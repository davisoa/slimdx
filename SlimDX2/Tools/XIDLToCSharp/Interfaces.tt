<#@ template debug="true" language="C#" hostspecific="True"  #>
<#@ output encoding="ASCII" extension=".cs" #>
<#@ assembly name="XIDLToCSharp.exe" #>
<#@ assembly name="SlimDX2.Tools.XIDL.dll" #>
<#@ import namespace="SlimDX2.Tools.XIDLToCSharp" #>
<#@ import namespace="SlimDX2.Tools.XIDL" #>
<#@ parameter name="Namespace" type="SlimDX2.Tools.XIDLToCSharp.CSharpNamespace" #>
// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Interfaces for <#= Namespace.Name #> namespace.
//     This code was generated by a tool.
//     Date : <#=  DateTime.Now #>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace <#= Namespace.Name #> {

<#
foreach (var sharpInterface in Namespace.Interfaces)
{
	ProcessInterface(sharpInterface);
}
#>
}
<#+
	public void ProcessInterface(CSharpInterface sharpInterface) {
#>
    
<#+	

	if (sharpInterface.ParentContainer is CSharpInterface) {
#>    /// <summary>Inner interface <#= sharpInterface.Name #>.</summary>
<#+
	} else {
		foreach (var docItem in sharpInterface.DocItems) {
#>
    /// <#= docItem #>	
<#+			
		}
	}
#>
    /// <unmanaged><#= sharpInterface.CppElementName #></unmanaged>
<#+	
	if (sharpInterface.Guid != null) {
#>
    [Guid("<#= sharpInterface.Guid #>")]
<#+	
	}
	
	// If Callback, then declare as interface
	if (sharpInterface.IsCallback) {
#>    <#= sharpInterface.VisibilityName #>partial interface <#= sharpInterface.Name #><#+	
	} else {
#>    <#= sharpInterface.VisibilityName #>partial class <#= sharpInterface.Name #><#+	
	}
	
	// Is there any Parent?
	if (sharpInterface.Parent != null || sharpInterface.IParent != null) {
#> : <#+	
		string separator = "";
		if (sharpInterface.Parent != null) {
#><#= sharpInterface.Parent.FullName #><#+
			separator = ", ";
		}		
		if (sharpInterface.IParent != null) {
#><#= separator #><#= sharpInterface.IParent.FullName #><#+
		}
	}
#> {
<#+
	if (!sharpInterface.IsCallback) {#>
        public <#= sharpInterface.Name #>(IntPtr basePtr) : base(basePtr) {
        }
<#+
	}
#>
        
<#+

	// --------------------------------------------------------------------------------------------------
	// Handle Inner Interfaces
	// --------------------------------------------------------------------------------------------------
	if (sharpInterface.HasInnerInterfaces) {
	
#>				
        /// <summary>Update nested inner interfaces pointer</summary>
        protected override void NativePointerUpdated()
        {            
<#+
		// Include Inner structure
		foreach (var innerInterface in sharpInterface.InnerInterfaces) {
#>            <#= innerInterface.PropertyAccesName #> = new <#= innerInterface.FullName #>(this.NativePointer);		
<#+		
		}
#>        }
<#+
		
		// Include Inner structure
		foreach (var innerInterface in sharpInterface.InnerInterfaces) {
#>      
		/// <summary>Inner interface giving access to <#= innerInterface.Name #> methods. </summary>
        public <#= innerInterface.Name #> <#= innerInterface.PropertyAccesName #> { get; private set; }		
<#+		
			PushIndent("    ");		
			ProcessInterface(innerInterface);			
			PopIndent();
		}
	}
	
	
	// ------------------------------------------------------------------------------------------------------------
	// Output Properties
	// ------------------------------------------------------------------------------------------------------------
	foreach (var sharpProperty in sharpInterface.Properties) {				
#>
        
<#+	
		foreach (var docItem in sharpProperty.DocItems) {
#>
        /// <#= docItem #>	
<#+			
		}		
#>
        /// <unmanaged><#= sharpProperty.Getter.CppSignature #></unmanaged>
        <#= sharpProperty.VisibilityName #><#= sharpProperty.PublicType.FullName #> <#= sharpProperty.Name #> {
<#+		if (sharpProperty.IsPropertyParam) {
#>
                get { <#= sharpProperty.PublicType.FullName #> __output__; <#= sharpProperty.Getter.Name #>(out __output__); return __output__; }
<#+		
			if (sharpProperty.Setter != null) {
#>
                set { <#= sharpProperty.Setter.Name #>(<#= sharpProperty.PrefixSetterParam #>value); }
<#+		
			}
		} else {
#>
                get { return <#= sharpProperty.Getter.Name #>(); }
<#+		
			if (sharpProperty.Setter != null) {
#>
                set { <#= sharpProperty.Setter.Name #>(value); }
<#+		
			}
		}
#>        }
<#+		
	}
		
	// ------------------------------------------------------------------------------------------------------------
	// Output methods
	// ------------------------------------------------------------------------------------------------------------
	foreach (var sharpInterfaceMethod in sharpInterface.Methods) {				
#>
        
<#+	
		foreach (var docItem in sharpInterfaceMethod.DocItems) {
#>
        /// <#= docItem #>	
<#+			
		}
		foreach (var param in sharpInterfaceMethod.Parameters) {
#>
        /// <param name="<#= param.Name #>"><#= param.SingleDoc #></param>
<#+			
		}
		if (sharpInterfaceMethod.HasReturnType) {
#>
        /// <returns><#= sharpInterfaceMethod.ReturnType.SingleDoc #></returns>
<#+			
		}
#>
        /// <unmanaged><#= sharpInterfaceMethod.CppSignature #></unmanaged>
<#+ 
		if (sharpInterface.IsCallback) {
        	#>        /* <#+
		} else {
        	#>        <#+
		}
		#><#= sharpInterfaceMethod.VisibilityName #><#= sharpInterfaceMethod.ReturnType.PublicType.FullName #> <#= sharpInterfaceMethod.Name #>(<#+
		int i = 0;
		int maxParam = sharpInterfaceMethod.ParameterCount;
		foreach (var param in sharpInterfaceMethod.Parameters) {
			#><#= param.ParamName #><#+				
			if ((i+1)<maxParam) {#>, <#+}
			i++;
		}
#>)<#+
		if (sharpInterface.IsCallback) {
			#> */

<#+
        	continue;
		}
		// Else Open Body
#> {
            unsafe {
<#+			
				// ---------------------------------------------------------------------------------------------------
				// Start Initializing Parameters out
				// ---------------------------------------------------------------------------------------------------
				foreach (var param in sharpInterfaceMethod.Parameters) {
					// Handle In-Optional
					if (param.IsArray && param.IsValueType && !param.HasNativeValueType) {
						if (param.IsOptionnal) {#>
                <#= param.PublicType.FullName #>[] <#= param.TempName #>_ = <#= param.Name #> ?? new <#= param.PublicType.FullName #>[1];
<#+						} 
						continue;
					}						
					// Does the structure has a Native marshalling?
					if (param.HasNativeValueType) {
						// If Native Marshalling and array, then marshall from managed array to a native managed array
						if (param.IsArray) {#>
                <#= param.PublicType.FullName #>.__Native[] <#= param.TempName #>_ = new <#= param.PublicType.FullName #>.__Native[<#= param.Name #>.Length];
<#+							if (param.IsRefIn) {#>
                for (int i = 0; i < <#= param.Name #>.Length; i++)
                    <#= param.Name #>[i].__MarshalTo(ref <#= param.TempName #>_[i]);				
<#+							}
						} else {#>
                <#= param.PublicType.FullName #>.__Native <#= param.TempName #> = new <#= param.PublicType.FullName #>.__Native();
<#+							if (param.IsRefIn && param.HasNativeValueType) {#>
                <#= param.Name #>.__MarshalTo(ref <#= param.TempName #>);
<#+							}
						}						
					} else if (param.IsOut) {
						if (param.IsValueType && !param.IsPrimitive) {#>
                <#= param.Name #> = new <#= param.PublicType.FullName #>();
<#+						} else if (param.PublicType is CSharpInterface) {
							if (param.IsArray) {#>
                IntPtr* <#= param.TempName #> = stackalloc IntPtr[<#= param.Name #>.Length];
<#+	
							} else {#>
                IntPtr <#= param.TempName #> = IntPtr.Zero;
<#+
							}
						}
					} else if (param.IsArray) {
						// Handle Array Of Interface [In]
						if (param.PublicType is CSharpInterface) {
							if (param.IsIn && param.IsOptionnal) {#>
                IntPtr* <#= param.TempName #> = (IntPtr*)0;
                if ( <#= param.Name #> != null ) {
                    IntPtr* <#= param.TempName #>_ = stackalloc IntPtr[<#= param.Name #>.Length];
                    <#= param.TempName #> = <#= param.TempName #>_;
                    for (int i = 0; i < <#= param.Name #>.Length; i++)                        
                        <#= param.TempName #>[i] =  <#= param.Name #>[i].NativePointer;
                }
<#+									
							} else {#>
                IntPtr* <#= param.TempName #> = stackalloc IntPtr[<#= param.Name #>.Length];
<#+								if (param.IsIn) {#>
                for (int i = 0; i < <#= param.Name #>.Length; i++)
                    <#= param.TempName #>[i] =  <#= param.Name #>[i].NativePointer;				
<#+								}
							}
						}
					// Handle Input String 
					} else if (param.IsString) {
						if (param.IsWideChar) {#>
                IntPtr <#= param.TempName #> = Marshal.StringToHGlobalUni(<#= param.Name #>);
<#+						} else {#>
                IntPtr <#= param.TempName #> = Marshal.StringToHGlobalAnsi(<#= param.Name #>);
<#+						}						
					} else if ( param.IsRefIn && param.IsValueType && param.IsOptionnal) {#>
                <#= param.PublicType.FullName #> <#= param.TempName #>;
                if (<#= param.Name #>.HasValue)
                    <#= param.TempName #> = <#= param.Name #>.Value;				
<#+						
					}

				} 
				// End Of initializing parameter out
				// ---------------------------------------------------------------------------------------------------
				
				// ---------------------------------------------------------------------------------------------------
				// Pre-Declare Return Type
				// ---------------------------------------------------------------------------------------------------
				if (sharpInterfaceMethod.HasReturnType) {#>
                <#= sharpInterfaceMethod.ReturnType.PublicType.FullName #> __result__;
<#+				}
				
				// ---------------------------------------------------------------------------------------------------
				// Handle fixed parameters
				// ---------------------------------------------------------------------------------------------------
				foreach (var param in sharpInterfaceMethod.Parameters) {
					if (param.IsArray && param.IsValueType) {
						if (param.HasNativeValueType || param.IsOptionnal) {#>
                fixed (void* <#= param.TempName #> = &<#= param.TempName #>_[0])
<#+	
						} else {#>
                fixed (void* <#= param.TempName #> = &<#= param.Name #>[0])
<#+						}						
						PushIndent("    ");
					} else if (param.IsFixed && param.IsValueType && !param.HasNativeValueType) {#>
                fixed (void* <#= param.TempName #> = &<#= param.Name #>)
<#+	
						PushIndent("    ");
					} 
				}

				// ---------------------------------------------------------------------------------------------------
				// Perform method call to Interop.Calli*
				// ---------------------------------------------------------------------------------------------------
				if (sharpInterfaceMethod.HasReturnType && !sharpInterfaceMethod.IsReturnStruct) {#>
                __result__= (<#= sharpInterfaceMethod.ReturnType.PublicType.FullName #>)<#+
				} else {
#>                <#+
				}
#><#= sharpInterfaceMethod.CastStart #><#= sharpInterfaceMethod.Assembly.FullName #>.LocalInterop.<#= sharpInterfaceMethod.Interop.Name #>(_nativePointer, <#= sharpInterfaceMethod.Offset #> * 4<#+
				if (sharpInterfaceMethod.IsReturnStruct) {#>,(void*)&__result__<#+}				
				i = 0;
				maxParam = sharpInterfaceMethod.ParameterCount;
				if (maxParam > 0) {#>, <#+}
				foreach (var param in sharpInterfaceMethod.Parameters) {
					#><#= param.CallName #><#+				
					if ((i+1)<maxParam) {#>, <#+}
					i++;
				}
				#>)<#= sharpInterfaceMethod.CastEnd #>;
<#+

				// ---------------------------------------------------------------------------------------------------
				// Unindent fixed parameters
				// ---------------------------------------------------------------------------------------------------
				foreach (var param in sharpInterfaceMethod.Parameters) {
					if ((param.IsArray && param.IsValueType) || (param.IsFixed && param.IsValueType && !param.HasNativeValueType)) 
						PopIndent();
				}				
				
				// ---------------------------------------------------------------------------------------------------
				// Post process on output parameters and free on Native input parameters
				// ---------------------------------------------------------------------------------------------------
				foreach (var param in sharpInterfaceMethod.Parameters) {
					if (param.IsOut) {
						if (param.HasNativeValueType) {
								if (param.IsArray) {#>
                for (int i = 0; i < <#= param.Name #>.Length; i++)
                    <#= param.Name #>[i].__MarshalFrom(ref <#= param.TempName #>_[i]);				
<#+								} else {#>
                <#= param.Name #> = new <#= param.PublicType.FullName #>();
                <#= param.Name #>.__MarshalFrom(ref <#= param.TempName #>);
<#+								}
						} else if (param.PublicType is CSharpInterface ) {
							var paramInterface = param.PublicType as CSharpInterface;
							if (param.IsArray) {#>
                for (int i = 0; i < <#= param.Name #>.Length; i++)
                    <#= param.Name #>[i] = (<#= param.TempName #>[i] == IntPtr.Zero)?null:new <#= paramInterface.DefaultImplem.FullName #>(<#= param.TempName #>[i]);	
<#+	
							} else {#>
                <#= param.Name #> = (<#= param.TempName #> == IntPtr.Zero)?null:new <#= paramInterface.DefaultImplem.FullName #>(<#= param.TempName #>);	
<#+
							}
						}
					// Handle Input String 
					} else if (param.IsString) {#>
                Marshal.FreeHGlobal(<#= param.TempName #> );
<#+						
					} else if (param.HasNativeValueType) {
						if (param.IsArray) {#>
                for (int i = 0; i < <#= param.Name #>.Length; i++)
                    <#= param.TempName #>_[i].__MarshalFree();				
<#+						} else {
#>                <#= param.TempName #>.__MarshalFree();
<#+						}
					}
				}

				// ---------------------------------------------------------------------------------------------------
				// Return value if any
				// ---------------------------------------------------------------------------------------------------
				if (sharpInterfaceMethod.HasReturnType) {
					if (sharpInterfaceMethod.ReturnType.PublicType.Name == Global.Name +".Result") {#>
                __result__.CheckError();
                return __result__;
<#+					} else {#>
                return __result__;
<#+					}
				}
#>            }
        }
<#+
	}
#>
    }
<#+
    } // End of ProcessInterface
#>

