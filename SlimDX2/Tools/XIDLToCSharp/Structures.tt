<#@ template debug="true" language="C#" hostspecific="True"  #>
<#@ output encoding="ASCII" extension=".cs" #>
<#@ assembly name="XIDLToCSharp.exe" #>
<#@ assembly name="SlimDX2.Tools.XIDL.dll" #>
<#@ import namespace="SlimDX2.Tools.XIDLToCSharp" #>
<#@ import namespace="SlimDX2.Tools.XIDL" #>
<#@ parameter name="Namespace" type="SlimDX2.Tools.XIDLToCSharp.CSharpNamespace" #>
// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Structs for <#= Namespace.Name #> namespace.
//     This code was generated by a tool.
//     Date : <#=  DateTime.Now #>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace <#= Namespace.Name #> {

<#
foreach (var sharpStruct in Namespace.Structs)
{
	ProcessStruct(sharpStruct);
}
#>
}
<#+
	public void ProcessStruct(CSharpStruct sharpStruct) {
#>
    
<#+	
	foreach (var docItem in sharpStruct.DocItems) {
#>
    /// <#= docItem #>	
<#+			
	}#>
    /// <unmanaged><#= sharpStruct.CppElementName #></unmanaged>
<#+	
	if (!sharpStruct.HasMarshalType) {
		if (sharpStruct.ExplicitLayout) {#>
    [StructLayout(LayoutKind.Explicit, Pack = <#= sharpStruct.Pack #> )]
<#+ 
		} else { 
#>
    [StructLayout(LayoutKind.Sequential, Pack = <#= sharpStruct.Pack #> )]
<#+  
		} 
	}
#>
    <#= sharpStruct.VisibilityName #> partial struct <#= sharpStruct.Name #> {	
<#+	
	// Include Inner structure
	foreach (var innerStruct in sharpStruct.InnerStructs) {
		PushIndent("    ");
		ProcessStruct(innerStruct);			
		PopIndent();
	}
	
	foreach (var sharpStructItem in sharpStruct.Fields) {				
#>
        
<#+	
		foreach (var docItem in sharpStructItem.DocItems) {
#>
        /// <#= docItem #>	
<#+			
		}
#>
        /// <unmanaged><#= sharpStructItem.CppElement.ToString() #></unmanaged>
<#+
		if (sharpStructItem.PublicType.FullName == "bool") {
#>
        <#= sharpStructItem.VisibilityName #>bool <#= sharpStructItem.Name #> { 
            get { 
                return (_<#= sharpStructItem.Name #>!=0)?true:false; 
            }
            set { 
                _<#= sharpStructItem.Name #> = value?1:0;
            }
        }
<#+
			if (!sharpStruct.HasMarshalType  && sharpStruct.ExplicitLayout) {
#>
        [FieldOffset(<#= sharpStructItem.Offset #>)]
<#+			
			}		
#>        internal int _<#= sharpStructItem.Name #>;
<#+

			
		} else if (sharpStructItem.IsArray && sharpStructItem.PublicType.FullName != "string") {
#>
        <#= sharpStructItem.VisibilityName #><#= sharpStructItem.PublicType.FullName #>[] <#= sharpStructItem.Name #> { 
            get { 
                if (_<#= sharpStructItem.Name #> == null) {
                    _<#= sharpStructItem.Name #> = new <#= sharpStructItem.PublicType.FullName #>[<#= sharpStructItem.ArrayDimension #>];
                }
                return _<#= sharpStructItem.Name #>; 
            }
        }
<#+			if (!sharpStruct.HasMarshalType  && sharpStruct.ExplicitLayout) {
#>
        [FieldOffset(<#= sharpStructItem.Offset #>)]
<#+			
			}		
#>        internal <#= sharpStructItem.PublicType.FullName #>[] _<#= sharpStructItem.Name #>;
<#+
		} else {
			if (sharpStructItem.IsBitField) {
#>
        <#= sharpStructItem.VisibilityName #><#= sharpStructItem.PublicType.FullName #>  <#= sharpStructItem.Name #> { 
            get { 
                return (<#= sharpStructItem.PublicType.FullName #>)((_<#= sharpStructItem.Name #> >> <#= sharpStructItem.BitOffset #>) &  <#= sharpStructItem.BitMask #>);
            }
            set { 
                _<#= sharpStructItem.Name #> = (<#= sharpStructItem.PublicType.FullName #>)((_<#= sharpStructItem.Name #> & ~( <#= sharpStructItem.BitMask #> << <#= sharpStructItem.BitOffset #>)) | ( (value & <#= sharpStructItem.BitMask #>) << <#= sharpStructItem.BitOffset #>));
            }
        }
        [FieldOffset(<#= sharpStructItem.Offset #>)]
        internal <#= sharpStructItem.PublicType.FullName #> _<#= sharpStructItem.Name #>;
		
<#+				
			} else {
				if (!sharpStruct.HasMarshalType  && sharpStruct.ExplicitLayout) {
#>
        [FieldOffset(<#= sharpStructItem.Offset #>)]
<#+			
				}	
#>
        <#= sharpStructItem.VisibilityName #><#= sharpStructItem.PublicType.FullName #> <#= sharpStructItem.Name #>;
<#+
			}
		}
	}

	// Put Native internal struct
	if (sharpStruct.HasMarshalType) {
#>

        // Internal native struct used for marshalling
<#+
		if (sharpStruct.ExplicitLayout) {
#>
        [StructLayout(LayoutKind.Explicit, Pack = <#= sharpStruct.Pack #> )]
<#+  
		} else { 
#>
        [StructLayout(LayoutKind.Sequential, Pack = <#= sharpStruct.Pack #> )]
<#+ 
		} 		
#>
        internal unsafe partial struct __Native {	
<#+
	    foreach (var sharpStructItem in sharpStruct.Fields) {				

		    if (sharpStructItem.PublicType.FullName == "bool") {
#>
            public <#= sharpStructItem.MarshalType.FullName #> _<#= sharpStructItem.Name #>;
<#+			
			} else  if (sharpStructItem.IsArray) {
				if (sharpStructItem.MarshalType is CSharpStruct) {
#>
            public <#= sharpStructItem.MarshalType.FullName #> <#= sharpStructItem.Name #>;
<#+
					for(int i = 1; i < sharpStructItem.ArrayDimension; i++) {
#>
            <#= sharpStructItem.MarshalType.FullName #> __<#= sharpStructItem.Name #><#= i #>;
<#+
					}
				} else {
#>
            public fixed <#= sharpStructItem.MarshalType.FullName #> <#= sharpStructItem.Name #>[<#= sharpStructItem.ArrayDimension #>];
<#+
				}
		    } else {
#>
            public <#= sharpStructItem.MarshalType.FullName #> <#= sharpStructItem.Name #>;
<#+
		    }
	    }

		if (sharpStruct.IsOut) {
#>
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
<#+
	    	foreach (var sharpStructItem in sharpStruct.Fields) {			    
				if (!sharpStructItem.IsArray) {
					if (sharpStructItem.PublicType.FullName == "string") {
				// Copy string
#>
                if (this.<#= sharpStructItem.Name #> != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.<#= sharpStructItem.Name #>);		
<#+
		    		}
				}	    
			}
#>            }
<#+		}					
#>
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
<#+
		// Write code for Marshal from native struct
	    foreach (var sharpStructItem in sharpStruct.Fields) {				
		    if (sharpStructItem.PublicType.FullName == "bool") {
#>
            this._<#= sharpStructItem.Name #> = @ref._<#= sharpStructItem.Name #>;
<#+			
			} else  if (sharpStructItem.IsArray) {
				if (sharpStructItem.MarshalType is CSharpStruct) {
#>
            fixed (void* __to = &this.<#= sharpStructItem.Name #>[0]) fixed (void* __from = &@ref.<#= sharpStructItem.Name #>) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, <#= sharpStructItem.ArrayDimension #>*sizeof ( <#= sharpStructItem.MarshalType.FullName #>));
<#+
				} else {
					if (sharpStructItem.MarshalType.FullName == "char") {
#>
            fixed (char* __ptr = @ref.<#= sharpStructItem.Name #>) this.<#= sharpStructItem.Name #> = new string(__ptr, 0, <#= sharpStructItem.ArrayDimension #>);
<#+
					} else if (sharpStructItem.PublicType.FullName == "string" && sharpStructItem.MarshalType.FullName == "byte") {
#>
            fixed (void* __ptr = @ref.<#= sharpStructItem.Name #>) this.<#= sharpStructItem.Name #> = new string((sbyte*)__ptr, 0, <#= sharpStructItem.ArrayDimension #>);
<#+
					} else {
#>
            fixed (void* __to = &this.<#= sharpStructItem.Name #>[0]) fixed (void* __from = @ref.<#= sharpStructItem.Name #>) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, <#= sharpStructItem.ArrayDimension #>*sizeof ( <#= sharpStructItem.MarshalType.FullName #>));
<#+
					}
				}
		    } else {
					if (sharpStructItem.PublicType.FullName == "string") {
				// Copy string
#>
            this.<#= sharpStructItem.Name #> = ( @ref.<#= sharpStructItem.Name #> == IntPtr.Zero )?null:new string((sbyte*)@ref.<#= sharpStructItem.Name #>);
<#+
					} else {
				// Copy Default fields
#>
            this.<#= sharpStructItem.Name #> = @ref.<#= sharpStructItem.Name #>;
<#+
					}
		    }
	    }
#>
        }
<#+
		if (sharpStruct.IsOut) {
#>
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
<#+
		// Write code for Marshal to native struct
	    foreach (var sharpStructItem in sharpStruct.Fields) {				
		
		    if (sharpStructItem.PublicType.FullName == "bool") {
#>
            @ref._<#= sharpStructItem.Name #> = this._<#= sharpStructItem.Name #>;
<#+			
			} else  if (sharpStructItem.IsArray) {
				if (sharpStructItem.MarshalType is CSharpStruct) {
#>
            fixed (void* __to = &@ref.<#= sharpStructItem.Name #>) fixed (void* __from = &this.<#= sharpStructItem.Name #>[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, <#= sharpStructItem.ArrayDimension #>*sizeof ( <#= sharpStructItem.MarshalType.FullName #>));
<#+
				} else {
					if (sharpStructItem.MarshalType.FullName == "char") {
#>
            fixed (char* __psrc = this.<#= sharpStructItem.Name #>) fixed (char* __ptr = @ref.<#= sharpStructItem.Name #>) Utilities.CopyMemory((IntPtr)__ptr, (IntPtr)__psrc, <#= sharpStructItem.ArrayDimension #>);
<#+
					} else if (sharpStructItem.PublicType.FullName == "string" && sharpStructItem.MarshalType.FullName == "byte") {
#>
            IntPtr <#= sharpStructItem.Name #>_ = Marshal.StringToHGlobalAnsi(this.<#= sharpStructItem.Name #>);
            fixed (void* __ptr = @ref.<#= sharpStructItem.Name #>) Utilities.CopyMemory((IntPtr)__ptr, <#= sharpStructItem.Name #>_, this.<#= sharpStructItem.Name #>.Length);
            Marshal.FreeHGlobal( <#= sharpStructItem.Name #>_);
<#+
					} else {
#>
            fixed (void* __to = @ref.<#= sharpStructItem.Name #>) fixed (void* __from = &this.<#= sharpStructItem.Name #>[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, <#= sharpStructItem.ArrayDimension #>*sizeof ( <#= sharpStructItem.MarshalType.FullName #>));
<#+
					}
				}
		    } else {
					if (sharpStructItem.PublicType.FullName == "string") {
				// Copy string
#>
            @ref.<#= sharpStructItem.Name #> = ( this.<#= sharpStructItem.Name #> == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.<#= sharpStructItem.Name #>);
<#+
					} else {
				// Copy Default fields
#>
            @ref.<#= sharpStructItem.Name #> = this.<#= sharpStructItem.Name #>;
<#+
					}
		    }
	    }
#>		
		}
<#+
		}		
    }
#>
    }
<#+
}
#>
