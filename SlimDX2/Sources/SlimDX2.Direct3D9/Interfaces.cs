// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Interfaces for SlimDX2.Direct3D9 namespace.
//     This code was generated by a tool.
//     Date : 11/10/2010 17:02:17
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace SlimDX2.Direct3D9 {

    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3D9</unmanaged>
    [Guid("81BDCBCA-64D4-426d-AE8D-AD0147F4275C")]
    public partial class Direct3D : SlimDX2.ComObject {
        public Direct3D(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Returns the number of adapters on the system.	
        /// </summary>	
        /// <unmanaged>UINT IDirect3D9::GetAdapterCount()</unmanaged>
        public int AdapterCount {
                get { return GetAdapterCount(); }
        }
        
        /// <summary>	
        /// Registers a pluggable software device. Software devices provide software rasterization enabling applications to access a variety of software rasterizers.	
        /// </summary>	
        /// <remarks>	
        ///  If the user's computer provides no special hardware acceleration for 3D operations, your application might emulate 3D hardware in software. Software rasterization devices emulate the functions of color 3D hardware in software. A software device runs more slowly than a hal. However, software devices take advantage of any special instructions supported by the CPU to increase performance. Instruction sets include the AMD 3DNow! instruction set on some AMD processors and the MMX instruction set supported by many Intel processors. Direct3D uses the 3D-Now! instruction set to accelerate transformation and lighting operations and the MMX instruction set to accelerate rasterization. Software devices communicate with Direct3D through an interface similar to the hardware device driver interface (DDI). Software devices are loaded by the application and registered with the <see cref="SlimDX2.Direct3D9.Direct3D"/> object. Direct3D uses the software device for rendering.  The Direct3D Driver Development Kit (DDK) provides the documentation and headers for developing pluggable software devices. 	
        /// </remarks>	
        /// <param name="initializeFunctionRef"> Pointer to the initialization function for the software device to be registered.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL. The method call is invalid. For example, a method's parameter may have an invalid value: D3DERR_OUTOFVIDEOMEMORY.  </returns>
        /// <unmanaged>HRESULT IDirect3D9::RegisterSoftwareDevice([None] void* pInitializeFunction)</unmanaged>
        public SlimDX2.Result RegisterSoftwareDevice(IntPtr initializeFunctionRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, (void*)initializeFunctionRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns the number of adapters on the system.	
        /// </summary>	
        /// <returns>  {{UINT}}  A UINT value that denotes the number of adapters on the system at the time this <see cref="SlimDX2.Direct3D9.Direct3D"/> interface was instantiated. </returns>
        /// <unmanaged>UINT IDirect3D9::GetAdapterCount()</unmanaged>
        internal int GetAdapterCount() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Describes the physical display adapters present in the system when the <see cref="SlimDX2.Direct3D9.Direct3D"/> interface was instantiated.	
        /// </summary>	
        /// <param name="adapter"> Ordinal number that denotes the display adapter. D3DADAPTER_DEFAULT is always the primary display adapter. The minimum value for this parameter is 0, and the maximum value for this parameter is one less than the value returned by {{GetAdapterCount}}.  </param>
        /// <param name="flags"> Flags sets the WHQLLevel member of <see cref="SlimDX2.Direct3D9.AdapterDetails"/>. Flags can be set to either 0 or D3DENUM_WHQL_LEVEL. If D3DENUM_WHQL_LEVEL is specified, this call can connect to the Internet to download new Microsoft Windows Hardware Quality Labs (WHQL) certificates.  </param>
        /// <param name="identifierRef"> Pointer to a <see cref="SlimDX2.Direct3D9.AdapterDetails"/> structure to be filled with information describing this adapter. If Adapter is greater than or equal to the number of adapters in the system, this structure will be zeroed.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if Adapter is out of range, if Flags contains unrecognized parameters, or if pIdentifier is NULL or points to unwriteable memory. </returns>
        /// <unmanaged>HRESULT IDirect3D9::GetAdapterIdentifier([None] UINT Adapter,[None] int Flags,[Out] D3DADAPTER_IDENTIFIER9* pIdentifier)</unmanaged>
        public SlimDX2.Result GetAdapterIdentifier(int adapter, int flags, out SlimDX2.Direct3D9.AdapterDetails identifierRef) {
            unsafe {
                SlimDX2.Direct3D9.AdapterDetails.__Native identifierRef_ = new SlimDX2.Direct3D9.AdapterDetails.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, adapter, flags, &identifierRef_);
                identifierRef = new SlimDX2.Direct3D9.AdapterDetails();
                identifierRef.__MarshalFrom(ref identifierRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns the number of display modes available on this adapter.	
        /// </summary>	
        /// <param name="adapter"> Ordinal number that denotes the display adapter. D3DADAPTER_DEFAULT is always the primary display adapter.  </param>
        /// <param name="format"> Identifies the format of the surface type using <see cref="SlimDX2.Direct3D9.Format"/>. Use {{EnumAdapterModes}} to see the valid formats. </param>
        /// <returns>  {{UINT}}  This method returns the number of display modes on this adapter or zero if Adapter is greater than or equal to the number of adapters on the system. </returns>
        /// <unmanaged>UINT IDirect3D9::GetAdapterModeCount([None] UINT Adapter,[None] D3DFORMAT Format)</unmanaged>
        public int GetAdapterModeCount(int adapter, SlimDX2.Direct3D9.Format format) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, adapter, unchecked((int)format));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Queries the device to determine whether the specified adapter supports the requested format and display mode. This method could be used in a loop to enumerate all the available adapter modes.	
        /// </summary>	
        /// <remarks>	
        ///  An application supplies a display mode and a format to EnumAdapterModes which returns a display mode. This method could be used in a loop to enumerate all available display modes. The application specifies a format and the enumeration is restricted to those display modes that exactly match the format (alpha is ignored). Allowed formats (which are members of <see cref="SlimDX2.Direct3D9.Format"/>) are as follows:  D3DFMT_A1R5G5B5 D3DFMT_A2R10G10B10 D3DFMT_A8R8G8B8 D3DFMT_R5G6B5 D3DFMT_X1R5G5B5 D3DFMT_X8R8G8B8  In addition, EnumAdapterModes treats pixel formats 565 and 555 as equivalent, and returns the correct version. The difference comes into play only when the application locks the back buffer and there is an explicit flag that the application must set in order to accomplish this. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number denoting the display adapter to enumerate. {{D3DADAPTER_DEFAULT}} is always the primary display adapter. This method returns D3DERR_INVALIDCALL when this value equals or exceeds the number of display adapters in the system.  </param>
        /// <param name="format"> Allowable pixel formats. See Remarks. </param>
        /// <param name="mode"> Represents the display-mode index which is an unsigned integer between zero and the value returned by {{GetAdapterModeCount}} minus one. </param>
        /// <param name="modeRef"> A pointer to the available display mode of type <see cref="SlimDX2.Direct3D9.DisplayMode"/>. See Remarks. </param>
        /// <returns>  <see cref="int"/>   If the device can be used on this adapter, D3D_OK is returned. If the Adapter equals or exceeds the number of display adapters in the system, D3DERR_INVALIDCALL is returned. If either surface format is not supported or if hardware acceleration is not available for the specified formats, D3DERR_NOTAVAILABLE is returned.  </returns>
        /// <unmanaged>HRESULT IDirect3D9::EnumAdapterModes([None] UINT Adapter,[None] D3DFORMAT Format,[None] UINT Mode,[None] D3DDISPLAYMODE* pMode)</unmanaged>
        public SlimDX2.Result EnumAdapterModes(int adapter, SlimDX2.Direct3D9.Format format, int mode, ref SlimDX2.Direct3D9.DisplayMode modeRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* modeRef_ = &modeRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, adapter, unchecked((int)format), mode, modeRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the current display mode of the adapter.	
        /// </summary>	
        /// <remarks>	
        ///  GetAdapterDisplayMode will not return the correct format when the display is in an extended format, such as 2:10:10:10. Instead, it returns the format X8R8G8B8.  	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number that denotes the display adapter to query. D3DADAPTER_DEFAULT is always the primary display adapter.  </param>
        /// <param name="modeRef"> Pointer to a <see cref="SlimDX2.Direct3D9.DisplayMode"/> structure, to be filled with information describing the current adapter's mode.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK.   If Adapter is out of range or pMode is invalid, this method returns D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3D9::GetAdapterDisplayMode([None] UINT Adapter,[Out] D3DDISPLAYMODE* pMode)</unmanaged>
        public SlimDX2.Result GetAdapterDisplayMode(int adapter, out SlimDX2.Direct3D9.DisplayMode modeRef) {
            unsafe {
                modeRef = new SlimDX2.Direct3D9.DisplayMode();
                SlimDX2.Result __result__;
                fixed (void* modeRef_ = &modeRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, adapter, modeRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Verifies whether a hardware accelerated device type can be used on this adapter.	
        /// </summary>	
        /// <remarks>	
        ///  A hal device type requires hardware acceleration. Applications can use CheckDeviceType to determine if the needed hardware and drivers are present to support a hal device.  Full-screen applications should not specify a DisplayFormat that contains an alpha channel. This will result in a failed call. Note that an alpha channel can be present in the back buffer but the two display formats must be identical in all other respects. For example, if DisplayFormat = D3DFMT_X1R5G5B5, valid values for BackBufferFormat include D3DFMT_X1R5G5B5 and D3DFMT_A1R5G5B5 but exclude D3DFMT_R5G6B5. The following code fragment shows how you could use CheckDeviceType to test whether a certain device type can be used on this adapter. 	
        /// <code> if(SUCCEEDED(pD3Device-&gt;CheckDeviceType(D3DADAPTER_DEFAULT,  D3DDEVTYPE_HAL,  DisplayFormat,  BackBufferFormat,  bIsWindowed))) return S_OK;	
        /// // There is no HAL on this adapter using this render-target format. 	
        /// // Try again, using another format. </code>	
        /// 	
        ///  This code returns S_OK if the device can be used on the default adapter with the specified surface format. Using CheckDeviceType to test for compatibility between a back buffer that differs from the display format will return appropriate values. This means that the call will reflect device capabilities. If the device cannot render to the requested back-buffer format, the call will still return D3DERR_NOTAVAILABLE. If the device can render to the format, but cannot perform the color-converting presentation, the return value will also be D3DERR_NOTAVAILABLE. Applications can discover hardware support for the presentation itself by calling {{CheckDeviceFormatConversion}}. No software emulation for the color-converting presentation itself will be offered. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number denoting the display adapter to enumerate. D3DADAPTER_DEFAULT is always the primary display adapter. This method returns D3DERR_INVALIDCALL when this value equals or exceeds the number of display adapters in the system.  </param>
        /// <param name="devType"> Member of the <see cref="SlimDX2.Direct3D9.DeviceType"/> enumerated type, indicating the device type to check.  </param>
        /// <param name="adapterFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, indicating the format of the adapter display mode for which the device type is to be checked. For example, some devices will operate only in 16-bits-per-pixel modes.  </param>
        /// <param name="backBufferFormat"> Back buffer format. For more information about formats, see <see cref="SlimDX2.Direct3D9.Format"/>. This value must be one of the render-target formats. You can use {{GetDisplayMode}} to obtain the current format. For windowed applications, the back buffer format does not need to match the display mode format if the hardware supports color conversion. The set of possible back buffer formats is constrained, but the runtime will allow any valid back buffer format to be presented to any desktop format. There is the additional requirement that the device be operable in the desktop mode because devices typically do not operate in 8 bits per pixel modes. Full-screen applications cannot do color conversion. D3DFMT_UNKNOWN is allowed for windowed mode.  </param>
        /// <param name="bWindowed"> Value indicating whether the device type will be used in full-screen or windowed mode. If set to TRUE, the query is performed for windowed applications; otherwise, this value should be set FALSE.  </param>
        /// <returns>  <see cref="int"/>  If the device can be used on this adapter, D3D_OK is returned. D3DERR_INVALIDCALL is returned if Adapter equals or exceeds the number of display adapters in the system. D3DERR_INVALIDCALL is also returned if CheckDeviceType specified a device that does not exist. D3DERR_NOTAVAILABLE is returned if the requested back buffer format is not supported, or if hardware acceleration is not available for the specified formats.  </returns>
        /// <unmanaged>HRESULT IDirect3D9::CheckDeviceType([None] UINT Adapter,[None] D3DDEVTYPE DevType,[None] D3DFORMAT AdapterFormat,[None] D3DFORMAT BackBufferFormat,[None] BOOL bWindowed)</unmanaged>
        public SlimDX2.Result CheckDeviceType(int adapter, SlimDX2.Direct3D9.DeviceType devType, SlimDX2.Direct3D9.Format adapterFormat, SlimDX2.Direct3D9.Format backBufferFormat, bool bWindowed) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, adapter, unchecked((int)devType), unchecked((int)adapterFormat), unchecked((int)backBufferFormat), (bWindowed?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Determines whether a surface format is available as a specified resource type and can be used as a texture, depth-stencil buffer, or render target, or any combination of the three, on a device representing this adapter.	
        /// </summary>	
        /// <remarks>	
        ///  Here are some examples using CheckDeviceFormat to check for hardware support of:  An off-screen plain surface format - Specify Usage = 0 and RType = D3DRTYPE_SURFACE. A depth-stencil format - The following snippet tests for the passed in depth-stencil format: 	
        /// <code> BOOL IsDepthFormatExisting( D3DFORMAT DepthFormat, D3DFORMAT AdapterFormat ) 	
        /// { HRESULT hr = pD3D-&gt;CheckDeviceFormat( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, AdapterFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, DepthFormat); return SUCCEEDED( hr );	
        /// } </code>	
        /// 	
        ///  See {{Selecting a Device (Direct3D 9)}} for more detail on the enumeration process.  Can this texture be rendered in a particular format - Given the current display mode, this example shows how to verify that the texture format is compatible with the specific back-buffer format: 	
        /// <code> BOOL IsTextureFormatOk( D3DFORMAT TextureFormat, D3DFORMAT AdapterFormat ) 	
        /// { HRESULT hr = pD3D-&gt;CheckDeviceFormat( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, AdapterFormat, 0, D3DRTYPE_TEXTURE, TextureFormat); return SUCCEEDED( hr );	
        /// } </code>	
        /// 	
        ///   Alpha blending in a pixel shader - Set Usage to <see cref="SlimDX2.Direct3D9.Usage.QueryPostPixelShaderBlending"/>. Expect this to fail for all floating-point render targets. Autogeneration of mipmaps - Set Usage to <see cref="SlimDX2.Direct3D9.Usage.AutoGenerateMipMap"/>. If the mipmap automatic generation fails, the application will get a non-mipmapped texture. Calling this method is considered a hint, so this method can return D3DOK_NOAUTOGEN (a valid success code) if the only thing that fails is the mipmap generation. For more information about mipmap generation, see {{Automatic Generation of Mipmaps (Direct3D 9)}}.  When migrating code from Direct3D 9 to Direct3D 10, the Direct3D 10 equivalent to CheckDeviceFormat is {{CheckFormatSupport}}. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number denoting the display adapter to query. {{D3DADAPTER_DEFAULT}} is always the primary display adapter. This method returns D3DERR_INVALIDCALL when this value equals or exceeds the number of display adapters in the system.  </param>
        /// <param name="deviceType"> Member of the <see cref="SlimDX2.Direct3D9.DeviceType"/> enumerated type, identifying the device type. </param>
        /// <param name="adapterFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, identifying the format of the display mode into which the adapter will be placed. </param>
        /// <param name="usage"> Requested usage options for the surface. Usage options are any combination of <see cref="SlimDX2.Direct3D9.Usage"/> and {{D3DUSAGE_QUERY}} constants (only a subset of the D3DUSAGE constants are valid for CheckDeviceFormat; see the table on the D3DUSAGE page). </param>
        /// <param name="rType"> Resource type requested for use with the queried format. Member of <see cref="SlimDX2.Direct3D9.ResourceType"/>.  </param>
        /// <param name="checkFormat"> Format of the surfaces which may be used, as defined by Usage. Member of <see cref="SlimDX2.Direct3D9.Format"/>. </param>
        /// <returns>  <see cref="int"/>  If the format is compatible with the specified device for the requested usage, this method returns D3D_OK. D3DERR_INVALIDCALL is returned if Adapter equals or exceeds the number of display adapters in the system, or if DeviceType is unsupported. D3DERR_NOTAVAILABLE is returned if the format is not acceptable to the device for this usage. </returns>
        /// <unmanaged>HRESULT IDirect3D9::CheckDeviceFormat([None] UINT Adapter,[None] D3DDEVTYPE DeviceType,[None] D3DFORMAT AdapterFormat,[None] int Usage,[None] D3DRESOURCETYPE RType,[None] D3DFORMAT CheckFormat)</unmanaged>
        public SlimDX2.Result CheckDeviceFormat(int adapter, SlimDX2.Direct3D9.DeviceType deviceType, SlimDX2.Direct3D9.Format adapterFormat, int usage, SlimDX2.Direct3D9.ResourceType rType, SlimDX2.Direct3D9.Format checkFormat) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, adapter, unchecked((int)deviceType), unchecked((int)adapterFormat), usage, unchecked((int)rType), unchecked((int)checkFormat));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Determines if a multisampling technique is available on this device.	
        /// </summary>	
        /// <remarks>	
        ///  This method is intended for use with both render-target and depth-stencil surfaces because you must create both surfaces multisampled if you want to use them together. The following code fragment shows how you could use CheckDeviceMultiSampleType to test for devices that support a specific multisampling method. 	
        /// <code> if( SUCCEEDED(pD3D-&gt;CheckDeviceMultiSampleType( pCaps-&gt;AdapterOrdinal,  pCaps-&gt;DeviceType, BackBufferFormat,  FALSE, D3DMULTISAMPLE_3_SAMPLES, NULL ) ) &amp;&amp; SUCCEEDED(pD3D-&gt;CheckDeviceMultiSampleType( pCaps-&gt;AdapterOrdinal,  pCaps-&gt;DeviceType, DepthBufferFormat,  FALSE, D3DMULTISAMPLE_3_SAMPLES, NULL ) ) ) return S_OK; </code>	
        /// 	
        ///  The preceding code will return S_OK if the device supports the full-screen D3DMULTISAMPLE_3_SAMPLES multisampling method with the surface format. See the remarks in <see cref="SlimDX2.Direct3D9.MultisampleType"/> for additional information on working with and setting multisample types and quality levels. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number denoting the display adapter to query. D3DADAPTER_DEFAULT is always the primary display adapter. This method returns FALSE when this value equals or exceeds the number of display adapters in the system. See Remarks. </param>
        /// <param name="deviceType"> Member of the <see cref="SlimDX2.Direct3D9.DeviceType"/> enumerated type, identifying the device type. </param>
        /// <param name="surfaceFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type that specifies the format of the surface to be multisampled. For more information, see Remarks. </param>
        /// <param name="windowed"> bool value. Specify TRUE to inquire about windowed multisampling, and specify FALSE to inquire about full-screen multisampling. </param>
        /// <param name="multiSampleType"> Member of the <see cref="SlimDX2.Direct3D9.MultisampleType"/> enumerated type, identifying the multisampling technique to test. </param>
        /// <param name="qualityLevelsRef"> pQualityLevels returns the number of device-specific sampling variations available with the given sample type. For example, if the returned value is 3, then quality levels 0, 1 and 2 can be used when creating resources with the given sample count. The meanings of these quality levels are defined by the device manufacturer and cannot be queried through D3D. For example, for a particular device different quality levels at a fixed sample count might refer to different spatial layouts of the sample locations or different methods of resolving.  This can be NULL if it is not necessary to return the quality levels. </param>
        /// <returns>  <see cref="int"/>  If the device can perform the specified multisampling method, this method returns D3D_OK. D3DERR_INVALIDCALL is returned if the Adapter or MultiSampleType parameters are invalid. This method returns D3DERR_NOTAVAILABLE if the queried multisampling technique is not supported by this device. D3DERR_INVALIDDEVICE is returned if DeviceType does not apply to this adapter.  </returns>
        /// <unmanaged>HRESULT IDirect3D9::CheckDeviceMultiSampleType([None] UINT Adapter,[None] D3DDEVTYPE DeviceType,[None] D3DFORMAT SurfaceFormat,[None] BOOL Windowed,[None] D3DMULTISAMPLE_TYPE MultiSampleType,[None] int* pQualityLevels)</unmanaged>
        public SlimDX2.Result CheckDeviceMultiSampleType(int adapter, SlimDX2.Direct3D9.DeviceType deviceType, SlimDX2.Direct3D9.Format surfaceFormat, bool windowed, SlimDX2.Direct3D9.MultisampleType multiSampleType, ref int qualityLevelsRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* qualityLevelsRef_ = &qualityLevelsRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, adapter, unchecked((int)deviceType), unchecked((int)surfaceFormat), (windowed?1:0), unchecked((int)multiSampleType), qualityLevelsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Determines whether a depth-stencil format is compatible with a render-target format in a particular display mode.	
        /// </summary>	
        /// <remarks>	
        ///  This method is provided to enable applications to work with hardware requiring that certain depth formats can only work with certain render-target formats. The behavior of this method has been changed for DirectX 8.1.  This method now pays attention to the D24x8 and D32 depth-stencil formats. The previous version assumed that these formats would always be usable with 32- or 16-bit render targets. This method will now return D3D_OK for these formats only if the device is capable of mixed-depth operations. The following code fragment shows how you could use {{CheckDeviceFormat}} to validate a depth stencil format. 	
        /// <code> BOOL IsDepthFormatOk(D3DFORMAT DepthFormat,  D3DFORMAT AdapterFormat,  D3DFORMAT BackBufferFormat)	
        /// { // Verify that the depth format exists HRESULT hr = pD3D-&gt;CheckDeviceFormat(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, AdapterFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, DepthFormat); if(FAILED(hr)) return FALSE; // Verify that the depth format is compatible hr = pD3D-&gt;CheckDepthStencilMatch(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, AdapterFormat, BackBufferFormat, DepthFormat); return SUCCEEDED(hr); } </code>	
        /// 	
        ///  The preceding call will return FALSE if DepthFormat cannot be used in conjunction with AdapterFormat and BackBufferFormat. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number denoting the display adapter to query. D3DADAPTER_DEFAULT is always the primary display adapter. </param>
        /// <param name="deviceType"> Member of the <see cref="SlimDX2.Direct3D9.DeviceType"/> enumerated type, identifying the device type. </param>
        /// <param name="adapterFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, identifying the format of the display mode into which the adapter will be placed.  </param>
        /// <param name="renderTargetFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, identifying the format of the render-target surface to be tested.  </param>
        /// <param name="depthStencilFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, identifying the format of the depth-stencil surface to be tested.  </param>
        /// <returns>  <see cref="int"/>  If the depth-stencil format is compatible with the render-target format in the display mode, this method returns D3D_OK. D3DERR_INVALIDCALL can be returned if one or more of the parameters is invalid. If a depth-stencil format is not compatible with the render target in the display mode, then this method returns D3DERR_NOTAVAILABLE. </returns>
        /// <unmanaged>HRESULT IDirect3D9::CheckDepthStencilMatch([None] UINT Adapter,[None] D3DDEVTYPE DeviceType,[None] D3DFORMAT AdapterFormat,[None] D3DFORMAT RenderTargetFormat,[None] D3DFORMAT DepthStencilFormat)</unmanaged>
        public SlimDX2.Result CheckDepthStencilMatch(int adapter, SlimDX2.Direct3D9.DeviceType deviceType, SlimDX2.Direct3D9.Format adapterFormat, SlimDX2.Direct3D9.Format renderTargetFormat, SlimDX2.Direct3D9.Format depthStencilFormat) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, adapter, unchecked((int)deviceType), unchecked((int)adapterFormat), unchecked((int)renderTargetFormat), unchecked((int)depthStencilFormat));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Tests the device to see if it supports conversion from one display format to another.	
        /// </summary>	
        /// <remarks>	
        ///  Using {{CheckDeviceType}} to test for compatibility between a back buffer that differs from the display format will return appropriate values. This means that the call will reflect device capabilities. If the device cannot render to the requested back buffer format, the call will still return D3DERR_NOTAVAILABLE. If the device can render to the format, but cannot perform the color-converting presentation, the return value will also be D3DERR_NOTAVAILABLE. Applications can discover hardware support for the presentation itself by calling CheckDeviceFormatConversion. No software emulation for the color-converting presentation itself will be offered. CheckDeviceFormatConversion can also be used to determine which combinations of source surface formats and destination surface formats are permissible in calls to {{StretchRect}}.  Color conversion is restricted to the following source and target formats.  The source format must be a FOURCC format or a valid back buffer format. For a list of these, see {{FourCC Formats}} and BackBuffer or Display Formats. The target format must be one of these unsigned formats:  D3DFMT_X1R5G5B5D3DFMT_A1R5G5B5D3DFMT_R5G6B5 D3DFMT_R8G8B8D3DFMT_X8R8G8B8D3DFMT_A8R8G8B8 D3DFMT_A2R10G10B10D3DFMT_A16B16G16R16D3DFMT_A2B10G10R10 D3DFMT_A8B8G8R8D3DFMT_X8B8G8R8D3DFMT_A16B16G16R16F D3DFMT_A32B32G32R32F  ?   	
        /// </remarks>	
        /// <param name="adapter"> Display adapter ordinal number. D3DADAPTER_DEFAULT is always the primary display adapter. This method returns D3DERR_INVALIDCALL when this value equals or exceeds the number of display adapters in the system.   </param>
        /// <param name="deviceType"> Device type. Member of the <see cref="SlimDX2.Direct3D9.DeviceType"/> enumerated type.  </param>
        /// <param name="sourceFormat"> Source adapter format. Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type. </param>
        /// <param name="targetFormat"> Target adapter format. Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value is D3DERR_INVALIDCALL. The method will return D3DERR_NOTAVAILABLE when the hardware does not support conversion between the two formats.  </returns>
        /// <unmanaged>HRESULT IDirect3D9::CheckDeviceFormatConversion([None] UINT Adapter,[None] D3DDEVTYPE DeviceType,[None] D3DFORMAT SourceFormat,[None] D3DFORMAT TargetFormat)</unmanaged>
        public SlimDX2.Result CheckDeviceFormatConversion(int adapter, SlimDX2.Direct3D9.DeviceType deviceType, SlimDX2.Direct3D9.Format sourceFormat, SlimDX2.Direct3D9.Format targetFormat) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, adapter, unchecked((int)deviceType), unchecked((int)sourceFormat), unchecked((int)targetFormat));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves device-specific information about a device. 	
        /// </summary>	
        /// <remarks>	
        ///  The application should not assume the persistence of vertex processing capabilities across Direct3D device objects. The particular capabilities that a physical device exposes may depend on parameters supplied to {{CreateDevice}}. For example, the capabilities may yield different vertex processing capabilities before and after creating a Direct3D Device Object with hardware vertex processing enabled. For more information see the description of <see cref="SlimDX2.Direct3D9.Capabilities"/>. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number that denotes the display adapter. D3DADAPTER_DEFAULT is always the primary display adapter.  </param>
        /// <param name="deviceType"> Member of the <see cref="SlimDX2.Direct3D9.DeviceType"/> enumerated type. Denotes the device type.  </param>
        /// <param name="capsRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Capabilities"/> structure to be filled with information describing the capabilities of the device.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_INVALIDDEVICE, D3DERR_OUTOFVIDEOMEMORY, and D3DERR_NOTAVAILABLE. </returns>
        /// <unmanaged>HRESULT IDirect3D9::GetDeviceCaps([None] UINT Adapter,[None] D3DDEVTYPE DeviceType,[Out] D3DCAPS9* pCaps)</unmanaged>
        public SlimDX2.Result GetDeviceCaps(int adapter, SlimDX2.Direct3D9.DeviceType deviceType, out SlimDX2.Direct3D9.Capabilities capsRef) {
            unsafe {
                capsRef = new SlimDX2.Direct3D9.Capabilities();
                SlimDX2.Result __result__;
                fixed (void* capsRef_ = &capsRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, adapter, unchecked((int)deviceType), capsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns the handle of the monitor associated with the Direct3D object.	
        /// </summary>	
        /// <remarks>	
        ///  As shown in the following code fragment, which illustrates how to obtain a handle to the monitor associated with a given device, use {{GetDirect3D}} to return the Direct3D enumerator from the device and use {{GetCreationParameters}} to retrieve the value for Adapter. 	
        /// <code> if( FAILED( pDevice-&gt;GetCreationParameters(  &amp;Parameters ) ) ) return D3DERR_INVALIDCALL; if( FAILED( pDevice-&gt;GetDirect3D(&amp;pD3D) ) ) return D3DERR_INVALIDCALL; hMonitor = pD3D-&gt;GetAdapterMonitor(Parameters.AdapterOrdinal); pD3D-&gt;Release(); </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number that denotes the display adapter. D3DADAPTER_DEFAULT is always the primary display adapter.  </param>
        /// <returns>  {{HMONITOR}}  Handle of the monitor associated with the Direct3D object. </returns>
        /// <unmanaged>HMONITOR IDirect3D9::GetAdapterMonitor([None] UINT Adapter)</unmanaged>
        public IntPtr GetAdapterMonitor(int adapter) {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 15 * 4, adapter);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a device to represent the display adapter.	
        /// </summary>	
        /// <remarks>	
        ///  This method returns a fully working device interface, set to the required display mode (or windowed), and allocated with the appropriate back buffers. To begin rendering, the application needs only to create and set a depth buffer (assuming EnableAutoDepthStencil is FALSE in <see cref="SlimDX2.Direct3D9.PresentParameters"/>). When you create a Direct3D device, you supply two different window parameters: a focus window (hFocusWindow) and a device window (the hDeviceWindow in <see cref="SlimDX2.Direct3D9.PresentParameters"/>). The purpose of each window is:  The focus window alerts Direct3D when an application switches from foreground mode to background mode (via Alt-Tab, a mouse click, or some other method). A single focus window is shared by each device created by an application. The device window determines the location and size of the back buffer on screen. This is used by Direct3D when the back buffer contents are copied to the front buffer during {{Present}}.  This method should not be run during the handling of WM_CREATE. An application should never pass a window handle to Direct3D while handling WM_CREATE.  Any call to create, release, or reset the device must be done using the same thread as the window procedure of the focus window. Note that D3DCREATE_HARDWARE_VERTEXPROCESSING, D3DCREATE_MIXED_VERTEXPROCESSING, and D3DCREATE_SOFTWARE_VERTEXPROCESSING are mutually exclusive flags, and at least one of these vertex processing flags must be specified when calling this method. Back buffers created as part of the device are only lockable if D3DPRESENTFLAG_LOCKABLE_BACKBUFFER is specified in the presentation parameters. (Multisampled back buffers and depth surfaces are never lockable.) The methods {{Reset}}, <see cref="SlimDX2.ComObject"/>, and {{TestCooperativeLevel}} must be called from the same thread that used this method to create a device. D3DFMT_UNKNOWN can be specified for the windowed mode back buffer format when calling CreateDevice, {{Reset}}, and {{CreateAdditionalSwapChain}}. This means the application does not have to query the current desktop format before calling CreateDevice for windowed mode. For full-screen mode, the back buffer format must be specified. If you attempt to create a device on a 0x0 sized window, CreateDevice will fail. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number that denotes the display adapter. {{D3DADAPTER_DEFAULT}} is always the primary display adapter.  </param>
        /// <param name="deviceType"> Member of the <see cref="SlimDX2.Direct3D9.DeviceType"/> enumerated type that denotes the desired device type. If the desired device type is not available, the method will fail.  </param>
        /// <param name="hFocusWindow"> The focus window alerts Direct3D when an application switches from foreground mode to background mode. See Remarks. 	   For full-screen mode, the window specified must be a top-level window. For windowed mode, this parameter may be NULL only if the hDeviceWindow member of pPresentationParameters is set to a valid, non-NULL value.  </param>
        /// <param name="behaviorFlags"> Combination of one or more options that control device creation. For more information, see {{D3DCREATE}}. </param>
        /// <param name="resentationParametersRef"> Pointer to a <see cref="SlimDX2.Direct3D9.PresentParameters"/> structure, describing the presentation parameters for the device to be created. If BehaviorFlags specifies <see cref="SlimDX2.Direct3D9.CreateFlags.AdapterGroupDevice"/>, pPresentationParameters is an array. Regardless of the number of heads that exist, only one depth/stencil surface is automatically created. For Windows 2000 and Windows XP, the full-screen device display refresh rate is set in the following order:   User-specified nonzero ForcedRefreshRate registry key, if supported by the device. Application-specified nonzero refresh rate value in the presentation parameter. Refresh rate of the latest desktop mode, if supported by the device. 75 hertz if supported by the device. 60 hertz if supported by the device. Device default.  An unsupported refresh rate will default to the closest supported refresh rate below it.  For example, if the application specifies 63 hertz, 60 hertz will be used. There are no supported refresh rates below 57 hertz. pPresentationParameters is both an input and an output parameter. Calling this method may change several members including:  If BackBufferCount, BackBufferWidth, and BackBufferHeight  are 0 before the method is called, they will be changed when the method returns. If BackBufferFormat equals <see cref="SlimDX2.Direct3D9.Format.Unknown"/> before the method is called, it will be changed when the method returns.  </param>
        /// <param name="returnedDeviceInterfaceRef"> Address of a pointer to the returned <see cref="SlimDX2.Direct3D9.Device"/> interface, which represents the created device.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_DEVICELOST, D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY. </returns>
        /// <unmanaged>HRESULT IDirect3D9::CreateDevice([None] UINT Adapter,[None] D3DDEVTYPE DeviceType,[None] HWND hFocusWindow,[None] int BehaviorFlags,[In, Buffer] D3DPRESENT_PARAMETERS* pPresentationParameters,[None] IDirect3DDevice9** ppReturnedDeviceInterface)</unmanaged>
        internal SlimDX2.Result CreateDevice(int adapter, SlimDX2.Direct3D9.DeviceType deviceType, IntPtr hFocusWindow, SlimDX2.Direct3D9.CreateFlags behaviorFlags, SlimDX2.Direct3D9.PresentParameters[] resentationParametersRef, out SlimDX2.Direct3D9.Device returnedDeviceInterfaceRef) {
            unsafe {
                IntPtr returnedDeviceInterfaceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* resentationParametersRef_ = &resentationParametersRef[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, adapter, unchecked((int)deviceType), (void*)hFocusWindow, unchecked((int)behaviorFlags), resentationParametersRef_, &returnedDeviceInterfaceRef_);
                returnedDeviceInterfaceRef = (returnedDeviceInterfaceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(returnedDeviceInterfaceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DDevice9</unmanaged>
    [Guid("D0223B96-BF7A-43fd-92BD-A43B0D82B9EB")]
    public partial class Device : SlimDX2.ComObject {
        public Device(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Returns an estimate of the amount of available texture memory.	
        /// </summary>	
        /// <remarks>	
        ///  The returned value is rounded to the nearest MB. This is done to reflect the fact that video memory estimates are never precise due to alignment and other issues that affect consumption by certain resources. Applications can use this value to make gross estimates of memory availability to make large-scale resource decisions such as how many levels of a mipmap to attempt to allocate, but applications cannot use this value to make small-scale decisions such as if there is enough memory left to allocate another resource. 	
        /// </remarks>	
        /// <unmanaged>UINT IDirect3DDevice9::GetAvailableTextureMem()</unmanaged>
        public int AvailableTextureMem {
                get { return GetAvailableTextureMem(); }
        }
        
        /// <summary>	
        /// Returns an interface to the instance of the Direct3D object that created the device.	
        /// </summary>	
        /// <remarks>	
        ///  Calling IDirect3DDevice9::GetDirect3D will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Direct3D"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3D9 interface results in a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetDirect3D([Out] IDirect3D9** ppD3D9)</unmanaged>
        public SlimDX2.Direct3D9.Direct3D Direct3D {
                get { SlimDX2.Direct3D9.Direct3D __output__; GetDirect3D(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the capabilities of the rendering device.	
        /// </summary>	
        /// <remarks>	
        ///  IDirect3DDevice9::GetDeviceCaps retrieves the software vertex pipeline capabilities when the device is being used in software vertex processing mode.   	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetDeviceCaps([Out] D3DCAPS9* pCaps)</unmanaged>
        public SlimDX2.Direct3D9.Capabilities DeviceCaps {
                get { SlimDX2.Direct3D9.Capabilities __output__; GetDeviceCaps(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the creation parameters of the device.	
        /// </summary>	
        /// <remarks>	
        ///  You can query the AdapterOrdinal member of the returned <see cref="SlimDX2.Direct3D9.CreationParameters"/> structure to retrieve the ordinal of the adapter represented by this device.  	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetCreationParameters([Out] D3DDEVICE_CREATION_PARAMETERS* pParameters)</unmanaged>
        public SlimDX2.Direct3D9.CreationParameters CreationParameters {
                get { SlimDX2.Direct3D9.CreationParameters __output__; GetCreationParameters(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the number of implicit swap chains.	
        /// </summary>	
        /// <remarks>	
        ///  Implicit swap chains are created by the device during <see cref="SlimDX2.Direct3D9.Direct3D.CreateDevice"/>. This method returns the number of swap chains created by CreateDevice.   An application may create additional swap chains using <see cref="SlimDX2.Direct3D9.Device.CreateAdditionalSwapChain"/>. 	
        /// </remarks>	
        /// <unmanaged>UINT IDirect3DDevice9::GetNumberOfSwapChains()</unmanaged>
        public int NumberOfSwapChains {
                get { return GetNumberOfSwapChains(); }
        }
        
        /// <summary>	
        /// This method allows the use of GDI dialog boxes in full-screen mode applications.	
        /// </summary>	
        /// <remarks>	
        ///  The GDI dialog boxes must be created as child to the device window. They should also be created within the same thread that created the device because this enables the parent window to manage redrawing the child window. The method has no effect for windowed mode applications, but this setting will be respected if the application resets the device into full-screen mode. If SetDialogBoxMode succeeds in a windowed mode application, any subsequent reset to full-screen mode will be checked against the restrictions listed above.  Also, SetDialogBoxMode causes all back buffers on the swap chain to be discarded, so an application is expected to refresh its content for all back buffers after this call. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetDialogBoxMode([None] BOOL bEnableDialogs)</unmanaged>
        public bool DialogBoxMode {
                set { SetDialogBoxMode(value); }
        }
        
        /// <summary>	
        /// Gets the depth-stencil surface owned by the Direct3DDevice object.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DSurface9 interface results in a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetDepthStencilSurface([Out] IDirect3DSurface9** ppZStencilSurface)</unmanaged>
        public SlimDX2.Direct3D9.Surface DepthStencilSurface {
                get { SlimDX2.Direct3D9.Surface __output__; GetDepthStencilSurface(out __output__); return __output__; }
                set { SetDepthStencilSurface(value); }
        }
        
        /// <summary>	
        /// Retrieves the viewport parameters currently set for the device.	
        /// </summary>	
        /// <remarks>	
        ///  Typically, methods that return state will not work on a device that is created using D3DCREATE_PUREDEVICE. This method however, will work even on a pure device. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetViewport([Out] D3DVIEWPORT9* pViewport)</unmanaged>
        public SlimDX2.Direct3D9.Viewport Viewport {
                get { SlimDX2.Direct3D9.Viewport __output__; GetViewport(out __output__); return __output__; }
                set { SetViewport(ref value); }
        }
        
        /// <summary>	
        /// Retrieves the current material properties for the device.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other values in {{D3DCREATE}}.  	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetMaterial([Out] D3DMATERIAL9* pMaterial)</unmanaged>
        public SlimDX2.Direct3D9.Material Material {
                get { SlimDX2.Direct3D9.Material __output__; GetMaterial(out __output__); return __output__; }
                set { SetMaterial(ref value); }
        }
        
        /// <summary>	
        /// Retrieves the clip status.	
        /// </summary>	
        /// <remarks>	
        ///  When clipping is enabled during vertex processing (by <see cref="SlimDX2.Direct3D9.Device.ProcessVertices"/>, <see cref="SlimDX2.Direct3D9.Device.DrawPrimitives"/>, or other drawing functions), Direct3D computes a clip code for every vertex. The clip code is a combination of D3DCS_* bits. When a vertex is outside a particular clipping plane, the corresponding bit is set in the clipping code. Direct3D maintains the clip status using <see cref="SlimDX2.Direct3D9.ClipStatus"/>, which has ClipUnion and ClipIntersection members. ClipUnion is a bitwise "OR" of all vertex clip codes and ClipIntersection is a bitwise "AND" of all vertex clip codes. Initial values are zero for ClipUnion and 0xFFFFFFFF for ClipIntersection. When D3DRS_CLIPPING is set to FALSE, ClipUnion and ClipIntersection are set to zero. Direct3D updates the clip status during drawing calls. To compute clip status for a particular object, set ClipUnion and ClipIntersection to their initial value and continue drawing. Clip status is not updated by <see cref="SlimDX2.Direct3D9.Device.DrawRectPatch"/> and <see cref="SlimDX2.Direct3D9.Device.DrawTriPatch"/> because there is no software emulation for them. Clip status is used during software vertex processing. Therefore, this method is not supported on pure or nonpure hardware processing devices. For more information about pure devices, see {{D3DCREATE}}. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetClipStatus([Out] D3DCLIPSTATUS9* pClipStatus)</unmanaged>
        public SlimDX2.Direct3D9.ClipStatus ClipStatus {
                get { SlimDX2.Direct3D9.ClipStatus __output__; GetClipStatus(out __output__); return __output__; }
                set { SetClipStatus(ref value); }
        }
        
        /// <summary>	
        /// Retrieves the current texture palette.	
        /// </summary>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetCurrentTexturePalette([Out] UINT* PaletteNumber)</unmanaged>
        public int CurrentTexturePalette {
                get { int __output__; GetCurrentTexturePalette(out __output__); return __output__; }
                set { SetCurrentTexturePalette(value); }
        }
        
        /// <summary>	
        /// Gets the scissor rectangle.	
        /// </summary>	
        /// <remarks>	
        ///  The scissor rectangle is used as a rectangular clipping region. See {{Rectangles (Direct3D 9)}} for further information on the use of rectangles in DirectX. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetScissorRect([Out] RECT* pRect)</unmanaged>
        public SlimDX2.Rectangle ScissorRect {
                get { SlimDX2.Rectangle __output__; GetScissorRect(out __output__); return __output__; }
                set { SetScissorRect(ref value); }
        }
        
        /// <summary>	
        /// Gets the vertex processing (hardware or software) mode.	
        /// </summary>	
        /// <remarks>	
        ///  An application can create a mixed-mode device to use both the software vertex processing and the hardware vertex processing. To switch between the two vertex processing modes in DirectX 8.x, use <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/> with the render state D3DRS_SOFTWAREVERTEXPROCESSING and the appropriate BOOL argument. The drawback of the render state approach was the difficulty in defining the semantics for state blocks. Applications and the runtime had to do extra work and be careful while recording and playing back state blocks. In Direct3D 9, use <see cref="SlimDX2.Direct3D9.Device.SetSoftwareVertexProcessing"/> instead. This new API is not recorded by StateBlocks. 	
        /// </remarks>	
        /// <unmanaged>BOOL IDirect3DDevice9::GetSoftwareVertexProcessing()</unmanaged>
        public bool SoftwareVertexProcessing {
                get { return GetSoftwareVertexProcessing(); }
                set { SetSoftwareVertexProcessing(value); }
        }
        
        /// <summary>	
        /// Gets the N-patch mode segments.	
        /// </summary>	
        /// <unmanaged>float IDirect3DDevice9::GetNPatchMode()</unmanaged>
        public float NPatchMode {
                get { return GetNPatchMode(); }
                set { SetNPatchMode(value); }
        }
        
        /// <summary>	
        /// Gets a vertex shader declaration.	
        /// </summary>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetVertexDeclaration([Out] IDirect3DVertexDeclaration9** ppDecl)</unmanaged>
        public SlimDX2.Direct3D9.VertexDeclaration VertexDeclaration {
                get { SlimDX2.Direct3D9.VertexDeclaration __output__; GetVertexDeclaration(out __output__); return __output__; }
                set { SetVertexDeclaration(value); }
        }
        
        /// <summary>	
        /// Gets the fixed vertex function declaration.	
        /// </summary>	
        /// <remarks>	
        ///  The fixed vertex function declaration is a set of FVF flags that determine how vertices processed by the fixed function pipeline will be used. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetFVF([Out] int* pFVF)</unmanaged>
        public SlimDX2.Direct3D9.VertexFormat VertexFormat {
                get { SlimDX2.Direct3D9.VertexFormat __output__; GetVertexFormat(out __output__); return __output__; }
                set { SetVertexFormat(value); }
        }
        
        /// <summary>	
        /// Retrieves the currently set vertex shader.	
        /// </summary>	
        /// <remarks>	
        ///  Typically, methods that return state will not work on a device that is created using D3DCREATE_PUREDEVICE. This method however, will work even on a pure device because it returns an interface. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetVertexShader([Out] IDirect3DVertexShader9** ppShader)</unmanaged>
        public SlimDX2.Direct3D9.VertexShader VertexShader {
                get { SlimDX2.Direct3D9.VertexShader __output__; GetVertexShader(out __output__); return __output__; }
                set { SetVertexShader(value); }
        }
        
        /// <summary>	
        /// Retrieves index data.	
        /// </summary>	
        /// <remarks>	
        ///   Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.IndexBuffer"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DIndexBuffer9 interface results in a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetIndices([Out] IDirect3DIndexBuffer9** ppIndexData)</unmanaged>
        public SlimDX2.Direct3D9.IndexBuffer Indices {
                get { SlimDX2.Direct3D9.IndexBuffer __output__; GetIndices(out __output__); return __output__; }
                set { SetIndices(value); }
        }
        
        /// <summary>	
        /// Retrieves the currently set pixel shader.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not work on a device that is created using D3DCREATE_PUREDEVICE. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetPixelShader([Out] IDirect3DPixelShader9** ppShader)</unmanaged>
        public SlimDX2.Direct3D9.PixelShader PixelShader {
                get { SlimDX2.Direct3D9.PixelShader __output__; GetPixelShader(out __output__); return __output__; }
                set { SetPixelShader(value); }
        }
        
        /// <summary>	
        /// Reports the current cooperative-level status of the Direct3D device for a windowed or full-screen application.	
        /// </summary>	
        /// <remarks>	
        ///  If the device is lost but cannot be restored at the current time, IDirect3DDevice9::TestCooperativeLevel returns the D3DERR_DEVICELOST return code. This would be the case, for example, when a full-screen device has lost focus. If an application detects a lost device, it should pause and periodically call IDirect3DDevice9::TestCooperativeLevel until it receives a return value of D3DERR_DEVICENOTRESET. The application may then attempt to reset the device by calling <see cref="SlimDX2.Direct3D9.Device.Reset"/> and, if this succeeds, restore the necessary resources and resume normal operation. Note that <see cref="SlimDX2.Direct3D9.Device.Present"/> will return D3DERR_DEVICELOST if the device is either "lost" or "not reset". A call to IDirect3DDevice9::TestCooperativeLevel will fail if called on a different thread than that used to create the device being reset. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK, indicating that the device is operational and the calling application can continue. If the method fails, the return value can be one of the following values: D3DERR_DEVICELOST, D3DERR_DEVICENOTRESET, D3DERR_DRIVERINTERNALERROR.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::TestCooperativeLevel()</unmanaged>
        public SlimDX2.Result TestCooperativeLevel() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns an estimate of the amount of available texture memory.	
        /// </summary>	
        /// <remarks>	
        ///  The returned value is rounded to the nearest MB. This is done to reflect the fact that video memory estimates are never precise due to alignment and other issues that affect consumption by certain resources. Applications can use this value to make gross estimates of memory availability to make large-scale resource decisions such as how many levels of a mipmap to attempt to allocate, but applications cannot use this value to make small-scale decisions such as if there is enough memory left to allocate another resource. 	
        /// </remarks>	
        /// <returns>  {{UINT}}  The function returns an estimate of the available texture memory. </returns>
        /// <unmanaged>UINT IDirect3DDevice9::GetAvailableTextureMem()</unmanaged>
        internal int GetAvailableTextureMem() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Evicts all managed resources, including both Direct3D and driver-managed resources.	
        /// </summary>	
        /// <remarks>	
        ///  This function causes only the D3DPOOL_DEFAULT copy of resources to be evicted. The resource copy in system memory is retained. See <see cref="SlimDX2.Direct3D9.Pool"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_OUTOFVIDEOMEMORY, D3DERR_COMMAND_UNPARSED. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::EvictManagedResources()</unmanaged>
        public SlimDX2.Result EvictManagedResources() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns an interface to the instance of the Direct3D object that created the device.	
        /// </summary>	
        /// <remarks>	
        ///  Calling IDirect3DDevice9::GetDirect3D will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Direct3D"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3D9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="d3D9Ref"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Direct3D"/> interface, representing the interface of the Direct3D object that created the device.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetDirect3D([Out] IDirect3D9** ppD3D9)</unmanaged>
        internal SlimDX2.Result GetDirect3D(out SlimDX2.Direct3D9.Direct3D d3D9Ref) {
            unsafe {
                IntPtr d3D9Ref_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, &d3D9Ref_);
                d3D9Ref = (d3D9Ref_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Direct3D(d3D9Ref_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the capabilities of the rendering device.	
        /// </summary>	
        /// <remarks>	
        ///  IDirect3DDevice9::GetDeviceCaps retrieves the software vertex pipeline capabilities when the device is being used in software vertex processing mode.   	
        /// </remarks>	
        /// <param name="capsRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Capabilities"/> structure, describing the returned device.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetDeviceCaps([Out] D3DCAPS9* pCaps)</unmanaged>
        internal SlimDX2.Result GetDeviceCaps(out SlimDX2.Direct3D9.Capabilities capsRef) {
            unsafe {
                capsRef = new SlimDX2.Direct3D9.Capabilities();
                SlimDX2.Result __result__;
                fixed (void* capsRef_ = &capsRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, capsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the display mode's spatial resolution, color resolution, and refresh frequency.	
        /// </summary>	
        /// <param name="iSwapChain"> An unsigned integer specifying the swap chain. </param>
        /// <param name="modeRef"> Pointer to a <see cref="SlimDX2.Direct3D9.DisplayMode"/> structure containing data about the display mode of the adapter. As opposed to the display mode of the device, which may not be active if the device does not own full-screen mode.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetDisplayMode([None] UINT iSwapChain,[Out] D3DDISPLAYMODE* pMode)</unmanaged>
        public SlimDX2.Result GetDisplayMode(int iSwapChain, out SlimDX2.Direct3D9.DisplayMode modeRef) {
            unsafe {
                modeRef = new SlimDX2.Direct3D9.DisplayMode();
                SlimDX2.Result __result__;
                fixed (void* modeRef_ = &modeRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, iSwapChain, modeRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the creation parameters of the device.	
        /// </summary>	
        /// <remarks>	
        ///  You can query the AdapterOrdinal member of the returned <see cref="SlimDX2.Direct3D9.CreationParameters"/> structure to retrieve the ordinal of the adapter represented by this device.  	
        /// </remarks>	
        /// <param name="arametersRef"> Pointer to a <see cref="SlimDX2.Direct3D9.CreationParameters"/> structure, describing the creation parameters of the device.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the argument is invalid. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetCreationParameters([Out] D3DDEVICE_CREATION_PARAMETERS* pParameters)</unmanaged>
        internal SlimDX2.Result GetCreationParameters(out SlimDX2.Direct3D9.CreationParameters arametersRef) {
            unsafe {
                arametersRef = new SlimDX2.Direct3D9.CreationParameters();
                SlimDX2.Result __result__;
                fixed (void* arametersRef_ = &arametersRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, arametersRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets properties for the cursor.	
        /// </summary>	
        /// <remarks>	
        ///  An operating system cursor is created and used under either of these conditions:  The hardware has set D3DCURSORCAPS_COLOR (see {{D3DCURSORCAPS}}), and the cursor size is 32x32 (which is the cursor size in the operating system). The application is running in windowed mode.  Otherwise, DirectX uses an emulated cursor. An application uses <see cref="SlimDX2.Direct3D9.Device.SetCursorPosition"/> to move an emulated cursor to follow mouse movement. It is recommended for applications to always trap WM_MOUSEMOVE events and call DXSetCursorPosition. Direct3D cursor functions use either GDI cursor or software emulation, depending on the hardware. Users typically want to respond to a WM_SETCURSOR message. For example, they might want to write the message handler as follows: 	
        /// <code> case WM_SETCURSOR:	
        /// // Turn off window cursor. 	
        /// SetCursor( NULL );	
        /// m_pd3dDevice-&gt;ShowCursor( TRUE );	
        /// return TRUE; // Prevent Windows from setting cursor to window class cursor.	
        /// break; </code>	
        /// 	
        ///  Or, users might want to call the IDirect3DDevice9::SetCursorProperties method if they want to change the cursor.  The application can determine what hardware support is available for cursors by examining appropriate members of the <see cref="SlimDX2.Direct3D9.Capabilities"/> structure. Typically, hardware supports only 32x32 cursors and, when windowed, the system might support only 32x32 cursors. In this case, IDirect3DDevice9::SetCursorProperties still succeeds but the cursor might be reduced to that size. The hot spot is scaled appropriately. The cursor does not survive when the device is lost. This method must be called after the device is reset. 	
        /// </remarks>	
        /// <param name="xHotSpot"> X-coordinate offset (in pixels) that marks the center of the cursor. The offset is relative to the upper-left corner of the cursor. When the cursor is given a new position, the image is drawn at an offset from this new position determined by subtracting the hot spot coordinates from the position.  </param>
        /// <param name="yHotSpot"> Y-coordinate offset (in pixels) that marks the center of the cursor. The offset is relative to the upper-left corner of the cursor. When the cursor is given a new position, the image is drawn at an offset from this new position determined by subtracting the hot spot coordinates from the position.  </param>
        /// <param name="cursorBitmapRef"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface. This parameter must point to an 8888 ARGB surface (format D3DFMT_A8R8G8B8). The contents of this surface will be copied and potentially format-converted into an internal buffer from which the cursor is displayed. The dimensions of this surface must be less than the dimensions of the display mode, and must be a power of two in each direction, although not necessarily the same power of two. The alpha channel must be either 0.0 or 1.0.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetCursorProperties([None] UINT XHotSpot,[None] UINT YHotSpot,[None] IDirect3DSurface9* pCursorBitmap)</unmanaged>
        public SlimDX2.Result SetCursorProperties(int xHotSpot, int yHotSpot, SlimDX2.Direct3D9.Surface cursorBitmapRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, xHotSpot, yHotSpot, (void*)((cursorBitmapRef == null)?IntPtr.Zero:cursorBitmapRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the cursor position and update options.	
        /// </summary>	
        /// <remarks>	
        ///  When running in full-screen mode, screen space coordinates are the back buffer coordinates appropriately scaled to the current display mode. When running in windowed mode, screen space coordinates are the desktop coordinates. The cursor image is drawn at the specified position minus the hotspot-offset specified by the {{SetCursorProperties}} method. If the cursor has been hidden by {{ShowCursor}}, the cursor is not drawn. 	
        /// </remarks>	
        /// <param name="x"> The new X-position of the cursor in virtual desktop coordinates. See Remarks.  </param>
        /// <param name="y"> The new Y-position of the cursor in virtual desktop coordinates. See Remarks.  </param>
        /// <param name="flags">  Specifies the update options for the cursor. Currently, only one flag is defined.  ValueMeaning  D3DCURSOR_IMMEDIATE_UPDATE   Update cursor at the refresh rate. If this flag is specified, the system guarantees that the cursor will be updated at a minimum of half the display refresh rate, but never more frequently than the display refresh rate. Otherwise, the method delays cursor updates until the next <see cref="SlimDX2.Direct3D9.Device.Present"/> call. Not setting this flag usually results in better performance than if the flag is set. However, applications should set this flag if the rate of calls to Present is low enough that users would notice a significant delay in cursor motion. This flag has no effect in a windowed-mode application. Some video cards implement hardware color cursors. This flag does not have an effect on these cards.   ? </param>
        /// <unmanaged>void IDirect3DDevice9::SetCursorPosition([None] int X,[None] int Y,[None] int Flags)</unmanaged>
        public void SetCursorPosition(int x, int y, int flags) {
            unsafe {
                SlimDX2.Direct3D9.LocalInterop.Callivoid(_nativePointer, 11 * 4, x, y, flags);
            }
        }
        
        /// <summary>	
        /// Displays or hides the cursor.	
        /// </summary>	
        /// <remarks>	
        ///  Direct3D cursor functions use either GDI cursor or software emulation, depending on the hardware. Users usually want to respond to a WM_SETCURSOR message. For example, the users might want to write the message handler like this: 	
        /// <code> case WM_SETCURSOR: // Turn off window cursor  SetCursor( NULL ); m_pd3dDevice-&gt;ShowCursor( TRUE ); return TRUE; // prevent Windows from setting cursor to window class cursor break; </code>	
        /// 	
        ///  Or users might want to call the <see cref="SlimDX2.Direct3D9.Device.SetCursorProperties"/> method if they want to change the cursor. See the code in the DirectX Graphics C/C++ Samples for more detail. 	
        /// </remarks>	
        /// <param name="bShow"> If bShow is TRUE, the cursor is shown. If bShow is FALSE, the cursor is hidden.  </param>
        /// <returns>  {{BOOL}}  Value indicating whether the cursor was previously visible. TRUE if the cursor was previously visible, or FALSE if the cursor was not previously visible. </returns>
        /// <unmanaged>BOOL IDirect3DDevice9::ShowCursor([None] BOOL bShow)</unmanaged>
        public bool ShowCursor(bool bShow) {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, (bShow?1:0)));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates an additional swap chain for rendering multiple views.	
        /// </summary>	
        /// <remarks>	
        ///  There is always at least one swap chain (the implicit swap chain) for each device because Direct3D 9 has one swap chain as a property of the device.  Note that any given device can support only one full-screen swap chain. D3DFMT_UNKNOWN can be specified for the windowed mode back buffer format when calling <see cref="SlimDX2.Direct3D9.Direct3D.CreateDevice"/>, <see cref="SlimDX2.Direct3D9.Device.Reset"/> and CreateAdditionalSwapChain. This means the application does not have to query the current desktop format before calling CreateDevice for windowed mode. For full-screen mode, the back buffer format must be specified.  	
        /// </remarks>	
        /// <param name="resentationParametersRef"> Pointer to a <see cref="SlimDX2.Direct3D9.PresentParameters"/> structure, containing the presentation parameters for the new swap chain. This value cannot be NULL. Calling this method changes the value of members of the D3DPRESENT_PARAMETERS structure.  If BackBufferCount == 0, calling CreateAdditionalSwapChain will increase it to 1. If the application is in windowed mode, and if either the BackBufferWidth or the BackBufferHeight == 0, they will be set to the client area width and height of the hwnd.  </param>
        /// <param name="swapChainRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.SwapChain"/> interface, representing the additional swap chain.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_DEVICELOST, D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateAdditionalSwapChain([None] D3DPRESENT_PARAMETERS* pPresentationParameters,[None] IDirect3DSwapChain9** pSwapChain)</unmanaged>
        internal SlimDX2.Result CreateAdditionalSwapChain(ref SlimDX2.Direct3D9.PresentParameters resentationParametersRef, out SlimDX2.Direct3D9.SwapChain swapChainRef) {
            unsafe {
                IntPtr swapChainRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* resentationParametersRef_ = &resentationParametersRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, resentationParametersRef_, &swapChainRef_);
                swapChainRef = (swapChainRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.SwapChain(swapChainRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a pointer to a swap chain.	
        /// </summary>	
        /// <param name="iSwapChain"> The swap chain ordinal value.  For more information, see NumberOfAdaptersInGroup in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="swapChainRef"> Pointer to an <see cref="SlimDX2.Direct3D9.SwapChain"/> interface that will receive a copy of swap chain.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetSwapChain([None] UINT iSwapChain,[Out] IDirect3DSwapChain9** pSwapChain)</unmanaged>
        public SlimDX2.Result GetSwapChain(int iSwapChain, out SlimDX2.Direct3D9.SwapChain swapChainRef) {
            unsafe {
                IntPtr swapChainRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, iSwapChain, &swapChainRef_);
                swapChainRef = (swapChainRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.SwapChain(swapChainRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of implicit swap chains.	
        /// </summary>	
        /// <remarks>	
        ///  Implicit swap chains are created by the device during <see cref="SlimDX2.Direct3D9.Direct3D.CreateDevice"/>. This method returns the number of swap chains created by CreateDevice.   An application may create additional swap chains using <see cref="SlimDX2.Direct3D9.Device.CreateAdditionalSwapChain"/>. 	
        /// </remarks>	
        /// <returns>  {{UINT}}  Number of implicit swap chains. See Remarks. </returns>
        /// <unmanaged>UINT IDirect3DDevice9::GetNumberOfSwapChains()</unmanaged>
        internal int GetNumberOfSwapChains() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Resets the type, size, and format of the swap chain.	
        /// </summary>	
        /// <remarks>	
        ///  If a call to IDirect3DDevice9::Reset fails, the device will be placed in the "lost" state (as indicated by a return value of D3DERR_DEVICELOST from a call to <see cref="SlimDX2.Direct3D9.Device.TestCooperativeLevel"/>) unless it is already in the "not reset" state (as indicated by a return value of D3DERR_DEVICENOTRESET from a call to IDirect3DDevice9::TestCooperativeLevel). Refer to IDirect3DDevice9::TestCooperativeLevel and {{Lost Devices (Direct3D 9)}} for further information concerning the use of IDirect3DDevice9::Reset in the context of lost devices. Calling IDirect3DDevice9::Reset causes all texture memory surfaces to be lost, managed textures to be flushed from video memory, and all state information to be lost. Before calling the IDirect3DDevice9::Reset method for a device, an application should release any explicit render targets, depth stencil surfaces, additional swap chains, state blocks, and D3DPOOL_DEFAULT resources associated with the device. There are two different types of swap chains: full-screen or windowed. If the new swap chain is full-screen, the adapter will be placed in the display mode that matches the new size. Direct3D 9 applications can expect messages to be sent to them during this call (for example, before this call is returned); applications should take precautions not to call into Direct3D at this time. In addition, when IDirect3DDevice9::Reset fails, the only valid methods that can be called are IDirect3DDevice9::Reset, <see cref="SlimDX2.Direct3D9.Device.TestCooperativeLevel"/>, and the various Release member functions. Calling any other method can result in an exception. A call to IDirect3DDevice9::Reset will fail if called on a different thread than that used to create the device being reset. Pixel shaders and vertex shaders survive IDirect3DDevice9::Reset calls for Direct3D 9. They do not need to be re-created explicitly by the application.  <see cref="SlimDX2.Direct3D9.Format.Unknown"/> can be specified for the windowed mode back buffer format when calling <see cref="SlimDX2.Direct3D9.Direct3D.CreateDevice"/>, IDirect3DDevice9::Reset, and <see cref="SlimDX2.Direct3D9.Device.CreateAdditionalSwapChain"/>. This means the application does not have to query the current desktop format before calling IDirect3D9::CreateDevice for windowed mode. For full-screen mode, the back buffer format must be specified. Setting BackBufferCount equal to zero  (BackBufferCount = 0) results in one back buffer. When trying to reset more than one display adapter in a group, set pPresentationParameters to point to an array of <see cref="SlimDX2.Direct3D9.PresentParameters"/> structures, one for each display in the adapter group. If a multihead device was created with <see cref="SlimDX2.Direct3D9.CreateFlags.AdapterGroupDevice"/>, IDirect3DDevice9::Reset requires an array of <see cref="SlimDX2.Direct3D9.PresentParameters"/> structures wherein each structure must specify a full-screen display. To switch back to windowed mode, the application must destroy the device and re-create a non-multihead device in windowed mode. 	
        /// </remarks>	
        /// <param name="resentationParametersRef"> Pointer to a <see cref="SlimDX2.Direct3D9.PresentParameters"/> structure, describing the new presentation parameters. This value cannot be NULL.   When switching to full-screen mode, Direct3D will try to find a desktop format that matches the back buffer format, so that back buffer and front buffer formats will be identical (to eliminate the need for color conversion). When this method returns:  BackBufferCount, BackBufferWidth, and BackBufferHeight are set to zero. BackBufferFormat is set to <see cref="SlimDX2.Direct3D9.Format.Unknown"/> for windowed mode only; a full-screen mode must specify a format.  </param>
        /// <returns>  <see cref="int"/>  Possible return values include: D3D_OK, D3DERR_DEVICELOST, D3DERR_DEVICEREMOVED, D3DERR_DRIVERINTERNALERROR, or D3DERR_OUTOFVIDEOMEMORY (see {{D3DERR}}). </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::Reset([None] D3DPRESENT_PARAMETERS* pPresentationParameters)</unmanaged>
        public SlimDX2.Result Reset(ref SlimDX2.Direct3D9.PresentParameters resentationParametersRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* resentationParametersRef_ = &resentationParametersRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, resentationParametersRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Presents the contents of the next buffer in the sequence of back buffers owned by the device.	
        /// </summary>	
        /// <remarks>	
        ///  If necessary, a stretch operation is applied to transfer the pixels within the source rectangle to the destination rectangle in the client area of the target window.  Present will fail, returning D3DERR_INVALIDCALL, if called between BeginScene and EndScene pairs unless the render target is not the current render target (such as the back buffer you get from creating an additional swap chain). This is a new behavior for Direct3D 9.  	
        /// </remarks>	
        /// <param name="sourceRectRef"> Pointer to a value that must be NULL unless the swap chain was created with D3DSWAPEFFECT_COPY. pSourceRect is a pointer to a <see cref="SlimDX2.Rectangle"/> structure containing the source rectangle. If NULL, the entire source surface is presented. If the rectangle exceeds the source surface, the rectangle is clipped to the source surface.  </param>
        /// <param name="destRectRef"> Pointer to a value that must be NULL unless the swap chain was created with D3DSWAPEFFECT_COPY. pDestRect is a pointer to a <see cref="SlimDX2.Rectangle"/> structure containing the destination rectangle, in window client coordinates. If NULL, the entire client area is filled. If the rectangle exceeds the destination client area, the rectangle is clipped to the destination client area.  </param>
        /// <param name="hDestWindowOverride"> Pointer to a destination window whose client area is taken as the target for this presentation. If this value is NULL, then the hWndDeviceWindow member of <see cref="SlimDX2.Direct3D9.PresentParameters"/> is taken.  </param>
        /// <param name="dirtyRegionRef"> Value must be NULL unless the swap chain was created with D3DSWAPEFFECT_COPY. For more information about swap chains, see {{Flipping Surfaces (Direct3D 9)}} and <see cref="SlimDX2.Direct3D9.SwapEffect"/>. If this value is non-NULL, the contained region is expressed in back buffer coordinates. The rectangles within the region are the minimal set of pixels that need to be updated. This method takes these rectangles into account when optimizing the presentation by copying only the pixels within the region, or some suitably expanded set of rectangles. This is an aid to optimization only, and the application should not rely on the region being copied exactly. The implementation can choose to copy the whole source rectangle.   </param>
        /// <returns>  <see cref="int"/>  Possible return values include: D3D_OK or D3DERR_DEVICEREMOVED (see {{D3DERR}}). </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::Present([In, Optional] const RECT* pSourceRect,[InOut, Optional] const RECT* pDestRect,[None] HWND hDestWindowOverride,[In, Optional] const RGNDATA* pDirtyRegion)</unmanaged>
        internal SlimDX2.Result Present(SlimDX2.Rectangle? sourceRectRef, IntPtr destRectRef, IntPtr hDestWindowOverride, IntPtr dirtyRegionRef) {
            unsafe {
                SlimDX2.Rectangle sourceRectRef_;
                if (sourceRectRef.HasValue)
                    sourceRectRef_ = sourceRectRef.Value;				
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, (sourceRectRef.HasValue)?&sourceRectRef_:(void*)IntPtr.Zero, (void*)destRectRef, (void*)hDestWindowOverride, (void*)dirtyRegionRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a back buffer from the device's swap chain.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DSurface9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="iSwapChain"> An unsigned integer specifying the swap chain. </param>
        /// <param name="iBackBuffer"> Index of the back buffer object to return. Back buffers are numbered from 0 to the total number of back buffers minus one. A value of 0 returns the first back buffer, not the front buffer. The front buffer is not accessible through this method. Use <see cref="SlimDX2.Direct3D9.Device.GetFrontBufferData"/> to retrieve a copy of the front buffer. </param>
        /// <param name="type"> Stereo view is not supported in Direct3D 9, so the only valid value for this parameter is D3DBACKBUFFER_TYPE_MONO.  </param>
        /// <param name="backBufferRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the returned back buffer surface.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If BackBuffer equals or exceeds the total number of back buffers, then the function fails and returns D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetBackBuffer([None] UINT iSwapChain,[None] UINT iBackBuffer,[None] D3DBACKBUFFER_TYPE Type,[Out] IDirect3DSurface9** ppBackBuffer)</unmanaged>
        public SlimDX2.Result GetBackBuffer(int iSwapChain, int iBackBuffer, SlimDX2.Direct3D9.BackbufferType type, out SlimDX2.Direct3D9.Surface backBufferRef) {
            unsafe {
                IntPtr backBufferRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, iSwapChain, iBackBuffer, unchecked((int)type), &backBufferRef_);
                backBufferRef = (backBufferRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(backBufferRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns information describing the raster of the monitor on which the swap chain is presented.	
        /// </summary>	
        /// <param name="iSwapChain"> An unsigned integer specifying the swap chain. </param>
        /// <param name="rasterStatusRef"> Pointer to a <see cref="SlimDX2.Direct3D9.RasterStatus"/> structure filled with information about the position or other status of the raster on the monitor driven by this adapter.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if pRasterStatus is invalid or if the device does not support reading the current scan line. To determine if the device supports reading the scan line, check for the D3DCAPS_READ_SCANLINE flag in the Caps member of <see cref="SlimDX2.Direct3D9.Capabilities"/>.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetRasterStatus([None] UINT iSwapChain,[Out] D3DRASTER_STATUS* pRasterStatus)</unmanaged>
        public SlimDX2.Result GetRasterStatus(int iSwapChain, out SlimDX2.Direct3D9.RasterStatus rasterStatusRef) {
            unsafe {
                rasterStatusRef = new SlimDX2.Direct3D9.RasterStatus();
                SlimDX2.Result __result__;
                fixed (void* rasterStatusRef_ = &rasterStatusRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, iSwapChain, rasterStatusRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// This method allows the use of GDI dialog boxes in full-screen mode applications.	
        /// </summary>	
        /// <remarks>	
        ///  The GDI dialog boxes must be created as child to the device window. They should also be created within the same thread that created the device because this enables the parent window to manage redrawing the child window. The method has no effect for windowed mode applications, but this setting will be respected if the application resets the device into full-screen mode. If SetDialogBoxMode succeeds in a windowed mode application, any subsequent reset to full-screen mode will be checked against the restrictions listed above.  Also, SetDialogBoxMode causes all back buffers on the swap chain to be discarded, so an application is expected to refresh its content for all back buffers after this call. 	
        /// </remarks>	
        /// <param name="bEnableDialogs"> TRUE to enable GDI dialog boxes, and FALSE to disable them. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL unless all of the following are true.   The application specified a back buffer format compatible with GDI, in other words, one of D3DFMT_X1R5G5B5, D3DFMT_R5G6B5, or D3DFMT_X8R8G8B8. The application specified no multisampling. The application specified D3DSWAPEFFECT_DISCARD. The application specified D3DPRESENTFLAG_LOCKABLE_BACKBUFFER. The application did not specify D3DCREATE_ADAPTERGROUP_DEVICE. The application is not between BeginScene and EndScene.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetDialogBoxMode([None] BOOL bEnableDialogs)</unmanaged>
        internal SlimDX2.Result SetDialogBoxMode(bool bEnableDialogs) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, (bEnableDialogs?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the gamma correction ramp for the implicit swap chain. This method will affect the entire screen (not just the active window if you are running in windowed mode).	
        /// </summary>	
        /// <remarks>	
        ///  There is always at least one swap chain (the implicit swap chain) for each device, because Direct3D 9 has one swap chain as a property of the device. The gamma ramp takes effect immediately; there is no wait for a vertical sync. If the device does not support gamma ramps in the swap chain's current presentation mode (full-screen or windowed), no error return is given. Applications can check the D3DCAPS2_FULLSCREENGAMMA and D3DCAPS2_CANCALIBRATEGAMMA capability bits in the Caps2 member of the D3DCAPS9 structure to determine the capabilities of the device and whether a calibrator is installed. For windowed gamma correction presentation, use <see cref="SlimDX2.Direct3D9.SwapChain.Present"/> if the hardware supports the feature. In DirectX 8, SetGammaRamp will set the gamma ramp only on a full-screen mode application. For more information about gamma correction, see {{Gamma (Direct3D 9)}}. 	
        /// </remarks>	
        /// <param name="iSwapChain"> Unsigned integer specifying the swap chain. </param>
        /// <param name="flags"> Indicates whether correction should be applied. Gamma correction results in a more consistent display, but can incur processing overhead and should not be used frequently. Short-duration effects, such as flashing the whole screen red, should not be calibrated, but long-duration gamma changes should be calibrated. One of the following values can be set:    ItemDescription  D3DSGR_CALIBRATE  If a gamma calibrator is installed, the ramp will be modified before being sent to the device to account for the system and monitor response curves. If a calibrator is not installed, the ramp will be passed directly to the device.   D3DSGR_NO_CALIBRATION  No gamma correction is applied. The supplied gamma table is transferred directly to the device.   ? </param>
        /// <param name="rampRef"> Pointer to a <see cref="SlimDX2.Direct3D9.GammaRamp"/> structure, representing the gamma correction ramp to be set for the implicit swap chain.  </param>
        /// <unmanaged>void IDirect3DDevice9::SetGammaRamp([None] UINT iSwapChain,[None] int Flags,[None] const D3DGAMMARAMP* pRamp)</unmanaged>
        public void SetGammaRamp(int iSwapChain, int flags, ref SlimDX2.Direct3D9.GammaRamp rampRef) {
            unsafe {
                SlimDX2.Direct3D9.GammaRamp.__Native rampRef_ = new SlimDX2.Direct3D9.GammaRamp.__Native();
                rampRef.__MarshalTo(ref rampRef_);
                SlimDX2.Direct3D9.LocalInterop.Callivoid(_nativePointer, 21 * 4, iSwapChain, flags, &rampRef_);
                rampRef.__MarshalFrom(ref rampRef_);
                rampRef_.__MarshalFree();
            }
        }
        
        /// <summary>	
        /// Retrieves the gamma correction ramp for the swap chain.	
        /// </summary>	
        /// <param name="iSwapChain"> An unsigned integer specifying the swap chain. </param>
        /// <param name="rampRef"> Pointer to an application-supplied <see cref="SlimDX2.Direct3D9.GammaRamp"/> structure to fill with the gamma correction ramp.  </param>
        /// <unmanaged>void IDirect3DDevice9::GetGammaRamp([None] UINT iSwapChain,[Out] D3DGAMMARAMP* pRamp)</unmanaged>
        public void GetGammaRamp(int iSwapChain, out SlimDX2.Direct3D9.GammaRamp rampRef) {
            unsafe {
                SlimDX2.Direct3D9.GammaRamp.__Native rampRef_ = new SlimDX2.Direct3D9.GammaRamp.__Native();
                SlimDX2.Direct3D9.LocalInterop.Callivoid(_nativePointer, 22 * 4, iSwapChain, &rampRef_);
                rampRef = new SlimDX2.Direct3D9.GammaRamp();
                rampRef.__MarshalFrom(ref rampRef_);
            }
        }
        
        /// <summary>	
        /// Creates a texture resource.	
        /// </summary>	
        /// <remarks>	
        ///  An application can discover support for {{Automatic Generation of Mipmaps (Direct3D 9)}} in a particular format by calling  <see cref="SlimDX2.Direct3D9.Direct3D.CheckDeviceFormat"/> with D3DUSAGE_AUTOGENMIPMAP. If IDirect3D9::CheckDeviceFormat returns D3DOK_NOAUTOGEN,  IDirect3DDevice9::CreateTexture will succeed but it will return a one-level texture. In Windows Vista CreateTexture can create a texture from a system memory pointer allowing the application more flexibility over the use, allocation and deletion of  the system memory.  For example, an application could pass a GDI system memory bitmap pointer and get a Direct3D texture interface around it.  Using a system memory  pointer with CreateTexture has the following restrictions.  The pitch of the texture must be equal to the width multiplied by the number of bytes per pixel. Only textures with a single mipmap level are supported.  The Levels argument must be 1. The Pool argument must be D3DPOOL_SYSTEMMEM. The pSharedHandle argument must be a valid pointer to a buffer that can hold the system memory point; *pSharedHandle must  be a valid pointer to system memory with a size in bytes of texture width * texture height * bytes per pixel of the texture format.  	
        /// </remarks>	
        /// <param name="width"> Width of the top-level of the texture, in pixels. The pixel dimensions of subsequent levels will be the truncated value of half of the previous level's  pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by 2 results in 0, 1 will be taken instead.  </param>
        /// <param name="height"> Height of the top-level of the texture, in pixels. The pixel dimensions of subsequent levels will be the truncated value of half of the previous level's  pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by 2 results in 0, 1 will be taken instead.  </param>
        /// <param name="levels"> Number of levels in the texture. If this is zero, Direct3D will generate all texture sublevels down to 1 by 1 pixels for hardware that supports  mipmapped textures. Call <see cref="SlimDX2.Direct3D9.BaseTexture.GetLevelCount"/> to see the number of levels generated.  </param>
        /// <param name="usage"> Usage can be 0, which indicates no usage value. However, if usage is desired, use a combination of one or more <see cref="SlimDX2.Direct3D9.Usage"/> constants. It is  good practice to match the usage parameter with the behavior flags in <see cref="SlimDX2.Direct3D9.Direct3D.CreateDevice"/>.  </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of all levels in the texture.  </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed.  </param>
        /// <param name="textureRef"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture resource.  </param>
        /// <param name="sharedHandleRef"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to  {{share resources}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL,  D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateTexture([None] UINT Width,[None] UINT Height,[None] UINT Levels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] IDirect3DTexture9** ppTexture,[None] HANDLE* pSharedHandle)</unmanaged>
        internal SlimDX2.Result CreateTexture(int width, int height, int levels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.Texture textureRef, IntPtr sharedHandleRef) {
            unsafe {
                IntPtr textureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, width, height, levels, usage, unchecked((int)format), unchecked((int)pool), &textureRef_, (void*)sharedHandleRef);
                textureRef = (textureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(textureRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a volume texture resource.	
        /// </summary>	
        /// <param name="width"> Width of the top-level of the volume texture, in pixels. This value must be a power of two if the D3DPTEXTURECAPS_VOLUMEMAP_POW2 member of <see cref="SlimDX2.Direct3D9.Capabilities"/> is set. The pixel dimensions of subsequent levels will be the truncated value of half of the previous level's pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by two results in 0 (zero), 1 will be taken instead. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in D3DCAPS9. </param>
        /// <param name="height"> Height of the top-level of the volume texture, in pixels. This value must be a power of two if the D3DPTEXTURECAPS_VOLUMEMAP_POW2 member of <see cref="SlimDX2.Direct3D9.Capabilities"/> is set. The pixel dimensions of subsequent levels will be the truncated value of half of the previous level's pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by 2 results in 0 (zero), 1 will be taken instead. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in D3DCAPS9. </param>
        /// <param name="depth"> Depth of the top-level of the volume texture, in pixels. This value must be a power of two if the D3DPTEXTURECAPS_VOLUMEMAP_POW2 member of <see cref="SlimDX2.Direct3D9.Capabilities"/> is set. The pixel dimensions of subsequent levels will be the truncated value of half of the previous level's pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by 2 results in 0 (zero), 1 will be taken instead. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in D3DCAPS9. </param>
        /// <param name="levels"> Number of levels in the texture. If this is zero, Direct3D will generate all texture sublevels down to 1x1 pixels for hardware that supports mipmapped volume textures. Call <see cref="SlimDX2.Direct3D9.BaseTexture.GetLevelCount"/> to see the number of levels generated.  </param>
        /// <param name="usage"> Usage can be 0, which indicates no usage value. If usage is desired, use D3DUSAGE_DYNAMIC or D3DUSAGE_SOFTWAREPROCESSING. For more information, see <see cref="SlimDX2.Direct3D9.Usage"/>.  </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of all levels in the volume texture.  </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the volume texture should be placed.  </param>
        /// <param name="volumeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the created volume texture resource.  </param>
        /// <param name="sharedHandleRef"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateVolumeTexture([None] UINT Width,[None] UINT Height,[None] UINT Depth,[None] UINT Levels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] IDirect3DVolumeTexture9** ppVolumeTexture,[None] HANDLE* pSharedHandle)</unmanaged>
        internal SlimDX2.Result CreateVolumeTexture(int width, int height, int depth, int levels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.VolumeTexture volumeTextureRef, IntPtr sharedHandleRef) {
            unsafe {
                IntPtr volumeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, width, height, depth, levels, usage, unchecked((int)format), unchecked((int)pool), &volumeTextureRef_, (void*)sharedHandleRef);
                volumeTextureRef = (volumeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(volumeTextureRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a cube texture resource.	
        /// </summary>	
        /// <remarks>	
        ///  A mipmap (texture) is a collection of successively downsampled (mipmapped) surfaces. On the other hand, a cube texture (created by IDirect3DDevice9::CreateCubeTexture) is a collection of six textures (mipmaps), one for each face. All faces must be present in the cube texture. Also, a cube map surface must be the same pixel size in all three dimensions (x, y, and z). An application can discover support for {{Automatic Generation of Mipmaps (Direct3D 9)}} in a particular format by calling <see cref="SlimDX2.Direct3D9.Direct3D.CheckDeviceFormat"/> with D3DUSAGE_AUTOGENMIPMAP. If IDirect3D9::CheckDeviceFormat returns D3DOK_NOAUTOGEN, IDirect3DDevice9::CreateCubeTexture will succeed but it will return a one-level texture. 	
        /// </remarks>	
        /// <param name="edgeLength"> Size of the edges of all the top-level faces of the cube texture. The pixel dimensions of subsequent levels of each face will be the truncated value of half of the previous level's pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by 2 results in 0 (zero), 1 will be taken instead.  </param>
        /// <param name="levels"> Number of levels in each face of the cube texture. If this is zero, Direct3D will generate all cube texture sublevels down to 1x1 pixels for each face for hardware that supports mipmapped cube textures.  Call <see cref="SlimDX2.Direct3D9.BaseTexture.GetLevelCount"/> to see the number of levels generated.  </param>
        /// <param name="usage"> Usage can be 0, which indicates no usage value. However, if usage is desired, use a combination of one or more <see cref="SlimDX2.Direct3D9.Usage"/> constants. It is good practice to match the usage parameter in CreateCubeTexture with the behavior flags in <see cref="SlimDX2.Direct3D9.Direct3D.CreateDevice"/>. For more information, see Remarks.  </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of all levels in all faces of the cube texture.  </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the cube texture should be placed.  </param>
        /// <param name="cubeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture resource.  </param>
        /// <param name="sharedHandleRef"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateCubeTexture([None] UINT EdgeLength,[None] UINT Levels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] IDirect3DCubeTexture9** ppCubeTexture,[None] HANDLE* pSharedHandle)</unmanaged>
        internal SlimDX2.Result CreateCubeTexture(int edgeLength, int levels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.CubeTexture cubeTextureRef, IntPtr sharedHandleRef) {
            unsafe {
                IntPtr cubeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4, edgeLength, levels, usage, unchecked((int)format), unchecked((int)pool), &cubeTextureRef_, (void*)sharedHandleRef);
                cubeTextureRef = (cubeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(cubeTextureRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a vertex buffer.	
        /// </summary>	
        /// <remarks>	
        ///  A vertex buffer can be used with either hardware or software vertex processing. This is determined by how the device and the vertex buffer are created. When a device is created, CreateDevice uses the behavior flag to determine whether to process vertices in hardware or software. There are three possibilities:  Process vertices in hardware by setting D3DCREATE_HARDWARE_VERTEXPROCESSING. Process vertices in software by setting D3DCREATE_SOFTWARE_VERTEXPROCESSING. Process vertices in either hardware or software by setting D3DCREATE_MIXED_VERTEXPROCESSING.  Mixed-mode devices might need to switch between software and hardware processing (using <see cref="SlimDX2.Direct3D9.Device.SetSoftwareVertexProcessing"/>) after the device is created.     When a vertex buffer is created, CreateVertexBuffer uses the usage parameter to decide whether to process vertices in hardware or software.  If CreateDevice uses D3DCREATE_HARDWARE_VERTEXPROCESSING, CreateVertexBuffer must use 0. If CreateDevice uses D3DCREATE_SOFTWARE_VERTEXPROCESSING, CreateVertexBuffer must use either 0 or D3DUSAGE_SOFTWAREPROCESSING. For either value, vertices will be processed in software. If CreateDevice uses D3DCREATE_MIXED_VERTEXPROCESSING, CreateVertexBuffer can use either 0 or D3DUSAGE_SOFTWAREPROCESSING.  To use a vertex buffer with a mixed mode device, create a single vertex buffer which can be used for both hardware or software processing. Use <see cref="SlimDX2.Direct3D9.Device.SetStreamSource"/> to set the current vertex buffer and use <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/>, if necessary, to change the device behavior to match. It is recommended that the vertex buffer usage matches the device behavior. Note that a vertex buffer created for software processing cannot be located in video memory. The <see cref="SlimDX2.Direct3D9.Device"/> interface supports rendering of primitives using vertex data stored in vertex buffer objects. Vertex buffers are created from the IDirect3DDevice9, and are usable only with the IDirect3DDevice9 object from which they are created. When set to a nonzero value, which must be a valid FVF code, the FVF parameter indicates that the buffer content is to be characterized by an FVF code. A vertex buffer that is created with an FVF code is referred to as an FVF vertex buffer. For more information, see {{FVF Vertex Buffers (Direct3D 9)}}.  Non-FVF buffers can be used to interleave data during multipass rendering or multitexture rendering in a single pass. To do this, one buffer contains geometry data and the others contain texture coordinates for each texture to be rendered. When rendering, the buffer containing the geometry data is interleaved with each of the buffers containing the texture coordinates. If FVF buffers were used instead, each of them would need to contain identical geometry data in addition to the texture coordinate data specific to each texture rendered. This would result in either a speed or memory penalty, depending on the strategy used. For more information about texture coordinates, see {{Texture Coordinates (Direct3D 9)}}. 	
        /// </remarks>	
        /// <param name="length"> Size of the vertex buffer, in bytes. For FVF vertex buffers, Length must be large enough to contain at least one vertex, but it need not be a multiple of the vertex size. Length is not validated for non-FVF buffers. See Remarks.  </param>
        /// <param name="usage"> Usage can be 0, which indicates no usage value. However, if usage is desired, use a combination of one or more <see cref="SlimDX2.Direct3D9.Usage"/> constants. It is good practice to match the usage parameter in CreateVertexBuffer with the behavior flags in <see cref="SlimDX2.Direct3D9.Direct3D.CreateDevice"/>. For more information, see Remarks.  </param>
        /// <param name="vertexFormat"> Combination of <see cref="SlimDX2.Direct3D9.VertexFormat"/>, a usage specifier that describes the vertex format of the vertices in this buffer. If this parameter is set to a valid FVF code, the created vertex buffer is an FVF vertex buffer (see Remarks). Otherwise, if this parameter is set to zero, the vertex buffer is a non-FVF vertex buffer.  </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing a valid memory class into which to place the resource. Do not set to D3DPOOL_SCRATCH. </param>
        /// <param name="vertexBufferRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VertexBuffer"/> interface, representing the created vertex buffer resource.  </param>
        /// <param name="sharedHandleRef"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateVertexBuffer([None] UINT Length,[None] int Usage,[None] int FVF,[None] D3DPOOL Pool,[None] IDirect3DVertexBuffer9** ppVertexBuffer,[None] HANDLE* pSharedHandle)</unmanaged>
        internal SlimDX2.Result CreateVertexBuffer(int length, SlimDX2.Direct3D9.Usage usage, SlimDX2.Direct3D9.VertexFormat vertexFormat, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.VertexBuffer vertexBufferRef, IntPtr sharedHandleRef) {
            unsafe {
                IntPtr vertexBufferRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 26 * 4, length, unchecked((int)usage), unchecked((int)vertexFormat), unchecked((int)pool), &vertexBufferRef_, (void*)sharedHandleRef);
                vertexBufferRef = (vertexBufferRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexBuffer(vertexBufferRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates an index buffer.	
        /// </summary>	
        /// <remarks>	
        ///  Index buffers are memory resources used to hold indices, they are similar to both surfaces and vertex buffers. The use of index buffers enables Direct3D to avoid unnecessary data copying and to place the buffer in the optimal memory type for the expected usage. To use index buffers, create an index buffer, lock it, fill it with indices, unlock it, pass it to <see cref="SlimDX2.Direct3D9.Device.SetIndices"/>, set up the vertices, set up the vertex shader, and call <see cref="SlimDX2.Direct3D9.Device.DrawIndexedPrimitive"/> for rendering. The MaxVertexIndex member of the <see cref="SlimDX2.Direct3D9.Capabilities"/> structure indicates the types of index buffers that are valid for rendering. 	
        /// </remarks>	
        /// <param name="length"> Size of the index buffer, in bytes.  </param>
        /// <param name="usage"> Usage can be 0, which indicates no usage value. However, if usage is desired, use a combination of one or more <see cref="SlimDX2.Direct3D9.Usage"/> constants. It is good practice to match the usage parameter in CreateIndexBuffer with the behavior flags in <see cref="SlimDX2.Direct3D9.Direct3D.CreateDevice"/>. For more information, see Remarks.  </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of the index buffer. For more information, see Remarks. The valid settings are the following:    ItemDescription  D3DFMT_INDEX16  Indices are 16 bits each.   D3DFMT_INDEX32  Indices are 32 bits each.   ? </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing a valid memory class into which to place the resource.  </param>
        /// <param name="indexBufferRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.IndexBuffer"/> interface, representing the created index buffer resource.  </param>
        /// <param name="sharedHandleRef"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateIndexBuffer([None] UINT Length,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] IDirect3DIndexBuffer9** ppIndexBuffer,[None] HANDLE* pSharedHandle)</unmanaged>
        internal SlimDX2.Result CreateIndexBuffer(int length, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.IndexBuffer indexBufferRef, IntPtr sharedHandleRef) {
            unsafe {
                IntPtr indexBufferRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 27 * 4, length, usage, unchecked((int)format), unchecked((int)pool), &indexBufferRef_, (void*)sharedHandleRef);
                indexBufferRef = (indexBufferRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.IndexBuffer(indexBufferRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a render-target surface.	
        /// </summary>	
        /// <remarks>	
        ///  Render-target surfaces are placed in the D3DPOOL_DEFAULT memory class. The creation of lockable, multisampled render targets is not supported. 	
        /// </remarks>	
        /// <param name="width"> Width of the render-target surface, in pixels.  </param>
        /// <param name="height"> Height of the render-target surface, in pixels.  </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of the render target.  </param>
        /// <param name="multiSample"> Member of the <see cref="SlimDX2.Direct3D9.MultisampleType"/> enumerated type, which describes the multisampling buffer type. This parameter specifies the antialiasing type for this render target. When this surface is passed to <see cref="SlimDX2.Direct3D9.Device.SetRenderTarget"/>, its multisample type must be the same as that of the depth-stencil set by <see cref="SlimDX2.Direct3D9.Device.SetDepthStencilSurface"/>.  </param>
        /// <param name="multisampleQuality"> Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by  <see cref="SlimDX2.Direct3D9.Direct3D.CheckDeviceMultiSampleType"/>. Passing a larger value returns the error, D3DERR_INVALIDCALL. The MultisampleQuality values of paired render targets, depth stencil surfaces, and the multisample type must all match. </param>
        /// <param name="lockable"> Render targets are not lockable unless the application specifies TRUE for Lockable. Note that lockable render targets reduce performance on some graphics hardware. The readback performance (moving data from video memory to system memory) depends on the type of hardware used (AGP vs. PCI Express) and is usually far lower than upload performance (moving data from system to video memory). If you need read access to render targets, use {{GetRenderTargetData}} instead of lockable render targets. </param>
        /// <param name="surfaceRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface.  </param>
        /// <param name="sharedHandleRef"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateRenderTarget([None] UINT Width,[None] UINT Height,[None] D3DFORMAT Format,[None] D3DMULTISAMPLE_TYPE MultiSample,[None] int MultisampleQuality,[None] BOOL Lockable,[None] IDirect3DSurface9** ppSurface,[None] HANDLE* pSharedHandle)</unmanaged>
        internal SlimDX2.Result CreateRenderTarget(int width, int height, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.MultisampleType multiSample, int multisampleQuality, bool lockable, out SlimDX2.Direct3D9.Surface surfaceRef, IntPtr sharedHandleRef) {
            unsafe {
                IntPtr surfaceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 28 * 4, width, height, unchecked((int)format), unchecked((int)multiSample), multisampleQuality, (lockable?1:0), &surfaceRef_, (void*)sharedHandleRef);
                surfaceRef = (surfaceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(surfaceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a depth-stencil resource.	
        /// </summary>	
        /// <remarks>	
        ///  The memory class of the depth-stencil buffer is always D3DPOOL_DEFAULT. 	
        /// </remarks>	
        /// <param name="width"> Width of the depth-stencil surface, in pixels.  </param>
        /// <param name="height"> Height of the depth-stencil surface, in pixels.  </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of the depth-stencil surface. This value must be one of the enumerated depth-stencil formats for this device. </param>
        /// <param name="multiSample"> Member of the <see cref="SlimDX2.Direct3D9.MultisampleType"/> enumerated type, describing the multisampling buffer type. This value must be one of the allowed multisample types. When this surface is passed to <see cref="SlimDX2.Direct3D9.Device.SetDepthStencilSurface"/>, its multisample type must be the same as that of the render target set by <see cref="SlimDX2.Direct3D9.Device.SetRenderTarget"/>. </param>
        /// <param name="multisampleQuality"> Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by  <see cref="SlimDX2.Direct3D9.Direct3D.CheckDeviceMultiSampleType"/>. Passing a larger value returns the error D3DERR_INVALIDCALL. The MultisampleQuality values of paired render targets, depth stencil surfaces, and the MultiSample type must all match. </param>
        /// <param name="discard"> Set this flag to TRUE to enable z-buffer discarding, and FALSE otherwise.				If this flag is set, the contents of the depth stencil buffer will be invalid after calling either <see cref="SlimDX2.Direct3D9.Device.Present"/> or <see cref="SlimDX2.Direct3D9.Device.SetDepthStencilSurface"/> with a different depth surface. This flag has the same behavior as the constant,  D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL, in {{D3DPRESENTFLAG}}. </param>
        /// <param name="surfaceRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the created depth-stencil surface resource.  </param>
        /// <param name="sharedHandleRef"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateDepthStencilSurface([None] UINT Width,[None] UINT Height,[None] D3DFORMAT Format,[None] D3DMULTISAMPLE_TYPE MultiSample,[None] int MultisampleQuality,[None] BOOL Discard,[None] IDirect3DSurface9** ppSurface,[None] HANDLE* pSharedHandle)</unmanaged>
        internal SlimDX2.Result CreateDepthStencilSurface(int width, int height, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.MultisampleType multiSample, int multisampleQuality, bool discard, out SlimDX2.Direct3D9.Surface surfaceRef, IntPtr sharedHandleRef) {
            unsafe {
                IntPtr surfaceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 29 * 4, width, height, unchecked((int)format), unchecked((int)multiSample), multisampleQuality, (discard?1:0), &surfaceRef_, (void*)sharedHandleRef);
                surfaceRef = (surfaceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(surfaceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copies rectangular subsets of pixels from one surface to another. 	
        /// </summary>	
        /// <remarks>	
        ///  This method is similar to CopyRects in DirectX 8. This function has the following restrictions.  The source surface must have been created with D3DPOOL_SYSTEMMEM. The destination surface must have been created with D3DPOOL_DEFAULT. Neither surface can be locked or holding an outstanding device context. Neither surface can be created with multisampling. The only valid flag for both surfaces is D3DMULTISAMPLE_NONE. The surface format cannot be a depth stencil format. The source and dest rects must fit within the surface. No stretching or shrinking is allowed (the rects must be the same size). The source format must match the dest format.  The following table shows the supported combinations.  Dest formats TextureRT textureRTOff-screen plain Src formatsTextureYesYesYes*Yes RT textureNoNoNoNo RTNoNoNoNo Off-screen plainYesYesYesYes  ? * If the driver does not support the requested copy, it will be emulated using lock and copy. If the application needs to copy data from a D3DPOOL_DEFAULT render target to a D3DPOOL_SYSTEMMEM surface, it can use {{GetRenderTargetData}}. 	
        /// </remarks>	
        /// <param name="sourceSurfaceRef"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the source surface. This parameter must point to a different surface than pDestinationSurface.  </param>
        /// <param name="sourceRectRef"> Pointer to a rectangle on the source surface. Specifying NULL for this parameter causes the entire surface to be copied.  </param>
        /// <param name="destinationSurfaceRef"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the destination surface. </param>
        /// <param name="destPointRef"> Pointer to the upper left corner of the destination rectangle. Specifying NULL for this parameter causes the entire surface to be copied.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::UpdateSurface([None] IDirect3DSurface9* pSourceSurface,[None] const RECT* pSourceRect,[None] IDirect3DSurface9* pDestinationSurface,[None] const POINT* pDestPoint)</unmanaged>
        public SlimDX2.Result UpdateSurface(SlimDX2.Direct3D9.Surface sourceSurfaceRef, ref SlimDX2.Rectangle sourceRectRef, SlimDX2.Direct3D9.Surface destinationSurfaceRef, ref System.Drawing.Point destPointRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* sourceRectRef_ = &sourceRectRef)
                    fixed (void* destPointRef_ = &destPointRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 30 * 4, (void*)((sourceSurfaceRef == null)?IntPtr.Zero:sourceSurfaceRef.NativePointer), sourceRectRef_, (void*)((destinationSurfaceRef == null)?IntPtr.Zero:destinationSurfaceRef.NativePointer), destPointRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Updates the dirty portions of a texture.	
        /// </summary>	
        /// <remarks>	
        ///  You can dirty a portion of a texture by locking it, or by calling one of the following methods.    <see cref="SlimDX2.Direct3D9.CubeTexture.AddDirtyRect"/>   <see cref="SlimDX2.Direct3D9.Texture.AddDirtyRect"/>   <see cref="SlimDX2.Direct3D9.VolumeTexture.AddDirtyBox"/>   <see cref="SlimDX2.Direct3D9.Device.UpdateSurface"/>   IDirect3DDevice9::UpdateTexture retrieves the dirty portions of the texture by calculating what has been accumulated since the last update operation. For performance reasons, dirty regions are only recorded for level zero of a texture. For sublevels, it is assumed that the corresponding (scaled) rectangle or box is also dirty. Dirty regions are automatically recorded when LockRect or <see cref="SlimDX2.Direct3D9.VolumeTexture.LockBox"/> is called without D3DLOCK_NO_DIRTY_UPDATE or D3DLOCK_READONLY. Also, the destination surface of <see cref="SlimDX2.Direct3D9.Device.UpdateSurface"/> is marked dirty. This method fails if the textures are of different types, if their bottom-level buffers are of different sizes, or if their matching levels do not match. For example, consider a six-level source texture with the following dimensions.  	
        /// <code> 32x16, 16x8, 8x4, 4x2, 2x1, 1x1 </code>	
        /// 	
        ///  This six-level source texture could be the source for the following one-level destination.  	
        /// <code> 1x1 </code>	
        /// 	
        ///  For the following two-level destination.  	
        /// <code> 2x1, 1x1 </code>	
        /// 	
        ///  Or, for the following three-level destination.  	
        /// <code> 4x2, 2x1, 1x1 </code>	
        /// 	
        ///  In addition, this method will fail if the textures are of different formats. If the destination texture has fewer levels than the source, only the matching levels are copied. If the source texture has fewer levels than the destination, the method will fail.  If the source texture has dirty regions, the copy can be optimized by restricting the copy to only those regions. It is not guaranteed that only those bytes marked dirty will be copied. Here are the possibilities for source and destination surface combinations:  If pSourceTexture is a non-autogenerated mipmap and pDestinationTexture is an autogenerated mipmap, only the topmost matching level is updated, and the destination sublevels are regenerated. All other source sublevels are ignored. If both pSourceTexture and pDestinationTexture are autogenerated mipmaps, only the topmost matching level is updated. The sublevels from the source are ignored and the destination sublevels are regenerated. If pSourceTexture is an autogenerated mipmap and pDestinationTexture a non-autogenerated mipmap, UpdateTexture will fail.  	
        /// </remarks>	
        /// <param name="sourceTextureRef"> Pointer to an <see cref="SlimDX2.Direct3D9.BaseTexture"/> interface, representing the source texture. The source texture must be in system memory (D3DPOOL_SYSTEMMEM).  </param>
        /// <param name="destinationTextureRef"> Pointer to an <see cref="SlimDX2.Direct3D9.BaseTexture"/> interface, representing the destination texture. The destination texture must be in the D3DPOOL_DEFAULT memory pool.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::UpdateTexture([None] IDirect3DBaseTexture9* pSourceTexture,[None] IDirect3DBaseTexture9* pDestinationTexture)</unmanaged>
        public SlimDX2.Result UpdateTexture(SlimDX2.Direct3D9.BaseTexture sourceTextureRef, SlimDX2.Direct3D9.BaseTexture destinationTextureRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 31 * 4, (void*)((sourceTextureRef == null)?IntPtr.Zero:sourceTextureRef.NativePointer), (void*)((destinationTextureRef == null)?IntPtr.Zero:destinationTextureRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copies the render-target data from device memory to system memory.	
        /// </summary>	
        /// <remarks>	
        ///  The destination surface must be either an off-screen plain surface or a level of a texture (mipmap or cube texture) created with D3DPOOL_SYSTEMMEM. The source surface must be a regular render target or a level of a render-target texture (mipmap or cube texture) created with POOL_DEFAULT. This method will fail if:  The render target is multisampled. The source render target is a different size than the destination surface. The source render target and destination surface formats do not match.  	
        /// </remarks>	
        /// <param name="renderTargetRef"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> object, representing a render target.  </param>
        /// <param name="destSurfaceRef"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> object, representing a destination surface.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_DRIVERINTERNALERROR, D3DERR_DEVICELOST, D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetRenderTargetData([Out] IDirect3DSurface9* pRenderTarget,[Out] IDirect3DSurface9* pDestSurface)</unmanaged>
        public SlimDX2.Result GetRenderTargetData(out SlimDX2.Direct3D9.Surface renderTargetRef, out SlimDX2.Direct3D9.Surface destSurfaceRef) {
            unsafe {
                IntPtr renderTargetRef_ = IntPtr.Zero;
                IntPtr destSurfaceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 32 * 4, &renderTargetRef_, &destSurfaceRef_);
                renderTargetRef = (renderTargetRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(renderTargetRef_);	
                destSurfaceRef = (destSurfaceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(destSurfaceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Generates a copy of the device's front buffer and places that copy in a system memory buffer provided by the application. 	
        /// </summary>	
        /// <remarks>	
        ///  The buffer pointed to by pDestSurface will be filled with a representation of the front buffer, converted to the standard 32 bits per pixel format D3DFMT_A8R8G8B8.  This method is the only way to capture an antialiased screen shot. This function is very slow, by design, and should not be used in any performance-critical path. For more information, see {{Lost Devices and Retrieved Data}}. 	
        /// </remarks>	
        /// <param name="iSwapChain"> An unsigned integer specifying the swap chain. </param>
        /// <param name="destSurfaceRef"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface that will receive a copy of the contents of the front buffer. The data is returned in successive rows with no intervening space, starting from the vertically highest row on the device's output to the lowest.  For windowed mode, the size of the destination surface should be the size of the desktop. For full-screen mode, the size of the destination surface should be the screen size.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_DRIVERINTERNALERROR, D3DERR_DEVICELOST, D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetFrontBufferData([None] UINT iSwapChain,[Out] IDirect3DSurface9* pDestSurface)</unmanaged>
        public SlimDX2.Result GetFrontBufferData(int iSwapChain, out SlimDX2.Direct3D9.Surface destSurfaceRef) {
            unsafe {
                IntPtr destSurfaceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 33 * 4, iSwapChain, &destSurfaceRef_);
                destSurfaceRef = (destSurfaceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(destSurfaceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copy the contents of the source rectangle to the destination rectangle. The source rectangle can be stretched and filtered by the copy. This function is often used to change the aspect ratio of a video stream.	
        /// </summary>	
        /// <remarks>	
        ///  StretchRect Restrictions  Driver support varies. See the section on driver support (below) to see which drivers support which source and destination formats. The source and destination surfaces must be created in the default memory pool. If filtering is specified, you must set the appropriate filter caps (see StretchRectFilterCaps in <see cref="SlimDX2.Direct3D9.Capabilities"/>). Stretching is not supported between source and destination rectangles on the same surface. Stretching is not supported if the destination surface is an off-screen plain surface but the source is not. You many not stretch between source and destination rectangles if either surface is in a compressed format (see {{Using Compressed Textures (Direct3D 9)}}). Stretching supports color-space conversion from YUV to high-precision RGBA only. Since color conversion support is not supported by software emulation, use <see cref="SlimDX2.Direct3D9.Direct3D.CheckDeviceFormatConversion"/> to test the hardware for color conversion support. If the source or destination surface is a texture surface (or a cube texture surface), you must use a Direct3D 9 driver that supports D3DDEVCAPS2_CAN_STRETCHRECT_FROM_TEXTURES (see {{D3DDEVCAPS2}}).  Additional Restrictions for Depth and Stencil Surfaces  The source and destination surfaces must be plain depth stencil surfaces (not textures) (see <see cref="SlimDX2.Direct3D9.Device.CreateDepthStencilSurface"/>). Neither of the surfaces can be discardable. The entire surface must be copied (that is: sub-rectangle copies are not allowed). Format conversion, stretching, and shrinking are not supported. StretchRect cannot be called inside of a BeginScene/EndScene pair.  Using StretchRect to downsample a Multisample Rendertarget You can use StretchRect to copy from one rendertarget to another. If the source rendertarget is multisampled, this results in downsampling the source rendertarget. For instance you could:  Create a multisampled rendertarget. Create a second rendertarget of the same size, that is not multisampled. Copy (using StretchRect the multisample rendertarget to the second rendertarget.  Note that use of the extra surface involved in using StretchRect to downsample a Multisample Rendertarget will result in a performance hit. Driver Support There are many restrictions as to which surface combinations are valid for StretchRect. Factors include whether the driver is a Direct3D 9 driver or older, and whether the operation will result in stretching/shrinking.  Since applications are not expected to recognize if the driver is a Direct3D 9 driver or not, the runtime will automatically set a new cap, D3DDEVCAPS2_CAN_STRETCHRECT_FROM_TEXTURES cap (see {{D3DDEVCAPS2}}), for Direct3D 9-level drivers and above.  DirectX 8 Driver (no stretching) Dest formats TextureRT textureRTOff-screen plain Src formatsTextureNoNoNoNo RT textureNoYesYesNo RTNoYesYesNo Off-screen plainYesYesYesYes  ?  DirectX 8 Driver (stretching) Dest formats TextureRT textureRTOff-screen plain Src formatsTextureNoNoNoNo RT textureNoNoNoNo RTNoYesYesNo Off-screen plainNoYesYesNo  ?  Direct3D 9 Driver (no stretching) Dest formats TextureRT textureRTOff-screen plain Src formatsTextureNoYesYesNo RT textureNoYesYesNo RTNoYesYesNo Off-screen plainNoYesYesYes  ?  Direct3D 9 Driver (stretching) Dest formats TextureRT textureRTOff-screen plain Src formatsTextureNoYesYesNo RT textureNoYesYesNo RTNoYesYesNo Off-screen plainNoYesYesNo  ? 	
        /// </remarks>	
        /// <param name="sourceSurfaceRef"> Pointer to the source surface. See <see cref="SlimDX2.Direct3D9.Surface"/>. </param>
        /// <param name="sourceRectRef"> Pointer to the source rectangle. A NULL for this parameter causes the entire source surface to be used. </param>
        /// <param name="destSurfaceRef"> Pointer to the destination surface. See <see cref="SlimDX2.Direct3D9.Surface"/>. </param>
        /// <param name="destRectRef"> Pointer to the destination rectangle. A NULL for this parameter causes the entire destination surface to be used. </param>
        /// <param name="filter"> Filter type. Allowable values are D3DTEXF_NONE, D3DTEXF_POINT, or D3DTEXF_LINEAR. For more information, see <see cref="SlimDX2.Direct3D9.TextureFilter"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::StretchRect([None] IDirect3DSurface9* pSourceSurface,[None] const RECT* pSourceRect,[None] IDirect3DSurface9* pDestSurface,[None] const RECT* pDestRect,[None] D3DTEXTUREFILTERTYPE Filter)</unmanaged>
        public SlimDX2.Result StretchRect(SlimDX2.Direct3D9.Surface sourceSurfaceRef, ref SlimDX2.Rectangle sourceRectRef, SlimDX2.Direct3D9.Surface destSurfaceRef, ref SlimDX2.Rectangle destRectRef, SlimDX2.Direct3D9.TextureFilter filter) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* sourceRectRef_ = &sourceRectRef)
                    fixed (void* destRectRef_ = &destRectRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 34 * 4, (void*)((sourceSurfaceRef == null)?IntPtr.Zero:sourceSurfaceRef.NativePointer), sourceRectRef_, (void*)((destSurfaceRef == null)?IntPtr.Zero:destSurfaceRef.NativePointer), destRectRef_, unchecked((int)filter));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Allows an application to fill a rectangular area of a D3DPOOL_DEFAULT surface with a specified color.	
        /// </summary>	
        /// <remarks>	
        ///  This method can only be applied to a render target, a render-target texture surface, or an off-screen plain surface with a pool type of D3DPOOL_DEFAULT. IDirect3DDevice9::ColorFill will work with all formats. However, when using a reference or software device, the only formats supported are D3DFMT_X1R5G5B5, D3DFMT_A1R5G5B5, D3DFMT_R5G6B5, D3DFMT_X8R8G8B8, D3DFMT_A8R8G8B8, D3DFMT_YUY2, D3DFMT_G8R8_G8B8, D3DFMT_UYVY, D3DFMT_R8G8_B8G8, D3DFMT_R16F, D3DFMT_G16R16F, D3DFMT_A16B16G16R16F, D3DFMT_R32F, D3DFMT_G32R32F, and D3DFMT_A32B32G32R32F. When using a DirectX 7 or DirectX 8.x driver, the only YUV formats supported are D3DFMT_UYVY and D3DFMT_YUY2. 	
        /// </remarks>	
        /// <param name="surfaceRef"> Pointer to the surface to be filled. </param>
        /// <param name="rectRef"> Pointer to the source rectangle. Using NULL means that the entire surface will be filled. </param>
        /// <param name="color"> Color used for filling. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::ColorFill([None] IDirect3DSurface9* pSurface,[In, Optional] const RECT* pRect,[None] D3DCOLOR color)</unmanaged>
        public SlimDX2.Result ColorFill(SlimDX2.Direct3D9.Surface surfaceRef, SlimDX2.Rectangle? rectRef, SlimMath.Color4 color) {
            unsafe {
                SlimDX2.Rectangle rectRef_;
                if (rectRef.HasValue)
                    rectRef_ = rectRef.Value;				
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 35 * 4, (void*)((surfaceRef == null)?IntPtr.Zero:surfaceRef.NativePointer), (rectRef.HasValue)?&rectRef_:(void*)IntPtr.Zero, color.ToArgb());
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create an off-screen surface.	
        /// </summary>	
        /// <remarks>	
        ///  D3DPOOL_SCRATCH will return a surface that has identical characteristics to a surface created by the DirectX 8.x method CreateImageSurface. D3DPOOL_DEFAULT is the appropriate pool for use with the <see cref="SlimDX2.Direct3D9.Device.StretchRect"/> and <see cref="SlimDX2.Direct3D9.Device.ColorFill"/>. D3DPOOL_MANAGED is not allowed when creating an offscreen plain surface. For more information about memory pools, see <see cref="SlimDX2.Direct3D9.Pool"/>. Off-screen plain surfaces are always lockable, regardless of their pool types. 	
        /// </remarks>	
        /// <param name="width"> Width of the surface. </param>
        /// <param name="height"> Height of the surface. </param>
        /// <param name="format"> Format of the surface. See <see cref="SlimDX2.Direct3D9.Format"/>.  </param>
        /// <param name="pool"> Surface pool type. See <see cref="SlimDX2.Direct3D9.Pool"/>. </param>
        /// <param name="surfaceRef"> Pointer to the <see cref="SlimDX2.Direct3D9.Surface"/> interface created. </param>
        /// <param name="sharedHandleRef"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateOffscreenPlainSurface([None] UINT Width,[None] UINT Height,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] IDirect3DSurface9** ppSurface,[None] HANDLE* pSharedHandle)</unmanaged>
        internal SlimDX2.Result CreateOffscreenPlainSurface(int width, int height, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.Surface surfaceRef, IntPtr sharedHandleRef) {
            unsafe {
                IntPtr surfaceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 36 * 4, width, height, unchecked((int)format), unchecked((int)pool), &surfaceRef_, (void*)sharedHandleRef);
                surfaceRef = (surfaceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(surfaceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a new color buffer for the device.	
        /// </summary>	
        /// <remarks>	
        ///  The device can support multiple render targets. The number of render targets supported by a device is contained in the NumSimultaneousRTs member of <see cref="SlimDX2.Direct3D9.Capabilities"/>. See {{Multiple Render Targets (Direct3D 9)}}. Setting a new render target will cause the viewport (see {{Viewports and Clipping (Direct3D 9)}}) to be set to the full size of the new render target. Some hardware tests the compatibility of the depth stencil buffer with the color buffer. If this is done, it is only done in a debug build. Restrictions for using this method include the following:  The multisample type must be the same for the render target and the depth stencil surface. The formats must be compatible for the render target and the depth stencil surface. See <see cref="SlimDX2.Direct3D9.Direct3D.CheckDepthStencilMatch"/>. The size of the depth stencil surface must be greater than or equal to the size of the render target.  These restrictions are validated only when using the debug runtime when any of the <see cref="SlimDX2.Direct3D9.Device"/> Draw methods are called. Cube textures differ from other surfaces in that they are collections of surfaces. To call IDirect3DDevice9::SetRenderTarget with a cube texture, you must select an individual face using <see cref="SlimDX2.Direct3D9.CubeTexture.GetCubeMapSurface"/> and pass the resulting surface to IDirect3DDevice9::SetRenderTarget.  	
        /// </remarks>	
        /// <param name="renderTargetIndex"> Index of the render target. See Remarks. </param>
        /// <param name="renderTargetRef"> Pointer to a new color buffer. If NULL, the color buffer for the corresponding RenderTargetIndex is disabled. Devices always must be associated with a color buffer. The new render-target surface must have at least D3DUSAGE_RENDERTARGET specified. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. This method will return D3DERR_INVALIDCALL if either:  pRenderTarget = NULL and RenderTargetIndex = 0 pRenderTarget is != NULL and the render target is invalid.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetRenderTarget([None] int RenderTargetIndex,[None] IDirect3DSurface9* pRenderTarget)</unmanaged>
        public SlimDX2.Result SetRenderTarget(int renderTargetIndex, SlimDX2.Direct3D9.Surface renderTargetRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 37 * 4, renderTargetIndex, (void*)((renderTargetRef == null)?IntPtr.Zero:renderTargetRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a render-target surface.	
        /// </summary>	
        /// <remarks>	
        ///  Typically, methods that return state will not work on a device that is created using D3DCREATE_PUREDEVICE. This method however, will work even on a pure device because it returns an interface. The device can now support multiple render targets. The number of render targets supported by a device is contained in the NumSimultaneousRTs member of <see cref="SlimDX2.Direct3D9.Capabilities"/>. See {{Multiple Render Targets (Direct3D 9)}}. Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using the IDirect3DSurface9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="renderTargetIndex"> Index of the render target. See Remarks. </param>
        /// <param name="renderTargetRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the returned render-target surface for this device.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL if one of the arguments is invalid, or D3DERR_NOTFOUND if there's no render target available for the given index.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetRenderTarget([None] int RenderTargetIndex,[Out] IDirect3DSurface9** ppRenderTarget)</unmanaged>
        public SlimDX2.Result GetRenderTarget(int renderTargetIndex, out SlimDX2.Direct3D9.Surface renderTargetRef) {
            unsafe {
                IntPtr renderTargetRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 38 * 4, renderTargetIndex, &renderTargetRef_);
                renderTargetRef = (renderTargetRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(renderTargetRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the depth stencil surface.	
        /// </summary>	
        /// <remarks>	
        ///  Restrictions for using this method include the following:  The multisample type must be the same for the render target and the depth stencil surface. The formats must be compatible for the render target and the depth stencil surface. See <see cref="SlimDX2.Direct3D9.Direct3D.CheckDepthStencilMatch"/>. The size of the depth stencil surface must be greater than or equal to the size of the render target.  These restrictions are validated only when using the debug runtime when any of the <see cref="SlimDX2.Direct3D9.Device"/> Draw methods are called. Cube textures differ from other surfaces in that they are collections of surfaces. To call IDirect3DDevice9::SetDepthStencilSurface with a cube texture, you must select an individual face using <see cref="SlimDX2.Direct3D9.CubeTexture.GetCubeMapSurface"/> and pass the resulting surface to IDirect3DDevice9::SetDepthStencilSurface.  	
        /// </remarks>	
        /// <param name="newZStencilRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface representing the depth stencil surface. Setting this to NULL disables the depth stencil operation. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If pZStencilSurface is other than NULL, the return value is D3DERR_INVALIDCALL when the stencil surface is invalid.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetDepthStencilSurface([None] IDirect3DSurface9* pNewZStencil)</unmanaged>
        internal SlimDX2.Result SetDepthStencilSurface(SlimDX2.Direct3D9.Surface newZStencilRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 39 * 4, (void*)((newZStencilRef == null)?IntPtr.Zero:newZStencilRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the depth-stencil surface owned by the Direct3DDevice object.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DSurface9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="zStencilSurfaceRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the returned depth-stencil surface.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK.If the device doesn't have a depth stencil buffer associated with it, the return value will be D3DERR_NOTFOUND. Otherwise, if the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetDepthStencilSurface([Out] IDirect3DSurface9** ppZStencilSurface)</unmanaged>
        internal SlimDX2.Result GetDepthStencilSurface(out SlimDX2.Direct3D9.Surface zStencilSurfaceRef) {
            unsafe {
                IntPtr zStencilSurfaceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 40 * 4, &zStencilSurfaceRef_);
                zStencilSurfaceRef = (zStencilSurfaceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(zStencilSurfaceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Begins a scene. 	
        /// </summary>	
        /// <remarks>	
        ///  Applications must call IDirect3DDevice9::BeginScene before performing any rendering and must call <see cref="SlimDX2.Direct3D9.Device.EndScene"/> when rendering is complete and before calling IDirect3DDevice9::BeginScene again. If IDirect3DDevice9::BeginScene fails, the device was unable to begin the scene, and there is no need to  call <see cref="SlimDX2.Direct3D9.Device.EndScene"/>. In fact, calls to IDirect3DDevice9::EndScene will fail if the  previous IDirect3DDevice9::BeginScene failed. This applies to any application that creates multiple swap chains. There should be one IDirect3DDevice9::BeginScene/<see cref="SlimDX2.Direct3D9.Device.EndScene"/> pair between any successive calls to  present (either <see cref="SlimDX2.Direct3D9.Device.Present"/> or <see cref="SlimDX2.Direct3D9.SwapChain.Present"/>). IDirect3DDevice9::BeginScene should  be called once before any rendering is performed, and IDirect3DDevice9::EndScene should be called once after all rendering for a frame has been submitted to the runtime. Multiple non-nested IDirect3DDevice9::BeginScene/IDirect3DDevice9::EndScene pairs between calls to present are legal, but having more than one pair may incur a performance hit. To enable maximal parallelism between the CPU and the graphics accelerator, it is advantageous to  call IDirect3DDevice9::EndScene as far ahead of calling present as possible. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. The method will fail with D3DERR_INVALIDCALL if IDirect3DDevice9::BeginScene is called  while already in a IDirect3DDevice9::BeginScene/<see cref="SlimDX2.Direct3D9.Device.EndScene"/> pair. This happens only  when IDirect3DDevice9::BeginScene is called twice without first calling IDirect3DDevice9::EndScene. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::BeginScene()</unmanaged>
        public SlimDX2.Result BeginScene() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 41 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Ends a scene that was begun by calling <see cref="SlimDX2.Direct3D9.Device.BeginScene"/>.	
        /// </summary>	
        /// <remarks>	
        ///  When this method succeeds, the scene has been queued up for rendering by the driver. This is not a synchronous method, so the scene is not guaranteed to have completed rendering when this method returns. Applications must call <see cref="SlimDX2.Direct3D9.Device.BeginScene"/> before performing any rendering and must call IDirect3DDevice9::EndScene when rendering is complete and before calling IDirect3DDevice9::BeginScene again. If <see cref="SlimDX2.Direct3D9.Device.BeginScene"/> fails, the device was unable to begin the scene, and there is no need to call IDirect3DDevice9::EndScene. In fact, calls to  IDirect3DDevice9::EndScene will fail if the previous IDirect3DDevice9::BeginScene failed. This applies to any application that creates multiple swap chains. There should be at most one <see cref="SlimDX2.Direct3D9.Device.BeginScene"/>/IDirect3DDevice9::EndScene pair between any successive calls to present (either <see cref="SlimDX2.Direct3D9.Device.Present"/> or <see cref="SlimDX2.Direct3D9.SwapChain.Present"/>). IDirect3DDevice9::BeginScene should be called once before any rendering is performed, and IDirect3DDevice9::EndScene should be called once after all rendering for a frame has been submitted to the runtime. To enable maximal parallelism between the CPU and the graphics accelerator, it is advantageous to call IDirect3DDevice9::EndScene as far ahead of calling present as possible. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. The method will fail with D3DERR_INVALIDCALL if <see cref="SlimDX2.Direct3D9.Device.BeginScene"/> is called while already in a IDirect3DDevice9::BeginScene/IDirect3DDevice9::EndScene pair. This happens only when IDirect3DDevice9::BeginScene is called twice without first calling IDirect3DDevice9::EndScene. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::EndScene()</unmanaged>
        public SlimDX2.Result EndScene() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 42 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Clears one or more surfaces such as a render target, {{multiple render targets}}, a stencil buffer, and a depth buffer.	
        /// </summary>	
        /// <remarks>	
        ///  Use this method to clear a surface including: a render target, all render targets in an MRT, a stencil buffer, or a depth buffer. Flags determines how many surfaces are cleared. Use pRects to clear a subset of a surface defined by an array of rectangles. IDirect3DDevice9::Clear will fail if you:  Try to clear either the depth buffer or the stencil buffer of a render target that does not have an attached depth buffer. Try to clear the stencil buffer when the depth buffer does not contain stencil data.  	
        /// </remarks>	
        /// <param name="count"> Number of rectangles in the array at pRects. Must be set to 0 if pRects is NULL. May not be 0 if pRects is a valid pointer. </param>
        /// <param name="rectsRef"> Pointer to an array of <see cref="SlimDX2.Rectangle"/> structures that describe the rectangles to clear. Set a rectangle to the dimensions of the rendering target to clear the entire surface. Each rectangle uses screen coordinates that correspond to points on the render target. Coordinates are clipped to the bounds of the viewport rectangle. To indicate that the entire viewport rectangle is to be cleared, set this parameter to NULL and Count to 0. </param>
        /// <param name="flags"> Combination of one or more {{D3DCLEAR}} flags that specify the surface(s) that will be cleared. </param>
        /// <param name="color"> Clear a render target to this ARGB color. </param>
        /// <param name="z"> Clear the depth buffer to this new z value which ranges from 0 to 1. See remarks. </param>
        /// <param name="stencil"> Clear the stencil buffer to this new value which ranges from 0 to 2n - 1 (n is the bit depth of the stencil buffer). See remarks.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::Clear([None] int Count,[In, Buffer, Optional] const D3DRECT* pRects,[None] int Flags,[None] D3DCOLOR Color,[None] float Z,[None] int Stencil)</unmanaged>
        internal SlimDX2.Result Clear_(int count, SlimDX2.Rectangle[] rectsRef, SlimDX2.Direct3D9.ClearFlags flags, SlimMath.Color4 color, float z, int stencil) {
            unsafe {
                SlimDX2.Rectangle[] rectsRef__ = rectsRef ?? new SlimDX2.Rectangle[1];
                SlimDX2.Result __result__;
                fixed (void* rectsRef_ = &rectsRef__[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 43 * 4, count, rectsRef==null?(void*)IntPtr.Zero:rectsRef_, unchecked((int)flags), color.ToArgb(), z, stencil);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a single device transformation-related state.	
        /// </summary>	
        /// <param name="state"> Device-state variable that is being modified. This parameter can be any member of the <see cref="SlimDX2.Direct3D9.TransformState"/> enumerated type, or the {{D3DTS_WORLDMATRIX}} macro.  </param>
        /// <param name="matrixRef"> Pointer to a <see cref="SlimMath.Matrix"/> structure that modifies the current transformation.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one of the arguments is invalid.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetTransform([None] D3DTRANSFORMSTATETYPE State,[None] const D3DMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result SetTransform(SlimDX2.Direct3D9.TransformState state, ref SlimMath.Matrix matrixRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 44 * 4, unchecked((int)state), matrixRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a matrix describing a transformation state.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other flag values in {{D3DCREATE}}.  	
        /// </remarks>	
        /// <param name="state"> Device state variable that is being modified. This parameter can be any member of the <see cref="SlimDX2.Direct3D9.TransformState"/> enumerated type, or the {{D3DTS_WORLDMATRIX}} macro.  </param>
        /// <param name="matrixRef"> Pointer to a  <see cref="SlimMath.Matrix"/> structure, describing the returned transformation state.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL if one of the arguments is invalid.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetTransform([None] D3DTRANSFORMSTATETYPE State,[Out] D3DMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result GetTransform(SlimDX2.Direct3D9.TransformState state, out SlimMath.Matrix matrixRef) {
            unsafe {
                matrixRef = new SlimMath.Matrix();
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 45 * 4, unchecked((int)state), matrixRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Multiplies a device's world, view, or projection matrices by a specified matrix. 	
        /// </summary>	
        /// <remarks>	
        ///  The multiplication order is pMatrix times State. An application might use the IDirect3DDevice9::MultiplyTransform method to work with hierarchies of transformations. For example, the geometry and transformations describing an arm might be arranged in the following hierarchy. 	
        /// <code> shoulder_transformation upper_arm geometry elbow transformation lower_arm geometry wrist transformation hand geometry </code>	
        /// 	
        ///  An application might use the following series of calls to render this hierarchy. Not all the parameters are shown in this pseudocode.  	
        /// <code> IDirect3DDevice9::SetTransform(D3DTS_WORLDMATRIX(0),  shoulder_transform)	
        /// IDirect3DDevice9::DrawPrimitive(upper_arm)	
        /// IDirect3DDevice9::MultiplyTransform(D3DTS_WORLDMATRIX(0),  elbow_transform)	
        /// IDirect3DDevice9::DrawPrimitive(lower_arm)	
        /// IDirect3DDevice9::MultiplyTransform(D3DTS_WORLDMATRIX(0),  wrist_transform)	
        /// IDirect3DDevice9::DrawPrimitive(hand) </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="arg0"> Member of the <see cref="SlimDX2.Direct3D9.TransformState"/> enumerated type, or the {{D3DTS_WORLDMATRIX}} macro that identifies which device matrix is to be modified. The most common setting, D3DTS_WORLDMATRIX(0), modifies the world matrix, but you can specify that the method modify the view or projection matrices, if needed.  </param>
        /// <param name="arg1"> Pointer to a <see cref="SlimMath.Matrix"/> structure that modifies the current transformation.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL if one of the arguments is invalid.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::MultiplyTransform([None] D3DTRANSFORMSTATETYPE arg0,[None] const D3DMATRIX* arg1)</unmanaged>
        public SlimDX2.Result MultiplyTransform(SlimDX2.Direct3D9.TransformState arg0, ref SlimMath.Matrix arg1) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* arg1_ = &arg1)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 46 * 4, unchecked((int)arg0), arg1_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the viewport parameters for the device.	
        /// </summary>	
        /// <remarks>	
        ///  Direct3D sets the following default values for the viewport.  	
        /// <code> D3DVIEWPORT9 vp;	
        /// vp.X      = 0;	
        /// vp.Y      = 0;	
        /// vp.Width  = RenderTarget.Width;	
        /// vp.Height = RenderTarget.Height;	
        /// vp.MinZ   = 0.0f;	
        /// vp.MaxZ   = 1.0f; </code>	
        /// 	
        ///  IDirect3DDevice9::SetViewport can be used to draw on part of the screen. Make sure to call it before any geometry is drawn so the viewport settings will take effect. To draw multiple views within a scene, repeat the IDirect3DDevice9::SetViewport and draw geometry sequence for each view. 	
        /// </remarks>	
        /// <param name="viewportRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Viewport"/> structure, specifying the viewport parameters to set.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, it will return D3DERR_INVALIDCALL. This will happen if pViewport is invalid, or if pViewport describes a region that cannot exist within the render target surface. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetViewport([None] const D3DVIEWPORT9* pViewport)</unmanaged>
        internal SlimDX2.Result SetViewport(ref SlimDX2.Direct3D9.Viewport viewportRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* viewportRef_ = &viewportRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 47 * 4, viewportRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the viewport parameters currently set for the device.	
        /// </summary>	
        /// <remarks>	
        ///  Typically, methods that return state will not work on a device that is created using D3DCREATE_PUREDEVICE. This method however, will work even on a pure device. 	
        /// </remarks>	
        /// <param name="viewportRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Viewport"/> structure, representing the returned viewport parameters.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the pViewport parameter is invalid.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetViewport([Out] D3DVIEWPORT9* pViewport)</unmanaged>
        internal SlimDX2.Result GetViewport(out SlimDX2.Direct3D9.Viewport viewportRef) {
            unsafe {
                viewportRef = new SlimDX2.Direct3D9.Viewport();
                SlimDX2.Result __result__;
                fixed (void* viewportRef_ = &viewportRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 48 * 4, viewportRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the material properties for the device.	
        /// </summary>	
        /// <param name="materialRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Material"/> structure, describing the material properties to set.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL if the pMaterial parameter is invalid.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetMaterial([None] const D3DMATERIAL9* pMaterial)</unmanaged>
        internal SlimDX2.Result SetMaterial(ref SlimDX2.Direct3D9.Material materialRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* materialRef_ = &materialRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 49 * 4, materialRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the current material properties for the device.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other values in {{D3DCREATE}}.  	
        /// </remarks>	
        /// <param name="materialRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Material"/> structure to fill with the currently set material properties.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL if the pMaterial parameter is invalid.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetMaterial([Out] D3DMATERIAL9* pMaterial)</unmanaged>
        internal SlimDX2.Result GetMaterial(out SlimDX2.Direct3D9.Material materialRef) {
            unsafe {
                materialRef = new SlimDX2.Direct3D9.Material();
                SlimDX2.Result __result__;
                fixed (void* materialRef_ = &materialRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 50 * 4, materialRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Assigns a set of lighting properties for this device.	
        /// </summary>	
        /// <remarks>	
        ///  Set light properties by preparing a <see cref="SlimDX2.Direct3D9.Light"/> structure and then calling the IDirect3DDevice9::SetLight method. The  IDirect3DDevice9::SetLight method accepts the index at which the device should place the set of light properties to its internal list of light properties, and the address of a prepared D3DLIGHT9 structure that defines those properties. You can call IDirect3DDevice9::SetLight with new information as needed to update the light's illumination properties. The system allocates memory to accommodate a set of lighting properties each time you call the IDirect3DDevice9::SetLight method with an index that has never been assigned properties. Applications can set a number of lights, with only a subset of the assigned lights enabled at a time. Check the MaxActiveLights member of the <see cref="SlimDX2.Direct3D9.Capabilities"/> structure when you retrieve device capabilities to determine the maximum number of active lights supported by that device. If you no longer need a light, you can disable it or overwrite it with a new set of light properties. The following example prepares and sets properties for a white point-light whose emitted light will not attenuate over distance. 	
        /// <code> // Assume d3dDevice is a valid pointer to an IDirect3DDevice9 interface.	
        /// D3DLight9 d3dLight;	
        /// HRESULT   hr; // Initialize the structure.	
        /// ZeroMemory(&amp;D3dLight, sizeof(d3dLight)); // Set up a white point light.	
        /// d3dLight.Type = D3DLIGHT_POINT;	
        /// d3dLight.Diffuse.r  = 1.0f;	
        /// d3dLight.Diffuse.g  = 1.0f;	
        /// d3dLight.Diffuse.b  = 1.0f;	
        /// d3dLight.Ambient.r  = 1.0f;	
        /// d3dLight.Ambient.g  = 1.0f;	
        /// d3dLight.Ambient.b  = 1.0f;	
        /// d3dLight.Specular.r = 1.0f;	
        /// d3dLight.Specular.g = 1.0f;	
        /// d3dLight.Specular.b = 1.0f; // Position it high in the scene and behind the user.	
        /// // Remember, these coordinates are in world space, so	
        /// // the user could be anywhere in world space, too. 	
        /// // For the purposes of this example, assume the user	
        /// // is at the origin of world space.	
        /// d3dLight.Position.x = 0.0f;	
        /// d3dLight.Position.y = 1000.0f;	
        /// d3dLight.Position.z = -100.0f; // Don't attenuate.	
        /// d3dLight.Attenuation0 = 1.0f; 	
        /// d3dLight.Range        = 1000.0f; // Set the property information for the first light.	
        /// hr = d3dDevice-&gt;SetLight(0, &amp;d3dLight);	
        /// if (SUCCEEDED(hr)) // Handle Success	
        /// else // Handle failure </code>	
        /// 	
        ///  Enable a light source by calling the <see cref="SlimDX2.Direct3D9.Device.LightEnable"/> method for the device. 	
        /// </remarks>	
        /// <param name="index"> Zero-based index of the set of lighting properties to set. If a set of lighting properties exists at this index, it is overwritten by the new properties specified in pLight.  </param>
        /// <param name="arg1"> Pointer to a <see cref="SlimDX2.Direct3D9.Light"/> structure, containing the lighting parameters to set.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetLight([None] int Index,[None] const D3DLIGHT9* arg1)</unmanaged>
        public SlimDX2.Result SetLight(int index, ref SlimDX2.Direct3D9.Light arg1) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* arg1_ = &arg1)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 51 * 4, index, arg1_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a set of lighting properties that this device uses.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other values in {{D3DCREATE}}. Retrieve all the properties for an existing light source by calling the IDirect3DDevice9::GetLight method for the device. When calling the IDirect3DDevice9::GetLight method, pass the zero-based index of the light source for which the properties will be retrieved as the first parameter, and supply the address of a <see cref="SlimDX2.Direct3D9.Light"/> structure as the second parameter. The device fills the D3DLIGHT9 structure to describe the lighting properties it uses for the light source at that index. 	
        /// <code> // Assume d3dDevice is a valid pointer to an IDirect3DDevice9 interface.	
        /// HRESULT hr;	
        /// D3DLight9 light; // Get the property information for the first light.	
        /// hr = pd3dDevice-&gt;GetLight(0, &amp;light);	
        /// if (SUCCEEDED(hr)) // Handle Success	
        /// else // Handle failure </code>	
        /// 	
        ///  If you supply an index outside the range of the light sources assigned in the device, the IDirect3DDevice9::GetLight method fails, returning D3DERR_INVALIDCALL. When you assign a set of light properties for a light source in a scene, the light source can be activated by calling the <see cref="SlimDX2.Direct3D9.Device.LightEnable"/> method for the device. New light sources are disabled by default. The IDirect3DDevice9::LightEnable method accepts two parameters. Set the first parameter to the zero-based index of the light source to be affected by the method, and set the second parameter to TRUE to enable the light or FALSE to disable it. The following code example illustrates the use of this method by enabling the first light source in the device's list of light source properties. 	
        /// <code> // Assume d3dDevice is a valid pointer to an IDirect3DDevice9 interface.	
        /// HRESULT hr; hr = pd3dDevice-&gt;LightEnable(0, TRUE);	
        /// if (SUCCEEDED(hr)) // Handle Success	
        /// else // Handle failure </code>	
        /// 	
        ///  Check the MaxActiveLights member of the <see cref="SlimDX2.Direct3D9.Capabilities"/> structure when you retrieve device capabilities to determine the maximum number of active lights supported by that device. If you enable or disable a light that has no properties that are set with <see cref="SlimDX2.Direct3D9.Device.SetLight"/>, the <see cref="SlimDX2.Direct3D9.Device.LightEnable"/> method creates a light source with the properties listed in following table and enables or disables it. 	
        /// </remarks>	
        /// <param name="index"> Zero-based index of the lighting property set to retrieve. This method will fail if a lighting property has not been set for this index by calling the <see cref="SlimDX2.Direct3D9.Device.SetLight"/> method.  </param>
        /// <param name="arg1"> Pointer to a <see cref="SlimDX2.Direct3D9.Light"/> structure that is filled with the retrieved lighting-parameter set.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetLight([None] int Index,[Out] D3DLIGHT9* arg1)</unmanaged>
        public SlimDX2.Result GetLight(int index, out SlimDX2.Direct3D9.Light arg1) {
            unsafe {
                arg1 = new SlimDX2.Direct3D9.Light();
                SlimDX2.Result __result__;
                fixed (void* arg1_ = &arg1)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 52 * 4, index, arg1_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Enables or disables a set of lighting parameters within a device.	
        /// </summary>	
        /// <remarks>	
        ///  If a value for LightIndex is outside the range of the light property sets assigned within the device, the IDirect3DDevice9::LightEnable method creates a light source represented by a <see cref="SlimDX2.Direct3D9.Light"/> structure with the following properties and sets its enabled state to the value specified in bEnable.  MemberDefault  Type D3DLIGHT_DIRECTIONAL  Diffuse (R:1, G:1, B:1, A:0)  Specular (R:0, G:0, B:0, A:0)  Ambient (R:0, G:0, B:0, A:0)  Position (0, 0, 0)  Direction (0, 0, 1)  Range 0  Falloff 0  Attenuation0 0  Attenuation1 0  Attenuation2 0  Theta 0  Phi 0  ? 	
        /// </remarks>	
        /// <param name="index"> Zero-based index of the set of lighting parameters that are the target of this method.  </param>
        /// <param name="enable"> Value that indicates if the set of lighting parameters are being enabled or disabled. Set this parameter to TRUE to enable lighting with the parameters at the specified index, or FALSE to disable it.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::LightEnable([None] int Index,[None] BOOL Enable)</unmanaged>
        public SlimDX2.Result LightEnable(int index, bool enable) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 53 * 4, index, (enable?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the activity status - enabled or disabled - for a set of lighting parameters within a device.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other values in {{D3DCREATE}}.  	
        /// </remarks>	
        /// <param name="index"> Zero-based index of the set of lighting parameters that are the target of this method.  </param>
        /// <param name="enableRef"> Pointer to a variable to fill with the status of the specified lighting parameters. After the call, a nonzero value at this address indicates that the specified lighting parameters are enabled; a value of 0 indicates that they are disabled.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetLightEnable([None] int Index,[Out] BOOL* pEnable)</unmanaged>
        public SlimDX2.Result GetLightEnable(int index, out bool enableRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* enableRef_ = &enableRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 54 * 4, index, enableRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the coefficients of a user-defined clipping plane for the device.	
        /// </summary>	
        /// <remarks>	
        ///  The coefficients that this method sets take the form of the general plane equation. If the values in the array at pPlane were labeled A, B, C, and D in the order that they appear in the array, they would fit into the general plane equation so that Ax + By + Cz + Dw = 0. A point with homogeneous coordinates (x, y, z, w) is visible in the half space of the plane if Ax + By + Cz + Dw &gt;= 0. Points that exist behind the clipping plane are clipped from the scene. When the fixed function pipeline is used the plane equations are assumed to be in world space. When the programmable pipeline is used the plane equations are assumed to be in the clipping space (the same space as output vertices). This method does not enable the clipping plane equation being set. To enable a clipping plane, set the corresponding bit in the DWORD value applied to the D3DRS_CLIPPLANEENABLE render state. 	
        /// </remarks>	
        /// <param name="index"> Index of the clipping plane for which the plane equation coefficients are to be set.  </param>
        /// <param name="laneRef"> Pointer to an address of a four-element array of values that represent the clipping plane coefficients to be set, in the form of the general plane equation. See Remarks.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value is D3DERR_INVALIDCALL. This error indicates that the value in Index exceeds the maximum clipping plane index supported by the device or that the array at pPlane is not large enough to contain four floating-point values.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetClipPlane([None] int Index,[None] const float* pPlane)</unmanaged>
        public SlimDX2.Result SetClipPlane(int index, ref float laneRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* laneRef_ = &laneRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 55 * 4, index, laneRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the coefficients of a user-defined clipping plane for the device.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other values in {{D3DCREATE}}."  The coefficients that this method reports take the form of the general plane equation. If the values in the array at pPlane were labeled A, B, C, and D in the order that they appear in the array, they would fit into the general plane equation so that Ax + By + Cz + Dw = 0. A point with homogeneous coordinates (x, y, z, w) is visible in the half space of the plane if Ax + By + Cz + Dw &gt;= 0. Points that exist on or behind the clipping plane are clipped from the scene. The plane equation used by this method exists in world space and is set by a previous call to the <see cref="SlimDX2.Direct3D9.Device.SetClipPlane"/> method. 	
        /// </remarks>	
        /// <param name="index"> Index of the clipping plane for which the plane equation coefficients are retrieved.  </param>
        /// <param name="laneRef"> Pointer to a four-element array of values that represent the coefficients of the clipping plane in the form of the general plane equation. See Remarks.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value is D3DERR_INVALIDCALL. This error indicates that the value in Index exceeds the maximum clipping plane index supported by the device, or that the array at pPlane is not large enough to contain four floating-point values. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetClipPlane([None] int Index,[Out] float* pPlane)</unmanaged>
        public SlimDX2.Result GetClipPlane(int index, out float laneRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* laneRef_ = &laneRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 56 * 4, index, laneRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a single device render-state parameter.	
        /// </summary>	
        /// <param name="state"> Device state variable that is being modified. This parameter can be any member of the <see cref="SlimDX2.Direct3D9.RenderState"/> enumerated type.  </param>
        /// <param name="value"> New value for the device render state to be set. The meaning of this parameter is dependent on the value specified for State. For example, if State were D3DRS_SHADEMODE, the second parameter would be one member of the <see cref="SlimDX2.Direct3D9.ShadeMode"/> enumerated type.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one of the arguments is invalid.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetRenderState([None] D3DRENDERSTATETYPE State,[None] int Value)</unmanaged>
        public SlimDX2.Result SetRenderState(SlimDX2.Direct3D9.RenderState state, int value) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 57 * 4, unchecked((int)state), value);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a render-state value for a device.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other values in {{D3DCREATE}}."  	
        /// </remarks>	
        /// <param name="state"> Device state variable that is being queried. This parameter can be any member of the <see cref="SlimDX2.Direct3D9.RenderState"/> enumerated type.  </param>
        /// <param name="valueRef"> Pointer to a variable that receives the value of the queried render state variable when the method returns.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL if one of the arguments is invalid.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetRenderState([None] D3DRENDERSTATETYPE State,[Out] int* pValue)</unmanaged>
        public SlimDX2.Result GetRenderState(SlimDX2.Direct3D9.RenderState state, out int valueRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* valueRef_ = &valueRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 58 * 4, unchecked((int)state), valueRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a new state block that contains the values for all device states, vertex-related states, or pixel-related states.	
        /// </summary>	
        /// <remarks>	
        ///  Vertex-related device states typically refer to those states that affect how the system processes vertices. Pixel-related states generally refer to device states that affect how the system processes pixel or depth-buffer data during rasterization. Some states are contained in both groups.    Differences between Direct3D 9 and Direct3D 10: In Direct3D 9, a state block contains state data, for the states it was requested to capture, when the object is created. To change the value of the state block, call <see cref="SlimDX2.Direct3D9.StateBlock.Capture"/> or <see cref="SlimDX2.Direct3D9.Device.BeginStateBlock"/>/<see cref="SlimDX2.Direct3D9.Device.EndStateBlock"/>. There is no state saved when a state block object is created in Direct3D 10.   ? 	
        /// </remarks>	
        /// <param name="type"> Type of state data that the method should capture. This parameter can be set to a value defined in the <see cref="SlimDX2.Direct3D9.StateBlockType"/> enumerated type.  </param>
        /// <param name="sBRef"> Pointer to a state block interface. See <see cref="SlimDX2.Direct3D9.StateBlock"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateStateBlock([None] D3DSTATEBLOCKTYPE Type,[None] IDirect3DStateBlock9** ppSB)</unmanaged>
        internal SlimDX2.Result CreateStateBlock(SlimDX2.Direct3D9.StateBlockType type, out SlimDX2.Direct3D9.StateBlock sBRef) {
            unsafe {
                IntPtr sBRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 59 * 4, unchecked((int)type), &sBRef_);
                sBRef = (sBRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.StateBlock(sBRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Signals Direct3D to begin recording a device-state block.	
        /// </summary>	
        /// <remarks>	
        ///  Applications can ensure that all recorded states are valid by calling the <see cref="SlimDX2.Direct3D9.Device.ValidateDevice"/> method prior to calling this method. The following methods can be recorded in a state block, after calling IDirect3DDevice9::BeginStateBlock and before <see cref="SlimDX2.Direct3D9.Device.EndStateBlock"/>.    <see cref="SlimDX2.Direct3D9.Device.LightEnable"/>   <see cref="SlimDX2.Direct3D9.Device.SetClipPlane"/>   <see cref="SlimDX2.Direct3D9.Device.SetCurrentTexturePalette"/>   <see cref="SlimDX2.Direct3D9.Device.SetVertexFormat"/>   <see cref="SlimDX2.Direct3D9.Device.SetIndices"/>   <see cref="SlimDX2.Direct3D9.Device.SetLight"/>   <see cref="SlimDX2.Direct3D9.Device.SetMaterial"/>   <see cref="SlimDX2.Direct3D9.Device.SetNPatchMode"/>   <see cref="SlimDX2.Direct3D9.Device.SetPixelShader"/>   <see cref="SlimDX2.Direct3D9.Device.SetPixelShaderConstantB"/>   <see cref="SlimDX2.Direct3D9.Device.SetPixelShaderConstantF"/>   <see cref="SlimDX2.Direct3D9.Device.SetPixelShaderConstantI"/>   <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/>   <see cref="SlimDX2.Direct3D9.Device.SetSamplerState"/>   <see cref="SlimDX2.Direct3D9.Device.SetScissorRect"/>   <see cref="SlimDX2.Direct3D9.Device.SetStreamSource"/>   <see cref="SlimDX2.Direct3D9.Device.SetStreamSourceFreq"/>   <see cref="SlimDX2.Direct3D9.Device.SetTexture"/>   <see cref="SlimDX2.Direct3D9.Device.SetTextureStageState"/>   <see cref="SlimDX2.Direct3D9.Device.SetTransform"/>   <see cref="SlimDX2.Direct3D9.Device.SetViewport"/>   <see cref="SlimDX2.Direct3D9.Device.SetVertexDeclaration"/>   <see cref="SlimDX2.Direct3D9.Device.SetVertexShader"/>   <see cref="SlimDX2.Direct3D9.Device.SetVertexShaderConstantB"/>   <see cref="SlimDX2.Direct3D9.Device.SetVertexShaderConstantF"/>   <see cref="SlimDX2.Direct3D9.Device.SetVertexShaderConstantI"/>   The ordering of state changes in a state block is not guaranteed. If the same state is specified multiple times in a state block, only the last value is used. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::BeginStateBlock()</unmanaged>
        public SlimDX2.Result BeginStateBlock() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 60 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Signals Direct3D to stop recording a device-state block and retrieve a pointer to the state block interface.	
        /// </summary>	
        /// <param name="sBRef"> Pointer to a state block interface. See <see cref="SlimDX2.Direct3D9.StateBlock"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::EndStateBlock([None] IDirect3DStateBlock9** ppSB)</unmanaged>
        public SlimDX2.Result EndStateBlock(out SlimDX2.Direct3D9.StateBlock sBRef) {
            unsafe {
                IntPtr sBRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 61 * 4, &sBRef_);
                sBRef = (sBRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.StateBlock(sBRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the clip status.	
        /// </summary>	
        /// <remarks>	
        ///  Clip status is used during software vertex processing. Therefore, this method is not supported on pure or nonpure hardware processing devices. For more information about pure devices, see {{D3DCREATE}}. When clipping is enabled during vertex processing (by <see cref="SlimDX2.Direct3D9.Device.ProcessVertices"/>, <see cref="SlimDX2.Direct3D9.Device.DrawPrimitives"/>, or other drawing functions), Direct3D computes a clip code for every vertex. The clip code is a combination of D3DCS_* bits. When a vertex is outside a particular clipping plane, the corresponding bit is set in the clipping code. Direct3D maintains the clip status using <see cref="SlimDX2.Direct3D9.ClipStatus"/>, which has ClipUnion and ClipIntersection members. ClipUnion is a bitwise "OR" of all vertex clip codes and ClipIntersection is a bitwise "AND" of all vertex clip codes. Initial values are zero for ClipUnion and 0xFFFFFFFF for ClipIntersection. When D3DRS_CLIPPING is set to FALSE, ClipUnion and ClipIntersection are set to zero. Direct3D updates the clip status during drawing calls. To compute clip status for a particular object, set ClipUnion and ClipIntersection to their initial value and continue drawing. Clip status is not updated by <see cref="SlimDX2.Direct3D9.Device.DrawRectPatch"/> and <see cref="SlimDX2.Direct3D9.Device.DrawTriPatch"/> because there is no software emulation for them. 	
        /// </remarks>	
        /// <param name="clipStatusRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ClipStatus"/> structure, describing the clip status settings to be set.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If one of the arguments is invalid, the return value is D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetClipStatus([None] const D3DCLIPSTATUS9* pClipStatus)</unmanaged>
        internal SlimDX2.Result SetClipStatus(ref SlimDX2.Direct3D9.ClipStatus clipStatusRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* clipStatusRef_ = &clipStatusRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 62 * 4, clipStatusRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the clip status.	
        /// </summary>	
        /// <remarks>	
        ///  When clipping is enabled during vertex processing (by <see cref="SlimDX2.Direct3D9.Device.ProcessVertices"/>, <see cref="SlimDX2.Direct3D9.Device.DrawPrimitives"/>, or other drawing functions), Direct3D computes a clip code for every vertex. The clip code is a combination of D3DCS_* bits. When a vertex is outside a particular clipping plane, the corresponding bit is set in the clipping code. Direct3D maintains the clip status using <see cref="SlimDX2.Direct3D9.ClipStatus"/>, which has ClipUnion and ClipIntersection members. ClipUnion is a bitwise "OR" of all vertex clip codes and ClipIntersection is a bitwise "AND" of all vertex clip codes. Initial values are zero for ClipUnion and 0xFFFFFFFF for ClipIntersection. When D3DRS_CLIPPING is set to FALSE, ClipUnion and ClipIntersection are set to zero. Direct3D updates the clip status during drawing calls. To compute clip status for a particular object, set ClipUnion and ClipIntersection to their initial value and continue drawing. Clip status is not updated by <see cref="SlimDX2.Direct3D9.Device.DrawRectPatch"/> and <see cref="SlimDX2.Direct3D9.Device.DrawTriPatch"/> because there is no software emulation for them. Clip status is used during software vertex processing. Therefore, this method is not supported on pure or nonpure hardware processing devices. For more information about pure devices, see {{D3DCREATE}}. 	
        /// </remarks>	
        /// <param name="clipStatusRef">  Pointer to a <see cref="SlimDX2.Direct3D9.ClipStatus"/> structure that describes the clip status.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the argument is invalid. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetClipStatus([Out] D3DCLIPSTATUS9* pClipStatus)</unmanaged>
        internal SlimDX2.Result GetClipStatus(out SlimDX2.Direct3D9.ClipStatus clipStatusRef) {
            unsafe {
                clipStatusRef = new SlimDX2.Direct3D9.ClipStatus();
                SlimDX2.Result __result__;
                fixed (void* clipStatusRef_ = &clipStatusRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 63 * 4, clipStatusRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a texture assigned to a stage for a device.	
        /// </summary>	
        /// <remarks>	
        ///  Typically, methods that return state will not work on a device that is created using D3DCREATE_PUREDEVICE. This method however, will work even on a pure device because it returns an interface. Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Texture"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DTexture9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="stage"> Stage identifier of the texture to retrieve. Stage identifiers are zero-based. </param>
        /// <param name="textureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.BaseTexture"/> interface, representing the returned texture.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetTexture([None] int Stage,[Out] IDirect3DBaseTexture9** ppTexture)</unmanaged>
        public SlimDX2.Result GetTexture(int stage, out SlimDX2.Direct3D9.BaseTexture textureRef) {
            unsafe {
                IntPtr textureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 64 * 4, stage, &textureRef_);
                textureRef = (textureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.BaseTexture(textureRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Assigns a texture to a stage for a device.	
        /// </summary>	
        /// <remarks>	
        ///  SetTexture is not allowed if the texture is created with a pool type of D3DPOOL_SCRATCH. SetTexture is not allowed with a pool type of D3DPOOL_SYSTEMMEM texture unless DevCaps is set with D3DDEVCAPS_TEXTURESYSTEMMEMORY. 	
        /// </remarks>	
        /// <param name="stage"> Zero based sampler number.  Textures are bound to samplers; samplers define sampling state such as the filtering mode and the address wrapping mode. Textures are referenced differently by the programmable and the fixed function pipeline:   Programmable shaders reference textures using the sampler number. The number of samplers available to a programmable shader is dependent on the shader version. For vertex shaders, see {{Sampler (Direct3D 9 asm-vs)}}. For pixel shaders see {{Sampler (Direct3D 9 asm-ps)}}. The fixed function pipeline on the other hand, references textures by texture stage number. The maximum number of samplers is determined from two caps: MaxSimultaneousTextures and MaxTextureBlendStages of the <see cref="SlimDX2.Direct3D9.Capabilities"/> structure.  There are two other special cases for stage/sampler numbers.  A special number called D3DDMAPSAMPLER is used for {{Displacement Mapping (Direct3D 9)}}. A programmable vertex shader uses a special number defined by a {{D3DVERTEXTEXTURESAMPLER}} when accessing {{Vertex Textures in vs_3_0 (DirectX HLSL)}}.  </param>
        /// <param name="textureRef"> Pointer to an <see cref="SlimDX2.Direct3D9.BaseTexture"/> interface, representing the texture being set.   </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetTexture([None] int Stage,[None] IDirect3DBaseTexture9* pTexture)</unmanaged>
        public SlimDX2.Result SetTexture(int stage, SlimDX2.Direct3D9.BaseTexture textureRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 65 * 4, stage, (void*)((textureRef == null)?IntPtr.Zero:textureRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a state value for an assigned texture.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other flag values in {{D3DCREATE}}."  	
        /// </remarks>	
        /// <param name="stage"> Stage identifier of the texture for which the state is retrieved. Stage identifiers are zero-based. Devices can have up to eight set textures, so the maximum value allowed for Stage is 7.  </param>
        /// <param name="type"> Texture state to retrieve. This parameter can be any member of the <see cref="SlimDX2.Direct3D9.TextureStage"/> enumerated type.  </param>
        /// <param name="valueRef"> Pointer a variable to fill with the retrieved state value. The meaning of the retrieved value is determined by the Type parameter.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetTextureStageState([None] int Stage,[None] D3DTEXTURESTAGESTATETYPE Type,[Out] int* pValue)</unmanaged>
        public SlimDX2.Result GetTextureStageState(int stage, SlimDX2.Direct3D9.TextureStage type, out int valueRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* valueRef_ = &valueRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 66 * 4, stage, unchecked((int)type), valueRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the state value for the currently assigned texture.	
        /// </summary>	
        /// <param name="stage"> Stage identifier of the texture for which the state value is set. Stage identifiers are zero-based. Devices can have up to eight set textures, so the maximum value allowed for Stage is 7.  </param>
        /// <param name="type"> Texture state to set. This parameter can be any member of the <see cref="SlimDX2.Direct3D9.TextureStage"/> enumerated type.  </param>
        /// <param name="value"> State value to set. The meaning of this value is determined by the Type parameter.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetTextureStageState([None] int Stage,[None] D3DTEXTURESTAGESTATETYPE Type,[None] int Value)</unmanaged>
        public SlimDX2.Result SetTextureStageState(int stage, SlimDX2.Direct3D9.TextureStage type, int value) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 67 * 4, stage, unchecked((int)type), value);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the sampler state value.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other values in {{D3DCREATE}}."  	
        /// </remarks>	
        /// <param name="sampler"> The sampler stage index. </param>
        /// <param name="type"> This parameter can be any member of the <see cref="SlimDX2.Direct3D9.SamplerState"/> enumerated type.  </param>
        /// <param name="valueRef"> State value to get. The meaning of this value is determined by the Type parameter.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetSamplerState([None] int Sampler,[None] D3DSAMPLERSTATETYPE Type,[Out] int* pValue)</unmanaged>
        public SlimDX2.Result GetSamplerState(int sampler, SlimDX2.Direct3D9.SamplerState type, out int valueRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* valueRef_ = &valueRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 68 * 4, sampler, unchecked((int)type), valueRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the sampler state value.	
        /// </summary>	
        /// <param name="sampler"> The sampler stage index. </param>
        /// <param name="type"> This parameter can be any member of the <see cref="SlimDX2.Direct3D9.SamplerState"/> enumerated type.  </param>
        /// <param name="value"> State value to set. The meaning of this value is determined by the Type parameter.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetSamplerState([None] int Sampler,[None] D3DSAMPLERSTATETYPE Type,[None] int Value)</unmanaged>
        public SlimDX2.Result SetSamplerState(int sampler, SlimDX2.Direct3D9.SamplerState type, int value) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 69 * 4, sampler, unchecked((int)type), value);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Reports the device's ability to render the current texture-blending operations and arguments in a single pass.	
        /// </summary>	
        /// <remarks>	
        ///  The IDirect3DDevice9::ValidateDevice method should be used to validate scenarios only when other capabilities are deficient. For example, in a multistage texturing scenario, you could query the MaxTextureBlendStages and MaxSimultaneousTextures members of a <see cref="SlimDX2.Direct3D9.Capabilities"/> structure to determine if multistage texturing is possible on the device. Current hardware does not necessarily implement all possible combinations of operations and arguments. You can determine whether a particular blending operation can be performed with given arguments by setting the desired blending operation, and then calling the IDirect3DDevice9::ValidateDevice method.  The IDirect3DDevice9::ValidateDevice method uses the current render states, textures, and texture-stage states to perform validation at the time of the call. Changes to these factors after the call invalidate the previous result, and the method must be called again before rendering a scene. For best performance, call IDirect3DDevice9::ValidateDevice at initialization time; do not use it within a render loop. Using diffuse iterated values, either as an argument or as an operation (D3DTA_DIFFUSED3DTOP_BLENDDIFFUSEALPHA) is rarely supported on current hardware. Most hardware can introduce iterated color data only at the last texture operation stage. Try to specify the texture (D3DTA_TEXTURE) for each stage as the first argument, rather than the second argument. Many cards do not support use of diffuse or scalar values at arbitrary texture stages. Often, these are available only at the first or last texture-blending stage. Many cards do not have a blending unit associated with the first texture that is capable of more than replicating alpha to color channels or inverting the input. Therefore, your application might need to use only the second texture stage, if possible. On such hardware, the first unit is presumed to be in its default state, which has the first color argument set to D3DTA_TEXTURE with the D3DTOP_SELECTARG1 operation. Operations on the output alpha that are more intricate than or substantially different from the color operations are less likely to be supported.  Some hardware does not support simultaneous use of D3DTA_TFACTOR and D3DTA_DIFFUSE. Many cards do not support simultaneous use of multiple textures and mipmapped trilinear filtering. If trilinear filtering has been requested for a texture involved in multitexture blending operations and validation fails, turn off trilinear filtering and revalidate. In this case, you might want to perform multipass rendering instead. 	
        /// </remarks>	
        /// <param name="numPassesRef"> Pointer to a DWORD value to fill with the number of rendering passes needed to complete the desired effect through multipass rendering.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_CONFLICTINGRENDERSTATE, D3DERR_CONFLICTINGTEXTUREFILTER, D3DERR_DEVICELOST, D3DERR_DRIVERINTERNALERROR, D3DERR_TOOMANYOPERATIONS, D3DERR_UNSUPPORTEDALPHAARG, D3DERR_UNSUPPORTEDALPHAOPERATION, D3DERR_UNSUPPORTEDCOLORARG, D3DERR_UNSUPPORTEDCOLOROPERATION, D3DERR_UNSUPPORTEDFACTORVALUE, D3DERR_UNSUPPORTEDTEXTUREFILTER, D3DERR_WRONGTEXTUREFORMAT,. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::ValidateDevice([None] int* pNumPasses)</unmanaged>
        public SlimDX2.Result ValidateDevice(ref int numPassesRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* numPassesRef_ = &numPassesRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 70 * 4, numPassesRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets palette entries.	
        /// </summary>	
        /// <remarks>	
        ///  For Direct3D 9 applications, any palette sent to this method must conform to the D3DPTEXTURECAPS_ALPHAPALETTE capability bit of the <see cref="SlimDX2.Direct3D9.Capabilities"/> structure. If D3DPTEXTURECAPS_ALPHAPALETTE is not set, every entry in the palette must have alpha set to 1.0 or this method will fail with D3DERR_INVALIDCALL. If D3DPTEXTURECAPS_ALPHAPALETTE is set, then any set of alpha values are allowed. Note that the debug runtime will print a warning message if all palette entries have alpha set to 0.  A single logical palette is associated with the device, and is shared by all texture stages. 	
        /// </remarks>	
        /// <param name="paletteNumber"> An ordinal value identifying the particular palette upon which the operation is to be performed.  </param>
        /// <param name="entriesRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing the palette entries to set. The number of PALETTEENTRY structures pointed to by pEntries is assumed to be 256. See Remarks.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetPaletteEntries([None] UINT PaletteNumber,[None] const PALETTEENTRY* pEntries)</unmanaged>
        public SlimDX2.Result SetPaletteEntries(int paletteNumber, ref SlimDX2.Windows.Paletteentry entriesRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* entriesRef_ = &entriesRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 71 * 4, paletteNumber, entriesRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves palette entries.	
        /// </summary>	
        /// <remarks>	
        ///  For more information about <see cref="SlimDX2.Windows.Paletteentry"/>, see the Platform SDK. Note??As of Direct3D 9, the peFlags member of the <see cref="SlimDX2.Windows.Paletteentry"/> structure does not work the way it is documented in the Platform SDK. The peFlags member is now the alpha channel for 8-bit palettized formats. 	
        /// </remarks>	
        /// <param name="paletteNumber"> An ordinal value identifying the particular palette to retrieve.  </param>
        /// <param name="entriesRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing the returned palette entries.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetPaletteEntries([None] UINT PaletteNumber,[Out] PALETTEENTRY* pEntries)</unmanaged>
        public SlimDX2.Result GetPaletteEntries(int paletteNumber, out SlimDX2.Windows.Paletteentry entriesRef) {
            unsafe {
                entriesRef = new SlimDX2.Windows.Paletteentry();
                SlimDX2.Result __result__;
                fixed (void* entriesRef_ = &entriesRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 72 * 4, paletteNumber, entriesRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the current texture palette.	
        /// </summary>	
        /// <remarks>	
        ///  A single logical palette is associated with the device, and is shared by all texture stages. 	
        /// </remarks>	
        /// <param name="paletteNumber"> Value that specifies the texture palette to set as the current texture palette.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetCurrentTexturePalette([None] UINT PaletteNumber)</unmanaged>
        internal SlimDX2.Result SetCurrentTexturePalette(int paletteNumber) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 73 * 4, paletteNumber);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the current texture palette.	
        /// </summary>	
        /// <param name="aletteNumberRef"> Pointer to a returned value that identifies the current texture palette.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetCurrentTexturePalette([Out] UINT* PaletteNumber)</unmanaged>
        internal SlimDX2.Result GetCurrentTexturePalette(out int aletteNumberRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* aletteNumberRef_ = &aletteNumberRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 74 * 4, aletteNumberRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the scissor rectangle.	
        /// </summary>	
        /// <remarks>	
        ///  The scissor rectangle is used as a rectangular clipping region. See {{Rectangles (Direct3D 9)}} for further information on the use of rectangles in DirectX. 	
        /// </remarks>	
        /// <param name="rectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure that defines the rendering area within the render target if scissor test is enabled. This parameter may not be NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetScissorRect([None] const RECT* pRect)</unmanaged>
        internal SlimDX2.Result SetScissorRect(ref SlimDX2.Rectangle rectRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* rectRef_ = &rectRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 75 * 4, rectRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the scissor rectangle.	
        /// </summary>	
        /// <remarks>	
        ///  The scissor rectangle is used as a rectangular clipping region. See {{Rectangles (Direct3D 9)}} for further information on the use of rectangles in DirectX. 	
        /// </remarks>	
        /// <param name="rectRef"> Returns a pointer to a <see cref="SlimDX2.Rectangle"/> structure that defines the rendering area within the render target if scissor test is enabled. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetScissorRect([Out] RECT* pRect)</unmanaged>
        internal SlimDX2.Result GetScissorRect(out SlimDX2.Rectangle rectRef) {
            unsafe {
                rectRef = new SlimDX2.Rectangle();
                SlimDX2.Result __result__;
                fixed (void* rectRef_ = &rectRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 76 * 4, rectRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to switch between software and hardware vertex processing.	
        /// </summary>	
        /// <remarks>	
        ///  The restrictions for changing modes are as follows:  If a device is created with D3DCREATE_SOFTWARE_VERTEXPROCESSING, the vertex processing will be done in software and cannot be changed. If a device is created with D3DCREATE_HARDWARE_VERTEXPROCESSING, the vertex processing will be done in hardware and cannot be changed. If a device is created with D3DCREATE_MIXED_VERTEXPROCESSING, the vertex processing will be done in hardware by default. The processing can be switched to software (or back to hardware) using IDirect3DDevice9::SetSoftwareVertexProcessing.  An application can create a mixed-mode device to use both the software vertex processing and the hardware vertex processing. To switch between the two vertex processing modes in DirectX 8.x, use IDirect3DDevice8::SetRenderState with the render state D3DRS_SOFTWAREVERTEXPROCESSING and the appropriate DWORD argument. The drawback of the render state approach was the difficulty in defining the semantics for state blocks. Applications and the runtime had to do extra work and be careful while recording and playing back state blocks. In Direct3D 9, use SetSoftwareVertexProcessing instead. This new API is not recorded by StateBlocks. 	
        /// </remarks>	
        /// <param name="bSoftware"> TRUE to specify software vertex processing; FALSE to specify hardware vertex processing. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetSoftwareVertexProcessing([None] BOOL bSoftware)</unmanaged>
        internal SlimDX2.Result SetSoftwareVertexProcessing(bool bSoftware) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 77 * 4, (bSoftware?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the vertex processing (hardware or software) mode.	
        /// </summary>	
        /// <remarks>	
        ///  An application can create a mixed-mode device to use both the software vertex processing and the hardware vertex processing. To switch between the two vertex processing modes in DirectX 8.x, use <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/> with the render state D3DRS_SOFTWAREVERTEXPROCESSING and the appropriate BOOL argument. The drawback of the render state approach was the difficulty in defining the semantics for state blocks. Applications and the runtime had to do extra work and be careful while recording and playing back state blocks. In Direct3D 9, use <see cref="SlimDX2.Direct3D9.Device.SetSoftwareVertexProcessing"/> instead. This new API is not recorded by StateBlocks. 	
        /// </remarks>	
        /// <returns>  {{BOOL}}  Returns TRUE if software vertex processing is set. Otherwise, it returns FALSE. </returns>
        /// <unmanaged>BOOL IDirect3DDevice9::GetSoftwareVertexProcessing()</unmanaged>
        internal bool GetSoftwareVertexProcessing() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 78 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Enable or disable N-patches.	
        /// </summary>	
        /// <param name="nSegments"> Specifies the number of subdivision segments. If the number of segments is less than 1.0, N-patches are disabled. The default value is 0.0.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetNPatchMode([None] float nSegments)</unmanaged>
        internal SlimDX2.Result SetNPatchMode(float nSegments) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 79 * 4, nSegments);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the N-patch mode segments.	
        /// </summary>	
        /// <returns>  {{FLOAT}}  Specifies the number of subdivision segments. If the number of segments is less than 1.0, N-patches are disabled. The default value is 0.0.  </returns>
        /// <unmanaged>float IDirect3DDevice9::GetNPatchMode()</unmanaged>
        internal float GetNPatchMode() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct3D9.LocalInterop.Callifloat(_nativePointer, 80 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams.	
        /// </summary>	
        /// <remarks>	
        ///  When converting a legacy application to Direct3D 9, you must add a call to either <see cref="SlimDX2.Direct3D9.Device.SetVertexFormat"/> to use the fixed function pipeline, or <see cref="SlimDX2.Direct3D9.Device.SetVertexDeclaration"/> to use a vertex shader before you make any Draw calls. 	
        /// </remarks>	
        /// <param name="primitiveType"> Member of the <see cref="SlimDX2.Direct3D9.PrimitiveType"/> enumerated type, describing the type of primitive to render.  </param>
        /// <param name="startVertex"> Index of the first vertex to load. Beginning at StartVertex the correct number of vertices will be read out of the vertex buffer.  </param>
        /// <param name="primitiveCount"> Number of primitives to render. The maximum number of primitives allowed is determined by checking the MaxPrimitiveCount member of the <see cref="SlimDX2.Direct3D9.Capabilities"/> structure. PrimitiveCount is the number of primitives as determined by the primitive type. If it is a line list, each primitive has two vertices. If it is a triangle list, each primitive has three vertices.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be  D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::DrawPrimitive([None] D3DPRIMITIVETYPE PrimitiveType,[None] UINT StartVertex,[None] UINT PrimitiveCount)</unmanaged>
        public SlimDX2.Result DrawPrimitives(SlimDX2.Direct3D9.PrimitiveType primitiveType, int startVertex, int primitiveCount) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 81 * 4, unchecked((int)primitiveType), startVertex, primitiveCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Based on indexing, renders the specified geometric primitive into an array of vertices.	
        /// </summary>	
        /// <remarks>	
        ///  This method draws indexed primitives from the current set of data input streams. MinIndex  and all the indices in the index stream are relative to the BaseVertexIndex. The MinIndex  and NumVertices  parameters specify the range of vertex indices used for each IDirect3DDevice9::DrawIndexedPrimitive call. These are used to optimize vertex processing of indexed primitives by processing a sequential range of vertices prior to indexing into these vertices. It is invalid for any indices used during this call to reference any vertices outside of this range. IDirect3DDevice9::DrawIndexedPrimitive fails if no index array is set. The D3DPT_POINTLIST member of the <see cref="SlimDX2.Direct3D9.PrimitiveType"/> enumerated type is not supported and is not a valid type for this method. When converting a legacy application to Direct3D 9, you must add a call to either <see cref="SlimDX2.Direct3D9.Device.SetVertexFormat"/> to use the fixed function pipeline, or <see cref="SlimDX2.Direct3D9.Device.SetVertexDeclaration"/> to use a vertex shader before you make any Draw calls. 	
        /// </remarks>	
        /// <param name="arg0"> Member of the <see cref="SlimDX2.Direct3D9.PrimitiveType"/> enumerated type, describing the type of primitive to render. D3DPT_POINTLIST is not supported with this method. See Remarks.  </param>
        /// <param name="baseVertexIndex"> Offset from the start of the vertex buffer to the first vertex. See {{Scenario 4}}. </param>
        /// <param name="minVertexIndex"> Minimum vertex index for vertices used during this call. This is a zero based index relative to BaseVertexIndex. </param>
        /// <param name="numVertices"> Number of vertices used during this call. The first vertex is located at index: BaseVertexIndex + MinIndex. </param>
        /// <param name="startIndex"> Index of the first index to use when accesssing the vertex buffer. Beginning at StartIndex to index vertices from the vertex buffer. </param>
        /// <param name="primCount"> Number of primitives to render. The number of vertices used is a function of the primitive count and the primitive type. The maximum number of primitives allowed is determined by checking the MaxPrimitiveCount member of the <see cref="SlimDX2.Direct3D9.Capabilities"/> structure.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::DrawIndexedPrimitive([None] D3DPRIMITIVETYPE arg0,[None] INT BaseVertexIndex,[None] UINT MinVertexIndex,[None] UINT NumVertices,[None] UINT startIndex,[None] UINT primCount)</unmanaged>
        public SlimDX2.Result DrawIndexedPrimitive(SlimDX2.Direct3D9.PrimitiveType arg0, int baseVertexIndex, int minVertexIndex, int numVertices, int startIndex, int primCount) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 82 * 4, unchecked((int)arg0), baseVertexIndex, minVertexIndex, numVertices, startIndex, primCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Renders data specified by a user memory pointer as a sequence of geometric primitives of the specified type.	
        /// </summary>	
        /// <remarks>	
        ///  This method is intended for use in applications that are unable to store their vertex data in vertex buffers. This method supports only a single vertex stream. The effect of this call is to use the provided vertex data pointer and stride for vertex stream 0. It is invalid to have the declaration of the current vertex shader refer to vertex streams other than stream 0. Following any IDirect3DDevice9::DrawPrimitiveUP call, the stream 0 settings, referenced by <see cref="SlimDX2.Direct3D9.Device.GetStreamSource"/>, are set to NULL. The vertex data passed to IDirect3DDevice9::DrawPrimitiveUP does not need to persist after the call. Direct3D completes its access to that data prior to returning from the call. When converting a legacy application to Direct3D 9, you must add a call to either <see cref="SlimDX2.Direct3D9.Device.SetVertexFormat"/> to use the fixed function pipeline, or <see cref="SlimDX2.Direct3D9.Device.SetVertexDeclaration"/> to use a vertex shader before you make any Draw calls. 	
        /// </remarks>	
        /// <param name="primitiveType"> Member of the <see cref="SlimDX2.Direct3D9.PrimitiveType"/> enumerated type, describing the type of primitive to render.  </param>
        /// <param name="primitiveCount"> Number of primitives to render. The maximum number of primitives allowed is determined by checking the MaxPrimitiveCount member of the <see cref="SlimDX2.Direct3D9.Capabilities"/> structure.  </param>
        /// <param name="vertexStreamZeroDataRef"> User memory pointer to the vertex data. </param>
        /// <param name="vertexStreamZeroStride"> The number of bytes of data for each vertex. This value may not be 0. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::DrawPrimitiveUP([None] D3DPRIMITIVETYPE PrimitiveType,[None] UINT PrimitiveCount,[None] const void* pVertexStreamZeroData,[None] UINT VertexStreamZeroStride)</unmanaged>
        public SlimDX2.Result DrawPrimitiveUP(SlimDX2.Direct3D9.PrimitiveType primitiveType, int primitiveCount, IntPtr vertexStreamZeroDataRef, int vertexStreamZeroStride) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 83 * 4, unchecked((int)primitiveType), primitiveCount, (void*)vertexStreamZeroDataRef, vertexStreamZeroStride);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Renders the specified geometric primitive with data specified by a user memory pointer.	
        /// </summary>	
        /// <remarks>	
        ///  This method is intended for use in applications that are unable to store their vertex data in vertex buffers. This method supports only a single vertex stream, which must be declared as stream 0. Following any IDirect3DDevice9::DrawIndexedPrimitiveUP call, the stream 0 settings, referenced by <see cref="SlimDX2.Direct3D9.Device.GetStreamSource"/>, are set to NULL. Also, the index buffer setting for <see cref="SlimDX2.Direct3D9.Device.SetIndices"/> is set to NULL. The vertex data passed to IDirect3DDevice9::DrawIndexedPrimitiveUP does not need to persist after the call. Direct3D completes its access to that data prior to returning from the call. When converting a legacy application to Direct3D 9, you must add a call to either <see cref="SlimDX2.Direct3D9.Device.SetVertexFormat"/> to use the fixed function pipeline, or <see cref="SlimDX2.Direct3D9.Device.SetVertexDeclaration"/> to use a vertex shader before you make any Draw calls. 	
        /// </remarks>	
        /// <param name="primitiveType"> Member of the <see cref="SlimDX2.Direct3D9.PrimitiveType"/> enumerated type, describing the type of primitive to render.  </param>
        /// <param name="minVertexIndex"> Minimum vertex index. This is a zero-based index. </param>
        /// <param name="numVertices">  Number of vertices used during this call. The first vertex is located at index: MinVertexIndex. </param>
        /// <param name="primitiveCount"> Number of primitives to render. The maximum number of primitives allowed is determined by checking the MaxPrimitiveCount member of the <see cref="SlimDX2.Direct3D9.Capabilities"/> structure (the number of indices is a function of the primitive count and the primitive type). </param>
        /// <param name="indexDataRef"> User memory pointer to the index data.  </param>
        /// <param name="indexDataFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of the index data. The valid settings are either:    <see cref="SlimDX2.Direct3D9.Format.Index16"/>   <see cref="SlimDX2.Direct3D9.Format.Index32"/>   </param>
        /// <param name="vertexStreamZeroDataRef"> User memory pointer to the vertex data. The vertex data must be in stream 0. </param>
        /// <param name="vertexStreamZeroStride"> The number of bytes of data for each vertex. This value may not be 0. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::DrawIndexedPrimitiveUP([None] D3DPRIMITIVETYPE PrimitiveType,[None] UINT MinVertexIndex,[None] UINT NumVertices,[None] UINT PrimitiveCount,[None] const void* pIndexData,[None] D3DFORMAT IndexDataFormat,[None] const void* pVertexStreamZeroData,[None] UINT VertexStreamZeroStride)</unmanaged>
        public SlimDX2.Result DrawIndexedPrimitiveUP(SlimDX2.Direct3D9.PrimitiveType primitiveType, int minVertexIndex, int numVertices, int primitiveCount, IntPtr indexDataRef, SlimDX2.Direct3D9.Format indexDataFormat, IntPtr vertexStreamZeroDataRef, int vertexStreamZeroStride) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 84 * 4, unchecked((int)primitiveType), minVertexIndex, numVertices, primitiveCount, (void*)indexDataRef, unchecked((int)indexDataFormat), (void*)vertexStreamZeroDataRef, vertexStreamZeroStride);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Applies the vertex processing defined by the vertex shader to the set of input data streams, generating a single stream of interleaved vertex data to the destination vertex buffer. 	
        /// </summary>	
        /// <remarks>	
        ///  The order of operations for this method is as follows:  Transform vertices to projection space using the world + view + projection matrix. Compute screen coordinates using viewport settings. If clipping is enabled, compute clipping codes and store them in an internal buffer, associated with the destination vertex buffer. If a vertex is inside the viewing frustum, its screen coordinates are computed. If the vertex is outside the viewing frustum, the vertex is stored in the destination vertex buffer in projection space coordinates. Other notes: The user does not have access to the internal clip code buffer. No clipping is done on triangles or any other primitives.  The destination vertex buffer, pDestBuffer, must be created with a nonzero FVF parameter in <see cref="SlimDX2.Direct3D9.Device.CreateVertexBuffer"/>. The FVF code specified during the call to the IDirect3DDevice9::CreateVertexBuffer method specifies the vertex elements present in the destination vertex buffer. When Direct3D generates texture coordinates, or copies or transforms input texture coordinates, and the output texture coordinate format defines more texture coordinate components than Direct3D generates, Direct3D does not change these extra components. 	
        /// </remarks>	
        /// <param name="srcStartIndex"> Index of first vertex to load.  </param>
        /// <param name="destIndex"> Index of first vertex in the destination vertex buffer into which the results are placed.  </param>
        /// <param name="vertexCount"> Number of vertices to process.  </param>
        /// <param name="destBufferRef"> Pointer to an <see cref="SlimDX2.Direct3D9.VertexBuffer"/> interface, the destination vertex buffer representing the stream of interleaved vertex data.  </param>
        /// <param name="vertexDeclRef"> Pointer to an <see cref="SlimDX2.Direct3D9.VertexDeclaration"/> interface that represents the output vertex data declaration. When vertex shader 3.0 or above is set as the current vertex shader, the output vertex declaration must be present. </param>
        /// <param name="flags"> Processing options. Set this parameter to 0 for default processing. Set to D3DPV_DONOTCOPYDATA to prevent the system from copying vertex data not affected by the vertex operation into the destination buffer. The D3DPV_DONOTCOPYDATA value may be combined with one or more <see cref="SlimDX2.Direct3D9.LockFlags"/> values appropriate for the destination buffer. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::ProcessVertices([None] UINT SrcStartIndex,[None] UINT DestIndex,[None] UINT VertexCount,[None] IDirect3DVertexBuffer9* pDestBuffer,[None] IDirect3DVertexDeclaration9* pVertexDecl,[None] int Flags)</unmanaged>
        public SlimDX2.Result ProcessVertices(int srcStartIndex, int destIndex, int vertexCount, SlimDX2.Direct3D9.VertexBuffer destBufferRef, SlimDX2.Direct3D9.VertexDeclaration vertexDeclRef, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 85 * 4, srcStartIndex, destIndex, vertexCount, (void*)((destBufferRef == null)?IntPtr.Zero:destBufferRef.NativePointer), (void*)((vertexDeclRef == null)?IntPtr.Zero:vertexDeclRef.NativePointer), flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a vertex shader declaration from the device and the vertex elements.	
        /// </summary>	
        /// <remarks>	
        ///  See the {{Vertex Declaration (Direct3D 9)}} page for a detailed description of how to map vertex declarations between different versions of DirectX. 	
        /// </remarks>	
        /// <param name="vertexElementsRef"> An array of <see cref="SlimDX2.Direct3D9.VertexElement"/> vertex elements. </param>
        /// <param name="declRef"> Pointer to an <see cref="SlimDX2.Direct3D9.VertexDeclaration"/> pointer that returns the created vertex shader declaration. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateVertexDeclaration([In, Buffer] const D3DVERTEXELEMENT9* pVertexElements,[None] IDirect3DVertexDeclaration9** ppDecl)</unmanaged>
        internal SlimDX2.Result CreateVertexDeclaration(SlimDX2.Direct3D9.VertexElement[] vertexElementsRef, out SlimDX2.Direct3D9.VertexDeclaration declRef) {
            unsafe {
                IntPtr declRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* vertexElementsRef_ = &vertexElementsRef[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 86 * 4, vertexElementsRef_, &declRef_);
                declRef = (declRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexDeclaration(declRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a {{Vertex Declaration (Direct3D 9)}}.	
        /// </summary>	
        /// <remarks>	
        ///  A vertex declaration is an IDirect3DVertexDeclaration9 object that defines the data members of a vertex (i.e. texture coordinates, colors, normals, etc.). This data can be useful for implementing {{vertex shaders and pixel shaders}}. 	
        /// </remarks>	
        /// <param name="declRef"> Pointer to an <see cref="SlimDX2.Direct3D9.VertexDeclaration"/> object, which contains the vertex declaration. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. The return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetVertexDeclaration([None] IDirect3DVertexDeclaration9* pDecl)</unmanaged>
        internal SlimDX2.Result SetVertexDeclaration(SlimDX2.Direct3D9.VertexDeclaration declRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 87 * 4, (void*)((declRef == null)?IntPtr.Zero:declRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a vertex shader declaration.	
        /// </summary>	
        /// <param name="declRef"> Pointer to an <see cref="SlimDX2.Direct3D9.VertexDeclaration"/> object that is returned. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. The return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetVertexDeclaration([Out] IDirect3DVertexDeclaration9** ppDecl)</unmanaged>
        internal SlimDX2.Result GetVertexDeclaration(out SlimDX2.Direct3D9.VertexDeclaration declRef) {
            unsafe {
                IntPtr declRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 88 * 4, &declRef_);
                declRef = (declRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexDeclaration(declRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the current vertex stream declaration.	
        /// </summary>	
        /// <remarks>	
        ///  Here are the steps necessary to initialize and use vertices that have a position, diffuse and specular color, and texture coordinates:  Define the custom vertex type and FVF code.	 	
        /// <code> struct LVertex	
        /// { FLOAT    x, y, z; D3DCOLOR specular, diffuse; FLOAT    tu, tv;	
        /// }; const DWORD VertexFVF = (D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_SPECULAR | D3DFVF_TEX1 ); </code>	
        /// 	
        ///   Create a vertex buffer with enough room for four vertices using <see cref="SlimDX2.Direct3D9.Device.CreateVertexBuffer"/>. 	
        /// <code> g_d3dDevice-&gt;CreateVertexBuffer( 4*sizeof(LVertex),   D3DUSAGE_WRITEONLY, VertexFVF, D3DPOOL_DEFAULT, &amp;pBigSquareVB, NULL ); </code>	
        /// 	
        ///   Set the values for each vertex. 	
        /// <code> LVertex * v;	
        /// pBigSquareVB-&gt;Lock( 0, 0, (BYTE**)&amp;v, 0 ); v[0].x  = 0.0f;  v[0].y  = 10.0;  v[0].z  = 10.0f;	
        /// v[0].diffuse  = 0xffff0000;	
        /// v[0].specular = 0xff00ff00;	
        /// v[0].tu = 0.0f;  v[0].tv = 0.0f; v[1].x  = 0.0f;  v[1].y  = 0.0f;  v[1].z  = 10.0f;	
        /// v[1].diffuse  = 0xff00ff00;	
        /// v[1].specular = 0xff00ffff;	
        /// v[1].tu = 0.0f;  v[1].tv = 0.0f; v[2].x  = 10.0f; v[2].y  = 10.0f; v[2].z  = 10.0f;	
        /// v[2].diffuse  = 0xffff00ff;	
        /// v[2].specular = 0xff000000;	
        /// v[2].tu = 0.0f;  v[2].tv = 0.0f; v[3].x  = 0.0f; v[3].y  = 10.0f;  v[3].z = 10.0f;	
        /// v[3].diffuse  = 0xffffff00;	
        /// v[3].specular = 0xffff0000;	
        /// v[3].tu = 0.0f; v[3].tv = 0.0f; pBigSquareVB-&gt;Unlock(); </code>	
        /// 	
        ///   The vertex buffer has been initialized and is ready to render. The following code example shows how to use the legacy FVF to draw a square. 	
        /// <code> g_d3dDevice-&gt;SetFVF(VertexFVF);	
        /// g_d3dDevice-&gt;SetStreamSource(0, pBigSquareVB, 0, sizeof(LVertex));	
        /// g_d3dDevice-&gt;DrawPrimitive(D3DPT_TRIANGLESTRIP, 0 ,2); </code>	
        /// 	
        ///    Here are the steps necessary to initialize and use vertices that have a position, a normal, and texture coordinates:  Define the custom vertex type and FVF code.	
        /// <code> struct Vertex	
        /// { FLOAT x, y, z; FLOAT nx, ny, nz; FLOAT tu, tv;	
        /// }; const DWORD VertexFVF = ( D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1 ); </code>	
        /// 	
        ///   Create a vertex buffer with enough room for four vertices using <see cref="SlimDX2.Direct3D9.Device.CreateVertexBuffer"/> (similar to the example above). Set the values for each vertex. 	
        /// <code> Vertex * v;	
        /// pBigSquareVB-&gt;Lock(0, 0, (BYTE**)&amp;v, 0); v[0].x  = 0.0f;  v[0].y  = 10.0;  v[0].z  = 10.0f;	
        /// v[0].nx = 0.0f;  v[0].ny = 1.0f;  v[0].nz = 0.0f;	
        /// v[0].tu = 0.0f;  v[0].tv = 0.0f; v[1].x  = 0.0f;  v[1].y  = 0.0f;  v[1].z  = 10.0f;	
        /// v[1].nx = 0.0f;  v[1].ny = 1.0f;  v[1].nz = 0.0f;	
        /// v[1].tu = 0.0f;  v[1].tv = 0.0f; v[2].x  = 10.0f; v[2].y  = 10.0f; v[2].z  = 10.0f;	
        /// v[2].nx = 0.0f;  v[2].ny = 1.0f;  v[2].nz = 0.0f;	
        /// v[2].tu = 0.0f;  v[2].tv = 0.0f; v[3].x  = 0.0f; v[3].y  = 10.0f;  v[3].z = 10.0f;	
        /// v[3].nx = 0.0f; v[3].ny = 1.0f;   v[3].nz = 0.0f;	
        /// v[3].tu = 0.0f; v[3].tv = 0.0f; pBigSquareVB-&gt;Unlock(); </code>	
        /// 	
        ///   Draw the object (similar to the example above).  	
        /// </remarks>	
        /// <param name="vertexFormat"> DWORD containing the fixed function vertex type. For more information, see <see cref="SlimDX2.Direct3D9.VertexFormat"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetFVF([None] int FVF)</unmanaged>
        internal SlimDX2.Result SetVertexFormat(SlimDX2.Direct3D9.VertexFormat vertexFormat) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 89 * 4, unchecked((int)vertexFormat));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the fixed vertex function declaration.	
        /// </summary>	
        /// <remarks>	
        ///  The fixed vertex function declaration is a set of FVF flags that determine how vertices processed by the fixed function pipeline will be used. 	
        /// </remarks>	
        /// <param name="vertexFormat"> A DWORD pointer to the fixed function vertex type. For more information, see <see cref="SlimDX2.Direct3D9.VertexFormat"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetFVF([Out] int* pFVF)</unmanaged>
        internal SlimDX2.Result GetVertexFormat(out SlimDX2.Direct3D9.VertexFormat vertexFormat) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* vertexFormat_ = &vertexFormat)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 90 * 4, vertexFormat_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a vertex shader.	
        /// </summary>	
        /// <remarks>	
        ///  When a device is created, <see cref="SlimDX2.Direct3D9.Direct3D.CreateDevice"/> uses the behavior flag to determine whether to process vertices in hardware or software. There are three possibilities:  Process vertices in hardware by setting D3DCREATE_HARDWARE_VERTEXPROCESSING. Process vertices in software by setting D3DCREATE_SOFTWARE_VERTEXPROCESSING. Process vertices in either hardware or software by setting D3DCREATE_MIXED_VERTEXPROCESSING. To switch a mixed-mode device between software and hardware processing, use <see cref="SlimDX2.Direct3D9.Device.SetSoftwareVertexProcessing"/>.  For an example using <see cref="SlimDX2.Direct3D9.D3DX9.CompileShader"/>, see {{HLSLwithoutEffects Sample}}. 	
        /// </remarks>	
        /// <param name="functionRef"> Pointer to an array of tokens that represents the vertex shader, including any embedded debug and symbol table information.    Use a function such as <see cref="SlimDX2.Direct3D9.D3DX9.CompileShader"/> to create the array from a HLSL shader. Use a function like <see cref="SlimDX2.Direct3D9.D3DX9.AssembleShader"/> to create the token array from an assembly language shader. Use a function like <see cref="SlimDX2.Direct3D9.EffectCompiler.CompileShader"/> to create the array from an effect.  </param>
        /// <param name="shaderRef"> Pointer to the returned vertex shader interface (see <see cref="SlimDX2.Direct3D9.VertexShader"/>). </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateVertexShader([None] const int* pFunction,[None] IDirect3DVertexShader9** ppShader)</unmanaged>
        internal SlimDX2.Result CreateVertexShader(ref int functionRef, out SlimDX2.Direct3D9.VertexShader shaderRef) {
            unsafe {
                IntPtr shaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* functionRef_ = &functionRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 91 * 4, functionRef_, &shaderRef_);
                shaderRef = (shaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexShader(shaderRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the vertex shader.	
        /// </summary>	
        /// <remarks>	
        ///  To set a fixed-function vertex shader (after having set a programmable vertex shader), call IDirect3DDevice9::SetVertexShader(NULL) to release the programmable shader, and then call <see cref="SlimDX2.Direct3D9.Device.SetVertexFormat"/> with the fixed-function vertex format. 	
        /// </remarks>	
        /// <param name="shaderRef"> Vertex shader interface. For more information, see <see cref="SlimDX2.Direct3D9.VertexShader"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetVertexShader([None] IDirect3DVertexShader9* pShader)</unmanaged>
        internal SlimDX2.Result SetVertexShader(SlimDX2.Direct3D9.VertexShader shaderRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 92 * 4, (void*)((shaderRef == null)?IntPtr.Zero:shaderRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the currently set vertex shader.	
        /// </summary>	
        /// <remarks>	
        ///  Typically, methods that return state will not work on a device that is created using D3DCREATE_PUREDEVICE. This method however, will work even on a pure device because it returns an interface. 	
        /// </remarks>	
        /// <param name="shaderRef"> Pointer to a vertex shader interface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If ppShader is invalid, D3DERR_INVALIDCALL is returned.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetVertexShader([Out] IDirect3DVertexShader9** ppShader)</unmanaged>
        internal SlimDX2.Result GetVertexShader(out SlimDX2.Direct3D9.VertexShader shaderRef) {
            unsafe {
                IntPtr shaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 93 * 4, &shaderRef_);
                shaderRef = (shaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexShader(shaderRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a floating-point vertex shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="constantDataRef"> Pointer to an array of constants. </param>
        /// <param name="vector4fCount"> Number of four float vectors in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetVertexShaderConstantF([None] UINT StartRegister,[None] const float* pConstantData,[None] UINT Vector4fCount)</unmanaged>
        public SlimDX2.Result SetVertexShaderConstantF(int startRegister, ref float constantDataRef, int vector4fCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 94 * 4, startRegister, constantDataRef_, vector4fCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a floating-point vertex shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="constantDataRef"> Pointer to an array of constants. </param>
        /// <param name="vector4fCount"> Number of four float vectors in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetVertexShaderConstantF([None] UINT StartRegister,[Out] float* pConstantData,[None] UINT Vector4fCount)</unmanaged>
        public SlimDX2.Result GetVertexShaderConstantF(int startRegister, out float constantDataRef, int vector4fCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 95 * 4, startRegister, constantDataRef_, vector4fCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an integer vertex shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="constantDataRef"> Pointer to an array of constants. </param>
        /// <param name="vector4iCount"> Number of four integer vectors in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetVertexShaderConstantI([None] UINT StartRegister,[None] const int* pConstantData,[None] UINT Vector4iCount)</unmanaged>
        public SlimDX2.Result SetVertexShaderConstantI(int startRegister, ref int constantDataRef, int vector4iCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 96 * 4, startRegister, constantDataRef_, vector4iCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an integer vertex shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="constantDataRef"> Pointer to an array of constants. </param>
        /// <param name="vector4iCount"> Number of four integer vectors in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetVertexShaderConstantI([None] UINT StartRegister,[Out] int* pConstantData,[None] UINT Vector4iCount)</unmanaged>
        public SlimDX2.Result GetVertexShaderConstantI(int startRegister, out int constantDataRef, int vector4iCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 97 * 4, startRegister, constantDataRef_, vector4iCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a Boolean vertex shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="constantDataRef"> Pointer to an array of constants. </param>
        /// <param name="boolCount"> Number of boolean values in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetVertexShaderConstantB([None] UINT StartRegister,[None] const BOOL* pConstantData,[None] UINT BoolCount)</unmanaged>
        public SlimDX2.Result SetVertexShaderConstantB(int startRegister, ref bool constantDataRef, int boolCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 98 * 4, startRegister, (constantDataRef?1:0), boolCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a Boolean vertex shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="constantDataRef"> Pointer to an array of constants. </param>
        /// <param name="boolCount"> Number of Boolean values in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetVertexShaderConstantB([None] UINT StartRegister,[Out] BOOL* pConstantData,[None] UINT BoolCount)</unmanaged>
        public SlimDX2.Result GetVertexShaderConstantB(int startRegister, out bool constantDataRef, int boolCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 99 * 4, startRegister, constantDataRef_, boolCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Binds a vertex buffer to a device data stream. For more information, see {{Setting the Stream Source (Direct3D 9)}}.	
        /// </summary>	
        /// <remarks>	
        ///  When a FVF vertex shader is used, the stride of the vertex stream must match the vertex size, computed from the FVF. When a declaration is used, the stride should be greater than or equal to the stream size computed from the declaration. When calling SetStreamSource, the stride is normally required to be equal to the vertex size. However, there are times when you may want to draw multiple instances of the same or similar geometry (such as when using instancing to draw). For this case, use a zero stride to tell the runtime not to increment the vertex buffer offset (ie: use the same vertex data for all instances). For more information about instancing, see {{Efficiently Drawing Multiple Instances of Geometry (Direct3D 9)}}. 	
        /// </remarks>	
        /// <param name="streamNumber"> Specifies the data stream, in the range from 0 to the maximum number of streams -1. </param>
        /// <param name="streamDataRef"> Pointer to an <see cref="SlimDX2.Direct3D9.VertexBuffer"/> interface, representing the vertex buffer to bind to the specified data stream.  </param>
        /// <param name="offsetInBytes"> Offset from the beginning of the stream to the beginning of the vertex data, in bytes. To find out if the device supports stream offsets, see the D3DDEVCAPS2_STREAMOFFSET constant in {{D3DDEVCAPS2}}. </param>
        /// <param name="stride"> Stride of the component, in bytes. See Remarks. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetStreamSource([None] UINT StreamNumber,[None] IDirect3DVertexBuffer9* pStreamData,[None] UINT OffsetInBytes,[None] UINT Stride)</unmanaged>
        public SlimDX2.Result SetStreamSource(int streamNumber, SlimDX2.Direct3D9.VertexBuffer streamDataRef, int offsetInBytes, int stride) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 100 * 4, streamNumber, (void*)((streamDataRef == null)?IntPtr.Zero:streamDataRef.NativePointer), offsetInBytes, stride);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a vertex buffer bound to the specified data stream.	
        /// </summary>	
        /// <remarks>	
        ///  A stream is defined as a uniform array of component data, where each component consists of one or more elements representing a single entity such as position, normal, color, and so on. When a FVF vertex shader is used, the stride of the vertex stream must match the vertex size, computed from the FVF. When a declaration is used, the stride should be greater than or equal to the stream size computed from the declaration.  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.VertexBuffer"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DVertexBuffer9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="streamNumber"> Specifies the data stream, in the range from 0 to the maximum number of streams minus one.  </param>
        /// <param name="streamDataRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VertexBuffer"/> interface, representing the returned vertex buffer bound to the specified data stream.  </param>
        /// <param name="offsetInBytesRef"> Pointer containing the offset from the beginning of the stream to the beginning of the vertex data. The offset is measured in bytes. See Remarks. </param>
        /// <param name="strideRef"> Pointer to a returned stride of the component, in bytes. See Remarks.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetStreamSource([None] UINT StreamNumber,[Out] IDirect3DVertexBuffer9** ppStreamData,[Out] UINT* pOffsetInBytes,[Out] UINT* pStride)</unmanaged>
        public SlimDX2.Result GetStreamSource(int streamNumber, out SlimDX2.Direct3D9.VertexBuffer streamDataRef, out int offsetInBytesRef, out int strideRef) {
            unsafe {
                IntPtr streamDataRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* offsetInBytesRef_ = &offsetInBytesRef)
                    fixed (void* strideRef_ = &strideRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 101 * 4, streamNumber, &streamDataRef_, offsetInBytesRef_, strideRef_);
                streamDataRef = (streamDataRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexBuffer(streamDataRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the stream source frequency divider value. This may be used to draw several instances of geometry.	
        /// </summary>	
        /// <remarks>	
        ///  There are two constants defined in d3d9types.h that are designed to use with SetStreamSourceFreq: D3DSTREAMSOURCE_INDEXEDDATA and D3DSTREAMSOURCE_INSTANCEDATA. To see how to use the constants, see {{Efficiently Drawing Multiple Instances of Geometry (Direct3D 9)}}. 	
        /// </remarks>	
        /// <param name="streamNumber"> Stream source number. </param>
        /// <param name="setting"> This parameter may have two different values. See remarks. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetStreamSourceFreq([None] UINT StreamNumber,[None] UINT Setting)</unmanaged>
        public SlimDX2.Result SetStreamSourceFreq(int streamNumber, int setting) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 102 * 4, streamNumber, setting);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the stream source frequency divider value.	
        /// </summary>	
        /// <remarks>	
        ///  Vertex shaders can now be invoked more than once per vertex. See {{Drawing Non-Indexed Geometry}}. 	
        /// </remarks>	
        /// <param name="streamNumber"> Stream source number. </param>
        /// <param name="settingRef"> Returns the frequency divider value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetStreamSourceFreq([None] UINT StreamNumber,[Out] UINT* pSetting)</unmanaged>
        public SlimDX2.Result GetStreamSourceFreq(int streamNumber, out int settingRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* settingRef_ = &settingRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 103 * 4, streamNumber, settingRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets index data.	
        /// </summary>	
        /// <remarks>	
        ///  When an application no longer holds a references to this interface, the interface will automatically be freed. The IDirect3DDevice9::SetIndices method sets the current index array to an index buffer. The single set of indices is used to index all streams.  	
        /// </remarks>	
        /// <param name="indexDataRef"> Pointer to an <see cref="SlimDX2.Direct3D9.IndexBuffer"/> interface, representing the index data to be set.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetIndices([None] IDirect3DIndexBuffer9* pIndexData)</unmanaged>
        internal SlimDX2.Result SetIndices(SlimDX2.Direct3D9.IndexBuffer indexDataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 104 * 4, (void*)((indexDataRef == null)?IntPtr.Zero:indexDataRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves index data.	
        /// </summary>	
        /// <remarks>	
        ///   Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.IndexBuffer"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DIndexBuffer9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="indexDataRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.IndexBuffer"/> interface, representing the returned index data.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetIndices([Out] IDirect3DIndexBuffer9** ppIndexData)</unmanaged>
        internal SlimDX2.Result GetIndices(out SlimDX2.Direct3D9.IndexBuffer indexDataRef) {
            unsafe {
                IntPtr indexDataRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 105 * 4, &indexDataRef_);
                indexDataRef = (indexDataRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.IndexBuffer(indexDataRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a pixel shader.	
        /// </summary>	
        /// <param name="functionRef"> Pointer to the pixel shader function token array, specifying the blending operations. This value cannot be NULL.  </param>
        /// <param name="shaderRef"> Pointer to the returned pixel shader interface. See <see cref="SlimDX2.Direct3D9.PixelShader"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::CreatePixelShader([None] const int* pFunction,[None] IDirect3DPixelShader9** ppShader)</unmanaged>
        internal SlimDX2.Result CreatePixelShader(ref int functionRef, out SlimDX2.Direct3D9.PixelShader shaderRef) {
            unsafe {
                IntPtr shaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* functionRef_ = &functionRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 106 * 4, functionRef_, &shaderRef_);
                shaderRef = (shaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PixelShader(shaderRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the current pixel shader to a previously created pixel shader.	
        /// </summary>	
        /// <param name="shaderRef"> Pixel shader interface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetPixelShader([None] IDirect3DPixelShader9* pShader)</unmanaged>
        internal SlimDX2.Result SetPixelShader(SlimDX2.Direct3D9.PixelShader shaderRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 107 * 4, (void*)((shaderRef == null)?IntPtr.Zero:shaderRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the currently set pixel shader.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not work on a device that is created using D3DCREATE_PUREDEVICE. 	
        /// </remarks>	
        /// <param name="shaderRef"> Pointer to a pixel shader interface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetPixelShader([Out] IDirect3DPixelShader9** ppShader)</unmanaged>
        internal SlimDX2.Result GetPixelShader(out SlimDX2.Direct3D9.PixelShader shaderRef) {
            unsafe {
                IntPtr shaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 108 * 4, &shaderRef_);
                shaderRef = (shaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PixelShader(shaderRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a floating-point shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="constantDataRef"> Pointer to an array of constants. </param>
        /// <param name="vector4fCount"> Number of four float vectors in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetPixelShaderConstantF([None] UINT StartRegister,[None] const float* pConstantData,[None] UINT Vector4fCount)</unmanaged>
        public SlimDX2.Result SetPixelShaderConstantF(int startRegister, ref float constantDataRef, int vector4fCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 109 * 4, startRegister, constantDataRef_, vector4fCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a floating-point shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="constantDataRef"> Pointer to an array of constants. </param>
        /// <param name="vector4fCount"> Number of four float vectors in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetPixelShaderConstantF([None] UINT StartRegister,[Out] float* pConstantData,[None] UINT Vector4fCount)</unmanaged>
        public SlimDX2.Result GetPixelShaderConstantF(int startRegister, out float constantDataRef, int vector4fCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 110 * 4, startRegister, constantDataRef_, vector4fCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an integer shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="constantDataRef"> Pointer to an array of constants. </param>
        /// <param name="vector4iCount"> Number of four integer vectors in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetPixelShaderConstantI([None] UINT StartRegister,[None] const int* pConstantData,[None] UINT Vector4iCount)</unmanaged>
        public SlimDX2.Result SetPixelShaderConstantI(int startRegister, ref int constantDataRef, int vector4iCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 111 * 4, startRegister, constantDataRef_, vector4iCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an integer shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="constantDataRef"> Pointer to an array of constants. </param>
        /// <param name="vector4iCount"> Number of four integer vectors in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetPixelShaderConstantI([None] UINT StartRegister,[Out] int* pConstantData,[None] UINT Vector4iCount)</unmanaged>
        public SlimDX2.Result GetPixelShaderConstantI(int startRegister, out int constantDataRef, int vector4iCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 112 * 4, startRegister, constantDataRef_, vector4iCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a Boolean shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="constantDataRef"> Pointer to an array of constants. </param>
        /// <param name="boolCount"> Number of boolean values in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::SetPixelShaderConstantB([None] UINT StartRegister,[None] const BOOL* pConstantData,[None] UINT BoolCount)</unmanaged>
        public SlimDX2.Result SetPixelShaderConstantB(int startRegister, ref bool constantDataRef, int boolCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 113 * 4, startRegister, (constantDataRef?1:0), boolCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a Boolean shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="constantDataRef"> Pointer to an array of constants. </param>
        /// <param name="boolCount"> Number of Boolean values in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::GetPixelShaderConstantB([None] UINT StartRegister,[Out] BOOL* pConstantData,[None] UINT BoolCount)</unmanaged>
        public SlimDX2.Result GetPixelShaderConstantB(int startRegister, out bool constantDataRef, int boolCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 114 * 4, startRegister, constantDataRef_, boolCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Draws a rectangular patch using the currently set streams.	
        /// </summary>	
        /// <remarks>	
        ///  For static patches: Set the vertex shader, set the appropriate streams, supply patch information in the pRectPatchInfo parameter, and specify a handle so that Direct3D can capture and cache information. Call IDirect3DDevice9::DrawRectPatch subsequently with pRectPatchInfo set to NULL to efficiently draw the patch. When drawing a cached patch, the currently set streams are ignored. Override the cached pNumSegs by specifying a new value for pNumSegs. When rendering a cached patch, you must set the same vertex shader that was set when it was captured. Calling IDirect3DDevice9::DrawRectPatch with a handle invalidates the same handle cached by a previous <see cref="SlimDX2.Direct3D9.Device.DrawTriPatch"/> call. For dynamic patches, the patch data changes for every rendering of the patch, so it is not efficient to cache information. The application can convey this to Direct3D by setting Handle to 0. In this case, Direct3D draws the patch using the currently set streams and the pNumSegs values, and does not cache any information. It is not valid to simultaneously set Handle to 0 and pRectPatchInfo to NULL. 	
        /// </remarks>	
        /// <param name="handle"> Handle to the rectangular patch to draw.  </param>
        /// <param name="numSegsRef"> Pointer to an array of four floating-point values that identify the number of segments each edge of the rectangle patch should be divided into when tessellated. See <see cref="SlimDX2.Direct3D9.RectanglePatchInfo"/>.  </param>
        /// <param name="rectPatchInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.RectanglePatchInfo"/> structure, describing the rectangular patch to draw.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be  D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::DrawRectPatch([None] UINT Handle,[None] const float* pNumSegs,[None] const D3DRECTPATCH_INFO* pRectPatchInfo)</unmanaged>
        public SlimDX2.Result DrawRectPatch(int handle, ref float numSegsRef, ref SlimDX2.Direct3D9.RectanglePatchInfo rectPatchInfoRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* numSegsRef_ = &numSegsRef)
                    fixed (void* rectPatchInfoRef_ = &rectPatchInfoRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 115 * 4, handle, numSegsRef_, rectPatchInfoRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Draws a triangular patch using the currently set streams.	
        /// </summary>	
        /// <remarks>	
        ///  For static patches: Set the vertex shader, set the appropriate streams, supply patch information in the pTriPatchInfo parameter, and specify a handle so that Direct3D can capture and cache information. To efficiently draw the patch, call IDirect3DDevice9::DrawTriPatch with pTriPatchInfo set to NULL. When drawing a cached patch, the currently set streams are ignored. Override the cached pNumSegs by specifying a new value for pNumSegs. When rendering a cached patch, you must set the same vertex shader that was set when it was captured. Calling IDirect3DDevice9::DrawTriPatch with a handle invalidates the same handle cached by a previous <see cref="SlimDX2.Direct3D9.Device.DrawRectPatch"/> call. For dynamic patches, the patch data changes for every rendering of the patch so it is not efficient to cache information. The application can convey this to Direct3D by setting Handle to 0. In this case, Direct3D draws the patch using the currently set streams and the pNumSegs values, and does not cache any information. It is not valid to simultaneously set Handle to 0 and pTriPatchInfo to NULL. 	
        /// </remarks>	
        /// <param name="handle"> Handle to the triangular patch to draw.  </param>
        /// <param name="numSegsRef"> Pointer to an array of three floating-point values that identify the number of segments each edge of the triangle patch should be divided into when tessellated. See <see cref="SlimDX2.Direct3D9.TrianglePatchInfo"/>.  </param>
        /// <param name="triPatchInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.TrianglePatchInfo"/> structure, describing the triangular high-order patch to draw.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be  D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::DrawTriPatch([None] UINT Handle,[None] const float* pNumSegs,[None] const D3DTRIPATCH_INFO* pTriPatchInfo)</unmanaged>
        public SlimDX2.Result DrawTriPatch(int handle, ref float numSegsRef, ref SlimDX2.Direct3D9.TrianglePatchInfo triPatchInfoRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* numSegsRef_ = &numSegsRef)
                    fixed (void* triPatchInfoRef_ = &triPatchInfoRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 116 * 4, handle, numSegsRef_, triPatchInfoRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Frees a cached high-order patch.	
        /// </summary>	
        /// <param name="handle"> Handle of the cached high-order patch to delete.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be  D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::DeletePatch([None] UINT Handle)</unmanaged>
        public SlimDX2.Result DeletePatch(int handle) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 117 * 4, handle);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a status query.	
        /// </summary>	
        /// <remarks>	
        ///  This method is provided for both synchronous and asynchronous queries. It takes the place of GetInfo, which is no longer supported in Direct3D 9. Synchronous and asynchronous queries are created with IDirect3DDevice9::CreateQuery with <see cref="SlimDX2.Direct3D9.QueryType"/>. When a query has been created and the API calls have been made that are being queried, use <see cref="SlimDX2.Direct3D9.Query.Issue"/> to issue a query and  <see cref="SlimDX2.Direct3D9.Query.GetData"/> to get the results of the query. 	
        /// </remarks>	
        /// <param name="type"> Identifies the query type. For more information, see <see cref="SlimDX2.Direct3D9.QueryType"/>. </param>
        /// <param name="queryRef"> Returns a pointer to the query interface that manages the query object. See <see cref="SlimDX2.Direct3D9.Query"/>.  This parameter can be set to NULL to see if a query is supported. If the query is not supported, the method returns D3DERR_NOTAVAILABLE. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_NOTAVAILABLE or  E_OUTOFMEMORY.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateQuery([None] D3DQUERYTYPE Type,[None] IDirect3DQuery9** ppQuery)</unmanaged>
        internal SlimDX2.Result CreateQuery(SlimDX2.Direct3D9.QueryType type, out SlimDX2.Direct3D9.Query queryRef) {
            unsafe {
                IntPtr queryRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 118 * 4, unchecked((int)type), &queryRef_);
                queryRef = (queryRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Query(queryRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DStateBlock9</unmanaged>
    [Guid("B07C4FE5-310D-4ba8-A23C-4F0F206F218B")]
    public partial class StateBlock : SlimDX2.ComObject {
        public StateBlock(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the device.	
        /// </summary>	
        /// <unmanaged>HRESULT IDirect3DStateBlock9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the device.	
        /// </summary>	
        /// <param name="deviceRef"> Pointer to the IDirect3DDevice9 interface that is returned. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DStateBlock9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Capture the current value of states that are included in a stateblock.	
        /// </summary>	
        /// <remarks>	
        ///  The Capture method captures current values for states within an existing state block. It does not capture the entire state of the device. For example: 	
        /// <code> IDirect3DStateBlock9* pStateBlock = NULL; pd3dDevice-&gt;BeginStateBlock();	
        /// // Add the ZENABLE state to the stateblock 	
        /// pd3dDevice-&gt;SetRenderState ( D3DRS_ZENABLE, D3DZB_TRUE );	
        /// pd3dDevice-&gt;EndStateBlock ( &amp;pStateBlock ); // Change the current value that is stored in the state block	
        /// pd3dDevice-&gt;SetRenderState ( D3DRS_ZENABLE, D3DZB_FALSE );	
        /// pStateBlock-&gt;Capture();			 pStateBlock-&gt;Release(); </code>	
        /// 	
        ///  Creating an empty stateblock and calling the Capture method does nothing if no states have been set. The Capture method  will not capture information for lights that are explicitly or implicitly created after the stateblock is created. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails because capture cannot be done while in record mode, the return value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DStateBlock9::Capture()</unmanaged>
        public SlimDX2.Result Capture() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Apply the state block to the current device state.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails while in record mode, the return value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DStateBlock9::Apply()</unmanaged>
        public SlimDX2.Result Apply() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DResource9</unmanaged>
    [Guid("05EEC05D-8F7D-4362-B999-D1BAF357C704")]
    public partial class Resource : SlimDX2.ComObject {
        public Resource(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the device associated with a resource.	
        /// </summary>	
        /// <remarks>	
        ///  This method allows navigation to the owning device object. Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DDevice9 interface results in a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DResource9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the priority for this resource.	
        /// </summary>	
        /// <remarks>	
        ///  IDirect3DResource9::GetPriority is used for priority control of managed resources. This method returns 0 on nonmanaged resources. Priorities are used to determine when managed resources are to be removed from memory. A resource assigned a low priority is removed before a resource with a high priority. If two resources have the same priority, the resource that was used more recently is kept in memory; the other resource is removed. Managed resources have a default priority of 0. 	
        /// </remarks>	
        /// <unmanaged>int IDirect3DResource9::GetPriority()</unmanaged>
        public int Priority {
                get { return GetPriority(); }
        }
        
        /// <summary>	
        /// Returns the type of the resource.	
        /// </summary>	
        /// <unmanaged>D3DRESOURCETYPE IDirect3DResource9::GetType()</unmanaged>
        public SlimDX2.Direct3D9.ResourceType TypeInfo {
                get { return GetTypeInfo(); }
        }
        
        /// <summary>	
        /// Retrieves the device associated with a resource.	
        /// </summary>	
        /// <remarks>	
        ///  This method allows navigation to the owning device object. Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DDevice9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="deviceRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface to fill with the device pointer, if the query succeeds.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DResource9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Associates data with the resource that is intended for use by the application, not by Direct3D. Data is passed by value, and multiple sets of data can be associated with a single resource.	
        /// </summary>	
        /// <remarks>	
        ///  Direct3D does not manage the memory at pData. If this buffer was dynamically allocated, it is the calling application's responsibility to free the memory. 	
        /// </remarks>	
        /// <param name="refguid"> Reference to the globally unique identifier that identifies the private data to set. </param>
        /// <param name="dataRef"> Pointer to a buffer that contains the data to be associated with the resource.  </param>
        /// <param name="sizeOfData"> Size of the buffer at pData, in bytes.  </param>
        /// <param name="flags"> Value that describes the type of data being passed, or indicates to the application that the data should be invalidated when the resource changes.    ItemDescription  (none)  If no flags are specified, Direct3D allocates memory to hold the data within the buffer and copies the data into the new buffer. The buffer allocated by Direct3D is automatically freed, as appropriate.   D3DSPD_IUNKNOWN  The data at pData is a pointer to an <see cref="SlimDX2.ComObject"/> interface. SizeOfData must be set to the size of a pointer to IUnknown, that is, sizeof(IUnknown*). Direct3D automatically callsIUnknown through pData when the private data is destroyed. Private data will be destroyed by a subsequent call to IDirect3DResource9::SetPrivateData with the same GUID, a subsequent call to <see cref="SlimDX2.Direct3D9.Resource.FreePrivateData"/>, or when the <see cref="SlimDX2.Direct3D9.Direct3D"/> object is released. For more information, see Remarks.   ? </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT IDirect3DResource9::SetPrivateData([None] REFGUID refguid,[None] const void* pData,[None] int SizeOfData,[None] int Flags)</unmanaged>
        public SlimDX2.Result SetPrivateData(Guid refguid, IntPtr dataRef, int sizeOfData, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, &refguid, (void*)dataRef, sizeOfData, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copies the private data associated with the resource to a provided buffer.	
        /// </summary>	
        /// <remarks>	
        ///  This method is inherited by the following interfaces:  <see cref="SlimDX2.Direct3D9.Resource"/>,  <see cref="SlimDX2.Direct3D9.BaseTexture"/>, <see cref="SlimDX2.Direct3D9.CubeTexture"/>,  <see cref="SlimDX2.Direct3D9.Texture"/>,  <see cref="SlimDX2.Direct3D9.VolumeTexture"/>, <see cref="SlimDX2.Direct3D9.IndexBuffer"/>,  <see cref="SlimDX2.Direct3D9.VertexBuffer"/>. 	
        /// </remarks>	
        /// <param name="refguid"> The globally unique identifier that identifies the private data to retrieve.  </param>
        /// <param name="dataRef"> Pointer to a previously allocated buffer to fill with the requested private data if the call succeeds. The application calling this method is responsible for allocating and releasing this buffer. If this parameter is NULL, this method will return the buffer size in pSizeOfData. </param>
        /// <param name="sizeOfDataRef"> Pointer to the size of the buffer at  pData, in bytes. If this value is less than the actual size of the private data (such as 0), the method sets this parameter to the required buffer size and the method returns D3DERR_MOREDATA.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_MOREDATA, D3DERR_NOTFOUND. </returns>
        /// <unmanaged>HRESULT IDirect3DResource9::GetPrivateData([None] REFGUID refguid,[None] void* pData,[Out] int* pSizeOfData)</unmanaged>
        public SlimDX2.Result GetPrivateData(Guid refguid, IntPtr dataRef, out int sizeOfDataRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* sizeOfDataRef_ = &sizeOfDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, &refguid, (void*)dataRef, sizeOfDataRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Frees the specified private data associated with this resource.	
        /// </summary>	
        /// <remarks>	
        ///  Direct3D calls this method automatically when a resource is released. 	
        /// </remarks>	
        /// <param name="refguid"> Reference to the globally unique identifier that identifies the private data to free. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTFOUND. </returns>
        /// <unmanaged>HRESULT IDirect3DResource9::FreePrivateData([None] REFGUID refguid)</unmanaged>
        public SlimDX2.Result FreePrivateData(Guid refguid) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, &refguid);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Assigns the priority of a resource for scheduling purposes.	
        /// </summary>	
        /// <remarks>	
        ///  This method is used to change the priority of managed resources (resources created with the <see cref="SlimDX2.Direct3D9.Pool.Managed"/> flag). This method returns 0 on non-managed resources. Priorities are used to determine when managed resources are to be removed from memory. A resource assigned a low priority is removed before a resource with a high priority. If two resources have the same priority, the resource that was used more recently is kept in memory; the other resource is removed. Managed resources have a default priority of 0. Windows Vista only - When this method is called using an <see cref="SlimDX2.Direct3D9.Direct3D9Ex"/> interface, only resources created with the <see cref="SlimDX2.Direct3D9.Pool.Default"/> flag will be affected. 	
        /// </remarks>	
        /// <param name="priorityNew"> Priority to assign to a resource.    Differences between Direct3D 9 and Direct3D 9 for Windows Vista The priority can be any DWORD value; Direct3D 9 for Windows Vista also supports any of these pre-defined values {{D3D9_RESOURCE_PRIORITY}}.   ? </param>
        /// <returns>  <see cref="int"/>  Returns the previous priority value for the resource. </returns>
        /// <unmanaged>int IDirect3DResource9::SetPriority([None] int PriorityNew)</unmanaged>
        public int SetPriority(int priorityNew) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, priorityNew);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the priority for this resource.	
        /// </summary>	
        /// <remarks>	
        ///  IDirect3DResource9::GetPriority is used for priority control of managed resources. This method returns 0 on nonmanaged resources. Priorities are used to determine when managed resources are to be removed from memory. A resource assigned a low priority is removed before a resource with a high priority. If two resources have the same priority, the resource that was used more recently is kept in memory; the other resource is removed. Managed resources have a default priority of 0. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  Returns a DWORD value, indicating the priority of the resource. </returns>
        /// <unmanaged>int IDirect3DResource9::GetPriority()</unmanaged>
        internal int GetPriority() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Preloads a managed resource.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method indicates that the application will need this managed resource shortly. This method has no effect on nonmanaged resources. IDirect3DResource9::PreLoad detects "thrashing" conditions where more resources are being used in each frame than can fit in video memory simultaneously. Under such circumstances IDirect3DResource9::PreLoad silently does nothing. 	
        /// </remarks>	
        /// <unmanaged>void IDirect3DResource9::PreLoad()</unmanaged>
        public void PreLoad() {
            unsafe {
                SlimDX2.Direct3D9.LocalInterop.Callivoid(_nativePointer, 9 * 4);
            }
        }
        
        /// <summary>	
        /// Returns the type of the resource.	
        /// </summary>	
        /// <returns>  <see cref="SlimDX2.Direct3D9.ResourceType"/>  Returns a member of the <see cref="SlimDX2.Direct3D9.ResourceType"/> enumerated type, identifying the type of the resource. </returns>
        /// <unmanaged>D3DRESOURCETYPE IDirect3DResource9::GetType()</unmanaged>
        internal SlimDX2.Direct3D9.ResourceType GetTypeInfo() {
            unsafe {
                SlimDX2.Direct3D9.ResourceType __result__;
                __result__= (SlimDX2.Direct3D9.ResourceType)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DVertexDeclaration9</unmanaged>
    [Guid("DD13C59C-36FA-4098-A8FB-C7ED39DC8546")]
    public partial class VertexDeclaration : SlimDX2.ComObject {
        public VertexDeclaration(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the current device.	
        /// </summary>	
        /// <unmanaged>HRESULT IDirect3DVertexDeclaration9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the current device.	
        /// </summary>	
        /// <param name="deviceRef"> Pointer to the IDirect3DDevice9 interface that is returned. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DVertexDeclaration9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the vertex shader declaration.	
        /// </summary>	
        /// <remarks>	
        ///  The number of elements, pNumElements, includes the {{D3DDECL_END}} macro, which ends the declaration. So the element count is actually one higher than the number of valid vertex elements. Here's an example that will return the vertex declaration array of up to 256 elements: 	
        /// <code> D3DVERTEXELEMENT9 decl[MAXD3DDECLLENGTH];	
        /// UINT numElements;	
        /// HRESULT hr = m_pVertexDeclaration-&gt;GetDeclaration( decl, &amp;numElements); </code>	
        /// 	
        ///  Specify NULL for pDeclto get the number of elements in the declaration. 	
        /// </remarks>	
        /// <param name="elementRef"> Array of vertex elements (see <see cref="SlimDX2.Direct3D9.VertexElement"/>) that make up a vertex shader declaration. The application needs to allocate enough room for this. The vertex element array ends with the {{D3DDECL_END}} macro. </param>
        /// <param name="numElementsRef"> Number of elements in the array. The application needs to allocate enough room for this.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DVertexDeclaration9::GetDeclaration([Out] D3DVERTEXELEMENT9* pElement,[Out] UINT* pNumElements)</unmanaged>
        public SlimDX2.Result GetDeclaration(out SlimDX2.Direct3D9.VertexElement elementRef, out int numElementsRef) {
            unsafe {
                elementRef = new SlimDX2.Direct3D9.VertexElement();
                SlimDX2.Result __result__;
                fixed (void* elementRef_ = &elementRef)
                    fixed (void* numElementsRef_ = &numElementsRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, elementRef_, numElementsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DVertexShader9</unmanaged>
    [Guid("EFC5557E-6265-4613-8A94-43857889EB36")]
    public partial class VertexShader : SlimDX2.ComObject {
        public VertexShader(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the device.	
        /// </summary>	
        /// <unmanaged>HRESULT IDirect3DVertexShader9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the device.	
        /// </summary>	
        /// <param name="deviceRef"> Pointer to the IDirect3DDevice9 interface that is returned. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DVertexShader9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a pointer to the shader data.	
        /// </summary>	
        /// <param name="arg0"> Pointer to a buffer that contains the shader data. The application needs to allocate enough room for this.  </param>
        /// <param name="sizeOfDataRef"> Size of the data, in bytes. To get the buffer size that is needed to retrieve the data, set pData = NULL when calling GetFunction. Then call GetFunction with the returned size, to get the buffer data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DVertexShader9::GetFunction([None] void* arg0,[Out] UINT* pSizeOfData)</unmanaged>
        public SlimDX2.Result GetFunction(IntPtr arg0, out int sizeOfDataRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* sizeOfDataRef_ = &sizeOfDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)arg0, sizeOfDataRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DPixelShader9</unmanaged>
    [Guid("6D3BDBDC-5B02-4415-B852-CE5E8BCCB289")]
    public partial class PixelShader : SlimDX2.ComObject {
        public PixelShader(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the device.	
        /// </summary>	
        /// <unmanaged>HRESULT IDirect3DPixelShader9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the device.	
        /// </summary>	
        /// <param name="deviceRef"> Pointer to the IDirect3DDevice9 interface that is returned. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DPixelShader9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a pointer to the shader data.	
        /// </summary>	
        /// <param name="arg0"> Pointer to a buffer that contains the shader data. The application needs to allocate enough room for this.  </param>
        /// <param name="sizeOfDataRef"> Size of the data, in bytes. To get the buffer size that is needed to retrieve the data, set pData = NULL when calling GetFunction. Then call GetFunction with the returned size, to get the buffer data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DPixelShader9::GetFunction([None] void* arg0,[Out] UINT* pSizeOfData)</unmanaged>
        public SlimDX2.Result GetFunction(IntPtr arg0, out int sizeOfDataRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* sizeOfDataRef_ = &sizeOfDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)arg0, sizeOfDataRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DBaseTexture9</unmanaged>
    [Guid("580CA87E-1D3C-4d54-991D-B7D3E3C298CE")]
    public partial class BaseTexture : SlimDX2.Direct3D9.Resource {
        public BaseTexture(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Returns a value clamped to the maximum level-of-detail set for a managed texture (this method is not supported for an unmanaged texture).	
        /// </summary>	
        /// <unmanaged>int IDirect3DBaseTexture9::GetLOD()</unmanaged>
        public int LOD {
                get { return GetLOD(); }
        }
        
        /// <summary>	
        /// Returns the number of texture levels in a multilevel texture.	
        /// </summary>	
        /// <remarks>	
        ///  This method applies to the following interfaces, which inherit from <see cref="SlimDX2.Direct3D9.BaseTexture"/>.   <see cref="SlimDX2.Direct3D9.CubeTexture"/>   <see cref="SlimDX2.Direct3D9.Texture"/>   <see cref="SlimDX2.Direct3D9.VolumeTexture"/>   	
        /// </remarks>	
        /// <unmanaged>int IDirect3DBaseTexture9::GetLevelCount()</unmanaged>
        public int LevelCount {
                get { return GetLevelCount(); }
        }
        
        /// <summary>	
        /// Get the filter type that is used for automatically generated mipmap sublevels.	
        /// </summary>	
        /// <remarks>	
        ///  Changing the filter type "dirties" the mipmap sublevels and causes them to be regenerated. The (default) filter type set at texture creation time is D3DTEXF_LINEAR. If the driver doesn't support a linear filter, the filter type will be set to D3DTEXF_POINT. All filter types supported by the driver for regular texture filtering are supported for autogeneration except D3DTEXF_NONE. For each resource type, drivers should support all the filter types reported in the corresponding texture, CubeTexture, and volumetexture filter caps. For more information about texture types, see <see cref="SlimDX2.Direct3D9.TextureFilter"/>. This method has no effect if the texture is not created with <see cref="SlimDX2.Direct3D9.Usage.AutoGenerateMipMap"/>. 	
        /// </remarks>	
        /// <unmanaged>D3DTEXTUREFILTERTYPE IDirect3DBaseTexture9::GetAutoGenFilterType()</unmanaged>
        public SlimDX2.Direct3D9.TextureFilter AutoGenFilterType {
                get { return GetAutoGenFilterType(); }
                set { SetAutoGenFilterType(value); }
        }
        
        /// <summary>	
        /// Sets the most detailed level-of-detail for a managed texture. 	
        /// </summary>	
        /// <remarks>	
        ///  This method applies to the following interfaces, which inherit from <see cref="SlimDX2.Direct3D9.BaseTexture"/>.   <see cref="SlimDX2.Direct3D9.CubeTexture"/>   <see cref="SlimDX2.Direct3D9.Texture"/>   <see cref="SlimDX2.Direct3D9.VolumeTexture"/>   <see cref="SlimDX2.Direct3D9.Resource"/>   SetLOD is used for level-of-detail control of managed textures. This method returns 0 on nonmanaged textures. SetLOD communicates to the Direct3D texture manager the most detailed mipmap in the chain that should be loaded into local video memory. For example, in a five-level mipmap chain, setting LODNew to 2 indicates that the texture manager should load only mipmap levels 2 through 4 into local video memory at any given time.  More specifically, if the texture was created with the dimensions of 256x256, setting the most detailed level to 0 indicates that 256 x 256 is the largest mipmap available, setting the most detailed level to 1 indicates that 128 x 128 is the largest mipmap available, and so on, up to the most detailed mip level (the smallest texture size) for the chain. 	
        /// </remarks>	
        /// <param name="lODNew"> Most detailed level-of-detail value to set for the mipmap chain.  </param>
        /// <returns>  <see cref="int"/>  A DWORD value, clamped to the maximum level-of-detail value (one less than the total number of levels). Subsequent calls to this method will return the clamped value, not the level-of-detail value that was previously set. </returns>
        /// <unmanaged>int IDirect3DBaseTexture9::SetLOD([None] int LODNew)</unmanaged>
        public int SetLOD(int lODNew) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, lODNew);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns a value clamped to the maximum level-of-detail set for a managed texture (this method is not supported for an unmanaged texture).	
        /// </summary>	
        /// <returns>  <see cref="int"/>  A DWORD value, clamped to the maximum level-of-detail value (one less than the total number of levels). Calling GetLOD on an unmanaged texture is not supported and will result in a {{D3DERR}} error code being returned. </returns>
        /// <unmanaged>int IDirect3DBaseTexture9::GetLOD()</unmanaged>
        internal int GetLOD() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns the number of texture levels in a multilevel texture.	
        /// </summary>	
        /// <remarks>	
        ///  This method applies to the following interfaces, which inherit from <see cref="SlimDX2.Direct3D9.BaseTexture"/>.   <see cref="SlimDX2.Direct3D9.CubeTexture"/>   <see cref="SlimDX2.Direct3D9.Texture"/>   <see cref="SlimDX2.Direct3D9.VolumeTexture"/>   	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  A DWORD value indicating the number of texture levels in a multilevel texture. </returns>
        /// <unmanaged>int IDirect3DBaseTexture9::GetLevelCount()</unmanaged>
        internal int GetLevelCount() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set the filter type that is used for automatically generated mipmap sublevels.	
        /// </summary>	
        /// <remarks>	
        ///  Changing the filter type "dirties" the mipmap sublevels and causes them to be regenerated. The (default) filter type set at texture creation time is D3DTEXF_LINEAR. If the driver does not support a linear filter, the filter type will be set to D3DTEXF_POINT. All filter types supported by the driver for regular texture filtering are supported for autogeneration except D3DTEXF_NONE. SetAutoGenFilterType will fail unless the driver sets the appropriate D3DPTFILTERCAPS_MINFxxx caps. These values are specified in the TextureFilterCaps and/or  CubeTextureFilterCaps members of <see cref="SlimDX2.Direct3D9.Capabilities"/>.  For more information about texture filter types, see <see cref="SlimDX2.Direct3D9.TextureFilter"/>. This method has no effect if the texture is not created with D3DUSAGE_AUTOGENMIPMAP. In this case, no failure is returned. For more information about usage constants, see <see cref="SlimDX2.Direct3D9.Usage"/>. 	
        /// </remarks>	
        /// <param name="filterType"> Filter type. See <see cref="SlimDX2.Direct3D9.TextureFilter"/>. This method will fail if the filter type is invalid or not supported. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DBaseTexture9::SetAutoGenFilterType([None] D3DTEXTUREFILTERTYPE FilterType)</unmanaged>
        internal SlimDX2.Result SetAutoGenFilterType(SlimDX2.Direct3D9.TextureFilter filterType) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, unchecked((int)filterType));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the filter type that is used for automatically generated mipmap sublevels.	
        /// </summary>	
        /// <remarks>	
        ///  Changing the filter type "dirties" the mipmap sublevels and causes them to be regenerated. The (default) filter type set at texture creation time is D3DTEXF_LINEAR. If the driver doesn't support a linear filter, the filter type will be set to D3DTEXF_POINT. All filter types supported by the driver for regular texture filtering are supported for autogeneration except D3DTEXF_NONE. For each resource type, drivers should support all the filter types reported in the corresponding texture, CubeTexture, and volumetexture filter caps. For more information about texture types, see <see cref="SlimDX2.Direct3D9.TextureFilter"/>. This method has no effect if the texture is not created with <see cref="SlimDX2.Direct3D9.Usage.AutoGenerateMipMap"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="SlimDX2.Direct3D9.TextureFilter"/>  Filter type. See <see cref="SlimDX2.Direct3D9.TextureFilter"/>. A texture must be created with <see cref="SlimDX2.Direct3D9.Usage.AutoGenerateMipMap"/> to use this method. Any other usage value will cause this method to return D3DTEXF_NONE.  </returns>
        /// <unmanaged>D3DTEXTUREFILTERTYPE IDirect3DBaseTexture9::GetAutoGenFilterType()</unmanaged>
        internal SlimDX2.Direct3D9.TextureFilter GetAutoGenFilterType() {
            unsafe {
                SlimDX2.Direct3D9.TextureFilter __result__;
                __result__= (SlimDX2.Direct3D9.TextureFilter)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Generate mipmap sublevels.	
        /// </summary>	
        /// <remarks>	
        ///  An application can generate mipmap sublevels at any time by calling GenerateMipSubLevels. To have mipmap sublevels generated automatically at texture creation time (see {{Automatic Generation of Mipmaps (Direct3D 9)}}), specify  D3DUSAGE_AUTOGENMIPMAP during {{CreateTexture}}, {{CreateCubeTexture}}, and {{CreateVolumeTexture}}. For more information about usage constants, see <see cref="SlimDX2.Direct3D9.Usage"/>. 	
        /// </remarks>	
        /// <unmanaged>void IDirect3DBaseTexture9::GenerateMipSubLevels()</unmanaged>
        public void GenerateMipSubLevels() {
            unsafe {
                SlimDX2.Direct3D9.LocalInterop.Callivoid(_nativePointer, 16 * 4);
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DTexture9</unmanaged>
    [Guid("85C31227-3DE5-4f00-9B3A-F11AC38C18B5")]
    public partial class Texture : SlimDX2.Direct3D9.BaseTexture {
        public Texture(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves a level description of a texture resource.	
        /// </summary>	
        /// <param name="level"> Identifies a level of the texture resource. This method returns a surface description for the level specified by this parameter.  </param>
        /// <param name="descRef"> Pointer to a <see cref="SlimDX2.Direct3D9.SurfaceDescription"/> structure, describing the returned level.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one of the arguments is invalid.  </returns>
        /// <unmanaged>HRESULT IDirect3DTexture9::GetLevelDesc([None] UINT Level,[Out] D3DSURFACE_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetLevelDescription(int level, out SlimDX2.Direct3D9.SurfaceDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D9.SurfaceDescription();
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, level, descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the specified texture surface level.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DSurface9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="level"> Identifies a level of the texture resource. This method returns a surface for the level specified by this parameter. The top-level surface is denoted by 0.  </param>
        /// <param name="surfaceLevelRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the returned surface.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DTexture9::GetSurfaceLevel([None] UINT Level,[Out] IDirect3DSurface9** ppSurfaceLevel)</unmanaged>
        public SlimDX2.Result GetSurfaceLevel(int level, out SlimDX2.Direct3D9.Surface surfaceLevelRef) {
            unsafe {
                IntPtr surfaceLevelRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, level, &surfaceLevelRef_);
                surfaceLevelRef = (surfaceLevelRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(surfaceLevelRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Locks a rectangle on a texture resource.	
        /// </summary>	
        /// <remarks>	
        ///  Textures created with D3DPOOL_DEFAULT are not lockable. Textures created in video memory are lockable when created with {{USAGE_DYNAMIC}}. For performance reasons, dirty regions are recorded only for level zero of a texture. Dirty regions are automatically recorded when IDirect3DTexture9::LockRect is called without <see cref="SlimDX2.Direct3D9.LockFlags.NoDirtyUpdate"/> or D3DLOCK_READONLY. See <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/> for more information. The only lockable format for a depth-stencil texture is {{D3DLOCK_D16_LOCKABLE}}. Video memory textures cannot be locked, but must be modified by calling <see cref="SlimDX2.Direct3D9.Device.UpdateSurface"/> or <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/>. There are exceptions for some proprietary driver pixel formats that Direct3D 9 does not recognize. These can be locked. This method cannot retrieve data from a texture resource created with <see cref="SlimDX2.Direct3D9.Usage.RenderTarget"/> because such a texture must be assigned to D3DPOOL_DEFAULT memory and is therefore not lockable. In this case, use instead <see cref="SlimDX2.Direct3D9.Device.GetRenderTargetData"/> to copy texture data from device memory to system memory. 	
        /// </remarks>	
        /// <param name="level"> Specifies the level of the texture resource to lock.  </param>
        /// <param name="lockedRectRef"> Pointer to a <see cref="SlimDX2.Direct3D9.LockedRect"/> structure, describing the locked region.  </param>
        /// <param name="rectRef"> Pointer to a rectangle to lock. Specified by a pointer to a RECT structure. Specifying NULL for this parameter expands the dirty region to cover the entire texture.  </param>
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY   You may not specify a subrect when using D3DLOCK_DISCARD. For a description of the flags, see <see cref="SlimDX2.Direct3D9.LockFlags"/>.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DTexture9::LockRect([None] UINT Level,[None] D3DLOCKED_RECT* pLockedRect,[None] const RECT* pRect,[None] int Flags)</unmanaged>
        public SlimDX2.Result LockRect(int level, ref SlimDX2.Direct3D9.LockedRect lockedRectRef, ref SlimDX2.Rectangle rectRef, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* lockedRectRef_ = &lockedRectRef)
                    fixed (void* rectRef_ = &rectRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, level, lockedRectRef_, rectRef_, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks a rectangle on a texture resource.	
        /// </summary>	
        /// <param name="level"> Specifies the level of the texture resource to unlock.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DTexture9::UnlockRect([None] UINT Level)</unmanaged>
        public SlimDX2.Result UnlockRect(int level) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, level);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds a dirty region to a texture resource.	
        /// </summary>	
        /// <remarks>	
        ///  For performance reasons, dirty regions are only recorded for level zero of a texture. For sublevels, it is assumed that the corresponding (scaled) rectangle or box is also dirty. Dirty regions are automatically recorded when <see cref="SlimDX2.Direct3D9.Texture.LockRect"/> is called without <see cref="SlimDX2.Direct3D9.LockFlags.NoDirtyUpdate"/> or <see cref="SlimDX2.Direct3D9.LockFlags.ReadOnly"/>. The destination surface of <see cref="SlimDX2.Direct3D9.Device.UpdateSurface"/> is also marked dirty automatically. Using <see cref="SlimDX2.Direct3D9.LockFlags.NoDirtyUpdate"/> and explicitly specifying dirty regions can be used to increase the efficiency of <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/>. Using this method, applications can optimize what subset of a resource is copied by specifying dirty regions on the resource. However, the dirty regions may be expanded to optimize alignment. 	
        /// </remarks>	
        /// <param name="dirtyRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure, specifying the dirty region to add. Specifying NULL expands the dirty region to cover the entire texture.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DTexture9::AddDirtyRect([None] const RECT* pDirtyRect)</unmanaged>
        public SlimDX2.Result AddDirtyRect(ref SlimDX2.Rectangle dirtyRectRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* dirtyRectRef_ = &dirtyRectRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, dirtyRectRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DVolumeTexture9</unmanaged>
    [Guid("2518526C-E789-4111-A7B9-47EF328D13E6")]
    public partial class VolumeTexture : SlimDX2.Direct3D9.BaseTexture {
        public VolumeTexture(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves a level description of a volume texture resource.	
        /// </summary>	
        /// <param name="level"> Identifies a level of the volume texture resource. This method returns a volume description for the level specified by this parameter.  </param>
        /// <param name="descRef"> Pointer to a <see cref="SlimDX2.Direct3D9.VolumeDescription"/> structure, describing the returned volume texture level.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one or more of the arguments are invalid.  </returns>
        /// <unmanaged>HRESULT IDirect3DVolumeTexture9::GetLevelDesc([None] UINT Level,[Out] D3DVOLUME_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetLevelDescription(int level, out SlimDX2.Direct3D9.VolumeDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D9.VolumeDescription();
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, level, descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the specified volume texture level.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Volume"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DVolume9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="level"> Identifies a level of the volume texture resource. This method returns a volume for the level specified by this parameter.  </param>
        /// <param name="volumeLevelRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface, representing the returned volume level.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DVolumeTexture9::GetVolumeLevel([None] UINT Level,[Out] IDirect3DVolume9** ppVolumeLevel)</unmanaged>
        public SlimDX2.Result GetVolumeLevel(int level, out SlimDX2.Direct3D9.Volume volumeLevelRef) {
            unsafe {
                IntPtr volumeLevelRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, level, &volumeLevelRef_);
                volumeLevelRef = (volumeLevelRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Volume(volumeLevelRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Locks a box on a volume texture resource.	
        /// </summary>	
        /// <remarks>	
        ///  For performance reasons, dirty regions are only recorded for level zero of a texture. Dirty regions are automatically recorded when LockBox is called without D3DLOCK_NO_DIRTY_UPDATE or D3DLOCK_READONLY. For more information, see {{UpdateTexture}}. 	
        /// </remarks>	
        /// <param name="level"> Specifies the level of the volume texture resource to lock.  </param>
        /// <param name="lockedVolumeRef"> Pointer to a <see cref="SlimDX2.Direct3D9.LockedBox"/> structure, describing the locked region.  </param>
        /// <param name="boxRef"> Pointer to the volume to lock. This parameter is specified by a pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifying NULL for this parameter locks the entire volume level.  </param>
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY   For a description of the flags, see <see cref="SlimDX2.Direct3D9.LockFlags"/>.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DVolumeTexture9::LockBox([None] UINT Level,[None] D3DLOCKED_BOX* pLockedVolume,[None] const D3DBOX* pBox,[None] int Flags)</unmanaged>
        public SlimDX2.Result LockBox(int level, ref SlimDX2.Direct3D9.LockedBox lockedVolumeRef, ref SlimDX2.Direct3D9.Box boxRef, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* lockedVolumeRef_ = &lockedVolumeRef)
                    fixed (void* boxRef_ = &boxRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, level, lockedVolumeRef_, boxRef_, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks a box on a volume texture resource.	
        /// </summary>	
        /// <param name="level"> Specifies the level of the volume texture resource to unlock.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DVolumeTexture9::UnlockBox([None] UINT Level)</unmanaged>
        public SlimDX2.Result UnlockBox(int level) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, level);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds a dirty region to a volume texture resource.	
        /// </summary>	
        /// <remarks>	
        ///  For performance reasons, dirty regions are only recorded for level zero of a texture. For sublevels, it is assumed that the corresponding (scaled) box is also dirty. Dirty regions are automatically recorded when {{LockBox}} is called without <see cref="SlimDX2.Direct3D9.LockFlags.NoDirtyUpdate"/> or <see cref="SlimDX2.Direct3D9.LockFlags.ReadOnly"/>. Using <see cref="SlimDX2.Direct3D9.LockFlags.NoDirtyUpdate"/> and explicitly specifying dirty regions can be used to increase the efficiency of {{UpdateTexture}}. Using this method, applications can optimize what subset of a resource is copied by specifying dirty boxes on the resource. However, the dirty regions may be expanded to optimize alignment. 	
        /// </remarks>	
        /// <param name="dirtyBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure, specifying the dirty region to add. Specifying NULL expands the dirty region to cover the entire volume texture.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DVolumeTexture9::AddDirtyBox([None] const D3DBOX* pDirtyBox)</unmanaged>
        public SlimDX2.Result AddDirtyBox(ref SlimDX2.Direct3D9.Box dirtyBoxRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* dirtyBoxRef_ = &dirtyBoxRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, dirtyBoxRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DCubeTexture9</unmanaged>
    [Guid("FFF32F81-D953-473a-9223-93D652ABA93F")]
    public partial class CubeTexture : SlimDX2.Direct3D9.BaseTexture {
        public CubeTexture(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves a description of one face of the specified cube texture level.	
        /// </summary>	
        /// <remarks>	
        ///  The <see cref="SlimDX2.Direct3D9.SurfaceDescription"/> structure contains Width and Height members, which describe the size of one face in the cube. To get the size of the entire cube, multiply six (the number of cube faces) by the product of Width and Height. 	
        /// </remarks>	
        /// <param name="level"> Specifies a level of a mipmapped cube texture. </param>
        /// <param name="descRef"> Pointer to a <see cref="SlimDX2.Direct3D9.SurfaceDescription"/> structure, describing one face of the specified cube texture level. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DCubeTexture9::GetLevelDesc([None] UINT Level,[Out] D3DSURFACE_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetLevelDescription(int level, out SlimDX2.Direct3D9.SurfaceDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D9.SurfaceDescription();
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, level, descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a cube texture map surface.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DSurface9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="faceType"> Member of the <see cref="SlimDX2.Direct3D9.CubeMapFace"/> enumerated type, identifying a cube map face.  </param>
        /// <param name="level"> Specifies a level of a mipmapped cube texture.  </param>
        /// <param name="cubeMapSurfaceRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the returned cube texture map surface.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DCubeTexture9::GetCubeMapSurface([None] D3DCUBEMAP_FACES FaceType,[None] UINT Level,[Out] IDirect3DSurface9** ppCubeMapSurface)</unmanaged>
        public SlimDX2.Result GetCubeMapSurface(SlimDX2.Direct3D9.CubeMapFace faceType, int level, out SlimDX2.Direct3D9.Surface cubeMapSurfaceRef) {
            unsafe {
                IntPtr cubeMapSurfaceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, unchecked((int)faceType), level, &cubeMapSurfaceRef_);
                cubeMapSurfaceRef = (cubeMapSurfaceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(cubeMapSurfaceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Locks a rectangle on a cube texture resource.	
        /// </summary>	
        /// <remarks>	
        ///  For performance reasons, dirty regions are only recorded for level zero of a texture. Dirty regions are automatically recorded when IDirect3DCubeTexture9::LockRect is called without D3DLOCK_NO_DIRTY_UPDATE or D3DLOCK_READONLY. See <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/> for more information. Cube textures created with D3DPOOL_DEFAULT are not lockable. Cube textures created in video memory are lockable when created with {{USAGE_DYNAMIC}}. The only lockable format for a depth-stencil texture is <see cref="SlimDX2.Direct3D9.Format.D16Lockable"/>. 	
        /// </remarks>	
        /// <param name="faceType"> Member of the <see cref="SlimDX2.Direct3D9.CubeMapFace"/> enumerated type, identifying a cube map face.  </param>
        /// <param name="level"> Specifies a level of a mipmapped cube texture.  </param>
        /// <param name="lockedRectRef"> Pointer to a <see cref="SlimDX2.Direct3D9.LockedRect"/> structure, describing the region to lock.  </param>
        /// <param name="rectRef"> Pointer to a rectangle to lock. Specified by a pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifying NULL for this parameter expands the dirty region to cover the entire cube texture. </param>
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY   You may not specify a subrect when using D3DLOCK_DISCARD. For a description of the flags, see <see cref="SlimDX2.Direct3D9.LockFlags"/>.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one or more of the arguments is invalid. </returns>
        /// <unmanaged>HRESULT IDirect3DCubeTexture9::LockRect([None] D3DCUBEMAP_FACES FaceType,[None] UINT Level,[None] D3DLOCKED_RECT* pLockedRect,[None] const RECT* pRect,[None] int Flags)</unmanaged>
        public SlimDX2.Result LockRect(SlimDX2.Direct3D9.CubeMapFace faceType, int level, ref SlimDX2.Direct3D9.LockedRect lockedRectRef, ref SlimDX2.Rectangle rectRef, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* lockedRectRef_ = &lockedRectRef)
                    fixed (void* rectRef_ = &rectRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, unchecked((int)faceType), level, lockedRectRef_, rectRef_, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks a rectangle on a cube texture resource.	
        /// </summary>	
        /// <param name="faceType"> Member of the <see cref="SlimDX2.Direct3D9.CubeMapFace"/> enumerated type, identifying a cube map face.  </param>
        /// <param name="level"> Specifies a level of a mipmapped cube texture.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DCubeTexture9::UnlockRect([None] D3DCUBEMAP_FACES FaceType,[None] UINT Level)</unmanaged>
        public SlimDX2.Result UnlockRect(SlimDX2.Direct3D9.CubeMapFace faceType, int level) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, unchecked((int)faceType), level);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds a dirty region to a cube texture resource.	
        /// </summary>	
        /// <remarks>	
        ///  For performance reasons, dirty regions are only recorded for level zero of a texture. For sublevels, it is assumed that the corresponding (scaled) rectangle or box is also dirty. Dirty regions are automatically recorded when <see cref="SlimDX2.Direct3D9.CubeTexture.LockRect"/> is called without <see cref="SlimDX2.Direct3D9.LockFlags.NoDirtyUpdate"/> or <see cref="SlimDX2.Direct3D9.LockFlags.ReadOnly"/>. The destination surface of <see cref="SlimDX2.Direct3D9.Device.UpdateSurface"/> is also marked dirty automatically. Using <see cref="SlimDX2.Direct3D9.LockFlags.NoDirtyUpdate"/> and explicitly specifying dirty regions can be used to increase the efficiency of <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/>. Using this method, applications can optimize what subset of a resource is copied by specifying dirty regions on the resource. However, the dirty regions may be expanded to optimize alignment. 	
        /// </remarks>	
        /// <param name="faceType"> Member of the <see cref="SlimDX2.Direct3D9.CubeMapFace"/> enumerated type, identifying the cube map face.  </param>
        /// <param name="dirtyRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure, specifying the dirty region. Specifying NULL expands the dirty region to cover the entire cube texture.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DCubeTexture9::AddDirtyRect([None] D3DCUBEMAP_FACES FaceType,[None] const RECT* pDirtyRect)</unmanaged>
        public SlimDX2.Result AddDirtyRect(SlimDX2.Direct3D9.CubeMapFace faceType, ref SlimDX2.Rectangle dirtyRectRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* dirtyRectRef_ = &dirtyRectRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, unchecked((int)faceType), dirtyRectRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DVertexBuffer9</unmanaged>
    [Guid("B64BB1B5-FD70-4df6-BF91-19D0A12455E3")]
    public partial class VertexBuffer : SlimDX2.Direct3D9.Resource {
        public VertexBuffer(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves a description of the vertex buffer resource.	
        /// </summary>	
        /// <unmanaged>HRESULT IDirect3DVertexBuffer9::GetDesc([Out] D3DVERTEXBUFFER_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.VertexBufferDescription Description {
                get { SlimDX2.Direct3D9.VertexBufferDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Locks a range of vertex data and obtains a pointer to the vertex buffer memory.	
        /// </summary>	
        /// <remarks>	
        ///  As a general rule, do not hold a lock across more than one frame. When working with vertex buffers, you are allowed to make multiple lock calls; however, you must ensure that the number of lock calls match the number of unlock calls. DrawPrimitive calls will not succeed with any outstanding lock count on any currently set vertex buffer. The D3DLOCK_DISCARD and D3DLOCK_NOOVERWRITE flags are valid only on buffers created with D3DUSAGE_DYNAMIC. For information about using D3DLOCK_DISCARD or D3DLOCK_NOOVERWRITE with IDirect3DVertexBuffer9::Lock, see {{Using Dynamic Vertex and Index Buffers}}. 	
        /// </remarks>	
        /// <param name="offsetToLock"> Offset into the vertex data to lock, in bytes. To lock the entire vertex buffer, specify 0 for both parameters, SizeToLock and OffsetToLock. </param>
        /// <param name="sizeToLock"> Size of the vertex data to lock, in bytes. To lock the entire vertex buffer, specify 0 for both parameters, SizeToLock and OffsetToLock. </param>
        /// <param name="bDataRef"> VOID* pointer to a memory buffer containing the returned vertex data.  </param>
        /// <param name="lockFlags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY D3DLOCK_NOOVERWRITE   For a description of the flags, see <see cref="SlimDX2.Direct3D9.LockFlags"/>.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DVertexBuffer9::Lock([None] UINT OffsetToLock,[None] UINT SizeToLock,[Out] void** ppbData,[None] int Flags)</unmanaged>
        internal SlimDX2.Result Lock_(int offsetToLock, int sizeToLock, out IntPtr bDataRef, SlimDX2.Direct3D9.LockFlags lockFlags) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* bDataRef_ = &bDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, offsetToLock, sizeToLock, bDataRef_, unchecked((int)lockFlags));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks vertex data.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DVertexBuffer9::Unlock()</unmanaged>
        public SlimDX2.Result Unlock() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a description of the vertex buffer resource.	
        /// </summary>	
        /// <param name="descRef"> Pointer to a <see cref="SlimDX2.Direct3D9.VertexBufferDescription"/> structure, describing the returned vertex buffer.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the argument is invalid. </returns>
        /// <unmanaged>HRESULT IDirect3DVertexBuffer9::GetDesc([Out] D3DVERTEXBUFFER_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.VertexBufferDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D9.VertexBufferDescription();
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DIndexBuffer9</unmanaged>
    [Guid("7C9DD65E-D3F7-4529-ACEE-785830ACDE35")]
    public partial class IndexBuffer : SlimDX2.Direct3D9.Resource {
        public IndexBuffer(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves a description of the index buffer resource.	
        /// </summary>	
        /// <unmanaged>HRESULT IDirect3DIndexBuffer9::GetDesc([Out] D3DINDEXBUFFER_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.IndexBufferDescription Description {
                get { SlimDX2.Direct3D9.IndexBufferDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Locks a range of index data and obtains a pointer to the index buffer memory.	
        /// </summary>	
        /// <remarks>	
        ///  As a general rule, do not hold a lock across more than one frame. When working with index buffers, you are allowed to make multiple lock calls. However, you must ensure that the number of lock calls match the number of unlock calls. <see cref="SlimDX2.Direct3D9.Device.DrawIndexedPrimitive"/> calls will not succeed with any outstanding lock count on any currently set index buffer.  The D3DLOCK_DISCARD and D3DLOCK_NOOVERWRITE flags are valid only on buffers created with D3DUSAGE_DYNAMIC. See {{Programming Tips (Direct3D 9)}} for information about using D3DLOCK_DISCARD or D3DLOCK_NOOVERWRITE. 	
        /// </remarks>	
        /// <param name="offsetToLock"> Offset into the index data to lock, in bytes. Lock the entire index buffer by specifying 0 for both parameters, SizeToLock and OffsetToLock.  </param>
        /// <param name="sizeToLock"> Size of the index data to lock, in bytes. Lock the entire index buffer by specifying 0 for both parameters, SizeToLock and OffsetToLock. </param>
        /// <param name="bDataRef"> VOID* pointer to a memory buffer containing the returned index data.  </param>
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY D3DLOCK_NOOVERWRITE   For a description of the flags, see <see cref="SlimDX2.Direct3D9.LockFlags"/>.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DIndexBuffer9::Lock([None] UINT OffsetToLock,[None] UINT SizeToLock,[None] void** ppbData,[None] int Flags)</unmanaged>
        public SlimDX2.Result Lock(int offsetToLock, int sizeToLock, IntPtr bDataRef, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, offsetToLock, sizeToLock, (void*)bDataRef, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks index data.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DIndexBuffer9::Unlock()</unmanaged>
        public SlimDX2.Result Unlock() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a description of the index buffer resource.	
        /// </summary>	
        /// <param name="descRef"> Pointer to a <see cref="SlimDX2.Direct3D9.IndexBufferDescription"/> structure, describing the returned index buffer.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the argument is invalid. </returns>
        /// <unmanaged>HRESULT IDirect3DIndexBuffer9::GetDesc([Out] D3DINDEXBUFFER_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.IndexBufferDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D9.IndexBufferDescription();
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DSurface9</unmanaged>
    [Guid("0CFBAF3A-9FF6-429a-99B3-A2796AF8B89B")]
    public partial class Surface : SlimDX2.Direct3D9.Resource {
        public Surface(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves a description of the surface.	
        /// </summary>	
        /// <unmanaged>HRESULT IDirect3DSurface9::GetDesc([Out] D3DSURFACE_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.SurfaceDescription Description {
                get { SlimDX2.Direct3D9.SurfaceDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves a device context.	
        /// </summary>	
        /// <remarks>	
        ///  The following restrictions apply.  IDirect3DSurface9::GetDC is valid on the following formats only: D3DFMT_R5G6B5, D3DFMT_X1R5G5B5, D3DFMT_R8G8B8, and D3DFMT_X8R8G8B8. Formats that contain Alpha are not supported because the GDI implementations don't have a well-defined behavior on the alpha channel. For more information about formats, see <see cref="SlimDX2.Direct3D9.Format"/>. Only one device context per surface can be returned at a time. IDirect3DSurface9::GetDC will fail if the surface is already locked. If the surface is a member of a mipmap or cubemap, IDirect3DSurface9::GetDC fails if any other mipmap or cubemap member is locked. IDirect3DSurface9::GetDC fails on render targets unless they were created lockable (or, in the case of back buffers, with the D3DPRESENTFLAG_LOCKABLE_BACKBUFFER flag). For surfaces not created with <see cref="SlimDX2.Direct3D9.Device.CreateOffscreenPlainSurface"/>, IDirect3DSurface9::GetDC will fail on default pool (D3DPOOL_DEFAULT) surfaces unless they are dynamic (D3DUSAGE_DYNAMIC) or are lockable render targets. IDirect3DSurface9::GetDC will fail on D3DPOOL_SCRATCH surfaces.  When a device context is outstanding on a surface, the application may not call these methods:  IDirect3DCubeTexture9 <see cref="SlimDX2.Direct3D9.CubeTexture.LockRect"/>  IDirect3DDevice9 <see cref="SlimDX2.Direct3D9.Device.ColorFill"/>   <see cref="SlimDX2.Direct3D9.Device.StretchRect"/>   <see cref="SlimDX2.Direct3D9.Device.UpdateSurface"/>   <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/>  IDirect3DSurface9 <see cref="SlimDX2.Direct3D9.Surface.LockRect"/>  IDirect3DSwapChain9 <see cref="SlimDX2.Direct3D9.SwapChain.Present"/> * IDirect3DTexture9 <see cref="SlimDX2.Direct3D9.Texture.LockRect"/>   ? * (on a swap chain that contains the surface) IDirect3DSurface9::GetDC causes an implicit lock; do not retain the device context for later use. Call <see cref="SlimDX2.Direct3D9.Surface.ReleaseDC"/> to release it.	 It is valid to call IDirect3DSurface9::GetDC/<see cref="SlimDX2.Direct3D9.Surface.ReleaseDC"/> on levels of a mipmap or cubemap, however, these calls will be slow to all miplevels except the topmost level, and GDI operations to these miplevels will not be accelerated. The hdc provides access to Win32 and GDI functionality. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DSurface9::GetDC([Out] HDC* phdc)</unmanaged>
        public IntPtr DC {
                get { IntPtr __output__; GetDC(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Provides access to the parent cube texture or texture (mipmap) object, if this surface is a child level of a cube texture or a mipmap. This method can also provide access to the parent swap chain if the surface is a back-buffer child.	
        /// </summary>	
        /// <remarks>	
        ///  If the surface is created using {{CreateRenderTarget}} or {{CreateOffscreenPlainSurface}} or {{CreateDepthStencilSurface}}, the surface is considered stand alone. In this case, GetContainer will return the Direct3D device used to create the surface. If the call succeeds, the reference count of the container is increased by one. Here's an example getting the parent texture of a mip surface. 	
        /// <code> // Assumes pSurface is a valid IDirect3DSurface9 pointer	
        /// void *pContainer = NULL;	
        /// IDirect3DTexture9 *pTexture = NULL;	
        /// HRESULT hr = pSurface-&gt;GetContainer(IID_IDirect3DTexture9, &amp;pContainer);	
        /// if (SUCCEEDED(hr) &amp;&amp; pContainer)	
        /// { pTexture = (IDirect3DTexture9 *)pContainer;	
        /// } </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="riid"> Reference identifier of the container being requested.  </param>
        /// <param name="containerRef"> Address of a pointer to fill with the container pointer if the query succeeds. See Remarks.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DSurface9::GetContainer([None] REFIID riid,[None] void** ppContainer)</unmanaged>
        public SlimDX2.Result GetContainer(Guid riid, IntPtr containerRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, &riid, (void*)containerRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a description of the surface.	
        /// </summary>	
        /// <param name="descRef"> Pointer to a <see cref="SlimDX2.Direct3D9.SurfaceDescription"/> structure, describing the surface.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the argument is invalid. </returns>
        /// <unmanaged>HRESULT IDirect3DSurface9::GetDesc([Out] D3DSURFACE_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.SurfaceDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D9.SurfaceDescription();
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Locks a rectangle on a surface.	
        /// </summary>	
        /// <remarks>	
        ///  If the <see cref="SlimDX2.Direct3D9.LockFlags.DoNotWait"/> flag is specified and the driver cannot lock the surface immediately, IDirect3DSurface9::LockRect will return D3DERR_WASSTILLDRAWING so that an application can use the CPU cycles while waiting for the driver to lock the surface. The only lockable format for a depth-stencil surface is D3DFMT_D16_LOCKABLE. See <see cref="SlimDX2.Direct3D9.Format"/>. For performance reasons, dirty regions are recorded only for level zero of a texture. Dirty regions are automatically recorded when IDirect3DSurface9::LockRect is called without <see cref="SlimDX2.Direct3D9.LockFlags.NoDirtyUpdate"/> or <see cref="SlimDX2.Direct3D9.LockFlags.ReadOnly"/>. See <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/> for more information. A multisample back buffer cannot be locked. This method cannot retrieve data from a surface that is is contained by a texture resource created with <see cref="SlimDX2.Direct3D9.Usage.RenderTarget"/> because such a texture must be assigned to D3DPOOL_DEFAULT memory and is therefore not lockable. In this case, use instead <see cref="SlimDX2.Direct3D9.Device.GetRenderTargetData"/> to copy texture data from device memory to system memory. 	
        /// </remarks>	
        /// <param name="lockedRectRef"> Pointer to a <see cref="SlimDX2.Direct3D9.LockedRect"/> structure that describes the locked region.  </param>
        /// <param name="rectRef"> Pointer to a rectangle to lock. Specified by a pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifying NULL for this parameter expands the dirty region to cover the entire surface.  </param>
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_DONOTWAIT D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY   You may not specify a subrect when using D3DLOCK_DISCARD. For a description of the flags, see <see cref="SlimDX2.Direct3D9.LockFlags"/>.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL or D3DERR_WASSTILLDRAWING. </returns>
        /// <unmanaged>HRESULT IDirect3DSurface9::LockRect([None] D3DLOCKED_RECT* pLockedRect,[None] const RECT* pRect,[None] int Flags)</unmanaged>
        public SlimDX2.Result LockRect(ref SlimDX2.Direct3D9.LockedRect lockedRectRef, ref SlimDX2.Rectangle rectRef, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* lockedRectRef_ = &lockedRectRef)
                    fixed (void* rectRef_ = &rectRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, lockedRectRef_, rectRef_, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks a rectangle on a surface.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DSurface9::UnlockRect()</unmanaged>
        public SlimDX2.Result UnlockRect() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a device context.	
        /// </summary>	
        /// <remarks>	
        ///  The following restrictions apply.  IDirect3DSurface9::GetDC is valid on the following formats only: D3DFMT_R5G6B5, D3DFMT_X1R5G5B5, D3DFMT_R8G8B8, and D3DFMT_X8R8G8B8. Formats that contain Alpha are not supported because the GDI implementations don't have a well-defined behavior on the alpha channel. For more information about formats, see <see cref="SlimDX2.Direct3D9.Format"/>. Only one device context per surface can be returned at a time. IDirect3DSurface9::GetDC will fail if the surface is already locked. If the surface is a member of a mipmap or cubemap, IDirect3DSurface9::GetDC fails if any other mipmap or cubemap member is locked. IDirect3DSurface9::GetDC fails on render targets unless they were created lockable (or, in the case of back buffers, with the D3DPRESENTFLAG_LOCKABLE_BACKBUFFER flag). For surfaces not created with <see cref="SlimDX2.Direct3D9.Device.CreateOffscreenPlainSurface"/>, IDirect3DSurface9::GetDC will fail on default pool (D3DPOOL_DEFAULT) surfaces unless they are dynamic (D3DUSAGE_DYNAMIC) or are lockable render targets. IDirect3DSurface9::GetDC will fail on D3DPOOL_SCRATCH surfaces.  When a device context is outstanding on a surface, the application may not call these methods:  IDirect3DCubeTexture9 <see cref="SlimDX2.Direct3D9.CubeTexture.LockRect"/>  IDirect3DDevice9 <see cref="SlimDX2.Direct3D9.Device.ColorFill"/>   <see cref="SlimDX2.Direct3D9.Device.StretchRect"/>   <see cref="SlimDX2.Direct3D9.Device.UpdateSurface"/>   <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/>  IDirect3DSurface9 <see cref="SlimDX2.Direct3D9.Surface.LockRect"/>  IDirect3DSwapChain9 <see cref="SlimDX2.Direct3D9.SwapChain.Present"/> * IDirect3DTexture9 <see cref="SlimDX2.Direct3D9.Texture.LockRect"/>   ? * (on a swap chain that contains the surface) IDirect3DSurface9::GetDC causes an implicit lock; do not retain the device context for later use. Call <see cref="SlimDX2.Direct3D9.Surface.ReleaseDC"/> to release it.	 It is valid to call IDirect3DSurface9::GetDC/<see cref="SlimDX2.Direct3D9.Surface.ReleaseDC"/> on levels of a mipmap or cubemap, however, these calls will be slow to all miplevels except the topmost level, and GDI operations to these miplevels will not be accelerated. The hdc provides access to Win32 and GDI functionality. 	
        /// </remarks>	
        /// <param name="hdcRef"> Pointer to the device context for the surface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the argument is invalid. </returns>
        /// <unmanaged>HRESULT IDirect3DSurface9::GetDC([Out] HDC* phdc)</unmanaged>
        internal SlimDX2.Result GetDC(out IntPtr hdcRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* hdcRef_ = &hdcRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, hdcRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Release a device context handle.	
        /// </summary>	
        /// <remarks>	
        ///  An hdc is a Windows resource. It must be released after use so Windows can return it to the pool of available resources. This method will release only the device context returned by <see cref="SlimDX2.Direct3D9.Surface.GetDC"/>. Otherwise, this method will fail. 	
        /// </remarks>	
        /// <param name="hdc"> Handle to a device context. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the argument is invalid. </returns>
        /// <unmanaged>HRESULT IDirect3DSurface9::ReleaseDC([None] HDC hdc)</unmanaged>
        public SlimDX2.Result ReleaseDC(IntPtr hdc) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, (void*)hdc);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DVolume9</unmanaged>
    [Guid("24F416E6-1F67-4aa7-B88E-D33F6F3128A1")]
    public partial class Volume : SlimDX2.ComObject {
        public Volume(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the device associated with a volume.	
        /// </summary>	
        /// <remarks>	
        ///  This method allows navigation to the owning device object.  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DDevice9 interface results in a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DVolume9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves a description of the volume.	
        /// </summary>	
        /// <unmanaged>HRESULT IDirect3DVolume9::GetDesc([Out] D3DVOLUME_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.VolumeDescription Description {
                get { SlimDX2.Direct3D9.VolumeDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the device associated with a volume.	
        /// </summary>	
        /// <remarks>	
        ///  This method allows navigation to the owning device object.  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DDevice9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="deviceRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface to fill with the device pointer, if the query succeeds.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DVolume9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Associates data with the volume that is intended for use by the application, not by Direct3D.	
        /// </summary>	
        /// <remarks>	
        ///  Direct3D does not manage the memory at pData. If this buffer was dynamically allocated, it is the calling application's responsibility to free the memory. Data is passed by value, and multiple sets of data can be associated with a single volume. 	
        /// </remarks>	
        /// <param name="refguid"> Reference to the globally unique identifier that identifies the private data to set. </param>
        /// <param name="dataRef"> Pointer to a buffer that contains the data to associate with the volume.  </param>
        /// <param name="sizeOfData"> Size of the buffer at pData in bytes.  </param>
        /// <param name="flags"> Value that describes the type of data being passed, or indicates to the application that the data should be invalidated when the resource changes.    ItemDescription  (none)  If no flags are specified, Direct3D allocates memory to hold the data within the buffer and copies the data into the new buffer. The buffer allocated by Direct3D is automatically freed, as appropriate.   D3DSPD_IUNKNOWN  The data at pData is a pointer to an <see cref="SlimDX2.ComObject"/> interface. SizeOfData must be set to the size of a pointer to an IUnknown interface, sizeof(IUnknown*). Direct3D automatically calls IUnknown through pData and IUnknown when the private data is destroyed. Private data will be destroyed by a subsequent call to IDirect3DVolume9::SetPrivateData with the same GUID, a subsequent call to <see cref="SlimDX2.Direct3D9.Volume.FreePrivateData"/>, or when the <see cref="SlimDX2.Direct3D9.Direct3D"/> object is released. For more information, see Remarks.   ? </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT IDirect3DVolume9::SetPrivateData([None] REFGUID refguid,[None] const void* pData,[None] int SizeOfData,[None] int Flags)</unmanaged>
        public SlimDX2.Result SetPrivateData(Guid refguid, IntPtr dataRef, int sizeOfData, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, &refguid, (void*)dataRef, sizeOfData, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copies the private data associated with the volume to a provided buffer.	
        /// </summary>	
        /// <param name="refguid"> Reference to (C++) or address of (C) the globally unique identifier that identifies the private data to retrieve.  </param>
        /// <param name="dataRef"> Pointer to a previously allocated buffer to fill with the requested private data if the call succeeds. The application calling this method is responsible for allocating and releasing this buffer. If this parameter is NULL, this method will return the buffer size in pSizeOfData. </param>
        /// <param name="sizeOfDataRef"> Pointer to the size of the buffer at  pData, in bytes. If this value is less than the actual size of the private data, such as 0, the method sets this parameter to the required buffer size, and the method returns D3DERR_MOREDATA.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_MOREDATA, D3DERR_NOTFOUND. </returns>
        /// <unmanaged>HRESULT IDirect3DVolume9::GetPrivateData([None] REFGUID refguid,[None] void* pData,[Out] int* pSizeOfData)</unmanaged>
        public SlimDX2.Result GetPrivateData(Guid refguid, IntPtr dataRef, out int sizeOfDataRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* sizeOfDataRef_ = &sizeOfDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, &refguid, (void*)dataRef, sizeOfDataRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Frees the specified private data associated with this volume.	
        /// </summary>	
        /// <remarks>	
        ///  Direct3D calls this method automatically when a volume is released.  	
        /// </remarks>	
        /// <param name="refguid"> Reference to the globally unique identifier that identifies the private data to free. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTFOUND. </returns>
        /// <unmanaged>HRESULT IDirect3DVolume9::FreePrivateData([None] REFGUID refguid)</unmanaged>
        public SlimDX2.Result FreePrivateData(Guid refguid) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, &refguid);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Provides access to the parent volume texture object, if this surface is a child level of a volume texture.	
        /// </summary>	
        /// <remarks>	
        ///  If the call succeeds, the reference count of the container is increased by one. Here's an example getting the parent volume texture of a volume texture. 	
        /// <code> // Assumes pSurface is a valid IDirect3DVolume9 pointer	
        /// void *pContainer = NULL;	
        /// IDirect3DVolumeTexture9 *pVolumeTexture = NULL;	
        /// HRESULT hr = pVolume-&gt;GetContainer(IID_IDirect3DVolumeTexture9, &amp;pContainer);	
        /// if (SUCCEEDED(hr) &amp;&amp; pContainer)	
        /// { pVolumeTexture = (IDirect3DVolumeTexture9 *)pContainer; </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="riid"> Reference identifier of the volume being requested.  </param>
        /// <param name="containerRef"> Address of a pointer to fill with the container pointer, if the query succeeds.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DVolume9::GetContainer([None] REFIID riid,[None] void** ppContainer)</unmanaged>
        public SlimDX2.Result GetContainer(Guid riid, IntPtr containerRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, &riid, (void*)containerRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a description of the volume.	
        /// </summary>	
        /// <param name="descRef"> Pointer to a <see cref="SlimDX2.Direct3D9.VolumeDescription"/> structure, describing the volume.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the argument is invalid. </returns>
        /// <unmanaged>HRESULT IDirect3DVolume9::GetDesc([Out] D3DVOLUME_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.VolumeDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D9.VolumeDescription();
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Locks a box on a volume resource.	
        /// </summary>	
        /// <remarks>	
        ///  For performance reasons, dirty regions are only recorded for level zero of a texture. Dirty regions are automatically recorded when IDirect3DVolume9::LockBox is called without D3DLOCK_NO_DIRTY_UPDATE or D3DLOCK_READONLY. See <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/> for more information. 	
        /// </remarks>	
        /// <param name="lockedVolumeRef"> Pointer to a <see cref="SlimDX2.Direct3D9.LockedBox"/> structure, describing the locked region.  </param>
        /// <param name="boxRef"> Pointer to a box to lock. Specified by a pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifying NULL for this parameter locks the entire volume.  </param>
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY   For a description of the flags, see <see cref="SlimDX2.Direct3D9.LockFlags"/>.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DVolume9::LockBox([None] D3DLOCKED_BOX* pLockedVolume,[None] const D3DBOX* pBox,[None] int Flags)</unmanaged>
        public SlimDX2.Result LockBox(ref SlimDX2.Direct3D9.LockedBox lockedVolumeRef, ref SlimDX2.Direct3D9.Box boxRef, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* lockedVolumeRef_ = &lockedVolumeRef)
                    fixed (void* boxRef_ = &boxRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, lockedVolumeRef_, boxRef_, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks a box on a volume resource.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DVolume9::UnlockBox()</unmanaged>
        public SlimDX2.Result UnlockBox() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DSwapChain9</unmanaged>
    [Guid("794950F2-ADFC-458a-905E-10A10B0B503B")]
    public partial class SwapChain : SlimDX2.ComObject {
        public SwapChain(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Generates a copy of the swapchain's front buffer and places that copy in a system memory buffer provided by the application.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DSurface9 interface results in a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetFrontBufferData([Out] IDirect3DSurface9* pDestSurface)</unmanaged>
        public SlimDX2.Direct3D9.Surface FrontBufferData {
                get { SlimDX2.Direct3D9.Surface __output__; GetFrontBufferData(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Returns information describing the raster of the monitor on which the swap chain is presented.	
        /// </summary>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetRasterStatus([Out] D3DRASTER_STATUS* pRasterStatus)</unmanaged>
        public SlimDX2.Direct3D9.RasterStatus RasterStatus {
                get { SlimDX2.Direct3D9.RasterStatus __output__; GetRasterStatus(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the display mode's spatial resolution, color resolution, and refresh frequency.	
        /// </summary>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetDisplayMode([Out] D3DDISPLAYMODE* pMode)</unmanaged>
        public SlimDX2.Direct3D9.DisplayMode DisplayMode {
                get { SlimDX2.Direct3D9.DisplayMode __output__; GetDisplayMode(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the device associated with the swap chain.	
        /// </summary>	
        /// <remarks>	
        ///  This method allows navigation to the owning device object. Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DDevice9 interface results in a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the presentation parameters associated with a swap chain.	
        /// </summary>	
        /// <remarks>	
        ///  This method can be used to see the presentation parameters of the parent swap chain of a surface (a back buffer, for instance). The parent swap chain can be retrieved with <see cref="SlimDX2.Direct3D9.Surface.GetContainer"/>. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetPresentParameters([Out] D3DPRESENT_PARAMETERS* pPresentationParameters)</unmanaged>
        public SlimDX2.Direct3D9.PresentParameters PresentParameters {
                get { SlimDX2.Direct3D9.PresentParameters __output__; GetPresentParameters(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Presents the contents of the next buffer in the sequence of back buffers owned by the swap chain.	
        /// </summary>	
        /// <remarks>	
        ///  The {{Present}} method is a shortcut to Present. Present has been updated to take a flag allowing the application to request that the method return immediately when the driver reports that it cannot schedule a presentation. If necessary, a stretch operation is applied to transfer the pixels within the source rectangle to the destination rectangle in the client area of the target window. Present will fail if called between {{BeginScene}} and {{EndScene}} pairs unless the render target is not the current render target (such as the back buffer you get from creating an additional swap chain). This is a new behavior for Direct3D 9. 	
        /// </remarks>	
        /// <param name="sourceRectRef"> Pointer to the source rectangle (see <see cref="SlimDX2.Rectangle"/>). Use NULL to present the entire surface. This value must be NULL unless the swap chain was created with D3DSWAPEFFECT_COPY. If the rectangle exceeds the source surface, the rectangle is clipped to the source surface.  </param>
        /// <param name="destRectRef"> Pointer to the destination rectangle in client coordinates (see <see cref="SlimDX2.Rectangle"/>). This value must be NULL unless the swap chain was created with D3DSWAPEFFECT_COPY. Use NULL to fill the entire client area. If the rectangle exceeds the destination client area, the rectangle is clipped to the destination client area.  </param>
        /// <param name="hDestWindowOverride"> Destination window whose client area is taken as the target for this presentation. If this value is NULL, the hWndDeviceWindow member of <see cref="SlimDX2.Direct3D9.PresentParameters"/> is taken.  </param>
        /// <param name="dirtyRegionRef"> This value must be NULL unless the swap chain was created with <see cref="SlimDX2.Direct3D9.SwapEffect.Copy"/>. See {{Flipping Surfaces (Direct3D 9)}}. If this value is non-NULL, the contained region is expressed in back buffer coordinates. The rectangles within the region are the minimal set of pixels that need to be updated. This method takes these rectangles into account when optimizing the presentation by copying only the pixels within the region, or some suitably expanded set of rectangles. This is an aid to optimization only, and the application should not rely on the region being copied exactly. The implementation may choose to copy the whole source rectangle. </param>
        /// <param name="dwFlags"> Allows the application to request that the method return immediately when the driver reports that it cannot schedule a presentation. Valid values are 0, or any combination of <see cref="SlimDX2.Direct3D9.Present.DoNotWait"/> or <see cref="SlimDX2.Direct3D9.Present.LinearContent"/>.   If dwFlags = 0, this method behaves as it did prior to Direct3D 9. Present will spin until the hardware is free, without returning an error. If dwFlags = <see cref="SlimDX2.Direct3D9.Present.DoNotWait"/>, and the hardware is busy processing or waiting for a vertical sync interval, the method will return D3DERR_WASSTILLDRAWING. If dwFlags = <see cref="SlimDX2.Direct3D9.Present.LinearContent"/>, gamma correction is performed from linear space to sRGB for windowed swap chains. This flag will take effect only when the driver exposes {{D3DCAPS3_LINEAR_TO_SRGB_PRESENTATION}} (see {{Gamma (Direct3D 9)}}). Appliations should specify this flag if the backbuffer format is 16-bit floating point in order to match windowed mode present to fullscreen gamma behavior.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_DEVICELOST, D3DERR_DRIVERINTERNALERROR, D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT IDirect3DSwapChain9::Present([None] const RECT* pSourceRect,[None] const RECT* pDestRect,[None] HWND hDestWindowOverride,[None] const RGNDATA* pDirtyRegion,[None] int dwFlags)</unmanaged>
        public SlimDX2.Result Present(ref SlimDX2.Rectangle sourceRectRef, ref SlimDX2.Rectangle destRectRef, IntPtr hDestWindowOverride, IntPtr dirtyRegionRef, int dwFlags) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* sourceRectRef_ = &sourceRectRef)
                    fixed (void* destRectRef_ = &destRectRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, sourceRectRef_, destRectRef_, (void*)hDestWindowOverride, (void*)dirtyRegionRef, dwFlags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Generates a copy of the swapchain's front buffer and places that copy in a system memory buffer provided by the application.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DSurface9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="destSurfaceRef"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface that will receive a copy of the swapchain's front buffer. The data is returned in successive rows with no intervening space, starting from the vertically highest row to the lowest.  For windowed mode, the size of the destination surface should be the size of the desktop. For full screen mode, the size of the destination surface should be the screen size.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If BackBuffer exceeds or equals the total number of back buffers, the function fails and returns D3DERR_INVALIDCALL.   </returns>
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetFrontBufferData([Out] IDirect3DSurface9* pDestSurface)</unmanaged>
        internal SlimDX2.Result GetFrontBufferData(out SlimDX2.Direct3D9.Surface destSurfaceRef) {
            unsafe {
                IntPtr destSurfaceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, &destSurfaceRef_);
                destSurfaceRef = (destSurfaceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(destSurfaceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a back buffer from the swap chain of the device.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DSurface9 interface results in a memory leak. You must release any surfaces obtained through this method before releasing the swap chain it belongs to. 	
        /// </remarks>	
        /// <param name="iBackBuffer"> Index of the back buffer object to return. Back buffers are numbered from 0 to the total number of back buffers - 1. A value of 0 returns the first back buffer, not the front buffer. The front buffer is not accessible through this method. Use <see cref="SlimDX2.Direct3D9.SwapChain.GetFrontBufferData"/> to retrieve a copy of the front buffer. </param>
        /// <param name="type"> Stereo view is not supported in Direct3D 9, so the only valid value for this parameter is D3DBACKBUFFER_TYPE_MONO.  </param>
        /// <param name="backBufferRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the returned back buffer surface.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If BackBuffer exceeds or equals the total number of back buffers, then the function fails and returns D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetBackBuffer([None] UINT iBackBuffer,[None] D3DBACKBUFFER_TYPE Type,[Out] IDirect3DSurface9** ppBackBuffer)</unmanaged>
        public SlimDX2.Result GetBackBuffer(int iBackBuffer, SlimDX2.Direct3D9.BackbufferType type, out SlimDX2.Direct3D9.Surface backBufferRef) {
            unsafe {
                IntPtr backBufferRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, iBackBuffer, unchecked((int)type), &backBufferRef_);
                backBufferRef = (backBufferRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(backBufferRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns information describing the raster of the monitor on which the swap chain is presented.	
        /// </summary>	
        /// <param name="rasterStatusRef"> Pointer to a <see cref="SlimDX2.Direct3D9.RasterStatus"/> structure filled with information about the position or other status of the raster on the monitor driven by this adapter.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if pRasterStatus is invalid or if the device does not support reading the current scan line. To determine if the device supports reading the scan line, check for the D3DCAPS_READ_SCANLINE flag in the Caps member of <see cref="SlimDX2.Direct3D9.Capabilities"/>.  </returns>
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetRasterStatus([Out] D3DRASTER_STATUS* pRasterStatus)</unmanaged>
        internal SlimDX2.Result GetRasterStatus(out SlimDX2.Direct3D9.RasterStatus rasterStatusRef) {
            unsafe {
                rasterStatusRef = new SlimDX2.Direct3D9.RasterStatus();
                SlimDX2.Result __result__;
                fixed (void* rasterStatusRef_ = &rasterStatusRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, rasterStatusRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the display mode's spatial resolution, color resolution, and refresh frequency.	
        /// </summary>	
        /// <param name="modeRef"> Pointer to a <see cref="SlimDX2.Direct3D9.DisplayMode"/> structure containing data about the display mode of the adapter. As opposed to the display mode of the device, which may not be active if the device does not own full-screen mode.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetDisplayMode([Out] D3DDISPLAYMODE* pMode)</unmanaged>
        internal SlimDX2.Result GetDisplayMode(out SlimDX2.Direct3D9.DisplayMode modeRef) {
            unsafe {
                modeRef = new SlimDX2.Direct3D9.DisplayMode();
                SlimDX2.Result __result__;
                fixed (void* modeRef_ = &modeRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, modeRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the device associated with the swap chain.	
        /// </summary>	
        /// <remarks>	
        ///  This method allows navigation to the owning device object. Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DDevice9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="deviceRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface to fill with the device pointer, if the query succeeds.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the presentation parameters associated with a swap chain.	
        /// </summary>	
        /// <remarks>	
        ///  This method can be used to see the presentation parameters of the parent swap chain of a surface (a back buffer, for instance). The parent swap chain can be retrieved with <see cref="SlimDX2.Direct3D9.Surface.GetContainer"/>. 	
        /// </remarks>	
        /// <param name="resentationParametersRef"> Pointer to the presentation parameters. See <see cref="SlimDX2.Direct3D9.PresentParameters"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetPresentParameters([Out] D3DPRESENT_PARAMETERS* pPresentationParameters)</unmanaged>
        internal SlimDX2.Result GetPresentParameters(out SlimDX2.Direct3D9.PresentParameters resentationParametersRef) {
            unsafe {
                resentationParametersRef = new SlimDX2.Direct3D9.PresentParameters();
                SlimDX2.Result __result__;
                fixed (void* resentationParametersRef_ = &resentationParametersRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, resentationParametersRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DQuery9</unmanaged>
    [Guid("d9771460-a695-4f26-bbd3-27b840b541cc")]
    public partial class Query : SlimDX2.ComObject {
        public Query(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the device that is being queried.	
        /// </summary>	
        /// <unmanaged>HRESULT IDirect3DQuery9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the query type.	
        /// </summary>	
        /// <unmanaged>D3DQUERYTYPE IDirect3DQuery9::GetType()</unmanaged>
        public SlimDX2.Direct3D9.QueryType TypeInfo {
                get { return GetTypeInfo(); }
        }
        
        /// <summary>	
        /// Gets the number of bytes in the query data.	
        /// </summary>	
        /// <unmanaged>int IDirect3DQuery9::GetDataSize()</unmanaged>
        public int DataSize {
                get { return GetDataSize(); }
        }
        
        /// <summary>	
        /// Gets the device that is being queried.	
        /// </summary>	
        /// <param name="deviceRef"> Pointer to the device being queried. See <see cref="SlimDX2.Direct3D9.Device"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DQuery9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the query type.	
        /// </summary>	
        /// <returns>  <see cref="SlimDX2.Direct3D9.QueryType"/>  Returns the query type. See <see cref="SlimDX2.Direct3D9.QueryType"/>. </returns>
        /// <unmanaged>D3DQUERYTYPE IDirect3DQuery9::GetType()</unmanaged>
        internal SlimDX2.Direct3D9.QueryType GetTypeInfo() {
            unsafe {
                SlimDX2.Direct3D9.QueryType __result__;
                __result__= (SlimDX2.Direct3D9.QueryType)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of bytes in the query data.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns the number of bytes of query data. </returns>
        /// <unmanaged>int IDirect3DQuery9::GetDataSize()</unmanaged>
        internal int GetDataSize() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Issue a query.	
        /// </summary>	
        /// <remarks>	
        ///  A signaled query means the query has completed, the data is available, and <see cref="SlimDX2.Direct3D9.Query.GetData"/> will return S_OK.  	
        /// </remarks>	
        /// <param name="dwIssueFlags"> Query flags specify the type of state change for the query. See {{D3DISSUE_BEGIN}} and {{D3DISSUE_END}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DQuery9::Issue([None] int dwIssueFlags)</unmanaged>
        public SlimDX2.Result Issue(int dwIssueFlags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, dwIssueFlags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Polls a queried resource to get the query state or a query result. For more information about queries, see {{Queries (Direct3D 9)}}.	
        /// </summary>	
        /// <remarks>	
        ///  It is possible to lose the device while polling for query status. When {{D3DGETDATA_FLUSH}} is specified, this method will return D3DERR_DEVICELOST in response to a lost device. This allows an application to prevent threads from endlessly polling due to a lost device (which cannot respond to the query). An application must never write code that only invokes GetData ( ... , 0 ), expecting that GetData will eventually return S_OK by itself over time. This is true, even if the application has used the FLUSH flag with GetData in the past. For example: 	
        /// <code> // Enables an infinite loop:	
        /// while( pQuery-&gt;GetData( ... , 0 ) == S_FALSE ) ; // Still enables an infinite loop:	
        /// pQuery-&gt;GetData( ... , D3DGETDATA_FLUSH );	
        /// while( pQuery-&gt;GetData( ... , 0 ) == S_FALSE ) ; // Does not enable an infinite loop because eventually the command	
        /// // buffer will fill up and that will cause a flush to occur.	
        /// while( pQuery-&gt;GetData( ..., 0 ) == S_FALSE ) { pDevice-&gt;SetTexture(...); pDevice-&gt;Draw(...);	
        /// } </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="dataRef"> Pointer to a buffer containing the query data. The user is responsible for allocating this. pData may be NULL only if dwSize is 0. </param>
        /// <param name="dwSize"> Number of bytes of data in pData. If you set dwSize to zero, you can use this method to poll the resource for the query status. See remarks. </param>
        /// <param name="dwGetDataFlags"> Data flags specifying the query type. Valid values are either 0 or {{D3DGETDATA_FLUSH}}. Use 0 to avoid flushing batched queries to the driver and use D3DGETDATA_FLUSH to go ahead and flush them. For applications writing their own version of waiting, a query result is not realized until the driver receives a flush. </param>
        /// <returns>  <see cref="int"/>  The return type identifies the query state (see {{Queries (Direct3D 9)}}). The method returns S_OK if the query data is available and S_FALSE if it is not.  These are considered successful return values. If the method fails when {{D3DGETDATA_FLUSH}} is used, the return value can be D3DERR_DEVICELOST.  </returns>
        /// <unmanaged>HRESULT IDirect3DQuery9::GetData([None] void* pData,[None] int dwSize,[None] int dwGetDataFlags)</unmanaged>
        public SlimDX2.Result GetData(IntPtr dataRef, int dwSize, int dwGetDataFlags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)dataRef, dwSize, dwGetDataFlags);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Applications use the methods of the IDirect3D9Ex interface (which inherits from <see cref="SlimDX2.Direct3D9.Direct3D"/>) to create Microsoft Direct3D 9Ex objects and set up the environment. This interface includes methods for enumerating and retrieving capabilities of the device and is available when the underlying device implementation is compliant with Windows Vista.	
    /// </summary>	
    /// <unmanaged>IDirect3D9Ex</unmanaged>
    [Guid("02177241-69FC-400C-8FF1-93A44DF6861D")]
    public partial class Direct3D9Ex : SlimDX2.Direct3D9.Direct3D {
        public Direct3D9Ex(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Returns the number of display modes available.	
        /// </summary>	
        /// <remarks>	
        ///  Events such as display mode changes on other heads of the same hardware, monitor change or its connection status change, and desktop extension/unextension could all affect the number of display mode available. To fullscreen applications, S_PRESENT_MODE_CHANGED returned from {{PresentEx}} or {{CheckDeviceState}} is the indication of display mode setting failure due to those events. To increase the chance of setting a currently available display mode successfully, fullscreen applications should try to requery the available display mode list upon receiving S_PRESENT_MODE_CHANGED. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number denoting the display adapter from which to retrieve the display mode count. </param>
        /// <param name="filterRef"> Specifies the characteristics of the desired display mode. See <see cref="SlimDX2.Direct3D9.DisplayModeFilter"/>. </param>
        /// <returns>  {{UINT}}  The number of display modes available. A return of value zero from this method is an indication that no such display mode is supported or simply this monitor is no longer available. </returns>
        /// <unmanaged>UINT IDirect3D9Ex::GetAdapterModeCountEx([None] UINT Adapter,[Out] const D3DDISPLAYMODEFILTER* pFilter)</unmanaged>
        public int GetAdapterModeCountEx(int adapter, out SlimDX2.Direct3D9.DisplayModeFilter filterRef) {
            unsafe {
                filterRef = new SlimDX2.Direct3D9.DisplayModeFilter();
                int __result__;
                fixed (void* filterRef_ = &filterRef)
                    __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, adapter, filterRef_);
                return __result__;
            }
        }
        
        /// <summary>	
        /// This method returns the actual display mode info based on the given mode index.	
        /// </summary>	
        /// <param name="adapter"> Ordinal number denoting the display adapter to enumerate. D3DADAPTER_DEFAULT is always the primary display adapter. This method returns D3DERR_INVALIDCALL when this value equals or exceeds the number of display adapters in the system. </param>
        /// <param name="filterRef"> See <see cref="SlimDX2.Direct3D9.DisplayModeFilter"/>. </param>
        /// <param name="mode"> Represents the display-mode index which is an unsigned integer between zero and the value returned by GetAdapterModeCount minus one. </param>
        /// <param name="modeRef"> A pointer to the available display mode of type <see cref="SlimDX2.Direct3D9.DisplayModeEx"/>. </param>
        /// <returns>  <see cref="int"/>   If the device can be used on this adapter, D3D_OK is returned. If the Adapter equals or exceeds the number of display adapters in the system, D3DERR_INVALIDCALL is returned.  </returns>
        /// <unmanaged>HRESULT IDirect3D9Ex::EnumAdapterModesEx([None] UINT Adapter,[None] const D3DDISPLAYMODEFILTER* pFilter,[None] UINT Mode,[None] D3DDISPLAYMODEEX* pMode)</unmanaged>
        public SlimDX2.Result EnumAdapterModesEx(int adapter, ref SlimDX2.Direct3D9.DisplayModeFilter filterRef, int mode, ref SlimDX2.Direct3D9.DisplayModeEx modeRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* filterRef_ = &filterRef)
                    fixed (void* modeRef_ = &modeRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, adapter, filterRef_, mode, modeRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the current display mode and rotation settings of the adapter.	
        /// </summary>	
        /// <remarks>	
        ///  GetAdapterDisplayModeEx does not return the correct format when the display is in an extended format, such as 2:10:10:10. Instead, it returns the format X8R8G8B8. To windowed applications, a value of S_PRESENT_MODE_CHANGED returned from {{PresentEx}} or {{CheckDeviceState}} indicates that the display mode changed and that the current display mode might have a different format. To avoid a color-converting Present blt, windowed applications can optionally get new display mode information by using this method and adjusting its swap chain format accordingly. This method returns D3DERR_NOTAVAILABLE if this head is no longer part of the desktop or if the monitor is disconnected. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number that denotes the display adapter to query. D3DADAPTER_DEFAULT is always the primary display adapter.  </param>
        /// <param name="modeRef"> Pointer to a <see cref="SlimDX2.Direct3D9.DisplayModeEx"/> structure containing data about the display mode of the adapter. As opposed to the display mode of the device, which may not be active if the device does not own full-screen mode. Can be set to NULL. </param>
        /// <param name="rotationRef"> Pointer to a <see cref="SlimDX2.Direct3D9.DisplayRotation"/> structure indicating the type of screen rotation the application will do. The value returned through this pointer is important when the <see cref="SlimDX2.Direct3D9.PresentFlags.NoAutoRotate"/> flag is used; otherwise, it can be set to NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK.   If Adapter is out of range or pMode is invalid, this method returns D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3D9Ex::GetAdapterDisplayModeEx([None] UINT Adapter,[Out] D3DDISPLAYMODEEX* pMode,[Out] D3DDISPLAYROTATION* pRotation)</unmanaged>
        public SlimDX2.Result GetAdapterDisplayModeEx(int adapter, out SlimDX2.Direct3D9.DisplayModeEx modeRef, out SlimDX2.Direct3D9.DisplayRotation rotationRef) {
            unsafe {
                modeRef = new SlimDX2.Direct3D9.DisplayModeEx();
                SlimDX2.Result __result__;
                fixed (void* modeRef_ = &modeRef)
                    fixed (void* rotationRef_ = &rotationRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, adapter, modeRef_, rotationRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a device to represent the display adapter.	
        /// </summary>	
        /// <param name="adapter"> Ordinal number that denotes the display adapter. {{D3DADAPTER_DEFAULT}} is always the primary display adapter. </param>
        /// <param name="deviceType"> Specifies the type of device. See <see cref="SlimDX2.Direct3D9.DeviceType"/>. If the desired device type is not available, the method will fail. </param>
        /// <param name="hFocusWindow"> The focus window alerts Direct3D when an application switches from foreground mode to background mode. For full-screen mode, the window specified must be a top-level window. For windowed mode, this parameter may be NULL only if the hDeviceWindow member of pPresentationParameters is set to a valid, non-NULL value. </param>
        /// <param name="behaviorFlags"> Combination of one or more options (see {{D3DCREATE}}) that control device creation. </param>
        /// <param name="resentationParametersRef"> Pointer to a <see cref="SlimDX2.Direct3D9.PresentParameters"/> structure, describing the presentation parameters for the device to be created. If BehaviorFlags specifies <see cref="SlimDX2.Direct3D9.CreateFlags.AdapterGroupDevice"/>, this parameter is an array. Regardless of the number of heads that exist, only one depth/stencil surface is automatically created. This parameter is both an input and an output parameter. Calling this method may change several members including:  If BackBufferCount, BackBufferWidth, and BackBufferHeight are 0 before the method is called, they will be changed when the method returns. If BackBufferFormat equals <see cref="SlimDX2.Direct3D9.Format.Unknown"/> before the method is called, it will be changed when the method returns.  </param>
        /// <param name="fullscreenDisplayModeRef"> The display mode for when the device is set to fullscreen. See <see cref="SlimDX2.Direct3D9.DisplayModeEx"/>. If BehaviorFlags specifies <see cref="SlimDX2.Direct3D9.CreateFlags.AdapterGroupDevice"/>, this parameter is an array. </param>
        /// <param name="returnedDeviceInterfaceRef"> Address of a pointer to the returned <see cref="SlimDX2.Direct3D9.DeviceEx"/>, which represents the created device. </param>
        /// <returns>  <see cref="int"/>  This method returns S_OK when rendering device along with swapchain buffers are created successfully. D3DERR_DEVICELOST is returned when any error other than invalid caller input is encountered. </returns>
        /// <unmanaged>HRESULT IDirect3D9Ex::CreateDeviceEx([None] UINT Adapter,[None] D3DDEVTYPE DeviceType,[None] HWND hFocusWindow,[None] int BehaviorFlags,[None] D3DPRESENT_PARAMETERS* pPresentationParameters,[None] D3DDISPLAYMODEEX* pFullscreenDisplayMode,[None] IDirect3DDevice9Ex** ppReturnedDeviceInterface)</unmanaged>
        public SlimDX2.Result CreateDeviceEx(int adapter, SlimDX2.Direct3D9.DeviceType deviceType, IntPtr hFocusWindow, int behaviorFlags, ref SlimDX2.Direct3D9.PresentParameters resentationParametersRef, ref SlimDX2.Direct3D9.DisplayModeEx fullscreenDisplayModeRef, out SlimDX2.Direct3D9.DeviceEx returnedDeviceInterfaceRef) {
            unsafe {
                IntPtr returnedDeviceInterfaceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* resentationParametersRef_ = &resentationParametersRef)
                    fixed (void* fullscreenDisplayModeRef_ = &fullscreenDisplayModeRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, adapter, unchecked((int)deviceType), (void*)hFocusWindow, behaviorFlags, resentationParametersRef_, fullscreenDisplayModeRef_, &returnedDeviceInterfaceRef_);
                returnedDeviceInterfaceRef = (returnedDeviceInterfaceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.DeviceEx(returnedDeviceInterfaceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// This method returns a unique identifier for the adapter that is specific to the adapter hardware. Applications can use this identifier to define robust mappings across various APIs (Direct3D 9, DXGI).	
        /// </summary>	
        /// <param name="adapter"> Ordinal number denoting the display adapter from which to retrieve the LUID. </param>
        /// <param name="lUIDRef"> A unique identifier for the given adapter. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
        /// <unmanaged>HRESULT IDirect3D9Ex::GetAdapterLUID([None] UINT Adapter,[Out] LUID* pLUID)</unmanaged>
        public SlimDX2.Result GetAdapterLUID(int adapter, out long lUIDRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* lUIDRef_ = &lUIDRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, adapter, lUIDRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Applications use the methods of the IDirect3DDevice9Ex interface to render primitives, create resources, work with system-level variables, adjust gamma ramp levels, work with palettes, and create shaders. The IDirect3DDevice9Ex interface derives from the <see cref="SlimDX2.Direct3D9.Device"/> interface.	
    /// </summary>	
    /// <unmanaged>IDirect3DDevice9Ex</unmanaged>
    [Guid("B18B10CE-2649-405a-870F-95F777D4313A")]
    public partial class DeviceEx : SlimDX2.Direct3D9.Device {
        public DeviceEx(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the priority of the GPU thread.	
        /// </summary>	
        /// <remarks>	
        ///  Use <see cref="SlimDX2.Direct3D9.DeviceEx.SetGPUThreadPriority"/> to set the priority of a thread. This method will retrieve the priority of the thread stored with the Direct3D device even if it was created with the <see cref="SlimDX2.Direct3D9.CreateFlags.PureDevice"/> flag. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::GetGPUThreadPriority([Out] INT* pPriority)</unmanaged>
        public int GPUThreadPriority {
                get { int __output__; GetGPUThreadPriority(out __output__); return __output__; }
                set { SetGPUThreadPriority(value); }
        }
        
        /// <summary>	
        /// Retrieves the number of frames of data that the system is allowed to queue.	
        /// </summary>	
        /// <remarks>	
        ///  Frame latency is the number of frames that are allowed to be stored in a queue, before submission for rendering. Latency is often used to control how the CPU chooses between responding to user input and frames that are in the render queue. It is often beneficial for applications that have no user input (for example, video playback) to queue more than 3 frames of data. 	
        /// </remarks>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::GetMaximumFrameLatency([Out] UINT* pMaxLatency)</unmanaged>
        public int MaximumFrameLatency {
                get { int __output__; GetMaximumFrameLatency(out __output__); return __output__; }
                set { SetMaximumFrameLatency(value); }
        }
        
        /// <summary>	
        /// Prepare the texture sampler for monochrome convolution filtering on a single-color texture.	
        /// </summary>	
        /// <remarks>	
        ///  This method is designed to filter a single color texture. A monochrome convolution filter is a 2D box filter with all of the weights set to 1.0;  the filter kernel resolution ranges from 1 x 1 to 7 x 7. When monochrome texture filtering is set to a texture sampler and texture sampling is performed at location, then Direct3D performs convolution.  Restrictions include:  The filter specified by this method is recorded in state blocks as a part of <see cref="SlimDX2.Direct3D9.StateBlockType.PixelState"/>. The only texture address mode supported is: {{D3DPTADDRESSCAPS_BORDER}}; the border color is always 0. This method is not supported for mipmaps. Using a non-monochrome texture with convolution filtering will generate a driver error.  	
        /// </remarks>	
        /// <param name="width"> The width of the filter kernel; ranging from 1 - {{D3DCONVOLUTIONMONO_MAXWIDTH}}. The default value is 1. </param>
        /// <param name="height"> The height of the filter kernel; ranging from 1 - {{D3DCONVOLUTIONMONO_MAXHEIGHT}}. The default value is 1. </param>
        /// <param name="rows"> An array of weights, one weight for each kernel sub-element in the width. This parameter must be NULL, which will set the weights equal to the default value. </param>
        /// <param name="columns"> An array of weights, one weight for each kernel sub-element in the height. This parameter must be NULL, which will set the weights equal to the default value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::SetConvolutionMonoKernel([None] UINT width,[None] UINT height,[None] float* rows,[None] float* columns)</unmanaged>
        public SlimDX2.Result SetConvolutionMonoKernel(int width, int height, ref float rows, ref float columns) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* rows_ = &rows)
                    fixed (void* columns_ = &columns)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 119 * 4, width, height, rows_, columns_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copy a text string to one surface using an alphabet of glyphs on another surface. Composition is done by the GPU using bitwise operations.	
        /// </summary>	
        /// <remarks>	
        ///  Glyphs from a one-bit source surface are put together into another one-bit texture surface with this method. The destination surface can then be used as the source for a normal texturing operation that will filter and scale the strings of text onto some other non-monochrome surface. This method has several constraints (which are similar to {{StretchRect}}):  Surfaces cannot be locked. The source and destination surfaces cannot be the same surface. The source and destination surfaces must be created with the <see cref="SlimDX2.Direct3D9.Format.A1"/> format. The source surface and both vertex buffers must be created with the <see cref="SlimDX2.Direct3D9.Pool.Default"/> flag. The destination surface must be created with either the <see cref="SlimDX2.Direct3D9.Pool.Default"/> or <see cref="SlimDX2.Direct3D9.Pool.SystemMemory"/> flags. The source rectangles must be within the source surface.  The method is not recorded in state blocks. 	
        /// </remarks>	
        /// <param name="srcRef"> A pointer to a source surface (prepared by <see cref="SlimDX2.Direct3D9.Surface"/>) that supplies the alphabet glyphs. This surface must be created with the <see cref="SlimDX2.Direct3D9.Usage.TextApi"/> flag. </param>
        /// <param name="dstRef"> A pointer to the destination surface (prepared by <see cref="SlimDX2.Direct3D9.Surface"/>) that receives the glyph data. The surface must be part of a texture. </param>
        /// <param name="srcRectDescsRef"> A pointer to a vertex buffer (see <see cref="SlimDX2.Direct3D9.VertexBuffer"/>) containing rectangles (see {{D3DCOMPOSERECTDESC}}) that enclose the desired glyphs in the source surface. </param>
        /// <param name="numRects"> The number of rectangles or glyphs that are used in the operation. The number applies to both the source and destination surfaces. The range is 0 to {{D3DCOMPOSERECTS_MAXNUMRECTS}}. </param>
        /// <param name="dstRectDescsRef"> A pointer to a vertex buffer (see <see cref="SlimDX2.Direct3D9.VertexBuffer"/>) containing rectangles (see {{D3DCOMPOSERECTDESTINATION}}) that describe the destination to which the indicated glyph from the source surface will be copied. </param>
        /// <param name="operation"> Specifies how to combine the source and destination surfaces. See <see cref="SlimDX2.Direct3D9.ComposeRectOperation"/>. </param>
        /// <param name="xoffset"> A value added to the x coordinates of all destination rectangles. This value can be negative, which may cause the glyph to be rejected or clipped if the result is beyond the bounds of the surface. </param>
        /// <param name="yoffset"> A value added to the y coordinates of all destination rectangles. This value can be negative, which may cause the glyph to be rejected or clipped if the result is beyond the bounds of the surface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::ComposeRects([None] IDirect3DSurface9* pSrc,[None] IDirect3DSurface9* pDst,[None] IDirect3DVertexBuffer9* pSrcRectDescs,[None] UINT NumRects,[None] IDirect3DVertexBuffer9* pDstRectDescs,[None] D3DCOMPOSERECTSOP Operation,[None] int Xoffset,[None] int Yoffset)</unmanaged>
        public SlimDX2.Result ComposeRects(SlimDX2.Direct3D9.Surface srcRef, SlimDX2.Direct3D9.Surface dstRef, SlimDX2.Direct3D9.VertexBuffer srcRectDescsRef, int numRects, SlimDX2.Direct3D9.VertexBuffer dstRectDescsRef, SlimDX2.Direct3D9.ComposeRectOperation operation, int xoffset, int yoffset) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 120 * 4, (void*)((srcRef == null)?IntPtr.Zero:srcRef.NativePointer), (void*)((dstRef == null)?IntPtr.Zero:dstRef.NativePointer), (void*)((srcRectDescsRef == null)?IntPtr.Zero:srcRectDescsRef.NativePointer), numRects, (void*)((dstRectDescsRef == null)?IntPtr.Zero:dstRectDescsRef.NativePointer), unchecked((int)operation), xoffset, yoffset);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Swap the swapchain's next buffer with the front buffer.	
        /// </summary>	
        /// <remarks>	
        ///  Similar to the <see cref="SlimDX2.Direct3D9.Device.Present"/> Method, PresentEx adds a dwflags parameter. When the swapchain is created with <see cref="SlimDX2.Direct3D9.SwapEffect.FlipEx"/> flag, pSourceRect, pDestRect and pDirtyRegion values must be set to NULL. 	
        /// </remarks>	
        /// <param name="sourceRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure indicating region on the source surface to copy in window client coordinates. Only applies when the swapchain was created with the <see cref="SlimDX2.Direct3D9.SwapEffect.Copy"/> flag. If NULL, the entire source surface is presented. If the rectangle exceeds the source surface, it is clipped to the source surface. </param>
        /// <param name="destRectRef"> Pointer to <see cref="SlimDX2.Rectangle"/> structure indicating the target region on the destination surface in window client coordinates. Only applies when the swapchain was created with the <see cref="SlimDX2.Direct3D9.SwapEffect.Copy"/> flag. If NULL, the entire client area is filled. If the rectangle exceeds the destination client area, it is clipped to the destination client area. </param>
        /// <param name="hDestWindowOverride"> Pointer to a destination window handle whose client area is taken as the target for this presentation. If this value is NULL, then the hWndDeviceWindow member of <see cref="SlimDX2.Direct3D9.PresentParameters"/> is taken. </param>
        /// <param name="dirtyRegionRef"> Pointer to a {{RGNDATA}} structure indicating the smallest set of pixels that need to be transferred. This value must be NULL unless the swapchain was created with the <see cref="SlimDX2.Direct3D9.SwapEffect.Copy"/> flag. For more information about swapchains, see {{Flipping Surfaces (Direct3D 9)}}. If this value is non-NULL, the contained region is expressed in back buffer coordinates. The method takes these rectangles into account when optimizing the presentation by copying only the pixels within the region, or some suitably expanded set of rectangles. This is an aid to optimization only, and the application should not rely on the region being copied exactly. The implementation can choose to copy the whole source rectangle. </param>
        /// <param name="dwFlags"> Allows the application to request that the method return immediately when the driver reports that it cannot schedule a presentation. Valid values are 0, or any combination of <see cref="SlimDX2.Direct3D9.Present"/> flags.   If dwFlags = 0, this method behaves as it did prior to Direct3D 9. Present will spin until the hardware is free, without returning an error. If dwFlags = <see cref="SlimDX2.Direct3D9.Present.DoNotFlip"/> the display driver is called with the front buffer as both the source and target surface. The driver responds by scheduling a frame synch, but not changing the displayed surface. This flag is only available in full-screen mode or when using D3DSWAPEFFECT_FLIPEX in windowed mode. If dwFlags = <see cref="SlimDX2.Direct3D9.Present.DoNotWait"/>, and the hardware is busy processing or waiting for a vertical sync interval, the method will return D3DERR_WASSTILLDRAWING. If dwFlags = <see cref="SlimDX2.Direct3D9.Present.ForceImmediate"/>, D3DPRESENT_INTERVAL_IMMEDIATE is enforced on this Present call. This flag can only be specified when using D3DSWAPEFFECT_FLIPEX. This behavior is the same for windowed and full-screen modes. If dwFlags = <see cref="SlimDX2.Direct3D9.Present.LinearContent"/>, gamma correction is performed from linear space to sRGB for windowed swap chains. This flag will take effect only when the driver exposes {{D3DCAPS3_LINEAR_TO_SRGB_PRESENTATION}} (see {{Gamma (Direct3D 9)}}).  </param>
        /// <returns>  <see cref="int"/>  Possible return values include: S_OK, D3DERR_DEVICELOST, D3DERR_DEVICEHUNG, D3DERR_DEVICEREMOVED, or D3DERR_OUTOFVIDEOMEMORY (see {{D3DERR}}). See {{Lost Device Behavior Changes}} for more information about lost, hung, and removed devices.   Differences between Direct3D 9 and Direct3D 9Ex: <see cref="SlimDX2.Direct3D9.SwapEffect.FlipEx"/> is only available in Direct3D9Ex running on Windows 7 (or more current operating system).   ? </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::PresentEx([None] const RECT* pSourceRect,[None] const RECT* pDestRect,[None] HWND hDestWindowOverride,[None] const RGNDATA* pDirtyRegion,[None] int dwFlags)</unmanaged>
        public SlimDX2.Result PresentEx(ref SlimDX2.Rectangle sourceRectRef, ref SlimDX2.Rectangle destRectRef, IntPtr hDestWindowOverride, IntPtr dirtyRegionRef, int dwFlags) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* sourceRectRef_ = &sourceRectRef)
                    fixed (void* destRectRef_ = &destRectRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 121 * 4, sourceRectRef_, destRectRef_, (void*)hDestWindowOverride, (void*)dirtyRegionRef, dwFlags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the priority of the GPU thread.	
        /// </summary>	
        /// <remarks>	
        ///  Use <see cref="SlimDX2.Direct3D9.DeviceEx.SetGPUThreadPriority"/> to set the priority of a thread. This method will retrieve the priority of the thread stored with the Direct3D device even if it was created with the <see cref="SlimDX2.Direct3D9.CreateFlags.PureDevice"/> flag. 	
        /// </remarks>	
        /// <param name="riorityRef"> Current GPU priority. Valid values range from -7 to 7. </param>
        /// <returns>  <see cref="int"/>  Possible return values include: D3D_OK or D3DERR_DEVICEREMOVED (see {{D3DERR}}). </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::GetGPUThreadPriority([Out] INT* pPriority)</unmanaged>
        internal SlimDX2.Result GetGPUThreadPriority(out int riorityRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* riorityRef_ = &riorityRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 122 * 4, riorityRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set the priority on the GPU thread.	
        /// </summary>	
        /// <remarks>	
        ///  GPU thread priority is not reset when a device is lost. The effects of calls to this method are not recorded in state blocks. 	
        /// </remarks>	
        /// <param name="priority"> The thread priority, ranging from -7 to 7. </param>
        /// <returns>  <see cref="int"/>  Possible return values include: D3D_OK, D3DERR_INVALIDCALL, or D3DERR_DEVICEREMOVED (see {{D3DERR}}). </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::SetGPUThreadPriority([None] INT Priority)</unmanaged>
        internal SlimDX2.Result SetGPUThreadPriority(int priority) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 123 * 4, priority);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Suspend execution of the calling thread until the next vertical blank signal.	
        /// </summary>	
        /// <remarks>	
        ///  This method allows applications to efficiently throttle their frame rate to that of the monitor associated with the device. Following a vertical blank, the amount of time it takes for the thread to wake up is typically very short. In some scenarios the hardware may stop generating vertical blank signals when nothing is being displayed on the monitor. In this case, the method will wait approximately 100ms and return with D3D_OK. 	
        /// </remarks>	
        /// <param name="iSwapChain"> Swap chain index. This is an optional, zero-based index used to specify a swap chain on a multihead card. </param>
        /// <returns>  <see cref="int"/>  This method will always return D3D_OK. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::WaitForVBlank([None] UINT iSwapChain)</unmanaged>
        public SlimDX2.Result WaitForVBlank(int iSwapChain) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 124 * 4, iSwapChain);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Checks an array of resources to determine if it is likely that they will cause a large stall at Draw time because the system must make the resources GPU-accessible.	
        /// </summary>	
        /// <remarks>	
        ///  This API is no more than a reasonable guess at residency, since resources may have been demoted by the time the application uses them. The expected usage pattern is as follows. If the application determines that a set of resources are not resident, then the application will substitute a lower-LOD version of the resource and continue with rendering. The video memory manager API, offers a feature to allow the application to express that it would like these lower-LOD resources to be made more likely to stay resident in GPU-accessible memory. It is the app's responsibility to create, fill and destroy these lower-LOD versions, if it so chooses. The application also needs to begin promotion of the higher-LOD versions when the residency check indicates that the resource is not resident in GPU-accessible memory. Since a per-process lock exists in kernel mode, a performant implementation will spawn a separate process whose sole job is to promote resources. The application communicates resource identity between the two process by means of the {{Sharing Resources}} shared surfaces API and promotes them by means of the {{SetPriority}}. 	
        /// </remarks>	
        /// <param name="resourceArrayRef"> An array of IDirect3DResource9 pointers that indicate the resources to check (for a description of IDirect3DResource9, see the DirectX SDK documentation). </param>
        /// <param name="numResources"> A value indicating the number of resources passed into the pResourceArray parameter up to a maximum of 65535. </param>
        /// <returns>  <see cref="int"/>  If all the resources are in GPU-accessible memory, the method will return S_OK. The system may need to perform a remapping operation to promote the resources, but will not have to copy data.  If no allocation that comprises the resources is on disk, but at least one allocation is not in GPU-accessible memory, the method will return S_RESIDENT_IN_SHARED_MEMORY. The system may need to perform a copy to promote the resource.  If at least one allocation that comprises the resources is on disk, this method will return S_NOT_RESIDENT.  The system may need to perform a copy to promote the resource. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::CheckResourceResidency([None] IDirect3DResource9** pResourceArray,[None] UINT32 NumResources)</unmanaged>
        public SlimDX2.Result CheckResourceResidency(out SlimDX2.Direct3D9.Resource resourceArrayRef, int numResources) {
            unsafe {
                IntPtr resourceArrayRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 125 * 4, &resourceArrayRef_, numResources);
                resourceArrayRef = (resourceArrayRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Resource(resourceArrayRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set the number of frames that the system is allowed to queue for rendering.	
        /// </summary>	
        /// <remarks>	
        ///  Frame latency is the number of frames that are allowed to be stored in a queue, before submission for rendering. Latency is often used to control how the CPU chooses between responding to user input and frames that are in the render queue. It is often beneficial for applications that have no user input (for example, video playback) to queue more than 3 frames of data. 	
        /// </remarks>	
        /// <param name="maxLatency"> The maximum number of back buffer frames that a driver can queue. The value is typically 3, but can range from 1 to 20. A value of 0 will reset latency to the default. For multi-head devices, MaxLatency is specified per-head. </param>
        /// <returns>  <see cref="int"/>  Possible return values include: D3D_OK or D3DERR_DEVICEREMOVED (see {{D3DERR}}). </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::SetMaximumFrameLatency([None] UINT MaxLatency)</unmanaged>
        internal SlimDX2.Result SetMaximumFrameLatency(int maxLatency) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 126 * 4, maxLatency);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of frames of data that the system is allowed to queue.	
        /// </summary>	
        /// <remarks>	
        ///  Frame latency is the number of frames that are allowed to be stored in a queue, before submission for rendering. Latency is often used to control how the CPU chooses between responding to user input and frames that are in the render queue. It is often beneficial for applications that have no user input (for example, video playback) to queue more than 3 frames of data. 	
        /// </remarks>	
        /// <param name="maxLatencyRef"> Returns the number of frames that can be queued for render. The value is typically 3, but can range from 1 to 20. </param>
        /// <returns>  <see cref="int"/>  Possible return values include: D3D_OK, D3DERR_DEVICELOST, D3DERR_DEVICEREMOVED, D3DERR_DRIVERINTERNALERROR, D3DERR_INVALIDCALL, or D3DERR_OUTOFVIDEOMEMORY (see {{D3DERR}}). </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::GetMaximumFrameLatency([Out] UINT* pMaxLatency)</unmanaged>
        internal SlimDX2.Result GetMaximumFrameLatency(out int maxLatencyRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* maxLatencyRef_ = &maxLatencyRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 127 * 4, maxLatencyRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Reports the current cooperative-level status of the Direct3D device for a windowed or full-screen application.	
        /// </summary>	
        /// <remarks>	
        ///  This method replaces <see cref="SlimDX2.Direct3D9.Device.TestCooperativeLevel"/>, which always returns S_OK in Direct3D 9Ex applications. See {{Lost Device Behavior Changes}} for more information about lost, hung, and removed devices. 	
        /// </remarks>	
        /// <param name="hDestinationWindow"> The destination window handle to check for occlusion. When this parameter is NULL, S_PRESENT_OCCLUDED is returned when another device has fullscreen ownership. When the window handle is not NULL, window's client area is checked for occlusion. A window is occluded if any part of it is obscured by another application. </param>
        /// <returns>  <see cref="int"/>  Possible return values include: D3D_OK, D3DERR_DEVICELOST, D3DERR_DEVICEHUNG, D3DERR_DEVICEREMOVED, or D3DERR_OUTOFVIDEOMEMORY (see {{D3DERR}}), or S_PRESENT_MODE_CHANGED, or S_PRESENT_OCCLUDED (see {{S_PRESENT}}). </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::CheckDeviceState([None] HWND hDestinationWindow)</unmanaged>
        public SlimDX2.Result CheckDeviceState(IntPtr hDestinationWindow) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 128 * 4, (void*)hDestinationWindow);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a render-target surface.	
        /// </summary>	
        /// <remarks>	
        ///  Render-target surfaces are placed in the D3DPOOL_DEFAULT memory class. The creation of lockable, multisampled render targets is not supported. 	
        /// </remarks>	
        /// <param name="width"> Width of the render-target surface, in pixels.  </param>
        /// <param name="height"> Height of the render-target surface, in pixels.  </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of the render target.  </param>
        /// <param name="multiSample"> Member of the <see cref="SlimDX2.Direct3D9.MultisampleType"/> enumerated type, which describes the multisampling buffer type. This parameter specifies the antialiasing type for this render target. When this surface is passed to <see cref="SlimDX2.Direct3D9.Device.SetRenderTarget"/>, its multisample type must be the same as that of the depth-stencil set by <see cref="SlimDX2.Direct3D9.Device.SetDepthStencilSurface"/>.  </param>
        /// <param name="multisampleQuality"> Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by  <see cref="SlimDX2.Direct3D9.Direct3D.CheckDeviceMultiSampleType"/>. Passing a larger value returns the error, D3DERR_INVALIDCALL. The MultisampleQuality values of paired render targets, depth stencil surfaces, and the multisample type must all match. </param>
        /// <param name="lockable"> Render targets are not lockable unless the application specifies TRUE for Lockable. Note that lockable render targets reduce performance on some graphics hardware. The readback performance (moving data from video memory to system memory) depends on the type of hardware used (AGP vs. PCI Express) and is usually far lower than upload performance (moving data from system to video memory). If you need read access to render targets, use {{GetRenderTargetData}} instead of lockable render targets. </param>
        /// <param name="surfaceRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface.  </param>
        /// <param name="sharedHandleRef"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <param name="usage"> Combination of one or more <see cref="SlimDX2.Direct3D9.Usage"/> constants which can be OR'd together. Value of 0 indicates no usage. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::CreateRenderTargetEx([None] UINT Width,[None] UINT Height,[None] D3DFORMAT Format,[None] D3DMULTISAMPLE_TYPE MultiSample,[None] int MultisampleQuality,[None] BOOL Lockable,[None] IDirect3DSurface9** ppSurface,[None] HANDLE* pSharedHandle,[None] int Usage)</unmanaged>
        public SlimDX2.Result CreateRenderTargetEx(int width, int height, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.MultisampleType multiSample, int multisampleQuality, bool lockable, out SlimDX2.Direct3D9.Surface surfaceRef, IntPtr sharedHandleRef, int usage) {
            unsafe {
                IntPtr surfaceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 129 * 4, width, height, unchecked((int)format), unchecked((int)multiSample), multisampleQuality, (lockable?1:0), &surfaceRef_, (void*)sharedHandleRef, usage);
                surfaceRef = (surfaceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(surfaceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create an off-screen surface.	
        /// </summary>	
        /// <remarks>	
        ///  D3DPOOL_SCRATCH will return a surface that has identical characteristics to a surface created by the DirectX 8.x method CreateImageSurface. D3DPOOL_DEFAULT is the appropriate pool for use with the <see cref="SlimDX2.Direct3D9.Device.StretchRect"/> and <see cref="SlimDX2.Direct3D9.Device.ColorFill"/>. D3DPOOL_MANAGED is not allowed when creating an offscreen plain surface. For more information about memory pools, see <see cref="SlimDX2.Direct3D9.Pool"/>. Off-screen plain surfaces are always lockable, regardless of their pool types. 	
        /// </remarks>	
        /// <param name="width"> Width of the surface. </param>
        /// <param name="height"> Height of the surface. </param>
        /// <param name="format"> Format of the surface. See <see cref="SlimDX2.Direct3D9.Format"/>.  </param>
        /// <param name="pool"> Surface pool type. See <see cref="SlimDX2.Direct3D9.Pool"/>. </param>
        /// <param name="surfaceRef"> Pointer to the <see cref="SlimDX2.Direct3D9.Surface"/> interface created. </param>
        /// <param name="sharedHandleRef"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <param name="usage"> Combination of one or more <see cref="SlimDX2.Direct3D9.Usage"/> constants which can be OR'd together. Value of 0 indicates no usage. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::CreateOffscreenPlainSurfaceEx([None] UINT Width,[None] UINT Height,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] IDirect3DSurface9** ppSurface,[None] HANDLE* pSharedHandle,[None] int Usage)</unmanaged>
        public SlimDX2.Result CreateOffscreenPlainSurfaceEx(int width, int height, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.Surface surfaceRef, IntPtr sharedHandleRef, int usage) {
            unsafe {
                IntPtr surfaceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 130 * 4, width, height, unchecked((int)format), unchecked((int)pool), &surfaceRef_, (void*)sharedHandleRef, usage);
                surfaceRef = (surfaceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(surfaceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a depth-stencil surface.	
        /// </summary>	
        /// <remarks>	
        ///  The memory class of the depth-stencil buffer is always D3DPOOL_DEFAULT. 	
        /// </remarks>	
        /// <param name="width"> Width of the depth-stencil surface, in pixels.  </param>
        /// <param name="height"> Height of the depth-stencil surface, in pixels.  </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of the depth-stencil surface. This value must be one of the enumerated depth-stencil formats for this device. </param>
        /// <param name="multiSample"> Member of the <see cref="SlimDX2.Direct3D9.MultisampleType"/> enumerated type, describing the multisampling buffer type. This value must be one of the allowed multisample types. When this surface is passed to <see cref="SlimDX2.Direct3D9.Device.SetDepthStencilSurface"/>, its multisample type must be the same as that of the render target set by <see cref="SlimDX2.Direct3D9.Device.SetRenderTarget"/>. </param>
        /// <param name="multisampleQuality"> Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by  <see cref="SlimDX2.Direct3D9.Direct3D.CheckDeviceMultiSampleType"/>. Passing a larger value returns the error D3DERR_INVALIDCALL. The MultisampleQuality values of paired render targets, depth stencil surfaces, and the MultiSample type must all match. </param>
        /// <param name="discard"> Set this flag to TRUE to enable z-buffer discarding, and FALSE otherwise.				If this flag is set, the contents of the depth stencil buffer will be invalid after calling either <see cref="SlimDX2.Direct3D9.Device.Present"/> or <see cref="SlimDX2.Direct3D9.Device.SetDepthStencilSurface"/> with a different depth surface. This flag has the same behavior as the constant,  D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL, in {{D3DPRESENTFLAG}}. </param>
        /// <param name="surfaceRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the created depth-stencil surface resource.  </param>
        /// <param name="sharedHandleRef"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <param name="usage"> Combination of one or more <see cref="SlimDX2.Direct3D9.Usage"/> constants which can be OR'd together. Value of 0 indicates no usage. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::CreateDepthStencilSurfaceEx([None] UINT Width,[None] UINT Height,[None] D3DFORMAT Format,[None] D3DMULTISAMPLE_TYPE MultiSample,[None] int MultisampleQuality,[None] BOOL Discard,[None] IDirect3DSurface9** ppSurface,[None] HANDLE* pSharedHandle,[None] int Usage)</unmanaged>
        public SlimDX2.Result CreateDepthStencilSurfaceEx(int width, int height, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.MultisampleType multiSample, int multisampleQuality, bool discard, out SlimDX2.Direct3D9.Surface surfaceRef, IntPtr sharedHandleRef, int usage) {
            unsafe {
                IntPtr surfaceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 131 * 4, width, height, unchecked((int)format), unchecked((int)multiSample), multisampleQuality, (discard?1:0), &surfaceRef_, (void*)sharedHandleRef, usage);
                surfaceRef = (surfaceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(surfaceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Resets the type, size, and format of the swap chain with all other surfaces persistent.	
        /// </summary>	
        /// <remarks>	
        ///  If a call to IDirect3DDevice9Ex::ResetEx fails, the device will be placed in the lost state (as indicated by a return value of D3DERR_DEVICELOST from a call to <see cref="SlimDX2.Direct3D9.DeviceEx.CheckDeviceState"/>). Refer to IDirect3DDevice9Ex::CheckDeviceState and {{Lost Device Behavior Changes}} for further information concerning the use of IDirect3DDevice9Ex::ResetEx in the context of lost devices. Unlike previous versions of DirectX, calling IDirect3DDevice9Ex::ResetEx does not cause surfaces, textures or state information to be lost. Pixel shaders and vertex shaders survive IDirect3DDevice9Ex::ResetEx calls for Direct3D 9. They do not need to be re-created explicitly by the application. There are two different types of swap chains: full-screen or windowed. If the new swap chain is full-screen, the adapter will be placed in the display mode that matches the new size. Applications can expect messages to be sent to them during this call (for example, before this call is returned); applications should take precautions not to call into Direct3D at this time. A call to IDirect3DDevice9Ex::ResetEx will fail if called on a different thread than that used to create the device being reset. D3DFMT_UNKNOWN can be specified for the windowed mode back buffer format when calling <see cref="SlimDX2.Direct3D9.Direct3D9Ex.CreateDeviceEx"/>, IDirect3DDevice9Ex::ResetEx, and <see cref="SlimDX2.Direct3D9.Device.CreateAdditionalSwapChain"/>. This means the application does not have to query the current desktop format before calling IDirect3D9Ex::CreateDeviceEx for windowed mode. For full-screen mode, the back buffer format must be specified. Setting BackBufferCount equal to zero (BackBufferCount = 0) results in one back buffer. When trying to reset more than one display adapter in a group, set pPresentationParameters to point to an array of <see cref="SlimDX2.Direct3D9.PresentParameters"/> structures, one for each display in the adapter group. If a multihead device was created with <see cref="SlimDX2.Direct3D9.CreateFlags.AdapterGroupDevice"/>, IDirect3DDevice9Ex::ResetEx requires an array of <see cref="SlimDX2.Direct3D9.PresentParameters"/> structures wherein each structure must specify a full-screen display. To switch back to windowed mode, the application must destroy the device and re-create a non-multihead device in windowed mode. 	
        /// </remarks>	
        /// <param name="resentationParametersRef"> Pointer to a <see cref="SlimDX2.Direct3D9.PresentParameters"/> structure, describing the new presentation parameters. This value cannot be NULL.   When switching to full-screen mode, Direct3D will try to find a desktop format that matches the back buffer format, so that back buffer and front buffer formats will be identical (to eliminate the need for color conversion). When this method returns:  BackBufferCount, BackBufferWidth, and BackBufferHeight are set to zero. BackBufferFormat is set to <see cref="SlimDX2.Direct3D9.Format"/> for windowed mode only; a full-screen mode must specify a format.  </param>
        /// <param name="fullscreenDisplayModeRef"> Pointer to a <see cref="SlimDX2.Direct3D9.DisplayModeEx"/> structure that describes the properties of the desired display mode. This value must be provided for fullscreen applications, but can be NULL for windowed applications.  </param>
        /// <returns>  <see cref="int"/>  The method can return: D3D_OK, D3DERR_DEVICELOST or D3DERR_DEVICEHUNG (see {{D3DERR}}).  If this method returns D3DERR_DEVICELOST or D3DERR_DEVICEHUNG then the application can only call IDirect3DDevice9Ex::ResetEx, <see cref="SlimDX2.Direct3D9.DeviceEx.CheckDeviceState"/> or release the interface pointer; any other API call will cause an exception. </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::ResetEx([None] D3DPRESENT_PARAMETERS* pPresentationParameters,[None] D3DDISPLAYMODEEX* pFullscreenDisplayMode)</unmanaged>
        public SlimDX2.Result ResetEx(ref SlimDX2.Direct3D9.PresentParameters resentationParametersRef, ref SlimDX2.Direct3D9.DisplayModeEx fullscreenDisplayModeRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* resentationParametersRef_ = &resentationParametersRef)
                    fixed (void* fullscreenDisplayModeRef_ = &fullscreenDisplayModeRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 132 * 4, resentationParametersRef_, fullscreenDisplayModeRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the display mode's spatial resolution, color resolution, refresh frequency, and rotation settings.	
        /// </summary>	
        /// <param name="iSwapChain"> An unsigned integer specifying the swap chain. </param>
        /// <param name="modeRef"> Pointer to a <see cref="SlimDX2.Direct3D9.DisplayModeEx"/> structure containing data about the display mode of the adapter. As opposed to the display mode of the device, which may not be active if the device does not own full-screen mode. Can be set to NULL. </param>
        /// <param name="rotationRef"> Pointer to a <see cref="SlimDX2.Direct3D9.DisplayRotation"/> indicating the type of screen rotation the application will do. The value returned through this pointer is important when the <see cref="SlimDX2.Direct3D9.PresentFlags.NoAutoRotate"/> flag is used; otherwise, it can be set to NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::GetDisplayModeEx([None] UINT iSwapChain,[Out] D3DDISPLAYMODEEX* pMode,[Out] D3DDISPLAYROTATION* pRotation)</unmanaged>
        public SlimDX2.Result GetDisplayModeEx(int iSwapChain, out SlimDX2.Direct3D9.DisplayModeEx modeRef, out SlimDX2.Direct3D9.DisplayRotation rotationRef) {
            unsafe {
                modeRef = new SlimDX2.Direct3D9.DisplayModeEx();
                SlimDX2.Result __result__;
                fixed (void* modeRef_ = &modeRef)
                    fixed (void* rotationRef_ = &rotationRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 133 * 4, iSwapChain, modeRef_, rotationRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Applications use the methods of the IDirect3DSwapChain9Ex interface to manipulate a swap chain.	
    /// </summary>	
    /// <unmanaged>IDirect3DSwapChain9Ex</unmanaged>
    [Guid("91886CAF-1C3D-4d2e-A0AB-3E4C7D8D3303")]
    public partial class SwapChain9Ex : SlimDX2.Direct3D9.SwapChain {
        public SwapChain9Ex(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Returns the number of times the swapchain has been processed.	
        /// </summary>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9Ex::GetLastPresentCount([Out] UINT* pLastPresentCount)</unmanaged>
        public int LastPresentCount {
                get { int __output__; GetLastPresentCount(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9Ex::GetPresentStats([Out] D3DPRESENTSTATS* pPresentationStatistics)</unmanaged>
        public SlimDX2.Direct3D9.PresentationStatistics PresentStats {
                get { SlimDX2.Direct3D9.PresentationStatistics __output__; GetPresentStats(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Returns the number of times the swapchain has been processed.	
        /// </summary>	
        /// <param name="lastPresentCountRef"> Pointer to a UINT to be filled with the number of times the <see cref="SlimDX2.Direct3D9.DeviceEx.PresentEx"/> method has been called. The count will also be incremented by calling some other APIs such as <see cref="SlimDX2.Direct3D9.Device.SetDialogBoxMode"/>. </param>
        /// <returns>  <see cref="int"/>  S_OK the method was successful. </returns>
        /// <unmanaged>HRESULT IDirect3DSwapChain9Ex::GetLastPresentCount([Out] UINT* pLastPresentCount)</unmanaged>
        internal SlimDX2.Result GetLastPresentCount(out int lastPresentCountRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* lastPresentCountRef_ = &lastPresentCountRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, lastPresentCountRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="resentationStatisticsRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IDirect3DSwapChain9Ex::GetPresentStats([Out] D3DPRESENTSTATS* pPresentationStatistics)</unmanaged>
        internal SlimDX2.Result GetPresentStats(out SlimDX2.Direct3D9.PresentationStatistics resentationStatisticsRef) {
            unsafe {
                resentationStatisticsRef = new SlimDX2.Direct3D9.PresentationStatistics();
                SlimDX2.Result __result__;
                fixed (void* resentationStatisticsRef_ = &resentationStatisticsRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, resentationStatisticsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the display mode's spatial resolution, color resolution, refresh frequency, and rotation settings.	
        /// </summary>	
        /// <param name="modeRef"> Pointer to a <see cref="SlimDX2.Direct3D9.DisplayModeEx"/> structure containing data about the display mode of the adapter. As opposed to the display mode of the device, which may not be active if the device does not own full-screen mode.  </param>
        /// <param name="rotationRef"> Pointer to a <see cref="SlimDX2.Direct3D9.DisplayRotation"/> indicating the type of screen rotation the application will do. The value returned through this pointer is important when the <see cref="SlimDX2.Direct3D9.PresentFlags.NoAutoRotate"/> flag is used; otherwise, it can be set to NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT IDirect3DSwapChain9Ex::GetDisplayModeEx([Out] D3DDISPLAYMODEEX* pMode,[Out] D3DDISPLAYROTATION* pRotation)</unmanaged>
        public SlimDX2.Result GetDisplayModeEx(out SlimDX2.Direct3D9.DisplayModeEx modeRef, out SlimDX2.Direct3D9.DisplayRotation rotationRef) {
            unsafe {
                modeRef = new SlimDX2.Direct3D9.DisplayModeEx();
                SlimDX2.Result __result__;
                fixed (void* modeRef_ = &modeRef)
                    fixed (void* rotationRef_ = &rotationRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, modeRef_, rotationRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXBuffer</unmanaged>
    [Guid("8ba5fb08-5195-40e2-ac58-0d989c3a0102")]
    public partial class ShaderBytecode : SlimDX2.ComObject {
        public ShaderBytecode(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves a pointer to the data in the buffer.	
        /// </summary>	
        /// <unmanaged>void* ID3DXBuffer::GetBufferPointer()</unmanaged>
        public IntPtr BufferPointer {
                get { return GetBufferPointer(); }
        }
        
        /// <summary>	
        /// Retrieves the total size of the data in the buffer.	
        /// </summary>	
        /// <unmanaged>int ID3DXBuffer::GetBufferSize()</unmanaged>
        public int BufferSize {
                get { return GetBufferSize(); }
        }
        
        /// <summary>	
        /// Retrieves a pointer to the data in the buffer.	
        /// </summary>	
        /// <returns>  {{LPVOID}}  Returns a pointer to the data in the buffer. </returns>
        /// <unmanaged>void* ID3DXBuffer::GetBufferPointer()</unmanaged>
        internal IntPtr GetBufferPointer() {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the total size of the data in the buffer.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns the total size of the data in the buffer, in bytes. </returns>
        /// <unmanaged>int ID3DXBuffer::GetBufferSize()</unmanaged>
        internal int GetBufferSize() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXSprite</unmanaged>
    [Guid("ba0b762d-7d28-43ec-b9dc-2f84443b0614")]
    public partial class Sprite : SlimDX2.ComObject {
        public Sprite(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the device associated with the sprite object.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. 	
        /// </remarks>	
        /// <unmanaged>HRESULT ID3DXSprite::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the sprite transform.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXSprite::GetTransform([Out] D3DXMATRIX* pTransform)</unmanaged>
        public SlimMath.Matrix Transform {
                get { SlimMath.Matrix __output__; GetTransform(out __output__); return __output__; }
                set { SetTransform(ref value); }
        }
        
        /// <summary>	
        /// Retrieves the device associated with the sprite object.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. 	
        /// </remarks>	
        /// <param name="deviceRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the Direct3D device object associated with the sprite object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT ID3DXSprite::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the sprite transform.	
        /// </summary>	
        /// <param name="transformRef"> Pointer to a <see cref="SlimMath.Matrix"/> that contains a transform of the sprite from the original world space. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT ID3DXSprite::GetTransform([Out] D3DXMATRIX* pTransform)</unmanaged>
        internal SlimDX2.Result GetTransform(out SlimMath.Matrix transformRef) {
            unsafe {
                transformRef = new SlimMath.Matrix();
                SlimDX2.Result __result__;
                fixed (void* transformRef_ = &transformRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, transformRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the sprite transform.	
        /// </summary>	
        /// <param name="transformRef"> Pointer to a <see cref="SlimMath.Matrix"/> that contains a transform of the sprite from the original world space. Use this transform to scale, rotate, or transform the sprite. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT ID3DXSprite::SetTransform([None] const D3DXMATRIX* pTransform)</unmanaged>
        internal SlimDX2.Result SetTransform(ref SlimMath.Matrix transformRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* transformRef_ = &transformRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, transformRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the right-handed world-view transform for a sprite. A call to this method is required before billboarding or sorting sprites.	
        /// </summary>	
        /// <remarks>	
        ///  A call to this method (or to <see cref="SlimDX2.Direct3D9.Sprite.SetWorldViewLH"/>) is required if the sprite will be rendered with the {{D3DXSprite__BILLBOARD}}, D3DXSprite__SORT_DEPTH_FRONTTOBACK, or D3DXSprite__SORT_DEPTH_BACKTOFRONT flag value in <see cref="SlimDX2.Direct3D9.Sprite.Begin"/>. 	
        /// </remarks>	
        /// <param name="worldRef"> Pointer to a <see cref="SlimMath.Matrix"/> that contains a world transform. If NULL, the identity matrix is used for the world transform. </param>
        /// <param name="viewRef"> Pointer to a <see cref="SlimMath.Matrix"/> that contains a view transform. If NULL, the identity matrix is used for the view transform. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT ID3DXSprite::SetWorldViewRH([None] const D3DXMATRIX* pWorld,[None] const D3DXMATRIX* pView)</unmanaged>
        public SlimDX2.Result SetWorldViewRH(ref SlimMath.Matrix worldRef, ref SlimMath.Matrix viewRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* worldRef_ = &worldRef)
                    fixed (void* viewRef_ = &viewRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, worldRef_, viewRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the left-handed world-view transform for a sprite. A call to this method is required before billboarding or sorting sprites.	
        /// </summary>	
        /// <remarks>	
        ///  A call to this method (or to <see cref="SlimDX2.Direct3D9.Sprite.SetWorldViewRH"/>) is required if the sprite will be rendered with the {{D3DXSprite__BILLBOARD}}, D3DXSprite__SORT_DEPTH_FRONTTOBACK, or D3DXSprite__SORT_DEPTH_BACKTOFRONT flag value in <see cref="SlimDX2.Direct3D9.Sprite.Begin"/>. 	
        /// </remarks>	
        /// <param name="worldRef"> Pointer to a <see cref="SlimMath.Matrix"/> that contains a world transform. If NULL, the identity matrix is used for the world transform. </param>
        /// <param name="viewRef"> Pointer to a <see cref="SlimMath.Matrix"/> that contains a view transform. If NULL, the identity matrix is used for the view transform. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT ID3DXSprite::SetWorldViewLH([None] const D3DXMATRIX* pWorld,[None] const D3DXMATRIX* pView)</unmanaged>
        public SlimDX2.Result SetWorldViewLH(ref SlimMath.Matrix worldRef, ref SlimMath.Matrix viewRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* worldRef_ = &worldRef)
                    fixed (void* viewRef_ = &viewRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, worldRef_, viewRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Prepares a device for drawing sprites.	
        /// </summary>	
        /// <remarks>	
        ///  This method must be called from inside a <see cref="SlimDX2.Direct3D9.Device.BeginScene"/> . . . <see cref="SlimDX2.Direct3D9.Device.EndScene"/> sequence. ID3DXSprite::Begin cannot be used as a substitute for either IDirect3DDevice9::BeginScene or <see cref="SlimDX2.Direct3D9.RenderToSurface.BeginScene"/>. This method will set the following states on the device. Render States:  Type (<see cref="SlimDX2.Direct3D9.RenderState"/>)Value D3DRS_ALPHABLENDENABLETRUE D3DRS_ALPHAFUNCD3DCMP_GREATER D3DRS_ALPHAREF0x00 D3DRS_ALPHATESTENABLEAlphaCmpCaps D3DRS_BLENDOPD3DBLENDOP_ADD D3DRS_CLIPPINGTRUE D3DRS_CLIPPLANEENABLEFALSE D3DRS_COLORWRITEENABLED3DCOLORWRITEENABLE_ALPHA | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_RED D3DRS_CULLMODED3DCULL_NONE D3DRS_DESTBLENDD3DBLEND_INVSRCALPHA D3DRS_DIFFUSEMATERIALSOURCED3DMCS_COLOR1 D3DRS_ENABLEADAPTIVETESSELLATIONFALSE D3DRS_FILLMODED3DFILL_SOLID D3DRS_FOGENABLEFALSE D3DRS_INDEXEDVERTEXBLENDENABLEFALSE D3DRS_LIGHTINGFALSE D3DRS_RANGEFOGENABLEFALSE D3DRS_SEPARATEALPHABLENDENABLEFALSE D3DRS_SHADEMODED3DSHADE_GOURAUD D3DRS_SPECULARENABLEFALSE D3DRS_SRCBLENDD3DBLEND_SRCALPHA D3DRS_SRGBWRITEENABLEFALSE D3DRS_STENCILENABLEFALSE D3DRS_VERTEXBLENDFALSE D3DRS_WRAP00  ? Texture Stage States:  Stage IdentifierType (<see cref="SlimDX2.Direct3D9.TextureStage"/>)Value 0D3DTSS_ALPHAARG1D3DTA_TEXTURE 0D3DTSS_ALPHAARG2D3DTA_DIFFUSE 0D3DTSS_ALPHAOPD3DTOP_MODULATE 0D3DTSS_COLORARG1D3DTA_TEXTURE 0D3DTSS_COLORARG2D3DTA_DIFFUSE 0D3DTSS_COLOROPD3DTOP_MODULATE 0D3DTSS_TEXCOORDINDEX0 0D3DTSS_TEXTURETRANSFORMFLAGSD3DTTFF_DISABLE 1D3DTSS_ALPHAOPD3DTOP_DISABLE 1D3DTSS_COLOROPD3DTOP_DISABLE  ? Sampler States:  Sampler Stage IndexType (<see cref="SlimDX2.Direct3D9.SamplerState"/>)Value 0D3DSAMP_ADDRESSUD3DTADDRESS_CLAMP 0D3DSAMP_ADDRESSVD3DTADDRESS_CLAMP 0D3DSAMP_MAGFILTERD3DTEXF_ANISOTROPIC if TextureFilterCaps includes D3DPTFILTERCAPS_MAGFANISOTROPIC; otherwise D3DTEXF_LINEAR 0D3DSAMP_MAXMIPLEVEL0 0D3DSAMP_MAXANISOTROPYMaxAnisotropy 0D3DSAMP_MINFILTERD3DTEXF_ANISOTROPIC if TextureFilterCaps includes D3DPTFILTERCAPS_MINFANISOTROPIC; otherwise D3DTEXF_LINEAR 0D3DSAMP_MIPFILTERD3DTEXF_LINEAR if TextureFilterCaps includes D3DPTFILTERCAPS_MIPFLINEAR; otherwise D3DTEXF_POINT 0D3DSAMP_MIPMAPLODBIAS0 0D3DSAMP_SRGBTEXTURE0  ? Note??This method disables N-patches. 	
        /// </remarks>	
        /// <param name="flags"> Combination of zero or more flags that describe sprite rendering options. For this method, the valid flags are:  D3DXSPRITE_ALPHABLEND D3DXSPRITE__BILLBOARD D3DXSPRITE_DONOTMODIFY_RENDERSTATE D3DXSPRITE_DONOTSAVESTATE D3DXSPRITE_OBJECTSPACE D3DXSPRITE__SORT_DEPTH_BACKTOFRONT D3DXSPRITE__SORT_DEPTH_FRONTTOBACK D3DXSPRITE__SORT_TEXTURE   For a description of the flags and for information on how to control device state capture and device view transforms, see {{D3DXSPRITE}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXSprite::Begin([None] int Flags)</unmanaged>
        public SlimDX2.Result Begin(int flags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds a sprite to the list of batched sprites.	
        /// </summary>	
        /// <remarks>	
        ///  To scale, rotate, or translate a sprite, call <see cref="SlimDX2.Direct3D9.Sprite.SetTransform"/> with a matrix that contains the scale, rotate, and translate (SRT) values, before calling ID3DXSprite::Draw. For information about setting SRT values in a matrix, see {{Matrix Transforms}}. 	
        /// </remarks>	
        /// <param name="pTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface that represents the sprite texture. </param>
        /// <param name="srcRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure that indicates the portion of the source texture to use for the sprite. If this parameter is NULL, then the entire source image is used for the sprite. </param>
        /// <param name="centerRef"> Pointer to a <see cref="SlimMath.Vector3"/> vector that identifies the center of the sprite. If this argument is NULL, the point (0,0,0) is used, which is the upper-left corner. </param>
        /// <param name="ositionRef"> Pointer to a <see cref="SlimMath.Vector3"/> vector that identifies the position of the sprite. If this argument is NULL, the point (0,0,0) is used, which is the upper-left corner. </param>
        /// <param name="color">  <see cref="SlimMath.Color4"/> type. The color and alpha channels are modulated by this value. A value of 0xFFFFFFFF maintains the original source color and alpha data. Use the {{D3DCOLOR_RGBA}} macro to help generate this color. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXSprite::Draw([None] LPDIRECT3DTEXTURE9 pTexture,[None] const RECT* pSrcRect,[None] const D3DXVECTOR3* pCenter,[None] const D3DXVECTOR3* pPosition,[None] D3DCOLOR Color)</unmanaged>
        public SlimDX2.Result Draw(SlimDX2.Direct3D9.Texture pTexture, ref SlimDX2.Rectangle srcRectRef, ref SlimMath.Vector3 centerRef, ref SlimMath.Vector3 ositionRef, SlimMath.Color4 color) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* srcRectRef_ = &srcRectRef)
                    fixed (void* centerRef_ = &centerRef)
                        fixed (void* ositionRef_ = &ositionRef)
                            __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, (void*)((pTexture == null)?IntPtr.Zero:pTexture.NativePointer), srcRectRef_, centerRef_, ositionRef_, color.ToArgb());
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Forces all batched sprites to be submitted to the device. Device states remain as they were after the last call to <see cref="SlimDX2.Direct3D9.Sprite.Begin"/>. The list of batched sprites is then cleared.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT ID3DXSprite::Flush()</unmanaged>
        public SlimDX2.Result Flush() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Calls <see cref="SlimDX2.Direct3D9.Sprite.Flush"/> and restores the device state to how it was before <see cref="SlimDX2.Direct3D9.Sprite.Begin"/> was called.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXSprite::End cannot be used as a substitute for either <see cref="SlimDX2.Direct3D9.Device.EndScene"/> or <see cref="SlimDX2.Direct3D9.RenderToSurface.EndScene"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT ID3DXSprite::End()</unmanaged>
        public SlimDX2.Result End() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost or before resetting a device.	
        /// </summary>	
        /// <remarks>	
        ///  This method should be called whenever the device is lost or before the user calls <see cref="SlimDX2.Direct3D9.Device.Reset"/>. Even if the device was not actually lost, ID3DXSprite::OnLostDevice is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling IDirect3DDevice9::Reset and then <see cref="SlimDX2.Direct3D9.Sprite.OnResetDevice"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSprite::OnLostDevice()</unmanaged>
        public SlimDX2.Result OnLostDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to re-acquire resources and save initial state.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXSprite::OnResetDevice should be called each time the device is reset (using <see cref="SlimDX2.Direct3D9.Device.Reset"/>), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSprite::OnResetDevice()</unmanaged>
        public SlimDX2.Result OnResetDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXFont</unmanaged>
    [Guid("d79dbb70-5f21-4d36-bbc2-ff525c213cdc")]
    public partial class Font : SlimDX2.ComObject {
        public Font(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the Direct3D device associated with the font object.	
        /// </summary>	
        /// <remarks>	
        ///  Note??Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Be sure to call <see cref="SlimDX2.ComObject"/> when you are done using this IDirect3DDevice9 interface or you will have a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT ID3DXFont::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets a description of the current font object. GetDescW and GetDescA are identical to this method, except that a pointer is returned to a <see cref="SlimDX2.Direct3D9.FontDescription"/> or D3DXFONT_DESCA structure, respectively.	
        /// </summary>	
        /// <remarks>	
        ///  This method describes Unicode font objects if UNICODE is defined. Otherwise GetDescA is called, which returns a pointer to the {{D3DXFONT_DESCA}} structure. 	
        /// </remarks>	
        /// <unmanaged>HRESULT ID3DXFont::GetDescW([Out] D3DXFONT_DESCW* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.FontDescription Description {
                get { SlimDX2.Direct3D9.FontDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Returns a handle to a display device context (DC) that has the font set.	
        /// </summary>	
        /// <unmanaged>HDC ID3DXFont::GetDC()</unmanaged>
        public IntPtr DC {
                get { return GetDC(); }
        }
        
        /// <summary>	
        /// Retrieves the Direct3D device associated with the font object.	
        /// </summary>	
        /// <remarks>	
        ///  Note??Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Be sure to call <see cref="SlimDX2.ComObject"/> when you are done using this IDirect3DDevice9 interface or you will have a memory leak. 	
        /// </remarks>	
        /// <param name="deviceRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the Direct3D device object associated with the font object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXFont::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a description of the current font object. GetDescW and GetDescA are identical to this method, except that a pointer is returned to a <see cref="SlimDX2.Direct3D9.FontDescription"/> or D3DXFONT_DESCA structure, respectively.	
        /// </summary>	
        /// <remarks>	
        ///  This method describes Unicode font objects if UNICODE is defined. Otherwise GetDescA is called, which returns a pointer to the {{D3DXFONT_DESCA}} structure. 	
        /// </remarks>	
        /// <param name="descRef"> Pointer to a {{D3DXFONT_DESC}} structure that describes the font object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXFont::GetDescW([Out] D3DXFONT_DESCW* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.FontDescription descRef) {
            unsafe {
                SlimDX2.Direct3D9.FontDescription.__Native descRef_ = new SlimDX2.Direct3D9.FontDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, &descRef_);
                descRef = new SlimDX2.Direct3D9.FontDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves font characteristics that are identified in a {{TEXTMETRIC}} structure. This method supports ANSI and Unicode compiler settings.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the structure type. If Unicode is defined, the function returns a TEXTMETRICW structure. Otherwise, the function call returns a TEXTMETRICA structure. 	
        /// </remarks>	
        /// <param name="textMetricsRef"> Pointer to a {{TEXTMETRIC}} structure, which contains font properties. </param>
        /// <returns>  {{BOOL}}  Nonzero if the function is successful; otherwise 0. </returns>
        /// <unmanaged>BOOL ID3DXFont::GetTextMetricsA([Out] TEXTMETRICA* pTextMetrics)</unmanaged>
        internal bool GetTextMetricsA(out SlimDX2.Windows.Win32.Textmetrica textMetricsRef) {
            unsafe {
                textMetricsRef = new SlimDX2.Windows.Win32.Textmetrica();
                bool __result__;
                fixed (void* textMetricsRef_ = &textMetricsRef)
                    __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, textMetricsRef_));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves font characteristics that are identified in a {{TEXTMETRIC}} structure. This method supports ANSI and Unicode compiler settings.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the structure type. If Unicode is defined, the function returns a TEXTMETRICW structure. Otherwise, the function call returns a TEXTMETRICA structure. 	
        /// </remarks>	
        /// <param name="textMetricsRef"> Pointer to a {{TEXTMETRIC}} structure, which contains font properties. </param>
        /// <returns>  {{BOOL}}  Nonzero if the function is successful; otherwise 0. </returns>
        /// <unmanaged>BOOL ID3DXFont::GetTextMetricsW([Out] TEXTMETRICW* pTextMetrics)</unmanaged>
        internal bool GetTextMetricsW(out SlimDX2.Windows.Win32.Textmetricw textMetricsRef) {
            unsafe {
                textMetricsRef = new SlimDX2.Windows.Win32.Textmetricw();
                bool __result__;
                fixed (void* textMetricsRef_ = &textMetricsRef)
                    __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, textMetricsRef_));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns a handle to a display device context (DC) that has the font set.	
        /// </summary>	
        /// <returns>  {{HDC}}  Handle to a display DC. </returns>
        /// <unmanaged>HDC ID3DXFont::GetDC()</unmanaged>
        internal IntPtr GetDC() {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 8 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns information about the placement and orientation of a glyph in a character cell.	
        /// </summary>	
        /// <param name="glyph"> Glyph identifier. </param>
        /// <param name="textureRef"> Address of a pointer to a <see cref="SlimDX2.Direct3D9.Texture"/> object that contains the glyph. </param>
        /// <param name="blackBoxRef"> Pointer to the smallest rectangle object that completely encloses the glyph. </param>
        /// <param name="cellIncRef"> Pointer to the two-dimensional vector that connects the origin of the current character cell to the origin of the next character cell. See <see cref="System.Drawing.Point"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXFont::GetGlyphData([None] UINT Glyph,[Out] LPDIRECT3DTEXTURE9* ppTexture,[Out] RECT* pBlackBox,[Out] POINT* pCellInc)</unmanaged>
        public SlimDX2.Result GetGlyphData(int glyph, out SlimDX2.Direct3D9.Texture textureRef, out SlimDX2.Rectangle blackBoxRef, out System.Drawing.Point cellIncRef) {
            unsafe {
                IntPtr textureRef_ = IntPtr.Zero;
                blackBoxRef = new SlimDX2.Rectangle();
                cellIncRef = new System.Drawing.Point();
                SlimDX2.Result __result__;
                fixed (void* blackBoxRef_ = &blackBoxRef)
                    fixed (void* cellIncRef_ = &cellIncRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, glyph, &textureRef_, blackBoxRef_, cellIncRef_);
                textureRef = (textureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(textureRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Loads a series of characters into video memory to improve the efficiency of rendering to the device.	
        /// </summary>	
        /// <remarks>	
        ///  This method generates textures containing glyphs that represent the input characters. The glyphs are drawn as a series of triangles. Characters will not be rendered to the device; {{DrawText}} must still be called to render the characters. However, by pre-loading characters into video memory, DrawText will use substantially fewer CPU resources. This method internally converts characters to glyphs using the GDI function {{GetCharacterPlacement}}. 	
        /// </remarks>	
        /// <param name="first"> ID of the first character to be loaded into video memory. </param>
        /// <param name="last"> ID of the last character to be loaded into video memory. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXFont::PreloadCharacters([None] UINT First,[None] UINT Last)</unmanaged>
        public SlimDX2.Result PreloadCharacters(int first, int last) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, first, last);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Loads a series of glyphs into video memory to improve the efficiency of rendering to the device.	
        /// </summary>	
        /// <remarks>	
        ///  This method generates textures that contain the input glyphs. The glyphs are drawn as a series of triangles. Glyphs will not be rendered to the device; {{DrawText}} must still be called to render the glyphs. However, by pre-loading glyphs into video memory, DrawText will use substantially fewer CPU resources. 	
        /// </remarks>	
        /// <param name="first"> ID of the first glyph to be loaded into video memory. </param>
        /// <param name="last"> ID of the last glyph to be loaded into video memory. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXFont::PreloadGlyphs([None] UINT First,[None] UINT Last)</unmanaged>
        public SlimDX2.Result PreloadGlyphs(int first, int last) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, first, last);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Loads formatted text into video memory to improve the efficiency of rendering to the device. This method supports ANSI and Unicode strings.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to PreloadTextW. Otherwise, the function call resolves to PreloadTextA because ANSI strings are being used. This method generates textures that contain glyphs that represent the input text. The glyphs are drawn as a series of triangles. Text will not be rendered to the device; {{DrawText}} must still be called to render the text. However, by preloading text into video memory, DrawText will use substantially fewer CPU resources. This method internally converts characters to glyphs using the GDI function {{GetCharacterPlacement}}. 	
        /// </remarks>	
        /// <param name="stringRef"> Pointer to a string of characters to be loaded into video memory. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR; otherwise, the data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="count"> Number of characters in the text string. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXFont::PreloadTextA([None] const char* pString,[None] INT Count)</unmanaged>
        public SlimDX2.Result PreloadTextA(string stringRef, int count) {
            unsafe {
                IntPtr stringRef_ = Marshal.StringToHGlobalAnsi(stringRef);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, (void*)stringRef_, count);
                Marshal.FreeHGlobal(stringRef_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Loads formatted text into video memory to improve the efficiency of rendering to the device. This method supports ANSI and Unicode strings.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to PreloadTextW. Otherwise, the function call resolves to PreloadTextA because ANSI strings are being used. This method generates textures that contain glyphs that represent the input text. The glyphs are drawn as a series of triangles. Text will not be rendered to the device; {{DrawText}} must still be called to render the text. However, by preloading text into video memory, DrawText will use substantially fewer CPU resources. This method internally converts characters to glyphs using the GDI function {{GetCharacterPlacement}}. 	
        /// </remarks>	
        /// <param name="stringRef"> Pointer to a string of characters to be loaded into video memory. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR; otherwise, the data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="count"> Number of characters in the text string. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXFont::PreloadTextW([None] const wchar* pString,[None] INT Count)</unmanaged>
        public SlimDX2.Result PreloadTextW(string stringRef, int count) {
            unsafe {
                IntPtr stringRef_ = Marshal.StringToHGlobalUni(stringRef);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, (void*)stringRef_, count);
                Marshal.FreeHGlobal(stringRef_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Draws formatted text. This method supports ANSI and Unicode strings.	
        /// </summary>	
        /// <remarks>	
        ///  The parameters of this method are very similar to those of the GDI {{DrawText}} function. This method supports both ANSI and Unicode strings. This method must be called inside a  {{BeginScene}} ... {{EndScene}} block. The only exception is when an application calls DrawText with DT_CALCRECT to calculate the size of a given block of text. Unless the DT_NOCLIP format is used, this method clips the text so that it does not appear outside the specified rectangle. All formatting is assumed to have multiple lines unless the DT_SINGLELINE format is specified. If the selected font is too large for the rectangle, this method does not attempt to substitute a smaller font. This method supports only fonts whose escapement and orientation are both zero. 	
        /// </remarks>	
        /// <param name="pSprite"> Pointer to an <see cref="SlimDX2.Direct3D9.Sprite"/> object that contains the string. Can be NULL, in which case Direct3D will render the string with its own sprite object. To improve efficiency, a sprite object should be specified if DrawText is to be called more than once in a row. </param>
        /// <param name="stringRef"> Pointer to a string to draw. If the Count parameter is -1, the string must be null-terminated. </param>
        /// <param name="count"> Specifies the number of characters in the string. If Count is -1, then the pString parameter is assumed to be a pointer to a null-terminated string and DrawText computes the character count automatically. </param>
        /// <param name="rectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure that contains the rectangle, in logical coordinates, in which the text is to be formatted. The coordinate value of the rectangle's right side must be greater than that of its left side. Likewise, the coordinate value of the bottom must be greater than that of the top. </param>
        /// <param name="format">  Specifies the method of formatting the text. It can be any combination of the following values:  ValueMeaning  DT_BOTTOM   Justifies the text to the bottom of the rectangle. This value must be combined with DT_SINGLELINE.   DT_CALCRECT   Determines the width and height of the rectangle. If there are multiple lines of text, DrawText uses the width of the rectangle pointed to by the pRect parameter and extends the base of the rectangle to bound the last line of text. If there is only one line of text, DrawText modifies the right side of the rectangle so that it bounds the last character in the line. In either case, DrawText returns the height of the formatted text but does not draw the text.   DT_CENTER   Centers text horizontally in the rectangle.   DT_EXPANDTABS   Expands tab characters. The default number of characters per tab is eight.   DT_LEFT   Aligns text to the left.   DT_NOCLIP   Draws without clipping. DrawText is somewhat faster when DT_NOCLIP is used.   DT_RIGHT   Aligns text to the right.   DT_RTLREADING   Displays text in right-to-left reading order for bidirectional text when a Hebrew or Arabic font is selected. The default reading order for all text is left-to-right.   DT_SINGLELINE   Displays text on a single line only. Carriage returns and line feeds do not break the line.   DT_TOP   Top-justifies text.   DT_VCENTER   Centers text vertically (single line only).   DT_WORDBREAK   Breaks words. Lines are automatically broken between words if a word would extend past the edge of the rectangle specified by the pRect parameter. A carriage return/line feed sequence also breaks the line.   ? </param>
        /// <param name="color"> Color of the text. For more information, see <see cref="SlimMath.Color4"/>. </param>
        /// <returns>  {{INT}}  If the function succeeds, the return value is the height of the text in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from pRect (top to the bottom) of the drawn text. If the function fails, the return value is zero. </returns>
        /// <unmanaged>INT ID3DXFont::DrawTextA([None] LPD3DXSPRITE pSprite,[None] const char* pString,[None] INT Count,[None] RECT* pRect,[None] int Format,[None] D3DCOLOR Color)</unmanaged>
        public int DrawTextA(SlimDX2.Direct3D9.Sprite pSprite, string stringRef, int count, ref SlimDX2.Rectangle rectRef, int format, SlimMath.Color4 color) {
            unsafe {
                IntPtr stringRef_ = Marshal.StringToHGlobalAnsi(stringRef);
                int __result__;
                fixed (void* rectRef_ = &rectRef)
                    __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, (void*)((pSprite == null)?IntPtr.Zero:pSprite.NativePointer), (void*)stringRef_, count, rectRef_, format, color.ToArgb());
                Marshal.FreeHGlobal(stringRef_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Draws formatted text. This method supports ANSI and Unicode strings.	
        /// </summary>	
        /// <remarks>	
        ///  The parameters of this method are very similar to those of the GDI {{DrawText}} function. This method supports both ANSI and Unicode strings. This method must be called inside a  {{BeginScene}} ... {{EndScene}} block. The only exception is when an application calls DrawText with DT_CALCRECT to calculate the size of a given block of text. Unless the DT_NOCLIP format is used, this method clips the text so that it does not appear outside the specified rectangle. All formatting is assumed to have multiple lines unless the DT_SINGLELINE format is specified. If the selected font is too large for the rectangle, this method does not attempt to substitute a smaller font. This method supports only fonts whose escapement and orientation are both zero. 	
        /// </remarks>	
        /// <param name="pSprite"> Pointer to an <see cref="SlimDX2.Direct3D9.Sprite"/> object that contains the string. Can be NULL, in which case Direct3D will render the string with its own sprite object. To improve efficiency, a sprite object should be specified if DrawText is to be called more than once in a row. </param>
        /// <param name="stringRef"> Pointer to a string to draw. If the Count parameter is -1, the string must be null-terminated. </param>
        /// <param name="count"> Specifies the number of characters in the string. If Count is -1, then the pString parameter is assumed to be a pointer to a null-terminated string and DrawText computes the character count automatically. </param>
        /// <param name="rectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure that contains the rectangle, in logical coordinates, in which the text is to be formatted. The coordinate value of the rectangle's right side must be greater than that of its left side. Likewise, the coordinate value of the bottom must be greater than that of the top. </param>
        /// <param name="format">  Specifies the method of formatting the text. It can be any combination of the following values:  ValueMeaning  DT_BOTTOM   Justifies the text to the bottom of the rectangle. This value must be combined with DT_SINGLELINE.   DT_CALCRECT   Determines the width and height of the rectangle. If there are multiple lines of text, DrawText uses the width of the rectangle pointed to by the pRect parameter and extends the base of the rectangle to bound the last line of text. If there is only one line of text, DrawText modifies the right side of the rectangle so that it bounds the last character in the line. In either case, DrawText returns the height of the formatted text but does not draw the text.   DT_CENTER   Centers text horizontally in the rectangle.   DT_EXPANDTABS   Expands tab characters. The default number of characters per tab is eight.   DT_LEFT   Aligns text to the left.   DT_NOCLIP   Draws without clipping. DrawText is somewhat faster when DT_NOCLIP is used.   DT_RIGHT   Aligns text to the right.   DT_RTLREADING   Displays text in right-to-left reading order for bidirectional text when a Hebrew or Arabic font is selected. The default reading order for all text is left-to-right.   DT_SINGLELINE   Displays text on a single line only. Carriage returns and line feeds do not break the line.   DT_TOP   Top-justifies text.   DT_VCENTER   Centers text vertically (single line only).   DT_WORDBREAK   Breaks words. Lines are automatically broken between words if a word would extend past the edge of the rectangle specified by the pRect parameter. A carriage return/line feed sequence also breaks the line.   ? </param>
        /// <param name="color"> Color of the text. For more information, see <see cref="SlimMath.Color4"/>. </param>
        /// <returns>  {{INT}}  If the function succeeds, the return value is the height of the text in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from pRect (top to the bottom) of the drawn text. If the function fails, the return value is zero. </returns>
        /// <unmanaged>INT ID3DXFont::DrawTextW([None] LPD3DXSPRITE pSprite,[None] const wchar* pString,[None] INT Count,[None] RECT* pRect,[None] int Format,[None] D3DCOLOR Color)</unmanaged>
        public int DrawTextW(SlimDX2.Direct3D9.Sprite pSprite, string stringRef, int count, ref SlimDX2.Rectangle rectRef, int format, SlimMath.Color4 color) {
            unsafe {
                IntPtr stringRef_ = Marshal.StringToHGlobalUni(stringRef);
                int __result__;
                fixed (void* rectRef_ = &rectRef)
                    __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, (void*)((pSprite == null)?IntPtr.Zero:pSprite.NativePointer), (void*)stringRef_, count, rectRef_, format, color.ToArgb());
                Marshal.FreeHGlobal(stringRef_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost, or before resetting a device.	
        /// </summary>	
        /// <remarks>	
        ///  This method should be called whenever the device is lost or before the user calls {{Reset}}. Even if the device was not actually lost, OnLostDevice is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling Reset and then {{OnResetDevice}}. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXFont::OnLostDevice()</unmanaged>
        public SlimDX2.Result OnLostDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to re-acquire resources and save initial state.	
        /// </summary>	
        /// <remarks>	
        ///  OnResetDevice should be called each time the device is reset (using {{Reset}}), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXFont::OnResetDevice()</unmanaged>
        public SlimDX2.Result OnResetDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXRenderToSurface</unmanaged>
    [Guid("6985f346-2c3d-43b3-be8b-daae8a03d894")]
    public partial class RenderToSurface : SlimDX2.ComObject {
        public RenderToSurface(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the Direct3D device associated with the render surface.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXRenderToSurface::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the parameters of the render surface.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXRenderToSurface::GetDesc([Out] D3DXRTS_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.RenderToSurfaceDescription Description {
                get { SlimDX2.Direct3D9.RenderToSurfaceDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the Direct3D device associated with the render surface.	
        /// </summary>	
        /// <param name="deviceRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the Direct3D device object associated with the render surface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Be sure to call <see cref="SlimDX2.ComObject"/> when you are done using this IDirect3DDevice9 interface or you will have a memory leak. </returns>
        /// <unmanaged>HRESULT ID3DXRenderToSurface::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the parameters of the render surface.	
        /// </summary>	
        /// <param name="descRef"> Pointer to a <see cref="SlimDX2.Direct3D9.RenderToSurfaceDescription"/> structure, describing the parameters of the render surface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXRenderToSurface::GetDesc([Out] D3DXRTS_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.RenderToSurfaceDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D9.RenderToSurfaceDescription();
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Begins a scene.	
        /// </summary>	
        /// <param name="pSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the render surface. </param>
        /// <param name="viewportRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Viewport"/> structure, describing the viewport for the scene. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL.D3DERR_OUTOFVIDEOMEMORY D3DXERR_INVALIDDATA E_OUTOFMEMORY </returns>
        /// <unmanaged>HRESULT ID3DXRenderToSurface::BeginScene([None] LPDIRECT3DSURFACE9 pSurface,[None] const D3DVIEWPORT9* pViewport)</unmanaged>
        public SlimDX2.Result BeginScene(SlimDX2.Direct3D9.Surface pSurface, ref SlimDX2.Direct3D9.Viewport viewportRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* viewportRef_ = &viewportRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)((pSurface == null)?IntPtr.Zero:pSurface.NativePointer), viewportRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Ends a scene.	
        /// </summary>	
        /// <param name="mipFilter"> Filter options, enumerated in {{D3DX_FILTER}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXRenderToSurface::EndScene([None] int MipFilter)</unmanaged>
        public SlimDX2.Result EndScene(int mipFilter) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, mipFilter);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost or before resetting a device.	
        /// </summary>	
        /// <remarks>	
        ///  This method should be called whenever the device is lost or before the user calls <see cref="SlimDX2.Direct3D9.Device.Reset"/>. Even if the device was not actually lost, ID3DXRenderToSurface::OnLostDevice is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling IDirect3DDevice9::Reset and then ID3DXRenderToSurface::OnResetDevice. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXRenderToSurface::OnLostDevice()</unmanaged>
        public SlimDX2.Result OnLostDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to re-acquire resources and save initial state.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXRenderToSurface::OnResetDevice should be called each time the device is reset (using <see cref="SlimDX2.Direct3D9.Device.Reset"/>), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXRenderToSurface::OnResetDevice()</unmanaged>
        public SlimDX2.Result OnResetDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXRenderToEnvMap</unmanaged>
    [Guid("313f1b4b-c7b0-4fa2-9d9d-8d380b64385e")]
    public partial class RenderToEnvironmentMap : SlimDX2.ComObject {
        public RenderToEnvironmentMap(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the Direct3D device associated with the environment map.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the description of the render surface.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::GetDesc([Out] D3DXRTE_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.RenderToEnvironmentMapDescription Description {
                get { SlimDX2.Direct3D9.RenderToEnvironmentMapDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the Direct3D device associated with the environment map.	
        /// </summary>	
        /// <param name="deviceRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface that represents the Direct3D device object associated with the environment map. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. Calling this method increases the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Be sure to call <see cref="SlimDX2.ComObject"/> when you are done using this IDirect3DDevice9 interface or you will have a memory leak. </returns>
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the description of the render surface.	
        /// </summary>	
        /// <param name="descRef"> Pointer to a <see cref="SlimDX2.Direct3D9.RenderToEnvironmentMapDescription"/> structure that describes the rendering surface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::GetDesc([Out] D3DXRTE_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.RenderToEnvironmentMapDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D9.RenderToEnvironmentMapDescription();
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Initiate the rendering of a cubic environment map.	
        /// </summary>	
        /// <remarks>	
        ///  See <see cref="SlimDX2.Direct3D9.RenderToEnvironmentMap.Face"/> to draw each of the 6 faces. 	
        /// </remarks>	
        /// <param name="pCubeTex"> Pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface that represents the cube texture to which to render. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::BeginCube([None] LPDIRECT3DCUBETEXTURE9 pCubeTex)</unmanaged>
        public SlimDX2.Result BeginCube(SlimDX2.Direct3D9.CubeTexture pCubeTex) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)((pCubeTex == null)?IntPtr.Zero:pCubeTex.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Initiate the rendering of a spherical environment map.	
        /// </summary>	
        /// <remarks>	
        ///  See <see cref="SlimDX2.Direct3D9.RenderToEnvironmentMap.Face"/> to draw the face. 	
        /// </remarks>	
        /// <param name="pTex"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface that represents the texture to which to render. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL.E_FAIL </returns>
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::BeginSphere([None] LPDIRECT3DTEXTURE9 pTex)</unmanaged>
        public SlimDX2.Result BeginSphere(SlimDX2.Direct3D9.Texture pTex) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)((pTex == null)?IntPtr.Zero:pTex.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Initiate the rendering of a hemispheric environment map.	
        /// </summary>	
        /// <remarks>	
        ///  See <see cref="SlimDX2.Direct3D9.RenderToEnvironmentMap.Face"/> to draw the face. 	
        /// </remarks>	
        /// <param name="pTexZPos"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface that represents the positive texture render surface. </param>
        /// <param name="pTexZNeg"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface that represents the negative texture render surface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL.E_FAIL </returns>
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::BeginHemisphere([None] LPDIRECT3DTEXTURE9 pTexZPos,[None] LPDIRECT3DTEXTURE9 pTexZNeg)</unmanaged>
        public SlimDX2.Result BeginHemisphere(SlimDX2.Direct3D9.Texture pTexZPos, SlimDX2.Direct3D9.Texture pTexZNeg) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)((pTexZPos == null)?IntPtr.Zero:pTexZPos.NativePointer), (void*)((pTexZNeg == null)?IntPtr.Zero:pTexZNeg.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Initiate the rendering of a parabolic environment map.	
        /// </summary>	
        /// <remarks>	
        ///  See <see cref="SlimDX2.Direct3D9.RenderToEnvironmentMap.Face"/> to draw the faces. 	
        /// </remarks>	
        /// <param name="pTexZPos"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface that represents the positive render texture. </param>
        /// <param name="pTexZNeg"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface that represents the negative render texture. </param>
        /// <returns>  <see cref="int"/>  If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL.E_FAIL </returns>
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::BeginParabolic([None] LPDIRECT3DTEXTURE9 pTexZPos,[None] LPDIRECT3DTEXTURE9 pTexZNeg)</unmanaged>
        public SlimDX2.Result BeginParabolic(SlimDX2.Direct3D9.Texture pTexZPos, SlimDX2.Direct3D9.Texture pTexZNeg) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, (void*)((pTexZPos == null)?IntPtr.Zero:pTexZPos.NativePointer), (void*)((pTexZNeg == null)?IntPtr.Zero:pTexZNeg.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Initiate the drawing of each face of an environment map.	
        /// </summary>	
        /// <remarks>	
        ///  This method must be called once for each type of environment map. The only exception is a cubic environment map which requires this method to be called six times, once for each face in D3DCUBEMAP_FACES. For more information, see {{Environment Mapping (Direct3D 9)}}.  	
        /// </remarks>	
        /// <param name="face"> The first face of the environmental cube map. See <see cref="SlimDX2.Direct3D9.CubeMapFace"/>. </param>
        /// <param name="mipFilter"> A valid combination of one or more {{D3DX_FILTER}} flags. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::Face([None] D3DCUBEMAP_FACES Face,[None] int MipFilter)</unmanaged>
        public SlimDX2.Result Face(SlimDX2.Direct3D9.CubeMapFace face, int mipFilter) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, unchecked((int)face), mipFilter);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Restore all render targets and, if needed, compose all the rendered faces into the environment map surface.	
        /// </summary>	
        /// <param name="mipFilter"> A valid combination of one or more {{D3DX_FILTER}} flags. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::End([None] int MipFilter)</unmanaged>
        public SlimDX2.Result End(int mipFilter) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, mipFilter);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost, or before resetting a device.	
        /// </summary>	
        /// <remarks>	
        ///  This method should be called whenever the device is lost or before the user calls <see cref="SlimDX2.Direct3D9.Device.Reset"/>. Even if the device was not actually lost, ID3DXRenderToEnvMap::OnLostDevice is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling IDirect3DDevice9::Reset and then <see cref="SlimDX2.Direct3D9.RenderToEnvironmentMap.OnResetDevice"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::OnLostDevice()</unmanaged>
        public SlimDX2.Result OnLostDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to re-acquire resources and save initial state.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXRenderToEnvMap::OnResetDevice should be called each time the device is reset (using <see cref="SlimDX2.Direct3D9.Device.Reset"/>), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::OnResetDevice()</unmanaged>
        public SlimDX2.Result OnResetDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXLine</unmanaged>
    [Guid("d379ba7f-9042-4ac4-9f5e-58192a4c6bd8")]
    public partial class Line : SlimDX2.ComObject {
        public Line(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the Direct3D device associated with the line object.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXLine::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the line stipple pattern.	
        /// </summary>	
        /// <unmanaged>int ID3DXLine::GetPattern()</unmanaged>
        public int Pattern {
                get { return GetPattern(); }
                set { SetPattern(value); }
        }
        
        /// <summary>	
        /// Gets the stipple-pattern scale value.	
        /// </summary>	
        /// <unmanaged>FLOAT ID3DXLine::GetPatternScale()</unmanaged>
        public float PatternScale {
                get { return GetPatternScale(); }
                set { SetPatternScale(value); }
        }
        
        /// <summary>	
        /// Gets the thickness of the line.	
        /// </summary>	
        /// <unmanaged>FLOAT ID3DXLine::GetWidth()</unmanaged>
        public float Width {
                get { return GetWidth(); }
                set { SetWidth(value); }
        }
        
        /// <summary>	
        /// Gets the line antialiasing state.	
        /// </summary>	
        /// <unmanaged>BOOL ID3DXLine::GetAntialias()</unmanaged>
        public bool Antialias {
                get { return GetAntialias(); }
                set { SetAntialias(value); }
        }
        
        /// <summary>	
        /// Gets the OpenGL-style line-drawing mode.	
        /// </summary>	
        /// <unmanaged>BOOL ID3DXLine::GetGLLines()</unmanaged>
        public bool GLLines {
                get { return GetGLLines(); }
                set { SetGLLines(value); }
        }
        
        /// <summary>	
        /// Retrieves the Direct3D device associated with the line object.	
        /// </summary>	
        /// <param name="deviceRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the Direct3D device object associated with the line object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXLine::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Prepares a device for drawing lines.	
        /// </summary>	
        /// <remarks>	
        ///  Calling ID3DXLine::Begin is optional. If called outside of a ID3DXLine::Begin/ID3DXLine::End sequence, the draw functions will internally call ID3DXLine::Begin and ID3DXLine::End. To avoid extra overhead, this method should be used if more than one draw function will be called successively. This method must be called from inside an <see cref="SlimDX2.Direct3D9.Device.BeginScene"/> and <see cref="SlimDX2.Direct3D9.Device.EndScene"/> sequence. ID3DXLine::Begin cannot be used as a substitute for either <see cref="SlimDX2.Direct3D9.Device.BeginScene"/> or <see cref="SlimDX2.Direct3D9.RenderToSurface.BeginScene"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXLine::Begin()</unmanaged>
        public SlimDX2.Result Begin() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Draws a line strip in screen space. Input is in the form of an array that defines points (of <see cref="SlimMath.Vector2"/>) on the line strip.	
        /// </summary>	
        /// <param name="vertexListRef"> Array of vertices that make up the line. See <see cref="SlimMath.Vector2"/>. </param>
        /// <param name="dwVertexListCount"> Number of vertices in the vertex list. </param>
        /// <param name="color"> Color of the line. See <see cref="SlimMath.Color4"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXLine::Draw([None] const D3DXVECTOR2* pVertexList,[None] int dwVertexListCount,[None] D3DCOLOR Color)</unmanaged>
        public SlimDX2.Result Draw(ref SlimMath.Vector2 vertexListRef, int dwVertexListCount, SlimMath.Color4 color) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* vertexListRef_ = &vertexListRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, vertexListRef_, dwVertexListCount, color.ToArgb());
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Draws a line strip in screen space with a specified input transformation matrix.	
        /// </summary>	
        /// <param name="vertexListRef"> Array of vertices that make up the line. See <see cref="SlimMath.Vector3"/>. </param>
        /// <param name="dwVertexListCount"> Number of vertices in the vertex list. </param>
        /// <param name="transformRef"> A scale, rotate, and translate (SRT) matrix for transforming the points. See <see cref="SlimMath.Matrix"/>. If this matrix is a projection matrix, any stippled lines will be drawn with a perspective-correct stippling pattern. Or, you can transform the vertices and use <see cref="SlimDX2.Direct3D9.Line.Draw"/> to draw the line with a nonperspective-correct stipple pattern. </param>
        /// <param name="color"> Color of the line. See <see cref="SlimMath.Color4"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXLine::DrawTransform([None] const D3DXVECTOR3* pVertexList,[None] int dwVertexListCount,[None] const D3DXMATRIX* pTransform,[None] D3DCOLOR Color)</unmanaged>
        public SlimDX2.Result DrawTransform(ref SlimMath.Vector3 vertexListRef, int dwVertexListCount, ref SlimMath.Matrix transformRef, SlimMath.Color4 color) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* vertexListRef_ = &vertexListRef)
                    fixed (void* transformRef_ = &transformRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, vertexListRef_, dwVertexListCount, transformRef_, color.ToArgb());
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Applies a stipple pattern to the line.	
        /// </summary>	
        /// <param name="dwPattern"> Describes the stipple pattern: 1 is opaque, 0 is transparent. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXLine::SetPattern([None] int dwPattern)</unmanaged>
        internal SlimDX2.Result SetPattern(int dwPattern) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, dwPattern);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the line stipple pattern.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns the line stipple pattern: 1 is opaque, 0 is transparent. </returns>
        /// <unmanaged>int ID3DXLine::GetPattern()</unmanaged>
        internal int GetPattern() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Stretches the stipple pattern along the line direction.	
        /// </summary>	
        /// <param name="fPatternScale"> Stipple pattern scaling value. 1.0f is the default value and represents no scaling. A value less than 1.0f shrinks the pattern, and a value greater than 1.0 stretches the pattern. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXLine::SetPatternScale([None] FLOAT fPatternScale)</unmanaged>
        internal SlimDX2.Result SetPatternScale(float fPatternScale) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, fPatternScale);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the stipple-pattern scale value.	
        /// </summary>	
        /// <returns>  {{FLOAT}}  Returns the value used to scale the stipple-pattern. 1.0f is the default value and represents no scaling. A value less than 1.0f shrinks the pattern, and a value greater than 1.0 stretches the pattern. </returns>
        /// <unmanaged>FLOAT ID3DXLine::GetPatternScale()</unmanaged>
        internal float GetPatternScale() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct3D9.LocalInterop.Callifloat(_nativePointer, 10 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Specifies the thickness of the line.	
        /// </summary>	
        /// <param name="fWidth"> Describes the line width. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXLine::SetWidth([None] FLOAT fWidth)</unmanaged>
        internal SlimDX2.Result SetWidth(float fWidth) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, fWidth);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the thickness of the line.	
        /// </summary>	
        /// <returns>  {{FLOAT}}  The line thickness. </returns>
        /// <unmanaged>FLOAT ID3DXLine::GetWidth()</unmanaged>
        internal float GetWidth() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct3D9.LocalInterop.Callifloat(_nativePointer, 12 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Toggles line antialiasing.	
        /// </summary>	
        /// <param name="bAntialias"> Toggles antialiasing on and off. TRUE turns antialiasing on, and FALSE turns antialiasing off. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXLine::SetAntialias([None] BOOL bAntialias)</unmanaged>
        internal SlimDX2.Result SetAntialias(bool bAntialias) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, (bAntialias?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the line antialiasing state.	
        /// </summary>	
        /// <returns>  {{BOOL}}  Returns the antialiasing switch value. TRUE means antialiasing is on, and FALSE means antialiasing is off. </returns>
        /// <unmanaged>BOOL ID3DXLine::GetAntialias()</unmanaged>
        internal bool GetAntialias() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Toggles the mode to draw OpenGL-style lines.	
        /// </summary>	
        /// <param name="bGLLines"> Toggles OpenGL-style line drawing. TRUE enables OpenGL-style lines, and FALSE enables Direct3D-style lines. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXLine::SetGLLines([None] BOOL bGLLines)</unmanaged>
        internal SlimDX2.Result SetGLLines(bool bGLLines) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, (bGLLines?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the OpenGL-style line-drawing mode.	
        /// </summary>	
        /// <returns>  {{BOOL}}  Returns TRUE if OpenGL-style lines are enabled, and FALSE if Direct3D-style lines are enabled. </returns>
        /// <unmanaged>BOOL ID3DXLine::GetGLLines()</unmanaged>
        internal bool GetGLLines() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Restores the device state to how it was when <see cref="SlimDX2.Direct3D9.Line.Begin"/> was called.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXLine::End cannot be used as a substitute for either <see cref="SlimDX2.Direct3D9.Device.EndScene"/> or <see cref="SlimDX2.Direct3D9.RenderToSurface.EndScene"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXLine::End()</unmanaged>
        public SlimDX2.Result End() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost, or before resetting a device.	
        /// </summary>	
        /// <remarks>	
        ///  This method should be called whenever the device is lost or before the user calls <see cref="SlimDX2.Direct3D9.Device.Reset"/>. Even if the device was not actually lost, ID3DXLine::OnLostDevice is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling IDirect3DDevice9::Reset and then <see cref="SlimDX2.Direct3D9.Line.OnResetDevice"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXLine::OnLostDevice()</unmanaged>
        public SlimDX2.Result OnLostDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to re-acquire resources and save initial state.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXLine::OnResetDevice should be called each time the device is reset (using <see cref="SlimDX2.Direct3D9.Device.Reset"/>), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXLine::OnResetDevice()</unmanaged>
        public SlimDX2.Result OnResetDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXFile</unmanaged>
    [Guid("cef08cf9-7b4f-4429-9624-2a690a933201")]
    public partial class File : SlimDX2.ComObject {
        public File(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Creates an enumerator object that will read a .x file.	
        /// </summary>	
        /// <remarks>	
        ///  After using this method, use one of the <see cref="SlimDX2.Direct3D9.FileEnumObject"/> methods to retrieve a data object. 	
        /// </remarks>	
        /// <param name="arg0"> The data source. Either:  A file name A {{D3DXF_FILELOADMEMORY}} structure A {{D3DXF_FILELOADRESOURCE}} structure   Depending on the value of loadflags. </param>
        /// <param name="arg1"> Value that specifies the source of the data. This value can be one of the {{D3DXF_FILELOADOPTIONS}} flags. </param>
        /// <param name="arg2"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.FileEnumObject"/> interface, representing the created enumerator object.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADVALUE, D3DXFERR_PARSEERROR. </returns>
        /// <unmanaged>HRESULT ID3DXFile::CreateEnumObject([None] LPCVOID arg0,[None] D3DXF_FILELOADOPTIONS arg1,[None] ID3DXFileEnumObject** arg2)</unmanaged>
        public SlimDX2.Result CreateEnumObject(IntPtr arg0, int arg1, out SlimDX2.Direct3D9.FileEnumObject arg2) {
            unsafe {
                IntPtr arg2_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, (void*)arg0, arg1, &arg2_);
                arg2 = (arg2_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileEnumObject(arg2_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a save object that will be used to save data to a .x file.	
        /// </summary>	
        /// <remarks>	
        ///  After using this method, use methods of the <see cref="SlimDX2.Direct3D9.FileSaveObject"/> interface to create data objects and to save templates or data. For the saved file format dwFileFormat, one of the binary, legacy binary, or text flags in {{File Formats}} must be specified. The file can be compressed by using the optional D3DXF_FILEFORMAT_COMPRESSED flag. The file format values can be combined in a logical OR to create compressed text or compressed binary files. If you indicate that the file format should be text and compressed, the file will be written out first as text and then compressed. However, compressed text files are not as efficient as binary text files; in most cases, therefore, you will want to indicate binary and compressed. 	
        /// </remarks>	
        /// <param name="arg0"> Pointer to the name of the file to use for saving data. </param>
        /// <param name="arg1"> Value that specifies the name of the file to which data is to be saved. This value can be one of the {{File Save Options}} flags. </param>
        /// <param name="arg2"> Indicates the format to use when saving the .x file. This value can be one of the {{File Formats}} flags. For more information, see Remarks. </param>
        /// <param name="arg3"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.FileSaveObject"/> interface, representing the created save object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADVALUE, D3DXFERR_PARSEERROR. </returns>
        /// <unmanaged>HRESULT ID3DXFile::CreateSaveObject([None] LPCVOID arg0,[None] D3DXF_FILESAVEOPTIONS arg1,[None] D3DXF_FILEFORMAT arg2,[None] ID3DXFileSaveObject** arg3)</unmanaged>
        public SlimDX2.Result CreateSaveObject(IntPtr arg0, int arg1, int arg2, out SlimDX2.Direct3D9.FileSaveObject arg3) {
            unsafe {
                IntPtr arg3_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)arg0, arg1, arg2, &arg3_);
                arg3 = (arg3_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileSaveObject(arg3_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Registers custom templates.	
        /// </summary>	
        /// <remarks>	
        ///  The following code fragment provides an example call to RegisterTemplates And example contents for the buffer to which pvData points. 	
        /// <code> #define XSKINEXP_TEMPLATES \ "xof 0303txt 0032\ template XSkinMeshHeader \ { \ &lt;3CF169CE-FF7C-44ab-93C0-F78F62D172E2&gt; \ WORD nMaxSkinWeightsPerVertex; \ WORD nMaxSkinWeightsPerFace; \ WORD nBones; \ } \ template VertexDuplicationIndices \ { \ &lt;B8D65549-D7C9-4995-89CF-53A9A8B031E3&gt; \ DWORD nIndices; \ DWORD nOriginalVertices; \ array DWORD indices[nIndices]; \ } \ template SkinWeights \ { \ &lt;6F0D123B-BAD2-4167-A0D0-80224F25FABB&gt; \ STRING transformNodeName;\ DWORD nWeights; \ array DWORD vertexIndices[nWeights]; \ array float weights[nWeights]; \ Matrix4x4 matrixOffset; \ }"	
        /// .	
        /// .	
        /// . LPD3DXFILE pD3DXFile = NULL; if ( FAILED  (hr = pD3DXFile-&gt;RegisterTemplates(  (LPVOID)XSKINEXP_TEMPLATES, sizeof( XSKINEXP_TEMPLATES ) - 1 ) ) )	
        /// goto End; </code>	
        /// 	
        ///  All templates must specify a name and a UUID. This method calls the {{RegisterEnumTemplates}} method, obtaining an <see cref="SlimDX2.Direct3D9.FileEnumObject"/> interface pointer by calling {{CreateEnumObject}} with pvData as the first parameter. 	
        /// </remarks>	
        /// <param name="arg0"> Pointer to a buffer consisting of a .x file in text or binary format that contains templates. </param>
        /// <param name="arg1"> Size of the buffer pointed to by pvData, in bytes. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADVALUE, D3DXFERR_PARSEERROR. </returns>
        /// <unmanaged>HRESULT ID3DXFile::RegisterTemplates([None] LPCVOID arg0,[None] SIZE_T arg1)</unmanaged>
        public SlimDX2.Result RegisterTemplates(IntPtr arg0, SlimDX2.Size arg1) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)arg0, (void*)arg1);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Registers custom templates, given an <see cref="SlimDX2.Direct3D9.FileEnumObject"/> enumeration object.	
        /// </summary>	
        /// <remarks>	
        ///  When this method is called, it copies templates stored with the ID3DXFileEnumObject, representing the file, to the local template store of the <see cref="SlimDX2.Direct3D9.File"/> object. If an <see cref="SlimDX2.Direct3D9.FileEnumObject"/> pointer is not available, call the {{RegisterTemplates}} method instead. 	
        /// </remarks>	
        /// <param name="arg0"> Pointer to an <see cref="SlimDX2.Direct3D9.FileEnumObject"/> enumeration object that contains templates. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK . If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT ID3DXFile::RegisterEnumTemplates([None] ID3DXFileEnumObject* arg0)</unmanaged>
        public SlimDX2.Result RegisterEnumTemplates(SlimDX2.Direct3D9.FileEnumObject arg0) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)((arg0 == null)?IntPtr.Zero:arg0.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXFileSaveObject</unmanaged>
    [Guid("cef08cfa-7b4f-4429-9624-2a690a933201")]
    public partial class FileSaveObject : SlimDX2.ComObject {
        public FileSaveObject(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the <see cref="SlimDX2.Direct3D9.File"/> interface of the object that created this <see cref="SlimDX2.Direct3D9.FileSaveObject"/> object.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXFileSaveObject::GetFile([Out] ID3DXFile** arg0)</unmanaged>
        public SlimDX2.Direct3D9.File File {
                get { SlimDX2.Direct3D9.File __output__; GetFile(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the <see cref="SlimDX2.Direct3D9.File"/> interface of the object that created this <see cref="SlimDX2.Direct3D9.FileSaveObject"/> object.	
        /// </summary>	
        /// <param name="arg0"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.File"/> object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADVALUE, E_NOINTERFACE, E_POINTER. </returns>
        /// <unmanaged>HRESULT ID3DXFileSaveObject::GetFile([Out] ID3DXFile** arg0)</unmanaged>
        internal SlimDX2.Result GetFile(out SlimDX2.Direct3D9.File arg0) {
            unsafe {
                IntPtr arg0_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &arg0_);
                arg0 = (arg0_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.File(arg0_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds a data object as a child of the <see cref="SlimDX2.Direct3D9.FileSaveData"/> object.	
        /// </summary>	
        /// <remarks>	
        ///  If a data reference object will reference the data object, either the szName or pId parameter must be non-NULL. Save the created data to disk by using the <see cref="SlimDX2.Direct3D9.FileSaveObject.Save"/> method. 	
        /// </remarks>	
        /// <param name="arg0"> GUID representing the data object's template. </param>
        /// <param name="arg1"> Pointer to the name of the data object. Specify NULL if the object does not have a name. </param>
        /// <param name="arg2"> Pointer to a GUID representing the data object. Specify NULL if the object does not have a GUID. </param>
        /// <param name="arg3"> Size of the data object, in bytes. </param>
        /// <param name="arg4"> Pointer to a buffer containing all required data in the data object. </param>
        /// <param name="arg5"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.FileSaveData"/> interface, representing the file data node to which the data object will be added. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADOBJECT, DXFILEERR_BADVALUE, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXFileSaveObject::AddDataObject([None] REFGUID arg0,[None] const char* arg1,[None] const GUID* arg2,[None] SIZE_T arg3,[None] LPCVOID arg4,[None] ID3DXFileSaveData** arg5)</unmanaged>
        public SlimDX2.Result AddDataObject(Guid arg0, string arg1, ref Guid arg2, SlimDX2.Size arg3, IntPtr arg4, out SlimDX2.Direct3D9.FileSaveData arg5) {
            unsafe {
                IntPtr arg1_ = Marshal.StringToHGlobalAnsi(arg1);
                IntPtr arg5_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* arg2_ = &arg2)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, &arg0, (void*)arg1_, arg2_, (void*)arg3, (void*)arg4, &arg5_);
                Marshal.FreeHGlobal(arg1_ );
                arg5 = (arg5_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileSaveData(arg5_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Saves a data object and its children to a .x file on disk.	
        /// </summary>	
        /// <remarks>	
        ///  After this method succeeds, <see cref="SlimDX2.Direct3D9.FileSaveObject.AddDataObject"/>, <see cref="SlimDX2.Direct3D9.FileSaveData.AddDataObject"/> and <see cref="SlimDX2.Direct3D9.FileSaveData.AddDataReference"/> can no longer be called until a new <see cref="SlimDX2.Direct3D9.File"/> object is created. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be the following: D3DXFERR_BADOBJECT. </returns>
        /// <unmanaged>HRESULT ID3DXFileSaveObject::Save()</unmanaged>
        public SlimDX2.Result Save() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXFileSaveData</unmanaged>
    [Guid("cef08cfb-7b4f-4429-9624-2a690a933201")]
    public partial class FileSaveData : SlimDX2.ComObject {
        public FileSaveData(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves a pointer to this <see cref="SlimDX2.Direct3D9.FileSaveObject"/> file data node.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXFileSaveData::GetSave([Out] ID3DXFileSaveObject** arg0)</unmanaged>
        public SlimDX2.Direct3D9.FileSaveObject Save {
                get { SlimDX2.Direct3D9.FileSaveObject __output__; GetSave(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the template ID of this file data node.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXFileSaveData::GetType([Out] GUID* arg0)</unmanaged>
        public Guid TypeInfo {
                get { Guid __output__; GetTypeInfo(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves a pointer to this <see cref="SlimDX2.Direct3D9.FileSaveObject"/> file data node.	
        /// </summary>	
        /// <param name="arg0"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.FileSaveObject"/> interface representing this file data node. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT ID3DXFileSaveData::GetSave([Out] ID3DXFileSaveObject** arg0)</unmanaged>
        internal SlimDX2.Result GetSave(out SlimDX2.Direct3D9.FileSaveObject arg0) {
            unsafe {
                IntPtr arg0_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &arg0_);
                arg0 = (arg0_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileSaveObject(arg0_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the name of this <see cref="SlimDX2.Direct3D9.FileSaveData"/> file data node.	
        /// </summary>	
        /// <remarks>	
        ///  For this method to succeed, either szName or puiSize must be non-NULL. 	
        /// </remarks>	
        /// <param name="arg0"> Address of a pointer to receive the name of this file data node. If this parameter is NULL, then puiSize will return the size of the string. If szName points to valid memory, the name of this file data node will be copied into szName up to the number of characters given by puiSize .  </param>
        /// <param name="arg1"> Pointer to the size of the string that represents the name of this file data node. This parameter can be NULL if szName provides a reference to the name. This parameter will return the size of the string if szName is NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT ID3DXFileSaveData::GetName([None] LPSTR arg0,[Out] SIZE_T* arg1)</unmanaged>
        public SlimDX2.Result GetName(string arg0, out SlimDX2.Size arg1) {
            unsafe {
                IntPtr arg0_ = Marshal.StringToHGlobalAnsi(arg0);
                SlimDX2.Result __result__;
                fixed (void* arg1_ = &arg1)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)arg0_, arg1_);
                Marshal.FreeHGlobal(arg0_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the GUID of this <see cref="SlimDX2.Direct3D9.FileSaveData"/> file data node.	
        /// </summary>	
        /// <param name="arg0"> Pointer to a GUID to receive the ID of this file data node. If the object has no ID, the returned parameter value will be GUID_NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT ID3DXFileSaveData::GetId([None] LPGUID arg0)</unmanaged>
        public SlimDX2.Result GetId(Guid arg0) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, &arg0);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the template ID of this file data node.	
        /// </summary>	
        /// <param name="arg0"> Pointer to the GUID representing the template in this file data node. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADOBJECT, D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT ID3DXFileSaveData::GetType([Out] GUID* arg0)</unmanaged>
        internal SlimDX2.Result GetTypeInfo(out Guid arg0) {
            unsafe {
                arg0 = new Guid();
                SlimDX2.Result __result__;
                fixed (void* arg0_ = &arg0)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, arg0_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds a data object as a child of the <see cref="SlimDX2.Direct3D9.FileSaveData"/> file data node.	
        /// </summary>	
        /// <param name="arg0"> GUID representing the data object's template. </param>
        /// <param name="arg1"> Pointer to the name of the data object to add. Specify NULL if the object does not have a name. </param>
        /// <param name="arg2"> Pointer to a GUID representing the data object. The data object must have been registered with <see cref="SlimDX2.Direct3D9.File.RegisterTemplates"/> or <see cref="SlimDX2.Direct3D9.File.RegisterEnumTemplates"/>. Specify NULL if the object does not have a GUID. </param>
        /// <param name="arg3"> Size of the data object, in bytes. </param>
        /// <param name="arg4"> Pointer to a buffer containing all required data in the data object. </param>
        /// <param name="arg5"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.FileSaveData"/> interface, representing the file data node to which the data object will be added. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADOBJECT, D3DXFERR_BADVALUE, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXFileSaveData::AddDataObject([None] REFGUID arg0,[None] const char* arg1,[None] const GUID* arg2,[None] SIZE_T arg3,[None] LPCVOID arg4,[None] ID3DXFileSaveData** arg5)</unmanaged>
        public SlimDX2.Result AddDataObject(Guid arg0, string arg1, ref Guid arg2, SlimDX2.Size arg3, IntPtr arg4, out SlimDX2.Direct3D9.FileSaveData arg5) {
            unsafe {
                IntPtr arg1_ = Marshal.StringToHGlobalAnsi(arg1);
                IntPtr arg5_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* arg2_ = &arg2)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, &arg0, (void*)arg1_, arg2_, (void*)arg3, (void*)arg4, &arg5_);
                Marshal.FreeHGlobal(arg1_ );
                arg5 = (arg5_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileSaveData(arg5_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds a data reference as a child of this <see cref="SlimDX2.Direct3D9.FileSaveData"/> file data node. The data reference points to a file data object.	
        /// </summary>	
        /// <remarks>	
        ///  The file data object being referenced must have either a name or a GUID. The file data object must also derive from a different parent <see cref="SlimDX2.Direct3D9.FileSaveData"/> object. 	
        /// </remarks>	
        /// <param name="arg0"> Pointer to the name of the data object to add by reference. Specify NULL if the data object does not have a name. </param>
        /// <param name="arg1"> Pointer to a GUID representing the data object to add by reference. If NULL, a reference will be added that points to the data object with the name given by szName. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADOBJECT, D3DXFERR_BADVALUE, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXFileSaveData::AddDataReference([None] const char* arg0,[None] const GUID* arg1)</unmanaged>
        public SlimDX2.Result AddDataReference(string arg0, ref Guid arg1) {
            unsafe {
                IntPtr arg0_ = Marshal.StringToHGlobalAnsi(arg0);
                SlimDX2.Result __result__;
                fixed (void* arg1_ = &arg1)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, (void*)arg0_, arg1_);
                Marshal.FreeHGlobal(arg0_ );
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXFileEnumObject</unmanaged>
    [Guid("cef08cfc-7b4f-4429-9624-2a690a933201")]
    public partial class FileEnumObject : SlimDX2.ComObject {
        public FileEnumObject(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the <see cref="SlimDX2.Direct3D9.File"/> object.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXFileEnumObject::GetFile([Out] ID3DXFile** arg0)</unmanaged>
        public SlimDX2.Direct3D9.File File {
                get { SlimDX2.Direct3D9.File __output__; GetFile(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the number of child objects in this file data object.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXFileEnumObject::GetChildren([Out] SIZE_T* arg0)</unmanaged>
        public SlimDX2.Size Children {
                get { SlimDX2.Size __output__; GetChildren(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the <see cref="SlimDX2.Direct3D9.File"/> object.	
        /// </summary>	
        /// <param name="arg0"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.File"/> interface, representing the returned object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT ID3DXFileEnumObject::GetFile([Out] ID3DXFile** arg0)</unmanaged>
        internal SlimDX2.Result GetFile(out SlimDX2.Direct3D9.File arg0) {
            unsafe {
                IntPtr arg0_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &arg0_);
                arg0 = (arg0_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.File(arg0_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of child objects in this file data object.	
        /// </summary>	
        /// <param name="arg0"> Address of a pointer to receive the number of child objects in this file data object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT ID3DXFileEnumObject::GetChildren([Out] SIZE_T* arg0)</unmanaged>
        internal SlimDX2.Result GetChildren(out SlimDX2.Size arg0) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* arg0_ = &arg0)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, arg0_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a child object in this file data object.	
        /// </summary>	
        /// <param name="arg0"> ID of the child object to retrieve. </param>
        /// <param name="arg1"> Address of a pointer to receive the child object's interface pointer. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADVALUE, D3DXFERR_NOMOREOBJECTS. </returns>
        /// <unmanaged>HRESULT ID3DXFileEnumObject::GetChild([None] SIZE_T arg0,[Out] ID3DXFileData** arg1)</unmanaged>
        public SlimDX2.Result GetChild(SlimDX2.Size arg0, out SlimDX2.Direct3D9.FileData arg1) {
            unsafe {
                IntPtr arg1_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)arg0, &arg1_);
                arg1 = (arg1_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileData(arg1_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the data object that has the specified GUID.	
        /// </summary>	
        /// <remarks>	
        ///  Obtain the GUID rguid of the current file data object with the <see cref="SlimDX2.Direct3D9.FileData.GetId"/> method. 	
        /// </remarks>	
        /// <param name="arg0"> Reference to the requested GUID.  </param>
        /// <param name="arg1"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.FileData"/> interface, representing the returned file data object.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following:DXFILEERR_BADVALUE, DXFILEERR_NOTFOUND. </returns>
        /// <unmanaged>HRESULT ID3DXFileEnumObject::GetDataObjectById([None] REFGUID arg0,[Out] ID3DXFileData** arg1)</unmanaged>
        public SlimDX2.Result GetDataObjectById(Guid arg0, out SlimDX2.Direct3D9.FileData arg1) {
            unsafe {
                IntPtr arg1_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, &arg0, &arg1_);
                arg1 = (arg1_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileData(arg1_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the data object that has the specified name.	
        /// </summary>	
        /// <remarks>	
        ///  Obtain the name szName of the current file data object with the <see cref="SlimDX2.Direct3D9.FileData.GetName"/> method. 	
        /// </remarks>	
        /// <param name="arg0"> Pointer to the requested name.  </param>
        /// <param name="arg1"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.FileData"/> interface, representing the returned file data object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following:DXFILEERR_BADVALUE, DXFILEERR_NOTFOUND. </returns>
        /// <unmanaged>HRESULT ID3DXFileEnumObject::GetDataObjectByName([Out] const char* arg0,[Out] ID3DXFileData** arg1)</unmanaged>
        public SlimDX2.Result GetDataObjectByName(IntPtr arg0, out SlimDX2.Direct3D9.FileData arg1) {
            unsafe {
                IntPtr arg1_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)arg0, &arg1_);
                arg1 = (arg1_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileData(arg1_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXFileData</unmanaged>
    [Guid("cef08cfd-7b4f-4429-9624-2a690a933201")]
    public partial class FileData : SlimDX2.ComObject {
        public FileData(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the enumeration object in this file data object.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXFileData::GetEnum([Out] ID3DXFileEnumObject** arg0)</unmanaged>
        public SlimDX2.Direct3D9.FileEnumObject Enum {
                get { SlimDX2.Direct3D9.FileEnumObject __output__; GetEnum(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the template ID in this file data object.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXFileData::GetType([Out] GUID* arg0)</unmanaged>
        public Guid TypeInfo {
                get { Guid __output__; GetTypeInfo(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Indicates whether this file data object is a reference object that points to another child data object.	
        /// </summary>	
        /// <unmanaged>BOOL ID3DXFileData::IsReference()</unmanaged>
        public bool IsReference {
                get { return IsReference_(); }
        }
        
        /// <summary>	
        /// Retrieves the number of children in this file data object.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXFileData::GetChildren([Out] SIZE_T* arg0)</unmanaged>
        public SlimDX2.Size Children {
                get { SlimDX2.Size __output__; GetChildren(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the enumeration object in this file data object.	
        /// </summary>	
        /// <param name="arg0"> Address of a pointer to receive the enumeration object in this file data object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT ID3DXFileData::GetEnum([Out] ID3DXFileEnumObject** arg0)</unmanaged>
        internal SlimDX2.Result GetEnum(out SlimDX2.Direct3D9.FileEnumObject arg0) {
            unsafe {
                IntPtr arg0_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &arg0_);
                arg0 = (arg0_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileEnumObject(arg0_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the name of this file data object.	
        /// </summary>	
        /// <remarks>	
        ///  For this method to succeed, either szName or puiSize must be non-NULL. 	
        /// </remarks>	
        /// <param name="arg0"> Address of a pointer to receive the name of this file data object. If this parameter is NULL, then puiSize will return the size of the string. If szName points to valid memory, the name of this file data object will be copied into szName up to the number of characters given by puiSize.  </param>
        /// <param name="arg1"> Pointer to the size of the string that represents the name of this file data object. This parameter can be NULL if szName provides a reference to the name. This parameter will return the size of the string if szName is NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT ID3DXFileData::GetName([None] LPSTR arg0,[Out] SIZE_T* arg1)</unmanaged>
        public SlimDX2.Result GetName(string arg0, out SlimDX2.Size arg1) {
            unsafe {
                IntPtr arg0_ = Marshal.StringToHGlobalAnsi(arg0);
                SlimDX2.Result __result__;
                fixed (void* arg1_ = &arg1)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)arg0_, arg1_);
                Marshal.FreeHGlobal(arg0_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the GUID of this file data object.	
        /// </summary>	
        /// <param name="arg0"> Pointer to a GUID to receive the ID of this file data object. If the file data object has no ID, the returned parameter value will be GUID_NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT ID3DXFileData::GetId([None] LPGUID arg0)</unmanaged>
        public SlimDX2.Result GetId(Guid arg0) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, &arg0);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Accesses the .x file data.	
        /// </summary>	
        /// <remarks>	
        ///  The ppData pointer is only valid during a ID3DXFileData::Lock ... <see cref="SlimDX2.Direct3D9.FileData.Unlock"/> sequence. You can make multiple lock calls. However, you must ensure that the number of lock calls matches the number of unlock calls. Because file data is not guaranteed to be aligned properly with byte boundaries, you should access ppData with UNALIGNED pointers. Returned parameter values are not guaranteed to be valid due to possible file corruption; therefore, your code should verify the returned parameter values. 	
        /// </remarks>	
        /// <param name="arg0"> Pointer to the size of the .x file data. </param>
        /// <param name="arg1"> Address of a pointer to receive the <see cref="SlimDX2.Direct3D9.FileData"/> file data object's interface pointer. See Remarks. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT ID3DXFileData::Lock([None] SIZE_T* arg0,[None] LPCVOID* arg1)</unmanaged>
        public SlimDX2.Result Lock(SlimDX2.Size arg0, IntPtr arg1) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)arg0, (void*)arg1);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Ends the lifespan of the ppData pointer returned by <see cref="SlimDX2.Direct3D9.FileData.Lock"/>.	
        /// </summary>	
        /// <remarks>	
        ///  You must ensure that the number of <see cref="SlimDX2.Direct3D9.FileData.Lock"/> calls matches the number of ID3DXFileData::Unlock calls. After calling Unlock, the ppData pointer returned by ID3DXFileData::Lock should no longer be used. 	
        /// </remarks>	
        /// <returns>  {{BOOL}}  The return value is S_OK. </returns>
        /// <unmanaged>HRESULT ID3DXFileData::Unlock()</unmanaged>
        public SlimDX2.Result Unlock() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the template ID in this file data object.	
        /// </summary>	
        /// <param name="arg0"> Pointer to the GUID representing the template in this file data object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT ID3DXFileData::GetType([Out] GUID* arg0)</unmanaged>
        internal SlimDX2.Result GetTypeInfo(out Guid arg0) {
            unsafe {
                arg0 = new Guid();
                SlimDX2.Result __result__;
                fixed (void* arg0_ = &arg0)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, arg0_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Indicates whether this file data object is a reference object that points to another child data object.	
        /// </summary>	
        /// <returns>  {{BOOL}}  Returns TRUE if the file data object is a reference object; returns FALSE otherwise. </returns>
        /// <unmanaged>BOOL ID3DXFileData::IsReference()</unmanaged>
        internal bool IsReference_() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of children in this file data object.	
        /// </summary>	
        /// <param name="arg0"> Address of a pointer to receive the number of children in this file data object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT ID3DXFileData::GetChildren([Out] SIZE_T* arg0)</unmanaged>
        internal SlimDX2.Result GetChildren(out SlimDX2.Size arg0) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* arg0_ = &arg0)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, arg0_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a child object in this file data object.	
        /// </summary>	
        /// <param name="arg0"> ID of the child object to retrieve. </param>
        /// <param name="arg1"> Address of a pointer to receive the child object's interface pointer. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following values: D3DXFERR_BADVALUE, D3DXFERR_NOMOREOBJECTS. </returns>
        /// <unmanaged>HRESULT ID3DXFileData::GetChild([None] SIZE_T arg0,[Out] ID3DXFileData** arg1)</unmanaged>
        public SlimDX2.Result GetChild(SlimDX2.Size arg0, out SlimDX2.Direct3D9.FileData arg1) {
            unsafe {
                IntPtr arg1_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, (void*)arg0, &arg1_);
                arg1 = (arg1_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileData(arg1_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXBaseMesh</unmanaged>
    [Guid("7ed943dd-52e8-40b5-a8d8-76685c406330")]
    public partial class BaseMesh : SlimDX2.ComObject {
        public BaseMesh(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the number of faces in the mesh.	
        /// </summary>	
        /// <unmanaged>int ID3DXBaseMesh::GetNumFaces()</unmanaged>
        public int NumFaces {
                get { return GetNumFaces(); }
        }
        
        /// <summary>	
        /// Retrieves the number of vertices in the mesh.	
        /// </summary>	
        /// <unmanaged>int ID3DXBaseMesh::GetNumVertices()</unmanaged>
        public int NumVertices {
                get { return GetNumVertices(); }
        }
        
        /// <summary>	
        /// Gets the fixed function vertex value.	
        /// </summary>	
        /// <remarks>	
        ///  This method can return 0 if the vertex format cannot be mapped directly to an FVF code.  This will occur for a mesh created from a vertex declaration that doesn't have the same order and elements supported by the FVF codes. 	
        /// </remarks>	
        /// <unmanaged>int ID3DXBaseMesh::GetFVF()</unmanaged>
        public int FVF {
                get { return GetFVF(); }
        }
        
        /// <summary>	
        /// Gets the number of bytes per vertex.	
        /// </summary>	
        /// <unmanaged>int ID3DXBaseMesh::GetNumBytesPerVertex()</unmanaged>
        public int NumBytesPerVertex {
                get { return GetNumBytesPerVertex(); }
        }
        
        /// <summary>	
        /// Retrieves the mesh options enabled for this mesh at creation time.	
        /// </summary>	
        /// <unmanaged>int ID3DXBaseMesh::GetOptions()</unmanaged>
        public int Options {
                get { return GetOptions(); }
        }
        
        /// <summary>	
        /// Retrieves the device associated with the mesh.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Be sure to call <see cref="SlimDX2.ComObject"/> when you are done using this IDirect3DDevice9 interface or you will have a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the vertex buffer associated with the mesh.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::GetVertexBuffer([Out] LPDIRECT3DVERTEXBUFFER9* ppVB)</unmanaged>
        public SlimDX2.Direct3D9.VertexBuffer VertexBuffer {
                get { SlimDX2.Direct3D9.VertexBuffer __output__; GetVertexBuffer(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the data in an index buffer.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::GetIndexBuffer([Out] LPDIRECT3DINDEXBUFFER9* ppIB)</unmanaged>
        public SlimDX2.Direct3D9.IndexBuffer IndexBuffer {
                get { SlimDX2.Direct3D9.IndexBuffer __output__; GetIndexBuffer(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Draws a subset of a mesh.	
        /// </summary>	
        /// <remarks>	
        ///  The subset that is specified by AttribId will be rendered by the <see cref="SlimDX2.Direct3D9.Device.DrawIndexedPrimitive"/> method, using the D3DPT_TRIANGLELIST primitive type, so an index buffer must be properly initialized. An attribute table is used to identify areas of the mesh that need to be drawn with different textures, render states, materials, and so on. In addition, the application can use the attribute table to hide portions of a mesh by not drawing a given attribute identifier (AttribId) when drawing the frame. 	
        /// </remarks>	
        /// <param name="attribId">  DWORD that specifies which subset of the mesh to draw. This value is used to differentiate faces in a mesh as belonging to one or more attribute groups. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseMesh::DrawSubset([None] int AttribId)</unmanaged>
        public SlimDX2.Result DrawSubset(int attribId) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, attribId);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of faces in the mesh.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns the number of faces in the mesh. </returns>
        /// <unmanaged>int ID3DXBaseMesh::GetNumFaces()</unmanaged>
        internal int GetNumFaces() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of vertices in the mesh.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns the number of vertices in the mesh. </returns>
        /// <unmanaged>int ID3DXBaseMesh::GetNumVertices()</unmanaged>
        internal int GetNumVertices() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the fixed function vertex value.	
        /// </summary>	
        /// <remarks>	
        ///  This method can return 0 if the vertex format cannot be mapped directly to an FVF code.  This will occur for a mesh created from a vertex declaration that doesn't have the same order and elements supported by the FVF codes. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  Returns the flexible vertex format (FVF) codes. </returns>
        /// <unmanaged>int ID3DXBaseMesh::GetFVF()</unmanaged>
        internal int GetFVF() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a declaration describing the vertices in the mesh.	
        /// </summary>	
        /// <remarks>	
        ///  The array of elements includes the {{D3DDECL_END}} macro, which ends the declaration. 	
        /// </remarks>	
        /// <param name="declaration"> Array of <see cref="SlimDX2.Direct3D9.VertexElement"/> elements describing the vertex format of the mesh vertices. The upper limit of this declarator array is {{MAX_FVF_DECL_SIZE}}. The vertex element array ends with the {{D3DDECL_END}} macro.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseMesh::GetDeclaration([None] D3DVERTEXELEMENT9 Declaration[65])</unmanaged>
        public SlimDX2.Result GetDeclaration(SlimDX2.Direct3D9.VertexElement[] declaration) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* declaration_ = &declaration[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, declaration_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of bytes per vertex.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns the number of bytes per vertex. </returns>
        /// <unmanaged>int ID3DXBaseMesh::GetNumBytesPerVertex()</unmanaged>
        internal int GetNumBytesPerVertex() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the mesh options enabled for this mesh at creation time.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns a combination of one or more of the following flags, indicating the options enabled for this mesh at creation time.  ValueDescription D3DXMESH_32BITUse 32-bit indices. D3DXMESH_DONOTCLIPUse the D3DUSAGE_DONOTCLIP usage flag for vertex and index buffers. D3DXMESH_DYNAMICEquivalent to specifying both D3DXMESH_VB_DYNAMIC and D3DXMESH_IB_DYNAMIC. D3DXMESH_RTPATCHESUse the D3DUSAGE_RTPATCHES usage flag for vertex and index buffers. D3DXMESH_NPATCHESSpecifying this flag causes the vertex and index buffer of the mesh to be created with D3DUSAGE_NPATCHES flag. This is required if the mesh object is to be rendered using N-Patch enhancement. D3DXMESH_MANAGEDEquivalent to specifying both D3DXMESH_VB_MANAGED and D3DXMESH_IB_MANAGED. D3DXMESH_POINTSUse the D3DUSAGE_POINTS usage flag for vertex and index buffers. D3DXMESH_IB_DYNAMICUse the D3DUSAGE_DYNAMIC usage flag for index buffers. D3DXMESH_IB_MANAGEDUse the D3DPOOL_MANAGED memory class for index buffers. D3DXMESH_IB_SYSTEMMEMUse the D3DPOOL_SYSTEMMEM memory class for index buffers. D3DXMESH_IB_WRITEONLYUse the D3DUSAGE_WRITEONLY usage flag for index buffers. D3DXMESH_SYSTEMMEMEquivalent to specifying both D3DXMESH_VB_SYSTEMMEM and D3DXMESH_IB_SYSTEMMEM. D3DXMESH_VB_DYNAMICUse the D3DUSAGE_DYNAMIC usage flag for vertex buffers. D3DXMESH_VB_MANAGEDUse the D3DPOOL_MANAGED memory class for vertex buffers. D3DXMESH_VB_SYSTEMMEMUse the D3DPOOL_SYSTEMMEM memory class for vertex buffers. D3DXMESH_VB_WRITEONLYUse the D3DUSAGE_WRITEONLY usage flag for vertex buffers. D3DXMESH_WRITEONLYEquivalent to specifying both D3DXMESH_VB_WRITEONLY and D3DXMESH_IB_WRITEONLY.  ? </returns>
        /// <unmanaged>int ID3DXBaseMesh::GetOptions()</unmanaged>
        internal int GetOptions() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the device associated with the mesh.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Be sure to call <see cref="SlimDX2.ComObject"/> when you are done using this IDirect3DDevice9 interface or you will have a memory leak. 	
        /// </remarks>	
        /// <param name="deviceRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the Direct3D device object associated with the mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseMesh::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Clones a mesh using a flexible vertex format (FVF) code.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXBaseMesh::CloneMeshFVF is used to reformat and change the vertex data layout. This is done by creating a new mesh object. For example, use it to to add space for normals, texture coordinates, colors, weights, etc. that were not present before.   <see cref="SlimDX2.Direct3D9.BaseMesh.UpdateSemantics"/> updates the vertex declaration with different semantic information without changing the layout of the vertex buffer. This method does not modify the contents of the vertex buffer. For example, use it to relabel a 3D texture coordinate as a binormal or tangent or vice versa. 	
        /// </remarks>	
        /// <param name="options"> A combination of one or more {{D3DXMESH}} flags specifying creation options for the mesh. </param>
        /// <param name="fvf"> Combination of FVF codes, which specifies the vertex format for the vertices in the output mesh. For the values of the codes, see <see cref="SlimDX2.Direct3D9.VertexFormat"/>. </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface representing the device object associated with the mesh. </param>
        /// <param name="cloneMeshRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the cloned mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXBaseMesh::CloneMeshFVF([None] int Options,[None] int FVF,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXMESH* ppCloneMesh)</unmanaged>
        public SlimDX2.Result CloneMeshFVF(int options, int fvf, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.Mesh cloneMeshRef) {
            unsafe {
                IntPtr cloneMeshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, options, fvf, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), &cloneMeshRef_);
                cloneMeshRef = (cloneMeshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(cloneMeshRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Clones a mesh using a declarator.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXBaseMesh::CloneMesh is used to reformat and change the vertex data layout. This is done by creating a new mesh object. For example, use it to add space for normals, texture coordinates, colors, weights, etc. that were not present before.   <see cref="SlimDX2.Direct3D9.BaseMesh.UpdateSemantics"/> updates the vertex declaration with different semantic information without changing the layout of the vertex buffer. This method does not modify the contents of the vertex buffer. For example, use it to relabel a 3D texture coordinate as a binormal or tangent or vice versa. 	
        /// </remarks>	
        /// <param name="options"> A combination of one or more {{D3DXMESH}} flags specifying creation options for the mesh. </param>
        /// <param name="declarationRef"> An array of <see cref="SlimDX2.Direct3D9.VertexElement"/> elements, which specify the vertex format for the vertices in the output mesh. </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device object associated with the mesh. </param>
        /// <param name="cloneMeshRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the cloned mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXBaseMesh::CloneMesh([None] int Options,[None] const D3DVERTEXELEMENT9* pDeclaration,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXMESH* ppCloneMesh)</unmanaged>
        public SlimDX2.Result CloneMesh(int options, ref SlimDX2.Direct3D9.VertexElement declarationRef, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.Mesh cloneMeshRef) {
            unsafe {
                IntPtr cloneMeshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* declarationRef_ = &declarationRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, options, declarationRef_, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), &cloneMeshRef_);
                cloneMeshRef = (cloneMeshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(cloneMeshRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the vertex buffer associated with the mesh.	
        /// </summary>	
        /// <param name="vBRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VertexBuffer"/> interface, representing the vertex buffer object associated with the mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseMesh::GetVertexBuffer([Out] LPDIRECT3DVERTEXBUFFER9* ppVB)</unmanaged>
        internal SlimDX2.Result GetVertexBuffer(out SlimDX2.Direct3D9.VertexBuffer vBRef) {
            unsafe {
                IntPtr vBRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, &vBRef_);
                vBRef = (vBRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexBuffer(vBRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the data in an index buffer.	
        /// </summary>	
        /// <param name="iBRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.IndexBuffer"/> interface, representing the index buffer object associated with the mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseMesh::GetIndexBuffer([Out] LPDIRECT3DINDEXBUFFER9* ppIB)</unmanaged>
        internal SlimDX2.Result GetIndexBuffer(out SlimDX2.Direct3D9.IndexBuffer iBRef) {
            unsafe {
                IntPtr iBRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, &iBRef_);
                iBRef = (iBRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.IndexBuffer(iBRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Locks a vertex buffer and obtains a pointer to the vertex buffer memory.	
        /// </summary>	
        /// <remarks>	
        ///  When working with vertex buffers, you are allowed to make multiple lock calls; however, you must ensure that the number of lock calls match the number of unlock calls. DrawPrimitive calls will not succeed with any outstanding lock count on any currently set vertex buffer. 	
        /// </remarks>	
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY D3DLOCK_NOOVERWRITE  For a description of the flags, see <see cref="SlimDX2.Direct3D9.LockFlags"/>. </param>
        /// <param name="dataRef"> VOID* pointer to a buffer containing the vertex data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseMesh::LockVertexBuffer([None] int Flags,[None] void** ppData)</unmanaged>
        public SlimDX2.Result LockVertexBuffer(int flags, IntPtr dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, flags, (void*)dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks a vertex buffer.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseMesh::UnlockVertexBuffer()</unmanaged>
        public SlimDX2.Result UnlockVertexBuffer() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Locks an index buffer and obtains a pointer to the index buffer memory.	
        /// </summary>	
        /// <remarks>	
        ///  When working with index buffers, you are allowed to make multiple lock calls. However, you must ensure that the number of lock calls match the number of unlock calls. DrawPrimitive calls will not succeed with any outstanding lock count on any currently set index buffer. 	
        /// </remarks>	
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:   D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY  For a description of the flags, see <see cref="SlimDX2.Direct3D9.LockFlags"/>. </param>
        /// <param name="dataRef"> VOID* pointer to a buffer containing the index data. The count of indices in this buffer will be equal to <see cref="SlimDX2.Direct3D9.BaseMesh.GetNumFaces"/> * 3. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseMesh::LockIndexBuffer([None] int Flags,[None] void** ppData)</unmanaged>
        public SlimDX2.Result LockIndexBuffer(int flags, IntPtr dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, flags, (void*)dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks an index buffer.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseMesh::UnlockIndexBuffer()</unmanaged>
        public SlimDX2.Result UnlockIndexBuffer() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves either an attribute table for a mesh, or the number of entries stored in an attribute table for a mesh.	
        /// </summary>	
        /// <remarks>	
        ///  An attribute table is created by <see cref="SlimDX2.Direct3D9.Mesh.Optimize"/> and passing D3DXMESHOPT_ATTRSORT for the Flags parameter. An attribute table is used to identify areas of the mesh that need to be drawn with different textures, render states, materials, and so on. In addition, the application can use the attribute table to hide portions of a mesh by not drawing a given attribute identifier when drawing the frame. 	
        /// </remarks>	
        /// <param name="attribTableRef"> Pointer to an array of <see cref="SlimDX2.Direct3D9.AttributeRange"/> structures, representing the entries in the mesh's attribute table. Specify NULL to retrieve the value for pAttribTableSize. </param>
        /// <param name="attribTableSizeRef"> Pointer to either the number of entries stored in pAttribTable or a value to be filled in with the number of entries stored in the attribute table for the mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseMesh::GetAttributeTable([Out] D3DXATTRIBUTERANGE* pAttribTable,[Out] int* pAttribTableSize)</unmanaged>
        public SlimDX2.Result GetAttributeTable(out SlimDX2.Direct3D9.AttributeRange attribTableRef, out int attribTableSizeRef) {
            unsafe {
                attribTableRef = new SlimDX2.Direct3D9.AttributeRange();
                SlimDX2.Result __result__;
                fixed (void* attribTableRef_ = &attribTableRef)
                    fixed (void* attribTableSizeRef_ = &attribTableSizeRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, attribTableRef_, attribTableSizeRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Converts point representative data to mesh adjacency information.	
        /// </summary>	
        /// <param name="repRef"> Pointer to an array of one DWORD per vertex of the mesh that contains point representative data. This parameter is optional. Supplying a NULL value will cause this parameter to be interpreted as an "identity" array. </param>
        /// <param name="adjacencyRef"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh. The number of bytes in this array must be at least 3 * <see cref="SlimDX2.Direct3D9.BaseMesh.GetNumFaces"/> * sizeof(DWORD). </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXBaseMesh::ConvertPointRepsToAdjacency([None] const int* pPRep,[None] int* pAdjacency)</unmanaged>
        public SlimDX2.Result ConvertPointRepsToAdjacency(ref int repRef, ref int adjacencyRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* repRef_ = &repRef)
                    fixed (void* adjacencyRef_ = &adjacencyRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, repRef_, adjacencyRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Converts mesh adjacency information to an array of point representatives.	
        /// </summary>	
        /// <param name="adjacencyRef"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh. The number of bytes in this array must be at least 3 * <see cref="SlimDX2.Direct3D9.BaseMesh.GetNumFaces"/> * sizeof(DWORD). </param>
        /// <param name="repRef"> Pointer to an array of one DWORD per vertex of the mesh that will be filled with point representative data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXBaseMesh::ConvertAdjacencyToPointReps([None] const int* pAdjacency,[None] int* pPRep)</unmanaged>
        public SlimDX2.Result ConvertAdjacencyToPointReps(ref int adjacencyRef, ref int repRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* adjacencyRef_ = &adjacencyRef)
                    fixed (void* repRef_ = &repRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, adjacencyRef_, repRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Generate a list of mesh edges, as well as a list of faces that share each edge.	
        /// </summary>	
        /// <remarks>	
        ///  After an application generates adjacency information for a mesh, the mesh data can be optimized for better drawing performance. The order of the entries in the adjacency buffer is determined by the order of the vertex indices in the index buffer. The adjacent triangle 0 always corresponds to the edge between the indices of the corners 0 and 1. The adjacent triangle 1 always corresponds to the edge between the indices of the corners 1 and 2 while the adjacent triangle 2 corresponds to the edge between the indices of the corners 2 and 0. 	
        /// </remarks>	
        /// <param name="epsilon"> Specifies that vertices that differ in position by less than epsilon should be treated as coincident. </param>
        /// <param name="adjacencyRef"> Pointer to an array of three DWORDs per face to be filled with the indices of adjacent faces. The number of bytes in this array must be at least 3 * <see cref="SlimDX2.Direct3D9.BaseMesh.GetNumFaces"/> * sizeof(DWORD). </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXBaseMesh::GenerateAdjacency([None] FLOAT Epsilon,[None] int* pAdjacency)</unmanaged>
        public SlimDX2.Result GenerateAdjacency(float epsilon, ref int adjacencyRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* adjacencyRef_ = &adjacencyRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 22 * 4, epsilon, adjacencyRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// This method allows the user to change the mesh declaration without changing the data layout of the vertex buffer. The call is valid only if the old and new declaration formats have the same vertex size.	
        /// </summary>	
        /// <remarks>	
        ///   <see cref="SlimDX2.Direct3D9.BaseMesh.CloneMesh"/> is used to reformat and change the vertex data layout. For example, use it to to add space for normals, texture coordinates, colors, weights, etc. that were not present before. ID3DXBaseMesh::UpdateSemantics is a method for updating the vertex declaration with different semantic information, without changing the layout of the vertex buffer. For example, use it to relabel a 3D texture coordinate as a binormal or tangent, or vice versa. 	
        /// </remarks>	
        /// <param name="declaration"> An array of <see cref="SlimDX2.Direct3D9.VertexElement"/> elements, describing the vertex format of the mesh vertices. The upper limit of this declarator array is {{MAX_FVF_DECL_SIZE}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseMesh::UpdateSemantics([None] D3DVERTEXELEMENT9 Declaration[65])</unmanaged>
        public SlimDX2.Result UpdateSemantics(SlimDX2.Direct3D9.VertexElement[] declaration) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* declaration_ = &declaration[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, declaration_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXMesh</unmanaged>
    [Guid("4020e5c2-1403-4929-883f-e2e849fac195")]
    public partial class Mesh : SlimDX2.Direct3D9.BaseMesh {
        public Mesh(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Locks the mesh buffer that contains the mesh attribute data, and returns a pointer to it.	
        /// </summary>	
        /// <remarks>	
        ///  If <see cref="SlimDX2.Direct3D9.Mesh.Optimize"/> has been called, the mesh will also have an attribute table that can be accessed using the <see cref="SlimDX2.Direct3D9.BaseMesh.GetAttributeTable"/> method.  	
        /// </remarks>	
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY  For a description of the flags, see <see cref="SlimDX2.Direct3D9.LockFlags"/>. </param>
        /// <param name="dataRef"> Address of a pointer to a buffer containing a DWORD for each face in the mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXMesh::LockAttributeBuffer([None] int Flags,[None] int** ppData)</unmanaged>
        public SlimDX2.Result LockAttributeBuffer(int flags, ref int dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* dataRef_ = &dataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, flags, dataRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks an attribute buffer.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXMesh::UnlockAttributeBuffer()</unmanaged>
        public SlimDX2.Result UnlockAttributeBuffer() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Generates a new mesh with reordered faces and vertices to optimize drawing performance.	
        /// </summary>	
        /// <remarks>	
        ///  This method generates a new mesh. Before running Optimize, an application must generate an adjacency buffer by calling <see cref="SlimDX2.Direct3D9.BaseMesh.GenerateAdjacency"/>. The adjacency buffer contains adjacency data, such as a list of edges and the faces that are adjacent to each other. This method is very similar to the <see cref="SlimDX2.Direct3D9.BaseMesh.CloneMesh"/> method, except that it can perform optimization while generating the new clone of the mesh. The output mesh inherits all of the creation parameters of the input mesh. 	
        /// </remarks>	
        /// <param name="flags"> Specifies the type of optimization to perform. This parameter can be set to a combination of one or more flags from {{D3DXMESHOPT}} and {{D3DXMESH}} (except D3DXMESH_32BIT, D3DXMESH_IB_WRITEONLY, and D3DXMESH_WRITEONLY). </param>
        /// <param name="adjacencyInRef"> Pointer to an array of three DWORDs per face that specifies the three neighbors for each face in the source mesh. If the edge has no adjacent faces, the value is 0xffffffff. See Remarks. </param>
        /// <param name="adjacencyOutRef"> Pointer to an array of three DWORDs per face that specifies the three neighbors for each face in the optimized mesh. If the edge has no adjacent faces, the value is 0xffffffff. </param>
        /// <param name="faceRemapRef"> An array of DWORDs, one per face, that identifies the original mesh face that corresponds to each face in the optimized mesh. If the value supplied for this argument is NULL, face remap data is not returned. </param>
        /// <param name="vertexRemapRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface, which contains a DWORD for each vertex that specifies how the new vertices map to the old vertices. This remap is useful if you need to alter external data based on the new vertex mapping. </param>
        /// <param name="optMeshRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the optimized mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXMesh::Optimize([None] int Flags,[None] const int* pAdjacencyIn,[None] int* pAdjacencyOut,[None] int* pFaceRemap,[None] LPD3DXBUFFER* ppVertexRemap,[None] LPD3DXMESH* ppOptMesh)</unmanaged>
        public SlimDX2.Result Optimize(int flags, ref int adjacencyInRef, ref int adjacencyOutRef, ref int faceRemapRef, out SlimDX2.Direct3D9.ShaderBytecode vertexRemapRef, out SlimDX2.Direct3D9.Mesh optMeshRef) {
            unsafe {
                IntPtr vertexRemapRef_ = IntPtr.Zero;
                IntPtr optMeshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* adjacencyInRef_ = &adjacencyInRef)
                    fixed (void* adjacencyOutRef_ = &adjacencyOutRef)
                        fixed (void* faceRemapRef_ = &faceRemapRef)
                            __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 26 * 4, flags, adjacencyInRef_, adjacencyOutRef_, faceRemapRef_, &vertexRemapRef_, &optMeshRef_);
                vertexRemapRef = (vertexRemapRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(vertexRemapRef_);	
                optMeshRef = (optMeshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(optMeshRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Generates a mesh with reordered faces and vertices to optimize drawing performance. This method reorders the existing mesh.	
        /// </summary>	
        /// <remarks>	
        ///  Before running ID3DXMesh::OptimizeInplace, an application must generate an adjacency buffer by calling <see cref="SlimDX2.Direct3D9.BaseMesh.GenerateAdjacency"/>. The adjacency buffer contains adjacency data, such as a list of edges and the faces that are adjacent to each other. Note??This method will fail if the mesh is sharing its vertex buffer with another mesh, unless the D3DXMESHOPT_IGNOREVERTS is set in Flags. 	
        /// </remarks>	
        /// <param name="flags"> Combination of one or more {{D3DXMESHOPT}} flags, specifying the type of optimization to perform. </param>
        /// <param name="adjacencyInRef"> Pointer to an array of three DWORDs per face that specifies the three neighbors for each face in the source mesh. If the edge has no adjacent faces, the value is 0xffffffff. </param>
        /// <param name="adjacencyOutRef"> Pointer to an array of three DWORDs per face that specifies the three neighbors for each face in the optimized mesh. If the edge has no adjacent faces, the value is 0xffffffff. If the value supplied for this argument is NULL, adjacency data is not returned. </param>
        /// <param name="faceRemapRef"> An array of DWORDs, one per face, that identifies the original mesh face that corresponds to each face in the optimized mesh. If the value supplied for this argument is NULL, face remap data is not returned. </param>
        /// <param name="vertexRemapRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface, which contains a DWORD for each vertex that specifies how the new vertices map to the old vertices. This remap is useful if you need to alter external data based on the new vertex mapping. If the value supplied for this argument is NULL, vertex remap data is not returned. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_CANNOTATTRSORT, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXMesh::OptimizeInplace([None] int Flags,[None] const int* pAdjacencyIn,[None] int* pAdjacencyOut,[None] int* pFaceRemap,[None] LPD3DXBUFFER* ppVertexRemap)</unmanaged>
        public SlimDX2.Result OptimizeInplace(int flags, ref int adjacencyInRef, ref int adjacencyOutRef, ref int faceRemapRef, out SlimDX2.Direct3D9.ShaderBytecode vertexRemapRef) {
            unsafe {
                IntPtr vertexRemapRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* adjacencyInRef_ = &adjacencyInRef)
                    fixed (void* adjacencyOutRef_ = &adjacencyOutRef)
                        fixed (void* faceRemapRef_ = &faceRemapRef)
                            __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 27 * 4, flags, adjacencyInRef_, adjacencyOutRef_, faceRemapRef_, &vertexRemapRef_);
                vertexRemapRef = (vertexRemapRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(vertexRemapRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the attribute table for a mesh and the number of entries stored in the table.	
        /// </summary>	
        /// <remarks>	
        ///  If an application keeps track of the information in an attribute table, and rearranges the table as a result of changes to attributes or faces, this method allows the application to update the attribute tables instead of calling <see cref="SlimDX2.Direct3D9.Mesh.Optimize"/> again. 	
        /// </remarks>	
        /// <param name="attribTableRef"> Pointer to an array of <see cref="SlimDX2.Direct3D9.AttributeRange"/> structures, representing the entries in the mesh attribute table. </param>
        /// <param name="cAttribTableSize"> Number of attributes in the mesh attribute table. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXMesh::SetAttributeTable([None] const D3DXATTRIBUTERANGE* pAttribTable,[None] int cAttribTableSize)</unmanaged>
        public SlimDX2.Result SetAttributeTable(ref SlimDX2.Direct3D9.AttributeRange attribTableRef, int cAttribTableSize) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* attribTableRef_ = &attribTableRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 28 * 4, attribTableRef_, cAttribTableSize);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXPMesh</unmanaged>
    [Guid("8875769a-d579-4088-aaeb-534d1ad84e96")]
    public partial class PMesh : SlimDX2.Direct3D9.BaseMesh {
        public PMesh(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXPMesh::SetNumFaces([None] int Faces)</unmanaged>
        public int NumFaces {
                set { SetNumFaces(value); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXPMesh::SetNumVertices([None] int Vertices)</unmanaged>
        public int NumVertices {
                set { SetNumVertices(value); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int ID3DXPMesh::GetMaxFaces()</unmanaged>
        public int MaxFaces {
                get { return GetMaxFaces(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int ID3DXPMesh::GetMinFaces()</unmanaged>
        public int MinFaces {
                get { return GetMinFaces(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int ID3DXPMesh::GetMaxVertices()</unmanaged>
        public int MaxVertices {
                get { return GetMaxVertices(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int ID3DXPMesh::GetMinVertices()</unmanaged>
        public int MinVertices {
                get { return GetMinVertices(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXPMesh::GetAdjacency([Out] int* pAdjacency)</unmanaged>
        public int Adjacency {
                get { int __output__; GetAdjacency(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>
        /// <param name="fvf">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="cloneMeshRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXPMesh::ClonePMeshFVF([None] int Options,[None] int FVF,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXPMESH* ppCloneMesh)</unmanaged>
        public SlimDX2.Result ClonePMeshFVF(int options, int fvf, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.PMesh cloneMeshRef) {
            unsafe {
                IntPtr cloneMeshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, options, fvf, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), &cloneMeshRef_);
                cloneMeshRef = (cloneMeshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PMesh(cloneMeshRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>
        /// <param name="declarationRef">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="cloneMeshRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXPMesh::ClonePMesh([None] int Options,[None] const D3DVERTEXELEMENT9* pDeclaration,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXPMESH* ppCloneMesh)</unmanaged>
        public SlimDX2.Result ClonePMesh(int options, ref SlimDX2.Direct3D9.VertexElement declarationRef, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.PMesh cloneMeshRef) {
            unsafe {
                IntPtr cloneMeshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* declarationRef_ = &declarationRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4, options, declarationRef_, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), &cloneMeshRef_);
                cloneMeshRef = (cloneMeshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PMesh(cloneMeshRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="faces">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXPMesh::SetNumFaces([None] int Faces)</unmanaged>
        internal SlimDX2.Result SetNumFaces(int faces) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 26 * 4, faces);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="vertices">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXPMesh::SetNumVertices([None] int Vertices)</unmanaged>
        internal SlimDX2.Result SetNumVertices(int vertices) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 27 * 4, vertices);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int ID3DXPMesh::GetMaxFaces()</unmanaged>
        internal int GetMaxFaces() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 28 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int ID3DXPMesh::GetMinFaces()</unmanaged>
        internal int GetMinFaces() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 29 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int ID3DXPMesh::GetMaxVertices()</unmanaged>
        internal int GetMaxVertices() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 30 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int ID3DXPMesh::GetMinVertices()</unmanaged>
        internal int GetMinVertices() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 31 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="streamRef">No documentation.</param>
        /// <param name="materialsRef">No documentation.</param>
        /// <param name="effectInstancesRef">No documentation.</param>
        /// <param name="numMaterials">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXPMesh::Save([None] void* pStream,[None] const D3DXMATERIAL* pMaterials,[None] const D3DXEFFECTINSTANCE* pEffectInstances,[None] int NumMaterials)</unmanaged>
        public SlimDX2.Result Save(IntPtr streamRef, ref SlimDX2.Direct3D9.ExtendedMaterial materialsRef, ref SlimDX2.Direct3D9.EffectInstance effectInstancesRef, int numMaterials) {
            unsafe {
                SlimDX2.Direct3D9.ExtendedMaterial.__Native materialsRef_ = new SlimDX2.Direct3D9.ExtendedMaterial.__Native();
                materialsRef.__MarshalTo(ref materialsRef_);
                SlimDX2.Direct3D9.EffectInstance.__Native effectInstancesRef_ = new SlimDX2.Direct3D9.EffectInstance.__Native();
                effectInstancesRef.__MarshalTo(ref effectInstancesRef_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 32 * 4, (void*)streamRef, &materialsRef_, &effectInstancesRef_, numMaterials);
                materialsRef.__MarshalFrom(ref materialsRef_);
                materialsRef_.__MarshalFree();
                effectInstancesRef.__MarshalFrom(ref effectInstancesRef_);
                effectInstancesRef_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="flags">No documentation.</param>
        /// <param name="adjacencyOutRef">No documentation.</param>
        /// <param name="faceRemapRef">No documentation.</param>
        /// <param name="vertexRemapRef">No documentation.</param>
        /// <param name="optMeshRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXPMesh::Optimize([None] int Flags,[None] int* pAdjacencyOut,[None] int* pFaceRemap,[None] LPD3DXBUFFER* ppVertexRemap,[None] LPD3DXMESH* ppOptMesh)</unmanaged>
        public SlimDX2.Result Optimize(int flags, ref int adjacencyOutRef, ref int faceRemapRef, out SlimDX2.Direct3D9.ShaderBytecode vertexRemapRef, out SlimDX2.Direct3D9.Mesh optMeshRef) {
            unsafe {
                IntPtr vertexRemapRef_ = IntPtr.Zero;
                IntPtr optMeshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* adjacencyOutRef_ = &adjacencyOutRef)
                    fixed (void* faceRemapRef_ = &faceRemapRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 33 * 4, flags, adjacencyOutRef_, faceRemapRef_, &vertexRemapRef_, &optMeshRef_);
                vertexRemapRef = (vertexRemapRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(vertexRemapRef_);	
                optMeshRef = (optMeshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(optMeshRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="flags">No documentation.</param>
        /// <param name="faceRemapRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXPMesh::OptimizeBaseLOD([None] int Flags,[None] int* pFaceRemap)</unmanaged>
        public SlimDX2.Result OptimizeBaseLOD(int flags, ref int faceRemapRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* faceRemapRef_ = &faceRemapRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 34 * 4, flags, faceRemapRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="newFacesMin">No documentation.</param>
        /// <param name="newFacesMax">No documentation.</param>
        /// <param name="rgiFaceRemap">No documentation.</param>
        /// <param name="rgiVertRemap">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXPMesh::TrimByFaces([None] int NewFacesMin,[None] int NewFacesMax,[None] int* rgiFaceRemap,[None] int* rgiVertRemap)</unmanaged>
        public SlimDX2.Result TrimByFaces(int newFacesMin, int newFacesMax, ref int rgiFaceRemap, ref int rgiVertRemap) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* rgiFaceRemap_ = &rgiFaceRemap)
                    fixed (void* rgiVertRemap_ = &rgiVertRemap)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 35 * 4, newFacesMin, newFacesMax, rgiFaceRemap_, rgiVertRemap_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="newVerticesMin">No documentation.</param>
        /// <param name="newVerticesMax">No documentation.</param>
        /// <param name="rgiFaceRemap">No documentation.</param>
        /// <param name="rgiVertRemap">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXPMesh::TrimByVertices([None] int NewVerticesMin,[None] int NewVerticesMax,[None] int* rgiFaceRemap,[None] int* rgiVertRemap)</unmanaged>
        public SlimDX2.Result TrimByVertices(int newVerticesMin, int newVerticesMax, ref int rgiFaceRemap, ref int rgiVertRemap) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* rgiFaceRemap_ = &rgiFaceRemap)
                    fixed (void* rgiVertRemap_ = &rgiVertRemap)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 36 * 4, newVerticesMin, newVerticesMax, rgiFaceRemap_, rgiVertRemap_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="adjacencyRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXPMesh::GetAdjacency([Out] int* pAdjacency)</unmanaged>
        internal SlimDX2.Result GetAdjacency(out int adjacencyRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* adjacencyRef_ = &adjacencyRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 37 * 4, adjacencyRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="vertexHistoryRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXPMesh::GenerateVertexHistory([None] int* pVertexHistory)</unmanaged>
        public SlimDX2.Result GenerateVertexHistory(ref int vertexHistoryRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* vertexHistoryRef_ = &vertexHistoryRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 38 * 4, vertexHistoryRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXSPMesh</unmanaged>
    [Guid("667ea4c7-f1cd-4386-b523-7c0290b83cc5")]
    public partial class SimplificationMesh : SlimDX2.ComObject {
        public SimplificationMesh(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int ID3DXSPMesh::GetNumFaces()</unmanaged>
        public int NumFaces {
                get { return GetNumFaces(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int ID3DXSPMesh::GetNumVertices()</unmanaged>
        public int NumVertices {
                get { return GetNumVertices(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int ID3DXSPMesh::GetFVF()</unmanaged>
        public int FVF {
                get { return GetFVF(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int ID3DXSPMesh::GetOptions()</unmanaged>
        public int Options {
                get { return GetOptions(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXSPMesh::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int ID3DXSPMesh::GetMaxFaces()</unmanaged>
        public int MaxFaces {
                get { return GetMaxFaces(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int ID3DXSPMesh::GetMaxVertices()</unmanaged>
        public int MaxVertices {
                get { return GetMaxVertices(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXSPMesh::GetVertexWeights([Out] FLOAT* pVertexWeights)</unmanaged>
        public float VertexWeights {
                get { float __output__; GetVertexWeights(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int ID3DXSPMesh::GetNumFaces()</unmanaged>
        internal int GetNumFaces() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int ID3DXSPMesh::GetNumVertices()</unmanaged>
        internal int GetNumVertices() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int ID3DXSPMesh::GetFVF()</unmanaged>
        internal int GetFVF() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="declaration">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXSPMesh::GetDeclaration([None] D3DVERTEXELEMENT9 Declaration[65])</unmanaged>
        public SlimDX2.Result GetDeclaration(SlimDX2.Direct3D9.VertexElement[] declaration) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* declaration_ = &declaration[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, declaration_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int ID3DXSPMesh::GetOptions()</unmanaged>
        internal int GetOptions() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="deviceRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXSPMesh::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>
        /// <param name="fvf">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="adjacencyOutRef">No documentation.</param>
        /// <param name="vertexRemapOutRef">No documentation.</param>
        /// <param name="cloneMeshRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXSPMesh::CloneMeshFVF([None] int Options,[None] int FVF,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] int* pAdjacencyOut,[None] int* pVertexRemapOut,[None] LPD3DXMESH* ppCloneMesh)</unmanaged>
        public SlimDX2.Result CloneMeshFVF(int options, int fvf, SlimDX2.Direct3D9.Device pD3DDevice, ref int adjacencyOutRef, ref int vertexRemapOutRef, out SlimDX2.Direct3D9.Mesh cloneMeshRef) {
            unsafe {
                IntPtr cloneMeshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* adjacencyOutRef_ = &adjacencyOutRef)
                    fixed (void* vertexRemapOutRef_ = &vertexRemapOutRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, options, fvf, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), adjacencyOutRef_, vertexRemapOutRef_, &cloneMeshRef_);
                cloneMeshRef = (cloneMeshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(cloneMeshRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>
        /// <param name="declarationRef">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="adjacencyOutRef">No documentation.</param>
        /// <param name="vertexRemapOutRef">No documentation.</param>
        /// <param name="cloneMeshRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXSPMesh::CloneMesh([None] int Options,[None] const D3DVERTEXELEMENT9* pDeclaration,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] int* pAdjacencyOut,[None] int* pVertexRemapOut,[None] LPD3DXMESH* ppCloneMesh)</unmanaged>
        public SlimDX2.Result CloneMesh(int options, ref SlimDX2.Direct3D9.VertexElement declarationRef, SlimDX2.Direct3D9.Device pD3DDevice, ref int adjacencyOutRef, ref int vertexRemapOutRef, out SlimDX2.Direct3D9.Mesh cloneMeshRef) {
            unsafe {
                IntPtr cloneMeshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* declarationRef_ = &declarationRef)
                    fixed (void* adjacencyOutRef_ = &adjacencyOutRef)
                        fixed (void* vertexRemapOutRef_ = &vertexRemapOutRef)
                            __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, options, declarationRef_, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), adjacencyOutRef_, vertexRemapOutRef_, &cloneMeshRef_);
                cloneMeshRef = (cloneMeshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(cloneMeshRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>
        /// <param name="fvf">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="vertexRemapOutRef">No documentation.</param>
        /// <param name="errorsByFaceRef">No documentation.</param>
        /// <param name="cloneMeshRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXSPMesh::ClonePMeshFVF([None] int Options,[None] int FVF,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] int* pVertexRemapOut,[None] FLOAT* pErrorsByFace,[None] LPD3DXPMESH* ppCloneMesh)</unmanaged>
        public SlimDX2.Result ClonePMeshFVF(int options, int fvf, SlimDX2.Direct3D9.Device pD3DDevice, ref int vertexRemapOutRef, ref float errorsByFaceRef, out SlimDX2.Direct3D9.PMesh cloneMeshRef) {
            unsafe {
                IntPtr cloneMeshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* vertexRemapOutRef_ = &vertexRemapOutRef)
                    fixed (void* errorsByFaceRef_ = &errorsByFaceRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, options, fvf, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), vertexRemapOutRef_, errorsByFaceRef_, &cloneMeshRef_);
                cloneMeshRef = (cloneMeshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PMesh(cloneMeshRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>
        /// <param name="declarationRef">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="vertexRemapOutRef">No documentation.</param>
        /// <param name="errorsbyFaceRef">No documentation.</param>
        /// <param name="cloneMeshRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXSPMesh::ClonePMesh([None] int Options,[None] const D3DVERTEXELEMENT9* pDeclaration,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] int* pVertexRemapOut,[None] FLOAT* pErrorsbyFace,[None] LPD3DXPMESH* ppCloneMesh)</unmanaged>
        public SlimDX2.Result ClonePMesh(int options, ref SlimDX2.Direct3D9.VertexElement declarationRef, SlimDX2.Direct3D9.Device pD3DDevice, ref int vertexRemapOutRef, ref float errorsbyFaceRef, out SlimDX2.Direct3D9.PMesh cloneMeshRef) {
            unsafe {
                IntPtr cloneMeshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* declarationRef_ = &declarationRef)
                    fixed (void* vertexRemapOutRef_ = &vertexRemapOutRef)
                        fixed (void* errorsbyFaceRef_ = &errorsbyFaceRef)
                            __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, options, declarationRef_, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), vertexRemapOutRef_, errorsbyFaceRef_, &cloneMeshRef_);
                cloneMeshRef = (cloneMeshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PMesh(cloneMeshRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="faces">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXSPMesh::ReduceFaces([None] int Faces)</unmanaged>
        public SlimDX2.Result ReduceFaces(int faces) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, faces);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="vertices">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXSPMesh::ReduceVertices([None] int Vertices)</unmanaged>
        public SlimDX2.Result ReduceVertices(int vertices) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, vertices);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int ID3DXSPMesh::GetMaxFaces()</unmanaged>
        internal int GetMaxFaces() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int ID3DXSPMesh::GetMaxVertices()</unmanaged>
        internal int GetMaxVertices() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="pVertexAttributeWeights">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXSPMesh::GetVertexAttributeWeights([None] LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights)</unmanaged>
        public SlimDX2.Result GetVertexAttributeWeights(ref SlimDX2.Direct3D9.AttributeWeights pVertexAttributeWeights) {
            unsafe {
                SlimDX2.Direct3D9.AttributeWeights.__Native pVertexAttributeWeights_ = new SlimDX2.Direct3D9.AttributeWeights.__Native();
                pVertexAttributeWeights.__MarshalTo(ref pVertexAttributeWeights_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, &pVertexAttributeWeights_);
                pVertexAttributeWeights.__MarshalFrom(ref pVertexAttributeWeights_);
                pVertexAttributeWeights_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="vertexWeightsRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3DXSPMesh::GetVertexWeights([Out] FLOAT* pVertexWeights)</unmanaged>
        internal SlimDX2.Result GetVertexWeights(out float vertexWeightsRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* vertexWeightsRef_ = &vertexWeightsRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, vertexWeightsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXPatchMesh</unmanaged>
    [Guid("3ce6cc22-dbf2-44f4-894d-f9c34a337139")]
    public partial class PatchMesh : SlimDX2.ComObject {
        public PatchMesh(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the number of patches in the mesh.	
        /// </summary>	
        /// <unmanaged>int ID3DXPatchMesh::GetNumPatches()</unmanaged>
        public int NumPatches {
                get { return GetNumPatches(); }
        }
        
        /// <summary>	
        /// Gets the number of vertices in the mesh.	
        /// </summary>	
        /// <unmanaged>int ID3DXPatchMesh::GetNumVertices()</unmanaged>
        public int NumVertices {
                get { return GetNumVertices(); }
        }
        
        /// <summary>	
        /// Gets the number of control vertices per patch.	
        /// </summary>	
        /// <unmanaged>int ID3DXPatchMesh::GetControlVerticesPerPatch()</unmanaged>
        public int ControlVerticesPerPatch {
                get { return GetControlVerticesPerPatch(); }
        }
        
        /// <summary>	
        /// Gets the type of patch.	
        /// </summary>	
        /// <remarks>	
        ///  For more information about patch types, see <see cref="SlimDX2.Direct3D9.PatchMeshType"/>. 	
        /// </remarks>	
        /// <unmanaged>int ID3DXPatchMesh::GetOptions()</unmanaged>
        public int Options {
                get { return GetOptions(); }
        }
        
        /// <summary>	
        /// Gets the device that created the mesh.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the mesh vertex buffer.	
        /// </summary>	
        /// <remarks>	
        ///  This method assumes uniform tessellation. 	
        /// </remarks>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetVertexBuffer([Out] LPDIRECT3DVERTEXBUFFER9* ppVB)</unmanaged>
        public SlimDX2.Direct3D9.VertexBuffer VertexBuffer {
                get { SlimDX2.Direct3D9.VertexBuffer __output__; GetVertexBuffer(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the mesh index buffer.	
        /// </summary>	
        /// <remarks>	
        ///   The index buffer contains the vertex ordering in the vertex buffer. The index buffer is used to access the vertex buffer when the mesh is rendered. 	
        /// </remarks>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetIndexBuffer([Out] LPDIRECT3DINDEXBUFFER9* ppIB)</unmanaged>
        public SlimDX2.Direct3D9.IndexBuffer IndexBuffer {
                get { SlimDX2.Direct3D9.IndexBuffer __output__; GetIndexBuffer(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the number of patches in the mesh.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  The number of patches. </returns>
        /// <unmanaged>int ID3DXPatchMesh::GetNumPatches()</unmanaged>
        internal int GetNumPatches() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of vertices in the mesh.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  The number of vertices. </returns>
        /// <unmanaged>int ID3DXPatchMesh::GetNumVertices()</unmanaged>
        internal int GetNumVertices() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the vertex declaration.	
        /// </summary>	
        /// <remarks>	
        ///  The array of elements includes the {{D3DDECL_END}} macro, which ends the declaration. 	
        /// </remarks>	
        /// <param name="declaration"> Array of <see cref="SlimDX2.Direct3D9.VertexElement"/> elements describing the vertex format of the mesh vertices. The dimension of this declarator array is {{MAX_FVF_DECL_SIZE}}. The vertex element array ends with the {{D3DDECL_END}} macro. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetDeclaration([None] D3DVERTEXELEMENT9 Declaration[65])</unmanaged>
        public SlimDX2.Result GetDeclaration(SlimDX2.Direct3D9.VertexElement[] declaration) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* declaration_ = &declaration[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, declaration_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of control vertices per patch.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  The number of control vertices per patch. </returns>
        /// <unmanaged>int ID3DXPatchMesh::GetControlVerticesPerPatch()</unmanaged>
        internal int GetControlVerticesPerPatch() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the type of patch.	
        /// </summary>	
        /// <remarks>	
        ///  For more information about patch types, see <see cref="SlimDX2.Direct3D9.PatchMeshType"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  The patch type. </returns>
        /// <unmanaged>int ID3DXPatchMesh::GetOptions()</unmanaged>
        internal int GetOptions() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the device that created the mesh.	
        /// </summary>	
        /// <param name="deviceRef"> Pointer to the device. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the attributes of the patch.	
        /// </summary>	
        /// <param name="patchInfo"> Pointer to the structures containing the patch attributes. For more information about patch attributes, see <see cref="SlimDX2.Direct3D9.PatchInfo"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetPatchInfo([None] LPD3DXPATCHINFO PatchInfo)</unmanaged>
        public SlimDX2.Result GetPatchInfo(ref SlimDX2.Direct3D9.PatchInfo patchInfo) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* patchInfo_ = &patchInfo)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, patchInfo_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the mesh vertex buffer.	
        /// </summary>	
        /// <remarks>	
        ///  This method assumes uniform tessellation. 	
        /// </remarks>	
        /// <param name="vBRef"> Pointer to the vertex buffer. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetVertexBuffer([Out] LPDIRECT3DVERTEXBUFFER9* ppVB)</unmanaged>
        internal SlimDX2.Result GetVertexBuffer(out SlimDX2.Direct3D9.VertexBuffer vBRef) {
            unsafe {
                IntPtr vBRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, &vBRef_);
                vBRef = (vBRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexBuffer(vBRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the mesh index buffer.	
        /// </summary>	
        /// <remarks>	
        ///   The index buffer contains the vertex ordering in the vertex buffer. The index buffer is used to access the vertex buffer when the mesh is rendered. 	
        /// </remarks>	
        /// <param name="iBRef"> Pointer to the index buffer. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetIndexBuffer([Out] LPDIRECT3DINDEXBUFFER9* ppIB)</unmanaged>
        internal SlimDX2.Result GetIndexBuffer(out SlimDX2.Direct3D9.IndexBuffer iBRef) {
            unsafe {
                IntPtr iBRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, &iBRef_);
                iBRef = (iBRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.IndexBuffer(iBRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Lock the vertex buffer.	
        /// </summary>	
        /// <remarks>	
        ///  The vertex buffer is usually locked, written to, and then unlocked for reading. Patch meshes use 16-bit index buffers. 	
        /// </remarks>	
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:   D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY D3DLOCK_NOOVERWRITE   For a description of the flags, see <see cref="SlimDX2.Direct3D9.LockFlags"/>. </param>
        /// <param name="dataRef"> VOID* pointer to a memory buffer containing the returned vertex data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::LockVertexBuffer([None] int flags,[None] void** ppData)</unmanaged>
        public SlimDX2.Result LockVertexBuffer(int flags, IntPtr dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, flags, (void*)dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlock the vertex buffer.	
        /// </summary>	
        /// <remarks>	
        ///  The vertex buffer is usually locked, written to, and then unlocked for reading. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::UnlockVertexBuffer()</unmanaged>
        public SlimDX2.Result UnlockVertexBuffer() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Lock the index buffer.	
        /// </summary>	
        /// <remarks>	
        ///  The index buffer is usually locked, written to, and then unlocked for reading. Patch mesh index buffers are 16-bit buffers. 	
        /// </remarks>	
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY   For a description of the flags, see <see cref="SlimDX2.Direct3D9.LockFlags"/>. </param>
        /// <param name="dataRef"> VOID* pointer to a memory buffer containing the returned index data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::LockIndexBuffer([None] int flags,[None] void** ppData)</unmanaged>
        public SlimDX2.Result LockIndexBuffer(int flags, IntPtr dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, flags, (void*)dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlock the index buffer.	
        /// </summary>	
        /// <remarks>	
        ///  The index buffer is usually locked, written to, and then unlocked for reading. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::UnlockIndexBuffer()</unmanaged>
        public SlimDX2.Result UnlockIndexBuffer() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Locks the attribute buffer.	
        /// </summary>	
        /// <remarks>	
        ///  The attribute buffer is usually locked, written to, and then unlocked for reading. 	
        /// </remarks>	
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY   For a description of the flags, see <see cref="SlimDX2.Direct3D9.LockFlags"/>. </param>
        /// <param name="dataRef"> Address of a pointer to a buffer containing a DWORD for each face in the mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::LockAttributeBuffer([None] int flags,[None] int** ppData)</unmanaged>
        public SlimDX2.Result LockAttributeBuffer(int flags, ref int dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* dataRef_ = &dataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, flags, dataRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlock the attribute buffer.	
        /// </summary>	
        /// <remarks>	
        ///  The attribute buffer is usually locked, written to, and then unlocked for reading. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::UnlockAttributeBuffer()</unmanaged>
        public SlimDX2.Result UnlockAttributeBuffer() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the size of the tessellated mesh, given a tessellation level.	
        /// </summary>	
        /// <remarks>	
        ///  This method assumes uniform tessellation. 	
        /// </remarks>	
        /// <param name="fTessLevel"> Tessellation level. </param>
        /// <param name="adaptive"> Adaptive tessellation. For adaptive tessellation, set this value to TRUE and set fTessLevel to the maximum tessellation value. This will result in the maximum mesh size necessary for adaptive tessellation. </param>
        /// <param name="numTriangles"> Pointer to the number of triangles generated by the tessellated mesh. </param>
        /// <param name="numVertices"> Pointer to the number of vertices generated by the tessellated mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetTessSize([None] FLOAT fTessLevel,[None] int Adaptive,[Out] int* NumTriangles,[Out] int* NumVertices)</unmanaged>
        public SlimDX2.Result GetTessSize(float fTessLevel, int adaptive, out int numTriangles, out int numVertices) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* numTriangles_ = &numTriangles)
                    fixed (void* numVertices_ = &numVertices)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, fTessLevel, adaptive, numTriangles_, numVertices_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Generate a list of mesh edges and the patches that share each edge.	
        /// </summary>	
        /// <remarks>	
        ///  After an application generates adjacency information for a mesh, the mesh data can be optimized for better drawing performance. This method determines which patches are adjacent (within the provided tolerance). This information is used internally to optimize tessellation. 	
        /// </remarks>	
        /// <param name="tolerance"> Specifies that vertices that differ in position by less than the tolerance should be treated as coincident. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::GenerateAdjacency([None] FLOAT Tolerance)</unmanaged>
        public SlimDX2.Result GenerateAdjacency(float tolerance) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, tolerance);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a new patch mesh with the specified vertex declaration.	
        /// </summary>	
        /// <remarks>	
        ///  CloneMesh converts the vertex buffer to the new vertex declaration. Entries in the vertex declaration that are new to the original mesh are set to 0. If the current mesh has adjacency, the new mesh will also have adjacency. 	
        /// </remarks>	
        /// <param name="options"> Combination of one or more {{D3DXMESH}} flags that specify creation options for the mesh. </param>
        /// <param name="declRef"> Array of <see cref="SlimDX2.Direct3D9.VertexElement"/> elements that specify the vertex format for the vertices in the output mesh. </param>
        /// <param name="meshRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.PatchMesh"/> interface that represents the cloned mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::CloneMesh([None] int Options,[None] const D3DVERTEXELEMENT9* pDecl,[None] LPD3DXPATCHMESH* pMesh)</unmanaged>
        public SlimDX2.Result CloneMesh(int options, ref SlimDX2.Direct3D9.VertexElement declRef, out SlimDX2.Direct3D9.PatchMesh meshRef) {
            unsafe {
                IntPtr meshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* declRef_ = &declRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, options, declRef_, &meshRef_);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PatchMesh(meshRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Optimizes the patch mesh for efficient tessellation.	
        /// </summary>	
        /// <remarks>	
        ///  After an application generates adjacency information for a mesh, the mesh data can be optimized (reordered) for better drawing performance. This method determines which patches are adjacent (within the provided tolerance). Adjacency information is also used to optimize tessellation. Generate adjacency information once and tessellate repeatedly by calling <see cref="SlimDX2.Direct3D9.PatchMesh.Tessellate"/>. The optimization performed is independent of the actual tessellation level used. However, if the mesh vertices are changed, you must regenerate the adjacency information. 	
        /// </remarks>	
        /// <param name="flags"> Currently unused. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_CANNOTATTRSORT. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::Optimize([None] int flags)</unmanaged>
        public SlimDX2.Result Optimize(int flags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets mesh geometry displacement parameters.	
        /// </summary>	
        /// <remarks>	
        ///  Displacement maps can only be 2D textures. Mipmapping is ignored for nonadaptive tessellation. 	
        /// </remarks>	
        /// <param name="texture"> Texture containing the displacement data. </param>
        /// <param name="minFilter"> Minification level. For more information, see <see cref="SlimDX2.Direct3D9.TextureFilter"/>. </param>
        /// <param name="magFilter"> Magnification level. For more information, see <see cref="SlimDX2.Direct3D9.TextureFilter"/>. </param>
        /// <param name="mipFilter"> Mip filter level. For more information, see <see cref="SlimDX2.Direct3D9.TextureFilter"/>. </param>
        /// <param name="wrap"> Texture address wrap mode. For more information, see <see cref="SlimDX2.Direct3D9.TextureAddress"/>  </param>
        /// <param name="dwLODBias"> Level of detail bias value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::SetDisplaceParam([None] LPDIRECT3DBASETEXTURE9 Texture,[None] D3DTEXTUREFILTERTYPE MinFilter,[None] D3DTEXTUREFILTERTYPE MagFilter,[None] D3DTEXTUREFILTERTYPE MipFilter,[None] D3DTEXTUREADDRESS Wrap,[None] int dwLODBias)</unmanaged>
        public SlimDX2.Result SetDisplaceParam(SlimDX2.Direct3D9.BaseTexture texture, SlimDX2.Direct3D9.TextureFilter minFilter, SlimDX2.Direct3D9.TextureFilter magFilter, SlimDX2.Direct3D9.TextureFilter mipFilter, SlimDX2.Direct3D9.TextureAddress wrap, int dwLODBias) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 22 * 4, (void*)((texture == null)?IntPtr.Zero:texture.NativePointer), unchecked((int)minFilter), unchecked((int)magFilter), unchecked((int)mipFilter), unchecked((int)wrap), dwLODBias);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets mesh geometry displacement parameters.	
        /// </summary>	
        /// <remarks>	
        ///  Displacement maps can only be 2D textures. Mipmapping is ignored for nonadaptive tessellation. 	
        /// </remarks>	
        /// <param name="texture"> Texture containing the displacement data. </param>
        /// <param name="minFilter"> Minification level. For more information, see <see cref="SlimDX2.Direct3D9.TextureFilter"/>. </param>
        /// <param name="magFilter"> Magnification level. For more information, see <see cref="SlimDX2.Direct3D9.TextureFilter"/>. </param>
        /// <param name="mipFilter"> Mip filter level. For more information, see <see cref="SlimDX2.Direct3D9.TextureFilter"/>. </param>
        /// <param name="wrap"> Texture address wrap mode. For more information, see <see cref="SlimDX2.Direct3D9.TextureAddress"/>. </param>
        /// <param name="dwLODBias"> Level of detail bias value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetDisplaceParam([Out] LPDIRECT3DBASETEXTURE9* Texture,[Out] D3DTEXTUREFILTERTYPE* MinFilter,[Out] D3DTEXTUREFILTERTYPE* MagFilter,[Out] D3DTEXTUREFILTERTYPE* MipFilter,[Out] D3DTEXTUREADDRESS* Wrap,[Out] int* dwLODBias)</unmanaged>
        public SlimDX2.Result GetDisplaceParam(out SlimDX2.Direct3D9.BaseTexture texture, out SlimDX2.Direct3D9.TextureFilter minFilter, out SlimDX2.Direct3D9.TextureFilter magFilter, out SlimDX2.Direct3D9.TextureFilter mipFilter, out SlimDX2.Direct3D9.TextureAddress wrap, out int dwLODBias) {
            unsafe {
                IntPtr texture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* minFilter_ = &minFilter)
                    fixed (void* magFilter_ = &magFilter)
                        fixed (void* mipFilter_ = &mipFilter)
                            fixed (void* wrap_ = &wrap)
                                fixed (void* dwLODBias_ = &dwLODBias)
                                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, &texture_, minFilter_, magFilter_, mipFilter_, wrap_, dwLODBias_);
                texture = (texture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.BaseTexture(texture_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Performs uniform tessellation based on the tessellation level.	
        /// </summary>	
        /// <remarks>	
        ///  This function will perform more efficiently if the patch mesh has been optimized using <see cref="SlimDX2.Direct3D9.PatchMesh.Optimize"/>.  	
        /// </remarks>	
        /// <param name="fTessLevel"> Tessellation level. This is the number of vertices introduced between existing vertices. The range of this float parameter is 0 &lt; fTessLevel &lt;= 32. </param>
        /// <param name="pMesh"> Resulting tessellated mesh. See <see cref="SlimDX2.Direct3D9.Mesh"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::Tessellate([None] FLOAT fTessLevel,[None] LPD3DXMESH pMesh)</unmanaged>
        public SlimDX2.Result Tessellate(float fTessLevel, SlimDX2.Direct3D9.Mesh pMesh) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, fTessLevel, (void*)((pMesh == null)?IntPtr.Zero:pMesh.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Performs adaptive tessellation based on the z-based adaptive tessellation criterion.	
        /// </summary>	
        /// <remarks>	
        ///  This function will perform more efficiently if the patch mesh has been optimized using <see cref="SlimDX2.Direct3D9.PatchMesh.Optimize"/>.  	
        /// </remarks>	
        /// <param name="transRef"> Specifies a 4D vector that is dotted with the vertices to get the per-vertex adaptive tessellation amount. Each edge is tessellated to the average value of the tessellation levels for the two vertices it connects. </param>
        /// <param name="dwMaxTessLevel"> Maximum limit for adaptive tessellation. This is the number of vertices introduced between existing vertices. This integer value can range from 1 to 32, inclusive. </param>
        /// <param name="dwMinTessLevel"> Minimum limit for adaptive tessellation. This is the number of vertices introduced between existing vertices. This integer value can range from 1 to 32, inclusive. </param>
        /// <param name="pMesh"> Resulting tessellated mesh. See <see cref="SlimDX2.Direct3D9.Mesh"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXPatchMesh::TessellateAdaptive([None] const D3DXVECTOR4* pTrans,[None] int dwMaxTessLevel,[None] int dwMinTessLevel,[None] LPD3DXMESH pMesh)</unmanaged>
        public SlimDX2.Result TessellateAdaptive(ref SlimMath.Vector4 transRef, int dwMaxTessLevel, int dwMinTessLevel, SlimDX2.Direct3D9.Mesh pMesh) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* transRef_ = &transRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4, transRef_, dwMaxTessLevel, dwMinTessLevel, (void*)((pMesh == null)?IntPtr.Zero:pMesh.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXSkinInfo</unmanaged>
    [Guid("11eaa540-f9a6-4d49-ae6a-e19221f70cc4")]
    public partial class SkinInfo : SlimDX2.ComObject {
        public SkinInfo(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the maximum number of influences for any vertex in the mesh.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::GetMaxVertexInfluences([Out] int* maxVertexInfluences)</unmanaged>
        public int MaxVertexInfluences {
                get { int __output__; GetMaxVertexInfluences(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the number of bones.	
        /// </summary>	
        /// <unmanaged>int ID3DXSkinInfo::GetNumBones()</unmanaged>
        public int NumBones {
                get { return GetNumBones(); }
        }
        
        /// <summary>	
        /// Gets the minimum bone influence. Influence values smaller than this are ignored.	
        /// </summary>	
        /// <unmanaged>FLOAT ID3DXSkinInfo::GetMinBoneInfluence()</unmanaged>
        public float MinBoneInfluence {
                get { return GetMinBoneInfluence(); }
                set { SetMinBoneInfluence(value); }
        }
        
        /// <summary>	
        /// Gets the fixed function vertex value.	
        /// </summary>	
        /// <remarks>	
        ///  This method can return 0 if the vertex format cannot be mapped directly to an FVF code.  This will occur for a mesh created from a vertex declaration that doesn't have the same order and elements supported by the FVF codes. 	
        /// </remarks>	
        /// <unmanaged>int ID3DXSkinInfo::GetFVF()</unmanaged>
        public int FVF {
                get { return GetFVF(); }
                set { SetFVF(value); }
        }
        
        /// <summary>	
        /// Sets the influence value for a bone.	
        /// </summary>	
        /// <param name="bone"> Bone number. </param>
        /// <param name="numInfluences"> Number of influences. </param>
        /// <param name="vertices"> The array of vertices influenced by a bone. </param>
        /// <param name="weights"> The array of weights influenced by a bone. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::SetBoneInfluence([None] int bone,[None] int numInfluences,[None] const int* vertices,[None] const FLOAT* weights)</unmanaged>
        public SlimDX2.Result SetBoneInfluence(int bone, int numInfluences, ref int vertices, ref float weights) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* vertices_ = &vertices)
                    fixed (void* weights_ = &weights)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, bone, numInfluences, vertices_, weights_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an influence value of a bone on a single vertex.	
        /// </summary>	
        /// <param name="boneNum"> Index of the bone. Must be between 0 and the number of bones. </param>
        /// <param name="influenceNum"> Index of the influence array of the specified bone. </param>
        /// <param name="weight"> Blend factor of the specified bone influence. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::SetBoneVertexInfluence([None] int boneNum,[None] int influenceNum,[None] float weight)</unmanaged>
        public SlimDX2.Result SetBoneVertexInfluence(int boneNum, int influenceNum, float weight) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, boneNum, influenceNum, weight);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of influences for a bone.	
        /// </summary>	
        /// <param name="bone"> Bone number. </param>
        /// <returns>  <see cref="int"/>  Returns the number of influences for a bone. </returns>
        /// <unmanaged>int ID3DXSkinInfo::GetNumBoneInfluences([None] int bone)</unmanaged>
        public int GetNumBoneInfluences(int bone) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, bone);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the vertices and weights that a bone influences.	
        /// </summary>	
        /// <remarks>	
        ///  Use <see cref="SlimDX2.Direct3D9.SkinInfo.GetNumBoneInfluences"/> to find out how many vertices the bone influences.  	
        /// </remarks>	
        /// <param name="bone"> Bone number. </param>
        /// <param name="vertices"> Get the array of vertices influenced by a bone. </param>
        /// <param name="weights"> Get the array of weights influenced by a bone. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::GetBoneInfluence([None] int bone,[Out] int* vertices,[Out] FLOAT* weights)</unmanaged>
        public SlimDX2.Result GetBoneInfluence(int bone, out int vertices, out float weights) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* vertices_ = &vertices)
                    fixed (void* weights_ = &weights)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, bone, vertices_, weights_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the blend factor and vertex affected by a specified bone influence.	
        /// </summary>	
        /// <param name="boneNum"> Index of the bone. Must be between 0 and the number of bones. </param>
        /// <param name="influenceNum"> Index of the influence array of the specified bone. </param>
        /// <param name="weightRef"> Pointer to the blend factor influenced by influenceNum. </param>
        /// <param name="vertexNumRef"> Pointer to the vertex influenced by influenceNum. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::GetBoneVertexInfluence([None] int boneNum,[None] int influenceNum,[Out] float* pWeight,[Out] int* pVertexNum)</unmanaged>
        public SlimDX2.Result GetBoneVertexInfluence(int boneNum, int influenceNum, out float weightRef, out int vertexNumRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* weightRef_ = &weightRef)
                    fixed (void* vertexNumRef_ = &vertexNumRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, boneNum, influenceNum, weightRef_, vertexNumRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the maximum number of influences for any vertex in the mesh.	
        /// </summary>	
        /// <param name="maxVertexInfluences"> Pointer to the maximum vertex influence. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::GetMaxVertexInfluences([Out] int* maxVertexInfluences)</unmanaged>
        internal SlimDX2.Result GetMaxVertexInfluences(out int maxVertexInfluences) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* maxVertexInfluences_ = &maxVertexInfluences)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, maxVertexInfluences_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of bones.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns the number of bones. </returns>
        /// <unmanaged>int ID3DXSkinInfo::GetNumBones()</unmanaged>
        internal int GetNumBones() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the index of the bone influence affecting a single vertex.	
        /// </summary>	
        /// <param name="boneNum"> Index of the bone. Must be between 0 and the number of bones. </param>
        /// <param name="vertexNum"> Index of the vertex for which the bone influence is to be found. Must be between 0 and the number of vertices in the mesh. </param>
        /// <param name="influenceIndexRef"> Pointer to the index of the bone influence that affects vertexNum. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the specified bone does not influence the given vertex, S_FALSE is returned. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::FindBoneVertexInfluenceIndex([None] int boneNum,[None] int vertexNum,[None] int* pInfluenceIndex)</unmanaged>
        public SlimDX2.Result FindBoneVertexInfluenceIndex(int boneNum, int vertexNum, ref int influenceIndexRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* influenceIndexRef_ = &influenceIndexRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, boneNum, vertexNum, influenceIndexRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the maximum face influences in a triangle mesh with the specified index buffer.	
        /// </summary>	
        /// <param name="pIB"> Pointer to the index buffer that contains the mesh index data. </param>
        /// <param name="numFaces"> Number of faces in the mesh. </param>
        /// <param name="maxFaceInfluences"> Pointer to the maximum face influences. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::GetMaxFaceInfluences([None] LPDIRECT3DINDEXBUFFER9 pIB,[None] int NumFaces,[Out] int* maxFaceInfluences)</unmanaged>
        public SlimDX2.Result GetMaxFaceInfluences(SlimDX2.Direct3D9.IndexBuffer pIB, int numFaces, out int maxFaceInfluences) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* maxFaceInfluences_ = &maxFaceInfluences)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, (void*)((pIB == null)?IntPtr.Zero:pIB.NativePointer), numFaces, maxFaceInfluences_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the minimum bone influence. Influence values smaller than this are ignored.	
        /// </summary>	
        /// <param name="minInfl"> Minimum influence value. Influence values smaller than this are ignored. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::SetMinBoneInfluence([None] FLOAT MinInfl)</unmanaged>
        internal SlimDX2.Result SetMinBoneInfluence(float minInfl) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, minInfl);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the minimum bone influence. Influence values smaller than this are ignored.	
        /// </summary>	
        /// <returns>  {{FLOAT}}  Returns the minimum bone influence value. </returns>
        /// <unmanaged>FLOAT ID3DXSkinInfo::GetMinBoneInfluence()</unmanaged>
        internal float GetMinBoneInfluence() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct3D9.LocalInterop.Callifloat(_nativePointer, 13 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the bone name.	
        /// </summary>	
        /// <remarks>	
        ///  Bone names are returned by <see cref="SlimDX2.Direct3D9.D3DX9.LoadMeshFromXof"/>. 	
        /// </remarks>	
        /// <param name="bone"> Bone number </param>
        /// <param name="nameRef"> Bone name </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::SetBoneName([None] int Bone,[None] const char* pName)</unmanaged>
        public SlimDX2.Result SetBoneName(int bone, string nameRef) {
            unsafe {
                IntPtr nameRef_ = Marshal.StringToHGlobalAnsi(nameRef);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, bone, (void*)nameRef_);
                Marshal.FreeHGlobal(nameRef_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the bone name, from the bone index.	
        /// </summary>	
        /// <param name="bone"> Bone number. </param>
        /// <returns>  {{LPCSTR}}  Returns the bone name. Do not free this string. </returns>
        /// <unmanaged>const char* ID3DXSkinInfo::GetBoneName([None] int Bone)</unmanaged>
        public IntPtr GetBoneName(int bone) {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 15 * 4, bone);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the bone offset matrix.	
        /// </summary>	
        /// <remarks>	
        ///  Bone names are returned by <see cref="SlimDX2.Direct3D9.D3DX9.LoadMeshFromXof"/>. 	
        /// </remarks>	
        /// <param name="bone"> Bone number. </param>
        /// <param name="boneTransformRef"> Pointer to the bone offset matrix. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::SetBoneOffsetMatrix([None] int Bone,[None] const D3DXMATRIX* pBoneTransform)</unmanaged>
        public SlimDX2.Result SetBoneOffsetMatrix(int bone, ref SlimMath.Matrix boneTransformRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* boneTransformRef_ = &boneTransformRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, bone, boneTransformRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the bone offset matrix.	
        /// </summary>	
        /// <param name="bone"> Bone number. </param>
        /// <returns>  {{LPD3DXMATRIX}}  Returns a pointer to the bone offset matrix. Do not free this pointer. </returns>
        /// <unmanaged>LPD3DXMATRIX ID3DXSkinInfo::GetBoneOffsetMatrix([None] int Bone)</unmanaged>
        public SlimMath.Matrix GetBoneOffsetMatrix(int bone) {
            unsafe {
                SlimMath.Matrix __result__;
                SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 17 * 4,(void*)&__result__, bone);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Clones a skin info object.	
        /// </summary>	
        /// <param name="skinInfoRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.SkinInfo"/> object, which will contain the cloned object if the method is successful. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::Clone([None] LPD3DXSKININFO* ppSkinInfo)</unmanaged>
        public SlimDX2.Result Clone(out SlimDX2.Direct3D9.SkinInfo skinInfoRef) {
            unsafe {
                IntPtr skinInfoRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, &skinInfoRef_);
                skinInfoRef = (skinInfoRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.SkinInfo(skinInfoRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Updates bone influence information to match vertices after they are reordered. This method should be called if the target vertex buffer has been reordered externally.	
        /// </summary>	
        /// <remarks>	
        ///  Each element in pVertexRemap specifies the previous vertex index for that position.  For example, if a vertex was in position 3 but has been remapped to position 5, then the fifth element of pVertexRemap should contain 3.  The vertex remap array returned by <see cref="SlimDX2.Direct3D9.Mesh.Optimize"/> can be used. 	
        /// </remarks>	
        /// <param name="numVertices"> Number of vertices to remap. </param>
        /// <param name="vertexRemapRef"> Array of DWORDS whose length is specified by NumVertices. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::Remap([None] int NumVertices,[None] int* pVertexRemap)</unmanaged>
        public SlimDX2.Result Remap(int numVertices, ref int vertexRemapRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* vertexRemapRef_ = &vertexRemapRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, numVertices, vertexRemapRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the flexible vertex format (FVF) type.	
        /// </summary>	
        /// <param name="fvf"> Flexible vertex format. See <see cref="SlimDX2.Direct3D9.VertexFormat"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::SetFVF([None] int FVF)</unmanaged>
        internal SlimDX2.Result SetFVF(int fvf) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, fvf);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the vertex declaration.	
        /// </summary>	
        /// <param name="declarationRef"> Pointer to an array of <see cref="SlimDX2.Direct3D9.VertexElement"/> elements. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::SetDeclaration([None] const D3DVERTEXELEMENT9* pDeclaration)</unmanaged>
        public SlimDX2.Result SetDeclaration(ref SlimDX2.Direct3D9.VertexElement declarationRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* declarationRef_ = &declarationRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, declarationRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the fixed function vertex value.	
        /// </summary>	
        /// <remarks>	
        ///  This method can return 0 if the vertex format cannot be mapped directly to an FVF code.  This will occur for a mesh created from a vertex declaration that doesn't have the same order and elements supported by the FVF codes. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  Returns the flexible vertex format (FVF) codes. </returns>
        /// <unmanaged>int ID3DXSkinInfo::GetFVF()</unmanaged>
        internal int GetFVF() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 22 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the vertex declaration.	
        /// </summary>	
        /// <remarks>	
        ///  The array of elements includes the {{D3DDECL_END}} macro, which ends the declaration. 	
        /// </remarks>	
        /// <param name="declaration"> Array of <see cref="SlimDX2.Direct3D9.VertexElement"/> elements describing the vertex format of the mesh vertices. The upper limit of this declarator array is {{MAX_FVF_DECL_SIZE}}. The vertex element array ends with the {{D3DDECL_END}} macro.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::GetDeclaration([None] D3DVERTEXELEMENT9 Declaration[65])</unmanaged>
        public SlimDX2.Result GetDeclaration(SlimDX2.Direct3D9.VertexElement[] declaration) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* declaration_ = &declaration[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, declaration_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Applies software skinning to the target vertices based on the current matrices.	
        /// </summary>	
        /// <remarks>	
        ///  When used to skin vertices with two position elements, this method skins the second position element with the inverse of the bone instead of the bone itself. 	
        /// </remarks>	
        /// <param name="boneTransformsRef"> Bone transform matrix. </param>
        /// <param name="boneInvTransposeTransformsRef"> Inverse transpose of the bone transform matrix. </param>
        /// <param name="pVerticesSrc"> Pointer to the buffer containing the source vertices. </param>
        /// <param name="pVerticesDst"> Pointer to the buffer containing the destination vertices. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::UpdateSkinnedMesh([None] const D3DXMATRIX* pBoneTransforms,[None] const D3DXMATRIX* pBoneInvTransposeTransforms,[None] LPCVOID pVerticesSrc,[None] PVOID pVerticesDst)</unmanaged>
        public SlimDX2.Result UpdateSkinnedMesh(ref SlimMath.Matrix boneTransformsRef, ref SlimMath.Matrix boneInvTransposeTransformsRef, IntPtr pVerticesSrc, IntPtr pVerticesDst) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* boneTransformsRef_ = &boneTransformsRef)
                    fixed (void* boneInvTransposeTransformsRef_ = &boneInvTransposeTransformsRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, boneTransformsRef_, boneInvTransposeTransformsRef_, (void*)pVerticesSrc, (void*)pVerticesDst);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Takes a mesh and returns a new mesh with per-vertex blend weights and a bone combination table. The table describes which bones affect which subsets of the mesh.	
        /// </summary>	
        /// <remarks>	
        ///  Each element in the remap array specifies the previous index for that position. For example, if a vertex was in position 3 but has been remapped to position 5, then the fifth element of pVertexRemap will contain 3. This method does not run on hardware that does not support fixed-function vertex blending. 	
        /// </remarks>	
        /// <param name="pMesh"> Input mesh. See <see cref="SlimDX2.Direct3D9.Mesh"/>. </param>
        /// <param name="options"> Currently unused. </param>
        /// <param name="adjacencyInRef"> Input mesh adjacency information. </param>
        /// <param name="pAdjacencyOut"> Output mesh adjacency information. </param>
        /// <param name="faceRemapRef"> An array of DWORDs, one per face, that identifies the original mesh face that corresponds to each face in the blended mesh. If the value supplied for this argument is NULL, face remap data is not returned. </param>
        /// <param name="vertexRemapRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface, which contains a DWORD for each vertex that specifies how the new vertices map to the old vertices. This remap is useful if you need to alter external data based on the new vertex mapping. This parameter is optional; NULL may be used. </param>
        /// <param name="maxFaceInflRef"> Pointer to a DWORD that will contain the maximum number of bone influences required per vertex for this skinning method. </param>
        /// <param name="numBoneCombinationsRef"> Pointer to the number of bones in the bone combination table. </param>
        /// <param name="boneCombinationTableRef"> Pointer to the bone combination table. The data is organized in a <see cref="SlimDX2.Direct3D9.BoneCombination"/> structure. </param>
        /// <param name="meshRef"> Pointer to the new mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::ConvertToBlendedMesh([None] LPD3DXMESH pMesh,[None] int Options,[None] const int* pAdjacencyIn,[None] LPDWORD pAdjacencyOut,[None] int* pFaceRemap,[None] LPD3DXBUFFER* ppVertexRemap,[None] int* pMaxFaceInfl,[None] int* pNumBoneCombinations,[None] LPD3DXBUFFER* ppBoneCombinationTable,[None] LPD3DXMESH* ppMesh)</unmanaged>
        public SlimDX2.Result ConvertToBlendedMesh(SlimDX2.Direct3D9.Mesh pMesh, int options, ref int adjacencyInRef, ref int pAdjacencyOut, ref int faceRemapRef, out SlimDX2.Direct3D9.ShaderBytecode vertexRemapRef, ref int maxFaceInflRef, ref int numBoneCombinationsRef, out SlimDX2.Direct3D9.ShaderBytecode boneCombinationTableRef, out SlimDX2.Direct3D9.Mesh meshRef) {
            unsafe {
                IntPtr vertexRemapRef_ = IntPtr.Zero;
                IntPtr boneCombinationTableRef_ = IntPtr.Zero;
                IntPtr meshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* adjacencyInRef_ = &adjacencyInRef)
                    fixed (void* pAdjacencyOut_ = &pAdjacencyOut)
                        fixed (void* faceRemapRef_ = &faceRemapRef)
                            fixed (void* maxFaceInflRef_ = &maxFaceInflRef)
                                fixed (void* numBoneCombinationsRef_ = &numBoneCombinationsRef)
                                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4, (void*)((pMesh == null)?IntPtr.Zero:pMesh.NativePointer), options, adjacencyInRef_, pAdjacencyOut_, faceRemapRef_, &vertexRemapRef_, maxFaceInflRef_, numBoneCombinationsRef_, &boneCombinationTableRef_, &meshRef_);
                vertexRemapRef = (vertexRemapRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(vertexRemapRef_);	
                boneCombinationTableRef = (boneCombinationTableRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(boneCombinationTableRef_);	
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(meshRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Takes a mesh and returns a new mesh with per-vertex blend weights, indices, and a bone combination table. The table describes which bone palettes affect which subsets of the mesh.	
        /// </summary>	
        /// <remarks>	
        ///  Each element in the remap arrays specifies the previous index for that position. For example, if a vertex was in position 3 but has been remapped to position 5, then the fifth element of pVertexRemap will contain 3. This method does not run on hardware that does not support fixed-function vertex blending. 	
        /// </remarks>	
        /// <param name="pMesh"> The input mesh. See <see cref="SlimDX2.Direct3D9.Mesh"/>. </param>
        /// <param name="options"> Currently unused. </param>
        /// <param name="paletteSize"> Number of bone matrices available for matrix palette skinning. </param>
        /// <param name="adjacencyInRef"> Input mesh adjacency information. </param>
        /// <param name="pAdjacencyOut"> Output mesh adjacency information. </param>
        /// <param name="faceRemapRef"> An array of DWORDs, one per face, that identifies the original mesh face that corresponds to each face in the blended mesh. If the value supplied for this argument is NULL, face remap data is not returned. </param>
        /// <param name="vertexRemapRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface, which contains a DWORD for each vertex that specifies how the new vertices map to the old vertices. This remap is useful if you need to alter external data based on the new vertex mapping. This parameter is optional; NULL may be used. </param>
        /// <param name="maxVertexInflRef"> Pointer to a DWORD that will contain the maximum number of bone influences required per vertex for this skinning method. </param>
        /// <param name="numBoneCombinationsRef"> Pointer to the number of bones in the bone combination table. </param>
        /// <param name="boneCombinationTableRef"> Pointer to the bone combination table. The data is organized in a <see cref="SlimDX2.Direct3D9.BoneCombination"/> structure. </param>
        /// <param name="meshRef"> Pointer to the new mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXSkinInfo::ConvertToIndexedBlendedMesh([None] LPD3DXMESH pMesh,[None] int Options,[None] int paletteSize,[None] const int* pAdjacencyIn,[None] LPDWORD pAdjacencyOut,[None] int* pFaceRemap,[None] LPD3DXBUFFER* ppVertexRemap,[None] int* pMaxVertexInfl,[None] int* pNumBoneCombinations,[None] LPD3DXBUFFER* ppBoneCombinationTable,[None] LPD3DXMESH* ppMesh)</unmanaged>
        public SlimDX2.Result ConvertToIndexedBlendedMesh(SlimDX2.Direct3D9.Mesh pMesh, int options, int paletteSize, ref int adjacencyInRef, ref int pAdjacencyOut, ref int faceRemapRef, out SlimDX2.Direct3D9.ShaderBytecode vertexRemapRef, ref int maxVertexInflRef, ref int numBoneCombinationsRef, out SlimDX2.Direct3D9.ShaderBytecode boneCombinationTableRef, out SlimDX2.Direct3D9.Mesh meshRef) {
            unsafe {
                IntPtr vertexRemapRef_ = IntPtr.Zero;
                IntPtr boneCombinationTableRef_ = IntPtr.Zero;
                IntPtr meshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* adjacencyInRef_ = &adjacencyInRef)
                    fixed (void* pAdjacencyOut_ = &pAdjacencyOut)
                        fixed (void* faceRemapRef_ = &faceRemapRef)
                            fixed (void* maxVertexInflRef_ = &maxVertexInflRef)
                                fixed (void* numBoneCombinationsRef_ = &numBoneCombinationsRef)
                                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 26 * 4, (void*)((pMesh == null)?IntPtr.Zero:pMesh.NativePointer), options, paletteSize, adjacencyInRef_, pAdjacencyOut_, faceRemapRef_, &vertexRemapRef_, maxVertexInflRef_, numBoneCombinationsRef_, &boneCombinationTableRef_, &meshRef_);
                vertexRemapRef = (vertexRemapRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(vertexRemapRef_);	
                boneCombinationTableRef = (boneCombinationTableRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(boneCombinationTableRef_);	
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(meshRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXConstantTable</unmanaged>
    [Guid("ab3c758f-093e-4356-b762-4db18f1b3a01")]
    public partial class ConstantTable : SlimDX2.ComObject {
        public ConstantTable(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets a pointer to the buffer that contains the constant table.	
        /// </summary>	
        /// <unmanaged>void* ID3DXConstantTable::GetBufferPointer()</unmanaged>
        public IntPtr BufferPointer {
                get { return GetBufferPointer(); }
        }
        
        /// <summary>	
        /// Gets the buffer size of the constant table.	
        /// </summary>	
        /// <unmanaged>int ID3DXConstantTable::GetBufferSize()</unmanaged>
        public int BufferSize {
                get { return GetBufferSize(); }
        }
        
        /// <summary>	
        /// Gets a description of the constant table.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXConstantTable::GetDesc([Out] D3DXCONSTANTTABLE_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.ConstantTableDescription Description {
                get { SlimDX2.Direct3D9.ConstantTableDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Sets the constants to their default values. The default values are declared in the variable declarations in the shader.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXConstantTable::SetDefaults([None] LPDIRECT3DDEVICE9 pDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Defaults {
                set { SetDefaults(value); }
        }
        
        /// <summary>	
        /// Gets a pointer to the buffer that contains the constant table.	
        /// </summary>	
        /// <returns>  {{LPVOID}}  Returns a pointer the buffer. </returns>
        /// <unmanaged>void* ID3DXConstantTable::GetBufferPointer()</unmanaged>
        internal IntPtr GetBufferPointer() {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the buffer size of the constant table.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns the size of the buffer, in bytes. </returns>
        /// <unmanaged>int ID3DXConstantTable::GetBufferSize()</unmanaged>
        internal int GetBufferSize() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a description of the constant table.	
        /// </summary>	
        /// <param name="descRef"> Description of the constant table. See <see cref="SlimDX2.Direct3D9.ConstantTableDescription"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::GetDesc([Out] D3DXCONSTANTTABLE_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.ConstantTableDescription descRef) {
            unsafe {
                SlimDX2.Direct3D9.ConstantTableDescription.__Native descRef_ = new SlimDX2.Direct3D9.ConstantTableDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, &descRef_);
                descRef = new SlimDX2.Direct3D9.ConstantTableDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a pointer to an array of constant descriptions in the constant table.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXConstantTable::GetConstantDesc will sometimes return a <see cref="SlimDX2.Direct3D9.ConstantDescription"/> with a Register_Count of 0.  This will happen with a constant appears in more than one Register_Set but does not have space in that register set allocated. Because a sampler can appear more than once in a constant table, this method can return an array of descriptions, each one with a different register index. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to a constant. See {{D3DXHANDLE}}. </param>
        /// <param name="constantDescRef"> Returns a pointer to an array of descriptions. See <see cref="SlimDX2.Direct3D9.ConstantDescription"/>. </param>
        /// <param name="countRef"> The input supplied must be the maximum size of the array. The output is the number of elements that are filled in the array when the function returns. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::GetConstantDesc([None] D3DXHANDLE hConstant,[Out] D3DXCONSTANT_DESC* pConstantDesc,[Out] UINT* pCount)</unmanaged>
        public SlimDX2.Result GetConstantDescription(string hConstant, out SlimDX2.Direct3D9.ConstantDescription constantDescRef, out int countRef) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Direct3D9.ConstantDescription.__Native constantDescRef_ = new SlimDX2.Direct3D9.ConstantDescription.__Native();
                SlimDX2.Result __result__;
                fixed (void* countRef_ = &countRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)hConstant_, &constantDescRef_, countRef_);
                Marshal.FreeHGlobal(hConstant_ );
                constantDescRef = new SlimDX2.Direct3D9.ConstantDescription();
                constantDescRef.__MarshalFrom(ref constantDescRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns the sampler index.	
        /// </summary>	
        /// <param name="hConstant"> The sampler handle. </param>
        /// <returns>  {{UINT}}  Returns the sampler index number from the constant table. </returns>
        /// <unmanaged>UINT ID3DXConstantTable::GetSamplerIndex([None] D3DXHANDLE hConstant)</unmanaged>
        public int GetSamplerIndex(string hConstant) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)hConstant_);
                Marshal.FreeHGlobal(hConstant_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a constant by looking up its index.	
        /// </summary>	
        /// <remarks>	
        ///  To get a constant from an array of constants, use <see cref="SlimDX2.Direct3D9.ConstantTable.GetConstantElement"/>. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to the parent data structure. If the constant is a top-level parameter (there is no parent data structure), use NULL. </param>
        /// <param name="index"> Zero-based index of the constant. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns a unique identifier to the constant. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXConstantTable::GetConstant([None] D3DXHANDLE hConstant,[None] UINT Index)</unmanaged>
        public byte GetConstant(string hConstant, int index) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 8 * 4, (void*)hConstant_, index);
                Marshal.FreeHGlobal(hConstant_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a constant by looking up its name.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the parent data structure. If the constant is a top-level parameter (there is no parent data structure), use NULL. </param>
        /// <param name="nameRef"> Name of the constant. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns a unique identifier to the constant. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXConstantTable::GetConstantByName([None] D3DXHANDLE hConstant,[Out] const char* pName)</unmanaged>
        public byte GetConstantByName(string hConstant, IntPtr nameRef) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 9 * 4, (void*)hConstant_, (void*)nameRef);
                Marshal.FreeHGlobal(hConstant_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a constant from an array of constants. An array is made up of elements.	
        /// </summary>	
        /// <remarks>	
        ///  To get a constant that is not part of an array, use <see cref="SlimDX2.Direct3D9.ConstantTable.GetConstant"/> or <see cref="SlimDX2.Direct3D9.ConstantTable.GetConstantByName"/>. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to the array of constants.  This value may not be NULL. </param>
        /// <param name="index"> Zero-based index of the element in the array. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns a unique identifier to the element constant. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXConstantTable::GetConstantElement([None] D3DXHANDLE hConstant,[None] UINT Index)</unmanaged>
        public byte GetConstantElement(string hConstant, int index) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 10 * 4, (void*)hConstant_, index);
                Marshal.FreeHGlobal(hConstant_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the constants to their default values. The default values are declared in the variable declarations in the shader.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::SetDefaults([None] LPDIRECT3DDEVICE9 pDevice)</unmanaged>
        internal SlimDX2.Result SetDefaults(SlimDX2.Direct3D9.Device pDevice) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the contents of the buffer to the constant table.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to a constant. See {{D3DXHANDLE}}. </param>
        /// <param name="pData"> Buffer containing data. </param>
        /// <param name="bytes"> Size of the buffer, in bytes. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::SetValue([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] LPCVOID pData,[None] UINT Bytes)</unmanaged>
        public SlimDX2.Result SetValue(SlimDX2.Direct3D9.Device pDevice, string hConstant, IntPtr pData, int bytes) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, (void*)pData, bytes);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a Boolean value.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the constant. See {{D3DXHANDLE}}. </param>
        /// <param name="b"> Boolean value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::SetBool([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] BOOL b)</unmanaged>
        public SlimDX2.Result SetBool(SlimDX2.Direct3D9.Device pDevice, string hConstant, bool b) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, (b?1:0));
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of Boolean values.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the array of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="bRef"> Array of Boolean values. </param>
        /// <param name="count"> Number of Boolean values in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::SetBoolArray([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const BOOL* pb,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetBoolArray(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref bool bRef, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* bRef_ = &bRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, (bRef?1:0), count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an integer value.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the constant. See {{D3DXHANDLE}}. </param>
        /// <param name="n"> Integer. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::SetInt([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] INT n)</unmanaged>
        public SlimDX2.Result SetInt(SlimDX2.Direct3D9.Device pDevice, string hConstant, int n) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, n);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of integers.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the array of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="nRef"> Array of integers. </param>
        /// <param name="count"> Number of integers in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::SetIntArray([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const INT* pn,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetIntArray(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref int nRef, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* nRef_ = &nRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, nRef_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a floating-point number.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the constant. See {{D3DXHANDLE}}. </param>
        /// <param name="f"> Floating-point number. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::SetFloat([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] FLOAT f)</unmanaged>
        public SlimDX2.Result SetFloat(SlimDX2.Direct3D9.Device pDevice, string hConstant, float f) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, f);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of floating-point numbers.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the array of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="fRef"> Array of floating-point numbers. </param>
        /// <param name="count"> Number of floating-point values in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::SetFloatArray([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const FLOAT* pf,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetFloatArray(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref float fRef, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* fRef_ = &fRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, fRef_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a 4D vector.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the vector constant. See {{D3DXHANDLE}}. </param>
        /// <param name="vectorRef"> Pointer to a 4D vector. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::SetVector([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const D3DXVECTOR4* pVector)</unmanaged>
        public SlimDX2.Result SetVector(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref SlimMath.Vector4 vectorRef) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* vectorRef_ = &vectorRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, vectorRef_);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of 4D vectors.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the array of vector constants. See {{D3DXHANDLE}}. </param>
        /// <param name="vectorRef"> Array of 4D vectors. </param>
        /// <param name="count"> Number of vectors in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::SetVectorArray([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const D3DXVECTOR4* pVector,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetVectorArray(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref SlimMath.Vector4 vectorRef, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* vectorRef_ = &vectorRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, vectorRef_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a nontransposed matrix.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the matrix of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="matrixRef"> Pointer to a nontransposed matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::SetMatrix([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const D3DXMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result SetMatrix(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref SlimMath.Matrix matrixRef) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, matrixRef_);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of nontransposed matrices.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the array of constant matrices. See {{D3DXHANDLE}}. </param>
        /// <param name="matrixRef"> Array of nontransposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::SetMatrixArray([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const D3DXMATRIX* pMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixArray(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref SlimMath.Matrix matrixRef, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 22 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, matrixRef_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of pointers to nontransposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A nontransposed matrix contains row-major data; that is, each vector is contained in a row. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to an array of constant matrices. See {{D3DXHANDLE}}. </param>
        /// <param name="matrixRef"> Array of pointers to nontransposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::SetMatrixPointerArray([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const D3DXMATRIX** ppMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixPointerArray(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref SlimMath.Matrix matrixRef, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, matrixRef_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a transposed matrix.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the matrix of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="matrixRef"> Pointer to a transposed matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::SetMatrixTranspose([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const D3DXMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result SetMatrixTranspose(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref SlimMath.Matrix matrixRef) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, matrixRef_);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of transposed matrices.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the array of matrix constants. See {{D3DXHANDLE}}. </param>
        /// <param name="matrixRef"> Array of transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::SetMatrixTransposeArray([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const D3DXMATRIX* pMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixTransposeArray(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref SlimMath.Matrix matrixRef, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, matrixRef_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of pointers to transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the array of matrix constants. See {{D3DXHANDLE}}. </param>
        /// <param name="matrixRef"> Array of pointers to transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXConstantTable::SetMatrixTransposePointerArray([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const D3DXMATRIX** ppMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixTransposePointerArray(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref SlimMath.Matrix matrixRef, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 26 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, matrixRef_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXTextureShader</unmanaged>
    [Guid("3e3d67f8-aa7a-405d-a857-ba01d4758426")]
    public partial class TextureShader : SlimDX2.ComObject {
        public TextureShader(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets a pointer to the function DWORD stream.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXTextureShader::GetFunction([Out] LPD3DXBUFFER* ppFunction)</unmanaged>
        public SlimDX2.Direct3D9.ShaderBytecode Function {
                get { SlimDX2.Direct3D9.ShaderBytecode __output__; GetFunction(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a pointer to the constant table.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXTextureShader::GetConstantBuffer([Out] LPD3DXBUFFER* ppConstantBuffer)</unmanaged>
        public SlimDX2.Direct3D9.ShaderBytecode ConstantBuffer {
                get { SlimDX2.Direct3D9.ShaderBytecode __output__; GetConstantBuffer(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets a description of the constant table.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXTextureShader::GetDesc([Out] D3DXCONSTANTTABLE_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.ConstantTableDescription Description {
                get { SlimDX2.Direct3D9.ConstantTableDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets a pointer to the function DWORD stream.	
        /// </summary>	
        /// <param name="functionRef"> A pointer to the function DWORD stream. See <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::GetFunction([Out] LPD3DXBUFFER* ppFunction)</unmanaged>
        internal SlimDX2.Result GetFunction(out SlimDX2.Direct3D9.ShaderBytecode functionRef) {
            unsafe {
                IntPtr functionRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &functionRef_);
                functionRef = (functionRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(functionRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a pointer to the constant table.	
        /// </summary>	
        /// <param name="constantBufferRef"> Pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface, which contains the constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::GetConstantBuffer([Out] LPD3DXBUFFER* ppConstantBuffer)</unmanaged>
        internal SlimDX2.Result GetConstantBuffer(out SlimDX2.Direct3D9.ShaderBytecode constantBufferRef) {
            unsafe {
                IntPtr constantBufferRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, &constantBufferRef_);
                constantBufferRef = (constantBufferRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(constantBufferRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a description of the constant table.	
        /// </summary>	
        /// <param name="descRef"> The attributes of the constant table. See <see cref="SlimDX2.Direct3D9.ConstantTableDescription"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::GetDesc([Out] D3DXCONSTANTTABLE_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.ConstantTableDescription descRef) {
            unsafe {
                SlimDX2.Direct3D9.ConstantTableDescription.__Native descRef_ = new SlimDX2.Direct3D9.ConstantTableDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, &descRef_);
                descRef = new SlimDX2.Direct3D9.ConstantTableDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a pointer to the array of constants in the constant table.	
        /// </summary>	
        /// <remarks>	
        ///  Samplers can appear more than once in a constant table, therefore, this method can return an array of descriptions each with a different register index. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to a constant. See {{D3DXHANDLE}}. </param>
        /// <param name="constantDescRef"> Returns a pointer to an array of descriptions. See <see cref="SlimDX2.Direct3D9.ConstantDescription"/>. </param>
        /// <param name="countRef"> The input supplied must be the maximum size of the array. The output is the number of elements that are filled in the array when the function returns. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::GetConstantDesc([None] D3DXHANDLE hConstant,[Out] D3DXCONSTANT_DESC* pConstantDesc,[Out] UINT* pCount)</unmanaged>
        public SlimDX2.Result GetConstantDescription(string hConstant, out SlimDX2.Direct3D9.ConstantDescription constantDescRef, out int countRef) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Direct3D9.ConstantDescription.__Native constantDescRef_ = new SlimDX2.Direct3D9.ConstantDescription.__Native();
                SlimDX2.Result __result__;
                fixed (void* countRef_ = &countRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)hConstant_, &constantDescRef_, countRef_);
                Marshal.FreeHGlobal(hConstant_ );
                constantDescRef = new SlimDX2.Direct3D9.ConstantDescription();
                constantDescRef.__MarshalFrom(ref constantDescRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a constant by looking up its index.	
        /// </summary>	
        /// <remarks>	
        ///  To get a constant from an array of constants, use <see cref="SlimDX2.Direct3D9.TextureShader.GetConstantElement"/>. 	
        /// </remarks>	
        /// <param name="hConstant"> A {{handle}} to the parent data structure. If the constant is a top-level parameter (there is no parent data structure), use NULL. </param>
        /// <param name="index"> Zero-based index of the constant. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns a unique identifier to the constant. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXTextureShader::GetConstant([None] D3DXHANDLE hConstant,[None] UINT Index)</unmanaged>
        public byte GetConstant(string hConstant, int index) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 7 * 4, (void*)hConstant_, index);
                Marshal.FreeHGlobal(hConstant_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a constant by looking up its name.	
        /// </summary>	
        /// <param name="hConstant"> A {{handle}} to the parent data structure. If the constant is a top-level parameter (there is no parent data structure), use NULL. </param>
        /// <param name="nameRef"> A string containing the name of the constant. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns a unique identifier to the constant. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXTextureShader::GetConstantByName([None] D3DXHANDLE hConstant,[Out] const char* pName)</unmanaged>
        public byte GetConstantByName(string hConstant, IntPtr nameRef) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 8 * 4, (void*)hConstant_, (void*)nameRef);
                Marshal.FreeHGlobal(hConstant_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a constant from the constant table.	
        /// </summary>	
        /// <remarks>	
        ///  To get a constant that is not part of an array, use <see cref="SlimDX2.Direct3D9.TextureShader.GetConstant"/> or <see cref="SlimDX2.Direct3D9.TextureShader.GetConstantByName"/>. 	
        /// </remarks>	
        /// <param name="hConstant"> A {{handle}} to the array of constants.  This value may not be NULL. </param>
        /// <param name="index"> Zero-based index of the element in the constant table. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns a unique identifier to the constant. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXTextureShader::GetConstantElement([None] D3DXHANDLE hConstant,[None] UINT Index)</unmanaged>
        public byte GetConstantElement(string hConstant, int index) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 9 * 4, (void*)hConstant_, index);
                Marshal.FreeHGlobal(hConstant_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the constants to the default values declared in the shader.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::SetDefaults()</unmanaged>
        public SlimDX2.Result SetDefaults() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the constant table with the data in the buffer.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to a constant. See {{D3DXHANDLE}}. </param>
        /// <param name="pData"> A pointer to a buffer containing the constant data. </param>
        /// <param name="bytes"> Size of the buffer, in bytes. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::SetValue([None] D3DXHANDLE hConstant,[None] LPCVOID pData,[None] UINT Bytes)</unmanaged>
        public SlimDX2.Result SetValue(string hConstant, IntPtr pData, int bytes) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, (void*)hConstant_, (void*)pData, bytes);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a BOOL value.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the constant. See {{D3DXHANDLE}}. </param>
        /// <param name="b"> BOOL value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::SetBool([None] D3DXHANDLE hConstant,[None] BOOL b)</unmanaged>
        public SlimDX2.Result SetBool(string hConstant, bool b) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, (void*)hConstant_, (b?1:0));
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of BOOL values.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the array of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="bRef"> Array of BOOL values. </param>
        /// <param name="count"> Number of BOOL values in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::SetBoolArray([None] D3DXHANDLE hConstant,[None] const BOOL* pb,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetBoolArray(string hConstant, ref bool bRef, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* bRef_ = &bRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, (void*)hConstant_, (bRef?1:0), count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an integer value.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the constant. See {{D3DXHANDLE}}. </param>
        /// <param name="n"> Integer value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::SetInt([None] D3DXHANDLE hConstant,[None] INT n)</unmanaged>
        public SlimDX2.Result SetInt(string hConstant, int n) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, (void*)hConstant_, n);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of integers.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the array of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="nRef"> Array of integers. </param>
        /// <param name="count"> Number of integers in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::SetIntArray([None] D3DXHANDLE hConstant,[None] const INT* pn,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetIntArray(string hConstant, ref int nRef, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* nRef_ = &nRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, (void*)hConstant_, nRef_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a floating-point number.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the constant. See {{D3DXHANDLE}}. </param>
        /// <param name="f"> Floating-point number. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::SetFloat([None] D3DXHANDLE hConstant,[None] FLOAT f)</unmanaged>
        public SlimDX2.Result SetFloat(string hConstant, float f) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, (void*)hConstant_, f);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of floating-point numbers.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the array of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="fRef"> Array of floating-point numbers. </param>
        /// <param name="count"> Number of floating-point values in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::SetFloatArray([None] D3DXHANDLE hConstant,[None] const FLOAT* pf,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetFloatArray(string hConstant, ref float fRef, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* fRef_ = &fRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, (void*)hConstant_, fRef_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a 4D vector.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the vector constant. See {{D3DXHANDLE}}. </param>
        /// <param name="vectorRef"> Pointer to a 4D vector. See <see cref="SlimMath.Vector4"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::SetVector([None] D3DXHANDLE hConstant,[None] const D3DXVECTOR4* pVector)</unmanaged>
        public SlimDX2.Result SetVector(string hConstant, ref SlimMath.Vector4 vectorRef) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* vectorRef_ = &vectorRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, (void*)hConstant_, vectorRef_);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of 4D vectors.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the array of vector constants. See {{D3DXHANDLE}}. </param>
        /// <param name="vectorRef"> Array of 4D vectors. See <see cref="SlimMath.Vector4"/>. </param>
        /// <param name="count"> Number of vectors in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::SetVectorArray([None] D3DXHANDLE hConstant,[None] const D3DXVECTOR4* pVector,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetVectorArray(string hConstant, ref SlimMath.Vector4 vectorRef, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* vectorRef_ = &vectorRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, (void*)hConstant_, vectorRef_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a non-transposed matrix.	
        /// </summary>	
        /// <remarks>	
        ///  A non-transposed matrix contains row-major data; that is, each vector is contained in a row. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to the matrix of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="matrixRef"> Pointer to a non-transposed matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::SetMatrix([None] D3DXHANDLE hConstant,[None] const D3DXMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result SetMatrix(string hConstant, ref SlimMath.Matrix matrixRef) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, (void*)hConstant_, matrixRef_);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of non-transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A non-transposed matrix contains row-major data; that is, each vector is contained in a row. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to the array of constant matrices. See {{D3DXHANDLE}}. </param>
        /// <param name="matrixRef"> Array of non-transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::SetMatrixArray([None] D3DXHANDLE hConstant,[None] const D3DXMATRIX* pMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixArray(string hConstant, ref SlimMath.Matrix matrixRef, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, (void*)hConstant_, matrixRef_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of pointers to non-transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A non-transposed matrix contains row-major data; that is, each vector is contained in a row. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to an array of constant matrices. See {{D3DXHANDLE}}. </param>
        /// <param name="matrixRef"> Array of pointers to non-transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::SetMatrixPointerArray([None] D3DXHANDLE hConstant,[None] const D3DXMATRIX** ppMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixPointerArray(string hConstant, ref SlimMath.Matrix matrixRef, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 22 * 4, (void*)hConstant_, matrixRef_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a transposed matrix.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to the matrix of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="matrixRef"> Pointer to a transposed matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::SetMatrixTranspose([None] D3DXHANDLE hConstant,[None] const D3DXMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result SetMatrixTranspose(string hConstant, ref SlimMath.Matrix matrixRef) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, (void*)hConstant_, matrixRef_);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to the array of matrix constants. See {{D3DXHANDLE}}. </param>
        /// <param name="matrixRef"> Array of transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::SetMatrixTransposeArray([None] D3DXHANDLE hConstant,[None] const D3DXMATRIX* pMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixTransposeArray(string hConstant, ref SlimMath.Matrix matrixRef, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, (void*)hConstant_, matrixRef_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of pointers to transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to the array of matrix constants. See {{D3DXHANDLE}}. </param>
        /// <param name="matrixRef"> Array of pointers to transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXTextureShader::SetMatrixTransposePointerArray([None] D3DXHANDLE hConstant,[None] const D3DXMATRIX** ppMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixTransposePointerArray(string hConstant, ref SlimMath.Matrix matrixRef, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4, (void*)hConstant_, matrixRef_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXInclude</unmanaged>
    public partial class Include : SlimDX2.CppObject {
        public Include(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// A user-implemented method for opening and reading the contents of a shader #include file.	
        /// </summary>	
        /// <param name="includeType"> The location of the #include file. See <see cref="SlimDX2.Direct3D9.IncludeType"/>. </param>
        /// <param name="fileNameRef"> Name of the #include file. </param>
        /// <param name="pParentData"> Pointer to the container that includes the #include file. </param>
        /// <param name="dataRef"> Pointer to the returned buffer that contains the include directives. This pointer remains valid until <see cref="SlimDX2.Direct3D9.Include.Close"/> is called. </param>
        /// <param name="bytesRef"> Number of bytes returned in ppData. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when reading the #include file, the API that caused the callback to be called will fail. This is one of the following:  The HLSL shader will fail one of the D3DXCompileShader*** functions. The assembly shader will fail one of the D3DXAssembleShader*** functions. The effect will fail one of the D3DXCreateEffect*** or D3DXCreateEffectCompiler*** functions.  </returns>
        /// <unmanaged>HRESULT ID3DXInclude::Open([None] D3DXINCLUDE_TYPE IncludeType,[None] const char* pFileName,[None] LPCVOID pParentData,[None] LPCVOID* ppData,[None] UINT* pBytes)</unmanaged>
        public SlimDX2.Result Open(SlimDX2.Direct3D9.IncludeType includeType, string fileNameRef, IntPtr pParentData, IntPtr dataRef, ref int bytesRef) {
            unsafe {
                IntPtr fileNameRef_ = Marshal.StringToHGlobalAnsi(fileNameRef);
                SlimDX2.Result __result__;
                fixed (void* bytesRef_ = &bytesRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 0 * 4, unchecked((int)includeType), (void*)fileNameRef_, (void*)pParentData, (void*)dataRef, bytesRef_);
                Marshal.FreeHGlobal(fileNameRef_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A user-implemented method for closing a shader #include file.	
        /// </summary>	
        /// <remarks>	
        ///   If <see cref="SlimDX2.Direct3D9.Include.Open"/> was successful, ID3DXInclude::Close is guaranteed to be called before the API using this interface returns. 	
        /// </remarks>	
        /// <param name="pData"> Pointer to the returned buffer that contains the include directives. This is the pointer that was returned by the corresponding <see cref="SlimDX2.Direct3D9.Include.Open"/> call. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when reading the #include file, the API that caused the callback to be called will fail. This is one of the following:  The HLSL shader will fail one of the D3DXCompileShader*** functions. The assembly shader will fail one of the D3DXAssembleShader*** functions. The effect will fail one of the D3DXCreateEffect*** or D3DXCreateEffectCompiler*** functions.  </returns>
        /// <unmanaged>HRESULT ID3DXInclude::Close([None] LPCVOID pData)</unmanaged>
        public SlimDX2.Result Close(IntPtr pData) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 1 * 4, (void*)pData);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXEffectPool</unmanaged>
    [Guid("9537ab04-3250-412e-8213-fcd2f8677933")]
    public partial class EffectPool : SlimDX2.ComObject {
        public EffectPool(IntPtr basePtr) : base(basePtr) {
        }
        
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXBaseEffect</unmanaged>
    [Guid("017c18ac-103f-4417-8c51-6bf6ef1e56be")]
    public partial class BaseEffect : SlimDX2.ComObject {
        public BaseEffect(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the effect description.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetDesc([Out] D3DXEFFECT_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.EffectDescription Description {
                get { SlimDX2.Direct3D9.EffectDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the effect description.	
        /// </summary>	
        /// <param name="descRef"> Returns a description of the effect. See <see cref="SlimDX2.Direct3D9.EffectDescription"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetDesc([Out] D3DXEFFECT_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.EffectDescription descRef) {
            unsafe {
                SlimDX2.Direct3D9.EffectDescription.__Native descRef_ = new SlimDX2.Direct3D9.EffectDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &descRef_);
                descRef = new SlimDX2.Direct3D9.EffectDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a parameter or annotation description.	
        /// </summary>	
        /// <param name="hParameter"> Parameter or annotation handle. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="descRef"> Returns a description of the specified parameter or annotation. See <see cref="SlimDX2.Direct3D9.ParameterDescription"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetParameterDesc([None] D3DXHANDLE hParameter,[Out] D3DXPARAMETER_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetParameterDescription(string hParameter, out SlimDX2.Direct3D9.ParameterDescription descRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Direct3D9.ParameterDescription.__Native descRef_ = new SlimDX2.Direct3D9.ParameterDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)hParameter_, &descRef_);
                Marshal.FreeHGlobal(hParameter_ );
                descRef = new SlimDX2.Direct3D9.ParameterDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a technique description.	
        /// </summary>	
        /// <param name="hTechnique"> Technique handle. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="descRef"> Returns a description of the technique. See <see cref="SlimDX2.Direct3D9.TechniqueDescription"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetTechniqueDesc([None] D3DXHANDLE hTechnique,[Out] D3DXTECHNIQUE_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetTechniqueDescription(string hTechnique, out SlimDX2.Direct3D9.TechniqueDescription descRef) {
            unsafe {
                IntPtr hTechnique_ = Marshal.StringToHGlobalAnsi(hTechnique);
                SlimDX2.Direct3D9.TechniqueDescription.__Native descRef_ = new SlimDX2.Direct3D9.TechniqueDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)hTechnique_, &descRef_);
                Marshal.FreeHGlobal(hTechnique_ );
                descRef = new SlimDX2.Direct3D9.TechniqueDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a pass description.	
        /// </summary>	
        /// <remarks>	
        ///  Note??If an effect is created with {{D3DXFX_NOT_CLONEABLE}}, this method will return NULL pointers (in <see cref="SlimDX2.Direct3D9.PassDescription"/>) to the shader functions. 	
        /// </remarks>	
        /// <param name="hPass"> Pass handle. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="descRef"> Returns a description of the specified pass. See <see cref="SlimDX2.Direct3D9.PassDescription"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetPassDesc([None] D3DXHANDLE hPass,[Out] D3DXPASS_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetPassDescription(string hPass, out SlimDX2.Direct3D9.PassDescription descRef) {
            unsafe {
                IntPtr hPass_ = Marshal.StringToHGlobalAnsi(hPass);
                SlimDX2.Direct3D9.PassDescription.__Native descRef_ = new SlimDX2.Direct3D9.PassDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)hPass_, &descRef_);
                Marshal.FreeHGlobal(hPass_ );
                descRef = new SlimDX2.Direct3D9.PassDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a function description.	
        /// </summary>	
        /// <param name="hShader"> Function handle. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="descRef"> Returns a description of the function. See <see cref="SlimDX2.Direct3D9.FunctionDescription"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetFunctionDesc([None] D3DXHANDLE hShader,[Out] D3DXFUNCTION_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetFunctionDescription(string hShader, out SlimDX2.Direct3D9.FunctionDescription descRef) {
            unsafe {
                IntPtr hShader_ = Marshal.StringToHGlobalAnsi(hShader);
                SlimDX2.Direct3D9.FunctionDescription.__Native descRef_ = new SlimDX2.Direct3D9.FunctionDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)hShader_, &descRef_);
                Marshal.FreeHGlobal(hShader_ );
                descRef = new SlimDX2.Direct3D9.FunctionDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a top-level parameter or a structure member parameter.	
        /// </summary>	
        /// <param name="hParameter"> Handle of the parameter, or NULL for top-level parameters. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="index"> Parameter index. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified parameter, or NULL if the index was invalid. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetParameter([None] D3DXHANDLE hParameter,[None] UINT Index)</unmanaged>
        public byte GetParameter(string hParameter, int index) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 8 * 4, (void*)hParameter_, index);
                Marshal.FreeHGlobal(hParameter_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a top-level parameter or a structure member parameter by looking up its name.	
        /// </summary>	
        /// <param name="hParameter"> Handle of the parameter, or NULL for top-level parameters. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="nameRef"> String containing the parameter name. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified parameter, or NULL if the index was invalid. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetParameterByName([None] D3DXHANDLE hParameter,[Out] const char* pName)</unmanaged>
        public byte GetParameterByName(string hParameter, IntPtr nameRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 9 * 4, (void*)hParameter_, (void*)nameRef);
                Marshal.FreeHGlobal(hParameter_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a top-level parameter or a structure member parameter by looking up its semantic with a case-insensitive search.	
        /// </summary>	
        /// <param name="hParameter"> Handle of the parameter, or NULL for top-level parameters. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="semanticRef"> String containing the semantic name. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the first parameter that matches the specified semantic, or NULL if the semantic was not found. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetParameterBySemantic([None] D3DXHANDLE hParameter,[Out] const char* pSemantic)</unmanaged>
        public byte GetParameterBySemantic(string hParameter, IntPtr semanticRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 10 * 4, (void*)hParameter_, (void*)semanticRef);
                Marshal.FreeHGlobal(hParameter_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the handle of an array element parameter.	
        /// </summary>	
        /// <remarks>	
        ///  This method is used to get an element of a parameter that is an array. 	
        /// </remarks>	
        /// <param name="hParameter"> Handle of the array. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="index"> Array element index. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified parameter, or NULL if either hParameter or ElementIndex is invalid.  See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetParameterElement([None] D3DXHANDLE hParameter,[None] UINT Index)</unmanaged>
        public byte GetParameterElement(string hParameter, int index) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 11 * 4, (void*)hParameter_, index);
                Marshal.FreeHGlobal(hParameter_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a technique.	
        /// </summary>	
        /// <param name="index"> Technique index. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified technique, or NULL if the index was invalid. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetTechnique([None] UINT Index)</unmanaged>
        public byte GetTechnique(int index) {
            unsafe {
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 12 * 4, index);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a technique by looking up its name.	
        /// </summary>	
        /// <param name="nameRef"> String containing the technique name. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the first technique that has the specified name, or NULL if the name was not found. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetTechniqueByName([None] const char* pName)</unmanaged>
        public byte GetTechniqueByName(string nameRef) {
            unsafe {
                IntPtr nameRef_ = Marshal.StringToHGlobalAnsi(nameRef);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 13 * 4, (void*)nameRef_);
                Marshal.FreeHGlobal(nameRef_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a pass.	
        /// </summary>	
        /// <param name="hTechnique"> Handle of the parent technique. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="index"> Index for the pass. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified pass inside the specified technique, or NULL if the index was invalid. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetPass([None] D3DXHANDLE hTechnique,[None] UINT Index)</unmanaged>
        public byte GetPass(string hTechnique, int index) {
            unsafe {
                IntPtr hTechnique_ = Marshal.StringToHGlobalAnsi(hTechnique);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 14 * 4, (void*)hTechnique_, index);
                Marshal.FreeHGlobal(hTechnique_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a pass by looking up its name.	
        /// </summary>	
        /// <param name="hTechnique"> Handle of the parent technique. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="nameRef"> String containing the pass name. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the first pass inside the specified technique that has the specified name, or NULL if the name was not found. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetPassByName([None] D3DXHANDLE hTechnique,[Out] const char* pName)</unmanaged>
        public byte GetPassByName(string hTechnique, IntPtr nameRef) {
            unsafe {
                IntPtr hTechnique_ = Marshal.StringToHGlobalAnsi(hTechnique);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 15 * 4, (void*)hTechnique_, (void*)nameRef);
                Marshal.FreeHGlobal(hTechnique_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a function.	
        /// </summary>	
        /// <param name="index"> Function index. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified function, or NULL if the index was invalid. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetFunction([None] UINT Index)</unmanaged>
        public byte GetFunction(int index) {
            unsafe {
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 16 * 4, index);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a function by looking up its name.	
        /// </summary>	
        /// <param name="nameRef"> String containing the function name.  </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified function, or NULL if the name was not found. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetFunctionByName([None] const char* pName)</unmanaged>
        public byte GetFunctionByName(string nameRef) {
            unsafe {
                IntPtr nameRef_ = Marshal.StringToHGlobalAnsi(nameRef);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 17 * 4, (void*)nameRef_);
                Marshal.FreeHGlobal(nameRef_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of an annotation. 	
        /// </summary>	
        /// <remarks>	
        ///  Annotations are user-specific data that can be attached to any technique, pass, or parameter. See {{Handles (Direct3D 9)}}.  	
        /// </remarks>	
        /// <param name="hObject"> Handle of a technique, pass, or top-level parameter. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="index"> Annotation index. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified annotation, or NULL if the index was invalid. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetAnnotation([None] D3DXHANDLE hObject,[None] UINT Index)</unmanaged>
        public byte GetAnnotation(string hObject, int index) {
            unsafe {
                IntPtr hObject_ = Marshal.StringToHGlobalAnsi(hObject);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 18 * 4, (void*)hObject_, index);
                Marshal.FreeHGlobal(hObject_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of an annotation by looking up its name.	
        /// </summary>	
        /// <param name="hObject"> Handle of a technique, pass, or top-level parameter. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="nameRef"> String containing the annotation name. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified annotation, or NULL if the name was not found. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetAnnotationByName([None] D3DXHANDLE hObject,[Out] const char* pName)</unmanaged>
        public byte GetAnnotationByName(string hObject, IntPtr nameRef) {
            unsafe {
                IntPtr hObject_ = Marshal.StringToHGlobalAnsi(hObject);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 19 * 4, (void*)hObject_, (void*)nameRef);
                Marshal.FreeHGlobal(hObject_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set the value of an arbitrary parameter or annotation, including simple types, structs, arrays, strings, shaders and textures. 	
        /// </summary>	
        /// <remarks>	
        ///  This method can be used in place of nearly all the effect set API calls. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pData"> Pointer to a buffer containing data. </param>
        /// <param name="bytes"> [in] Number of bytes in the buffer. Pass in D3DX_DEFAULT if you know your buffer is large enough to contain the entire parameter, and you want to skip size validation. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetValue([None] D3DXHANDLE hParameter,[None] LPCVOID pData,[None] UINT Bytes)</unmanaged>
        public SlimDX2.Result SetValue(string hParameter, IntPtr pData, int bytes) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, (void*)hParameter_, (void*)pData, bytes);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the value of an arbitrary parameter or annotation, including simple types, structs, arrays, strings, shaders and textures. This method can be used in place of nearly all the Getxxx calls in <see cref="SlimDX2.Direct3D9.BaseEffect"/>.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="dataRef"> Returns a buffer containing the value. </param>
        /// <param name="bytes"> [in] Number of bytes in the buffer. Pass in D3DX_DEFAULT if you know your buffer is large enough to contain the entire parameter, and you want to skip size validation. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetValue([None] D3DXHANDLE hParameter,[None] void* pData,[None] UINT Bytes)</unmanaged>
        public SlimDX2.Result GetValue(string hParameter, IntPtr dataRef, int bytes) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, (void*)hParameter_, (void*)dataRef, bytes);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a BOOL value.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="b"> Boolean value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetBool([None] D3DXHANDLE hParameter,[None] BOOL b)</unmanaged>
        public SlimDX2.Result SetBool(string hParameter, bool b) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 22 * 4, (void*)hParameter_, (b?1:0));
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a BOOL value.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="bRef"> Returns a Boolean value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetBool([None] D3DXHANDLE hParameter,[Out] BOOL* pb)</unmanaged>
        public SlimDX2.Result GetBool(string hParameter, out bool bRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* bRef_ = &bRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, (void*)hParameter_, bRef_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of Boolean values.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="bRef"> Array of Boolean values. </param>
        /// <param name="count"> Number of Boolean values in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetBoolArray([None] D3DXHANDLE hParameter,[None] const BOOL* pb,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetBoolArray(string hParameter, ref bool bRef, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* bRef_ = &bRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, (void*)hParameter_, (bRef?1:0), count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an array of BOOL values.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="bRef"> Returns an array of Boolean values. </param>
        /// <param name="count"> Number of Boolean values in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetBoolArray([None] D3DXHANDLE hParameter,[Out] BOOL* pb,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetBoolArray(string hParameter, out bool bRef, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* bRef_ = &bRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4, (void*)hParameter_, bRef_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an integer.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="n"> Integer value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetInt([None] D3DXHANDLE hParameter,[None] INT n)</unmanaged>
        public SlimDX2.Result SetInt(string hParameter, int n) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 26 * 4, (void*)hParameter_, n);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an integer.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="nRef"> Returns an integer. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetInt([None] D3DXHANDLE hParameter,[Out] INT* pn)</unmanaged>
        public SlimDX2.Result GetInt(string hParameter, out int nRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* nRef_ = &nRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 27 * 4, (void*)hParameter_, nRef_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of integers.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="nRef"> Array of integers. </param>
        /// <param name="count"> Number of integers in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetIntArray([None] D3DXHANDLE hParameter,[None] const INT* pn,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetIntArray(string hParameter, ref int nRef, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* nRef_ = &nRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 28 * 4, (void*)hParameter_, nRef_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an array of integers.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="nRef"> Returns an array of integers. </param>
        /// <param name="count"> Number of integers in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetIntArray([None] D3DXHANDLE hParameter,[Out] INT* pn,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetIntArray(string hParameter, out int nRef, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* nRef_ = &nRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 29 * 4, (void*)hParameter_, nRef_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a floating point value.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="f"> Floating point value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetFloat([None] D3DXHANDLE hParameter,[None] FLOAT f)</unmanaged>
        public SlimDX2.Result SetFloat(string hParameter, float f) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 30 * 4, (void*)hParameter_, f);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a floating point value.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="fRef"> Returns a floating point value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetFloat([None] D3DXHANDLE hParameter,[Out] FLOAT* pf)</unmanaged>
        public SlimDX2.Result GetFloat(string hParameter, out float fRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* fRef_ = &fRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 31 * 4, (void*)hParameter_, fRef_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of floating point values.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="fRef"> Array of floating point values. </param>
        /// <param name="count"> Number of floating point values in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetFloatArray([None] D3DXHANDLE hParameter,[None] const FLOAT* pf,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetFloatArray(string hParameter, ref float fRef, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* fRef_ = &fRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 32 * 4, (void*)hParameter_, fRef_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an array of floating point values.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="fRef"> Returns an array of floating point values. </param>
        /// <param name="count"> Number of floating point values in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetFloatArray([None] D3DXHANDLE hParameter,[Out] FLOAT* pf,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetFloatArray(string hParameter, out float fRef, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* fRef_ = &fRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 33 * 4, (void*)hParameter_, fRef_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a vector.	
        /// </summary>	
        /// <remarks>	
        ///  If the destination vector is smaller than the source vector, the additional components of the source vector will be ignored. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="vectorRef"> Pointer to a 4D vector. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetVector([None] D3DXHANDLE hParameter,[None] const D3DXVECTOR4* pVector)</unmanaged>
        public SlimDX2.Result SetVector(string hParameter, ref SlimMath.Vector4 vectorRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* vectorRef_ = &vectorRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 34 * 4, (void*)hParameter_, vectorRef_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a vector.	
        /// </summary>	
        /// <remarks>	
        ///  If the destination vector is larger than the source vector, only the initial components of the destination vector will be filled, and the remaining components will be set to zero. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="vectorRef"> Returns a 4D vector. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetVector([None] D3DXHANDLE hParameter,[Out] D3DXVECTOR4* pVector)</unmanaged>
        public SlimDX2.Result GetVector(string hParameter, out SlimMath.Vector4 vectorRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                vectorRef = new SlimMath.Vector4();
                SlimDX2.Result __result__;
                fixed (void* vectorRef_ = &vectorRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 35 * 4, (void*)hParameter_, vectorRef_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of vectors.	
        /// </summary>	
        /// <remarks>	
        ///  If the destination vectors are smaller than the source vectors, the additional components of the source vectors will be ignored. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="vectorRef"> Array of 4D floating point vectors. </param>
        /// <param name="count"> Number of vectors in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetVectorArray([None] D3DXHANDLE hParameter,[None] const D3DXVECTOR4* pVector,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetVectorArray(string hParameter, ref SlimMath.Vector4 vectorRef, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* vectorRef_ = &vectorRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 36 * 4, (void*)hParameter_, vectorRef_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an array of vectors.	
        /// </summary>	
        /// <remarks>	
        ///  If the destination vectors are larger than the source vectors, only the initial components of each destination vector will be filled, and the remaining destination vector components will be set to zero. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="vectorRef"> Returns an array of 4D floating point vectors. </param>
        /// <param name="count"> Number of vectors in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetVectorArray([None] D3DXHANDLE hParameter,[Out] D3DXVECTOR4* pVector,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetVectorArray(string hParameter, out SlimMath.Vector4 vectorRef, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                vectorRef = new SlimMath.Vector4();
                SlimDX2.Result __result__;
                fixed (void* vectorRef_ = &vectorRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 37 * 4, (void*)hParameter_, vectorRef_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a non-transposed matrix.	
        /// </summary>	
        /// <remarks>	
        ///  A non-transposed matrix contains row-major data. In other words, each vector is contained in a row. If the destination matrix is smaller than the source matrix, the additional components of the source matrix will be ignored. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="matrixRef"> Pointer to a nontransposed matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetMatrix([None] D3DXHANDLE hParameter,[None] const D3DXMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result SetMatrix(string hParameter, ref SlimMath.Matrix matrixRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 38 * 4, (void*)hParameter_, matrixRef_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a nontransposed matrix.	
        /// </summary>	
        /// <remarks>	
        ///  A nontransposed matrix contains row-major data; that is, each vector is contained in a row. If the destination matrix is larger than the source matrix, only the upper-left components of the destination matrix will be filled, and the remaining components will be set to zero. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="matrixRef"> Returns a nontransposed matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetMatrix([None] D3DXHANDLE hParameter,[Out] D3DXMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result GetMatrix(string hParameter, out SlimMath.Matrix matrixRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                matrixRef = new SlimMath.Matrix();
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 39 * 4, (void*)hParameter_, matrixRef_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of nontransposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A nontransposed matrix contains row-major data; that is, each vector is contained in a row. If the destination matrices are smaller than the source matrices, the additional components of the source matrices will be ignored. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="matrixRef"> Array of nontransposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetMatrixArray([None] D3DXHANDLE hParameter,[None] const D3DXMATRIX* pMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixArray(string hParameter, ref SlimMath.Matrix matrixRef, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 40 * 4, (void*)hParameter_, matrixRef_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an array of nontransposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A nontransposed matrix contains row-major data; that is, each vector is contained in a row. If the destination matrices are larger than the source matrices, only the upper-left components of each destination matrix will be filled, and the remaining destination matrix components will be set to zero. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="matrixRef"> Returns an array of nontransposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetMatrixArray([None] D3DXHANDLE hParameter,[Out] D3DXMATRIX* pMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetMatrixArray(string hParameter, out SlimMath.Matrix matrixRef, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                matrixRef = new SlimMath.Matrix();
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 41 * 4, (void*)hParameter_, matrixRef_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of pointers to nontransposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A nontransposed matrix contains row-major data; that is, each vector is contained in a row. If the destination matrices are smaller than the source matrices, the additional components of the source matrices will be ignored. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="matrixRef"> Array of pointers to nontransposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetMatrixPointerArray([None] D3DXHANDLE hParameter,[None] const D3DXMATRIX** ppMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixPointerArray(string hParameter, ref SlimMath.Matrix matrixRef, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 42 * 4, (void*)hParameter_, matrixRef_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an array of pointers to nontransposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A nontransposed matrix contains row-major data; that is, each vector is contained in a row. If the destination matrices are larger than the source matrices, only the upper-left components of each destination matrix will be filled, and the remaining destination matrix components will be set to zero. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="matrixRef"> Array of pointers to nontransposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetMatrixPointerArray([None] D3DXHANDLE hParameter,[Out] D3DXMATRIX** ppMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetMatrixPointerArray(string hParameter, out SlimMath.Matrix matrixRef, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                matrixRef = new SlimMath.Matrix();
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 43 * 4, (void*)hParameter_, matrixRef_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a transposed matrix.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. If the destination matrix is smaller than the source matrix, the additional components of the source matrix will be ignored. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="matrixRef"> Pointer to a transposed matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetMatrixTranspose([None] D3DXHANDLE hParameter,[None] const D3DXMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result SetMatrixTranspose(string hParameter, ref SlimMath.Matrix matrixRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 44 * 4, (void*)hParameter_, matrixRef_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a transposed matrix.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. If the destination matrix is larger than the source matrix, only the upper-left elements of the destination matrix will be filled, and the remaining destination matrix components will be set to zero. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="matrixRef"> Returns a transposed matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetMatrixTranspose([None] D3DXHANDLE hParameter,[Out] D3DXMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result GetMatrixTranspose(string hParameter, out SlimMath.Matrix matrixRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                matrixRef = new SlimMath.Matrix();
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 45 * 4, (void*)hParameter_, matrixRef_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. If the destination matrices are smaller than the source matrices, the additional components of the source matrices will be ignored. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="matrixRef"> Array of transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetMatrixTransposeArray([None] D3DXHANDLE hParameter,[None] const D3DXMATRIX* pMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixTransposeArray(string hParameter, ref SlimMath.Matrix matrixRef, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 46 * 4, (void*)hParameter_, matrixRef_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an array of transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. If the destination matrices are larger than the source matrices, only the upper-left components of each destination matrix will be filled, and the remaining destination matrix components will be set to zero. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="matrixRef"> Returns an array of transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetMatrixTransposeArray([None] D3DXHANDLE hParameter,[Out] D3DXMATRIX* pMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetMatrixTransposeArray(string hParameter, out SlimMath.Matrix matrixRef, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                matrixRef = new SlimMath.Matrix();
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 47 * 4, (void*)hParameter_, matrixRef_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of pointers to transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. If the destination matrices are smaller than the source matrices, the additional components of the source matrices will be ignored. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="matrixRef"> Array of pointers to transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetMatrixTransposePointerArray([None] D3DXHANDLE hParameter,[None] const D3DXMATRIX** ppMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixTransposePointerArray(string hParameter, ref SlimMath.Matrix matrixRef, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 48 * 4, (void*)hParameter_, matrixRef_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an array of pointers to transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. If the destination matrices are larger than the source matrices, only the upper-left components of each destination matrix will be filled, and the remaining destination matrix components will be set to zero. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="matrixRef"> Array of pointers to transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetMatrixTransposePointerArray([None] D3DXHANDLE hParameter,[Out] D3DXMATRIX** ppMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetMatrixTransposePointerArray(string hParameter, out SlimMath.Matrix matrixRef, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                matrixRef = new SlimMath.Matrix();
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 49 * 4, (void*)hParameter_, matrixRef_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a string.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="stringRef"> String to set. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetString([None] D3DXHANDLE hParameter,[None] const char* pString)</unmanaged>
        public SlimDX2.Result SetString(string hParameter, string stringRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                IntPtr stringRef_ = Marshal.StringToHGlobalAnsi(stringRef);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 50 * 4, (void*)hParameter_, (void*)stringRef_);
                Marshal.FreeHGlobal(hParameter_ );
                Marshal.FreeHGlobal(stringRef_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a string.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="stringRef"> Returns a string identified by hParameter. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetString([None] D3DXHANDLE hParameter,[Out] const char** ppString)</unmanaged>
        public SlimDX2.Result GetString(string hParameter, IntPtr stringRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 51 * 4, (void*)hParameter_, (void*)stringRef);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a texture.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pTexture"> Texture object. See <see cref="SlimDX2.Direct3D9.BaseTexture"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetTexture([None] D3DXHANDLE hParameter,[None] LPDIRECT3DBASETEXTURE9 pTexture)</unmanaged>
        public SlimDX2.Result SetTexture(string hParameter, SlimDX2.Direct3D9.BaseTexture pTexture) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 52 * 4, (void*)hParameter_, (void*)((pTexture == null)?IntPtr.Zero:pTexture.NativePointer));
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a texture.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="textureRef"> Returns a texture object. See <see cref="SlimDX2.Direct3D9.BaseTexture"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetTexture([None] D3DXHANDLE hParameter,[Out] LPDIRECT3DBASETEXTURE9* ppTexture)</unmanaged>
        public SlimDX2.Result GetTexture(string hParameter, out SlimDX2.Direct3D9.BaseTexture textureRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                IntPtr textureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 53 * 4, (void*)hParameter_, &textureRef_);
                Marshal.FreeHGlobal(hParameter_ );
                textureRef = (textureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.BaseTexture(textureRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a pixel shader.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pShaderRef"> Returns a pixel shader object. See <see cref="SlimDX2.Direct3D9.PixelShader"/> object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetPixelShader([None] D3DXHANDLE hParameter,[Out] LPDIRECT3DPIXELSHADER9* ppPShader)</unmanaged>
        public SlimDX2.Result GetPixelShader(string hParameter, out SlimDX2.Direct3D9.PixelShader pShaderRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                IntPtr pShaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 54 * 4, (void*)hParameter_, &pShaderRef_);
                Marshal.FreeHGlobal(hParameter_ );
                pShaderRef = (pShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PixelShader(pShaderRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a vertex shader.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="vShaderRef"> Returns a vertex shader object. See <see cref="SlimDX2.Direct3D9.VertexShader"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetVertexShader([None] D3DXHANDLE hParameter,[Out] LPDIRECT3DVERTEXSHADER9* ppVShader)</unmanaged>
        public SlimDX2.Result GetVertexShader(string hParameter, out SlimDX2.Direct3D9.VertexShader vShaderRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                IntPtr vShaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 55 * 4, (void*)hParameter_, &vShaderRef_);
                Marshal.FreeHGlobal(hParameter_ );
                vShaderRef = (vShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexShader(vShaderRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set the range of an array to pass to the device.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="uStart"> Start index. </param>
        /// <param name="uEnd"> Stop index. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetArrayRange([None] D3DXHANDLE hParameter,[None] UINT uStart,[None] UINT uEnd)</unmanaged>
        public SlimDX2.Result SetArrayRange(string hParameter, int uStart, int uEnd) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 56 * 4, (void*)hParameter_, uStart, uEnd);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXEffectStateManager</unmanaged>
    [Guid("79aab587-6dbc-4fa7-82de-37fa1781c5ce")]
    public partial class EffectStateManager : SlimDX2.ComObject {
        public EffectStateManager(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set material state.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetMaterial([None] const D3DMATERIAL9* pMaterial)</unmanaged>
        public SlimDX2.Direct3D9.Material Material {
                set { SetMaterial(ref value); }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set the number of subdivision segments for N-patches.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetNPatchMode([None] FLOAT NumSegments)</unmanaged>
        public float NPatchMode {
                set { SetNPatchMode(value); }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a FVF code.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetFVF([None] int FVF)</unmanaged>
        public SlimDX2.Direct3D9.VertexFormat VertexFormat {
                set { SetVertexFormat(value); }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a vertex shader.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetVertexShader([None] LPDIRECT3DVERTEXSHADER9 pShader)</unmanaged>
        public SlimDX2.Direct3D9.VertexShader VertexShader {
                set { SetVertexShader(value); }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a pixel shader.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetPixelShader([None] LPDIRECT3DPIXELSHADER9 pShader)</unmanaged>
        public SlimDX2.Direct3D9.PixelShader PixelShader {
                set { SetPixelShader(value); }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a transform.	
        /// </summary>	
        /// <param name="state"> The type of transform to apply the matrix to. See <see cref="SlimDX2.Direct3D9.TransformState"/>. </param>
        /// <param name="matrixRef"> A transformation matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetTransform"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetTransform([None] D3DTRANSFORMSTATETYPE State,[None] const D3DMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result SetTransform(SlimDX2.Direct3D9.TransformState state, ref SlimMath.Matrix matrixRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, unchecked((int)state), matrixRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set material state.	
        /// </summary>	
        /// <param name="materialRef"> A pointer to the material state. See <see cref="SlimDX2.Direct3D9.Material"/>. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetMaterial"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetMaterial([None] const D3DMATERIAL9* pMaterial)</unmanaged>
        internal SlimDX2.Result SetMaterial(ref SlimDX2.Direct3D9.Material materialRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* materialRef_ = &materialRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, materialRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a light.	
        /// </summary>	
        /// <param name="index"> The zero-based index of the light. This is the same index  in <see cref="SlimDX2.Direct3D9.Device.SetLight"/>. </param>
        /// <param name="lightRef"> The light object. See <see cref="SlimDX2.Direct3D9.Light"/>. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetLight"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetLight([None] int Index,[None] const D3DLIGHT9* pLight)</unmanaged>
        public SlimDX2.Result SetLight(int index, ref SlimDX2.Direct3D9.Light lightRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* lightRef_ = &lightRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, index, lightRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to enable/disable a light.	
        /// </summary>	
        /// <param name="index"> The zero-based index of the light. This is the same index in <see cref="SlimDX2.Direct3D9.Device.SetLight"/>. </param>
        /// <param name="enable"> True to enable the light, false otherwise. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.LightEnable"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::LightEnable([None] int Index,[None] BOOL Enable)</unmanaged>
        public SlimDX2.Result LightEnable(int index, bool enable) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, index, (enable?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set render state.	
        /// </summary>	
        /// <param name="state"> The render state to set. <see cref="SlimDX2.Direct3D9.RenderState"/>  </param>
        /// <param name="value"> The render state value. See {{Effect States (Direct3D 9)}}. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetRenderState([None] D3DRENDERSTATETYPE State,[None] int Value)</unmanaged>
        public SlimDX2.Result SetRenderState(SlimDX2.Direct3D9.RenderState state, int value) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, unchecked((int)state), value);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a texture.	
        /// </summary>	
        /// <param name="stage"> The stage to which the texture is assigned. This is the index value in <see cref="SlimDX2.Direct3D9.Device.SetTexture"/> or <see cref="SlimDX2.Direct3D9.Device.SetTextureStageState"/>.  </param>
        /// <param name="pTexture"> A pointer to the texture object. This can be any of the Direct3D texture types (cube, volume, etc.). See <see cref="SlimDX2.Direct3D9.BaseTexture"/>. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetTexture"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetTexture([None] int Stage,[None] LPDIRECT3DBASETEXTURE9 pTexture)</unmanaged>
        public SlimDX2.Result SetTexture(int stage, SlimDX2.Direct3D9.BaseTexture pTexture) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, stage, (void*)((pTexture == null)?IntPtr.Zero:pTexture.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set the texture stage state.	
        /// </summary>	
        /// <param name="stage"> The stage that the texture is assigned to. This is the index value in <see cref="SlimDX2.Direct3D9.Device.SetTexture"/> or <see cref="SlimDX2.Direct3D9.Device.SetTextureStageState"/>.  </param>
        /// <param name="type"> Defines the type of operation that a texture stage will perform. See  <see cref="SlimDX2.Direct3D9.TextureStage"/>.  </param>
        /// <param name="value"> Can be either an operation (<see cref="SlimDX2.Direct3D9.TextureOperation"/>) or an argument value ({{D3DTA}}), depending on what is chosen for Type. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetTextureStageState"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetTextureStageState([None] int Stage,[None] D3DTEXTURESTAGESTATETYPE Type,[None] int Value)</unmanaged>
        public SlimDX2.Result SetTextureStageState(int stage, SlimDX2.Direct3D9.TextureStage type, int value) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, stage, unchecked((int)type), value);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a sampler.	
        /// </summary>	
        /// <param name="sampler"> The zero-based sampler number.  </param>
        /// <param name="type"> Identifies sampler state, which can specify the filtering, addressing, or the border color. See <see cref="SlimDX2.Direct3D9.SamplerState"/>. </param>
        /// <param name="value"> A value from one of the sampler state types in Type.  </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetSamplerState"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetSamplerState([None] int Sampler,[None] D3DSAMPLERSTATETYPE Type,[None] int Value)</unmanaged>
        public SlimDX2.Result SetSamplerState(int sampler, SlimDX2.Direct3D9.SamplerState type, int value) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, sampler, unchecked((int)type), value);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set the number of subdivision segments for N-patches.	
        /// </summary>	
        /// <param name="numSegments"> Break the surface into this number of subdivisions. This is the same as the number used by <see cref="SlimDX2.Direct3D9.Device.SetNPatchMode"/>. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetNPatchMode"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetNPatchMode([None] FLOAT NumSegments)</unmanaged>
        internal SlimDX2.Result SetNPatchMode(float numSegments) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, numSegments);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a FVF code.	
        /// </summary>	
        /// <param name="vertexFormat"> The FVF constant, that determines how to interpret vertex data. See <see cref="SlimDX2.Direct3D9.VertexFormat"/>. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetVertexFormat"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetFVF([None] int FVF)</unmanaged>
        internal SlimDX2.Result SetVertexFormat(SlimDX2.Direct3D9.VertexFormat vertexFormat) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, unchecked((int)vertexFormat));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a vertex shader.	
        /// </summary>	
        /// <param name="pShader"> A pointer to a vertex shader object. See <see cref="SlimDX2.Direct3D9.VertexShader"/>.  </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetVertexShader"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetVertexShader([None] LPDIRECT3DVERTEXSHADER9 pShader)</unmanaged>
        internal SlimDX2.Result SetVertexShader(SlimDX2.Direct3D9.VertexShader pShader) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, (void*)((pShader == null)?IntPtr.Zero:pShader.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set an array of vertex shader floating-point constants.	
        /// </summary>	
        /// <param name="registerIndex"> The zero-based index of the first constant register. </param>
        /// <param name="constantDataRef"> An array of floating-point constants. </param>
        /// <param name="registerCount"> The number of registers in pConstantData. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetVertexShaderConstantF"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetVertexShaderConstantF([None] UINT RegisterIndex,[None] const FLOAT* pConstantData,[None] UINT RegisterCount)</unmanaged>
        public SlimDX2.Result SetVertexShaderConstantF(int registerIndex, ref float constantDataRef, int registerCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, registerIndex, constantDataRef_, registerCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set an array of vertex shader integer constants.	
        /// </summary>	
        /// <param name="registerIndex"> The zero-based index of the first constant register. </param>
        /// <param name="constantDataRef"> An array of integer constants. </param>
        /// <param name="registerCount"> The number of registers in pConstantData. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetVertexShaderConstantI"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetVertexShaderConstantI([None] UINT RegisterIndex,[None] const INT* pConstantData,[None] UINT RegisterCount)</unmanaged>
        public SlimDX2.Result SetVertexShaderConstantI(int registerIndex, ref int constantDataRef, int registerCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, registerIndex, constantDataRef_, registerCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set an array of vertex shader Boolean constants.	
        /// </summary>	
        /// <param name="registerIndex"> The zero-based index of the first constant register. </param>
        /// <param name="constantDataRef"> An array of Boolean constants. </param>
        /// <param name="registerCount"> The number of registers in pConstantData. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetVertexShaderConstantB"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetVertexShaderConstantB([None] UINT RegisterIndex,[None] const BOOL* pConstantData,[None] UINT RegisterCount)</unmanaged>
        public SlimDX2.Result SetVertexShaderConstantB(int registerIndex, ref bool constantDataRef, int registerCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, registerIndex, (constantDataRef?1:0), registerCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a pixel shader.	
        /// </summary>	
        /// <param name="pShader"> A pointer to a pixel shader object. See <see cref="SlimDX2.Direct3D9.PixelShader"/>.  </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetPixelShader"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetPixelShader([None] LPDIRECT3DPIXELSHADER9 pShader)</unmanaged>
        internal SlimDX2.Result SetPixelShader(SlimDX2.Direct3D9.PixelShader pShader) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, (void*)((pShader == null)?IntPtr.Zero:pShader.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set an array of vertex shader floating-point constants.	
        /// </summary>	
        /// <param name="registerIndex"> The zero-based index of the first constant register. </param>
        /// <param name="constantDataRef"> An array of floating-point constants. </param>
        /// <param name="registerCount"> The number of registers in pConstantData. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetPixelShaderConstantF"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetPixelShaderConstantF([None] UINT RegisterIndex,[None] const FLOAT* pConstantData,[None] UINT RegisterCount)</unmanaged>
        public SlimDX2.Result SetPixelShaderConstantF(int registerIndex, ref float constantDataRef, int registerCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, registerIndex, constantDataRef_, registerCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set an array of vertex shader integer constants.	
        /// </summary>	
        /// <param name="registerIndex"> The zero-based index of the first constant register. </param>
        /// <param name="constantDataRef"> An array of integer constants. </param>
        /// <param name="registerCount"> The number of registers in pConstantData. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetPixelShaderConstantI"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetPixelShaderConstantI([None] UINT RegisterIndex,[None] const INT* pConstantData,[None] UINT RegisterCount)</unmanaged>
        public SlimDX2.Result SetPixelShaderConstantI(int registerIndex, ref int constantDataRef, int registerCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, registerIndex, constantDataRef_, registerCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set an array of vertex shader Boolean constants.	
        /// </summary>	
        /// <param name="registerIndex"> The zero-based index of the first constant register. </param>
        /// <param name="constantDataRef"> An array of Boolean constants. </param>
        /// <param name="registerCount"> The number of registers in pConstantData. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetPixelShaderConstantB"/>) will fail.  </returns>
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetPixelShaderConstantB([None] UINT RegisterIndex,[None] const BOOL* pConstantData,[None] UINT RegisterCount)</unmanaged>
        public SlimDX2.Result SetPixelShaderConstantB(int registerIndex, ref bool constantDataRef, int registerCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* constantDataRef_ = &constantDataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, registerIndex, (constantDataRef?1:0), registerCount);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXEffect</unmanaged>
    [Guid("f6ceb4b3-4e4c-40dd-b883-8d8de5ea0cd5")]
    public partial class Effect : SlimDX2.Direct3D9.BaseEffect {
        public Effect(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets a pointer to the pool of shared parameters.	
        /// </summary>	
        /// <remarks>	
        ///  Pools contain shared parameters between effects. See {{Cloning and Sharing (Direct3D 9)}}. 	
        /// </remarks>	
        /// <unmanaged>HRESULT ID3DXEffect::GetPool([Out] LPD3DXEFFECTPOOL* ppPool)</unmanaged>
        public SlimDX2.Direct3D9.EffectPool Pool {
                get { SlimDX2.Direct3D9.EffectPool __output__; GetPool(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Sets the active technique.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXEffect::SetTechnique([None] D3DXHANDLE hTechnique)</unmanaged>
        public string Technique {
                set { SetTechnique(value); }
        }
        
        /// <summary>	
        /// Gets the current technique.	
        /// </summary>	
        /// <unmanaged>D3DXHANDLE ID3DXEffect::GetCurrentTechnique()</unmanaged>
        public byte CurrentTechnique {
                get { return GetCurrentTechnique(); }
        }
        
        /// <summary>	
        /// Retrieves the device associated with the effect.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count for the <see cref="SlimDX2.Direct3D9.Device"/> interface. Be sure to call IUnknown::Release when you are done using the IDirect3DDevice9 interface or you will have a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT ID3DXEffect::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the effect state manager.	
        /// </summary>	
        /// <remarks>	
        ///  The <see cref="SlimDX2.Direct3D9.EffectStateManager"/> is a user-implemented interface that furnishes callbacks into an application for setting device state from an effect. 	
        /// </remarks>	
        /// <unmanaged>HRESULT ID3DXEffect::GetStateManager([Out] LPD3DXEFFECTSTATEMANAGER* ppManager)</unmanaged>
        public SlimDX2.Direct3D9.EffectStateManager StateManager {
                get { SlimDX2.Direct3D9.EffectStateManager __output__; GetStateManager(out __output__); return __output__; }
                set { SetStateManager(value); }
        }
        
        /// <summary>	
        /// Gets a pointer to the pool of shared parameters.	
        /// </summary>	
        /// <remarks>	
        ///  Pools contain shared parameters between effects. See {{Cloning and Sharing (Direct3D 9)}}. 	
        /// </remarks>	
        /// <param name="poolRef"> Pointer to a <see cref="SlimDX2.Direct3D9.EffectPool"/> object.  </param>
        /// <returns>  <see cref="int"/>  This method always returns the value S_OK. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::GetPool([Out] LPD3DXEFFECTPOOL* ppPool)</unmanaged>
        internal SlimDX2.Result GetPool(out SlimDX2.Direct3D9.EffectPool poolRef) {
            unsafe {
                IntPtr poolRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 57 * 4, &poolRef_);
                poolRef = (poolRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.EffectPool(poolRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the active technique.	
        /// </summary>	
        /// <param name="hTechnique"> Unique handle to the technique.  See {{Handles (Direct3D 9)}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::SetTechnique([None] D3DXHANDLE hTechnique)</unmanaged>
        internal SlimDX2.Result SetTechnique(string hTechnique) {
            unsafe {
                IntPtr hTechnique_ = Marshal.StringToHGlobalAnsi(hTechnique);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 58 * 4, (void*)hTechnique_);
                Marshal.FreeHGlobal(hTechnique_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the current technique.	
        /// </summary>	
        /// <returns>  {{D3DXHANDLE}}  A unique identifier to the current technique.  See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXEffect::GetCurrentTechnique()</unmanaged>
        internal byte GetCurrentTechnique() {
            unsafe {
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 59 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Validate a technique.	
        /// </summary>	
        /// <param name="hTechnique"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::ValidateTechnique([None] D3DXHANDLE hTechnique)</unmanaged>
        public SlimDX2.Result ValidateTechnique(string hTechnique) {
            unsafe {
                IntPtr hTechnique_ = Marshal.StringToHGlobalAnsi(hTechnique);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 60 * 4, (void*)hTechnique_);
                Marshal.FreeHGlobal(hTechnique_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Searches for the next valid technique, starting at the technique after the specified technique.	
        /// </summary>	
        /// <param name="hTechnique"> Unique identifier to a technique. See {{Handles (Direct3D 9)}}. Specify NULL for this parameter to find the first valid technique. </param>
        /// <param name="techniqueRef"> Pointer to an identifier for the next technique. NULL is returned if this is the last technique.  See {{Handles (Direct3D 9)}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::FindNextValidTechnique([None] D3DXHANDLE hTechnique,[None] D3DXHANDLE* pTechnique)</unmanaged>
        public SlimDX2.Result FindNextValidTechnique(string hTechnique, string techniqueRef) {
            unsafe {
                IntPtr hTechnique_ = Marshal.StringToHGlobalAnsi(hTechnique);
                IntPtr techniqueRef_ = Marshal.StringToHGlobalAnsi(techniqueRef);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 61 * 4, (void*)hTechnique_, (void*)techniqueRef_);
                Marshal.FreeHGlobal(hTechnique_ );
                Marshal.FreeHGlobal(techniqueRef_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Determines if a parameter is used by the technique.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier for the parameter.  See {{Handles (Direct3D 9)}}. </param>
        /// <param name="hTechnique"> Unique identifier for the technique.  See {{Handles (Direct3D 9)}}. </param>
        /// <returns>  {{BOOL}}  Returns TRUE if the parameter is being used and returns FALSE if the parameter is not being used. </returns>
        /// <unmanaged>BOOL ID3DXEffect::IsParameterUsed([None] D3DXHANDLE hParameter,[None] D3DXHANDLE hTechnique)</unmanaged>
        public bool IsParameterUsed(string hParameter, string hTechnique) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                IntPtr hTechnique_ = Marshal.StringToHGlobalAnsi(hTechnique);
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 62 * 4, (void*)hParameter_, (void*)hTechnique_));
                Marshal.FreeHGlobal(hParameter_ );
                Marshal.FreeHGlobal(hTechnique_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Starts an active technique.	
        /// </summary>	
        /// <remarks>	
        ///  An application sets one active technique in the effect system by calling ID3DXEffect::Begin. The effect system responds by capturing all the pipeline state that can be changed by the technique in a state block. An application signals the end of a technique by calling <see cref="SlimDX2.Direct3D9.Effect.End"/>, which uses the state block to restore the original state. The effect system, therefore, takes care of saving state when a technique becomes active and restoring state when a technique ends. If you choose to disable this save and restore functionality, see {{D3DXFX_DONOTSAVESAMPLERSTATE}}. Within the ID3DXEffect::Begin and <see cref="SlimDX2.Direct3D9.Effect.End"/> pair, an application uses <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/> to set the active pass, <see cref="SlimDX2.Direct3D9.Effect.CommitChanges"/> if any state changes occurred after the pass was activated, and <see cref="SlimDX2.Direct3D9.Effect.EndPass"/> to end the active pass. 	
        /// </remarks>	
        /// <param name="assesRef"> Pointer to a value returned that indicates the number of passes needed to render the current technique.  </param>
        /// <param name="flags"> DWORD that determines if state modified by an effect is saved and restored. The default value 0 specifies that ID3DXEffect::Begin and <see cref="SlimDX2.Direct3D9.Effect.End"/> will save and restore all state modified by the effect (including pixel and vertex shader constants). Valid flags can be seen at {{Effect State Save and Restore Flags}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::Begin([None] UINT* pPasses,[None] int Flags)</unmanaged>
        public SlimDX2.Result Begin(ref int assesRef, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* assesRef_ = &assesRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 63 * 4, assesRef_, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Begins a pass, within the active technique.	
        /// </summary>	
        /// <remarks>	
        ///  An application sets one active pass (within one active technique) in the effect system by calling ID3DXEffect::BeginPass. An application signals the end of the active pass by calling <see cref="SlimDX2.Direct3D9.Effect.EndPass"/>. ID3DXEffect::BeginPass and ID3DXEffect::EndPass must occur in a matching pair, within a matching pair of <see cref="SlimDX2.Direct3D9.Effect.Begin"/> and <see cref="SlimDX2.Direct3D9.Effect.End"/> calls. If the application changes any effect state using any of the {{Effect::Setx}} methods inside of a ID3DXEffect::BeginPass/<see cref="SlimDX2.Direct3D9.Effect.EndPass"/> matching pair, the application must call <see cref="SlimDX2.Direct3D9.Effect.CommitChanges"/> to set the update the device with the state changes. If no state changes occur within a ID3DXEffect::BeginPass and ID3DXEffect::EndPass matching pair, it is not necessary to call ID3DXEffect::CommitChanges. 	
        /// </remarks>	
        /// <param name="pass"> A zero-based integer index into the technique. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::BeginPass([None] UINT Pass)</unmanaged>
        public SlimDX2.Result BeginPass(int pass) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 64 * 4, pass);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Propagate state changes that occur inside of an active pass to the device before rendering.	
        /// </summary>	
        /// <remarks>	
        ///  If the application changes any effect state using any of the {{ID3DXEffect::Setx}} methods inside of an <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>/<see cref="SlimDX2.Direct3D9.Effect.EndPass"/> matching pair, the application must call ID3DXEffect::CommitChanges before any DrawxPrimitive call to propagate state changes to the device before rendering. If no state changes occur within a ID3DXEffect::BeginPass and ID3DXEffect::EndPass matching pair, it is not necessary to call ID3DXEffect::CommitChanges. This is slightly different for any shared parameters in a cloned effect. When a technique is active on a cloned effect (that is, when <see cref="SlimDX2.Direct3D9.Effect.Begin"/> has been called but and <see cref="SlimDX2.Direct3D9.Effect.End"/> has not been called), ID3DXEffect::CommitChanges updates parameters that are not shared as expected. To update a shared parameter (only for a cloned effect whose technique is active), call ID3DXEffect::End to deactivate the technique and ID3DXEffect::Begin to reactivate the technique before calling ID3DXEffect::CommitChanges. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::CommitChanges()</unmanaged>
        public SlimDX2.Result CommitChanges() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 65 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// End an active pass.	
        /// </summary>	
        /// <remarks>	
        ///  An application signals the end of rendering an active pass by calling ID3DXEffect::EndPass. Each ID3DXEffect::EndPass must be part of a matching pair of <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/> and ID3DXEffect::EndPass calls. Each matching pair of <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/> and ID3DXEffect::EndPass calls must be located within a matching pair of <see cref="SlimDX2.Direct3D9.Effect.Begin"/> and <see cref="SlimDX2.Direct3D9.Effect.End"/> calls. If the application changes any effect state using any of the {{Effect::Setx}} methods inside of a <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>/ID3DXEffect::EndPass matching pair, the application must call <see cref="SlimDX2.Direct3D9.Effect.CommitChanges"/> before any DrawxPrimitive call to propagate state changes to the device before rendering. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  This method always returns the value S_OK. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::EndPass()</unmanaged>
        public SlimDX2.Result EndPass() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 66 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Ends an active technique.	
        /// </summary>	
        /// <remarks>	
        ///  All rendering in an effect is done within a matching pair of <see cref="SlimDX2.Direct3D9.Effect.Begin"/> and ID3DXEffect::End calls. After all passes are rendered, ID3DXEffect::End must be called to end the active technique. The effect system responds by using the state block created when ID3DXEffect::Begin was called, to automatically restore the pipeline state before ID3DXEffect::Begin. By default, the effect system takes care of saving state prior to a technique, and restoring state after a technique. If you choose to disable this save and restore functionality, see {{D3DXFX_DONOTSAVESAMPLERSTATE}}. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  This method always returns the value S_OK. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::End()</unmanaged>
        public SlimDX2.Result End() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 67 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the device associated with the effect.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count for the <see cref="SlimDX2.Direct3D9.Device"/> interface. Be sure to call IUnknown::Release when you are done using the IDirect3DDevice9 interface or you will have a memory leak. 	
        /// </remarks>	
        /// <param name="deviceRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the effect.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 68 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost, or before resetting a device.	
        /// </summary>	
        /// <remarks>	
        ///  This method should be called whenever the device is lost or before the user calls <see cref="SlimDX2.Direct3D9.Device.Reset"/>. Even if the device was not actually lost, ID3DXEffect::OnLostDevice is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling IDirect3DDevice9::Reset and then <see cref="SlimDX2.Direct3D9.Effect.OnResetDevice"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::OnLostDevice()</unmanaged>
        public SlimDX2.Result OnLostDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 69 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to re-acquire resources and save initial state.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXEffect::OnResetDevice should be called each time the device is reset (using <see cref="SlimDX2.Direct3D9.Device.Reset"/>), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::OnResetDevice()</unmanaged>
        public SlimDX2.Result OnResetDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 70 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set the effect state manager.	
        /// </summary>	
        /// <remarks>	
        ///  The <see cref="SlimDX2.Direct3D9.EffectStateManager"/> is a user-implemented interface that furnishes callbacks into an application for setting device state from an effect. 	
        /// </remarks>	
        /// <param name="pManager"> A pointer to the state manager. See <see cref="SlimDX2.Direct3D9.EffectStateManager"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::SetStateManager([None] LPD3DXEFFECTSTATEMANAGER pManager)</unmanaged>
        internal SlimDX2.Result SetStateManager(SlimDX2.Direct3D9.EffectStateManager pManager) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 71 * 4, (void*)((pManager == null)?IntPtr.Zero:pManager.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the effect state manager.	
        /// </summary>	
        /// <remarks>	
        ///  The <see cref="SlimDX2.Direct3D9.EffectStateManager"/> is a user-implemented interface that furnishes callbacks into an application for setting device state from an effect. 	
        /// </remarks>	
        /// <param name="managerRef"> Returns a pointer to the state manager. See <see cref="SlimDX2.Direct3D9.EffectStateManager"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::GetStateManager([Out] LPD3DXEFFECTSTATEMANAGER* ppManager)</unmanaged>
        internal SlimDX2.Result GetStateManager(out SlimDX2.Direct3D9.EffectStateManager managerRef) {
            unsafe {
                IntPtr managerRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 72 * 4, &managerRef_);
                managerRef = (managerRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.EffectStateManager(managerRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Start capturing state changes in a parameter block.	
        /// </summary>	
        /// <remarks>	
        ///  Capture effect parameter state changes until EndParameterBlock is called. Effect parameters include any state changes outside of a pass. Delete parameter blocks if they are no longer needed by calling DeleteParameterBlock. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::BeginParameterBlock()</unmanaged>
        public SlimDX2.Result BeginParameterBlock() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 73 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Stop capturing effect parameter state changes.	
        /// </summary>	
        /// <remarks>	
        ///  All effect parameters that change state (after calling BeginParameterBlock and before calling EndParameterBlock) will be saved in an effect parameter state block. Use ApplyParameterBlock to apply this block of state changes to the effect system. Once you are finished with a state block use DeleteParameterBlock to free the memory. 	
        /// </remarks>	
        /// <returns>  {{D3DXHANDLE}}  Returns a handle to the parameter state block. </returns>
        /// <unmanaged>D3DXHANDLE ID3DXEffect::EndParameterBlock()</unmanaged>
        public byte EndParameterBlock() {
            unsafe {
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 74 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Apply the values in a state block to the current effect system state.	
        /// </summary>	
        /// <remarks>	
        ///  Capture effect parameter state changes in a parameter block by calling BeginParameterBlock; stop capturing state changes by calling EndParameterBlock. These state changes include any effect parameter changes that occur inside of a technique (including those outside of a pass). Once you are done with the parameter block, call DeleteParameterBlock to recover memory. 	
        /// </remarks>	
        /// <param name="hParameterBlock"> A handle to the parameter block. This is the handle returned by <see cref="SlimDX2.Direct3D9.Effect.EndParameterBlock"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::ApplyParameterBlock([None] D3DXHANDLE hParameterBlock)</unmanaged>
        public SlimDX2.Result ApplyParameterBlock(string hParameterBlock) {
            unsafe {
                IntPtr hParameterBlock_ = Marshal.StringToHGlobalAnsi(hParameterBlock);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 75 * 4, (void*)hParameterBlock_);
                Marshal.FreeHGlobal(hParameterBlock_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Delete a parameter block.	
        /// </summary>	
        /// <remarks>	
        ///  Parameter blocks are blocks of effect states. Use a parameter block to record state changes so that they can be applied later on with a single API call. When no longer needed, delete the parameter block to reduce memory usage. 	
        /// </remarks>	
        /// <param name="hParameterBlock"> A handle to the parameter block. This is the handle returned by <see cref="SlimDX2.Direct3D9.Effect.EndParameterBlock"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::DeleteParameterBlock([None] D3DXHANDLE hParameterBlock)</unmanaged>
        public SlimDX2.Result DeleteParameterBlock(string hParameterBlock) {
            unsafe {
                IntPtr hParameterBlock_ = Marshal.StringToHGlobalAnsi(hParameterBlock);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 76 * 4, (void*)hParameterBlock_);
                Marshal.FreeHGlobal(hParameterBlock_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a copy of an effect.	
        /// </summary>	
        /// <remarks>	
        ///  Note??This function will not clone an effect if the user specifies {{D3DXFX_NOT_CLONEABLE}} during effect creation. To update shared and non-shared parameters in an active technique of a cloned effect, see <see cref="SlimDX2.Direct3D9.Effect.CommitChanges"/>. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the effect.  </param>
        /// <param name="effectRef"> Pointer to an <see cref="SlimDX2.Direct3D9.Effect"/> interface, containing the cloned effect.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::CloneEffect([None] LPDIRECT3DDEVICE9 pDevice,[None] LPD3DXEFFECT* ppEffect)</unmanaged>
        public SlimDX2.Result CloneEffect(SlimDX2.Direct3D9.Device pDevice, out SlimDX2.Direct3D9.Effect effectRef) {
            unsafe {
                IntPtr effectRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 77 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), &effectRef_);
                effectRef = (effectRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Effect(effectRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set a contiguous range of shader constants with a memory copy.	
        /// </summary>	
        /// <remarks>	
        ///  SetRawValue is a very fast way to set effect constants since it performs a memory copy without performing validation or any data conversion (like converting a row-major matrix to a column-major matrix). Use SetRawValue to set a series of contiguous effect constants. For instance, you could set an array of twenty matrices with 20 calls to <see cref="SlimDX2.Direct3D9.BaseEffect.SetMatrix"/> or by using a single SetRawValue. All values are expected to be either matrix4x4s or float4s and all matrices are expected to be in column-major order. Int or float values are cast into a float4; therefore, it is highly recommended that you use SetRawValue with only float4 or matrix4x4 data. 	
        /// </remarks>	
        /// <param name="hParameter"> Handle to the value to set, or the name of the value passed in as a string. Passing in a handle is more efficient. See {{Handles (Direct3D 9)}}.  </param>
        /// <param name="pData"> Pointer to a buffer containing the data to be set. SetRawValue checks for valid memory, but does not do any checking for valid data. </param>
        /// <param name="byteOffset"> Number of bytes between the beginning of the effect data and the beginning of the effect constants you are going to set. </param>
        /// <param name="bytes"> The size of the buffer to be set, in bytes. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following:E_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXEffect::SetRawValue([None] D3DXHANDLE hParameter,[None] LPCVOID pData,[None] UINT ByteOffset,[None] UINT Bytes)</unmanaged>
        public SlimDX2.Result SetRawValue(string hParameter, IntPtr pData, int byteOffset, int bytes) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 78 * 4, (void*)hParameter_, (void*)pData, byteOffset, bytes);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXEffectCompiler</unmanaged>
    [Guid("51b8a949-1a31-47e6-bea0-4b30db53f1e0")]
    public partial class EffectCompiler : SlimDX2.Direct3D9.BaseEffect {
        public EffectCompiler(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Toggles the literal status of a parameter. A literal parameter has a value that doesn't change during the lifetime of an effect.	
        /// </summary>	
        /// <remarks>	
        ///  This methods only changes whether the parameter is a literal or not. To change the value of a parameter, use a method like <see cref="SlimDX2.Direct3D9.BaseEffect.SetBool"/> or <see cref="SlimDX2.Direct3D9.BaseEffect.SetValue"/>. This function must be called before the effect is compiled.  Here is an example of how one might use this function: 	
        /// <code> LPD3DXEFFECTCOMPILER pEffectCompiler; char errors[1000]; HRESULT hr; hr = D3DXCreateEffectCompilerFromFile("shader.fx", NULL, NULL, 0, &amp;pEffectCompiler,  &amp;errors); //In the fx file, literalInt is declared as an int. //By calling this function, the compiler will treat //it as a literal (i.e. #define) hr = pEffectCompiler-&gt;SetLiteral("literalInt", TRUE); //create ten different variations of the same effect LPD3DXBUFFER pEffects[10]; LPD3DXBUFFER pErrors; for(int i = 0; i &lt; 10; ++i) { hr = pEffectCompiler-&gt;SetInt("literalInt", i); hr = pEffectCompiler-&gt;CompileEffect(0, &amp;pEffects[i], &amp;pErrors); } </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier to a parameter. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="literal"> Set to True to make the parameter a literal, and False if the parameter can change value during the shader lifetime. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXEffectCompiler::SetLiteral([None] D3DXHANDLE hParameter,[None] BOOL Literal)</unmanaged>
        public SlimDX2.Result SetLiteral(string hParameter, bool literal) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 57 * 4, (void*)hParameter_, (literal?1:0));
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a literal status of a parameter. A literal parameter has a value that doesn't change during the lifetime of an effect.	
        /// </summary>	
        /// <remarks>	
        ///  This methods only changes whether the parameter is a literal or not. To change the value of a parameter, use a method like <see cref="SlimDX2.Direct3D9.BaseEffect.SetBool"/> or <see cref="SlimDX2.Direct3D9.BaseEffect.SetValue"/>. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier to a parameter. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="literalRef"> Returns True if the parameter is a literal, and False otherwise. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXEffectCompiler::GetLiteral([None] D3DXHANDLE hParameter,[Out] BOOL* pLiteral)</unmanaged>
        public SlimDX2.Result GetLiteral(string hParameter, out bool literalRef) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* literalRef_ = &literalRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 58 * 4, (void*)hParameter_, literalRef_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Compile an effect.	
        /// </summary>	
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="effectRef"> Buffer containing the compiled effect. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. </param>
        /// <param name="errorMsgsRef"> Buffer containing at least the first compile error message that occurred. This includes effect compiler errors and high-level language compile errors. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the arguments are invalid, the method will return D3DERR_INVALIDCALL. If the method fails, the return value will be E_FAIL. </returns>
        /// <unmanaged>HRESULT ID3DXEffectCompiler::CompileEffect([None] int Flags,[None] LPD3DXBUFFER* ppEffect,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
        public SlimDX2.Result CompileEffect(int flags, out SlimDX2.Direct3D9.ShaderBytecode effectRef, out SlimDX2.Direct3D9.ShaderBytecode errorMsgsRef) {
            unsafe {
                IntPtr effectRef_ = IntPtr.Zero;
                IntPtr errorMsgsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 59 * 4, flags, &effectRef_, &errorMsgsRef_);
                effectRef = (effectRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(effectRef_);	
                errorMsgsRef = (errorMsgsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorMsgsRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Compiles a shader from an effect that contains one or more functions.	
        /// </summary>	
        /// <remarks>	
        ///  Targets can be specified for vertex shaders, pixel shaders, and texture fill functions.  Vertex shader targetsvs_1_1, vs_2_0, vs_2_sw, vs_3_0 Pixel shader targetsps_1_1, ps_1_2, ps_1_3, ps_1_4, ps_2_0, ps_2_sw, ps_3_0 Texture fill targetstx_0, tx_1  ? This method compiles a shader from a function that is written in a C-like language. For more information, see {{HLSL}}. 	
        /// </remarks>	
        /// <param name="hFunction"> Unique identifier to the function to be compiled. This value must not be NULL. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="targetRef"> Pointer to a shader profile which determines the shader instruction set. See {{D3DXGetVertexShaderProfile}} or {{D3DXGetPixelShaderProfile}} for a list of the profiles available. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="shaderRef"> Buffer containing the compiled shader. The compiler shader is an array of DWORDs. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. </param>
        /// <param name="errorMsgsRef"> Buffer containing at least the first compile error message that occurred. This includes effect compiler errors and high-level language compile errors. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. </param>
        /// <param name="constantTableRef"> Returns an <see cref="SlimDX2.Direct3D9.ConstantTable"/> interface, which can be used to access shader constants. This value can be NULL. If you compile your application as large address aware (that is, you use the /LARGEADDRESSAWARE linker option to handle addresses larger than 2 GB), you cannot use this parameter and must set it to NULL. Instead, you must use the <see cref="SlimDX2.Direct3D9.D3DX9.GetShaderConstantTableEx"/> function to retrieve the shader-constant table that is embedded inside the shader. In this D3DXGetShaderConstantTableEx call, you must pass the D3DXCONSTTABLE_LARGEADDRESSAWARE flag to the Flags parameter to specify to access up to 4 GB of virtual address space. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the arguments are invalid, the method will return D3DERR_INVALIDCALL. If the method fails, the return value will be E_FAIL. </returns>
        /// <unmanaged>HRESULT ID3DXEffectCompiler::CompileShader([None] D3DXHANDLE hFunction,[None] const char* pTarget,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
        public SlimDX2.Result CompileShader(string hFunction, string targetRef, int flags, out SlimDX2.Direct3D9.ShaderBytecode shaderRef, out SlimDX2.Direct3D9.ShaderBytecode errorMsgsRef, out SlimDX2.Direct3D9.ConstantTable constantTableRef) {
            unsafe {
                IntPtr hFunction_ = Marshal.StringToHGlobalAnsi(hFunction);
                IntPtr targetRef_ = Marshal.StringToHGlobalAnsi(targetRef);
                IntPtr shaderRef_ = IntPtr.Zero;
                IntPtr errorMsgsRef_ = IntPtr.Zero;
                IntPtr constantTableRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 60 * 4, (void*)hFunction_, (void*)targetRef_, flags, &shaderRef_, &errorMsgsRef_, &constantTableRef_);
                Marshal.FreeHGlobal(hFunction_ );
                Marshal.FreeHGlobal(targetRef_ );
                shaderRef = (shaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(shaderRef_);	
                errorMsgsRef = (errorMsgsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorMsgsRef_);	
                constantTableRef = (constantTableRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ConstantTable(constantTableRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXAllocateHierarchy</unmanaged>
    public partial class IAllocateHierarchy : SlimDX2.CppObject {
        public IAllocateHierarchy(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Requests allocation of a frame object.	
        /// </summary>	
        /// <param name="name"> Name of the frame to be created. </param>
        /// <param name="newFrameRef"> Returns the created frame object. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from D3DERR or D3DXERR,  as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT ID3DXAllocateHierarchy::CreateFrame([None] const char* Name,[None] LPD3DXFRAME* ppNewFrame)</unmanaged>
        public SlimDX2.Result CreateFrame(string name, ref SlimDX2.Direct3D9.Frame newFrameRef) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D9.Frame.__Native newFrameRef_ = new SlimDX2.Direct3D9.Frame.__Native();
                newFrameRef.__MarshalTo(ref newFrameRef_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 0 * 4, (void*)name_, &newFrameRef_);
                Marshal.FreeHGlobal(name_ );
                newFrameRef.__MarshalFrom(ref newFrameRef_);
                newFrameRef_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Requests allocation of a mesh container object.	
        /// </summary>	
        /// <param name="name"> Name of the mesh. </param>
        /// <param name="meshDataRef"> Pointer to the mesh data structure. See <see cref="SlimDX2.Direct3D9.MeshData"/>. </param>
        /// <param name="materialsRef"> Array of materials used in the mesh. </param>
        /// <param name="effectInstancesRef"> Array of effect instances used in the mesh. See <see cref="SlimDX2.Direct3D9.EffectInstance"/>. </param>
        /// <param name="numMaterials"> Number of materials in the materials array. </param>
        /// <param name="adjacencyRef"> Adjacency array for the mesh. </param>
        /// <param name="pSkinInfo"> Pointer to the skin mesh object if skin data is found. See <see cref="SlimDX2.Direct3D9.SkinInfo"/>. </param>
        /// <param name="newMeshContainerRef"> Returns the created mesh container. See <see cref="SlimDX2.Direct3D9.MeshContainer"/>. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message  from D3DERR or D3DXERR, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT ID3DXAllocateHierarchy::CreateMeshContainer([None] const char* Name,[None] const D3DXMESHDATA* pMeshData,[None] const D3DXMATERIAL* pMaterials,[None] const D3DXEFFECTINSTANCE* pEffectInstances,[None] int NumMaterials,[None] const int* pAdjacency,[None] LPD3DXSKININFO pSkinInfo,[None] LPD3DXMESHCONTAINER* ppNewMeshContainer)</unmanaged>
        public SlimDX2.Result CreateMeshContainer(string name, ref SlimDX2.Direct3D9.MeshData meshDataRef, ref SlimDX2.Direct3D9.ExtendedMaterial materialsRef, ref SlimDX2.Direct3D9.EffectInstance effectInstancesRef, int numMaterials, ref int adjacencyRef, SlimDX2.Direct3D9.SkinInfo pSkinInfo, ref SlimDX2.Direct3D9.MeshContainer newMeshContainerRef) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D9.ExtendedMaterial.__Native materialsRef_ = new SlimDX2.Direct3D9.ExtendedMaterial.__Native();
                materialsRef.__MarshalTo(ref materialsRef_);
                SlimDX2.Direct3D9.EffectInstance.__Native effectInstancesRef_ = new SlimDX2.Direct3D9.EffectInstance.__Native();
                effectInstancesRef.__MarshalTo(ref effectInstancesRef_);
                SlimDX2.Direct3D9.MeshContainer.__Native newMeshContainerRef_ = new SlimDX2.Direct3D9.MeshContainer.__Native();
                newMeshContainerRef.__MarshalTo(ref newMeshContainerRef_);
                SlimDX2.Result __result__;
                fixed (void* meshDataRef_ = &meshDataRef)
                    fixed (void* adjacencyRef_ = &adjacencyRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 1 * 4, (void*)name_, meshDataRef_, &materialsRef_, &effectInstancesRef_, numMaterials, adjacencyRef_, (void*)((pSkinInfo == null)?IntPtr.Zero:pSkinInfo.NativePointer), &newMeshContainerRef_);
                Marshal.FreeHGlobal(name_ );
                materialsRef.__MarshalFrom(ref materialsRef_);
                materialsRef_.__MarshalFree();
                effectInstancesRef.__MarshalFrom(ref effectInstancesRef_);
                effectInstancesRef_.__MarshalFree();
                newMeshContainerRef.__MarshalFrom(ref newMeshContainerRef_);
                newMeshContainerRef_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Requests deallocation of a frame object.	
        /// </summary>	
        /// <param name="pFrameToFree"> Pointer to the frame to be deallocated. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message  from D3DERR or D3DXERR, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT ID3DXAllocateHierarchy::DestroyFrame([None] LPD3DXFRAME pFrameToFree)</unmanaged>
        public SlimDX2.Result DestroyFrame(ref SlimDX2.Direct3D9.Frame pFrameToFree) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pFrameToFree_ = new SlimDX2.Direct3D9.Frame.__Native();
                pFrameToFree.__MarshalTo(ref pFrameToFree_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 2 * 4, &pFrameToFree_);
                pFrameToFree.__MarshalFrom(ref pFrameToFree_);
                pFrameToFree_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Requests deallocation of a mesh container object.	
        /// </summary>	
        /// <param name="pMeshContainerToFree"> Pointer to the mesh container object to be deallocated. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message  from D3DERR or D3DXERR, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT ID3DXAllocateHierarchy::DestroyMeshContainer([None] LPD3DXMESHCONTAINER pMeshContainerToFree)</unmanaged>
        public SlimDX2.Result DestroyMeshContainer(ref SlimDX2.Direct3D9.MeshContainer pMeshContainerToFree) {
            unsafe {
                SlimDX2.Direct3D9.MeshContainer.__Native pMeshContainerToFree_ = new SlimDX2.Direct3D9.MeshContainer.__Native();
                pMeshContainerToFree.__MarshalTo(ref pMeshContainerToFree_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &pMeshContainerToFree_);
                pMeshContainerToFree.__MarshalFrom(ref pMeshContainerToFree_);
                pMeshContainerToFree_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXLoadUserData</unmanaged>
    public partial class ILoadUserData : SlimDX2.CppObject {
        public ILoadUserData(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Load top level data from a .x file.	
        /// </summary>	
        /// <param name="pXofChildData"> Pointer to a .x file data structure. This is defined in Dxfile.h. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from D3DERR or D3DXERR, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT ID3DXLoadUserData::LoadTopLevelData([None] LPD3DXFILEDATA pXofChildData)</unmanaged>
        public SlimDX2.Result LoadTopLevelData(SlimDX2.Direct3D9.FileData pXofChildData) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 0 * 4, (void*)((pXofChildData == null)?IntPtr.Zero:pXofChildData.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Load frame child data from a .x file.	
        /// </summary>	
        /// <param name="pFrame"> Pointer to a mesh container. See <see cref="SlimDX2.Direct3D9.Frame"/>. </param>
        /// <param name="pXofChildData"> Pointer to a .x file data structure. This is defined in Dxfile.h. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from D3DERR or D3DXERR, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error.  </returns>
        /// <unmanaged>HRESULT ID3DXLoadUserData::LoadFrameChildData([None] LPD3DXFRAME pFrame,[None] LPD3DXFILEDATA pXofChildData)</unmanaged>
        public SlimDX2.Result LoadFrameChildData(ref SlimDX2.Direct3D9.Frame pFrame, SlimDX2.Direct3D9.FileData pXofChildData) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pFrame_ = new SlimDX2.Direct3D9.Frame.__Native();
                pFrame.__MarshalTo(ref pFrame_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 1 * 4, &pFrame_, (void*)((pXofChildData == null)?IntPtr.Zero:pXofChildData.NativePointer));
                pFrame.__MarshalFrom(ref pFrame_);
                pFrame_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Load mesh child data from a .x file.	
        /// </summary>	
        /// <param name="pMeshContainer"> Pointer to a mesh container. See <see cref="SlimDX2.Direct3D9.MeshContainer"/>. </param>
        /// <param name="pXofChildData"> Pointer to a .x file data structure. This is defined in Dxfile.h. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from D3DERR or D3DXERR, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT ID3DXLoadUserData::LoadMeshChildData([None] LPD3DXMESHCONTAINER pMeshContainer,[None] LPD3DXFILEDATA pXofChildData)</unmanaged>
        public SlimDX2.Result LoadMeshChildData(ref SlimDX2.Direct3D9.MeshContainer pMeshContainer, SlimDX2.Direct3D9.FileData pXofChildData) {
            unsafe {
                SlimDX2.Direct3D9.MeshContainer.__Native pMeshContainer_ = new SlimDX2.Direct3D9.MeshContainer.__Native();
                pMeshContainer.__MarshalTo(ref pMeshContainer_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 2 * 4, &pMeshContainer_, (void*)((pXofChildData == null)?IntPtr.Zero:pXofChildData.NativePointer));
                pMeshContainer.__MarshalFrom(ref pMeshContainer_);
                pMeshContainer_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXSaveUserData</unmanaged>
    public partial class ISaveUserData : SlimDX2.CppObject {
        public ISaveUserData(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Add child data to the frame.	
        /// </summary>	
        /// <remarks>	
        ///   <see cref="SlimDX2.Direct3D9.ISaveUserData.RegisterTemplates"/> and <see cref="SlimDX2.Direct3D9.ISaveUserData.SaveTemplates"/> provide a mechanism for adding a template to a .x file for saving user data. 	
        /// </remarks>	
        /// <param name="frameRef"> Pointer to a mesh container. See <see cref="SlimDX2.Direct3D9.Frame"/>. </param>
        /// <param name="pXofSave"> Pointer to a .x file save object. Use the pointer to call <see cref="SlimDX2.Direct3D9.FileSaveObject.AddDataObject"/> to add a child data object. Do not save the data with <see cref="SlimDX2.Direct3D9.FileSaveObject.Save"/>. </param>
        /// <param name="pXofFrameData"> Pointer to a .x file data node. Use the pointer to call <see cref="SlimDX2.Direct3D9.FileSaveData.AddDataObject"/> to add a child data object. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT ID3DXSaveUserData::AddFrameChildData([None] const D3DXFRAME* pFrame,[None] LPD3DXFILESAVEOBJECT pXofSave,[None] LPD3DXFILESAVEDATA pXofFrameData)</unmanaged>
        public SlimDX2.Result AddFrameChildData(ref SlimDX2.Direct3D9.Frame frameRef, SlimDX2.Direct3D9.FileSaveObject pXofSave, SlimDX2.Direct3D9.FileSaveData pXofFrameData) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native frameRef_ = new SlimDX2.Direct3D9.Frame.__Native();
                frameRef.__MarshalTo(ref frameRef_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 0 * 4, &frameRef_, (void*)((pXofSave == null)?IntPtr.Zero:pXofSave.NativePointer), (void*)((pXofFrameData == null)?IntPtr.Zero:pXofFrameData.NativePointer));
                frameRef.__MarshalFrom(ref frameRef_);
                frameRef_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Add child data to the mesh.	
        /// </summary>	
        /// <param name="meshContainerRef"> Pointer to a mesh container. See <see cref="SlimDX2.Direct3D9.MeshContainer"/>. </param>
        /// <param name="pXofSave"> Pointer to a .x file save object. Use the pointer to call <see cref="SlimDX2.Direct3D9.FileSaveObject.AddDataObject"/> to add a child data object. Do not save the data with <see cref="SlimDX2.Direct3D9.FileSaveObject.Save"/>. </param>
        /// <param name="pXofMeshData"> Pointer to a .x file data node. Use the pointer to call <see cref="SlimDX2.Direct3D9.FileSaveData.AddDataObject"/> to add a child data object. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT ID3DXSaveUserData::AddMeshChildData([None] const D3DXMESHCONTAINER* pMeshContainer,[None] LPD3DXFILESAVEOBJECT pXofSave,[None] LPD3DXFILESAVEDATA pXofMeshData)</unmanaged>
        public SlimDX2.Result AddMeshChildData(ref SlimDX2.Direct3D9.MeshContainer meshContainerRef, SlimDX2.Direct3D9.FileSaveObject pXofSave, SlimDX2.Direct3D9.FileSaveData pXofMeshData) {
            unsafe {
                SlimDX2.Direct3D9.MeshContainer.__Native meshContainerRef_ = new SlimDX2.Direct3D9.MeshContainer.__Native();
                meshContainerRef.__MarshalTo(ref meshContainerRef_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 1 * 4, &meshContainerRef_, (void*)((pXofSave == null)?IntPtr.Zero:pXofSave.NativePointer), (void*)((pXofMeshData == null)?IntPtr.Zero:pXofMeshData.NativePointer));
                meshContainerRef.__MarshalFrom(ref meshContainerRef_);
                meshContainerRef_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Add a top level object before the frame hierarchy.	
        /// </summary>	
        /// <param name="pXofSave"> Pointer to a .x file save object. Use this pointer to call {{IDirectXFileSaveObject::CreateDataObject}} to create the data object to be saved. Then call {{IDirectXFileSaveObject::SaveData}} to save the data. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT ID3DXSaveUserData::AddTopLevelDataObjectsPre([None] LPD3DXFILESAVEOBJECT pXofSave)</unmanaged>
        public SlimDX2.Result AddTopLevelDataObjectsPre(SlimDX2.Direct3D9.FileSaveObject pXofSave) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 2 * 4, (void*)((pXofSave == null)?IntPtr.Zero:pXofSave.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Add a top level object after the frame hierarchy.	
        /// </summary>	
        /// <param name="pXofSave"> Pointer to a .x file save object. Use this pointer to call {{IDirectXFileSaveObject::CreateDataObject}} to create the data object to be saved. Then call {{IDirectXFileSaveObject::SaveData}} to save the data. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT ID3DXSaveUserData::AddTopLevelDataObjectsPost([None] LPD3DXFILESAVEOBJECT pXofSave)</unmanaged>
        public SlimDX2.Result AddTopLevelDataObjectsPost(SlimDX2.Direct3D9.FileSaveObject pXofSave) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, (void*)((pXofSave == null)?IntPtr.Zero:pXofSave.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback for the user to register a .x file template.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXSaveUserData::RegisterTemplates and <see cref="SlimDX2.Direct3D9.ISaveUserData.SaveTemplates"/> provide a mechanism for adding a template to a .x file for saving user data. 	
        /// </remarks>	
        /// <param name="pXFileApi"> Use this pointer to register user-defined .x file templates. See <see cref="SlimDX2.Direct3D9.File"/>. Do not use this parameter to add data objects. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT ID3DXSaveUserData::RegisterTemplates([None] LPD3DXFILE pXFileApi)</unmanaged>
        public SlimDX2.Result RegisterTemplates(SlimDX2.Direct3D9.File pXFileApi) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)((pXFileApi == null)?IntPtr.Zero:pXFileApi.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback for the user to save a .x file template.	
        /// </summary>	
        /// <remarks>	
        ///   <see cref="SlimDX2.Direct3D9.ISaveUserData.RegisterTemplates"/> and ID3DXSaveUserData::SaveTemplates provide a mechanism for adding a template to a .x file for saving user data. 	
        /// </remarks>	
        /// <param name="pXofSave"> Pointer to a .x file save object. Do not use this parameter to add data objects. See <see cref="SlimDX2.Direct3D9.FileSaveObject"/>. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT ID3DXSaveUserData::SaveTemplates([None] LPD3DXFILESAVEOBJECT pXofSave)</unmanaged>
        public SlimDX2.Result SaveTemplates(SlimDX2.Direct3D9.FileSaveObject pXofSave) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)((pXofSave == null)?IntPtr.Zero:pXofSave.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXAnimationSet</unmanaged>
    [Guid("698cfb3f-9289-4d95-9a57-33a94b5a65f9")]
    public partial class AnimationSet : SlimDX2.ComObject {
        public AnimationSet(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the animation set name.	
        /// </summary>	
        /// <unmanaged>const char* ID3DXAnimationSet::GetName()</unmanaged>
        public IntPtr Name {
                get { return GetName(); }
        }
        
        /// <summary>	
        /// Gets the period of the animation set.	
        /// </summary>	
        /// <remarks>	
        ///  The period is the range of time that the animation key frames are valid. For looping animations, this is the period of the loop. The time units that the key frames are specified in (for example, seconds) is determined by the application.  	
        /// </remarks>	
        /// <unmanaged>DOUBLE ID3DXAnimationSet::GetPeriod()</unmanaged>
        public double Period {
                get { return GetPeriod(); }
        }
        
        /// <summary>	
        /// Gets the number of animations in the animation set.	
        /// </summary>	
        /// <unmanaged>UINT ID3DXAnimationSet::GetNumAnimations()</unmanaged>
        public int NumAnimations {
                get { return GetNumAnimations(); }
        }
        
        /// <summary>	
        /// Gets the animation set name.	
        /// </summary>	
        /// <returns>  {{LPCSTR}}  Name of the animation set. </returns>
        /// <unmanaged>const char* ID3DXAnimationSet::GetName()</unmanaged>
        internal IntPtr GetName() {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the period of the animation set.	
        /// </summary>	
        /// <remarks>	
        ///  The period is the range of time that the animation key frames are valid. For looping animations, this is the period of the loop. The time units that the key frames are specified in (for example, seconds) is determined by the application.  	
        /// </remarks>	
        /// <returns>  {{DOUBLE}}  Period of the animation set. </returns>
        /// <unmanaged>DOUBLE ID3DXAnimationSet::GetPeriod()</unmanaged>
        internal double GetPeriod() {
            unsafe {
                double __result__;
                __result__= (double)SlimDX2.Direct3D9.LocalInterop.CalliSystemDouble(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns time position in the local timeframe of an animation set.	
        /// </summary>	
        /// <remarks>	
        ///  The time position returned by this method can be used as the PeriodicPosition parameter of <see cref="SlimDX2.Direct3D9.AnimationSet.GetSRT"/>. 	
        /// </remarks>	
        /// <param name="position"> Local time of the animation set. </param>
        /// <returns>  {{DOUBLE}}  Time position as measured in the timeframe of the animation set. This value will be bounded by the period of the animation set. </returns>
        /// <unmanaged>DOUBLE ID3DXAnimationSet::GetPeriodicPosition([None] DOUBLE Position)</unmanaged>
        public double GetPeriodicPosition(double position) {
            unsafe {
                double __result__;
                __result__= (double)SlimDX2.Direct3D9.LocalInterop.CalliSystemDouble(_nativePointer, 5 * 4, position);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of animations in the animation set.	
        /// </summary>	
        /// <returns>  {{UINT}}  Number of animations in the animation set. </returns>
        /// <unmanaged>UINT ID3DXAnimationSet::GetNumAnimations()</unmanaged>
        internal int GetNumAnimations() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the name of an animation, given its index.	
        /// </summary>	
        /// <param name="index"> Index of the animation. </param>
        /// <param name="nameRef"> Address of a pointer to a string that receives the animation name. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationSet::GetAnimationNameByIndex([None] UINT Index,[Out] const char** ppName)</unmanaged>
        public SlimDX2.Result GetAnimationNameByIndex(int index, IntPtr nameRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, index, (void*)nameRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the index of an animation, given its name.	
        /// </summary>	
        /// <param name="nameRef"> Name of the animation. </param>
        /// <param name="indexRef"> Pointer to the animation index. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationSet::GetAnimationIndexByName([Out] const char* pName,[Out] UINT* pIndex)</unmanaged>
        public SlimDX2.Result GetAnimationIndexByName(IntPtr nameRef, out int indexRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* indexRef_ = &indexRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, (void*)nameRef, indexRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the scale, rotation, and translation values of the animation set.	
        /// </summary>	
        /// <param name="periodicPosition"> Position of the animation set. The position can be obtained by calling <see cref="SlimDX2.Direct3D9.AnimationSet.GetPeriodicPosition"/>. </param>
        /// <param name="animation"> Animation index. </param>
        /// <param name="scaleRef"> Pointer to the <see cref="SlimMath.Vector3"/> vector that describes the scale of the animation set. </param>
        /// <param name="rotationRef"> Pointer to the <see cref="SlimMath.Quaternion"/> quaternion that describes the rotation of the animation set. </param>
        /// <param name="translationRef"> Pointer to the <see cref="SlimMath.Vector3"/> vector that describes the translation of the animation set. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationSet::GetSRT([None] DOUBLE PeriodicPosition,[None] UINT Animation,[Out] D3DXVECTOR3* pScale,[Out] D3DXQUATERNION* pRotation,[Out] D3DXVECTOR3* pTranslation)</unmanaged>
        public SlimDX2.Result GetSRT(double periodicPosition, int animation, out SlimMath.Vector3 scaleRef, out SlimMath.Quaternion rotationRef, out SlimMath.Vector3 translationRef) {
            unsafe {
                scaleRef = new SlimMath.Vector3();
                rotationRef = new SlimMath.Quaternion();
                translationRef = new SlimMath.Vector3();
                SlimDX2.Result __result__;
                fixed (void* scaleRef_ = &scaleRef)
                    fixed (void* rotationRef_ = &rotationRef)
                        fixed (void* translationRef_ = &translationRef)
                            __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, periodicPosition, animation, scaleRef_, rotationRef_, translationRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets information about a specific callback in the animation set.	
        /// </summary>	
        /// <param name="position"> Position from which to find callbacks. </param>
        /// <param name="flags"> Callback search flags. This parameter can be set to a combination of one or more flags from <see cref="SlimDX2.Direct3D9.CallbackSearchFlags"/>. </param>
        /// <param name="callbackPositionRef"> Pointer to the position of the callback. </param>
        /// <param name="callbackDataRef"> Address of the callback data pointer. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationSet::GetCallback([None] DOUBLE Position,[None] int Flags,[Out] DOUBLE* pCallbackPosition,[None] void** ppCallbackData)</unmanaged>
        public SlimDX2.Result GetCallback(double position, int flags, out double callbackPositionRef, IntPtr callbackDataRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* callbackPositionRef_ = &callbackPositionRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, position, flags, callbackPositionRef_, (void*)callbackDataRef);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXKeyframedAnimationSet</unmanaged>
    [Guid("fa4e8e3a-9786-407d-8b4c-5995893764af")]
    public partial class KeyframedAnimationSet : SlimDX2.Direct3D9.AnimationSet {
        public KeyframedAnimationSet(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the type of the animation set playback loop.	
        /// </summary>	
        /// <unmanaged>D3DXPLAYBACK_TYPE ID3DXKeyframedAnimationSet::GetPlaybackType()</unmanaged>
        public SlimDX2.Direct3D9.PlaybackType PlaybackType {
                get { return GetPlaybackType(); }
        }
        
        /// <summary>	
        /// Gets the number of animation key frame ticks that occur per second.	
        /// </summary>	
        /// <unmanaged>DOUBLE ID3DXKeyframedAnimationSet::GetSourceTicksPerSecond()</unmanaged>
        public double SourceTicksPerSecond {
                get { return GetSourceTicksPerSecond(); }
        }
        
        /// <summary>	
        /// Gets the number of callback keys in the animation set.	
        /// </summary>	
        /// <unmanaged>UINT ID3DXKeyframedAnimationSet::GetNumCallbackKeys()</unmanaged>
        public int NumCallbackKeys {
                get { return GetNumCallbackKeys(); }
        }
        
        /// <summary>	
        /// Gets the type of the animation set playback loop.	
        /// </summary>	
        /// <returns>  <see cref="SlimDX2.Direct3D9.PlaybackType"/>  Type of the animation set playback loop. See <see cref="SlimDX2.Direct3D9.PlaybackType"/>. </returns>
        /// <unmanaged>D3DXPLAYBACK_TYPE ID3DXKeyframedAnimationSet::GetPlaybackType()</unmanaged>
        internal SlimDX2.Direct3D9.PlaybackType GetPlaybackType() {
            unsafe {
                SlimDX2.Direct3D9.PlaybackType __result__;
                __result__= (SlimDX2.Direct3D9.PlaybackType)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of animation key frame ticks that occur per second.	
        /// </summary>	
        /// <returns>  {{DOUBLE}}  Number of animation key frame ticks that occur per second. </returns>
        /// <unmanaged>DOUBLE ID3DXKeyframedAnimationSet::GetSourceTicksPerSecond()</unmanaged>
        internal double GetSourceTicksPerSecond() {
            unsafe {
                double __result__;
                __result__= (double)SlimDX2.Direct3D9.LocalInterop.CalliSystemDouble(_nativePointer, 12 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of scale keys in the specified key frame animation.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <returns>  {{UINT}}  Number of scale keys in the specified key frame animation. </returns>
        /// <unmanaged>UINT ID3DXKeyframedAnimationSet::GetNumScaleKeys([None] UINT Animation)</unmanaged>
        public int GetNumScaleKeys(int animation) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, animation);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Fills an array with scale key data used for key frame animation.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="pScaleKeys"> Pointer to a user-allocated array of <see cref="SlimDX2.Direct3D9.ScaleKey"/> vectors that the method is to fill with animation scale data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::GetScaleKeys([None] UINT Animation,[None] LPD3DXKEY_VECTOR3 pScaleKeys)</unmanaged>
        public SlimDX2.Result GetScaleKeys(int animation, ref SlimDX2.Direct3D9.ScaleKey pScaleKeys) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pScaleKeys_ = &pScaleKeys)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, animation, pScaleKeys_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get scale information for a specific key frame in the animation set.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="key"> Key frame. </param>
        /// <param name="pScaleKey"> Pointer to the scale data. See  <see cref="SlimDX2.Direct3D9.ScaleKey"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::GetScaleKey([None] UINT Animation,[None] UINT Key,[None] LPD3DXKEY_VECTOR3 pScaleKey)</unmanaged>
        public SlimDX2.Result GetScaleKey(int animation, int key, ref SlimDX2.Direct3D9.ScaleKey pScaleKey) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pScaleKey_ = &pScaleKey)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, animation, key, pScaleKey_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set scale information for a specific key frame in the animation set.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="key"> Key frame. </param>
        /// <param name="pScaleKey"> Pointer to the scale data. See <see cref="SlimDX2.Direct3D9.ScaleKey"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::SetScaleKey([None] UINT Animation,[None] UINT Key,[None] LPD3DXKEY_VECTOR3 pScaleKey)</unmanaged>
        public SlimDX2.Result SetScaleKey(int animation, int key, ref SlimDX2.Direct3D9.ScaleKey pScaleKey) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pScaleKey_ = &pScaleKey)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, animation, key, pScaleKey_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of rotation keys in the specified key frame animation.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <returns>  {{UINT}}  Number of rotation keys in the specified key frame animation. </returns>
        /// <unmanaged>UINT ID3DXKeyframedAnimationSet::GetNumRotationKeys([None] UINT Animation)</unmanaged>
        public int GetNumRotationKeys(int animation) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, animation);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Fills an array with rotational key data used for key frame animation.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="pRotationKeys"> Pointer to a user-allocated array of <see cref="SlimDX2.Direct3D9.RotationKey"/> quaternions that the method is to fill with animation rotation data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::GetRotationKeys([None] UINT Animation,[None] LPD3DXKEY_QUATERNION pRotationKeys)</unmanaged>
        public SlimDX2.Result GetRotationKeys(int animation, ref SlimDX2.Direct3D9.RotationKey pRotationKeys) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pRotationKeys_ = &pRotationKeys)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, animation, pRotationKeys_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get rotation information for a specific key frame in the animation set.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="key"> Key frame. </param>
        /// <param name="pRotationKey"> Pointer to the rotation data. See  <see cref="SlimDX2.Direct3D9.RotationKey"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::GetRotationKey([None] UINT Animation,[None] UINT Key,[None] LPD3DXKEY_QUATERNION pRotationKey)</unmanaged>
        public SlimDX2.Result GetRotationKey(int animation, int key, ref SlimDX2.Direct3D9.RotationKey pRotationKey) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pRotationKey_ = &pRotationKey)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, animation, key, pRotationKey_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set rotation information for a specific key frame in the animation set.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="key"> Key frame. </param>
        /// <param name="pRotationKey"> Pointer to the rotation data. See <see cref="SlimDX2.Direct3D9.ScaleKey"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::SetRotationKey([None] UINT Animation,[None] UINT Key,[None] LPD3DXKEY_QUATERNION pRotationKey)</unmanaged>
        public SlimDX2.Result SetRotationKey(int animation, int key, ref SlimDX2.Direct3D9.RotationKey pRotationKey) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pRotationKey_ = &pRotationKey)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, animation, key, pRotationKey_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of translation keys in the specified key frame animation.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <returns>  {{UINT}}  Number of translation keys in the specified key frame animation. </returns>
        /// <unmanaged>UINT ID3DXKeyframedAnimationSet::GetNumTranslationKeys([None] UINT Animation)</unmanaged>
        public int GetNumTranslationKeys(int animation) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, animation);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Fills an array with translational key data used for key frame animation.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="pTranslationKeys"> Pointer to a user-allocated array of <see cref="SlimDX2.Direct3D9.ScaleKey"/> vectors that the method is to fill with animation translation data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::GetTranslationKeys([None] UINT Animation,[None] LPD3DXKEY_VECTOR3 pTranslationKeys)</unmanaged>
        public SlimDX2.Result GetTranslationKeys(int animation, ref SlimDX2.Direct3D9.ScaleKey pTranslationKeys) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pTranslationKeys_ = &pTranslationKeys)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 22 * 4, animation, pTranslationKeys_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get translation information for a specific key frame in the animation set.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="key"> Key Frame. </param>
        /// <param name="pTranslationKey"> Pointer to the rotation information. See <see cref="SlimDX2.Direct3D9.ScaleKey"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::GetTranslationKey([None] UINT Animation,[None] UINT Key,[None] LPD3DXKEY_VECTOR3 pTranslationKey)</unmanaged>
        public SlimDX2.Result GetTranslationKey(int animation, int key, ref SlimDX2.Direct3D9.ScaleKey pTranslationKey) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pTranslationKey_ = &pTranslationKey)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, animation, key, pTranslationKey_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set translation information for a specific key frame in the animation set.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="key"> Key Frame. </param>
        /// <param name="pTranslationKey"> Pointer to the translation data. See <see cref="SlimDX2.Direct3D9.ScaleKey"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::SetTranslationKey([None] UINT Animation,[None] UINT Key,[None] LPD3DXKEY_VECTOR3 pTranslationKey)</unmanaged>
        public SlimDX2.Result SetTranslationKey(int animation, int key, ref SlimDX2.Direct3D9.ScaleKey pTranslationKey) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pTranslationKey_ = &pTranslationKey)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, animation, key, pTranslationKey_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of callback keys in the animation set.	
        /// </summary>	
        /// <returns>  {{UINT}}  Number of callback keys in the animation set. </returns>
        /// <unmanaged>UINT ID3DXKeyframedAnimationSet::GetNumCallbackKeys()</unmanaged>
        internal int GetNumCallbackKeys() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Fills an array with callback key data used for key frame animation.	
        /// </summary>	
        /// <param name="pCallbackKeys"> Pointer to a user-allocated array of <see cref="SlimDX2.Direct3D9.CallbackKey"/> structures that the method is to fill with callback data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::GetCallbackKeys([None] LPD3DXKEY_CALLBACK pCallbackKeys)</unmanaged>
        public SlimDX2.Result GetCallbackKeys(ref SlimDX2.Direct3D9.CallbackKey pCallbackKeys) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pCallbackKeys_ = &pCallbackKeys)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 26 * 4, pCallbackKeys_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets information about a specific callback in the animation set.	
        /// </summary>	
        /// <param name="key"> Animation index. </param>
        /// <param name="pCallbackKey"> Pointer to the {{callback function}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::GetCallbackKey([None] UINT Key,[None] LPD3DXKEY_CALLBACK pCallbackKey)</unmanaged>
        public SlimDX2.Result GetCallbackKey(int key, ref SlimDX2.Direct3D9.CallbackKey pCallbackKey) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pCallbackKey_ = &pCallbackKey)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 27 * 4, key, pCallbackKey_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets information about a specific callback in the animation set.	
        /// </summary>	
        /// <param name="key"> Animation index. </param>
        /// <param name="pCallbackKey"> Pointer to the {{callback function}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::SetCallbackKey([None] UINT Key,[None] LPD3DXKEY_CALLBACK pCallbackKey)</unmanaged>
        public SlimDX2.Result SetCallbackKey(int key, ref SlimDX2.Direct3D9.CallbackKey pCallbackKey) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pCallbackKey_ = &pCallbackKey)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 28 * 4, key, pCallbackKey_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Removes the scale data at the specified key frame.	
        /// </summary>	
        /// <remarks>	
        ///  This method is slow and should not be used after an animation has begun to play. 	
        /// </remarks>	
        /// <param name="animation"> Animation identifier. </param>
        /// <param name="key"> Key frame. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::UnregisterScaleKey([None] UINT Animation,[None] UINT Key)</unmanaged>
        public SlimDX2.Result UnregisterScaleKey(int animation, int key) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 29 * 4, animation, key);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Removes the rotation data at the specified key frame.	
        /// </summary>	
        /// <remarks>	
        ///  This method is slow and should not be used after an animation has begun to play. 	
        /// </remarks>	
        /// <param name="animation"> Animation identifier. </param>
        /// <param name="key"> Key frame. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::UnregisterRotationKey([None] UINT Animation,[None] UINT Key)</unmanaged>
        public SlimDX2.Result UnregisterRotationKey(int animation, int key) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 30 * 4, animation, key);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Removes the translation data at the specified key frame.	
        /// </summary>	
        /// <remarks>	
        ///  This method is slow and should not be used after an animation has begun to play. 	
        /// </remarks>	
        /// <param name="animation"> Animation identifier. </param>
        /// <param name="key"> Key frame. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::UnregisterTranslationKey([None] UINT Animation,[None] UINT Key)</unmanaged>
        public SlimDX2.Result UnregisterTranslationKey(int animation, int key) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 31 * 4, animation, key);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Register the scale, rotate, and translate (SRT) key frame data for an animation.	
        /// </summary>	
        /// <param name="nameRef"> Pointer to the animation name. </param>
        /// <param name="numScaleKeys"> Number of scale keys. </param>
        /// <param name="numRotationKeys"> Number of rotation keys. </param>
        /// <param name="numTranslationKeys"> Number of translation keys. </param>
        /// <param name="scaleKeysRef"> Address of a pointer to a user-allocated array of <see cref="SlimDX2.Direct3D9.ScaleKey"/> vectors that the method fills with scale data. </param>
        /// <param name="rotationKeysRef"> Address of a pointer to a user-allocated array of <see cref="SlimDX2.Direct3D9.RotationKey"/> quaternions that the method fills with rotation data. </param>
        /// <param name="translationKeysRef"> Address of a pointer to a user-allocated array of <see cref="SlimDX2.Direct3D9.ScaleKey"/> vectors that the method fills with translation data. </param>
        /// <param name="animationIndexRef"> Returns the animation index. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::RegisterAnimationSRTKeys([None] const char* pName,[None] UINT NumScaleKeys,[None] UINT NumRotationKeys,[None] UINT NumTranslationKeys,[None] const D3DXKEY_VECTOR3* pScaleKeys,[None] const D3DXKEY_QUATERNION* pRotationKeys,[None] const D3DXKEY_VECTOR3* pTranslationKeys,[None] int* pAnimationIndex)</unmanaged>
        public SlimDX2.Result RegisterAnimationSRTKeys(string nameRef, int numScaleKeys, int numRotationKeys, int numTranslationKeys, ref SlimDX2.Direct3D9.ScaleKey scaleKeysRef, ref SlimDX2.Direct3D9.RotationKey rotationKeysRef, ref SlimDX2.Direct3D9.ScaleKey translationKeysRef, ref int animationIndexRef) {
            unsafe {
                IntPtr nameRef_ = Marshal.StringToHGlobalAnsi(nameRef);
                SlimDX2.Result __result__;
                fixed (void* scaleKeysRef_ = &scaleKeysRef)
                    fixed (void* rotationKeysRef_ = &rotationKeysRef)
                        fixed (void* translationKeysRef_ = &translationKeysRef)
                            fixed (void* animationIndexRef_ = &animationIndexRef)
                                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 32 * 4, (void*)nameRef_, numScaleKeys, numRotationKeys, numTranslationKeys, scaleKeysRef_, rotationKeysRef_, translationKeysRef_, animationIndexRef_);
                Marshal.FreeHGlobal(nameRef_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Transforms animations in an animation set into a compressed format and returns a pointer to the buffer that stores the compressed data.	
        /// </summary>	
        /// <param name="flags"> One of the <see cref="SlimDX2.Direct3D9.CompressionFlags"/> values that define the compression mode used for storing compressed animation set data. D3DXCOMPRESS_DEFAULT is the only value currently supported. </param>
        /// <param name="lossiness"> Desired compression loss ratio, in the range from 0 to 1. </param>
        /// <param name="pHierarchy"> Pointer to a <see cref="SlimDX2.Direct3D9.Frame"/> transformation frame hierarchy. Can be NULL. </param>
        /// <param name="compressedDataRef"> Address of a pointer to the <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> compressed animation set. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::Compress([None] int Flags,[None] FLOAT Lossiness,[None] LPD3DXFRAME pHierarchy,[None] LPD3DXBUFFER* ppCompressedData)</unmanaged>
        public SlimDX2.Result Compress(int flags, float lossiness, ref SlimDX2.Direct3D9.Frame pHierarchy, out SlimDX2.Direct3D9.ShaderBytecode compressedDataRef) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pHierarchy_ = new SlimDX2.Direct3D9.Frame.__Native();
                pHierarchy.__MarshalTo(ref pHierarchy_);
                IntPtr compressedDataRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 33 * 4, flags, lossiness, &pHierarchy_, &compressedDataRef_);
                pHierarchy.__MarshalFrom(ref pHierarchy_);
                pHierarchy_.__MarshalFree();
                compressedDataRef = (compressedDataRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(compressedDataRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Remove the animation data from the animation set.	
        /// </summary>	
        /// <param name="index"> The animation index. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::UnregisterAnimation([None] UINT Index)</unmanaged>
        public SlimDX2.Result UnregisterAnimation(int index) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 34 * 4, index);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXCompressedAnimationSet</unmanaged>
    [Guid("6cc2480d-3808-4739-9f88-de49facd8d4c")]
    public partial class CompressedAnimationSet : SlimDX2.Direct3D9.AnimationSet {
        public CompressedAnimationSet(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the type of the animation set playback loop.	
        /// </summary>	
        /// <unmanaged>D3DXPLAYBACK_TYPE ID3DXCompressedAnimationSet::GetPlaybackType()</unmanaged>
        public SlimDX2.Direct3D9.PlaybackType PlaybackType {
                get { return GetPlaybackType(); }
        }
        
        /// <summary>	
        /// Gets the number of animation key frame ticks that occur per second.	
        /// </summary>	
        /// <unmanaged>DOUBLE ID3DXCompressedAnimationSet::GetSourceTicksPerSecond()</unmanaged>
        public double SourceTicksPerSecond {
                get { return GetSourceTicksPerSecond(); }
        }
        
        /// <summary>	
        /// Gets the data buffer that stores compressed key frame animation data.	
        /// </summary>	
        /// <unmanaged>HRESULT ID3DXCompressedAnimationSet::GetCompressedData([Out] LPD3DXBUFFER* ppCompressedData)</unmanaged>
        public SlimDX2.Direct3D9.ShaderBytecode CompressedData {
                get { SlimDX2.Direct3D9.ShaderBytecode __output__; GetCompressedData(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the number of callback keys in the animation set.	
        /// </summary>	
        /// <unmanaged>UINT ID3DXCompressedAnimationSet::GetNumCallbackKeys()</unmanaged>
        public int NumCallbackKeys {
                get { return GetNumCallbackKeys(); }
        }
        
        /// <summary>	
        /// Gets the type of the animation set playback loop.	
        /// </summary>	
        /// <returns>  <see cref="SlimDX2.Direct3D9.PlaybackType"/>  Type of the animation set playback loop. See <see cref="SlimDX2.Direct3D9.PlaybackType"/>. </returns>
        /// <unmanaged>D3DXPLAYBACK_TYPE ID3DXCompressedAnimationSet::GetPlaybackType()</unmanaged>
        internal SlimDX2.Direct3D9.PlaybackType GetPlaybackType() {
            unsafe {
                SlimDX2.Direct3D9.PlaybackType __result__;
                __result__= (SlimDX2.Direct3D9.PlaybackType)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of animation key frame ticks that occur per second.	
        /// </summary>	
        /// <returns>  {{DOUBLE}}  Number of animation key frame ticks that occur per second. </returns>
        /// <unmanaged>DOUBLE ID3DXCompressedAnimationSet::GetSourceTicksPerSecond()</unmanaged>
        internal double GetSourceTicksPerSecond() {
            unsafe {
                double __result__;
                __result__= (double)SlimDX2.Direct3D9.LocalInterop.CalliSystemDouble(_nativePointer, 12 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the data buffer that stores compressed key frame animation data.	
        /// </summary>	
        /// <param name="compressedDataRef"> Address of a pointer to the <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> data buffer that receives compressed key frame animation data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXCompressedAnimationSet::GetCompressedData([Out] LPD3DXBUFFER* ppCompressedData)</unmanaged>
        internal SlimDX2.Result GetCompressedData(out SlimDX2.Direct3D9.ShaderBytecode compressedDataRef) {
            unsafe {
                IntPtr compressedDataRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, &compressedDataRef_);
                compressedDataRef = (compressedDataRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(compressedDataRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of callback keys in the animation set.	
        /// </summary>	
        /// <returns>  {{UINT}}  Number of callback keys in the animation set. </returns>
        /// <unmanaged>UINT ID3DXCompressedAnimationSet::GetNumCallbackKeys()</unmanaged>
        internal int GetNumCallbackKeys() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Fills an array with callback key data used for key frame animation.	
        /// </summary>	
        /// <param name="pCallbackKeys"> Pointer to a user-allocated array of <see cref="SlimDX2.Direct3D9.CallbackKey"/> structures that the method is to fill with callback data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXCompressedAnimationSet::GetCallbackKeys([None] LPD3DXKEY_CALLBACK pCallbackKeys)</unmanaged>
        public SlimDX2.Result GetCallbackKeys(ref SlimDX2.Direct3D9.CallbackKey pCallbackKeys) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pCallbackKeys_ = &pCallbackKeys)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, pCallbackKeys_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXAnimationCallbackHandler</unmanaged>
    public partial class AnimationCallbackHandler : SlimDX2.CppObject {
        public AnimationCallbackHandler(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// The application implements this method. This method is called when a callback occurs for an animation set in one of the tracks during a  call to <see cref="SlimDX2.Direct3D9.AnimationController.AdvanceTime"/>.	
        /// </summary>	
        /// <param name="track"> Identifier of the track on which the callback occurs. </param>
        /// <param name="callbackDataRef"> Pointer to user-owned callback data. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message  from {{D3DERR}} or {{D3DXERR}}. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationCallbackHandler::HandleCallback([None] UINT Track,[None] void* pCallbackData)</unmanaged>
        public SlimDX2.Result HandleCallback(int track, IntPtr callbackDataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 0 * 4, track, (void*)callbackDataRef);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXAnimationController</unmanaged>
    [Guid("ac8948ec-f86d-43e2-96de-31fc35f96d9e")]
    public partial class AnimationController : SlimDX2.ComObject {
        public AnimationController(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the maximum number of animation outputs the animation controller can support.	
        /// </summary>	
        /// <unmanaged>UINT ID3DXAnimationController::GetMaxNumAnimationOutputs()</unmanaged>
        public int MaxNumAnimationOutputs {
                get { return GetMaxNumAnimationOutputs(); }
        }
        
        /// <summary>	
        /// Gets the maximum number of animation sets the animation controller can support.	
        /// </summary>	
        /// <unmanaged>UINT ID3DXAnimationController::GetMaxNumAnimationSets()</unmanaged>
        public int MaxNumAnimationSets {
                get { return GetMaxNumAnimationSets(); }
        }
        
        /// <summary>	
        /// Gets the maximum number of tracks in the animation controller.	
        /// </summary>	
        /// <remarks>	
        ///  The maximum number of tracks the controller can manage. 	
        /// </remarks>	
        /// <unmanaged>UINT ID3DXAnimationController::GetMaxNumTracks()</unmanaged>
        public int MaxNumTracks {
                get { return GetMaxNumTracks(); }
        }
        
        /// <summary>	
        /// Gets the maximum number of events the animation controller can support.	
        /// </summary>	
        /// <unmanaged>UINT ID3DXAnimationController::GetMaxNumEvents()</unmanaged>
        public int MaxNumEvents {
                get { return GetMaxNumEvents(); }
        }
        
        /// <summary>	
        /// Returns the number of animation sets currently registered in the animation controller.	
        /// </summary>	
        /// <remarks>	
        ///  The controller contains any number of animations sets and tracks. Animation sets can be registered with  {{RegisterAnimationOutput}}.  An animation controller created by a call  to {{D3DXLoadMeshHierarchyFromX}} will automatically register loaded animation sets. 	
        /// </remarks>	
        /// <unmanaged>UINT ID3DXAnimationController::GetNumAnimationSets()</unmanaged>
        public int NumAnimationSets {
                get { return GetNumAnimationSets(); }
        }
        
        /// <summary>	
        /// Gets the global animation time.	
        /// </summary>	
        /// <remarks>	
        ///  Animations are designed using a local animation time and mixed into global time with {{AdvanceTime}}. 	
        /// </remarks>	
        /// <unmanaged>DOUBLE ID3DXAnimationController::GetTime()</unmanaged>
        public double Time {
                get { return GetTime(); }
        }
        
        /// <summary>	
        /// Gets the current priority blending weight used by the animation controller.	
        /// </summary>	
        /// <remarks>	
        ///  The priority blending weight is used to blend high and low priority tracks together. 	
        /// </remarks>	
        /// <unmanaged>FLOAT ID3DXAnimationController::GetPriorityBlend()</unmanaged>
        public float PriorityBlend {
                get { return GetPriorityBlend(); }
                set { SetPriorityBlend(value); }
        }
        
        /// <summary>	
        /// Returns an event handle to a priority blend event that is currently running.	
        /// </summary>	
        /// <unmanaged>D3DXEVENTHANDLE ID3DXAnimationController::GetCurrentPriorityBlend()</unmanaged>
        public int CurrentPriorityBlend {
                get { return GetCurrentPriorityBlend(); }
        }
        
        /// <summary>	
        /// Get the maximum number of animation outputs the animation controller can support.	
        /// </summary>	
        /// <returns>  {{UINT}}  The maximum number of animation outputs the controller can manage. </returns>
        /// <unmanaged>UINT ID3DXAnimationController::GetMaxNumAnimationOutputs()</unmanaged>
        internal int GetMaxNumAnimationOutputs() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the maximum number of animation sets the animation controller can support.	
        /// </summary>	
        /// <returns>  {{UINT}}  The maximum number of animation sets the controller can manage. </returns>
        /// <unmanaged>UINT ID3DXAnimationController::GetMaxNumAnimationSets()</unmanaged>
        internal int GetMaxNumAnimationSets() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the maximum number of tracks in the animation controller.	
        /// </summary>	
        /// <remarks>	
        ///  The maximum number of tracks the controller can manage. 	
        /// </remarks>	
        /// <returns>  {{UINT}}  Number of tracks. </returns>
        /// <unmanaged>UINT ID3DXAnimationController::GetMaxNumTracks()</unmanaged>
        internal int GetMaxNumTracks() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the maximum number of events the animation controller can support.	
        /// </summary>	
        /// <returns>  {{UINT}}  The maximum number of events the controller can manage. </returns>
        /// <unmanaged>UINT ID3DXAnimationController::GetMaxNumEvents()</unmanaged>
        internal int GetMaxNumEvents() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds an animation output to the animation controller and registers pointers for scale, rotate, and translate (SRT) transformations.	
        /// </summary>	
        /// <remarks>	
        ///  If the animation output is already registered, pMatrix will be filled with the input transformation data. Animation sets created with {{D3DXLoadMeshHierarchyFromX}} automatically register all loaded animation sets. 	
        /// </remarks>	
        /// <param name="nameRef"> Name of the animation output. </param>
        /// <param name="matrixRef"> Pointer to a <see cref="SlimMath.Matrix"/> structure containing SRT transformation data. Can be NULL. </param>
        /// <param name="scaleRef"> Pointer to a <see cref="SlimMath.Vector3"/> vector that describes the scale of the animation set. Can be NULL. </param>
        /// <param name="rotationRef"> Pointer to a <see cref="SlimMath.Quaternion"/> quaternion that describes the rotation of the animation set. Can be NULL. </param>
        /// <param name="translationRef"> Pointer to a <see cref="SlimMath.Vector3"/> vector that describes the translation of the animation set. Can be NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::RegisterAnimationOutput([None] const char* pName,[None] D3DXMATRIX* pMatrix,[None] D3DXVECTOR3* pScale,[None] D3DXQUATERNION* pRotation,[None] D3DXVECTOR3* pTranslation)</unmanaged>
        public SlimDX2.Result RegisterAnimationOutput(string nameRef, ref SlimMath.Matrix matrixRef, ref SlimMath.Vector3 scaleRef, ref SlimMath.Quaternion rotationRef, ref SlimMath.Vector3 translationRef) {
            unsafe {
                IntPtr nameRef_ = Marshal.StringToHGlobalAnsi(nameRef);
                SlimDX2.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    fixed (void* scaleRef_ = &scaleRef)
                        fixed (void* rotationRef_ = &rotationRef)
                            fixed (void* translationRef_ = &translationRef)
                                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)nameRef_, matrixRef_, scaleRef_, rotationRef_, translationRef_);
                Marshal.FreeHGlobal(nameRef_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds an animation set to the animation controller.	
        /// </summary>	
        /// <param name="pAnimSet"> Pointer to the <see cref="SlimDX2.Direct3D9.AnimationSet"/> animation set to add. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::RegisterAnimationSet([None] LPD3DXANIMATIONSET pAnimSet)</unmanaged>
        public SlimDX2.Result RegisterAnimationSet(SlimDX2.Direct3D9.AnimationSet pAnimSet) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, (void*)((pAnimSet == null)?IntPtr.Zero:pAnimSet.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Removes an animation set from the animation controller.	
        /// </summary>	
        /// <param name="pAnimSet"> Pointer to the <see cref="SlimDX2.Direct3D9.AnimationSet"/> animation set to remove. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, D3DERR_NOTFOUND. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::UnregisterAnimationSet([None] LPD3DXANIMATIONSET pAnimSet)</unmanaged>
        public SlimDX2.Result UnregisterAnimationSet(SlimDX2.Direct3D9.AnimationSet pAnimSet) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, (void*)((pAnimSet == null)?IntPtr.Zero:pAnimSet.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns the number of animation sets currently registered in the animation controller.	
        /// </summary>	
        /// <remarks>	
        ///  The controller contains any number of animations sets and tracks. Animation sets can be registered with  {{RegisterAnimationOutput}}.  An animation controller created by a call  to {{D3DXLoadMeshHierarchyFromX}} will automatically register loaded animation sets. 	
        /// </remarks>	
        /// <returns>  {{UINT}}  Number of animation sets. </returns>
        /// <unmanaged>UINT ID3DXAnimationController::GetNumAnimationSets()</unmanaged>
        internal int GetNumAnimationSets() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an animation set.	
        /// </summary>	
        /// <remarks>	
        ///  The animation controller contains an array of animation sets. This method returns one of them at the given index. 	
        /// </remarks>	
        /// <param name="index"> Index of the animation set. </param>
        /// <param name="animationSetRef"> Pointer to the <see cref="SlimDX2.Direct3D9.AnimationSet"/> animation set. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::GetAnimationSet([None] UINT Index,[Out] LPD3DXANIMATIONSET* ppAnimationSet)</unmanaged>
        public SlimDX2.Result GetAnimationSet(int index, out SlimDX2.Direct3D9.AnimationSet animationSetRef) {
            unsafe {
                IntPtr animationSetRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, index, &animationSetRef_);
                animationSetRef = (animationSetRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.AnimationSet(animationSetRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an animation set, given its name.	
        /// </summary>	
        /// <remarks>	
        ///  The animation controller contains an array of animation sets. This method returns an animation set that has the given name. 	
        /// </remarks>	
        /// <param name="szName"> String containing the name of the animation set. </param>
        /// <param name="animationSetRef"> Pointer to the <see cref="SlimDX2.Direct3D9.AnimationSet"/> animation set. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::GetAnimationSetByName([Out] const char* szName,[Out] LPD3DXANIMATIONSET* ppAnimationSet)</unmanaged>
        public SlimDX2.Result GetAnimationSetByName(IntPtr szName, out SlimDX2.Direct3D9.AnimationSet animationSetRef) {
            unsafe {
                IntPtr animationSetRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, (void*)szName, &animationSetRef_);
                animationSetRef = (animationSetRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.AnimationSet(animationSetRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Animates the mesh and advances the global animation time by a specified amount.	
        /// </summary>	
        /// <param name="timeDelta"> Amount, in seconds, by which to advance the global animation time. TimeDelta value must be non-negative or zero. </param>
        /// <param name="pCallbackHandler"> Pointer to a user-defined animation callback handler interface, <see cref="SlimDX2.Direct3D9.AnimationCallbackHandler"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::AdvanceTime([None] DOUBLE TimeDelta,[None] LPD3DXANIMATIONCALLBACKHANDLER pCallbackHandler)</unmanaged>
        public SlimDX2.Result AdvanceTime(double timeDelta, SlimDX2.Direct3D9.AnimationCallbackHandler pCallbackHandler) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, timeDelta, (void*)((pCallbackHandler == null)?IntPtr.Zero:pCallbackHandler.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Resets the global animation time to zero. Any pending events will retain their original schedules, but in the new timeframe.	
        /// </summary>	
        /// <remarks>	
        ///  This method is typically used when the global animation time value is nearing the maximum precision of DOUBLE storage, or 264 - 1. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::ResetTime()</unmanaged>
        public SlimDX2.Result ResetTime() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the global animation time.	
        /// </summary>	
        /// <remarks>	
        ///  Animations are designed using a local animation time and mixed into global time with {{AdvanceTime}}. 	
        /// </remarks>	
        /// <returns>  {{DOUBLE}}  Returns the global animation time. </returns>
        /// <unmanaged>DOUBLE ID3DXAnimationController::GetTime()</unmanaged>
        internal double GetTime() {
            unsafe {
                double __result__;
                __result__= (double)SlimDX2.Direct3D9.LocalInterop.CalliSystemDouble(_nativePointer, 15 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Applies the animation set to the specified track.	
        /// </summary>	
        /// <remarks>	
        ///  This method sets the animation set to the specified track for mixing.  The animation set for each track is blended according to the  track weight and speed when {{AdvanceTime}} is called. 	
        /// </remarks>	
        /// <param name="track"> Identifier of the track to which the animation set is applied. </param>
        /// <param name="pAnimSet"> Pointer to the <see cref="SlimDX2.Direct3D9.AnimationSet"/> animation set to be added to the track. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::SetTrackAnimationSet([None] UINT Track,[None] LPD3DXANIMATIONSET pAnimSet)</unmanaged>
        public SlimDX2.Result SetTrackAnimationSet(int track, SlimDX2.Direct3D9.AnimationSet pAnimSet) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, track, (void*)((pAnimSet == null)?IntPtr.Zero:pAnimSet.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the animation set for the given track.	
        /// </summary>	
        /// <param name="track"> Track identifier. </param>
        /// <param name="animSetRef"> Pointer to the <see cref="SlimDX2.Direct3D9.AnimationSet"/> animation set for the given track. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::GetTrackAnimationSet([None] UINT Track,[Out] LPD3DXANIMATIONSET* ppAnimSet)</unmanaged>
        public SlimDX2.Result GetTrackAnimationSet(int track, out SlimDX2.Direct3D9.AnimationSet animSetRef) {
            unsafe {
                IntPtr animSetRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, track, &animSetRef_);
                animSetRef = (animSetRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.AnimationSet(animSetRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the priority blending weight for the specified animation track.	
        /// </summary>	
        /// <remarks>	
        ///  	
        /// </remarks>	
        /// <param name="track"> Track identifier. </param>
        /// <param name="priority"> Track priority. This parameter should be set to one of the constants from <see cref="SlimDX2.Direct3D9.TrackPriority"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::SetTrackPriority([None] UINT Track,[None] D3DXPRIORITY_TYPE Priority)</unmanaged>
        public SlimDX2.Result SetTrackPriority(int track, SlimDX2.Direct3D9.TrackPriority priority) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, track, unchecked((int)priority));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the track speed. The track speed is similar to a multiplier that is used to speed up or slow down the playback of the track.	
        /// </summary>	
        /// <param name="track"> Identifier of the track to set the speed on. </param>
        /// <param name="speed"> New speed. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::SetTrackSpeed([None] UINT Track,[None] FLOAT Speed)</unmanaged>
        public SlimDX2.Result SetTrackSpeed(int track, float speed) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, track, speed);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the track weight. The weight is used to determine how to blend multiple tracks together.	
        /// </summary>	
        /// <param name="track"> Identifier of the track to set the weight on. </param>
        /// <param name="weight"> Weight value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::SetTrackWeight([None] UINT Track,[None] FLOAT Weight)</unmanaged>
        public SlimDX2.Result SetTrackWeight(int track, float weight) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, track, weight);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the track to the specified local animation time.	
        /// </summary>	
        /// <param name="track"> Track identifier. </param>
        /// <param name="position"> Local animation time value to assign to the track. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::SetTrackPosition([None] UINT Track,[None] DOUBLE Position)</unmanaged>
        public SlimDX2.Result SetTrackPosition(int track, double position) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, track, position);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Enables or disables a track in the animation controller.	
        /// </summary>	
        /// <remarks>	
        ///  To mix a track with other tracks, the Enable flag must be set to TRUE. Conversely, setting the flag to FALSE will prevent the track from being  mixed with other tracks. 	
        /// </remarks>	
        /// <param name="track"> Identifier of the track to be mixed. </param>
        /// <param name="enable"> Enable value. Set to TRUE to enable this track in the controller, or to FALSE to prevent it from being mixed. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::SetTrackEnable([None] UINT Track,[None] BOOL Enable)</unmanaged>
        public SlimDX2.Result SetTrackEnable(int track, bool enable) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 22 * 4, track, (enable?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the track description.	
        /// </summary>	
        /// <param name="track"> Identifier of the track to modify. </param>
        /// <param name="pDesc"> Description of the track. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::SetTrackDesc([None] UINT Track,[None] LPD3DXTRACK_DESC pDesc)</unmanaged>
        public SlimDX2.Result SetTrackDescription(int track, ref SlimDX2.Direct3D9.TrackDescription pDesc) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pDesc_ = &pDesc)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, track, pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the track description.	
        /// </summary>	
        /// <param name="track"> Track identifier. </param>
        /// <param name="pDesc"> Pointer to the track description. See <see cref="SlimDX2.Direct3D9.TrackDescription"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::GetTrackDesc([None] UINT Track,[None] LPD3DXTRACK_DESC pDesc)</unmanaged>
        public SlimDX2.Result GetTrackDescription(int track, ref SlimDX2.Direct3D9.TrackDescription pDesc) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pDesc_ = &pDesc)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, track, pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the priority blending weight used by the animation controller.	
        /// </summary>	
        /// <remarks>	
        ///  The blend weight is used to blend high and low priority tracks together. 	
        /// </remarks>	
        /// <param name="blendWeight"> Priority blending weight used by the animation controller. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following values: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::SetPriorityBlend([None] FLOAT BlendWeight)</unmanaged>
        internal SlimDX2.Result SetPriorityBlend(float blendWeight) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4, blendWeight);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the current priority blending weight used by the animation controller.	
        /// </summary>	
        /// <remarks>	
        ///  The priority blending weight is used to blend high and low priority tracks together. 	
        /// </remarks>	
        /// <returns>  {{FLOAT}}  Returns the current priority blending weight. </returns>
        /// <unmanaged>FLOAT ID3DXAnimationController::GetPriorityBlend()</unmanaged>
        internal float GetPriorityBlend() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct3D9.LocalInterop.Callifloat(_nativePointer, 26 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an event key that changes the rate of play of an animation track.	
        /// </summary>	
        /// <param name="track"> Identifier of the track to modify. </param>
        /// <param name="newSpeed"> New speed of the animation track. </param>
        /// <param name="startTime"> Global time key. Specifies the global time when the change will take place. </param>
        /// <param name="duration"> Transition time, which specifies how long the smooth transition will take to complete. </param>
        /// <param name="transition"> Specifies the transition type used for transitioning between speeds. See <see cref="SlimDX2.Direct3D9.TransitionType"/>. </param>
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the priority blend event. NULL is returned if one or more of the input parameters is invalid, or no free event is available. </returns>
        /// <unmanaged>D3DXEVENTHANDLE ID3DXAnimationController::KeyTrackSpeed([None] UINT Track,[None] FLOAT NewSpeed,[None] DOUBLE StartTime,[None] DOUBLE Duration,[None] D3DXTRANSITION_TYPE Transition)</unmanaged>
        public int KeyTrackSpeed(int track, float newSpeed, double startTime, double duration, SlimDX2.Direct3D9.TransitionType transition) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 27 * 4, track, newSpeed, startTime, duration, unchecked((int)transition));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an event key that changes the weight of an animation track. The weight is used as a multiplier when combining multiple tracks together.	
        /// </summary>	
        /// <remarks>	
        ///  The weight is used like a multiplier to determine how much of this track to blend together with other tracks. 	
        /// </remarks>	
        /// <param name="track"> Identifier of the track to modify. </param>
        /// <param name="newWeight"> New weight of the track. </param>
        /// <param name="startTime"> Global time key. Specifies the global time when the change will take place. </param>
        /// <param name="duration"> Transition time, which specifies how long the smooth transition will take to complete. </param>
        /// <param name="transition"> Specifies the transition type used for transitioning between weights. See <see cref="SlimDX2.Direct3D9.TransitionType"/>. </param>
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the priority blend event. NULL is returned if one or more of the input parameters is invalid, or no free event is available. </returns>
        /// <unmanaged>D3DXEVENTHANDLE ID3DXAnimationController::KeyTrackWeight([None] UINT Track,[None] FLOAT NewWeight,[None] DOUBLE StartTime,[None] DOUBLE Duration,[None] D3DXTRANSITION_TYPE Transition)</unmanaged>
        public int KeyTrackWeight(int track, float newWeight, double startTime, double duration, SlimDX2.Direct3D9.TransitionType transition) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 28 * 4, track, newWeight, startTime, duration, unchecked((int)transition));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an event key that changes the local time of an animation track.	
        /// </summary>	
        /// <param name="track"> Identifier of the track to modify. </param>
        /// <param name="newPosition"> New local time of the animation track. </param>
        /// <param name="startTime"> Global time key. Specifies the global time when the change will take place. </param>
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the priority blend event. NULL is returned if Track is invalid, or if no free event is available. </returns>
        /// <unmanaged>D3DXEVENTHANDLE ID3DXAnimationController::KeyTrackPosition([None] UINT Track,[None] DOUBLE NewPosition,[None] DOUBLE StartTime)</unmanaged>
        public int KeyTrackPosition(int track, double newPosition, double startTime) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 29 * 4, track, newPosition, startTime);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an event key that enables or disables an animation track.	
        /// </summary>	
        /// <param name="track"> Identifier of the animation track to modify. </param>
        /// <param name="newEnable"> Enable flag. Set this to TRUE to enable the animation track, or to FALSE to disable the track. </param>
        /// <param name="startTime"> Global time key. Specifies the global time when the change will take place. </param>
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the priority blend event. NULL is returned if Track is invalid. </returns>
        /// <unmanaged>D3DXEVENTHANDLE ID3DXAnimationController::KeyTrackEnable([None] UINT Track,[None] BOOL NewEnable,[None] DOUBLE StartTime)</unmanaged>
        public int KeyTrackEnable(int track, bool newEnable, double startTime) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 30 * 4, track, (newEnable?1:0), startTime);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets blending event keys for the specified animation track.	
        /// </summary>	
        /// <remarks>	
        ///  The animation controller blends in three phases: low priority tracks are blended first, high priority tracks are blended second, and  then the results of both are blended. 	
        /// </remarks>	
        /// <param name="newBlendWeight"> Number between 0 and 1 that is used to blend tracks together. </param>
        /// <param name="startTime"> Global time to start the blend. </param>
        /// <param name="duration"> Global time duration of the blend. </param>
        /// <param name="transition"> Specifies the transition type used for the duration of the blend. See <see cref="SlimDX2.Direct3D9.TransitionType"/>. </param>
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the priority blend event. NULL is returned if one or more of the input parameters is invalid, or no free event is available. </returns>
        /// <unmanaged>D3DXEVENTHANDLE ID3DXAnimationController::KeyPriorityBlend([None] FLOAT NewBlendWeight,[None] DOUBLE StartTime,[None] DOUBLE Duration,[None] D3DXTRANSITION_TYPE Transition)</unmanaged>
        public int KeyPriorityBlend(float newBlendWeight, double startTime, double duration, SlimDX2.Direct3D9.TransitionType transition) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 31 * 4, newBlendWeight, startTime, duration, unchecked((int)transition));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Removes a specified event from an animation track, preventing the execution of the event.	
        /// </summary>	
        /// <param name="hEvent"> Event handle to the event to be removed from the animation track. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::UnkeyEvent([None] D3DXEVENTHANDLE hEvent)</unmanaged>
        public SlimDX2.Result UnkeyEvent(int hEvent) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 32 * 4, hEvent);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Removes all events from a specified animation track.	
        /// </summary>	
        /// <remarks>	
        ///  This method prevents the execution of all events previously scheduled on the track, and discards all data associated with those events. 	
        /// </remarks>	
        /// <param name="track"> Identifier of the track on which all events should be removed. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::UnkeyAllTrackEvents([None] UINT Track)</unmanaged>
        public SlimDX2.Result UnkeyAllTrackEvents(int track) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 33 * 4, track);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Removes all scheduled priority blend events from the animation controller.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::UnkeyAllPriorityBlends()</unmanaged>
        public SlimDX2.Result UnkeyAllPriorityBlends() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 34 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns an event handle to the event currently running on the specified animation track.	
        /// </summary>	
        /// <param name="track"> Track identifier. </param>
        /// <param name="eventType"> Type of event to query. </param>
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the event currently running on the specified track. NULL is returned if no event is running on the specified track. </returns>
        /// <unmanaged>D3DXEVENTHANDLE ID3DXAnimationController::GetCurrentTrackEvent([None] UINT Track,[None] D3DXEVENT_TYPE EventType)</unmanaged>
        public int GetCurrentTrackEvent(int track, SlimDX2.Direct3D9.EventType eventType) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 35 * 4, track, unchecked((int)eventType));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns an event handle to a priority blend event that is currently running.	
        /// </summary>	
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the currently running priority blend event. NULL is returned if no priority blend event is currently running. </returns>
        /// <unmanaged>D3DXEVENTHANDLE ID3DXAnimationController::GetCurrentPriorityBlend()</unmanaged>
        internal int GetCurrentPriorityBlend() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 36 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns an event handle to the next event scheduled to occur after a specified event on an animation track.	
        /// </summary>	
        /// <remarks>	
        ///  This method can be used iteratively to locate a desired event by repeatedly passing in NULL for hEvent. Note??Do not iterate further after the method has returned NULL. 	
        /// </remarks>	
        /// <param name="track"> Track identifier. </param>
        /// <param name="hEvent"> Event handle to a specified event after which to search for a following event. If set to NULL, then the method will return the next scheduled event. </param>
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the next event scheduled to run on the specified track. NULL is returned if no new event is scheduled. </returns>
        /// <unmanaged>D3DXEVENTHANDLE ID3DXAnimationController::GetUpcomingTrackEvent([None] UINT Track,[None] D3DXEVENTHANDLE hEvent)</unmanaged>
        public int GetUpcomingTrackEvent(int track, int hEvent) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 37 * 4, track, hEvent);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns an event handle to the next priority blend event scheduled to occur after a specified event.	
        /// </summary>	
        /// <remarks>	
        ///  This method can be used iteratively to locate a desired priority blend event by repeatedly passing in NULL for hEvent. Note??Do not iterate further after the method has returned NULL. 	
        /// </remarks>	
        /// <param name="hEvent"> Event handle to a specified event after which to search for a following priority blend event. If set to NULL, then the method will  return the next scheduled priority blend event. </param>
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the next scheduled priority blend event. NULL is returned if no new priority blend event is scheduled. </returns>
        /// <unmanaged>D3DXEVENTHANDLE ID3DXAnimationController::GetUpcomingPriorityBlend([None] D3DXEVENTHANDLE hEvent)</unmanaged>
        public int GetUpcomingPriorityBlend(int hEvent) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 38 * 4, hEvent);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Checks whether a specified event handle is valid and the animation event has not yet completed.	
        /// </summary>	
        /// <remarks>	
        ///  The method will indicate that an event handle is valid even if the event is running but has not yet completed. 	
        /// </remarks>	
        /// <param name="hEvent"> Event handle to an animation event. </param>
        /// <returns>  <see cref="int"/>  Returns S_OK if the event handle is valid and the event has not yet completed. Returns E_FAIL if the event handle is invalid and/or the event has completed. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::ValidateEvent([None] D3DXEVENTHANDLE hEvent)</unmanaged>
        public SlimDX2.Result ValidateEvent(int hEvent) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 39 * 4, hEvent);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a description of a specified animation event.	
        /// </summary>	
        /// <param name="hEvent"> Event handle to an animation event to describe. </param>
        /// <param name="pDesc"> Pointer to a <see cref="SlimDX2.Direct3D9.EventDescription"/> structure that contains a description of the animation event. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::GetEventDesc([None] D3DXEVENTHANDLE hEvent,[None] LPD3DXEVENT_DESC pDesc)</unmanaged>
        public SlimDX2.Result GetEventDescription(int hEvent, ref SlimDX2.Direct3D9.EventDescription pDesc) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pDesc_ = &pDesc)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 40 * 4, hEvent, pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Clones, or copies, an animation controller.	
        /// </summary>	
        /// <param name="maxNumAnimationOutputs"> Maximum number of animation outputs the controller can support. </param>
        /// <param name="maxNumAnimationSets"> Maximum number of animation sets the controller can support. </param>
        /// <param name="maxNumTracks"> Maximum number of tracks the controller can support. </param>
        /// <param name="maxNumEvents"> Maximum number of events the controller can support. </param>
        /// <param name="animControllerRef"> Address of a pointer to the cloned <see cref="SlimDX2.Direct3D9.AnimationController"/> animation controller. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ID3DXAnimationController::CloneAnimationController([None] UINT MaxNumAnimationOutputs,[None] UINT MaxNumAnimationSets,[None] UINT MaxNumTracks,[None] UINT MaxNumEvents,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
        public SlimDX2.Result CloneAnimationController(int maxNumAnimationOutputs, int maxNumAnimationSets, int maxNumTracks, int maxNumEvents, out SlimDX2.Direct3D9.AnimationController animControllerRef) {
            unsafe {
                IntPtr animControllerRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 41 * 4, maxNumAnimationOutputs, maxNumAnimationSets, maxNumTracks, maxNumEvents, &animControllerRef_);
                animControllerRef = (animControllerRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.AnimationController(animControllerRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
}
