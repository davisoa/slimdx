// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Interfaces for SlimDX2.Direct3D9 namespace.
//     This code was generated by a tool.
//     Date : 11/09/2010 17:36:56
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace SlimDX2.Direct3D9 {

    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3D9</unmanaged>
    [Guid("81BDCBCA-64D4-426d-AE8D-AD0147F4275C")]
    public partial class Direct3D9 : SlimDX2.ComObject {
        public Direct3D9(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Returns the number of adapters on the system.	
        /// </summary>	
        /// <unmanaged>UINT GetAdapterCount()</unmanaged>
        public int AdapterCount {
                get { return GetAdapterCount(); }
        }
        
        /// <summary>	
        /// Registers a pluggable software device. Software devices provide software rasterization enabling applications to access a variety of software rasterizers.	
        /// </summary>	
        /// <remarks>	
        ///  If the user's computer provides no special hardware acceleration for 3D operations, your application might emulate 3D hardware in software. Software rasterization devices emulate the functions of color 3D hardware in software. A software device runs more slowly than a hal. However, software devices take advantage of any special instructions supported by the CPU to increase performance. Instruction sets include the AMD 3DNow! instruction set on some AMD processors and the MMX instruction set supported by many Intel processors. Direct3D uses the 3D-Now! instruction set to accelerate transformation and lighting operations and the MMX instruction set to accelerate rasterization. Software devices communicate with Direct3D through an interface similar to the hardware device driver interface (DDI). Software devices are loaded by the application and registered with the <see cref="SlimDX2.Direct3D9.Direct3D9"/> object. Direct3D uses the software device for rendering.  The Direct3D Driver Development Kit (DDK) provides the documentation and headers for developing pluggable software devices. 	
        /// </remarks>	
        /// <param name="pInitializeFunction"> Pointer to the initialization function for the software device to be registered.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL. The method call is invalid. For example, a method's parameter may have an invalid value: D3DERR_OUTOFVIDEOMEMORY.  </returns>
        /// <unmanaged>HRESULT RegisterSoftwareDevice([None] void* pInitializeFunction)</unmanaged>
        public SlimDX2.Result RegisterSoftwareDevice(IntPtr pInitializeFunction) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, (void*)pInitializeFunction);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns the number of adapters on the system.	
        /// </summary>	
        /// <returns>  {{UINT}}  A UINT value that denotes the number of adapters on the system at the time this <see cref="SlimDX2.Direct3D9.Direct3D9"/> interface was instantiated. </returns>
        /// <unmanaged>UINT GetAdapterCount()</unmanaged>
        internal int GetAdapterCount() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Describes the physical display adapters present in the system when the <see cref="SlimDX2.Direct3D9.Direct3D9"/> interface was instantiated.	
        /// </summary>	
        /// <param name="adapter"> Ordinal number that denotes the display adapter. D3DADAPTER_DEFAULT is always the primary display adapter. The minimum value for this parameter is 0, and the maximum value for this parameter is one less than the value returned by {{GetAdapterCount}}.  </param>
        /// <param name="flags"> Flags sets the WHQLLevel member of <see cref="SlimDX2.Direct3D9.AdapterIdentifier9"/>. Flags can be set to either 0 or D3DENUM_WHQL_LEVEL. If D3DENUM_WHQL_LEVEL is specified, this call can connect to the Internet to download new Microsoft Windows Hardware Quality Labs (WHQL) certificates.  </param>
        /// <param name="pIdentifier"> Pointer to a <see cref="SlimDX2.Direct3D9.AdapterIdentifier9"/> structure to be filled with information describing this adapter. If Adapter is greater than or equal to the number of adapters in the system, this structure will be zeroed.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if Adapter is out of range, if Flags contains unrecognized parameters, or if pIdentifier is NULL or points to unwriteable memory. </returns>
        /// <unmanaged>HRESULT GetAdapterIdentifier([None] UINT Adapter,[None] int Flags,[Out] D3DADAPTER_IDENTIFIER9* pIdentifier)</unmanaged>
        public SlimDX2.Result GetAdapterIdentifier(int adapter, int flags, out SlimDX2.Direct3D9.AdapterIdentifier9 pIdentifier) {
            unsafe {
                SlimDX2.Direct3D9.AdapterIdentifier9.__Native pIdentifier_ = new SlimDX2.Direct3D9.AdapterIdentifier9.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, adapter, flags, &pIdentifier_);
                pIdentifier = new SlimDX2.Direct3D9.AdapterIdentifier9();
                pIdentifier.__MarshalFrom(ref pIdentifier_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns the number of display modes available on this adapter.	
        /// </summary>	
        /// <param name="adapter"> Ordinal number that denotes the display adapter. D3DADAPTER_DEFAULT is always the primary display adapter.  </param>
        /// <param name="format"> Identifies the format of the surface type using <see cref="SlimDX2.Direct3D9.Format"/>. Use {{EnumAdapterModes}} to see the valid formats. </param>
        /// <returns>  {{UINT}}  This method returns the number of display modes on this adapter or zero if Adapter is greater than or equal to the number of adapters on the system. </returns>
        /// <unmanaged>UINT GetAdapterModeCount([None] UINT Adapter,[None] D3DFORMAT Format)</unmanaged>
        public int GetAdapterModeCount(int adapter, SlimDX2.Direct3D9.Format format) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, adapter, unchecked((int)format));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Queries the device to determine whether the specified adapter supports the requested format and display mode. This method could be used in a loop to enumerate all the available adapter modes.	
        /// </summary>	
        /// <remarks>	
        ///  An application supplies a display mode and a format to EnumAdapterModes which returns a display mode. This method could be used in a loop to enumerate all available display modes. The application specifies a format and the enumeration is restricted to those display modes that exactly match the format (alpha is ignored). Allowed formats (which are members of <see cref="SlimDX2.Direct3D9.Format"/>) are as follows:  D3DFMT_A1R5G5B5 D3DFMT_A2R10G10B10 D3DFMT_A8R8G8B8 D3DFMT_R5G6B5 D3DFMT_X1R5G5B5 D3DFMT_X8R8G8B8  In addition, EnumAdapterModes treats pixel formats 565 and 555 as equivalent, and returns the correct version. The difference comes into play only when the application locks the back buffer and there is an explicit flag that the application must set in order to accomplish this. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number denoting the display adapter to enumerate. {{D3DADAPTER_DEFAULT}} is always the primary display adapter. This method returns D3DERR_INVALIDCALL when this value equals or exceeds the number of display adapters in the system.  </param>
        /// <param name="format"> Allowable pixel formats. See Remarks. </param>
        /// <param name="mode"> Represents the display-mode index which is an unsigned integer between zero and the value returned by {{GetAdapterModeCount}} minus one. </param>
        /// <param name="pMode"> A pointer to the available display mode of type <see cref="SlimDX2.Direct3D9.Displaymode"/>. See Remarks. </param>
        /// <returns>  <see cref="int"/>   If the device can be used on this adapter, D3D_OK is returned. If the Adapter equals or exceeds the number of display adapters in the system, D3DERR_INVALIDCALL is returned. If either surface format is not supported or if hardware acceleration is not available for the specified formats, D3DERR_NOTAVAILABLE is returned.  </returns>
        /// <unmanaged>HRESULT EnumAdapterModes([None] UINT Adapter,[None] D3DFORMAT Format,[None] UINT Mode,[None] D3DDISPLAYMODE* pMode)</unmanaged>
        public SlimDX2.Result EnumAdapterModes(int adapter, SlimDX2.Direct3D9.Format format, int mode, ref SlimDX2.Direct3D9.Displaymode pMode) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pMode_ = &pMode)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, adapter, unchecked((int)format), mode, pMode_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the current display mode of the adapter.	
        /// </summary>	
        /// <remarks>	
        ///  GetAdapterDisplayMode will not return the correct format when the display is in an extended format, such as 2:10:10:10. Instead, it returns the format X8R8G8B8.  	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number that denotes the display adapter to query. D3DADAPTER_DEFAULT is always the primary display adapter.  </param>
        /// <param name="pMode"> Pointer to a <see cref="SlimDX2.Direct3D9.Displaymode"/> structure, to be filled with information describing the current adapter's mode.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK.   If Adapter is out of range or pMode is invalid, this method returns D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetAdapterDisplayMode([None] UINT Adapter,[Out] D3DDISPLAYMODE* pMode)</unmanaged>
        public SlimDX2.Result GetAdapterDisplayMode(int adapter, out SlimDX2.Direct3D9.Displaymode pMode) {
            unsafe {
                pMode = new SlimDX2.Direct3D9.Displaymode();
                SlimDX2.Result __result__;
                fixed (void* pMode_ = &pMode)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, adapter, pMode_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Verifies whether a hardware accelerated device type can be used on this adapter.	
        /// </summary>	
        /// <remarks>	
        ///  A hal device type requires hardware acceleration. Applications can use CheckDeviceType to determine if the needed hardware and drivers are present to support a hal device.  Full-screen applications should not specify a DisplayFormat that contains an alpha channel. This will result in a failed call. Note that an alpha channel can be present in the back buffer but the two display formats must be identical in all other respects. For example, if DisplayFormat = D3DFMT_X1R5G5B5, valid values for BackBufferFormat include D3DFMT_X1R5G5B5 and D3DFMT_A1R5G5B5 but exclude D3DFMT_R5G6B5. The following code fragment shows how you could use CheckDeviceType to test whether a certain device type can be used on this adapter. 	
        /// <code> if(SUCCEEDED(pD3Device-&gt;CheckDeviceType(D3DADAPTER_DEFAULT,  D3DDEVTYPE_HAL,  DisplayFormat,  BackBufferFormat,  bIsWindowed))) return S_OK;	
        /// // There is no HAL on this adapter using this render-target format. 	
        /// // Try again, using another format. </code>	
        /// 	
        ///  This code returns S_OK if the device can be used on the default adapter with the specified surface format. Using CheckDeviceType to test for compatibility between a back buffer that differs from the display format will return appropriate values. This means that the call will reflect device capabilities. If the device cannot render to the requested back-buffer format, the call will still return D3DERR_NOTAVAILABLE. If the device can render to the format, but cannot perform the color-converting presentation, the return value will also be D3DERR_NOTAVAILABLE. Applications can discover hardware support for the presentation itself by calling {{CheckDeviceFormatConversion}}. No software emulation for the color-converting presentation itself will be offered. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number denoting the display adapter to enumerate. D3DADAPTER_DEFAULT is always the primary display adapter. This method returns D3DERR_INVALIDCALL when this value equals or exceeds the number of display adapters in the system.  </param>
        /// <param name="devType"> Member of the <see cref="SlimDX2.Direct3D9.Devtype"/> enumerated type, indicating the device type to check.  </param>
        /// <param name="adapterFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, indicating the format of the adapter display mode for which the device type is to be checked. For example, some devices will operate only in 16-bits-per-pixel modes.  </param>
        /// <param name="backBufferFormat"> Back buffer format. For more information about formats, see <see cref="SlimDX2.Direct3D9.Format"/>. This value must be one of the render-target formats. You can use {{GetDisplayMode}} to obtain the current format. For windowed applications, the back buffer format does not need to match the display mode format if the hardware supports color conversion. The set of possible back buffer formats is constrained, but the runtime will allow any valid back buffer format to be presented to any desktop format. There is the additional requirement that the device be operable in the desktop mode because devices typically do not operate in 8 bits per pixel modes. Full-screen applications cannot do color conversion. D3DFMT_UNKNOWN is allowed for windowed mode.  </param>
        /// <param name="bWindowed"> Value indicating whether the device type will be used in full-screen or windowed mode. If set to TRUE, the query is performed for windowed applications; otherwise, this value should be set FALSE.  </param>
        /// <returns>  <see cref="int"/>  If the device can be used on this adapter, D3D_OK is returned. D3DERR_INVALIDCALL is returned if Adapter equals or exceeds the number of display adapters in the system. D3DERR_INVALIDCALL is also returned if CheckDeviceType specified a device that does not exist. D3DERR_NOTAVAILABLE is returned if the requested back buffer format is not supported, or if hardware acceleration is not available for the specified formats.  </returns>
        /// <unmanaged>HRESULT CheckDeviceType([None] UINT Adapter,[None] D3DDEVTYPE DevType,[None] D3DFORMAT AdapterFormat,[None] D3DFORMAT BackBufferFormat,[None] BOOL bWindowed)</unmanaged>
        public SlimDX2.Result CheckDeviceType(int adapter, SlimDX2.Direct3D9.Devtype devType, SlimDX2.Direct3D9.Format adapterFormat, SlimDX2.Direct3D9.Format backBufferFormat, bool bWindowed) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, adapter, unchecked((int)devType), unchecked((int)adapterFormat), unchecked((int)backBufferFormat), (bWindowed?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Determines whether a surface format is available as a specified resource type and can be used as a texture, depth-stencil buffer, or render target, or any combination of the three, on a device representing this adapter.	
        /// </summary>	
        /// <remarks>	
        ///  Here are some examples using CheckDeviceFormat to check for hardware support of:  An off-screen plain surface format - Specify Usage = 0 and RType = D3DRTYPE_SURFACE. A depth-stencil format - The following snippet tests for the passed in depth-stencil format: 	
        /// <code> BOOL IsDepthFormatExisting( D3DFORMAT DepthFormat, D3DFORMAT AdapterFormat ) 	
        /// { HRESULT hr = pD3D-&gt;CheckDeviceFormat( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, AdapterFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, DepthFormat); return SUCCEEDED( hr );	
        /// } </code>	
        /// 	
        ///  See {{Selecting a Device (Direct3D 9)}} for more detail on the enumeration process.  Can this texture be rendered in a particular format - Given the current display mode, this example shows how to verify that the texture format is compatible with the specific back-buffer format: 	
        /// <code> BOOL IsTextureFormatOk( D3DFORMAT TextureFormat, D3DFORMAT AdapterFormat ) 	
        /// { HRESULT hr = pD3D-&gt;CheckDeviceFormat( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, AdapterFormat, 0, D3DRTYPE_TEXTURE, TextureFormat); return SUCCEEDED( hr );	
        /// } </code>	
        /// 	
        ///   Alpha blending in a pixel shader - Set Usage to {{D3DUSAGE_QUERY_POSTPIXELSHADER_BLENDING}}. Expect this to fail for all floating-point render targets. Autogeneration of mipmaps - Set Usage to {{D3DUSAGE_AUTOGENMIPMAP}}. If the mipmap automatic generation fails, the application will get a non-mipmapped texture. Calling this method is considered a hint, so this method can return D3DOK_NOAUTOGEN (a valid success code) if the only thing that fails is the mipmap generation. For more information about mipmap generation, see {{Automatic Generation of Mipmaps (Direct3D 9)}}.  When migrating code from Direct3D 9 to Direct3D 10, the Direct3D 10 equivalent to CheckDeviceFormat is {{CheckFormatSupport}}. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number denoting the display adapter to query. {{D3DADAPTER_DEFAULT}} is always the primary display adapter. This method returns D3DERR_INVALIDCALL when this value equals or exceeds the number of display adapters in the system.  </param>
        /// <param name="deviceType"> Member of the <see cref="SlimDX2.Direct3D9.Devtype"/> enumerated type, identifying the device type. </param>
        /// <param name="adapterFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, identifying the format of the display mode into which the adapter will be placed. </param>
        /// <param name="usage"> Requested usage options for the surface. Usage options are any combination of {{D3DUSAGE}} and {{D3DUSAGE_QUERY}} constants (only a subset of the D3DUSAGE constants are valid for CheckDeviceFormat; see the table on the D3DUSAGE page). </param>
        /// <param name="rType"> Resource type requested for use with the queried format. Member of <see cref="SlimDX2.Direct3D9.Resourcetype"/>.  </param>
        /// <param name="checkFormat"> Format of the surfaces which may be used, as defined by Usage. Member of <see cref="SlimDX2.Direct3D9.Format"/>. </param>
        /// <returns>  <see cref="int"/>  If the format is compatible with the specified device for the requested usage, this method returns D3D_OK. D3DERR_INVALIDCALL is returned if Adapter equals or exceeds the number of display adapters in the system, or if DeviceType is unsupported. D3DERR_NOTAVAILABLE is returned if the format is not acceptable to the device for this usage. </returns>
        /// <unmanaged>HRESULT CheckDeviceFormat([None] UINT Adapter,[None] D3DDEVTYPE DeviceType,[None] D3DFORMAT AdapterFormat,[None] int Usage,[None] D3DRESOURCETYPE RType,[None] D3DFORMAT CheckFormat)</unmanaged>
        public SlimDX2.Result CheckDeviceFormat(int adapter, SlimDX2.Direct3D9.Devtype deviceType, SlimDX2.Direct3D9.Format adapterFormat, int usage, SlimDX2.Direct3D9.Resourcetype rType, SlimDX2.Direct3D9.Format checkFormat) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, adapter, unchecked((int)deviceType), unchecked((int)adapterFormat), usage, unchecked((int)rType), unchecked((int)checkFormat));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Determines if a multisampling technique is available on this device.	
        /// </summary>	
        /// <remarks>	
        ///  This method is intended for use with both render-target and depth-stencil surfaces because you must create both surfaces multisampled if you want to use them together. The following code fragment shows how you could use CheckDeviceMultiSampleType to test for devices that support a specific multisampling method. 	
        /// <code> if( SUCCEEDED(pD3D-&gt;CheckDeviceMultiSampleType( pCaps-&gt;AdapterOrdinal,  pCaps-&gt;DeviceType, BackBufferFormat,  FALSE, D3DMULTISAMPLE_3_SAMPLES, NULL ) ) &amp;&amp; SUCCEEDED(pD3D-&gt;CheckDeviceMultiSampleType( pCaps-&gt;AdapterOrdinal,  pCaps-&gt;DeviceType, DepthBufferFormat,  FALSE, D3DMULTISAMPLE_3_SAMPLES, NULL ) ) ) return S_OK; </code>	
        /// 	
        ///  The preceding code will return S_OK if the device supports the full-screen D3DMULTISAMPLE_3_SAMPLES multisampling method with the surface format. See the remarks in <see cref="SlimDX2.Direct3D9.MultisampleType"/> for additional information on working with and setting multisample types and quality levels. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number denoting the display adapter to query. D3DADAPTER_DEFAULT is always the primary display adapter. This method returns FALSE when this value equals or exceeds the number of display adapters in the system. See Remarks. </param>
        /// <param name="deviceType"> Member of the <see cref="SlimDX2.Direct3D9.Devtype"/> enumerated type, identifying the device type. </param>
        /// <param name="surfaceFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type that specifies the format of the surface to be multisampled. For more information, see Remarks. </param>
        /// <param name="windowed"> bool value. Specify TRUE to inquire about windowed multisampling, and specify FALSE to inquire about full-screen multisampling. </param>
        /// <param name="multiSampleType"> Member of the <see cref="SlimDX2.Direct3D9.MultisampleType"/> enumerated type, identifying the multisampling technique to test. </param>
        /// <param name="pQualityLevels"> pQualityLevels returns the number of device-specific sampling variations available with the given sample type. For example, if the returned value is 3, then quality levels 0, 1 and 2 can be used when creating resources with the given sample count. The meanings of these quality levels are defined by the device manufacturer and cannot be queried through D3D. For example, for a particular device different quality levels at a fixed sample count might refer to different spatial layouts of the sample locations or different methods of resolving.  This can be NULL if it is not necessary to return the quality levels. </param>
        /// <returns>  <see cref="int"/>  If the device can perform the specified multisampling method, this method returns D3D_OK. D3DERR_INVALIDCALL is returned if the Adapter or MultiSampleType parameters are invalid. This method returns D3DERR_NOTAVAILABLE if the queried multisampling technique is not supported by this device. D3DERR_INVALIDDEVICE is returned if DeviceType does not apply to this adapter.  </returns>
        /// <unmanaged>HRESULT CheckDeviceMultiSampleType([None] UINT Adapter,[None] D3DDEVTYPE DeviceType,[None] D3DFORMAT SurfaceFormat,[None] BOOL Windowed,[None] D3DMULTISAMPLE_TYPE MultiSampleType,[None] int* pQualityLevels)</unmanaged>
        public SlimDX2.Result CheckDeviceMultiSampleType(int adapter, SlimDX2.Direct3D9.Devtype deviceType, SlimDX2.Direct3D9.Format surfaceFormat, bool windowed, SlimDX2.Direct3D9.MultisampleType multiSampleType, ref int pQualityLevels) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pQualityLevels_ = &pQualityLevels)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, adapter, unchecked((int)deviceType), unchecked((int)surfaceFormat), (windowed?1:0), unchecked((int)multiSampleType), pQualityLevels_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Determines whether a depth-stencil format is compatible with a render-target format in a particular display mode.	
        /// </summary>	
        /// <remarks>	
        ///  This method is provided to enable applications to work with hardware requiring that certain depth formats can only work with certain render-target formats. The behavior of this method has been changed for DirectX 8.1.  This method now pays attention to the D24x8 and D32 depth-stencil formats. The previous version assumed that these formats would always be usable with 32- or 16-bit render targets. This method will now return D3D_OK for these formats only if the device is capable of mixed-depth operations. The following code fragment shows how you could use {{CheckDeviceFormat}} to validate a depth stencil format. 	
        /// <code> BOOL IsDepthFormatOk(D3DFORMAT DepthFormat,  D3DFORMAT AdapterFormat,  D3DFORMAT BackBufferFormat)	
        /// { // Verify that the depth format exists HRESULT hr = pD3D-&gt;CheckDeviceFormat(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, AdapterFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, DepthFormat); if(FAILED(hr)) return FALSE; // Verify that the depth format is compatible hr = pD3D-&gt;CheckDepthStencilMatch(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, AdapterFormat, BackBufferFormat, DepthFormat); return SUCCEEDED(hr); } </code>	
        /// 	
        ///  The preceding call will return FALSE if DepthFormat cannot be used in conjunction with AdapterFormat and BackBufferFormat. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number denoting the display adapter to query. D3DADAPTER_DEFAULT is always the primary display adapter. </param>
        /// <param name="deviceType"> Member of the <see cref="SlimDX2.Direct3D9.Devtype"/> enumerated type, identifying the device type. </param>
        /// <param name="adapterFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, identifying the format of the display mode into which the adapter will be placed.  </param>
        /// <param name="renderTargetFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, identifying the format of the render-target surface to be tested.  </param>
        /// <param name="depthStencilFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, identifying the format of the depth-stencil surface to be tested.  </param>
        /// <returns>  <see cref="int"/>  If the depth-stencil format is compatible with the render-target format in the display mode, this method returns D3D_OK. D3DERR_INVALIDCALL can be returned if one or more of the parameters is invalid. If a depth-stencil format is not compatible with the render target in the display mode, then this method returns D3DERR_NOTAVAILABLE. </returns>
        /// <unmanaged>HRESULT CheckDepthStencilMatch([None] UINT Adapter,[None] D3DDEVTYPE DeviceType,[None] D3DFORMAT AdapterFormat,[None] D3DFORMAT RenderTargetFormat,[None] D3DFORMAT DepthStencilFormat)</unmanaged>
        public SlimDX2.Result CheckDepthStencilMatch(int adapter, SlimDX2.Direct3D9.Devtype deviceType, SlimDX2.Direct3D9.Format adapterFormat, SlimDX2.Direct3D9.Format renderTargetFormat, SlimDX2.Direct3D9.Format depthStencilFormat) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, adapter, unchecked((int)deviceType), unchecked((int)adapterFormat), unchecked((int)renderTargetFormat), unchecked((int)depthStencilFormat));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Tests the device to see if it supports conversion from one display format to another.	
        /// </summary>	
        /// <remarks>	
        ///  Using {{CheckDeviceType}} to test for compatibility between a back buffer that differs from the display format will return appropriate values. This means that the call will reflect device capabilities. If the device cannot render to the requested back buffer format, the call will still return D3DERR_NOTAVAILABLE. If the device can render to the format, but cannot perform the color-converting presentation, the return value will also be D3DERR_NOTAVAILABLE. Applications can discover hardware support for the presentation itself by calling CheckDeviceFormatConversion. No software emulation for the color-converting presentation itself will be offered. CheckDeviceFormatConversion can also be used to determine which combinations of source surface formats and destination surface formats are permissible in calls to {{StretchRect}}.  Color conversion is restricted to the following source and target formats.  The source format must be a FOURCC format or a valid back buffer format. For a list of these, see {{FourCC Formats}} and BackBuffer or Display Formats. The target format must be one of these unsigned formats:  D3DFMT_X1R5G5B5D3DFMT_A1R5G5B5D3DFMT_R5G6B5 D3DFMT_R8G8B8D3DFMT_X8R8G8B8D3DFMT_A8R8G8B8 D3DFMT_A2R10G10B10D3DFMT_A16B16G16R16D3DFMT_A2B10G10R10 D3DFMT_A8B8G8R8D3DFMT_X8B8G8R8D3DFMT_A16B16G16R16F D3DFMT_A32B32G32R32F      	
        /// </remarks>	
        /// <param name="adapter"> Display adapter ordinal number. D3DADAPTER_DEFAULT is always the primary display adapter. This method returns D3DERR_INVALIDCALL when this value equals or exceeds the number of display adapters in the system.   </param>
        /// <param name="deviceType"> Device type. Member of the <see cref="SlimDX2.Direct3D9.Devtype"/> enumerated type.  </param>
        /// <param name="sourceFormat"> Source adapter format. Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type. </param>
        /// <param name="targetFormat"> Target adapter format. Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value is D3DERR_INVALIDCALL. The method will return D3DERR_NOTAVAILABLE when the hardware does not support conversion between the two formats.  </returns>
        /// <unmanaged>HRESULT CheckDeviceFormatConversion([None] UINT Adapter,[None] D3DDEVTYPE DeviceType,[None] D3DFORMAT SourceFormat,[None] D3DFORMAT TargetFormat)</unmanaged>
        public SlimDX2.Result CheckDeviceFormatConversion(int adapter, SlimDX2.Direct3D9.Devtype deviceType, SlimDX2.Direct3D9.Format sourceFormat, SlimDX2.Direct3D9.Format targetFormat) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, adapter, unchecked((int)deviceType), unchecked((int)sourceFormat), unchecked((int)targetFormat));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves device-specific information about a device. 	
        /// </summary>	
        /// <remarks>	
        ///  The application should not assume the persistence of vertex processing capabilities across Direct3D device objects. The particular capabilities that a physical device exposes may depend on parameters supplied to {{CreateDevice}}. For example, the capabilities may yield different vertex processing capabilities before and after creating a Direct3D Device Object with hardware vertex processing enabled. For more information see the description of <see cref="SlimDX2.Direct3D9.Caps9"/>. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number that denotes the display adapter. D3DADAPTER_DEFAULT is always the primary display adapter.  </param>
        /// <param name="deviceType"> Member of the <see cref="SlimDX2.Direct3D9.Devtype"/> enumerated type. Denotes the device type.  </param>
        /// <param name="pCaps"> Pointer to a <see cref="SlimDX2.Direct3D9.Caps9"/> structure to be filled with information describing the capabilities of the device.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_INVALIDDEVICE, D3DERR_OUTOFVIDEOMEMORY, and D3DERR_NOTAVAILABLE. </returns>
        /// <unmanaged>HRESULT GetDeviceCaps([None] UINT Adapter,[None] D3DDEVTYPE DeviceType,[Out] D3DCAPS9* pCaps)</unmanaged>
        public SlimDX2.Result GetDeviceCaps(int adapter, SlimDX2.Direct3D9.Devtype deviceType, out SlimDX2.Direct3D9.Caps9 pCaps) {
            unsafe {
                pCaps = new SlimDX2.Direct3D9.Caps9();
                SlimDX2.Result __result__;
                fixed (void* pCaps_ = &pCaps)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, adapter, unchecked((int)deviceType), pCaps_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns the handle of the monitor associated with the Direct3D object.	
        /// </summary>	
        /// <remarks>	
        ///  As shown in the following code fragment, which illustrates how to obtain a handle to the monitor associated with a given device, use {{GetDirect3D}} to return the Direct3D enumerator from the device and use {{GetCreationParameters}} to retrieve the value for Adapter. 	
        /// <code> if( FAILED( pDevice-&gt;GetCreationParameters(  &amp;Parameters ) ) ) return D3DERR_INVALIDCALL; if( FAILED( pDevice-&gt;GetDirect3D(&amp;pD3D) ) ) return D3DERR_INVALIDCALL; hMonitor = pD3D-&gt;GetAdapterMonitor(Parameters.AdapterOrdinal); pD3D-&gt;Release(); </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number that denotes the display adapter. D3DADAPTER_DEFAULT is always the primary display adapter.  </param>
        /// <returns>  {{HMONITOR}}  Handle of the monitor associated with the Direct3D object. </returns>
        /// <unmanaged>HMONITOR GetAdapterMonitor([None] UINT Adapter)</unmanaged>
        public IntPtr GetAdapterMonitor(int adapter) {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 15 * 4, adapter);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a device to represent the display adapter.	
        /// </summary>	
        /// <remarks>	
        ///  This method returns a fully working device interface, set to the required display mode (or windowed), and allocated with the appropriate back buffers. To begin rendering, the application needs only to create and set a depth buffer (assuming EnableAutoDepthStencil is FALSE in <see cref="SlimDX2.Direct3D9.PresentParameters"/>). When you create a Direct3D device, you supply two different window parameters: a focus window (hFocusWindow) and a device window (the hDeviceWindow in <see cref="SlimDX2.Direct3D9.PresentParameters"/>). The purpose of each window is:  The focus window alerts Direct3D when an application switches from foreground mode to background mode (via Alt-Tab, a mouse click, or some other method). A single focus window is shared by each device created by an application. The device window determines the location and size of the back buffer on screen. This is used by Direct3D when the back buffer contents are copied to the front buffer during {{Present}}.  This method should not be run during the handling of WM_CREATE. An application should never pass a window handle to Direct3D while handling WM_CREATE.  Any call to create, release, or reset the device must be done using the same thread as the window procedure of the focus window. Note that D3DCREATE_HARDWARE_VERTEXPROCESSING, D3DCREATE_MIXED_VERTEXPROCESSING, and D3DCREATE_SOFTWARE_VERTEXPROCESSING are mutually exclusive flags, and at least one of these vertex processing flags must be specified when calling this method. Back buffers created as part of the device are only lockable if D3DPRESENTFLAG_LOCKABLE_BACKBUFFER is specified in the presentation parameters. (Multisampled back buffers and depth surfaces are never lockable.) The methods {{Reset}}, <see cref="SlimDX2.ComObject"/>, and {{TestCooperativeLevel}} must be called from the same thread that used this method to create a device. D3DFMT_UNKNOWN can be specified for the windowed mode back buffer format when calling CreateDevice, {{Reset}}, and {{CreateAdditionalSwapChain}}. This means the application does not have to query the current desktop format before calling CreateDevice for windowed mode. For full-screen mode, the back buffer format must be specified. If you attempt to create a device on a 0x0 sized window, CreateDevice will fail. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number that denotes the display adapter. {{D3DADAPTER_DEFAULT}} is always the primary display adapter.  </param>
        /// <param name="deviceType"> Member of the <see cref="SlimDX2.Direct3D9.Devtype"/> enumerated type that denotes the desired device type. If the desired device type is not available, the method will fail.  </param>
        /// <param name="hFocusWindow"> The focus window alerts Direct3D when an application switches from foreground mode to background mode. See Remarks. 	   For full-screen mode, the window specified must be a top-level window. For windowed mode, this parameter may be NULL only if the hDeviceWindow member of pPresentationParameters is set to a valid, non-NULL value.  </param>
        /// <param name="behaviorFlags"> Combination of one or more options that control device creation. For more information, see {{D3DCREATE}}. </param>
        /// <param name="pPresentationParameters"> Pointer to a <see cref="SlimDX2.Direct3D9.PresentParameters"/> structure, describing the presentation parameters for the device to be created. If BehaviorFlags specifies {{D3DCREATE_ADAPTERGROUP_DEVICE}}, pPresentationParameters is an array. Regardless of the number of heads that exist, only one depth/stencil surface is automatically created. For Windows 2000 and Windows XP, the full-screen device display refresh rate is set in the following order:   User-specified nonzero ForcedRefreshRate registry key, if supported by the device. Application-specified nonzero refresh rate value in the presentation parameter. Refresh rate of the latest desktop mode, if supported by the device. 75 hertz if supported by the device. 60 hertz if supported by the device. Device default.  An unsupported refresh rate will default to the closest supported refresh rate below it.  For example, if the application specifies 63 hertz, 60 hertz will be used. There are no supported refresh rates below 57 hertz. pPresentationParameters is both an input and an output parameter. Calling this method may change several members including:  If BackBufferCount, BackBufferWidth, and BackBufferHeight  are 0 before the method is called, they will be changed when the method returns. If BackBufferFormat equals <see cref="SlimDX2.Direct3D9.Format.MtUnknown"/> before the method is called, it will be changed when the method returns.  </param>
        /// <param name="ppReturnedDeviceInterface"> Address of a pointer to the returned <see cref="SlimDX2.Direct3D9.Device"/> interface, which represents the created device.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_DEVICELOST, D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY. </returns>
        /// <unmanaged>HRESULT CreateDevice([None] UINT Adapter,[None] D3DDEVTYPE DeviceType,[None] HWND hFocusWindow,[None] int BehaviorFlags,[None] D3DPRESENT_PARAMETERS* pPresentationParameters,[None] IDirect3DDevice9** ppReturnedDeviceInterface)</unmanaged>
        public SlimDX2.Result CreateDevice(int adapter, SlimDX2.Direct3D9.Devtype deviceType, IntPtr hFocusWindow, int behaviorFlags, ref SlimDX2.Direct3D9.PresentParameters pPresentationParameters, out SlimDX2.Direct3D9.Device ppReturnedDeviceInterface) {
            unsafe {
                IntPtr ppReturnedDeviceInterface_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pPresentationParameters_ = &pPresentationParameters)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, adapter, unchecked((int)deviceType), (void*)hFocusWindow, behaviorFlags, pPresentationParameters_, &ppReturnedDeviceInterface_);
                ppReturnedDeviceInterface = (ppReturnedDeviceInterface_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppReturnedDeviceInterface_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DDevice9</unmanaged>
    [Guid("D0223B96-BF7A-43fd-92BD-A43B0D82B9EB")]
    public partial class Device : SlimDX2.ComObject {
        public Device(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Returns an estimate of the amount of available texture memory.	
        /// </summary>	
        /// <remarks>	
        ///  The returned value is rounded to the nearest MB. This is done to reflect the fact that video memory estimates are never precise due to alignment and other issues that affect consumption by certain resources. Applications can use this value to make gross estimates of memory availability to make large-scale resource decisions such as how many levels of a mipmap to attempt to allocate, but applications cannot use this value to make small-scale decisions such as if there is enough memory left to allocate another resource. 	
        /// </remarks>	
        /// <unmanaged>UINT GetAvailableTextureMem()</unmanaged>
        public int AvailableTextureMem {
                get { return GetAvailableTextureMem(); }
        }
        
        /// <summary>	
        /// Returns an interface to the instance of the Direct3D object that created the device.	
        /// </summary>	
        /// <remarks>	
        ///  Calling IDirect3DDevice9::GetDirect3D will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Direct3D9"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3D9 interface results in a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDirect3D([Out] IDirect3D9** ppD3D9)</unmanaged>
        public SlimDX2.Direct3D9.Direct3D9 Direct3D {
                get { SlimDX2.Direct3D9.Direct3D9 __output__; GetDirect3D(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the capabilities of the rendering device.	
        /// </summary>	
        /// <remarks>	
        ///  IDirect3DDevice9::GetDeviceCaps retrieves the software vertex pipeline capabilities when the device is being used in software vertex processing mode.   	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDeviceCaps([Out] D3DCAPS9* pCaps)</unmanaged>
        public SlimDX2.Direct3D9.Caps9 DeviceCaps {
                get { SlimDX2.Direct3D9.Caps9 __output__; GetDeviceCaps(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the creation parameters of the device.	
        /// </summary>	
        /// <remarks>	
        ///  You can query the AdapterOrdinal member of the returned <see cref="SlimDX2.Direct3D9.DeviceCreationParameters"/> structure to retrieve the ordinal of the adapter represented by this device.  	
        /// </remarks>	
        /// <unmanaged>HRESULT GetCreationParameters([Out] D3DDEVICE_CREATION_PARAMETERS* pParameters)</unmanaged>
        public SlimDX2.Direct3D9.DeviceCreationParameters CreationParameters {
                get { SlimDX2.Direct3D9.DeviceCreationParameters __output__; GetCreationParameters(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the number of implicit swap chains.	
        /// </summary>	
        /// <remarks>	
        ///  Implicit swap chains are created by the device during <see cref="SlimDX2.Direct3D9.Direct3D9.CreateDevice"/>. This method returns the number of swap chains created by CreateDevice.   An application may create additional swap chains using <see cref="SlimDX2.Direct3D9.Device.CreateAdditionalSwapChain"/>. 	
        /// </remarks>	
        /// <unmanaged>UINT GetNumberOfSwapChains()</unmanaged>
        public int NumberOfSwapChains {
                get { return GetNumberOfSwapChains(); }
        }
        
        /// <summary>	
        /// This method allows the use of GDI dialog boxes in full-screen mode applications.	
        /// </summary>	
        /// <remarks>	
        ///  The GDI dialog boxes must be created as child to the device window. They should also be created within the same thread that created the device because this enables the parent window to manage redrawing the child window. The method has no effect for windowed mode applications, but this setting will be respected if the application resets the device into full-screen mode. If SetDialogBoxMode succeeds in a windowed mode application, any subsequent reset to full-screen mode will be checked against the restrictions listed above.  Also, SetDialogBoxMode causes all back buffers on the swap chain to be discarded, so an application is expected to refresh its content for all back buffers after this call. 	
        /// </remarks>	
        /// <unmanaged>HRESULT SetDialogBoxMode([None] BOOL bEnableDialogs)</unmanaged>
        public bool DialogBoxMode {
                set { SetDialogBoxMode(value); }
        }
        
        /// <summary>	
        /// Gets the depth-stencil surface owned by the Direct3DDevice object.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DSurface9 interface results in a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDepthStencilSurface([Out] IDirect3DSurface9** ppZStencilSurface)</unmanaged>
        public SlimDX2.Direct3D9.Surface DepthStencilSurface {
                get { SlimDX2.Direct3D9.Surface __output__; GetDepthStencilSurface(out __output__); return __output__; }
                set { SetDepthStencilSurface(value); }
        }
        
        /// <summary>	
        /// Retrieves the viewport parameters currently set for the device.	
        /// </summary>	
        /// <remarks>	
        ///  Typically, methods that return state will not work on a device that is created using D3DCREATE_PUREDEVICE. This method however, will work even on a pure device. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetViewport([Out] D3DVIEWPORT9* pViewport)</unmanaged>
        public SlimDX2.Direct3D9.Viewport9 Viewport {
                get { SlimDX2.Direct3D9.Viewport9 __output__; GetViewport(out __output__); return __output__; }
                set { SetViewport(ref value); }
        }
        
        /// <summary>	
        /// Retrieves the current material properties for the device.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other values in {{D3DCREATE}}.  	
        /// </remarks>	
        /// <unmanaged>HRESULT GetMaterial([Out] D3DMATERIAL9* pMaterial)</unmanaged>
        public SlimDX2.Direct3D9.Material9 Material {
                get { SlimDX2.Direct3D9.Material9 __output__; GetMaterial(out __output__); return __output__; }
                set { SetMaterial(ref value); }
        }
        
        /// <summary>	
        /// Retrieves the clip status.	
        /// </summary>	
        /// <remarks>	
        ///  When clipping is enabled during vertex processing (by <see cref="SlimDX2.Direct3D9.Device.ProcessVertices"/>, <see cref="SlimDX2.Direct3D9.Device.DrawPrimitive"/>, or other drawing functions), Direct3D computes a clip code for every vertex. The clip code is a combination of D3DCS_* bits. When a vertex is outside a particular clipping plane, the corresponding bit is set in the clipping code. Direct3D maintains the clip status using <see cref="SlimDX2.Direct3D9.Clipstatus9"/>, which has ClipUnion and ClipIntersection members. ClipUnion is a bitwise "OR" of all vertex clip codes and ClipIntersection is a bitwise "AND" of all vertex clip codes. Initial values are zero for ClipUnion and 0xFFFFFFFF for ClipIntersection. When D3DRS_CLIPPING is set to FALSE, ClipUnion and ClipIntersection are set to zero. Direct3D updates the clip status during drawing calls. To compute clip status for a particular object, set ClipUnion and ClipIntersection to their initial value and continue drawing. Clip status is not updated by <see cref="SlimDX2.Direct3D9.Device.DrawRectPatch"/> and <see cref="SlimDX2.Direct3D9.Device.DrawTriPatch"/> because there is no software emulation for them. Clip status is used during software vertex processing. Therefore, this method is not supported on pure or nonpure hardware processing devices. For more information about pure devices, see {{D3DCREATE}}. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetClipStatus([Out] D3DCLIPSTATUS9* pClipStatus)</unmanaged>
        public SlimDX2.Direct3D9.Clipstatus9 ClipStatus {
                get { SlimDX2.Direct3D9.Clipstatus9 __output__; GetClipStatus(out __output__); return __output__; }
                set { SetClipStatus(ref value); }
        }
        
        /// <summary>	
        /// Retrieves the current texture palette.	
        /// </summary>	
        /// <unmanaged>HRESULT GetCurrentTexturePalette([Out] UINT* PaletteNumber)</unmanaged>
        public int CurrentTexturePalette {
                get { int __output__; GetCurrentTexturePalette(out __output__); return __output__; }
                set { SetCurrentTexturePalette(value); }
        }
        
        /// <summary>	
        /// Gets the scissor rectangle.	
        /// </summary>	
        /// <remarks>	
        ///  The scissor rectangle is used as a rectangular clipping region. See {{Rectangles (Direct3D 9)}} for further information on the use of rectangles in DirectX. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetScissorRect([Out] RECT* pRect)</unmanaged>
        public SlimDX2.Rectangle ScissorRect {
                get { SlimDX2.Rectangle __output__; GetScissorRect(out __output__); return __output__; }
                set { SetScissorRect(ref value); }
        }
        
        /// <summary>	
        /// Gets the vertex processing (hardware or software) mode.	
        /// </summary>	
        /// <remarks>	
        ///  An application can create a mixed-mode device to use both the software vertex processing and the hardware vertex processing. To switch between the two vertex processing modes in DirectX 8.x, use <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/> with the render state D3DRS_SOFTWAREVERTEXPROCESSING and the appropriate BOOL argument. The drawback of the render state approach was the difficulty in defining the semantics for state blocks. Applications and the runtime had to do extra work and be careful while recording and playing back state blocks. In Direct3D 9, use <see cref="SlimDX2.Direct3D9.Device.SetSoftwareVertexProcessing"/> instead. This new API is not recorded by StateBlocks. 	
        /// </remarks>	
        /// <unmanaged>BOOL GetSoftwareVertexProcessing()</unmanaged>
        public bool SoftwareVertexProcessing {
                get { return GetSoftwareVertexProcessing(); }
                set { SetSoftwareVertexProcessing(value); }
        }
        
        /// <summary>	
        /// Gets the N-patch mode segments.	
        /// </summary>	
        /// <unmanaged>float GetNPatchMode()</unmanaged>
        public float NPatchMode {
                get { return GetNPatchMode(); }
                set { SetNPatchMode(value); }
        }
        
        /// <summary>	
        /// Gets a vertex shader declaration.	
        /// </summary>	
        /// <unmanaged>HRESULT GetVertexDeclaration([Out] IDirect3DVertexDeclaration9** ppDecl)</unmanaged>
        public SlimDX2.Direct3D9.VertexDeclaration VertexDeclaration {
                get { SlimDX2.Direct3D9.VertexDeclaration __output__; GetVertexDeclaration(out __output__); return __output__; }
                set { SetVertexDeclaration(value); }
        }
        
        /// <summary>	
        /// Gets the fixed vertex function declaration.	
        /// </summary>	
        /// <remarks>	
        ///  The fixed vertex function declaration is a set of FVF flags that determine how vertices processed by the fixed function pipeline will be used. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetFVF([Out] int* pFVF)</unmanaged>
        public int FVF {
                get { int __output__; GetFVF(out __output__); return __output__; }
                set { SetFVF(value); }
        }
        
        /// <summary>	
        /// Retrieves the currently set vertex shader.	
        /// </summary>	
        /// <remarks>	
        ///  Typically, methods that return state will not work on a device that is created using D3DCREATE_PUREDEVICE. This method however, will work even on a pure device because it returns an interface. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetVertexShader([Out] IDirect3DVertexShader9** ppShader)</unmanaged>
        public SlimDX2.Direct3D9.VertexShader VertexShader {
                get { SlimDX2.Direct3D9.VertexShader __output__; GetVertexShader(out __output__); return __output__; }
                set { SetVertexShader(value); }
        }
        
        /// <summary>	
        /// Retrieves index data.	
        /// </summary>	
        /// <remarks>	
        ///   Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.IndexBuffer"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DIndexBuffer9 interface results in a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetIndices([Out] IDirect3DIndexBuffer9** ppIndexData)</unmanaged>
        public SlimDX2.Direct3D9.IndexBuffer Indices {
                get { SlimDX2.Direct3D9.IndexBuffer __output__; GetIndices(out __output__); return __output__; }
                set { SetIndices(value); }
        }
        
        /// <summary>	
        /// Retrieves the currently set pixel shader.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not work on a device that is created using D3DCREATE_PUREDEVICE. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetPixelShader([Out] IDirect3DPixelShader9** ppShader)</unmanaged>
        public SlimDX2.Direct3D9.PixelShader PixelShader {
                get { SlimDX2.Direct3D9.PixelShader __output__; GetPixelShader(out __output__); return __output__; }
                set { SetPixelShader(value); }
        }
        
        /// <summary>	
        /// Reports the current cooperative-level status of the Direct3D device for a windowed or full-screen application.	
        /// </summary>	
        /// <remarks>	
        ///  If the device is lost but cannot be restored at the current time, IDirect3DDevice9::TestCooperativeLevel returns the D3DERR_DEVICELOST return code. This would be the case, for example, when a full-screen device has lost focus. If an application detects a lost device, it should pause and periodically call IDirect3DDevice9::TestCooperativeLevel until it receives a return value of D3DERR_DEVICENOTRESET. The application may then attempt to reset the device by calling <see cref="SlimDX2.Direct3D9.Device.Reset"/> and, if this succeeds, restore the necessary resources and resume normal operation. Note that <see cref="SlimDX2.Direct3D9.Device.Present"/> will return D3DERR_DEVICELOST if the device is either "lost" or "not reset". A call to IDirect3DDevice9::TestCooperativeLevel will fail if called on a different thread than that used to create the device being reset. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK, indicating that the device is operational and the calling application can continue. If the method fails, the return value can be one of the following values: D3DERR_DEVICELOST, D3DERR_DEVICENOTRESET, D3DERR_DRIVERINTERNALERROR.  </returns>
        /// <unmanaged>HRESULT TestCooperativeLevel()</unmanaged>
        public SlimDX2.Result TestCooperativeLevel() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns an estimate of the amount of available texture memory.	
        /// </summary>	
        /// <remarks>	
        ///  The returned value is rounded to the nearest MB. This is done to reflect the fact that video memory estimates are never precise due to alignment and other issues that affect consumption by certain resources. Applications can use this value to make gross estimates of memory availability to make large-scale resource decisions such as how many levels of a mipmap to attempt to allocate, but applications cannot use this value to make small-scale decisions such as if there is enough memory left to allocate another resource. 	
        /// </remarks>	
        /// <returns>  {{UINT}}  The function returns an estimate of the available texture memory. </returns>
        /// <unmanaged>UINT GetAvailableTextureMem()</unmanaged>
        internal int GetAvailableTextureMem() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Evicts all managed resources, including both Direct3D and driver-managed resources.	
        /// </summary>	
        /// <remarks>	
        ///  This function causes only the D3DPOOL_DEFAULT copy of resources to be evicted. The resource copy in system memory is retained. See <see cref="SlimDX2.Direct3D9.Pool"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_OUTOFVIDEOMEMORY, D3DERR_COMMAND_UNPARSED. </returns>
        /// <unmanaged>HRESULT EvictManagedResources()</unmanaged>
        public SlimDX2.Result EvictManagedResources() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns an interface to the instance of the Direct3D object that created the device.	
        /// </summary>	
        /// <remarks>	
        ///  Calling IDirect3DDevice9::GetDirect3D will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Direct3D9"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3D9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="ppD3D9"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Direct3D9"/> interface, representing the interface of the Direct3D object that created the device.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetDirect3D([Out] IDirect3D9** ppD3D9)</unmanaged>
        internal SlimDX2.Result GetDirect3D(out SlimDX2.Direct3D9.Direct3D9 ppD3D9) {
            unsafe {
                IntPtr ppD3D9_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, &ppD3D9_);
                ppD3D9 = (ppD3D9_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Direct3D9(ppD3D9_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the capabilities of the rendering device.	
        /// </summary>	
        /// <remarks>	
        ///  IDirect3DDevice9::GetDeviceCaps retrieves the software vertex pipeline capabilities when the device is being used in software vertex processing mode.   	
        /// </remarks>	
        /// <param name="pCaps"> Pointer to a <see cref="SlimDX2.Direct3D9.Caps9"/> structure, describing the returned device.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetDeviceCaps([Out] D3DCAPS9* pCaps)</unmanaged>
        internal SlimDX2.Result GetDeviceCaps(out SlimDX2.Direct3D9.Caps9 pCaps) {
            unsafe {
                pCaps = new SlimDX2.Direct3D9.Caps9();
                SlimDX2.Result __result__;
                fixed (void* pCaps_ = &pCaps)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, pCaps_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the display mode's spatial resolution, color resolution, and refresh frequency.	
        /// </summary>	
        /// <param name="iSwapChain"> An unsigned integer specifying the swap chain. </param>
        /// <param name="pMode"> Pointer to a <see cref="SlimDX2.Direct3D9.Displaymode"/> structure containing data about the display mode of the adapter. As opposed to the display mode of the device, which may not be active if the device does not own full-screen mode.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetDisplayMode([None] UINT iSwapChain,[Out] D3DDISPLAYMODE* pMode)</unmanaged>
        public SlimDX2.Result GetDisplayMode(int iSwapChain, out SlimDX2.Direct3D9.Displaymode pMode) {
            unsafe {
                pMode = new SlimDX2.Direct3D9.Displaymode();
                SlimDX2.Result __result__;
                fixed (void* pMode_ = &pMode)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, iSwapChain, pMode_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the creation parameters of the device.	
        /// </summary>	
        /// <remarks>	
        ///  You can query the AdapterOrdinal member of the returned <see cref="SlimDX2.Direct3D9.DeviceCreationParameters"/> structure to retrieve the ordinal of the adapter represented by this device.  	
        /// </remarks>	
        /// <param name="pParameters"> Pointer to a <see cref="SlimDX2.Direct3D9.DeviceCreationParameters"/> structure, describing the creation parameters of the device.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the argument is invalid. </returns>
        /// <unmanaged>HRESULT GetCreationParameters([Out] D3DDEVICE_CREATION_PARAMETERS* pParameters)</unmanaged>
        internal SlimDX2.Result GetCreationParameters(out SlimDX2.Direct3D9.DeviceCreationParameters pParameters) {
            unsafe {
                pParameters = new SlimDX2.Direct3D9.DeviceCreationParameters();
                SlimDX2.Result __result__;
                fixed (void* pParameters_ = &pParameters)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, pParameters_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets properties for the cursor.	
        /// </summary>	
        /// <remarks>	
        ///  An operating system cursor is created and used under either of these conditions:  The hardware has set D3DCURSORCAPS_COLOR (see {{D3DCURSORCAPS}}), and the cursor size is 32x32 (which is the cursor size in the operating system). The application is running in windowed mode.  Otherwise, DirectX uses an emulated cursor. An application uses <see cref="SlimDX2.Direct3D9.Device.SetCursorPosition"/> to move an emulated cursor to follow mouse movement. It is recommended for applications to always trap WM_MOUSEMOVE events and call DXSetCursorPosition. Direct3D cursor functions use either GDI cursor or software emulation, depending on the hardware. Users typically want to respond to a WM_SETCURSOR message. For example, they might want to write the message handler as follows: 	
        /// <code> case WM_SETCURSOR:	
        /// // Turn off window cursor. 	
        /// SetCursor( NULL );	
        /// m_pd3dDevice-&gt;ShowCursor( TRUE );	
        /// return TRUE; // Prevent Windows from setting cursor to window class cursor.	
        /// break; </code>	
        /// 	
        ///  Or, users might want to call the IDirect3DDevice9::SetCursorProperties method if they want to change the cursor.  The application can determine what hardware support is available for cursors by examining appropriate members of the <see cref="SlimDX2.Direct3D9.Caps9"/> structure. Typically, hardware supports only 32x32 cursors and, when windowed, the system might support only 32x32 cursors. In this case, IDirect3DDevice9::SetCursorProperties still succeeds but the cursor might be reduced to that size. The hot spot is scaled appropriately. The cursor does not survive when the device is lost. This method must be called after the device is reset. 	
        /// </remarks>	
        /// <param name="xHotSpot"> X-coordinate offset (in pixels) that marks the center of the cursor. The offset is relative to the upper-left corner of the cursor. When the cursor is given a new position, the image is drawn at an offset from this new position determined by subtracting the hot spot coordinates from the position.  </param>
        /// <param name="yHotSpot"> Y-coordinate offset (in pixels) that marks the center of the cursor. The offset is relative to the upper-left corner of the cursor. When the cursor is given a new position, the image is drawn at an offset from this new position determined by subtracting the hot spot coordinates from the position.  </param>
        /// <param name="pCursorBitmap"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface. This parameter must point to an 8888 ARGB surface (format D3DFMT_A8R8G8B8). The contents of this surface will be copied and potentially format-converted into an internal buffer from which the cursor is displayed. The dimensions of this surface must be less than the dimensions of the display mode, and must be a power of two in each direction, although not necessarily the same power of two. The alpha channel must be either 0.0 or 1.0.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT SetCursorProperties([None] UINT XHotSpot,[None] UINT YHotSpot,[None] IDirect3DSurface9* pCursorBitmap)</unmanaged>
        public SlimDX2.Result SetCursorProperties(int xHotSpot, int yHotSpot, SlimDX2.Direct3D9.Surface pCursorBitmap) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, xHotSpot, yHotSpot, (void*)((pCursorBitmap == null)?IntPtr.Zero:pCursorBitmap.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the cursor position and update options.	
        /// </summary>	
        /// <remarks>	
        ///  When running in full-screen mode, screen space coordinates are the back buffer coordinates appropriately scaled to the current display mode. When running in windowed mode, screen space coordinates are the desktop coordinates. The cursor image is drawn at the specified position minus the hotspot-offset specified by the {{SetCursorProperties}} method. If the cursor has been hidden by {{ShowCursor}}, the cursor is not drawn. 	
        /// </remarks>	
        /// <param name="x"> The new X-position of the cursor in virtual desktop coordinates. See Remarks.  </param>
        /// <param name="y"> The new Y-position of the cursor in virtual desktop coordinates. See Remarks.  </param>
        /// <param name="flags">  Specifies the update options for the cursor. Currently, only one flag is defined.  ValueMeaning  D3DCURSOR_IMMEDIATE_UPDATE   Update cursor at the refresh rate. If this flag is specified, the system guarantees that the cursor will be updated at a minimum of half the display refresh rate, but never more frequently than the display refresh rate. Otherwise, the method delays cursor updates until the next <see cref="SlimDX2.Direct3D9.Device.Present"/> call. Not setting this flag usually results in better performance than if the flag is set. However, applications should set this flag if the rate of calls to Present is low enough that users would notice a significant delay in cursor motion. This flag has no effect in a windowed-mode application. Some video cards implement hardware color cursors. This flag does not have an effect on these cards.     </param>
        /// <unmanaged>void SetCursorPosition([None] int X,[None] int Y,[None] int Flags)</unmanaged>
        public void SetCursorPosition(int x, int y, int flags) {
            unsafe {
                SlimDX2.Direct3D9.LocalInterop.Callivoid(_nativePointer, 11 * 4, x, y, flags);
            }
        }
        
        /// <summary>	
        /// Displays or hides the cursor.	
        /// </summary>	
        /// <remarks>	
        ///  Direct3D cursor functions use either GDI cursor or software emulation, depending on the hardware. Users usually want to respond to a WM_SETCURSOR message. For example, the users might want to write the message handler like this: 	
        /// <code> case WM_SETCURSOR: // Turn off window cursor  SetCursor( NULL ); m_pd3dDevice-&gt;ShowCursor( TRUE ); return TRUE; // prevent Windows from setting cursor to window class cursor break; </code>	
        /// 	
        ///  Or users might want to call the <see cref="SlimDX2.Direct3D9.Device.SetCursorProperties"/> method if they want to change the cursor. See the code in the DirectX Graphics C/C++ Samples for more detail. 	
        /// </remarks>	
        /// <param name="bShow"> If bShow is TRUE, the cursor is shown. If bShow is FALSE, the cursor is hidden.  </param>
        /// <returns>  {{BOOL}}  Value indicating whether the cursor was previously visible. TRUE if the cursor was previously visible, or FALSE if the cursor was not previously visible. </returns>
        /// <unmanaged>BOOL ShowCursor([None] BOOL bShow)</unmanaged>
        public bool ShowCursor(bool bShow) {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, (bShow?1:0)));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates an additional swap chain for rendering multiple views.	
        /// </summary>	
        /// <remarks>	
        ///  There is always at least one swap chain (the implicit swap chain) for each device because Direct3D 9 has one swap chain as a property of the device.  Note that any given device can support only one full-screen swap chain. D3DFMT_UNKNOWN can be specified for the windowed mode back buffer format when calling <see cref="SlimDX2.Direct3D9.Direct3D9.CreateDevice"/>, <see cref="SlimDX2.Direct3D9.Device.Reset"/> and CreateAdditionalSwapChain. This means the application does not have to query the current desktop format before calling CreateDevice for windowed mode. For full-screen mode, the back buffer format must be specified.  	
        /// </remarks>	
        /// <param name="pPresentationParameters"> Pointer to a <see cref="SlimDX2.Direct3D9.PresentParameters"/> structure, containing the presentation parameters for the new swap chain. This value cannot be NULL. Calling this method changes the value of members of the D3DPRESENT_PARAMETERS structure.  If BackBufferCount == 0, calling CreateAdditionalSwapChain will increase it to 1. If the application is in windowed mode, and if either the BackBufferWidth or the BackBufferHeight == 0, they will be set to the client area width and height of the hwnd.  </param>
        /// <param name="pSwapChain"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.SwapChain"/> interface, representing the additional swap chain.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_DEVICELOST, D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT CreateAdditionalSwapChain([None] D3DPRESENT_PARAMETERS* pPresentationParameters,[None] IDirect3DSwapChain9** pSwapChain)</unmanaged>
        public SlimDX2.Result CreateAdditionalSwapChain(ref SlimDX2.Direct3D9.PresentParameters pPresentationParameters, out SlimDX2.Direct3D9.SwapChain pSwapChain) {
            unsafe {
                IntPtr pSwapChain_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pPresentationParameters_ = &pPresentationParameters)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, pPresentationParameters_, &pSwapChain_);
                pSwapChain = (pSwapChain_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.SwapChain(pSwapChain_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a pointer to a swap chain.	
        /// </summary>	
        /// <param name="iSwapChain"> The swap chain ordinal value.  For more information, see NumberOfAdaptersInGroup in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="pSwapChain"> Pointer to an <see cref="SlimDX2.Direct3D9.SwapChain"/> interface that will receive a copy of swap chain.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetSwapChain([None] UINT iSwapChain,[Out] IDirect3DSwapChain9** pSwapChain)</unmanaged>
        public SlimDX2.Result GetSwapChain(int iSwapChain, out SlimDX2.Direct3D9.SwapChain pSwapChain) {
            unsafe {
                IntPtr pSwapChain_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, iSwapChain, &pSwapChain_);
                pSwapChain = (pSwapChain_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.SwapChain(pSwapChain_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of implicit swap chains.	
        /// </summary>	
        /// <remarks>	
        ///  Implicit swap chains are created by the device during <see cref="SlimDX2.Direct3D9.Direct3D9.CreateDevice"/>. This method returns the number of swap chains created by CreateDevice.   An application may create additional swap chains using <see cref="SlimDX2.Direct3D9.Device.CreateAdditionalSwapChain"/>. 	
        /// </remarks>	
        /// <returns>  {{UINT}}  Number of implicit swap chains. See Remarks. </returns>
        /// <unmanaged>UINT GetNumberOfSwapChains()</unmanaged>
        internal int GetNumberOfSwapChains() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Resets the type, size, and format of the swap chain.	
        /// </summary>	
        /// <remarks>	
        ///  If a call to IDirect3DDevice9::Reset fails, the device will be placed in the "lost" state (as indicated by a return value of D3DERR_DEVICELOST from a call to <see cref="SlimDX2.Direct3D9.Device.TestCooperativeLevel"/>) unless it is already in the "not reset" state (as indicated by a return value of D3DERR_DEVICENOTRESET from a call to IDirect3DDevice9::TestCooperativeLevel). Refer to IDirect3DDevice9::TestCooperativeLevel and {{Lost Devices (Direct3D 9)}} for further information concerning the use of IDirect3DDevice9::Reset in the context of lost devices. Calling IDirect3DDevice9::Reset causes all texture memory surfaces to be lost, managed textures to be flushed from video memory, and all state information to be lost. Before calling the IDirect3DDevice9::Reset method for a device, an application should release any explicit render targets, depth stencil surfaces, additional swap chains, state blocks, and D3DPOOL_DEFAULT resources associated with the device. There are two different types of swap chains: full-screen or windowed. If the new swap chain is full-screen, the adapter will be placed in the display mode that matches the new size. Direct3D 9 applications can expect messages to be sent to them during this call (for example, before this call is returned); applications should take precautions not to call into Direct3D at this time. In addition, when IDirect3DDevice9::Reset fails, the only valid methods that can be called are IDirect3DDevice9::Reset, <see cref="SlimDX2.Direct3D9.Device.TestCooperativeLevel"/>, and the various Release member functions. Calling any other method can result in an exception. A call to IDirect3DDevice9::Reset will fail if called on a different thread than that used to create the device being reset. Pixel shaders and vertex shaders survive IDirect3DDevice9::Reset calls for Direct3D 9. They do not need to be re-created explicitly by the application.  <see cref="SlimDX2.Direct3D9.Format.MtUnknown"/> can be specified for the windowed mode back buffer format when calling <see cref="SlimDX2.Direct3D9.Direct3D9.CreateDevice"/>, IDirect3DDevice9::Reset, and <see cref="SlimDX2.Direct3D9.Device.CreateAdditionalSwapChain"/>. This means the application does not have to query the current desktop format before calling IDirect3D9::CreateDevice for windowed mode. For full-screen mode, the back buffer format must be specified. Setting BackBufferCount equal to zero  (BackBufferCount = 0) results in one back buffer. When trying to reset more than one display adapter in a group, set pPresentationParameters to point to an array of <see cref="SlimDX2.Direct3D9.PresentParameters"/> structures, one for each display in the adapter group. If a multihead device was created with {{D3DCREATE_ADAPTERGROUP_DEVICE}}, IDirect3DDevice9::Reset requires an array of <see cref="SlimDX2.Direct3D9.PresentParameters"/> structures wherein each structure must specify a full-screen display. To switch back to windowed mode, the application must destroy the device and re-create a non-multihead device in windowed mode. 	
        /// </remarks>	
        /// <param name="pPresentationParameters"> Pointer to a <see cref="SlimDX2.Direct3D9.PresentParameters"/> structure, describing the new presentation parameters. This value cannot be NULL.   When switching to full-screen mode, Direct3D will try to find a desktop format that matches the back buffer format, so that back buffer and front buffer formats will be identical (to eliminate the need for color conversion). When this method returns:  BackBufferCount, BackBufferWidth, and BackBufferHeight are set to zero. BackBufferFormat is set to <see cref="SlimDX2.Direct3D9.Format.MtUnknown"/> for windowed mode only; a full-screen mode must specify a format.  </param>
        /// <returns>  <see cref="int"/>  Possible return values include: D3D_OK, D3DERR_DEVICELOST, D3DERR_DEVICEREMOVED, D3DERR_DRIVERINTERNALERROR, or D3DERR_OUTOFVIDEOMEMORY (see {{D3DERR}}). </returns>
        /// <unmanaged>HRESULT Reset([None] D3DPRESENT_PARAMETERS* pPresentationParameters)</unmanaged>
        public SlimDX2.Result Reset(ref SlimDX2.Direct3D9.PresentParameters pPresentationParameters) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pPresentationParameters_ = &pPresentationParameters)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, pPresentationParameters_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Presents the contents of the next buffer in the sequence of back buffers owned by the device.	
        /// </summary>	
        /// <remarks>	
        ///  If necessary, a stretch operation is applied to transfer the pixels within the source rectangle to the destination rectangle in the client area of the target window.  Present will fail, returning D3DERR_INVALIDCALL, if called between BeginScene and EndScene pairs unless the render target is not the current render target (such as the back buffer you get from creating an additional swap chain). This is a new behavior for Direct3D 9.  	
        /// </remarks>	
        /// <param name="pSourceRect"> Pointer to a value that must be NULL unless the swap chain was created with D3DSWAPEFFECT_COPY. pSourceRect is a pointer to a <see cref="SlimDX2.Rectangle"/> structure containing the source rectangle. If NULL, the entire source surface is presented. If the rectangle exceeds the source surface, the rectangle is clipped to the source surface.  </param>
        /// <param name="pDestRect"> Pointer to a value that must be NULL unless the swap chain was created with D3DSWAPEFFECT_COPY. pDestRect is a pointer to a <see cref="SlimDX2.Rectangle"/> structure containing the destination rectangle, in window client coordinates. If NULL, the entire client area is filled. If the rectangle exceeds the destination client area, the rectangle is clipped to the destination client area.  </param>
        /// <param name="hDestWindowOverride"> Pointer to a destination window whose client area is taken as the target for this presentation. If this value is NULL, then the hWndDeviceWindow member of <see cref="SlimDX2.Direct3D9.PresentParameters"/> is taken.  </param>
        /// <param name="pDirtyRegion"> Value must be NULL unless the swap chain was created with D3DSWAPEFFECT_COPY. For more information about swap chains, see {{Flipping Surfaces (Direct3D 9)}} and <see cref="SlimDX2.Direct3D9.Swapeffect"/>. If this value is non-NULL, the contained region is expressed in back buffer coordinates. The rectangles within the region are the minimal set of pixels that need to be updated. This method takes these rectangles into account when optimizing the presentation by copying only the pixels within the region, or some suitably expanded set of rectangles. This is an aid to optimization only, and the application should not rely on the region being copied exactly. The implementation can choose to copy the whole source rectangle.   </param>
        /// <returns>  <see cref="int"/>  Possible return values include: D3D_OK or D3DERR_DEVICEREMOVED (see {{D3DERR}}). </returns>
        /// <unmanaged>HRESULT Present([None] const RECT* pSourceRect,[None] const RECT* pDestRect,[None] HWND hDestWindowOverride,[None] const RGNDATA* pDirtyRegion)</unmanaged>
        public SlimDX2.Result Present(ref SlimDX2.Rectangle pSourceRect, ref SlimDX2.Rectangle pDestRect, IntPtr hDestWindowOverride, ref SlimDX2.Windows.Rgndata pDirtyRegion) {
            unsafe {
                SlimDX2.Windows.Rgndata.__Native pDirtyRegion_ = new SlimDX2.Windows.Rgndata.__Native();
                pDirtyRegion.__MarshalTo(ref pDirtyRegion_);
                SlimDX2.Result __result__;
                fixed (void* pSourceRect_ = &pSourceRect)
                    fixed (void* pDestRect_ = &pDestRect)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, pSourceRect_, pDestRect_, (void*)hDestWindowOverride, &pDirtyRegion_);
                pDirtyRegion.__MarshalFrom(ref pDirtyRegion_);
                pDirtyRegion_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a back buffer from the device's swap chain.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DSurface9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="iSwapChain"> An unsigned integer specifying the swap chain. </param>
        /// <param name="iBackBuffer"> Index of the back buffer object to return. Back buffers are numbered from 0 to the total number of back buffers minus one. A value of 0 returns the first back buffer, not the front buffer. The front buffer is not accessible through this method. Use <see cref="SlimDX2.Direct3D9.Device.GetFrontBufferData"/> to retrieve a copy of the front buffer. </param>
        /// <param name="type"> Stereo view is not supported in Direct3D 9, so the only valid value for this parameter is D3DBACKBUFFER_TYPE_MONO.  </param>
        /// <param name="ppBackBuffer"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the returned back buffer surface.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If BackBuffer equals or exceeds the total number of back buffers, then the function fails and returns D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetBackBuffer([None] UINT iSwapChain,[None] UINT iBackBuffer,[None] D3DBACKBUFFER_TYPE Type,[Out] IDirect3DSurface9** ppBackBuffer)</unmanaged>
        public SlimDX2.Result GetBackBuffer(int iSwapChain, int iBackBuffer, SlimDX2.Direct3D9.BackbufferType type, out SlimDX2.Direct3D9.Surface ppBackBuffer) {
            unsafe {
                IntPtr ppBackBuffer_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, iSwapChain, iBackBuffer, unchecked((int)type), &ppBackBuffer_);
                ppBackBuffer = (ppBackBuffer_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(ppBackBuffer_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns information describing the raster of the monitor on which the swap chain is presented.	
        /// </summary>	
        /// <param name="iSwapChain"> An unsigned integer specifying the swap chain. </param>
        /// <param name="pRasterStatus"> Pointer to a <see cref="SlimDX2.Direct3D9.RasterStatus"/> structure filled with information about the position or other status of the raster on the monitor driven by this adapter.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if pRasterStatus is invalid or if the device does not support reading the current scan line. To determine if the device supports reading the scan line, check for the D3DCAPS_READ_SCANLINE flag in the Caps member of <see cref="SlimDX2.Direct3D9.Caps9"/>.  </returns>
        /// <unmanaged>HRESULT GetRasterStatus([None] UINT iSwapChain,[Out] D3DRASTER_STATUS* pRasterStatus)</unmanaged>
        public SlimDX2.Result GetRasterStatus(int iSwapChain, out SlimDX2.Direct3D9.RasterStatus pRasterStatus) {
            unsafe {
                pRasterStatus = new SlimDX2.Direct3D9.RasterStatus();
                SlimDX2.Result __result__;
                fixed (void* pRasterStatus_ = &pRasterStatus)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, iSwapChain, pRasterStatus_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// This method allows the use of GDI dialog boxes in full-screen mode applications.	
        /// </summary>	
        /// <remarks>	
        ///  The GDI dialog boxes must be created as child to the device window. They should also be created within the same thread that created the device because this enables the parent window to manage redrawing the child window. The method has no effect for windowed mode applications, but this setting will be respected if the application resets the device into full-screen mode. If SetDialogBoxMode succeeds in a windowed mode application, any subsequent reset to full-screen mode will be checked against the restrictions listed above.  Also, SetDialogBoxMode causes all back buffers on the swap chain to be discarded, so an application is expected to refresh its content for all back buffers after this call. 	
        /// </remarks>	
        /// <param name="bEnableDialogs"> TRUE to enable GDI dialog boxes, and FALSE to disable them. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL unless all of the following are true.   The application specified a back buffer format compatible with GDI, in other words, one of D3DFMT_X1R5G5B5, D3DFMT_R5G6B5, or D3DFMT_X8R8G8B8. The application specified no multisampling. The application specified D3DSWAPEFFECT_DISCARD. The application specified D3DPRESENTFLAG_LOCKABLE_BACKBUFFER. The application did not specify D3DCREATE_ADAPTERGROUP_DEVICE. The application is not between BeginScene and EndScene.  </returns>
        /// <unmanaged>HRESULT SetDialogBoxMode([None] BOOL bEnableDialogs)</unmanaged>
        internal SlimDX2.Result SetDialogBoxMode(bool bEnableDialogs) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, (bEnableDialogs?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the gamma correction ramp for the implicit swap chain. This method will affect the entire screen (not just the active window if you are running in windowed mode).	
        /// </summary>	
        /// <remarks>	
        ///  There is always at least one swap chain (the implicit swap chain) for each device, because Direct3D 9 has one swap chain as a property of the device. The gamma ramp takes effect immediately; there is no wait for a vertical sync. If the device does not support gamma ramps in the swap chain's current presentation mode (full-screen or windowed), no error return is given. Applications can check the D3DCAPS2_FULLSCREENGAMMA and D3DCAPS2_CANCALIBRATEGAMMA capability bits in the Caps2 member of the D3DCAPS9 structure to determine the capabilities of the device and whether a calibrator is installed. For windowed gamma correction presentation, use <see cref="SlimDX2.Direct3D9.SwapChain.Present"/> if the hardware supports the feature. In DirectX 8, SetGammaRamp will set the gamma ramp only on a full-screen mode application. For more information about gamma correction, see {{Gamma (Direct3D 9)}}. 	
        /// </remarks>	
        /// <param name="iSwapChain"> Unsigned integer specifying the swap chain. </param>
        /// <param name="flags"> Indicates whether correction should be applied. Gamma correction results in a more consistent display, but can incur processing overhead and should not be used frequently. Short-duration effects, such as flashing the whole screen red, should not be calibrated, but long-duration gamma changes should be calibrated. One of the following values can be set:    ItemDescription  D3DSGR_CALIBRATE  If a gamma calibrator is installed, the ramp will be modified before being sent to the device to account for the system and monitor response curves. If a calibrator is not installed, the ramp will be passed directly to the device.   D3DSGR_NO_CALIBRATION  No gamma correction is applied. The supplied gamma table is transferred directly to the device.     </param>
        /// <param name="pRamp"> Pointer to a <see cref="SlimDX2.Direct3D9.Gammaramp"/> structure, representing the gamma correction ramp to be set for the implicit swap chain.  </param>
        /// <unmanaged>void SetGammaRamp([None] UINT iSwapChain,[None] int Flags,[None] const D3DGAMMARAMP* pRamp)</unmanaged>
        public void SetGammaRamp(int iSwapChain, int flags, ref SlimDX2.Direct3D9.Gammaramp pRamp) {
            unsafe {
                SlimDX2.Direct3D9.Gammaramp.__Native pRamp_ = new SlimDX2.Direct3D9.Gammaramp.__Native();
                pRamp.__MarshalTo(ref pRamp_);
                SlimDX2.Direct3D9.LocalInterop.Callivoid(_nativePointer, 21 * 4, iSwapChain, flags, &pRamp_);
                pRamp.__MarshalFrom(ref pRamp_);
                pRamp_.__MarshalFree();
            }
        }
        
        /// <summary>	
        /// Retrieves the gamma correction ramp for the swap chain.	
        /// </summary>	
        /// <param name="iSwapChain"> An unsigned integer specifying the swap chain. </param>
        /// <param name="pRamp"> Pointer to an application-supplied <see cref="SlimDX2.Direct3D9.Gammaramp"/> structure to fill with the gamma correction ramp.  </param>
        /// <unmanaged>void GetGammaRamp([None] UINT iSwapChain,[Out] D3DGAMMARAMP* pRamp)</unmanaged>
        public void GetGammaRamp(int iSwapChain, out SlimDX2.Direct3D9.Gammaramp pRamp) {
            unsafe {
                SlimDX2.Direct3D9.Gammaramp.__Native pRamp_ = new SlimDX2.Direct3D9.Gammaramp.__Native();
                SlimDX2.Direct3D9.LocalInterop.Callivoid(_nativePointer, 22 * 4, iSwapChain, &pRamp_);
                pRamp = new SlimDX2.Direct3D9.Gammaramp();
                pRamp.__MarshalFrom(ref pRamp_);
            }
        }
        
        /// <summary>	
        /// Creates a texture resource.	
        /// </summary>	
        /// <remarks>	
        ///  An application can discover support for {{Automatic Generation of Mipmaps (Direct3D 9)}} in a particular format by calling  <see cref="SlimDX2.Direct3D9.Direct3D9.CheckDeviceFormat"/> with D3DUSAGE_AUTOGENMIPMAP. If IDirect3D9::CheckDeviceFormat returns D3DOK_NOAUTOGEN,  IDirect3DDevice9::CreateTexture will succeed but it will return a one-level texture. In Windows Vista CreateTexture can create a texture from a system memory pointer allowing the application more flexibility over the use, allocation and deletion of  the system memory.  For example, an application could pass a GDI system memory bitmap pointer and get a Direct3D texture interface around it.  Using a system memory  pointer with CreateTexture has the following restrictions.  The pitch of the texture must be equal to the width multiplied by the number of bytes per pixel. Only textures with a single mipmap level are supported.  The Levels argument must be 1. The Pool argument must be D3DPOOL_SYSTEMMEM. The pSharedHandle argument must be a valid pointer to a buffer that can hold the system memory point; *pSharedHandle must  be a valid pointer to system memory with a size in bytes of texture width * texture height * bytes per pixel of the texture format.  	
        /// </remarks>	
        /// <param name="width"> Width of the top-level of the texture, in pixels. The pixel dimensions of subsequent levels will be the truncated value of half of the previous level's  pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by 2 results in 0, 1 will be taken instead.  </param>
        /// <param name="height"> Height of the top-level of the texture, in pixels. The pixel dimensions of subsequent levels will be the truncated value of half of the previous level's  pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by 2 results in 0, 1 will be taken instead.  </param>
        /// <param name="levels"> Number of levels in the texture. If this is zero, Direct3D will generate all texture sublevels down to 1 by 1 pixels for hardware that supports  mipmapped textures. Call <see cref="SlimDX2.Direct3D9.BaseTexture.GetLevelCount"/> to see the number of levels generated.  </param>
        /// <param name="usage"> Usage can be 0, which indicates no usage value. However, if usage is desired, use a combination of one or more {{D3DUSAGE}} constants. It is  good practice to match the usage parameter with the behavior flags in <see cref="SlimDX2.Direct3D9.Direct3D9.CreateDevice"/>.  </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of all levels in the texture.  </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed.  </param>
        /// <param name="ppTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture resource.  </param>
        /// <param name="pSharedHandle"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to  {{share resources}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL,  D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT CreateTexture([None] UINT Width,[None] UINT Height,[None] UINT Levels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] IDirect3DTexture9** ppTexture,[None] HANDLE* pSharedHandle)</unmanaged>
        public SlimDX2.Result CreateTexture(int width, int height, int levels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.Texture ppTexture, IntPtr pSharedHandle) {
            unsafe {
                IntPtr ppTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, width, height, levels, usage, unchecked((int)format), unchecked((int)pool), &ppTexture_, (void*)pSharedHandle);
                ppTexture = (ppTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(ppTexture_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a volume texture resource.	
        /// </summary>	
        /// <param name="width"> Width of the top-level of the volume texture, in pixels. This value must be a power of two if the D3DPTEXTURECAPS_VOLUMEMAP_POW2 member of <see cref="SlimDX2.Direct3D9.Caps9"/> is set. The pixel dimensions of subsequent levels will be the truncated value of half of the previous level's pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by two results in 0 (zero), 1 will be taken instead. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in D3DCAPS9. </param>
        /// <param name="height"> Height of the top-level of the volume texture, in pixels. This value must be a power of two if the D3DPTEXTURECAPS_VOLUMEMAP_POW2 member of <see cref="SlimDX2.Direct3D9.Caps9"/> is set. The pixel dimensions of subsequent levels will be the truncated value of half of the previous level's pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by 2 results in 0 (zero), 1 will be taken instead. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in D3DCAPS9. </param>
        /// <param name="depth"> Depth of the top-level of the volume texture, in pixels. This value must be a power of two if the D3DPTEXTURECAPS_VOLUMEMAP_POW2 member of <see cref="SlimDX2.Direct3D9.Caps9"/> is set. The pixel dimensions of subsequent levels will be the truncated value of half of the previous level's pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by 2 results in 0 (zero), 1 will be taken instead. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in D3DCAPS9. </param>
        /// <param name="levels"> Number of levels in the texture. If this is zero, Direct3D will generate all texture sublevels down to 1x1 pixels for hardware that supports mipmapped volume textures. Call <see cref="SlimDX2.Direct3D9.BaseTexture.GetLevelCount"/> to see the number of levels generated.  </param>
        /// <param name="usage"> Usage can be 0, which indicates no usage value. If usage is desired, use D3DUSAGE_DYNAMIC or D3DUSAGE_SOFTWAREPROCESSING. For more information, see {{D3DUSAGE}}.  </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of all levels in the volume texture.  </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the volume texture should be placed.  </param>
        /// <param name="ppVolumeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the created volume texture resource.  </param>
        /// <param name="pSharedHandle"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT CreateVolumeTexture([None] UINT Width,[None] UINT Height,[None] UINT Depth,[None] UINT Levels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] IDirect3DVolumeTexture9** ppVolumeTexture,[None] HANDLE* pSharedHandle)</unmanaged>
        public SlimDX2.Result CreateVolumeTexture(int width, int height, int depth, int levels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.VolumeTexture ppVolumeTexture, IntPtr pSharedHandle) {
            unsafe {
                IntPtr ppVolumeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, width, height, depth, levels, usage, unchecked((int)format), unchecked((int)pool), &ppVolumeTexture_, (void*)pSharedHandle);
                ppVolumeTexture = (ppVolumeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(ppVolumeTexture_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a cube texture resource.	
        /// </summary>	
        /// <remarks>	
        ///  A mipmap (texture) is a collection of successively downsampled (mipmapped) surfaces. On the other hand, a cube texture (created by IDirect3DDevice9::CreateCubeTexture) is a collection of six textures (mipmaps), one for each face. All faces must be present in the cube texture. Also, a cube map surface must be the same pixel size in all three dimensions (x, y, and z). An application can discover support for {{Automatic Generation of Mipmaps (Direct3D 9)}} in a particular format by calling <see cref="SlimDX2.Direct3D9.Direct3D9.CheckDeviceFormat"/> with D3DUSAGE_AUTOGENMIPMAP. If IDirect3D9::CheckDeviceFormat returns D3DOK_NOAUTOGEN, IDirect3DDevice9::CreateCubeTexture will succeed but it will return a one-level texture. 	
        /// </remarks>	
        /// <param name="edgeLength"> Size of the edges of all the top-level faces of the cube texture. The pixel dimensions of subsequent levels of each face will be the truncated value of half of the previous level's pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by 2 results in 0 (zero), 1 will be taken instead.  </param>
        /// <param name="levels"> Number of levels in each face of the cube texture. If this is zero, Direct3D will generate all cube texture sublevels down to 1x1 pixels for each face for hardware that supports mipmapped cube textures.  Call <see cref="SlimDX2.Direct3D9.BaseTexture.GetLevelCount"/> to see the number of levels generated.  </param>
        /// <param name="usage"> Usage can be 0, which indicates no usage value. However, if usage is desired, use a combination of one or more {{D3DUSAGE}} constants. It is good practice to match the usage parameter in CreateCubeTexture with the behavior flags in <see cref="SlimDX2.Direct3D9.Direct3D9.CreateDevice"/>. For more information, see Remarks.  </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of all levels in all faces of the cube texture.  </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the cube texture should be placed.  </param>
        /// <param name="ppCubeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture resource.  </param>
        /// <param name="pSharedHandle"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT CreateCubeTexture([None] UINT EdgeLength,[None] UINT Levels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] IDirect3DCubeTexture9** ppCubeTexture,[None] HANDLE* pSharedHandle)</unmanaged>
        public SlimDX2.Result CreateCubeTexture(int edgeLength, int levels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.CubeTexture ppCubeTexture, IntPtr pSharedHandle) {
            unsafe {
                IntPtr ppCubeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4, edgeLength, levels, usage, unchecked((int)format), unchecked((int)pool), &ppCubeTexture_, (void*)pSharedHandle);
                ppCubeTexture = (ppCubeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(ppCubeTexture_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a vertex buffer.	
        /// </summary>	
        /// <remarks>	
        ///  A vertex buffer can be used with either hardware or software vertex processing. This is determined by how the device and the vertex buffer are created. When a device is created, CreateDevice uses the behavior flag to determine whether to process vertices in hardware or software. There are three possibilities:  Process vertices in hardware by setting D3DCREATE_HARDWARE_VERTEXPROCESSING. Process vertices in software by setting D3DCREATE_SOFTWARE_VERTEXPROCESSING. Process vertices in either hardware or software by setting D3DCREATE_MIXED_VERTEXPROCESSING.  Mixed-mode devices might need to switch between software and hardware processing (using <see cref="SlimDX2.Direct3D9.Device.SetSoftwareVertexProcessing"/>) after the device is created.     When a vertex buffer is created, CreateVertexBuffer uses the usage parameter to decide whether to process vertices in hardware or software.  If CreateDevice uses D3DCREATE_HARDWARE_VERTEXPROCESSING, CreateVertexBuffer must use 0. If CreateDevice uses D3DCREATE_SOFTWARE_VERTEXPROCESSING, CreateVertexBuffer must use either 0 or D3DUSAGE_SOFTWAREPROCESSING. For either value, vertices will be processed in software. If CreateDevice uses D3DCREATE_MIXED_VERTEXPROCESSING, CreateVertexBuffer can use either 0 or D3DUSAGE_SOFTWAREPROCESSING.  To use a vertex buffer with a mixed mode device, create a single vertex buffer which can be used for both hardware or software processing. Use <see cref="SlimDX2.Direct3D9.Device.SetStreamSource"/> to set the current vertex buffer and use <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/>, if necessary, to change the device behavior to match. It is recommended that the vertex buffer usage matches the device behavior. Note that a vertex buffer created for software processing cannot be located in video memory. The <see cref="SlimDX2.Direct3D9.Device"/> interface supports rendering of primitives using vertex data stored in vertex buffer objects. Vertex buffers are created from the IDirect3DDevice9, and are usable only with the IDirect3DDevice9 object from which they are created. When set to a nonzero value, which must be a valid FVF code, the FVF parameter indicates that the buffer content is to be characterized by an FVF code. A vertex buffer that is created with an FVF code is referred to as an FVF vertex buffer. For more information, see {{FVF Vertex Buffers (Direct3D 9)}}.  Non-FVF buffers can be used to interleave data during multipass rendering or multitexture rendering in a single pass. To do this, one buffer contains geometry data and the others contain texture coordinates for each texture to be rendered. When rendering, the buffer containing the geometry data is interleaved with each of the buffers containing the texture coordinates. If FVF buffers were used instead, each of them would need to contain identical geometry data in addition to the texture coordinate data specific to each texture rendered. This would result in either a speed or memory penalty, depending on the strategy used. For more information about texture coordinates, see {{Texture Coordinates (Direct3D 9)}}. 	
        /// </remarks>	
        /// <param name="length"> Size of the vertex buffer, in bytes. For FVF vertex buffers, Length must be large enough to contain at least one vertex, but it need not be a multiple of the vertex size. Length is not validated for non-FVF buffers. See Remarks.  </param>
        /// <param name="usage"> Usage can be 0, which indicates no usage value. However, if usage is desired, use a combination of one or more {{D3DUSAGE}} constants. It is good practice to match the usage parameter in CreateVertexBuffer with the behavior flags in <see cref="SlimDX2.Direct3D9.Direct3D9.CreateDevice"/>. For more information, see Remarks.  </param>
        /// <param name="fvf"> Combination of {{D3DFVF}}, a usage specifier that describes the vertex format of the vertices in this buffer. If this parameter is set to a valid FVF code, the created vertex buffer is an FVF vertex buffer (see Remarks). Otherwise, if this parameter is set to zero, the vertex buffer is a non-FVF vertex buffer.  </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing a valid memory class into which to place the resource. Do not set to D3DPOOL_SCRATCH. </param>
        /// <param name="ppVertexBuffer"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VertexBuffer"/> interface, representing the created vertex buffer resource.  </param>
        /// <param name="pSharedHandle"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT CreateVertexBuffer([None] UINT Length,[None] int Usage,[None] int FVF,[None] D3DPOOL Pool,[None] IDirect3DVertexBuffer9** ppVertexBuffer,[None] HANDLE* pSharedHandle)</unmanaged>
        public SlimDX2.Result CreateVertexBuffer(int length, int usage, int fvf, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.VertexBuffer ppVertexBuffer, IntPtr pSharedHandle) {
            unsafe {
                IntPtr ppVertexBuffer_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 26 * 4, length, usage, fvf, unchecked((int)pool), &ppVertexBuffer_, (void*)pSharedHandle);
                ppVertexBuffer = (ppVertexBuffer_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexBuffer(ppVertexBuffer_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates an index buffer.	
        /// </summary>	
        /// <remarks>	
        ///  Index buffers are memory resources used to hold indices, they are similar to both surfaces and vertex buffers. The use of index buffers enables Direct3D to avoid unnecessary data copying and to place the buffer in the optimal memory type for the expected usage. To use index buffers, create an index buffer, lock it, fill it with indices, unlock it, pass it to <see cref="SlimDX2.Direct3D9.Device.SetIndices"/>, set up the vertices, set up the vertex shader, and call <see cref="SlimDX2.Direct3D9.Device.DrawIndexedPrimitive"/> for rendering. The MaxVertexIndex member of the <see cref="SlimDX2.Direct3D9.Caps9"/> structure indicates the types of index buffers that are valid for rendering. 	
        /// </remarks>	
        /// <param name="length"> Size of the index buffer, in bytes.  </param>
        /// <param name="usage"> Usage can be 0, which indicates no usage value. However, if usage is desired, use a combination of one or more {{D3DUSAGE}} constants. It is good practice to match the usage parameter in CreateIndexBuffer with the behavior flags in <see cref="SlimDX2.Direct3D9.Direct3D9.CreateDevice"/>. For more information, see Remarks.  </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of the index buffer. For more information, see Remarks. The valid settings are the following:    ItemDescription  D3DFMT_INDEX16  Indices are 16 bits each.   D3DFMT_INDEX32  Indices are 32 bits each.     </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing a valid memory class into which to place the resource.  </param>
        /// <param name="ppIndexBuffer"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.IndexBuffer"/> interface, representing the created index buffer resource.  </param>
        /// <param name="pSharedHandle"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.  </returns>
        /// <unmanaged>HRESULT CreateIndexBuffer([None] UINT Length,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] IDirect3DIndexBuffer9** ppIndexBuffer,[None] HANDLE* pSharedHandle)</unmanaged>
        public SlimDX2.Result CreateIndexBuffer(int length, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.IndexBuffer ppIndexBuffer, IntPtr pSharedHandle) {
            unsafe {
                IntPtr ppIndexBuffer_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 27 * 4, length, usage, unchecked((int)format), unchecked((int)pool), &ppIndexBuffer_, (void*)pSharedHandle);
                ppIndexBuffer = (ppIndexBuffer_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.IndexBuffer(ppIndexBuffer_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a render-target surface.	
        /// </summary>	
        /// <remarks>	
        ///  Render-target surfaces are placed in the D3DPOOL_DEFAULT memory class. The creation of lockable, multisampled render targets is not supported. 	
        /// </remarks>	
        /// <param name="width"> Width of the render-target surface, in pixels.  </param>
        /// <param name="height"> Height of the render-target surface, in pixels.  </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of the render target.  </param>
        /// <param name="multiSample"> Member of the <see cref="SlimDX2.Direct3D9.MultisampleType"/> enumerated type, which describes the multisampling buffer type. This parameter specifies the antialiasing type for this render target. When this surface is passed to <see cref="SlimDX2.Direct3D9.Device.SetRenderTarget"/>, its multisample type must be the same as that of the depth-stencil set by <see cref="SlimDX2.Direct3D9.Device.SetDepthStencilSurface"/>.  </param>
        /// <param name="multisampleQuality"> Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by  <see cref="SlimDX2.Direct3D9.Direct3D9.CheckDeviceMultiSampleType"/>. Passing a larger value returns the error, D3DERR_INVALIDCALL. The MultisampleQuality values of paired render targets, depth stencil surfaces, and the multisample type must all match. </param>
        /// <param name="lockable"> Render targets are not lockable unless the application specifies TRUE for Lockable. Note that lockable render targets reduce performance on some graphics hardware. The readback performance (moving data from video memory to system memory) depends on the type of hardware used (AGP vs. PCI Express) and is usually far lower than upload performance (moving data from system to video memory). If you need read access to render targets, use {{GetRenderTargetData}} instead of lockable render targets. </param>
        /// <param name="ppSurface"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface.  </param>
        /// <param name="pSharedHandle"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT CreateRenderTarget([None] UINT Width,[None] UINT Height,[None] D3DFORMAT Format,[None] D3DMULTISAMPLE_TYPE MultiSample,[None] int MultisampleQuality,[None] BOOL Lockable,[None] IDirect3DSurface9** ppSurface,[None] HANDLE* pSharedHandle)</unmanaged>
        public SlimDX2.Result CreateRenderTarget(int width, int height, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.MultisampleType multiSample, int multisampleQuality, bool lockable, out SlimDX2.Direct3D9.Surface ppSurface, IntPtr pSharedHandle) {
            unsafe {
                IntPtr ppSurface_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 28 * 4, width, height, unchecked((int)format), unchecked((int)multiSample), multisampleQuality, (lockable?1:0), &ppSurface_, (void*)pSharedHandle);
                ppSurface = (ppSurface_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(ppSurface_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a depth-stencil resource.	
        /// </summary>	
        /// <remarks>	
        ///  The memory class of the depth-stencil buffer is always D3DPOOL_DEFAULT. 	
        /// </remarks>	
        /// <param name="width"> Width of the depth-stencil surface, in pixels.  </param>
        /// <param name="height"> Height of the depth-stencil surface, in pixels.  </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of the depth-stencil surface. This value must be one of the enumerated depth-stencil formats for this device. </param>
        /// <param name="multiSample"> Member of the <see cref="SlimDX2.Direct3D9.MultisampleType"/> enumerated type, describing the multisampling buffer type. This value must be one of the allowed multisample types. When this surface is passed to <see cref="SlimDX2.Direct3D9.Device.SetDepthStencilSurface"/>, its multisample type must be the same as that of the render target set by <see cref="SlimDX2.Direct3D9.Device.SetRenderTarget"/>. </param>
        /// <param name="multisampleQuality"> Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by  <see cref="SlimDX2.Direct3D9.Direct3D9.CheckDeviceMultiSampleType"/>. Passing a larger value returns the error D3DERR_INVALIDCALL. The MultisampleQuality values of paired render targets, depth stencil surfaces, and the MultiSample type must all match. </param>
        /// <param name="discard"> Set this flag to TRUE to enable z-buffer discarding, and FALSE otherwise.				If this flag is set, the contents of the depth stencil buffer will be invalid after calling either <see cref="SlimDX2.Direct3D9.Device.Present"/> or <see cref="SlimDX2.Direct3D9.Device.SetDepthStencilSurface"/> with a different depth surface. This flag has the same behavior as the constant,  D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL, in {{D3DPRESENTFLAG}}. </param>
        /// <param name="ppSurface"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the created depth-stencil surface resource.  </param>
        /// <param name="pSharedHandle"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT CreateDepthStencilSurface([None] UINT Width,[None] UINT Height,[None] D3DFORMAT Format,[None] D3DMULTISAMPLE_TYPE MultiSample,[None] int MultisampleQuality,[None] BOOL Discard,[None] IDirect3DSurface9** ppSurface,[None] HANDLE* pSharedHandle)</unmanaged>
        public SlimDX2.Result CreateDepthStencilSurface(int width, int height, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.MultisampleType multiSample, int multisampleQuality, bool discard, out SlimDX2.Direct3D9.Surface ppSurface, IntPtr pSharedHandle) {
            unsafe {
                IntPtr ppSurface_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 29 * 4, width, height, unchecked((int)format), unchecked((int)multiSample), multisampleQuality, (discard?1:0), &ppSurface_, (void*)pSharedHandle);
                ppSurface = (ppSurface_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(ppSurface_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copies rectangular subsets of pixels from one surface to another. 	
        /// </summary>	
        /// <remarks>	
        ///  This method is similar to CopyRects in DirectX 8. This function has the following restrictions.  The source surface must have been created with D3DPOOL_SYSTEMMEM. The destination surface must have been created with D3DPOOL_DEFAULT. Neither surface can be locked or holding an outstanding device context. Neither surface can be created with multisampling. The only valid flag for both surfaces is D3DMULTISAMPLE_NONE. The surface format cannot be a depth stencil format. The source and dest rects must fit within the surface. No stretching or shrinking is allowed (the rects must be the same size). The source format must match the dest format.  The following table shows the supported combinations.  Dest formats TextureRT textureRTOff-screen plain Src formatsTextureYesYesYes*Yes RT textureNoNoNoNo RTNoNoNoNo Off-screen plainYesYesYesYes    * If the driver does not support the requested copy, it will be emulated using lock and copy. If the application needs to copy data from a D3DPOOL_DEFAULT render target to a D3DPOOL_SYSTEMMEM surface, it can use {{GetRenderTargetData}}. 	
        /// </remarks>	
        /// <param name="pSourceSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the source surface. This parameter must point to a different surface than pDestinationSurface.  </param>
        /// <param name="pSourceRect"> Pointer to a rectangle on the source surface. Specifying NULL for this parameter causes the entire surface to be copied.  </param>
        /// <param name="pDestinationSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the destination surface. </param>
        /// <param name="pDestPoint"> Pointer to the upper left corner of the destination rectangle. Specifying NULL for this parameter causes the entire surface to be copied.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT UpdateSurface([None] IDirect3DSurface9* pSourceSurface,[None] const RECT* pSourceRect,[None] IDirect3DSurface9* pDestinationSurface,[None] const POINT* pDestPoint)</unmanaged>
        public SlimDX2.Result UpdateSurface(SlimDX2.Direct3D9.Surface pSourceSurface, ref SlimDX2.Rectangle pSourceRect, SlimDX2.Direct3D9.Surface pDestinationSurface, ref System.Drawing.Point pDestPoint) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pSourceRect_ = &pSourceRect)
                    fixed (void* pDestPoint_ = &pDestPoint)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 30 * 4, (void*)((pSourceSurface == null)?IntPtr.Zero:pSourceSurface.NativePointer), pSourceRect_, (void*)((pDestinationSurface == null)?IntPtr.Zero:pDestinationSurface.NativePointer), pDestPoint_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Updates the dirty portions of a texture.	
        /// </summary>	
        /// <remarks>	
        ///  You can dirty a portion of a texture by locking it, or by calling one of the following methods.    <see cref="SlimDX2.Direct3D9.CubeTexture.AddDirtyRect"/>   <see cref="SlimDX2.Direct3D9.Texture.AddDirtyRect"/>   <see cref="SlimDX2.Direct3D9.VolumeTexture.AddDirtyBox"/>   <see cref="SlimDX2.Direct3D9.Device.UpdateSurface"/>   IDirect3DDevice9::UpdateTexture retrieves the dirty portions of the texture by calculating what has been accumulated since the last update operation. For performance reasons, dirty regions are only recorded for level zero of a texture. For sublevels, it is assumed that the corresponding (scaled) rectangle or box is also dirty. Dirty regions are automatically recorded when LockRect or <see cref="SlimDX2.Direct3D9.VolumeTexture.LockBox"/> is called without D3DLOCK_NO_DIRTY_UPDATE or D3DLOCK_READONLY. Also, the destination surface of <see cref="SlimDX2.Direct3D9.Device.UpdateSurface"/> is marked dirty. This method fails if the textures are of different types, if their bottom-level buffers are of different sizes, or if their matching levels do not match. For example, consider a six-level source texture with the following dimensions.  	
        /// <code> 32x16, 16x8, 8x4, 4x2, 2x1, 1x1 </code>	
        /// 	
        ///  This six-level source texture could be the source for the following one-level destination.  	
        /// <code> 1x1 </code>	
        /// 	
        ///  For the following two-level destination.  	
        /// <code> 2x1, 1x1 </code>	
        /// 	
        ///  Or, for the following three-level destination.  	
        /// <code> 4x2, 2x1, 1x1 </code>	
        /// 	
        ///  In addition, this method will fail if the textures are of different formats. If the destination texture has fewer levels than the source, only the matching levels are copied. If the source texture has fewer levels than the destination, the method will fail.  If the source texture has dirty regions, the copy can be optimized by restricting the copy to only those regions. It is not guaranteed that only those bytes marked dirty will be copied. Here are the possibilities for source and destination surface combinations:  If pSourceTexture is a non-autogenerated mipmap and pDestinationTexture is an autogenerated mipmap, only the topmost matching level is updated, and the destination sublevels are regenerated. All other source sublevels are ignored. If both pSourceTexture and pDestinationTexture are autogenerated mipmaps, only the topmost matching level is updated. The sublevels from the source are ignored and the destination sublevels are regenerated. If pSourceTexture is an autogenerated mipmap and pDestinationTexture a non-autogenerated mipmap, UpdateTexture will fail.  	
        /// </remarks>	
        /// <param name="pSourceTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.BaseTexture"/> interface, representing the source texture. The source texture must be in system memory (D3DPOOL_SYSTEMMEM).  </param>
        /// <param name="pDestinationTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.BaseTexture"/> interface, representing the destination texture. The destination texture must be in the D3DPOOL_DEFAULT memory pool.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT UpdateTexture([None] IDirect3DBaseTexture9* pSourceTexture,[None] IDirect3DBaseTexture9* pDestinationTexture)</unmanaged>
        public SlimDX2.Result UpdateTexture(SlimDX2.Direct3D9.BaseTexture pSourceTexture, SlimDX2.Direct3D9.BaseTexture pDestinationTexture) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 31 * 4, (void*)((pSourceTexture == null)?IntPtr.Zero:pSourceTexture.NativePointer), (void*)((pDestinationTexture == null)?IntPtr.Zero:pDestinationTexture.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copies the render-target data from device memory to system memory.	
        /// </summary>	
        /// <remarks>	
        ///  The destination surface must be either an off-screen plain surface or a level of a texture (mipmap or cube texture) created with D3DPOOL_SYSTEMMEM. The source surface must be a regular render target or a level of a render-target texture (mipmap or cube texture) created with POOL_DEFAULT. This method will fail if:  The render target is multisampled. The source render target is a different size than the destination surface. The source render target and destination surface formats do not match.  	
        /// </remarks>	
        /// <param name="pRenderTarget"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> object, representing a render target.  </param>
        /// <param name="pDestSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> object, representing a destination surface.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_DRIVERINTERNALERROR, D3DERR_DEVICELOST, D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetRenderTargetData([Out] IDirect3DSurface9* pRenderTarget,[Out] IDirect3DSurface9* pDestSurface)</unmanaged>
        public SlimDX2.Result GetRenderTargetData(out SlimDX2.Direct3D9.Surface pRenderTarget, out SlimDX2.Direct3D9.Surface pDestSurface) {
            unsafe {
                IntPtr pRenderTarget_ = IntPtr.Zero;
                IntPtr pDestSurface_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 32 * 4, &pRenderTarget_, &pDestSurface_);
                pRenderTarget = (pRenderTarget_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(pRenderTarget_);	
                pDestSurface = (pDestSurface_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(pDestSurface_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Generates a copy of the device's front buffer and places that copy in a system memory buffer provided by the application. 	
        /// </summary>	
        /// <remarks>	
        ///  The buffer pointed to by pDestSurface will be filled with a representation of the front buffer, converted to the standard 32 bits per pixel format D3DFMT_A8R8G8B8.  This method is the only way to capture an antialiased screen shot. This function is very slow, by design, and should not be used in any performance-critical path. For more information, see {{Lost Devices and Retrieved Data}}. 	
        /// </remarks>	
        /// <param name="iSwapChain"> An unsigned integer specifying the swap chain. </param>
        /// <param name="pDestSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface that will receive a copy of the contents of the front buffer. The data is returned in successive rows with no intervening space, starting from the vertically highest row on the device's output to the lowest.  For windowed mode, the size of the destination surface should be the size of the desktop. For full-screen mode, the size of the destination surface should be the screen size.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_DRIVERINTERNALERROR, D3DERR_DEVICELOST, D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT GetFrontBufferData([None] UINT iSwapChain,[Out] IDirect3DSurface9* pDestSurface)</unmanaged>
        public SlimDX2.Result GetFrontBufferData(int iSwapChain, out SlimDX2.Direct3D9.Surface pDestSurface) {
            unsafe {
                IntPtr pDestSurface_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 33 * 4, iSwapChain, &pDestSurface_);
                pDestSurface = (pDestSurface_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(pDestSurface_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copy the contents of the source rectangle to the destination rectangle. The source rectangle can be stretched and filtered by the copy. This function is often used to change the aspect ratio of a video stream.	
        /// </summary>	
        /// <remarks>	
        ///  StretchRect Restrictions  Driver support varies. See the section on driver support (below) to see which drivers support which source and destination formats. The source and destination surfaces must be created in the default memory pool. If filtering is specified, you must set the appropriate filter caps (see StretchRectFilterCaps in <see cref="SlimDX2.Direct3D9.Caps9"/>). Stretching is not supported between source and destination rectangles on the same surface. Stretching is not supported if the destination surface is an off-screen plain surface but the source is not. You many not stretch between source and destination rectangles if either surface is in a compressed format (see {{Using Compressed Textures (Direct3D 9)}}). Stretching supports color-space conversion from YUV to high-precision RGBA only. Since color conversion support is not supported by software emulation, use <see cref="SlimDX2.Direct3D9.Direct3D9.CheckDeviceFormatConversion"/> to test the hardware for color conversion support. If the source or destination surface is a texture surface (or a cube texture surface), you must use a Direct3D 9 driver that supports D3DDEVCAPS2_CAN_STRETCHRECT_FROM_TEXTURES (see {{D3DDEVCAPS2}}).  Additional Restrictions for Depth and Stencil Surfaces  The source and destination surfaces must be plain depth stencil surfaces (not textures) (see <see cref="SlimDX2.Direct3D9.Device.CreateDepthStencilSurface"/>). Neither of the surfaces can be discardable. The entire surface must be copied (that is: sub-rectangle copies are not allowed). Format conversion, stretching, and shrinking are not supported. StretchRect cannot be called inside of a BeginScene/EndScene pair.  Using StretchRect to downsample a Multisample Rendertarget You can use StretchRect to copy from one rendertarget to another. If the source rendertarget is multisampled, this results in downsampling the source rendertarget. For instance you could:  Create a multisampled rendertarget. Create a second rendertarget of the same size, that is not multisampled. Copy (using StretchRect the multisample rendertarget to the second rendertarget.  Note that use of the extra surface involved in using StretchRect to downsample a Multisample Rendertarget will result in a performance hit. Driver Support There are many restrictions as to which surface combinations are valid for StretchRect. Factors include whether the driver is a Direct3D 9 driver or older, and whether the operation will result in stretching/shrinking.  Since applications are not expected to recognize if the driver is a Direct3D 9 driver or not, the runtime will automatically set a new cap, D3DDEVCAPS2_CAN_STRETCHRECT_FROM_TEXTURES cap (see {{D3DDEVCAPS2}}), for Direct3D 9-level drivers and above.  DirectX 8 Driver (no stretching) Dest formats TextureRT textureRTOff-screen plain Src formatsTextureNoNoNoNo RT textureNoYesYesNo RTNoYesYesNo Off-screen plainYesYesYesYes     DirectX 8 Driver (stretching) Dest formats TextureRT textureRTOff-screen plain Src formatsTextureNoNoNoNo RT textureNoNoNoNo RTNoYesYesNo Off-screen plainNoYesYesNo     Direct3D 9 Driver (no stretching) Dest formats TextureRT textureRTOff-screen plain Src formatsTextureNoYesYesNo RT textureNoYesYesNo RTNoYesYesNo Off-screen plainNoYesYesYes     Direct3D 9 Driver (stretching) Dest formats TextureRT textureRTOff-screen plain Src formatsTextureNoYesYesNo RT textureNoYesYesNo RTNoYesYesNo Off-screen plainNoYesYesNo    	
        /// </remarks>	
        /// <param name="pSourceSurface"> Pointer to the source surface. See <see cref="SlimDX2.Direct3D9.Surface"/>. </param>
        /// <param name="pSourceRect"> Pointer to the source rectangle. A NULL for this parameter causes the entire source surface to be used. </param>
        /// <param name="pDestSurface"> Pointer to the destination surface. See <see cref="SlimDX2.Direct3D9.Surface"/>. </param>
        /// <param name="pDestRect"> Pointer to the destination rectangle. A NULL for this parameter causes the entire destination surface to be used. </param>
        /// <param name="filter"> Filter type. Allowable values are D3DTEXF_NONE, D3DTEXF_POINT, or D3DTEXF_LINEAR. For more information, see <see cref="SlimDX2.Direct3D9.Texturefiltertype"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT StretchRect([None] IDirect3DSurface9* pSourceSurface,[None] const RECT* pSourceRect,[None] IDirect3DSurface9* pDestSurface,[None] const RECT* pDestRect,[None] D3DTEXTUREFILTERTYPE Filter)</unmanaged>
        public SlimDX2.Result StretchRect(SlimDX2.Direct3D9.Surface pSourceSurface, ref SlimDX2.Rectangle pSourceRect, SlimDX2.Direct3D9.Surface pDestSurface, ref SlimDX2.Rectangle pDestRect, SlimDX2.Direct3D9.Texturefiltertype filter) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pSourceRect_ = &pSourceRect)
                    fixed (void* pDestRect_ = &pDestRect)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 34 * 4, (void*)((pSourceSurface == null)?IntPtr.Zero:pSourceSurface.NativePointer), pSourceRect_, (void*)((pDestSurface == null)?IntPtr.Zero:pDestSurface.NativePointer), pDestRect_, unchecked((int)filter));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Allows an application to fill a rectangular area of a D3DPOOL_DEFAULT surface with a specified color.	
        /// </summary>	
        /// <remarks>	
        ///  This method can only be applied to a render target, a render-target texture surface, or an off-screen plain surface with a pool type of D3DPOOL_DEFAULT. IDirect3DDevice9::ColorFill will work with all formats. However, when using a reference or software device, the only formats supported are D3DFMT_X1R5G5B5, D3DFMT_A1R5G5B5, D3DFMT_R5G6B5, D3DFMT_X8R8G8B8, D3DFMT_A8R8G8B8, D3DFMT_YUY2, D3DFMT_G8R8_G8B8, D3DFMT_UYVY, D3DFMT_R8G8_B8G8, D3DFMT_R16F, D3DFMT_G16R16F, D3DFMT_A16B16G16R16F, D3DFMT_R32F, D3DFMT_G32R32F, and D3DFMT_A32B32G32R32F. When using a DirectX 7 or DirectX 8.x driver, the only YUV formats supported are D3DFMT_UYVY and D3DFMT_YUY2. 	
        /// </remarks>	
        /// <param name="pSurface"> Pointer to the surface to be filled. </param>
        /// <param name="pRect"> Pointer to the source rectangle. Using NULL means that the entire surface will be filled. </param>
        /// <param name="color"> Color used for filling. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ColorFill([None] IDirect3DSurface9* pSurface,[None] const RECT* pRect,[None] D3DCOLOR color)</unmanaged>
        public SlimDX2.Result ColorFill(SlimDX2.Direct3D9.Surface pSurface, ref SlimDX2.Rectangle pRect, int color) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pRect_ = &pRect)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 35 * 4, (void*)((pSurface == null)?IntPtr.Zero:pSurface.NativePointer), pRect_, color);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create an off-screen surface.	
        /// </summary>	
        /// <remarks>	
        ///  D3DPOOL_SCRATCH will return a surface that has identical characteristics to a surface created by the DirectX 8.x method CreateImageSurface. D3DPOOL_DEFAULT is the appropriate pool for use with the <see cref="SlimDX2.Direct3D9.Device.StretchRect"/> and <see cref="SlimDX2.Direct3D9.Device.ColorFill"/>. D3DPOOL_MANAGED is not allowed when creating an offscreen plain surface. For more information about memory pools, see <see cref="SlimDX2.Direct3D9.Pool"/>. Off-screen plain surfaces are always lockable, regardless of their pool types. 	
        /// </remarks>	
        /// <param name="width"> Width of the surface. </param>
        /// <param name="height"> Height of the surface. </param>
        /// <param name="format"> Format of the surface. See <see cref="SlimDX2.Direct3D9.Format"/>.  </param>
        /// <param name="pool"> Surface pool type. See <see cref="SlimDX2.Direct3D9.Pool"/>. </param>
        /// <param name="ppSurface"> Pointer to the <see cref="SlimDX2.Direct3D9.Surface"/> interface created. </param>
        /// <param name="pSharedHandle"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT CreateOffscreenPlainSurface([None] UINT Width,[None] UINT Height,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] IDirect3DSurface9** ppSurface,[None] HANDLE* pSharedHandle)</unmanaged>
        public SlimDX2.Result CreateOffscreenPlainSurface(int width, int height, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.Surface ppSurface, IntPtr pSharedHandle) {
            unsafe {
                IntPtr ppSurface_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 36 * 4, width, height, unchecked((int)format), unchecked((int)pool), &ppSurface_, (void*)pSharedHandle);
                ppSurface = (ppSurface_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(ppSurface_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a new color buffer for the device.	
        /// </summary>	
        /// <remarks>	
        ///  The device can support multiple render targets. The number of render targets supported by a device is contained in the NumSimultaneousRTs member of <see cref="SlimDX2.Direct3D9.Caps9"/>. See {{Multiple Render Targets (Direct3D 9)}}. Setting a new render target will cause the viewport (see {{Viewports and Clipping (Direct3D 9)}}) to be set to the full size of the new render target. Some hardware tests the compatibility of the depth stencil buffer with the color buffer. If this is done, it is only done in a debug build. Restrictions for using this method include the following:  The multisample type must be the same for the render target and the depth stencil surface. The formats must be compatible for the render target and the depth stencil surface. See <see cref="SlimDX2.Direct3D9.Direct3D9.CheckDepthStencilMatch"/>. The size of the depth stencil surface must be greater than or equal to the size of the render target.  These restrictions are validated only when using the debug runtime when any of the <see cref="SlimDX2.Direct3D9.Device"/> Draw methods are called. Cube textures differ from other surfaces in that they are collections of surfaces. To call IDirect3DDevice9::SetRenderTarget with a cube texture, you must select an individual face using <see cref="SlimDX2.Direct3D9.CubeTexture.GetCubeMapSurface"/> and pass the resulting surface to IDirect3DDevice9::SetRenderTarget.  	
        /// </remarks>	
        /// <param name="renderTargetIndex"> Index of the render target. See Remarks. </param>
        /// <param name="pRenderTarget"> Pointer to a new color buffer. If NULL, the color buffer for the corresponding RenderTargetIndex is disabled. Devices always must be associated with a color buffer. The new render-target surface must have at least D3DUSAGE_RENDERTARGET specified. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. This method will return D3DERR_INVALIDCALL if either:  pRenderTarget = NULL and RenderTargetIndex = 0 pRenderTarget is != NULL and the render target is invalid.  </returns>
        /// <unmanaged>HRESULT SetRenderTarget([None] int RenderTargetIndex,[None] IDirect3DSurface9* pRenderTarget)</unmanaged>
        public SlimDX2.Result SetRenderTarget(int renderTargetIndex, SlimDX2.Direct3D9.Surface pRenderTarget) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 37 * 4, renderTargetIndex, (void*)((pRenderTarget == null)?IntPtr.Zero:pRenderTarget.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a render-target surface.	
        /// </summary>	
        /// <remarks>	
        ///  Typically, methods that return state will not work on a device that is created using D3DCREATE_PUREDEVICE. This method however, will work even on a pure device because it returns an interface. The device can now support multiple render targets. The number of render targets supported by a device is contained in the NumSimultaneousRTs member of <see cref="SlimDX2.Direct3D9.Caps9"/>. See {{Multiple Render Targets (Direct3D 9)}}. Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using the IDirect3DSurface9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="renderTargetIndex"> Index of the render target. See Remarks. </param>
        /// <param name="ppRenderTarget"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the returned render-target surface for this device.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL if one of the arguments is invalid, or D3DERR_NOTFOUND if there's no render target available for the given index.  </returns>
        /// <unmanaged>HRESULT GetRenderTarget([None] int RenderTargetIndex,[Out] IDirect3DSurface9** ppRenderTarget)</unmanaged>
        public SlimDX2.Result GetRenderTarget(int renderTargetIndex, out SlimDX2.Direct3D9.Surface ppRenderTarget) {
            unsafe {
                IntPtr ppRenderTarget_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 38 * 4, renderTargetIndex, &ppRenderTarget_);
                ppRenderTarget = (ppRenderTarget_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(ppRenderTarget_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the depth stencil surface.	
        /// </summary>	
        /// <remarks>	
        ///  Restrictions for using this method include the following:  The multisample type must be the same for the render target and the depth stencil surface. The formats must be compatible for the render target and the depth stencil surface. See <see cref="SlimDX2.Direct3D9.Direct3D9.CheckDepthStencilMatch"/>. The size of the depth stencil surface must be greater than or equal to the size of the render target.  These restrictions are validated only when using the debug runtime when any of the <see cref="SlimDX2.Direct3D9.Device"/> Draw methods are called. Cube textures differ from other surfaces in that they are collections of surfaces. To call IDirect3DDevice9::SetDepthStencilSurface with a cube texture, you must select an individual face using <see cref="SlimDX2.Direct3D9.CubeTexture.GetCubeMapSurface"/> and pass the resulting surface to IDirect3DDevice9::SetDepthStencilSurface.  	
        /// </remarks>	
        /// <param name="pNewZStencil"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface representing the depth stencil surface. Setting this to NULL disables the depth stencil operation. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If pZStencilSurface is other than NULL, the return value is D3DERR_INVALIDCALL when the stencil surface is invalid.  </returns>
        /// <unmanaged>HRESULT SetDepthStencilSurface([None] IDirect3DSurface9* pNewZStencil)</unmanaged>
        internal SlimDX2.Result SetDepthStencilSurface(SlimDX2.Direct3D9.Surface pNewZStencil) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 39 * 4, (void*)((pNewZStencil == null)?IntPtr.Zero:pNewZStencil.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the depth-stencil surface owned by the Direct3DDevice object.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DSurface9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="ppZStencilSurface"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the returned depth-stencil surface.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK.If the device doesn't have a depth stencil buffer associated with it, the return value will be D3DERR_NOTFOUND. Otherwise, if the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetDepthStencilSurface([Out] IDirect3DSurface9** ppZStencilSurface)</unmanaged>
        internal SlimDX2.Result GetDepthStencilSurface(out SlimDX2.Direct3D9.Surface ppZStencilSurface) {
            unsafe {
                IntPtr ppZStencilSurface_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 40 * 4, &ppZStencilSurface_);
                ppZStencilSurface = (ppZStencilSurface_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(ppZStencilSurface_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Begins a scene. 	
        /// </summary>	
        /// <remarks>	
        ///  Applications must call IDirect3DDevice9::BeginScene before performing any rendering and must call <see cref="SlimDX2.Direct3D9.Device.EndScene"/> when rendering is complete and before calling IDirect3DDevice9::BeginScene again. If IDirect3DDevice9::BeginScene fails, the device was unable to begin the scene, and there is no need to  call <see cref="SlimDX2.Direct3D9.Device.EndScene"/>. In fact, calls to IDirect3DDevice9::EndScene will fail if the  previous IDirect3DDevice9::BeginScene failed. This applies to any application that creates multiple swap chains. There should be one IDirect3DDevice9::BeginScene/<see cref="SlimDX2.Direct3D9.Device.EndScene"/> pair between any successive calls to  present (either <see cref="SlimDX2.Direct3D9.Device.Present"/> or <see cref="SlimDX2.Direct3D9.SwapChain.Present"/>). IDirect3DDevice9::BeginScene should  be called once before any rendering is performed, and IDirect3DDevice9::EndScene should be called once after all rendering for a frame has been submitted to the runtime. Multiple non-nested IDirect3DDevice9::BeginScene/IDirect3DDevice9::EndScene pairs between calls to present are legal, but having more than one pair may incur a performance hit. To enable maximal parallelism between the CPU and the graphics accelerator, it is advantageous to  call IDirect3DDevice9::EndScene as far ahead of calling present as possible. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. The method will fail with D3DERR_INVALIDCALL if IDirect3DDevice9::BeginScene is called  while already in a IDirect3DDevice9::BeginScene/<see cref="SlimDX2.Direct3D9.Device.EndScene"/> pair. This happens only  when IDirect3DDevice9::BeginScene is called twice without first calling IDirect3DDevice9::EndScene. </returns>
        /// <unmanaged>HRESULT BeginScene()</unmanaged>
        public SlimDX2.Result BeginScene() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 41 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Ends a scene that was begun by calling <see cref="SlimDX2.Direct3D9.Device.BeginScene"/>.	
        /// </summary>	
        /// <remarks>	
        ///  When this method succeeds, the scene has been queued up for rendering by the driver. This is not a synchronous method, so the scene is not guaranteed to have completed rendering when this method returns. Applications must call <see cref="SlimDX2.Direct3D9.Device.BeginScene"/> before performing any rendering and must call IDirect3DDevice9::EndScene when rendering is complete and before calling IDirect3DDevice9::BeginScene again. If <see cref="SlimDX2.Direct3D9.Device.BeginScene"/> fails, the device was unable to begin the scene, and there is no need to call IDirect3DDevice9::EndScene. In fact, calls to  IDirect3DDevice9::EndScene will fail if the previous IDirect3DDevice9::BeginScene failed. This applies to any application that creates multiple swap chains. There should be at most one <see cref="SlimDX2.Direct3D9.Device.BeginScene"/>/IDirect3DDevice9::EndScene pair between any successive calls to present (either <see cref="SlimDX2.Direct3D9.Device.Present"/> or <see cref="SlimDX2.Direct3D9.SwapChain.Present"/>). IDirect3DDevice9::BeginScene should be called once before any rendering is performed, and IDirect3DDevice9::EndScene should be called once after all rendering for a frame has been submitted to the runtime. To enable maximal parallelism between the CPU and the graphics accelerator, it is advantageous to call IDirect3DDevice9::EndScene as far ahead of calling present as possible. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. The method will fail with D3DERR_INVALIDCALL if <see cref="SlimDX2.Direct3D9.Device.BeginScene"/> is called while already in a IDirect3DDevice9::BeginScene/IDirect3DDevice9::EndScene pair. This happens only when IDirect3DDevice9::BeginScene is called twice without first calling IDirect3DDevice9::EndScene. </returns>
        /// <unmanaged>HRESULT EndScene()</unmanaged>
        public SlimDX2.Result EndScene() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 42 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Clears one or more surfaces such as a render target, {{multiple render targets}}, a stencil buffer, and a depth buffer.	
        /// </summary>	
        /// <remarks>	
        ///  Use this method to clear a surface including: a render target, all render targets in an MRT, a stencil buffer, or a depth buffer. Flags determines how many surfaces are cleared. Use pRects to clear a subset of a surface defined by an array of rectangles. IDirect3DDevice9::Clear will fail if you:  Try to clear either the depth buffer or the stencil buffer of a render target that does not have an attached depth buffer. Try to clear the stencil buffer when the depth buffer does not contain stencil data.  	
        /// </remarks>	
        /// <param name="count"> Number of rectangles in the array at pRects. Must be set to 0 if pRects is NULL. May not be 0 if pRects is a valid pointer. </param>
        /// <param name="pRects"> Pointer to an array of <see cref="System.Drawing.Size"/> structures that describe the rectangles to clear. Set a rectangle to the dimensions of the rendering target to clear the entire surface. Each rectangle uses screen coordinates that correspond to points on the render target. Coordinates are clipped to the bounds of the viewport rectangle. To indicate that the entire viewport rectangle is to be cleared, set this parameter to NULL and Count to 0. </param>
        /// <param name="flags"> Combination of one or more {{D3DCLEAR}} flags that specify the surface(s) that will be cleared. </param>
        /// <param name="color"> Clear a render target to this ARGB color. </param>
        /// <param name="z"> Clear the depth buffer to this new z value which ranges from 0 to 1. See remarks. </param>
        /// <param name="stencil"> Clear the stencil buffer to this new value which ranges from 0 to 2n - 1 (n is the bit depth of the stencil buffer). See remarks.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT Clear([None] int Count,[None] const D3DRECT* pRects,[None] int Flags,[None] D3DCOLOR Color,[None] float Z,[None] int Stencil)</unmanaged>
        public SlimDX2.Result Clear(int count, ref System.Drawing.Size pRects, int flags, int color, float z, int stencil) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pRects_ = &pRects)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 43 * 4, count, pRects_, flags, color, z, stencil);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a single device transformation-related state.	
        /// </summary>	
        /// <param name="state"> Device-state variable that is being modified. This parameter can be any member of the <see cref="SlimDX2.Direct3D9.Transformstatetype"/> enumerated type, or the {{D3DTS_WORLDMATRIX}} macro.  </param>
        /// <param name="pMatrix"> Pointer to a <see cref="SlimMath.Matrix"/> structure that modifies the current transformation.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one of the arguments is invalid.  </returns>
        /// <unmanaged>HRESULT SetTransform([None] D3DTRANSFORMSTATETYPE State,[None] const D3DMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result SetTransform(SlimDX2.Direct3D9.Transformstatetype state, ref SlimMath.Matrix pMatrix) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 44 * 4, unchecked((int)state), pMatrix_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a matrix describing a transformation state.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other flag values in {{D3DCREATE}}.  	
        /// </remarks>	
        /// <param name="state"> Device state variable that is being modified. This parameter can be any member of the <see cref="SlimDX2.Direct3D9.Transformstatetype"/> enumerated type, or the {{D3DTS_WORLDMATRIX}} macro.  </param>
        /// <param name="pMatrix"> Pointer to a  <see cref="SlimMath.Matrix"/> structure, describing the returned transformation state.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL if one of the arguments is invalid.  </returns>
        /// <unmanaged>HRESULT GetTransform([None] D3DTRANSFORMSTATETYPE State,[Out] D3DMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result GetTransform(SlimDX2.Direct3D9.Transformstatetype state, out SlimMath.Matrix pMatrix) {
            unsafe {
                pMatrix = new SlimMath.Matrix();
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 45 * 4, unchecked((int)state), pMatrix_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Multiplies a device's world, view, or projection matrices by a specified matrix. 	
        /// </summary>	
        /// <remarks>	
        ///  The multiplication order is pMatrix times State. An application might use the IDirect3DDevice9::MultiplyTransform method to work with hierarchies of transformations. For example, the geometry and transformations describing an arm might be arranged in the following hierarchy. 	
        /// <code> shoulder_transformation upper_arm geometry elbow transformation lower_arm geometry wrist transformation hand geometry </code>	
        /// 	
        ///  An application might use the following series of calls to render this hierarchy. Not all the parameters are shown in this pseudocode.  	
        /// <code> IDirect3DDevice9::SetTransform(D3DTS_WORLDMATRIX(0),  shoulder_transform)	
        /// IDirect3DDevice9::DrawPrimitive(upper_arm)	
        /// IDirect3DDevice9::MultiplyTransform(D3DTS_WORLDMATRIX(0),  elbow_transform)	
        /// IDirect3DDevice9::DrawPrimitive(lower_arm)	
        /// IDirect3DDevice9::MultiplyTransform(D3DTS_WORLDMATRIX(0),  wrist_transform)	
        /// IDirect3DDevice9::DrawPrimitive(hand) </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="arg0"> Member of the <see cref="SlimDX2.Direct3D9.Transformstatetype"/> enumerated type, or the {{D3DTS_WORLDMATRIX}} macro that identifies which device matrix is to be modified. The most common setting, D3DTS_WORLDMATRIX(0), modifies the world matrix, but you can specify that the method modify the view or projection matrices, if needed.  </param>
        /// <param name="arg1"> Pointer to a <see cref="SlimMath.Matrix"/> structure that modifies the current transformation.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL if one of the arguments is invalid.  </returns>
        /// <unmanaged>HRESULT MultiplyTransform([None] D3DTRANSFORMSTATETYPE arg0,[None] const D3DMATRIX* arg1)</unmanaged>
        public SlimDX2.Result MultiplyTransform(SlimDX2.Direct3D9.Transformstatetype arg0, ref SlimMath.Matrix arg1) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* arg1_ = &arg1)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 46 * 4, unchecked((int)arg0), arg1_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the viewport parameters for the device.	
        /// </summary>	
        /// <remarks>	
        ///  Direct3D sets the following default values for the viewport.  	
        /// <code> D3DVIEWPORT9 vp;	
        /// vp.X      = 0;	
        /// vp.Y      = 0;	
        /// vp.Width  = RenderTarget.Width;	
        /// vp.Height = RenderTarget.Height;	
        /// vp.MinZ   = 0.0f;	
        /// vp.MaxZ   = 1.0f; </code>	
        /// 	
        ///  IDirect3DDevice9::SetViewport can be used to draw on part of the screen. Make sure to call it before any geometry is drawn so the viewport settings will take effect. To draw multiple views within a scene, repeat the IDirect3DDevice9::SetViewport and draw geometry sequence for each view. 	
        /// </remarks>	
        /// <param name="pViewport"> Pointer to a <see cref="SlimDX2.Direct3D9.Viewport9"/> structure, specifying the viewport parameters to set.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, it will return D3DERR_INVALIDCALL. This will happen if pViewport is invalid, or if pViewport describes a region that cannot exist within the render target surface. </returns>
        /// <unmanaged>HRESULT SetViewport([None] const D3DVIEWPORT9* pViewport)</unmanaged>
        internal SlimDX2.Result SetViewport(ref SlimDX2.Direct3D9.Viewport9 pViewport) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pViewport_ = &pViewport)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 47 * 4, pViewport_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the viewport parameters currently set for the device.	
        /// </summary>	
        /// <remarks>	
        ///  Typically, methods that return state will not work on a device that is created using D3DCREATE_PUREDEVICE. This method however, will work even on a pure device. 	
        /// </remarks>	
        /// <param name="pViewport"> Pointer to a <see cref="SlimDX2.Direct3D9.Viewport9"/> structure, representing the returned viewport parameters.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the pViewport parameter is invalid.  </returns>
        /// <unmanaged>HRESULT GetViewport([Out] D3DVIEWPORT9* pViewport)</unmanaged>
        internal SlimDX2.Result GetViewport(out SlimDX2.Direct3D9.Viewport9 pViewport) {
            unsafe {
                pViewport = new SlimDX2.Direct3D9.Viewport9();
                SlimDX2.Result __result__;
                fixed (void* pViewport_ = &pViewport)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 48 * 4, pViewport_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the material properties for the device.	
        /// </summary>	
        /// <param name="pMaterial"> Pointer to a <see cref="SlimDX2.Direct3D9.Material9"/> structure, describing the material properties to set.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL if the pMaterial parameter is invalid.  </returns>
        /// <unmanaged>HRESULT SetMaterial([None] const D3DMATERIAL9* pMaterial)</unmanaged>
        internal SlimDX2.Result SetMaterial(ref SlimDX2.Direct3D9.Material9 pMaterial) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pMaterial_ = &pMaterial)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 49 * 4, pMaterial_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the current material properties for the device.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other values in {{D3DCREATE}}.  	
        /// </remarks>	
        /// <param name="pMaterial"> Pointer to a <see cref="SlimDX2.Direct3D9.Material9"/> structure to fill with the currently set material properties.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL if the pMaterial parameter is invalid.  </returns>
        /// <unmanaged>HRESULT GetMaterial([Out] D3DMATERIAL9* pMaterial)</unmanaged>
        internal SlimDX2.Result GetMaterial(out SlimDX2.Direct3D9.Material9 pMaterial) {
            unsafe {
                pMaterial = new SlimDX2.Direct3D9.Material9();
                SlimDX2.Result __result__;
                fixed (void* pMaterial_ = &pMaterial)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 50 * 4, pMaterial_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Assigns a set of lighting properties for this device.	
        /// </summary>	
        /// <remarks>	
        ///  Set light properties by preparing a <see cref="SlimDX2.Direct3D9.Light9"/> structure and then calling the IDirect3DDevice9::SetLight method. The  IDirect3DDevice9::SetLight method accepts the index at which the device should place the set of light properties to its internal list of light properties, and the address of a prepared D3DLIGHT9 structure that defines those properties. You can call IDirect3DDevice9::SetLight with new information as needed to update the light's illumination properties. The system allocates memory to accommodate a set of lighting properties each time you call the IDirect3DDevice9::SetLight method with an index that has never been assigned properties. Applications can set a number of lights, with only a subset of the assigned lights enabled at a time. Check the MaxActiveLights member of the <see cref="SlimDX2.Direct3D9.Caps9"/> structure when you retrieve device capabilities to determine the maximum number of active lights supported by that device. If you no longer need a light, you can disable it or overwrite it with a new set of light properties. The following example prepares and sets properties for a white point-light whose emitted light will not attenuate over distance. 	
        /// <code> // Assume d3dDevice is a valid pointer to an IDirect3DDevice9 interface.	
        /// D3DLight9 d3dLight;	
        /// HRESULT   hr; // Initialize the structure.	
        /// ZeroMemory(&amp;D3dLight, sizeof(d3dLight)); // Set up a white point light.	
        /// d3dLight.Type = D3DLIGHT_POINT;	
        /// d3dLight.Diffuse.r  = 1.0f;	
        /// d3dLight.Diffuse.g  = 1.0f;	
        /// d3dLight.Diffuse.b  = 1.0f;	
        /// d3dLight.Ambient.r  = 1.0f;	
        /// d3dLight.Ambient.g  = 1.0f;	
        /// d3dLight.Ambient.b  = 1.0f;	
        /// d3dLight.Specular.r = 1.0f;	
        /// d3dLight.Specular.g = 1.0f;	
        /// d3dLight.Specular.b = 1.0f; // Position it high in the scene and behind the user.	
        /// // Remember, these coordinates are in world space, so	
        /// // the user could be anywhere in world space, too. 	
        /// // For the purposes of this example, assume the user	
        /// // is at the origin of world space.	
        /// d3dLight.Position.x = 0.0f;	
        /// d3dLight.Position.y = 1000.0f;	
        /// d3dLight.Position.z = -100.0f; // Don't attenuate.	
        /// d3dLight.Attenuation0 = 1.0f; 	
        /// d3dLight.Range        = 1000.0f; // Set the property information for the first light.	
        /// hr = d3dDevice-&gt;SetLight(0, &amp;d3dLight);	
        /// if (SUCCEEDED(hr)) // Handle Success	
        /// else // Handle failure </code>	
        /// 	
        ///  Enable a light source by calling the <see cref="SlimDX2.Direct3D9.Device.LightEnable"/> method for the device. 	
        /// </remarks>	
        /// <param name="index"> Zero-based index of the set of lighting properties to set. If a set of lighting properties exists at this index, it is overwritten by the new properties specified in pLight.  </param>
        /// <param name="arg1"> Pointer to a <see cref="SlimDX2.Direct3D9.Light9"/> structure, containing the lighting parameters to set.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT SetLight([None] int Index,[None] const D3DLIGHT9* arg1)</unmanaged>
        public SlimDX2.Result SetLight(int index, ref SlimDX2.Direct3D9.Light9 arg1) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* arg1_ = &arg1)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 51 * 4, index, arg1_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a set of lighting properties that this device uses.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other values in {{D3DCREATE}}. Retrieve all the properties for an existing light source by calling the IDirect3DDevice9::GetLight method for the device. When calling the IDirect3DDevice9::GetLight method, pass the zero-based index of the light source for which the properties will be retrieved as the first parameter, and supply the address of a <see cref="SlimDX2.Direct3D9.Light9"/> structure as the second parameter. The device fills the D3DLIGHT9 structure to describe the lighting properties it uses for the light source at that index. 	
        /// <code> // Assume d3dDevice is a valid pointer to an IDirect3DDevice9 interface.	
        /// HRESULT hr;	
        /// D3DLight9 light; // Get the property information for the first light.	
        /// hr = pd3dDevice-&gt;GetLight(0, &amp;light);	
        /// if (SUCCEEDED(hr)) // Handle Success	
        /// else // Handle failure </code>	
        /// 	
        ///  If you supply an index outside the range of the light sources assigned in the device, the IDirect3DDevice9::GetLight method fails, returning D3DERR_INVALIDCALL. When you assign a set of light properties for a light source in a scene, the light source can be activated by calling the <see cref="SlimDX2.Direct3D9.Device.LightEnable"/> method for the device. New light sources are disabled by default. The IDirect3DDevice9::LightEnable method accepts two parameters. Set the first parameter to the zero-based index of the light source to be affected by the method, and set the second parameter to TRUE to enable the light or FALSE to disable it. The following code example illustrates the use of this method by enabling the first light source in the device's list of light source properties. 	
        /// <code> // Assume d3dDevice is a valid pointer to an IDirect3DDevice9 interface.	
        /// HRESULT hr; hr = pd3dDevice-&gt;LightEnable(0, TRUE);	
        /// if (SUCCEEDED(hr)) // Handle Success	
        /// else // Handle failure </code>	
        /// 	
        ///  Check the MaxActiveLights member of the <see cref="SlimDX2.Direct3D9.Caps9"/> structure when you retrieve device capabilities to determine the maximum number of active lights supported by that device. If you enable or disable a light that has no properties that are set with <see cref="SlimDX2.Direct3D9.Device.SetLight"/>, the <see cref="SlimDX2.Direct3D9.Device.LightEnable"/> method creates a light source with the properties listed in following table and enables or disables it. 	
        /// </remarks>	
        /// <param name="index"> Zero-based index of the lighting property set to retrieve. This method will fail if a lighting property has not been set for this index by calling the <see cref="SlimDX2.Direct3D9.Device.SetLight"/> method.  </param>
        /// <param name="arg1"> Pointer to a <see cref="SlimDX2.Direct3D9.Light9"/> structure that is filled with the retrieved lighting-parameter set.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetLight([None] int Index,[Out] D3DLIGHT9* arg1)</unmanaged>
        public SlimDX2.Result GetLight(int index, out SlimDX2.Direct3D9.Light9 arg1) {
            unsafe {
                arg1 = new SlimDX2.Direct3D9.Light9();
                SlimDX2.Result __result__;
                fixed (void* arg1_ = &arg1)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 52 * 4, index, arg1_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Enables or disables a set of lighting parameters within a device.	
        /// </summary>	
        /// <remarks>	
        ///  If a value for LightIndex is outside the range of the light property sets assigned within the device, the IDirect3DDevice9::LightEnable method creates a light source represented by a <see cref="SlimDX2.Direct3D9.Light9"/> structure with the following properties and sets its enabled state to the value specified in bEnable.  MemberDefault  Type D3DLIGHT_DIRECTIONAL  Diffuse (R:1, G:1, B:1, A:0)  Specular (R:0, G:0, B:0, A:0)  Ambient (R:0, G:0, B:0, A:0)  Position (0, 0, 0)  Direction (0, 0, 1)  Range 0  Falloff 0  Attenuation0 0  Attenuation1 0  Attenuation2 0  Theta 0  Phi 0    	
        /// </remarks>	
        /// <param name="index"> Zero-based index of the set of lighting parameters that are the target of this method.  </param>
        /// <param name="enable"> Value that indicates if the set of lighting parameters are being enabled or disabled. Set this parameter to TRUE to enable lighting with the parameters at the specified index, or FALSE to disable it.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT LightEnable([None] int Index,[None] BOOL Enable)</unmanaged>
        public SlimDX2.Result LightEnable(int index, bool enable) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 53 * 4, index, (enable?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the activity status - enabled or disabled - for a set of lighting parameters within a device.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other values in {{D3DCREATE}}.  	
        /// </remarks>	
        /// <param name="index"> Zero-based index of the set of lighting parameters that are the target of this method.  </param>
        /// <param name="pEnable"> Pointer to a variable to fill with the status of the specified lighting parameters. After the call, a nonzero value at this address indicates that the specified lighting parameters are enabled; a value of 0 indicates that they are disabled.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetLightEnable([None] int Index,[Out] BOOL* pEnable)</unmanaged>
        public SlimDX2.Result GetLightEnable(int index, out bool pEnable) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pEnable_ = &pEnable)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 54 * 4, index, pEnable_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the coefficients of a user-defined clipping plane for the device.	
        /// </summary>	
        /// <remarks>	
        ///  The coefficients that this method sets take the form of the general plane equation. If the values in the array at pPlane were labeled A, B, C, and D in the order that they appear in the array, they would fit into the general plane equation so that Ax + By + Cz + Dw = 0. A point with homogeneous coordinates (x, y, z, w) is visible in the half space of the plane if Ax + By + Cz + Dw &gt;= 0. Points that exist behind the clipping plane are clipped from the scene. When the fixed function pipeline is used the plane equations are assumed to be in world space. When the programmable pipeline is used the plane equations are assumed to be in the clipping space (the same space as output vertices). This method does not enable the clipping plane equation being set. To enable a clipping plane, set the corresponding bit in the DWORD value applied to the D3DRS_CLIPPLANEENABLE render state. 	
        /// </remarks>	
        /// <param name="index"> Index of the clipping plane for which the plane equation coefficients are to be set.  </param>
        /// <param name="pPlane"> Pointer to an address of a four-element array of values that represent the clipping plane coefficients to be set, in the form of the general plane equation. See Remarks.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value is D3DERR_INVALIDCALL. This error indicates that the value in Index exceeds the maximum clipping plane index supported by the device or that the array at pPlane is not large enough to contain four floating-point values.  </returns>
        /// <unmanaged>HRESULT SetClipPlane([None] int Index,[None] const float* pPlane)</unmanaged>
        public SlimDX2.Result SetClipPlane(int index, ref float pPlane) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pPlane_ = &pPlane)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 55 * 4, index, pPlane_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the coefficients of a user-defined clipping plane for the device.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other values in {{D3DCREATE}}."  The coefficients that this method reports take the form of the general plane equation. If the values in the array at pPlane were labeled A, B, C, and D in the order that they appear in the array, they would fit into the general plane equation so that Ax + By + Cz + Dw = 0. A point with homogeneous coordinates (x, y, z, w) is visible in the half space of the plane if Ax + By + Cz + Dw &gt;= 0. Points that exist on or behind the clipping plane are clipped from the scene. The plane equation used by this method exists in world space and is set by a previous call to the <see cref="SlimDX2.Direct3D9.Device.SetClipPlane"/> method. 	
        /// </remarks>	
        /// <param name="index"> Index of the clipping plane for which the plane equation coefficients are retrieved.  </param>
        /// <param name="pPlane"> Pointer to a four-element array of values that represent the coefficients of the clipping plane in the form of the general plane equation. See Remarks.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value is D3DERR_INVALIDCALL. This error indicates that the value in Index exceeds the maximum clipping plane index supported by the device, or that the array at pPlane is not large enough to contain four floating-point values. </returns>
        /// <unmanaged>HRESULT GetClipPlane([None] int Index,[Out] float* pPlane)</unmanaged>
        public SlimDX2.Result GetClipPlane(int index, out float pPlane) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pPlane_ = &pPlane)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 56 * 4, index, pPlane_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a single device render-state parameter.	
        /// </summary>	
        /// <param name="state"> Device state variable that is being modified. This parameter can be any member of the <see cref="SlimDX2.Direct3D9.Renderstatetype"/> enumerated type.  </param>
        /// <param name="value"> New value for the device render state to be set. The meaning of this parameter is dependent on the value specified for State. For example, if State were D3DRS_SHADEMODE, the second parameter would be one member of the <see cref="SlimDX2.Direct3D9.Shademode"/> enumerated type.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one of the arguments is invalid.  </returns>
        /// <unmanaged>HRESULT SetRenderState([None] D3DRENDERSTATETYPE State,[None] int Value)</unmanaged>
        public SlimDX2.Result SetRenderState(SlimDX2.Direct3D9.Renderstatetype state, int value) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 57 * 4, unchecked((int)state), value);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a render-state value for a device.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other values in {{D3DCREATE}}."  	
        /// </remarks>	
        /// <param name="state"> Device state variable that is being queried. This parameter can be any member of the <see cref="SlimDX2.Direct3D9.Renderstatetype"/> enumerated type.  </param>
        /// <param name="pValue"> Pointer to a variable that receives the value of the queried render state variable when the method returns.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL if one of the arguments is invalid.  </returns>
        /// <unmanaged>HRESULT GetRenderState([None] D3DRENDERSTATETYPE State,[Out] int* pValue)</unmanaged>
        public SlimDX2.Result GetRenderState(SlimDX2.Direct3D9.Renderstatetype state, out int pValue) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pValue_ = &pValue)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 58 * 4, unchecked((int)state), pValue_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a new state block that contains the values for all device states, vertex-related states, or pixel-related states.	
        /// </summary>	
        /// <remarks>	
        ///  Vertex-related device states typically refer to those states that affect how the system processes vertices. Pixel-related states generally refer to device states that affect how the system processes pixel or depth-buffer data during rasterization. Some states are contained in both groups.    Differences between Direct3D 9 and Direct3D 10: In Direct3D 9, a state block contains state data, for the states it was requested to capture, when the object is created. To change the value of the state block, call <see cref="SlimDX2.Direct3D9.StateBlock.Capture"/> or <see cref="SlimDX2.Direct3D9.Device.BeginStateBlock"/>/<see cref="SlimDX2.Direct3D9.Device.EndStateBlock"/>. There is no state saved when a state block object is created in Direct3D 10.     	
        /// </remarks>	
        /// <param name="type"> Type of state data that the method should capture. This parameter can be set to a value defined in the <see cref="SlimDX2.Direct3D9.Stateblocktype"/> enumerated type.  </param>
        /// <param name="ppSB"> Pointer to a state block interface. See <see cref="SlimDX2.Direct3D9.StateBlock"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT CreateStateBlock([None] D3DSTATEBLOCKTYPE Type,[None] IDirect3DStateBlock9** ppSB)</unmanaged>
        public SlimDX2.Result CreateStateBlock(SlimDX2.Direct3D9.Stateblocktype type, out SlimDX2.Direct3D9.StateBlock ppSB) {
            unsafe {
                IntPtr ppSB_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 59 * 4, unchecked((int)type), &ppSB_);
                ppSB = (ppSB_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.StateBlock(ppSB_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Signals Direct3D to begin recording a device-state block.	
        /// </summary>	
        /// <remarks>	
        ///  Applications can ensure that all recorded states are valid by calling the <see cref="SlimDX2.Direct3D9.Device.ValidateDevice"/> method prior to calling this method. The following methods can be recorded in a state block, after calling IDirect3DDevice9::BeginStateBlock and before <see cref="SlimDX2.Direct3D9.Device.EndStateBlock"/>.    <see cref="SlimDX2.Direct3D9.Device.LightEnable"/>   <see cref="SlimDX2.Direct3D9.Device.SetClipPlane"/>   <see cref="SlimDX2.Direct3D9.Device.SetCurrentTexturePalette"/>   <see cref="SlimDX2.Direct3D9.Device.SetFVF"/>   <see cref="SlimDX2.Direct3D9.Device.SetIndices"/>   <see cref="SlimDX2.Direct3D9.Device.SetLight"/>   <see cref="SlimDX2.Direct3D9.Device.SetMaterial"/>   <see cref="SlimDX2.Direct3D9.Device.SetNPatchMode"/>   <see cref="SlimDX2.Direct3D9.Device.SetPixelShader"/>   <see cref="SlimDX2.Direct3D9.Device.SetPixelShaderConstantB"/>   <see cref="SlimDX2.Direct3D9.Device.SetPixelShaderConstantF"/>   <see cref="SlimDX2.Direct3D9.Device.SetPixelShaderConstantI"/>   <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/>   <see cref="SlimDX2.Direct3D9.Device.SetSamplerState"/>   <see cref="SlimDX2.Direct3D9.Device.SetScissorRect"/>   <see cref="SlimDX2.Direct3D9.Device.SetStreamSource"/>   <see cref="SlimDX2.Direct3D9.Device.SetStreamSourceFreq"/>   <see cref="SlimDX2.Direct3D9.Device.SetTexture"/>   <see cref="SlimDX2.Direct3D9.Device.SetTextureStageState"/>   <see cref="SlimDX2.Direct3D9.Device.SetTransform"/>   <see cref="SlimDX2.Direct3D9.Device.SetViewport"/>   <see cref="SlimDX2.Direct3D9.Device.SetVertexDeclaration"/>   <see cref="SlimDX2.Direct3D9.Device.SetVertexShader"/>   <see cref="SlimDX2.Direct3D9.Device.SetVertexShaderConstantB"/>   <see cref="SlimDX2.Direct3D9.Device.SetVertexShaderConstantF"/>   <see cref="SlimDX2.Direct3D9.Device.SetVertexShaderConstantI"/>   The ordering of state changes in a state block is not guaranteed. If the same state is specified multiple times in a state block, only the last value is used. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT BeginStateBlock()</unmanaged>
        public SlimDX2.Result BeginStateBlock() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 60 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Signals Direct3D to stop recording a device-state block and retrieve a pointer to the state block interface.	
        /// </summary>	
        /// <param name="ppSB"> Pointer to a state block interface. See <see cref="SlimDX2.Direct3D9.StateBlock"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT EndStateBlock([None] IDirect3DStateBlock9** ppSB)</unmanaged>
        public SlimDX2.Result EndStateBlock(out SlimDX2.Direct3D9.StateBlock ppSB) {
            unsafe {
                IntPtr ppSB_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 61 * 4, &ppSB_);
                ppSB = (ppSB_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.StateBlock(ppSB_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the clip status.	
        /// </summary>	
        /// <remarks>	
        ///  Clip status is used during software vertex processing. Therefore, this method is not supported on pure or nonpure hardware processing devices. For more information about pure devices, see {{D3DCREATE}}. When clipping is enabled during vertex processing (by <see cref="SlimDX2.Direct3D9.Device.ProcessVertices"/>, <see cref="SlimDX2.Direct3D9.Device.DrawPrimitive"/>, or other drawing functions), Direct3D computes a clip code for every vertex. The clip code is a combination of D3DCS_* bits. When a vertex is outside a particular clipping plane, the corresponding bit is set in the clipping code. Direct3D maintains the clip status using <see cref="SlimDX2.Direct3D9.Clipstatus9"/>, which has ClipUnion and ClipIntersection members. ClipUnion is a bitwise "OR" of all vertex clip codes and ClipIntersection is a bitwise "AND" of all vertex clip codes. Initial values are zero for ClipUnion and 0xFFFFFFFF for ClipIntersection. When D3DRS_CLIPPING is set to FALSE, ClipUnion and ClipIntersection are set to zero. Direct3D updates the clip status during drawing calls. To compute clip status for a particular object, set ClipUnion and ClipIntersection to their initial value and continue drawing. Clip status is not updated by <see cref="SlimDX2.Direct3D9.Device.DrawRectPatch"/> and <see cref="SlimDX2.Direct3D9.Device.DrawTriPatch"/> because there is no software emulation for them. 	
        /// </remarks>	
        /// <param name="pClipStatus"> Pointer to a <see cref="SlimDX2.Direct3D9.Clipstatus9"/> structure, describing the clip status settings to be set.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If one of the arguments is invalid, the return value is D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT SetClipStatus([None] const D3DCLIPSTATUS9* pClipStatus)</unmanaged>
        internal SlimDX2.Result SetClipStatus(ref SlimDX2.Direct3D9.Clipstatus9 pClipStatus) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pClipStatus_ = &pClipStatus)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 62 * 4, pClipStatus_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the clip status.	
        /// </summary>	
        /// <remarks>	
        ///  When clipping is enabled during vertex processing (by <see cref="SlimDX2.Direct3D9.Device.ProcessVertices"/>, <see cref="SlimDX2.Direct3D9.Device.DrawPrimitive"/>, or other drawing functions), Direct3D computes a clip code for every vertex. The clip code is a combination of D3DCS_* bits. When a vertex is outside a particular clipping plane, the corresponding bit is set in the clipping code. Direct3D maintains the clip status using <see cref="SlimDX2.Direct3D9.Clipstatus9"/>, which has ClipUnion and ClipIntersection members. ClipUnion is a bitwise "OR" of all vertex clip codes and ClipIntersection is a bitwise "AND" of all vertex clip codes. Initial values are zero for ClipUnion and 0xFFFFFFFF for ClipIntersection. When D3DRS_CLIPPING is set to FALSE, ClipUnion and ClipIntersection are set to zero. Direct3D updates the clip status during drawing calls. To compute clip status for a particular object, set ClipUnion and ClipIntersection to their initial value and continue drawing. Clip status is not updated by <see cref="SlimDX2.Direct3D9.Device.DrawRectPatch"/> and <see cref="SlimDX2.Direct3D9.Device.DrawTriPatch"/> because there is no software emulation for them. Clip status is used during software vertex processing. Therefore, this method is not supported on pure or nonpure hardware processing devices. For more information about pure devices, see {{D3DCREATE}}. 	
        /// </remarks>	
        /// <param name="pClipStatus">  Pointer to a <see cref="SlimDX2.Direct3D9.Clipstatus9"/> structure that describes the clip status.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the argument is invalid. </returns>
        /// <unmanaged>HRESULT GetClipStatus([Out] D3DCLIPSTATUS9* pClipStatus)</unmanaged>
        internal SlimDX2.Result GetClipStatus(out SlimDX2.Direct3D9.Clipstatus9 pClipStatus) {
            unsafe {
                pClipStatus = new SlimDX2.Direct3D9.Clipstatus9();
                SlimDX2.Result __result__;
                fixed (void* pClipStatus_ = &pClipStatus)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 63 * 4, pClipStatus_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a texture assigned to a stage for a device.	
        /// </summary>	
        /// <remarks>	
        ///  Typically, methods that return state will not work on a device that is created using D3DCREATE_PUREDEVICE. This method however, will work even on a pure device because it returns an interface. Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Texture"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DTexture9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="stage"> Stage identifier of the texture to retrieve. Stage identifiers are zero-based. </param>
        /// <param name="ppTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.BaseTexture"/> interface, representing the returned texture.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetTexture([None] int Stage,[Out] IDirect3DBaseTexture9** ppTexture)</unmanaged>
        public SlimDX2.Result GetTexture(int stage, out SlimDX2.Direct3D9.BaseTexture ppTexture) {
            unsafe {
                IntPtr ppTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 64 * 4, stage, &ppTexture_);
                ppTexture = (ppTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.BaseTexture(ppTexture_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Assigns a texture to a stage for a device.	
        /// </summary>	
        /// <remarks>	
        ///  SetTexture is not allowed if the texture is created with a pool type of D3DPOOL_SCRATCH. SetTexture is not allowed with a pool type of D3DPOOL_SYSTEMMEM texture unless DevCaps is set with D3DDEVCAPS_TEXTURESYSTEMMEMORY. 	
        /// </remarks>	
        /// <param name="stage"> Zero based sampler number.  Textures are bound to samplers; samplers define sampling state such as the filtering mode and the address wrapping mode. Textures are referenced differently by the programmable and the fixed function pipeline:   Programmable shaders reference textures using the sampler number. The number of samplers available to a programmable shader is dependent on the shader version. For vertex shaders, see {{Sampler (Direct3D 9 asm-vs)}}. For pixel shaders see {{Sampler (Direct3D 9 asm-ps)}}. The fixed function pipeline on the other hand, references textures by texture stage number. The maximum number of samplers is determined from two caps: MaxSimultaneousTextures and MaxTextureBlendStages of the <see cref="SlimDX2.Direct3D9.Caps9"/> structure.  There are two other special cases for stage/sampler numbers.  A special number called D3DDMAPSAMPLER is used for {{Displacement Mapping (Direct3D 9)}}. A programmable vertex shader uses a special number defined by a {{D3DVERTEXTEXTURESAMPLER}} when accessing {{Vertex Textures in vs_3_0 (DirectX HLSL)}}.  </param>
        /// <param name="pTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.BaseTexture"/> interface, representing the texture being set.   </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT SetTexture([None] int Stage,[None] IDirect3DBaseTexture9* pTexture)</unmanaged>
        public SlimDX2.Result SetTexture(int stage, SlimDX2.Direct3D9.BaseTexture pTexture) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 65 * 4, stage, (void*)((pTexture == null)?IntPtr.Zero:pTexture.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a state value for an assigned texture.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other flag values in {{D3DCREATE}}."  	
        /// </remarks>	
        /// <param name="stage"> Stage identifier of the texture for which the state is retrieved. Stage identifiers are zero-based. Devices can have up to eight set textures, so the maximum value allowed for Stage is 7.  </param>
        /// <param name="type"> Texture state to retrieve. This parameter can be any member of the <see cref="SlimDX2.Direct3D9.Texturestagestatetype"/> enumerated type.  </param>
        /// <param name="pValue"> Pointer a variable to fill with the retrieved state value. The meaning of the retrieved value is determined by the Type parameter.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetTextureStageState([None] int Stage,[None] D3DTEXTURESTAGESTATETYPE Type,[Out] int* pValue)</unmanaged>
        public SlimDX2.Result GetTextureStageState(int stage, SlimDX2.Direct3D9.Texturestagestatetype type, out int pValue) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pValue_ = &pValue)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 66 * 4, stage, unchecked((int)type), pValue_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the state value for the currently assigned texture.	
        /// </summary>	
        /// <param name="stage"> Stage identifier of the texture for which the state value is set. Stage identifiers are zero-based. Devices can have up to eight set textures, so the maximum value allowed for Stage is 7.  </param>
        /// <param name="type"> Texture state to set. This parameter can be any member of the <see cref="SlimDX2.Direct3D9.Texturestagestatetype"/> enumerated type.  </param>
        /// <param name="value"> State value to set. The meaning of this value is determined by the Type parameter.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT SetTextureStageState([None] int Stage,[None] D3DTEXTURESTAGESTATETYPE Type,[None] int Value)</unmanaged>
        public SlimDX2.Result SetTextureStageState(int stage, SlimDX2.Direct3D9.Texturestagestatetype type, int value) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 67 * 4, stage, unchecked((int)type), value);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the sampler state value.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not return device state for a device that is created using D3DCREATE_PUREDEVICE. If you want to use this method, you must create your device with any of the other values in {{D3DCREATE}}."  	
        /// </remarks>	
        /// <param name="sampler"> The sampler stage index. </param>
        /// <param name="type"> This parameter can be any member of the <see cref="SlimDX2.Direct3D9.Samplerstatetype"/> enumerated type.  </param>
        /// <param name="pValue"> State value to get. The meaning of this value is determined by the Type parameter.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetSamplerState([None] int Sampler,[None] D3DSAMPLERSTATETYPE Type,[Out] int* pValue)</unmanaged>
        public SlimDX2.Result GetSamplerState(int sampler, SlimDX2.Direct3D9.Samplerstatetype type, out int pValue) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pValue_ = &pValue)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 68 * 4, sampler, unchecked((int)type), pValue_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the sampler state value.	
        /// </summary>	
        /// <param name="sampler"> The sampler stage index. </param>
        /// <param name="type"> This parameter can be any member of the <see cref="SlimDX2.Direct3D9.Samplerstatetype"/> enumerated type.  </param>
        /// <param name="value"> State value to set. The meaning of this value is determined by the Type parameter.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT SetSamplerState([None] int Sampler,[None] D3DSAMPLERSTATETYPE Type,[None] int Value)</unmanaged>
        public SlimDX2.Result SetSamplerState(int sampler, SlimDX2.Direct3D9.Samplerstatetype type, int value) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 69 * 4, sampler, unchecked((int)type), value);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Reports the device's ability to render the current texture-blending operations and arguments in a single pass.	
        /// </summary>	
        /// <remarks>	
        ///  The IDirect3DDevice9::ValidateDevice method should be used to validate scenarios only when other capabilities are deficient. For example, in a multistage texturing scenario, you could query the MaxTextureBlendStages and MaxSimultaneousTextures members of a <see cref="SlimDX2.Direct3D9.Caps9"/> structure to determine if multistage texturing is possible on the device. Current hardware does not necessarily implement all possible combinations of operations and arguments. You can determine whether a particular blending operation can be performed with given arguments by setting the desired blending operation, and then calling the IDirect3DDevice9::ValidateDevice method.  The IDirect3DDevice9::ValidateDevice method uses the current render states, textures, and texture-stage states to perform validation at the time of the call. Changes to these factors after the call invalidate the previous result, and the method must be called again before rendering a scene. For best performance, call IDirect3DDevice9::ValidateDevice at initialization time; do not use it within a render loop. Using diffuse iterated values, either as an argument or as an operation (D3DTA_DIFFUSED3DTOP_BLENDDIFFUSEALPHA) is rarely supported on current hardware. Most hardware can introduce iterated color data only at the last texture operation stage. Try to specify the texture (D3DTA_TEXTURE) for each stage as the first argument, rather than the second argument. Many cards do not support use of diffuse or scalar values at arbitrary texture stages. Often, these are available only at the first or last texture-blending stage. Many cards do not have a blending unit associated with the first texture that is capable of more than replicating alpha to color channels or inverting the input. Therefore, your application might need to use only the second texture stage, if possible. On such hardware, the first unit is presumed to be in its default state, which has the first color argument set to D3DTA_TEXTURE with the D3DTOP_SELECTARG1 operation. Operations on the output alpha that are more intricate than or substantially different from the color operations are less likely to be supported.  Some hardware does not support simultaneous use of D3DTA_TFACTOR and D3DTA_DIFFUSE. Many cards do not support simultaneous use of multiple textures and mipmapped trilinear filtering. If trilinear filtering has been requested for a texture involved in multitexture blending operations and validation fails, turn off trilinear filtering and revalidate. In this case, you might want to perform multipass rendering instead. 	
        /// </remarks>	
        /// <param name="pNumPasses"> Pointer to a DWORD value to fill with the number of rendering passes needed to complete the desired effect through multipass rendering.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_CONFLICTINGRENDERSTATE, D3DERR_CONFLICTINGTEXTUREFILTER, D3DERR_DEVICELOST, D3DERR_DRIVERINTERNALERROR, D3DERR_TOOMANYOPERATIONS, D3DERR_UNSUPPORTEDALPHAARG, D3DERR_UNSUPPORTEDALPHAOPERATION, D3DERR_UNSUPPORTEDCOLORARG, D3DERR_UNSUPPORTEDCOLOROPERATION, D3DERR_UNSUPPORTEDFACTORVALUE, D3DERR_UNSUPPORTEDTEXTUREFILTER, D3DERR_WRONGTEXTUREFORMAT,. </returns>
        /// <unmanaged>HRESULT ValidateDevice([None] int* pNumPasses)</unmanaged>
        public SlimDX2.Result ValidateDevice(ref int pNumPasses) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pNumPasses_ = &pNumPasses)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 70 * 4, pNumPasses_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets palette entries.	
        /// </summary>	
        /// <remarks>	
        ///  For Direct3D 9 applications, any palette sent to this method must conform to the D3DPTEXTURECAPS_ALPHAPALETTE capability bit of the <see cref="SlimDX2.Direct3D9.Caps9"/> structure. If D3DPTEXTURECAPS_ALPHAPALETTE is not set, every entry in the palette must have alpha set to 1.0 or this method will fail with D3DERR_INVALIDCALL. If D3DPTEXTURECAPS_ALPHAPALETTE is set, then any set of alpha values are allowed. Note that the debug runtime will print a warning message if all palette entries have alpha set to 0.  A single logical palette is associated with the device, and is shared by all texture stages. 	
        /// </remarks>	
        /// <param name="paletteNumber"> An ordinal value identifying the particular palette upon which the operation is to be performed.  </param>
        /// <param name="pEntries"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing the palette entries to set. The number of PALETTEENTRY structures pointed to by pEntries is assumed to be 256. See Remarks.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT SetPaletteEntries([None] UINT PaletteNumber,[None] const PALETTEENTRY* pEntries)</unmanaged>
        public SlimDX2.Result SetPaletteEntries(int paletteNumber, ref SlimDX2.Windows.Paletteentry pEntries) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pEntries_ = &pEntries)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 71 * 4, paletteNumber, pEntries_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves palette entries.	
        /// </summary>	
        /// <remarks>	
        ///  For more information about <see cref="SlimDX2.Windows.Paletteentry"/>, see the Platform SDK. Note As of Direct3D 9, the peFlags member of the <see cref="SlimDX2.Windows.Paletteentry"/> structure does not work the way it is documented in the Platform SDK. The peFlags member is now the alpha channel for 8-bit palettized formats. 	
        /// </remarks>	
        /// <param name="paletteNumber"> An ordinal value identifying the particular palette to retrieve.  </param>
        /// <param name="pEntries"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing the returned palette entries.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetPaletteEntries([None] UINT PaletteNumber,[Out] PALETTEENTRY* pEntries)</unmanaged>
        public SlimDX2.Result GetPaletteEntries(int paletteNumber, out SlimDX2.Windows.Paletteentry pEntries) {
            unsafe {
                pEntries = new SlimDX2.Windows.Paletteentry();
                SlimDX2.Result __result__;
                fixed (void* pEntries_ = &pEntries)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 72 * 4, paletteNumber, pEntries_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the current texture palette.	
        /// </summary>	
        /// <remarks>	
        ///  A single logical palette is associated with the device, and is shared by all texture stages. 	
        /// </remarks>	
        /// <param name="paletteNumber"> Value that specifies the texture palette to set as the current texture palette.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT SetCurrentTexturePalette([None] UINT PaletteNumber)</unmanaged>
        internal SlimDX2.Result SetCurrentTexturePalette(int paletteNumber) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 73 * 4, paletteNumber);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the current texture palette.	
        /// </summary>	
        /// <param name="paletteNumber"> Pointer to a returned value that identifies the current texture palette.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetCurrentTexturePalette([Out] UINT* PaletteNumber)</unmanaged>
        internal SlimDX2.Result GetCurrentTexturePalette(out int paletteNumber) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* paletteNumber_ = &paletteNumber)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 74 * 4, paletteNumber_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the scissor rectangle.	
        /// </summary>	
        /// <remarks>	
        ///  The scissor rectangle is used as a rectangular clipping region. See {{Rectangles (Direct3D 9)}} for further information on the use of rectangles in DirectX. 	
        /// </remarks>	
        /// <param name="pRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure that defines the rendering area within the render target if scissor test is enabled. This parameter may not be NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetScissorRect([None] const RECT* pRect)</unmanaged>
        internal SlimDX2.Result SetScissorRect(ref SlimDX2.Rectangle pRect) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pRect_ = &pRect)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 75 * 4, pRect_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the scissor rectangle.	
        /// </summary>	
        /// <remarks>	
        ///  The scissor rectangle is used as a rectangular clipping region. See {{Rectangles (Direct3D 9)}} for further information on the use of rectangles in DirectX. 	
        /// </remarks>	
        /// <param name="pRect"> Returns a pointer to a <see cref="SlimDX2.Rectangle"/> structure that defines the rendering area within the render target if scissor test is enabled. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetScissorRect([Out] RECT* pRect)</unmanaged>
        internal SlimDX2.Result GetScissorRect(out SlimDX2.Rectangle pRect) {
            unsafe {
                pRect = new SlimDX2.Rectangle();
                SlimDX2.Result __result__;
                fixed (void* pRect_ = &pRect)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 76 * 4, pRect_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to switch between software and hardware vertex processing.	
        /// </summary>	
        /// <remarks>	
        ///  The restrictions for changing modes are as follows:  If a device is created with D3DCREATE_SOFTWARE_VERTEXPROCESSING, the vertex processing will be done in software and cannot be changed. If a device is created with D3DCREATE_HARDWARE_VERTEXPROCESSING, the vertex processing will be done in hardware and cannot be changed. If a device is created with D3DCREATE_MIXED_VERTEXPROCESSING, the vertex processing will be done in hardware by default. The processing can be switched to software (or back to hardware) using IDirect3DDevice9::SetSoftwareVertexProcessing.  An application can create a mixed-mode device to use both the software vertex processing and the hardware vertex processing. To switch between the two vertex processing modes in DirectX 8.x, use IDirect3DDevice8::SetRenderState with the render state D3DRS_SOFTWAREVERTEXPROCESSING and the appropriate DWORD argument. The drawback of the render state approach was the difficulty in defining the semantics for state blocks. Applications and the runtime had to do extra work and be careful while recording and playing back state blocks. In Direct3D 9, use SetSoftwareVertexProcessing instead. This new API is not recorded by StateBlocks. 	
        /// </remarks>	
        /// <param name="bSoftware"> TRUE to specify software vertex processing; FALSE to specify hardware vertex processing. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT SetSoftwareVertexProcessing([None] BOOL bSoftware)</unmanaged>
        internal SlimDX2.Result SetSoftwareVertexProcessing(bool bSoftware) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 77 * 4, (bSoftware?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the vertex processing (hardware or software) mode.	
        /// </summary>	
        /// <remarks>	
        ///  An application can create a mixed-mode device to use both the software vertex processing and the hardware vertex processing. To switch between the two vertex processing modes in DirectX 8.x, use <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/> with the render state D3DRS_SOFTWAREVERTEXPROCESSING and the appropriate BOOL argument. The drawback of the render state approach was the difficulty in defining the semantics for state blocks. Applications and the runtime had to do extra work and be careful while recording and playing back state blocks. In Direct3D 9, use <see cref="SlimDX2.Direct3D9.Device.SetSoftwareVertexProcessing"/> instead. This new API is not recorded by StateBlocks. 	
        /// </remarks>	
        /// <returns>  {{BOOL}}  Returns TRUE if software vertex processing is set. Otherwise, it returns FALSE. </returns>
        /// <unmanaged>BOOL GetSoftwareVertexProcessing()</unmanaged>
        internal bool GetSoftwareVertexProcessing() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 78 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Enable or disable N-patches.	
        /// </summary>	
        /// <param name="nSegments"> Specifies the number of subdivision segments. If the number of segments is less than 1.0, N-patches are disabled. The default value is 0.0.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK.  </returns>
        /// <unmanaged>HRESULT SetNPatchMode([None] float nSegments)</unmanaged>
        internal SlimDX2.Result SetNPatchMode(float nSegments) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 79 * 4, nSegments);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the N-patch mode segments.	
        /// </summary>	
        /// <returns>  {{FLOAT}}  Specifies the number of subdivision segments. If the number of segments is less than 1.0, N-patches are disabled. The default value is 0.0.  </returns>
        /// <unmanaged>float GetNPatchMode()</unmanaged>
        internal float GetNPatchMode() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct3D9.LocalInterop.Callifloat(_nativePointer, 80 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams.	
        /// </summary>	
        /// <remarks>	
        ///  When converting a legacy application to Direct3D 9, you must add a call to either <see cref="SlimDX2.Direct3D9.Device.SetFVF"/> to use the fixed function pipeline, or <see cref="SlimDX2.Direct3D9.Device.SetVertexDeclaration"/> to use a vertex shader before you make any Draw calls. 	
        /// </remarks>	
        /// <param name="primitiveType"> Member of the <see cref="SlimDX2.Direct3D9.Primitivetype"/> enumerated type, describing the type of primitive to render.  </param>
        /// <param name="startVertex"> Index of the first vertex to load. Beginning at StartVertex the correct number of vertices will be read out of the vertex buffer.  </param>
        /// <param name="primitiveCount"> Number of primitives to render. The maximum number of primitives allowed is determined by checking the MaxPrimitiveCount member of the <see cref="SlimDX2.Direct3D9.Caps9"/> structure. PrimitiveCount is the number of primitives as determined by the primitive type. If it is a line list, each primitive has two vertices. If it is a triangle list, each primitive has three vertices.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be  D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT DrawPrimitive([None] D3DPRIMITIVETYPE PrimitiveType,[None] UINT StartVertex,[None] UINT PrimitiveCount)</unmanaged>
        public SlimDX2.Result DrawPrimitive(SlimDX2.Direct3D9.Primitivetype primitiveType, int startVertex, int primitiveCount) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 81 * 4, unchecked((int)primitiveType), startVertex, primitiveCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Based on indexing, renders the specified geometric primitive into an array of vertices.	
        /// </summary>	
        /// <remarks>	
        ///  This method draws indexed primitives from the current set of data input streams. MinIndex  and all the indices in the index stream are relative to the BaseVertexIndex. The MinIndex  and NumVertices  parameters specify the range of vertex indices used for each IDirect3DDevice9::DrawIndexedPrimitive call. These are used to optimize vertex processing of indexed primitives by processing a sequential range of vertices prior to indexing into these vertices. It is invalid for any indices used during this call to reference any vertices outside of this range. IDirect3DDevice9::DrawIndexedPrimitive fails if no index array is set. The D3DPT_POINTLIST member of the <see cref="SlimDX2.Direct3D9.Primitivetype"/> enumerated type is not supported and is not a valid type for this method. When converting a legacy application to Direct3D 9, you must add a call to either <see cref="SlimDX2.Direct3D9.Device.SetFVF"/> to use the fixed function pipeline, or <see cref="SlimDX2.Direct3D9.Device.SetVertexDeclaration"/> to use a vertex shader before you make any Draw calls. 	
        /// </remarks>	
        /// <param name="arg0"> Member of the <see cref="SlimDX2.Direct3D9.Primitivetype"/> enumerated type, describing the type of primitive to render. D3DPT_POINTLIST is not supported with this method. See Remarks.  </param>
        /// <param name="baseVertexIndex"> Offset from the start of the vertex buffer to the first vertex. See {{Scenario 4}}. </param>
        /// <param name="minVertexIndex"> Minimum vertex index for vertices used during this call. This is a zero based index relative to BaseVertexIndex. </param>
        /// <param name="numVertices"> Number of vertices used during this call. The first vertex is located at index: BaseVertexIndex + MinIndex. </param>
        /// <param name="startIndex"> Index of the first index to use when accesssing the vertex buffer. Beginning at StartIndex to index vertices from the vertex buffer. </param>
        /// <param name="primCount"> Number of primitives to render. The number of vertices used is a function of the primitive count and the primitive type. The maximum number of primitives allowed is determined by checking the MaxPrimitiveCount member of the <see cref="SlimDX2.Direct3D9.Caps9"/> structure.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT DrawIndexedPrimitive([None] D3DPRIMITIVETYPE arg0,[None] INT BaseVertexIndex,[None] UINT MinVertexIndex,[None] UINT NumVertices,[None] UINT startIndex,[None] UINT primCount)</unmanaged>
        public SlimDX2.Result DrawIndexedPrimitive(SlimDX2.Direct3D9.Primitivetype arg0, int baseVertexIndex, int minVertexIndex, int numVertices, int startIndex, int primCount) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 82 * 4, unchecked((int)arg0), baseVertexIndex, minVertexIndex, numVertices, startIndex, primCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Renders data specified by a user memory pointer as a sequence of geometric primitives of the specified type.	
        /// </summary>	
        /// <remarks>	
        ///  This method is intended for use in applications that are unable to store their vertex data in vertex buffers. This method supports only a single vertex stream. The effect of this call is to use the provided vertex data pointer and stride for vertex stream 0. It is invalid to have the declaration of the current vertex shader refer to vertex streams other than stream 0. Following any IDirect3DDevice9::DrawPrimitiveUP call, the stream 0 settings, referenced by <see cref="SlimDX2.Direct3D9.Device.GetStreamSource"/>, are set to NULL. The vertex data passed to IDirect3DDevice9::DrawPrimitiveUP does not need to persist after the call. Direct3D completes its access to that data prior to returning from the call. When converting a legacy application to Direct3D 9, you must add a call to either <see cref="SlimDX2.Direct3D9.Device.SetFVF"/> to use the fixed function pipeline, or <see cref="SlimDX2.Direct3D9.Device.SetVertexDeclaration"/> to use a vertex shader before you make any Draw calls. 	
        /// </remarks>	
        /// <param name="primitiveType"> Member of the <see cref="SlimDX2.Direct3D9.Primitivetype"/> enumerated type, describing the type of primitive to render.  </param>
        /// <param name="primitiveCount"> Number of primitives to render. The maximum number of primitives allowed is determined by checking the MaxPrimitiveCount member of the <see cref="SlimDX2.Direct3D9.Caps9"/> structure.  </param>
        /// <param name="pVertexStreamZeroData"> User memory pointer to the vertex data. </param>
        /// <param name="vertexStreamZeroStride"> The number of bytes of data for each vertex. This value may not be 0. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT DrawPrimitiveUP([None] D3DPRIMITIVETYPE PrimitiveType,[None] UINT PrimitiveCount,[None] const void* pVertexStreamZeroData,[None] UINT VertexStreamZeroStride)</unmanaged>
        public SlimDX2.Result DrawPrimitiveUP(SlimDX2.Direct3D9.Primitivetype primitiveType, int primitiveCount, IntPtr pVertexStreamZeroData, int vertexStreamZeroStride) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 83 * 4, unchecked((int)primitiveType), primitiveCount, (void*)pVertexStreamZeroData, vertexStreamZeroStride);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Renders the specified geometric primitive with data specified by a user memory pointer.	
        /// </summary>	
        /// <remarks>	
        ///  This method is intended for use in applications that are unable to store their vertex data in vertex buffers. This method supports only a single vertex stream, which must be declared as stream 0. Following any IDirect3DDevice9::DrawIndexedPrimitiveUP call, the stream 0 settings, referenced by <see cref="SlimDX2.Direct3D9.Device.GetStreamSource"/>, are set to NULL. Also, the index buffer setting for <see cref="SlimDX2.Direct3D9.Device.SetIndices"/> is set to NULL. The vertex data passed to IDirect3DDevice9::DrawIndexedPrimitiveUP does not need to persist after the call. Direct3D completes its access to that data prior to returning from the call. When converting a legacy application to Direct3D 9, you must add a call to either <see cref="SlimDX2.Direct3D9.Device.SetFVF"/> to use the fixed function pipeline, or <see cref="SlimDX2.Direct3D9.Device.SetVertexDeclaration"/> to use a vertex shader before you make any Draw calls. 	
        /// </remarks>	
        /// <param name="primitiveType"> Member of the <see cref="SlimDX2.Direct3D9.Primitivetype"/> enumerated type, describing the type of primitive to render.  </param>
        /// <param name="minVertexIndex"> Minimum vertex index. This is a zero-based index. </param>
        /// <param name="numVertices">  Number of vertices used during this call. The first vertex is located at index: MinVertexIndex. </param>
        /// <param name="primitiveCount"> Number of primitives to render. The maximum number of primitives allowed is determined by checking the MaxPrimitiveCount member of the <see cref="SlimDX2.Direct3D9.Caps9"/> structure (the number of indices is a function of the primitive count and the primitive type). </param>
        /// <param name="pIndexData"> User memory pointer to the index data.  </param>
        /// <param name="indexDataFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of the index data. The valid settings are either:    <see cref="SlimDX2.Direct3D9.Format.MtIndex16"/>   <see cref="SlimDX2.Direct3D9.Format.MtIndex32"/>   </param>
        /// <param name="pVertexStreamZeroData"> User memory pointer to the vertex data. The vertex data must be in stream 0. </param>
        /// <param name="vertexStreamZeroStride"> The number of bytes of data for each vertex. This value may not be 0. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT DrawIndexedPrimitiveUP([None] D3DPRIMITIVETYPE PrimitiveType,[None] UINT MinVertexIndex,[None] UINT NumVertices,[None] UINT PrimitiveCount,[None] const void* pIndexData,[None] D3DFORMAT IndexDataFormat,[None] const void* pVertexStreamZeroData,[None] UINT VertexStreamZeroStride)</unmanaged>
        public SlimDX2.Result DrawIndexedPrimitiveUP(SlimDX2.Direct3D9.Primitivetype primitiveType, int minVertexIndex, int numVertices, int primitiveCount, IntPtr pIndexData, SlimDX2.Direct3D9.Format indexDataFormat, IntPtr pVertexStreamZeroData, int vertexStreamZeroStride) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 84 * 4, unchecked((int)primitiveType), minVertexIndex, numVertices, primitiveCount, (void*)pIndexData, unchecked((int)indexDataFormat), (void*)pVertexStreamZeroData, vertexStreamZeroStride);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Applies the vertex processing defined by the vertex shader to the set of input data streams, generating a single stream of interleaved vertex data to the destination vertex buffer. 	
        /// </summary>	
        /// <remarks>	
        ///  The order of operations for this method is as follows:  Transform vertices to projection space using the world + view + projection matrix. Compute screen coordinates using viewport settings. If clipping is enabled, compute clipping codes and store them in an internal buffer, associated with the destination vertex buffer. If a vertex is inside the viewing frustum, its screen coordinates are computed. If the vertex is outside the viewing frustum, the vertex is stored in the destination vertex buffer in projection space coordinates. Other notes: The user does not have access to the internal clip code buffer. No clipping is done on triangles or any other primitives.  The destination vertex buffer, pDestBuffer, must be created with a nonzero FVF parameter in <see cref="SlimDX2.Direct3D9.Device.CreateVertexBuffer"/>. The FVF code specified during the call to the IDirect3DDevice9::CreateVertexBuffer method specifies the vertex elements present in the destination vertex buffer. When Direct3D generates texture coordinates, or copies or transforms input texture coordinates, and the output texture coordinate format defines more texture coordinate components than Direct3D generates, Direct3D does not change these extra components. 	
        /// </remarks>	
        /// <param name="srcStartIndex"> Index of first vertex to load.  </param>
        /// <param name="destIndex"> Index of first vertex in the destination vertex buffer into which the results are placed.  </param>
        /// <param name="vertexCount"> Number of vertices to process.  </param>
        /// <param name="pDestBuffer"> Pointer to an <see cref="SlimDX2.Direct3D9.VertexBuffer"/> interface, the destination vertex buffer representing the stream of interleaved vertex data.  </param>
        /// <param name="pVertexDecl"> Pointer to an <see cref="SlimDX2.Direct3D9.VertexDeclaration"/> interface that represents the output vertex data declaration. When vertex shader 3.0 or above is set as the current vertex shader, the output vertex declaration must be present. </param>
        /// <param name="flags"> Processing options. Set this parameter to 0 for default processing. Set to D3DPV_DONOTCOPYDATA to prevent the system from copying vertex data not affected by the vertex operation into the destination buffer. The D3DPV_DONOTCOPYDATA value may be combined with one or more {{D3DLOCK}} values appropriate for the destination buffer. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT ProcessVertices([None] UINT SrcStartIndex,[None] UINT DestIndex,[None] UINT VertexCount,[None] IDirect3DVertexBuffer9* pDestBuffer,[None] IDirect3DVertexDeclaration9* pVertexDecl,[None] int Flags)</unmanaged>
        public SlimDX2.Result ProcessVertices(int srcStartIndex, int destIndex, int vertexCount, SlimDX2.Direct3D9.VertexBuffer pDestBuffer, SlimDX2.Direct3D9.VertexDeclaration pVertexDecl, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 85 * 4, srcStartIndex, destIndex, vertexCount, (void*)((pDestBuffer == null)?IntPtr.Zero:pDestBuffer.NativePointer), (void*)((pVertexDecl == null)?IntPtr.Zero:pVertexDecl.NativePointer), flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a vertex shader declaration from the device and the vertex elements.	
        /// </summary>	
        /// <remarks>	
        ///  See the {{Vertex Declaration (Direct3D 9)}} page for a detailed description of how to map vertex declarations between different versions of DirectX. 	
        /// </remarks>	
        /// <param name="pVertexElements"> An array of <see cref="SlimDX2.Direct3D9.Vertexelement9"/> vertex elements. </param>
        /// <param name="ppDecl"> Pointer to an <see cref="SlimDX2.Direct3D9.VertexDeclaration"/> pointer that returns the created vertex shader declaration. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT CreateVertexDeclaration([None] const D3DVERTEXELEMENT9* pVertexElements,[None] IDirect3DVertexDeclaration9** ppDecl)</unmanaged>
        public SlimDX2.Result CreateVertexDeclaration(ref SlimDX2.Direct3D9.Vertexelement9 pVertexElements, out SlimDX2.Direct3D9.VertexDeclaration ppDecl) {
            unsafe {
                IntPtr ppDecl_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pVertexElements_ = &pVertexElements)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 86 * 4, pVertexElements_, &ppDecl_);
                ppDecl = (ppDecl_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexDeclaration(ppDecl_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a {{Vertex Declaration (Direct3D 9)}}.	
        /// </summary>	
        /// <remarks>	
        ///  A vertex declaration is an IDirect3DVertexDeclaration9 object that defines the data members of a vertex (i.e. texture coordinates, colors, normals, etc.). This data can be useful for implementing {{vertex shaders and pixel shaders}}. 	
        /// </remarks>	
        /// <param name="pDecl"> Pointer to an <see cref="SlimDX2.Direct3D9.VertexDeclaration"/> object, which contains the vertex declaration. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. The return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT SetVertexDeclaration([None] IDirect3DVertexDeclaration9* pDecl)</unmanaged>
        internal SlimDX2.Result SetVertexDeclaration(SlimDX2.Direct3D9.VertexDeclaration pDecl) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 87 * 4, (void*)((pDecl == null)?IntPtr.Zero:pDecl.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a vertex shader declaration.	
        /// </summary>	
        /// <param name="ppDecl"> Pointer to an <see cref="SlimDX2.Direct3D9.VertexDeclaration"/> object that is returned. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. The return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetVertexDeclaration([Out] IDirect3DVertexDeclaration9** ppDecl)</unmanaged>
        internal SlimDX2.Result GetVertexDeclaration(out SlimDX2.Direct3D9.VertexDeclaration ppDecl) {
            unsafe {
                IntPtr ppDecl_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 88 * 4, &ppDecl_);
                ppDecl = (ppDecl_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexDeclaration(ppDecl_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the current vertex stream declaration.	
        /// </summary>	
        /// <remarks>	
        ///  Here are the steps necessary to initialize and use vertices that have a position, diffuse and specular color, and texture coordinates:  Define the custom vertex type and FVF code.	 	
        /// <code> struct LVertex	
        /// { FLOAT    x, y, z; D3DCOLOR specular, diffuse; FLOAT    tu, tv;	
        /// }; const DWORD VertexFVF = (D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_SPECULAR | D3DFVF_TEX1 ); </code>	
        /// 	
        ///   Create a vertex buffer with enough room for four vertices using <see cref="SlimDX2.Direct3D9.Device.CreateVertexBuffer"/>. 	
        /// <code> g_d3dDevice-&gt;CreateVertexBuffer( 4*sizeof(LVertex),   D3DUSAGE_WRITEONLY, VertexFVF, D3DPOOL_DEFAULT, &amp;pBigSquareVB, NULL ); </code>	
        /// 	
        ///   Set the values for each vertex. 	
        /// <code> LVertex * v;	
        /// pBigSquareVB-&gt;Lock( 0, 0, (BYTE**)&amp;v, 0 ); v[0].x  = 0.0f;  v[0].y  = 10.0;  v[0].z  = 10.0f;	
        /// v[0].diffuse  = 0xffff0000;	
        /// v[0].specular = 0xff00ff00;	
        /// v[0].tu = 0.0f;  v[0].tv = 0.0f; v[1].x  = 0.0f;  v[1].y  = 0.0f;  v[1].z  = 10.0f;	
        /// v[1].diffuse  = 0xff00ff00;	
        /// v[1].specular = 0xff00ffff;	
        /// v[1].tu = 0.0f;  v[1].tv = 0.0f; v[2].x  = 10.0f; v[2].y  = 10.0f; v[2].z  = 10.0f;	
        /// v[2].diffuse  = 0xffff00ff;	
        /// v[2].specular = 0xff000000;	
        /// v[2].tu = 0.0f;  v[2].tv = 0.0f; v[3].x  = 0.0f; v[3].y  = 10.0f;  v[3].z = 10.0f;	
        /// v[3].diffuse  = 0xffffff00;	
        /// v[3].specular = 0xffff0000;	
        /// v[3].tu = 0.0f; v[3].tv = 0.0f; pBigSquareVB-&gt;Unlock(); </code>	
        /// 	
        ///   The vertex buffer has been initialized and is ready to render. The following code example shows how to use the legacy FVF to draw a square. 	
        /// <code> g_d3dDevice-&gt;SetFVF(VertexFVF);	
        /// g_d3dDevice-&gt;SetStreamSource(0, pBigSquareVB, 0, sizeof(LVertex));	
        /// g_d3dDevice-&gt;DrawPrimitive(D3DPT_TRIANGLESTRIP, 0 ,2); </code>	
        /// 	
        ///    Here are the steps necessary to initialize and use vertices that have a position, a normal, and texture coordinates:  Define the custom vertex type and FVF code.	
        /// <code> struct Vertex	
        /// { FLOAT x, y, z; FLOAT nx, ny, nz; FLOAT tu, tv;	
        /// }; const DWORD VertexFVF = ( D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1 ); </code>	
        /// 	
        ///   Create a vertex buffer with enough room for four vertices using <see cref="SlimDX2.Direct3D9.Device.CreateVertexBuffer"/> (similar to the example above). Set the values for each vertex. 	
        /// <code> Vertex * v;	
        /// pBigSquareVB-&gt;Lock(0, 0, (BYTE**)&amp;v, 0); v[0].x  = 0.0f;  v[0].y  = 10.0;  v[0].z  = 10.0f;	
        /// v[0].nx = 0.0f;  v[0].ny = 1.0f;  v[0].nz = 0.0f;	
        /// v[0].tu = 0.0f;  v[0].tv = 0.0f; v[1].x  = 0.0f;  v[1].y  = 0.0f;  v[1].z  = 10.0f;	
        /// v[1].nx = 0.0f;  v[1].ny = 1.0f;  v[1].nz = 0.0f;	
        /// v[1].tu = 0.0f;  v[1].tv = 0.0f; v[2].x  = 10.0f; v[2].y  = 10.0f; v[2].z  = 10.0f;	
        /// v[2].nx = 0.0f;  v[2].ny = 1.0f;  v[2].nz = 0.0f;	
        /// v[2].tu = 0.0f;  v[2].tv = 0.0f; v[3].x  = 0.0f; v[3].y  = 10.0f;  v[3].z = 10.0f;	
        /// v[3].nx = 0.0f; v[3].ny = 1.0f;   v[3].nz = 0.0f;	
        /// v[3].tu = 0.0f; v[3].tv = 0.0f; pBigSquareVB-&gt;Unlock(); </code>	
        /// 	
        ///   Draw the object (similar to the example above).  	
        /// </remarks>	
        /// <param name="fvf"> DWORD containing the fixed function vertex type. For more information, see {{D3DFVF}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetFVF([None] int FVF)</unmanaged>
        internal SlimDX2.Result SetFVF(int fvf) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 89 * 4, fvf);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the fixed vertex function declaration.	
        /// </summary>	
        /// <remarks>	
        ///  The fixed vertex function declaration is a set of FVF flags that determine how vertices processed by the fixed function pipeline will be used. 	
        /// </remarks>	
        /// <param name="pFVF"> A DWORD pointer to the fixed function vertex type. For more information, see {{D3DFVF}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetFVF([Out] int* pFVF)</unmanaged>
        internal SlimDX2.Result GetFVF(out int pFVF) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pFVF_ = &pFVF)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 90 * 4, pFVF_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a vertex shader.	
        /// </summary>	
        /// <remarks>	
        ///  When a device is created, <see cref="SlimDX2.Direct3D9.Direct3D9.CreateDevice"/> uses the behavior flag to determine whether to process vertices in hardware or software. There are three possibilities:  Process vertices in hardware by setting D3DCREATE_HARDWARE_VERTEXPROCESSING. Process vertices in software by setting D3DCREATE_SOFTWARE_VERTEXPROCESSING. Process vertices in either hardware or software by setting D3DCREATE_MIXED_VERTEXPROCESSING. To switch a mixed-mode device between software and hardware processing, use <see cref="SlimDX2.Direct3D9.Device.SetSoftwareVertexProcessing"/>.  For an example using <see cref="SlimDX2.Direct3D9.D3DX9.CompileShader"/>, see {{HLSLwithoutEffects Sample}}. 	
        /// </remarks>	
        /// <param name="pFunction"> Pointer to an array of tokens that represents the vertex shader, including any embedded debug and symbol table information.    Use a function such as <see cref="SlimDX2.Direct3D9.D3DX9.CompileShader"/> to create the array from a HLSL shader. Use a function like <see cref="SlimDX2.Direct3D9.D3DX9.AssembleShader"/> to create the token array from an assembly language shader. Use a function like <see cref="SlimDX2.Direct3D9.EffectCompiler.CompileShader"/> to create the array from an effect.  </param>
        /// <param name="ppShader"> Pointer to the returned vertex shader interface (see <see cref="SlimDX2.Direct3D9.VertexShader"/>). </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT CreateVertexShader([None] const int* pFunction,[None] IDirect3DVertexShader9** ppShader)</unmanaged>
        public SlimDX2.Result CreateVertexShader(ref int pFunction, out SlimDX2.Direct3D9.VertexShader ppShader) {
            unsafe {
                IntPtr ppShader_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pFunction_ = &pFunction)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 91 * 4, pFunction_, &ppShader_);
                ppShader = (ppShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexShader(ppShader_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the vertex shader.	
        /// </summary>	
        /// <remarks>	
        ///  To set a fixed-function vertex shader (after having set a programmable vertex shader), call IDirect3DDevice9::SetVertexShader(NULL) to release the programmable shader, and then call <see cref="SlimDX2.Direct3D9.Device.SetFVF"/> with the fixed-function vertex format. 	
        /// </remarks>	
        /// <param name="pShader"> Vertex shader interface. For more information, see <see cref="SlimDX2.Direct3D9.VertexShader"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT SetVertexShader([None] IDirect3DVertexShader9* pShader)</unmanaged>
        internal SlimDX2.Result SetVertexShader(SlimDX2.Direct3D9.VertexShader pShader) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 92 * 4, (void*)((pShader == null)?IntPtr.Zero:pShader.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the currently set vertex shader.	
        /// </summary>	
        /// <remarks>	
        ///  Typically, methods that return state will not work on a device that is created using D3DCREATE_PUREDEVICE. This method however, will work even on a pure device because it returns an interface. 	
        /// </remarks>	
        /// <param name="ppShader"> Pointer to a vertex shader interface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If ppShader is invalid, D3DERR_INVALIDCALL is returned.  </returns>
        /// <unmanaged>HRESULT GetVertexShader([Out] IDirect3DVertexShader9** ppShader)</unmanaged>
        internal SlimDX2.Result GetVertexShader(out SlimDX2.Direct3D9.VertexShader ppShader) {
            unsafe {
                IntPtr ppShader_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 93 * 4, &ppShader_);
                ppShader = (ppShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexShader(ppShader_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a floating-point vertex shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="pConstantData"> Pointer to an array of constants. </param>
        /// <param name="vector4fCount"> Number of four float vectors in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetVertexShaderConstantF([None] UINT StartRegister,[None] const float* pConstantData,[None] UINT Vector4fCount)</unmanaged>
        public SlimDX2.Result SetVertexShaderConstantF(int startRegister, ref float pConstantData, int vector4fCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 94 * 4, startRegister, pConstantData_, vector4fCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a floating-point vertex shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="pConstantData"> Pointer to an array of constants. </param>
        /// <param name="vector4fCount"> Number of four float vectors in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetVertexShaderConstantF([None] UINT StartRegister,[Out] float* pConstantData,[None] UINT Vector4fCount)</unmanaged>
        public SlimDX2.Result GetVertexShaderConstantF(int startRegister, out float pConstantData, int vector4fCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 95 * 4, startRegister, pConstantData_, vector4fCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an integer vertex shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="pConstantData"> Pointer to an array of constants. </param>
        /// <param name="vector4iCount"> Number of four integer vectors in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetVertexShaderConstantI([None] UINT StartRegister,[None] const int* pConstantData,[None] UINT Vector4iCount)</unmanaged>
        public SlimDX2.Result SetVertexShaderConstantI(int startRegister, ref int pConstantData, int vector4iCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 96 * 4, startRegister, pConstantData_, vector4iCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an integer vertex shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="pConstantData"> Pointer to an array of constants. </param>
        /// <param name="vector4iCount"> Number of four integer vectors in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetVertexShaderConstantI([None] UINT StartRegister,[Out] int* pConstantData,[None] UINT Vector4iCount)</unmanaged>
        public SlimDX2.Result GetVertexShaderConstantI(int startRegister, out int pConstantData, int vector4iCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 97 * 4, startRegister, pConstantData_, vector4iCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a Boolean vertex shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="pConstantData"> Pointer to an array of constants. </param>
        /// <param name="boolCount"> Number of boolean values in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetVertexShaderConstantB([None] UINT StartRegister,[None] const BOOL* pConstantData,[None] UINT BoolCount)</unmanaged>
        public SlimDX2.Result SetVertexShaderConstantB(int startRegister, ref bool pConstantData, int boolCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 98 * 4, startRegister, (pConstantData?1:0), boolCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a Boolean vertex shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="pConstantData"> Pointer to an array of constants. </param>
        /// <param name="boolCount"> Number of Boolean values in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetVertexShaderConstantB([None] UINT StartRegister,[Out] BOOL* pConstantData,[None] UINT BoolCount)</unmanaged>
        public SlimDX2.Result GetVertexShaderConstantB(int startRegister, out bool pConstantData, int boolCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 99 * 4, startRegister, pConstantData_, boolCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Binds a vertex buffer to a device data stream. For more information, see {{Setting the Stream Source (Direct3D 9)}}.	
        /// </summary>	
        /// <remarks>	
        ///  When a FVF vertex shader is used, the stride of the vertex stream must match the vertex size, computed from the FVF. When a declaration is used, the stride should be greater than or equal to the stream size computed from the declaration. When calling SetStreamSource, the stride is normally required to be equal to the vertex size. However, there are times when you may want to draw multiple instances of the same or similar geometry (such as when using instancing to draw). For this case, use a zero stride to tell the runtime not to increment the vertex buffer offset (ie: use the same vertex data for all instances). For more information about instancing, see {{Efficiently Drawing Multiple Instances of Geometry (Direct3D 9)}}. 	
        /// </remarks>	
        /// <param name="streamNumber"> Specifies the data stream, in the range from 0 to the maximum number of streams -1. </param>
        /// <param name="pStreamData"> Pointer to an <see cref="SlimDX2.Direct3D9.VertexBuffer"/> interface, representing the vertex buffer to bind to the specified data stream.  </param>
        /// <param name="offsetInBytes"> Offset from the beginning of the stream to the beginning of the vertex data, in bytes. To find out if the device supports stream offsets, see the D3DDEVCAPS2_STREAMOFFSET constant in {{D3DDEVCAPS2}}. </param>
        /// <param name="stride"> Stride of the component, in bytes. See Remarks. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT SetStreamSource([None] UINT StreamNumber,[None] IDirect3DVertexBuffer9* pStreamData,[None] UINT OffsetInBytes,[None] UINT Stride)</unmanaged>
        public SlimDX2.Result SetStreamSource(int streamNumber, SlimDX2.Direct3D9.VertexBuffer pStreamData, int offsetInBytes, int stride) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 100 * 4, streamNumber, (void*)((pStreamData == null)?IntPtr.Zero:pStreamData.NativePointer), offsetInBytes, stride);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a vertex buffer bound to the specified data stream.	
        /// </summary>	
        /// <remarks>	
        ///  A stream is defined as a uniform array of component data, where each component consists of one or more elements representing a single entity such as position, normal, color, and so on. When a FVF vertex shader is used, the stride of the vertex stream must match the vertex size, computed from the FVF. When a declaration is used, the stride should be greater than or equal to the stream size computed from the declaration.  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.VertexBuffer"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DVertexBuffer9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="streamNumber"> Specifies the data stream, in the range from 0 to the maximum number of streams minus one.  </param>
        /// <param name="ppStreamData"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VertexBuffer"/> interface, representing the returned vertex buffer bound to the specified data stream.  </param>
        /// <param name="pOffsetInBytes"> Pointer containing the offset from the beginning of the stream to the beginning of the vertex data. The offset is measured in bytes. See Remarks. </param>
        /// <param name="pStride"> Pointer to a returned stride of the component, in bytes. See Remarks.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetStreamSource([None] UINT StreamNumber,[Out] IDirect3DVertexBuffer9** ppStreamData,[Out] UINT* pOffsetInBytes,[Out] UINT* pStride)</unmanaged>
        public SlimDX2.Result GetStreamSource(int streamNumber, out SlimDX2.Direct3D9.VertexBuffer ppStreamData, out int pOffsetInBytes, out int pStride) {
            unsafe {
                IntPtr ppStreamData_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pOffsetInBytes_ = &pOffsetInBytes)
                    fixed (void* pStride_ = &pStride)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 101 * 4, streamNumber, &ppStreamData_, pOffsetInBytes_, pStride_);
                ppStreamData = (ppStreamData_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexBuffer(ppStreamData_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the stream source frequency divider value. This may be used to draw several instances of geometry.	
        /// </summary>	
        /// <remarks>	
        ///  There are two constants defined in d3d9types.h that are designed to use with SetStreamSourceFreq: D3DSTREAMSOURCE_INDEXEDDATA and D3DSTREAMSOURCE_INSTANCEDATA. To see how to use the constants, see {{Efficiently Drawing Multiple Instances of Geometry (Direct3D 9)}}. 	
        /// </remarks>	
        /// <param name="streamNumber"> Stream source number. </param>
        /// <param name="setting"> This parameter may have two different values. See remarks. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT SetStreamSourceFreq([None] UINT StreamNumber,[None] UINT Setting)</unmanaged>
        public SlimDX2.Result SetStreamSourceFreq(int streamNumber, int setting) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 102 * 4, streamNumber, setting);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the stream source frequency divider value.	
        /// </summary>	
        /// <remarks>	
        ///  Vertex shaders can now be invoked more than once per vertex. See {{Drawing Non-Indexed Geometry}}. 	
        /// </remarks>	
        /// <param name="streamNumber"> Stream source number. </param>
        /// <param name="pSetting"> Returns the frequency divider value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetStreamSourceFreq([None] UINT StreamNumber,[Out] UINT* pSetting)</unmanaged>
        public SlimDX2.Result GetStreamSourceFreq(int streamNumber, out int pSetting) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pSetting_ = &pSetting)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 103 * 4, streamNumber, pSetting_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets index data.	
        /// </summary>	
        /// <remarks>	
        ///  When an application no longer holds a references to this interface, the interface will automatically be freed. The IDirect3DDevice9::SetIndices method sets the current index array to an index buffer. The single set of indices is used to index all streams.  	
        /// </remarks>	
        /// <param name="pIndexData"> Pointer to an <see cref="SlimDX2.Direct3D9.IndexBuffer"/> interface, representing the index data to be set.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetIndices([None] IDirect3DIndexBuffer9* pIndexData)</unmanaged>
        internal SlimDX2.Result SetIndices(SlimDX2.Direct3D9.IndexBuffer pIndexData) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 104 * 4, (void*)((pIndexData == null)?IntPtr.Zero:pIndexData.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves index data.	
        /// </summary>	
        /// <remarks>	
        ///   Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.IndexBuffer"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DIndexBuffer9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="ppIndexData"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.IndexBuffer"/> interface, representing the returned index data.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetIndices([Out] IDirect3DIndexBuffer9** ppIndexData)</unmanaged>
        internal SlimDX2.Result GetIndices(out SlimDX2.Direct3D9.IndexBuffer ppIndexData) {
            unsafe {
                IntPtr ppIndexData_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 105 * 4, &ppIndexData_);
                ppIndexData = (ppIndexData_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.IndexBuffer(ppIndexData_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a pixel shader.	
        /// </summary>	
        /// <param name="pFunction"> Pointer to the pixel shader function token array, specifying the blending operations. This value cannot be NULL.  </param>
        /// <param name="ppShader"> Pointer to the returned pixel shader interface. See <see cref="SlimDX2.Direct3D9.PixelShader"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT CreatePixelShader([None] const int* pFunction,[None] IDirect3DPixelShader9** ppShader)</unmanaged>
        public SlimDX2.Result CreatePixelShader(ref int pFunction, out SlimDX2.Direct3D9.PixelShader ppShader) {
            unsafe {
                IntPtr ppShader_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pFunction_ = &pFunction)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 106 * 4, pFunction_, &ppShader_);
                ppShader = (ppShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PixelShader(ppShader_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the current pixel shader to a previously created pixel shader.	
        /// </summary>	
        /// <param name="pShader"> Pixel shader interface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT SetPixelShader([None] IDirect3DPixelShader9* pShader)</unmanaged>
        internal SlimDX2.Result SetPixelShader(SlimDX2.Direct3D9.PixelShader pShader) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 107 * 4, (void*)((pShader == null)?IntPtr.Zero:pShader.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the currently set pixel shader.	
        /// </summary>	
        /// <remarks>	
        ///  This method will not work on a device that is created using D3DCREATE_PUREDEVICE. 	
        /// </remarks>	
        /// <param name="ppShader"> Pointer to a pixel shader interface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetPixelShader([Out] IDirect3DPixelShader9** ppShader)</unmanaged>
        internal SlimDX2.Result GetPixelShader(out SlimDX2.Direct3D9.PixelShader ppShader) {
            unsafe {
                IntPtr ppShader_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 108 * 4, &ppShader_);
                ppShader = (ppShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PixelShader(ppShader_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a floating-point shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="pConstantData"> Pointer to an array of constants. </param>
        /// <param name="vector4fCount"> Number of four float vectors in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetPixelShaderConstantF([None] UINT StartRegister,[None] const float* pConstantData,[None] UINT Vector4fCount)</unmanaged>
        public SlimDX2.Result SetPixelShaderConstantF(int startRegister, ref float pConstantData, int vector4fCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 109 * 4, startRegister, pConstantData_, vector4fCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a floating-point shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="pConstantData"> Pointer to an array of constants. </param>
        /// <param name="vector4fCount"> Number of four float vectors in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetPixelShaderConstantF([None] UINT StartRegister,[Out] float* pConstantData,[None] UINT Vector4fCount)</unmanaged>
        public SlimDX2.Result GetPixelShaderConstantF(int startRegister, out float pConstantData, int vector4fCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 110 * 4, startRegister, pConstantData_, vector4fCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an integer shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="pConstantData"> Pointer to an array of constants. </param>
        /// <param name="vector4iCount"> Number of four integer vectors in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetPixelShaderConstantI([None] UINT StartRegister,[None] const int* pConstantData,[None] UINT Vector4iCount)</unmanaged>
        public SlimDX2.Result SetPixelShaderConstantI(int startRegister, ref int pConstantData, int vector4iCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 111 * 4, startRegister, pConstantData_, vector4iCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an integer shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="pConstantData"> Pointer to an array of constants. </param>
        /// <param name="vector4iCount"> Number of four integer vectors in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetPixelShaderConstantI([None] UINT StartRegister,[Out] int* pConstantData,[None] UINT Vector4iCount)</unmanaged>
        public SlimDX2.Result GetPixelShaderConstantI(int startRegister, out int pConstantData, int vector4iCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 112 * 4, startRegister, pConstantData_, vector4iCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a Boolean shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="pConstantData"> Pointer to an array of constants. </param>
        /// <param name="boolCount"> Number of boolean values in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetPixelShaderConstantB([None] UINT StartRegister,[None] const BOOL* pConstantData,[None] UINT BoolCount)</unmanaged>
        public SlimDX2.Result SetPixelShaderConstantB(int startRegister, ref bool pConstantData, int boolCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 113 * 4, startRegister, (pConstantData?1:0), boolCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a Boolean shader constant.	
        /// </summary>	
        /// <param name="startRegister"> Register number that will contain the first constant value. </param>
        /// <param name="pConstantData"> Pointer to an array of constants. </param>
        /// <param name="boolCount"> Number of Boolean values in the array of constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetPixelShaderConstantB([None] UINT StartRegister,[Out] BOOL* pConstantData,[None] UINT BoolCount)</unmanaged>
        public SlimDX2.Result GetPixelShaderConstantB(int startRegister, out bool pConstantData, int boolCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 114 * 4, startRegister, pConstantData_, boolCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Draws a rectangular patch using the currently set streams.	
        /// </summary>	
        /// <remarks>	
        ///  For static patches: Set the vertex shader, set the appropriate streams, supply patch information in the pRectPatchInfo parameter, and specify a handle so that Direct3D can capture and cache information. Call IDirect3DDevice9::DrawRectPatch subsequently with pRectPatchInfo set to NULL to efficiently draw the patch. When drawing a cached patch, the currently set streams are ignored. Override the cached pNumSegs by specifying a new value for pNumSegs. When rendering a cached patch, you must set the same vertex shader that was set when it was captured. Calling IDirect3DDevice9::DrawRectPatch with a handle invalidates the same handle cached by a previous <see cref="SlimDX2.Direct3D9.Device.DrawTriPatch"/> call. For dynamic patches, the patch data changes for every rendering of the patch, so it is not efficient to cache information. The application can convey this to Direct3D by setting Handle to 0. In this case, Direct3D draws the patch using the currently set streams and the pNumSegs values, and does not cache any information. It is not valid to simultaneously set Handle to 0 and pRectPatchInfo to NULL. 	
        /// </remarks>	
        /// <param name="handle"> Handle to the rectangular patch to draw.  </param>
        /// <param name="pNumSegs"> Pointer to an array of four floating-point values that identify the number of segments each edge of the rectangle patch should be divided into when tessellated. See <see cref="SlimDX2.Direct3D9.RectpatchInformation"/>.  </param>
        /// <param name="pRectPatchInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.RectpatchInformation"/> structure, describing the rectangular patch to draw.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be  D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT DrawRectPatch([None] UINT Handle,[None] const float* pNumSegs,[None] const D3DRECTPATCH_INFO* pRectPatchInfo)</unmanaged>
        public SlimDX2.Result DrawRectPatch(int handle, ref float pNumSegs, ref SlimDX2.Direct3D9.RectpatchInformation pRectPatchInfo) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pNumSegs_ = &pNumSegs)
                    fixed (void* pRectPatchInfo_ = &pRectPatchInfo)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 115 * 4, handle, pNumSegs_, pRectPatchInfo_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Draws a triangular patch using the currently set streams.	
        /// </summary>	
        /// <remarks>	
        ///  For static patches: Set the vertex shader, set the appropriate streams, supply patch information in the pTriPatchInfo parameter, and specify a handle so that Direct3D can capture and cache information. To efficiently draw the patch, call IDirect3DDevice9::DrawTriPatch with pTriPatchInfo set to NULL. When drawing a cached patch, the currently set streams are ignored. Override the cached pNumSegs by specifying a new value for pNumSegs. When rendering a cached patch, you must set the same vertex shader that was set when it was captured. Calling IDirect3DDevice9::DrawTriPatch with a handle invalidates the same handle cached by a previous <see cref="SlimDX2.Direct3D9.Device.DrawRectPatch"/> call. For dynamic patches, the patch data changes for every rendering of the patch so it is not efficient to cache information. The application can convey this to Direct3D by setting Handle to 0. In this case, Direct3D draws the patch using the currently set streams and the pNumSegs values, and does not cache any information. It is not valid to simultaneously set Handle to 0 and pTriPatchInfo to NULL. 	
        /// </remarks>	
        /// <param name="handle"> Handle to the triangular patch to draw.  </param>
        /// <param name="pNumSegs"> Pointer to an array of three floating-point values that identify the number of segments each edge of the triangle patch should be divided into when tessellated. See <see cref="SlimDX2.Direct3D9.TripatchInformation"/>.  </param>
        /// <param name="pTriPatchInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.TripatchInformation"/> structure, describing the triangular high-order patch to draw.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be  D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT DrawTriPatch([None] UINT Handle,[None] const float* pNumSegs,[None] const D3DTRIPATCH_INFO* pTriPatchInfo)</unmanaged>
        public SlimDX2.Result DrawTriPatch(int handle, ref float pNumSegs, ref SlimDX2.Direct3D9.TripatchInformation pTriPatchInfo) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pNumSegs_ = &pNumSegs)
                    fixed (void* pTriPatchInfo_ = &pTriPatchInfo)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 116 * 4, handle, pNumSegs_, pTriPatchInfo_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Frees a cached high-order patch.	
        /// </summary>	
        /// <param name="handle"> Handle of the cached high-order patch to delete.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be  D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT DeletePatch([None] UINT Handle)</unmanaged>
        public SlimDX2.Result DeletePatch(int handle) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 117 * 4, handle);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a status query.	
        /// </summary>	
        /// <remarks>	
        ///  This method is provided for both synchronous and asynchronous queries. It takes the place of GetInfo, which is no longer supported in Direct3D 9. Synchronous and asynchronous queries are created with IDirect3DDevice9::CreateQuery with <see cref="SlimDX2.Direct3D9.Querytype"/>. When a query has been created and the API calls have been made that are being queried, use <see cref="SlimDX2.Direct3D9.Query.Issue"/> to issue a query and  <see cref="SlimDX2.Direct3D9.Query.GetData"/> to get the results of the query. 	
        /// </remarks>	
        /// <param name="type"> Identifies the query type. For more information, see <see cref="SlimDX2.Direct3D9.Querytype"/>. </param>
        /// <param name="ppQuery"> Returns a pointer to the query interface that manages the query object. See <see cref="SlimDX2.Direct3D9.Query"/>.  This parameter can be set to NULL to see if a query is supported. If the query is not supported, the method returns D3DERR_NOTAVAILABLE. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_NOTAVAILABLE or  E_OUTOFMEMORY.  </returns>
        /// <unmanaged>HRESULT CreateQuery([None] D3DQUERYTYPE Type,[None] IDirect3DQuery9** ppQuery)</unmanaged>
        public SlimDX2.Result CreateQuery(SlimDX2.Direct3D9.Querytype type, out SlimDX2.Direct3D9.Query ppQuery) {
            unsafe {
                IntPtr ppQuery_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 118 * 4, unchecked((int)type), &ppQuery_);
                ppQuery = (ppQuery_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Query(ppQuery_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DStateBlock9</unmanaged>
    [Guid("B07C4FE5-310D-4ba8-A23C-4F0F206F218B")]
    public partial class StateBlock : SlimDX2.ComObject {
        public StateBlock(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the device.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the device.	
        /// </summary>	
        /// <param name="ppDevice"> Pointer to the IDirect3DDevice9 interface that is returned. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device ppDevice) {
            unsafe {
                IntPtr ppDevice_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &ppDevice_);
                ppDevice = (ppDevice_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppDevice_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Capture the current value of states that are included in a stateblock.	
        /// </summary>	
        /// <remarks>	
        ///  The Capture method captures current values for states within an existing state block. It does not capture the entire state of the device. For example: 	
        /// <code> IDirect3DStateBlock9* pStateBlock = NULL; pd3dDevice-&gt;BeginStateBlock();	
        /// // Add the ZENABLE state to the stateblock 	
        /// pd3dDevice-&gt;SetRenderState ( D3DRS_ZENABLE, D3DZB_TRUE );	
        /// pd3dDevice-&gt;EndStateBlock ( &amp;pStateBlock ); // Change the current value that is stored in the state block	
        /// pd3dDevice-&gt;SetRenderState ( D3DRS_ZENABLE, D3DZB_FALSE );	
        /// pStateBlock-&gt;Capture();			 pStateBlock-&gt;Release(); </code>	
        /// 	
        ///  Creating an empty stateblock and calling the Capture method does nothing if no states have been set. The Capture method  will not capture information for lights that are explicitly or implicitly created after the stateblock is created. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails because capture cannot be done while in record mode, the return value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT Capture()</unmanaged>
        public SlimDX2.Result Capture() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Apply the state block to the current device state.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails while in record mode, the return value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT Apply()</unmanaged>
        public SlimDX2.Result Apply() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DResource9</unmanaged>
    [Guid("05EEC05D-8F7D-4362-B999-D1BAF357C704")]
    public partial class Resource : SlimDX2.ComObject {
        public Resource(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the device associated with a resource.	
        /// </summary>	
        /// <remarks>	
        ///  This method allows navigation to the owning device object. Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DDevice9 interface results in a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the priority for this resource.	
        /// </summary>	
        /// <remarks>	
        ///  IDirect3DResource9::GetPriority is used for priority control of managed resources. This method returns 0 on nonmanaged resources. Priorities are used to determine when managed resources are to be removed from memory. A resource assigned a low priority is removed before a resource with a high priority. If two resources have the same priority, the resource that was used more recently is kept in memory; the other resource is removed. Managed resources have a default priority of 0. 	
        /// </remarks>	
        /// <unmanaged>int GetPriority()</unmanaged>
        public int Priority {
                get { return GetPriority(); }
        }
        
        /// <summary>	
        /// Returns the type of the resource.	
        /// </summary>	
        /// <unmanaged>D3DRESOURCETYPE GetType()</unmanaged>
        public SlimDX2.Direct3D9.Resourcetype TypeInfo {
                get { return GetTypeInfo(); }
        }
        
        /// <summary>	
        /// Retrieves the device associated with a resource.	
        /// </summary>	
        /// <remarks>	
        ///  This method allows navigation to the owning device object. Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DDevice9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="ppDevice"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface to fill with the device pointer, if the query succeeds.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device ppDevice) {
            unsafe {
                IntPtr ppDevice_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &ppDevice_);
                ppDevice = (ppDevice_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppDevice_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Associates data with the resource that is intended for use by the application, not by Direct3D. Data is passed by value, and multiple sets of data can be associated with a single resource.	
        /// </summary>	
        /// <remarks>	
        ///  Direct3D does not manage the memory at pData. If this buffer was dynamically allocated, it is the calling application's responsibility to free the memory. 	
        /// </remarks>	
        /// <param name="refguid"> Reference to the globally unique identifier that identifies the private data to set. </param>
        /// <param name="pData"> Pointer to a buffer that contains the data to be associated with the resource.  </param>
        /// <param name="sizeOfData"> Size of the buffer at pData, in bytes.  </param>
        /// <param name="flags"> Value that describes the type of data being passed, or indicates to the application that the data should be invalidated when the resource changes.    ItemDescription  (none)  If no flags are specified, Direct3D allocates memory to hold the data within the buffer and copies the data into the new buffer. The buffer allocated by Direct3D is automatically freed, as appropriate.   D3DSPD_IUNKNOWN  The data at pData is a pointer to an <see cref="SlimDX2.ComObject"/> interface. SizeOfData must be set to the size of a pointer to IUnknown, that is, sizeof(IUnknown*). Direct3D automatically callsIUnknown through pData when the private data is destroyed. Private data will be destroyed by a subsequent call to IDirect3DResource9::SetPrivateData with the same GUID, a subsequent call to <see cref="SlimDX2.Direct3D9.Resource.FreePrivateData"/>, or when the <see cref="SlimDX2.Direct3D9.Direct3D9"/> object is released. For more information, see Remarks.     </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT SetPrivateData([None] REFGUID refguid,[None] const void* pData,[None] int SizeOfData,[None] int Flags)</unmanaged>
        public SlimDX2.Result SetPrivateData(Guid refguid, IntPtr pData, int sizeOfData, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, &refguid, (void*)pData, sizeOfData, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copies the private data associated with the resource to a provided buffer.	
        /// </summary>	
        /// <remarks>	
        ///  This method is inherited by the following interfaces:  <see cref="SlimDX2.Direct3D9.Resource"/>,  <see cref="SlimDX2.Direct3D9.BaseTexture"/>, <see cref="SlimDX2.Direct3D9.CubeTexture"/>,  <see cref="SlimDX2.Direct3D9.Texture"/>,  <see cref="SlimDX2.Direct3D9.VolumeTexture"/>, <see cref="SlimDX2.Direct3D9.IndexBuffer"/>,  <see cref="SlimDX2.Direct3D9.VertexBuffer"/>. 	
        /// </remarks>	
        /// <param name="refguid"> The globally unique identifier that identifies the private data to retrieve.  </param>
        /// <param name="pData"> Pointer to a previously allocated buffer to fill with the requested private data if the call succeeds. The application calling this method is responsible for allocating and releasing this buffer. If this parameter is NULL, this method will return the buffer size in pSizeOfData. </param>
        /// <param name="pSizeOfData"> Pointer to the size of the buffer at  pData, in bytes. If this value is less than the actual size of the private data (such as 0), the method sets this parameter to the required buffer size and the method returns D3DERR_MOREDATA.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_MOREDATA, D3DERR_NOTFOUND. </returns>
        /// <unmanaged>HRESULT GetPrivateData([None] REFGUID refguid,[None] void* pData,[Out] int* pSizeOfData)</unmanaged>
        public SlimDX2.Result GetPrivateData(Guid refguid, IntPtr pData, out int pSizeOfData) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pSizeOfData_ = &pSizeOfData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, &refguid, (void*)pData, pSizeOfData_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Frees the specified private data associated with this resource.	
        /// </summary>	
        /// <remarks>	
        ///  Direct3D calls this method automatically when a resource is released. 	
        /// </remarks>	
        /// <param name="refguid"> Reference to the globally unique identifier that identifies the private data to free. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTFOUND. </returns>
        /// <unmanaged>HRESULT FreePrivateData([None] REFGUID refguid)</unmanaged>
        public SlimDX2.Result FreePrivateData(Guid refguid) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, &refguid);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Assigns the priority of a resource for scheduling purposes.	
        /// </summary>	
        /// <remarks>	
        ///  This method is used to change the priority of managed resources (resources created with the <see cref="SlimDX2.Direct3D9.Pool.Managed"/> flag). This method returns 0 on non-managed resources. Priorities are used to determine when managed resources are to be removed from memory. A resource assigned a low priority is removed before a resource with a high priority. If two resources have the same priority, the resource that was used more recently is kept in memory; the other resource is removed. Managed resources have a default priority of 0. Windows Vista only - When this method is called using an <see cref="SlimDX2.Direct3D9.Direct3D9Ex"/> interface, only resources created with the <see cref="SlimDX2.Direct3D9.Pool.Default"/> flag will be affected. 	
        /// </remarks>	
        /// <param name="priorityNew"> Priority to assign to a resource.    Differences between Direct3D 9 and Direct3D 9 for Windows Vista The priority can be any DWORD value; Direct3D 9 for Windows Vista also supports any of these pre-defined values {{D3D9_RESOURCE_PRIORITY}}.     </param>
        /// <returns>  <see cref="int"/>  Returns the previous priority value for the resource. </returns>
        /// <unmanaged>int SetPriority([None] int PriorityNew)</unmanaged>
        public int SetPriority(int priorityNew) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, priorityNew);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the priority for this resource.	
        /// </summary>	
        /// <remarks>	
        ///  IDirect3DResource9::GetPriority is used for priority control of managed resources. This method returns 0 on nonmanaged resources. Priorities are used to determine when managed resources are to be removed from memory. A resource assigned a low priority is removed before a resource with a high priority. If two resources have the same priority, the resource that was used more recently is kept in memory; the other resource is removed. Managed resources have a default priority of 0. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  Returns a DWORD value, indicating the priority of the resource. </returns>
        /// <unmanaged>int GetPriority()</unmanaged>
        internal int GetPriority() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Preloads a managed resource.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method indicates that the application will need this managed resource shortly. This method has no effect on nonmanaged resources. IDirect3DResource9::PreLoad detects "thrashing" conditions where more resources are being used in each frame than can fit in video memory simultaneously. Under such circumstances IDirect3DResource9::PreLoad silently does nothing. 	
        /// </remarks>	
        /// <unmanaged>void PreLoad()</unmanaged>
        public void PreLoad() {
            unsafe {
                SlimDX2.Direct3D9.LocalInterop.Callivoid(_nativePointer, 9 * 4);
            }
        }
        
        /// <summary>	
        /// Returns the type of the resource.	
        /// </summary>	
        /// <returns>  <see cref="SlimDX2.Direct3D9.Resourcetype"/>  Returns a member of the <see cref="SlimDX2.Direct3D9.Resourcetype"/> enumerated type, identifying the type of the resource. </returns>
        /// <unmanaged>D3DRESOURCETYPE GetType()</unmanaged>
        internal SlimDX2.Direct3D9.Resourcetype GetTypeInfo() {
            unsafe {
                SlimDX2.Direct3D9.Resourcetype __result__;
                __result__= (SlimDX2.Direct3D9.Resourcetype)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DVertexDeclaration9</unmanaged>
    [Guid("DD13C59C-36FA-4098-A8FB-C7ED39DC8546")]
    public partial class VertexDeclaration : SlimDX2.ComObject {
        public VertexDeclaration(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the current device.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the current device.	
        /// </summary>	
        /// <param name="ppDevice"> Pointer to the IDirect3DDevice9 interface that is returned. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device ppDevice) {
            unsafe {
                IntPtr ppDevice_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &ppDevice_);
                ppDevice = (ppDevice_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppDevice_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the vertex shader declaration.	
        /// </summary>	
        /// <remarks>	
        ///  The number of elements, pNumElements, includes the {{D3DDECL_END}} macro, which ends the declaration. So the element count is actually one higher than the number of valid vertex elements. Here's an example that will return the vertex declaration array of up to 256 elements: 	
        /// <code> D3DVERTEXELEMENT9 decl[MAXD3DDECLLENGTH];	
        /// UINT numElements;	
        /// HRESULT hr = m_pVertexDeclaration-&gt;GetDeclaration( decl, &amp;numElements); </code>	
        /// 	
        ///  Specify NULL for pDeclto get the number of elements in the declaration. 	
        /// </remarks>	
        /// <param name="pElement"> Array of vertex elements (see <see cref="SlimDX2.Direct3D9.Vertexelement9"/>) that make up a vertex shader declaration. The application needs to allocate enough room for this. The vertex element array ends with the {{D3DDECL_END}} macro. </param>
        /// <param name="pNumElements"> Number of elements in the array. The application needs to allocate enough room for this.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetDeclaration([Out] D3DVERTEXELEMENT9* pElement,[Out] UINT* pNumElements)</unmanaged>
        public SlimDX2.Result GetDeclaration(out SlimDX2.Direct3D9.Vertexelement9 pElement, out int pNumElements) {
            unsafe {
                pElement = new SlimDX2.Direct3D9.Vertexelement9();
                SlimDX2.Result __result__;
                fixed (void* pElement_ = &pElement)
                    fixed (void* pNumElements_ = &pNumElements)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, pElement_, pNumElements_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DVertexShader9</unmanaged>
    [Guid("EFC5557E-6265-4613-8A94-43857889EB36")]
    public partial class VertexShader : SlimDX2.ComObject {
        public VertexShader(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the device.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the device.	
        /// </summary>	
        /// <param name="ppDevice"> Pointer to the IDirect3DDevice9 interface that is returned. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device ppDevice) {
            unsafe {
                IntPtr ppDevice_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &ppDevice_);
                ppDevice = (ppDevice_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppDevice_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a pointer to the shader data.	
        /// </summary>	
        /// <param name="arg0"> Pointer to a buffer that contains the shader data. The application needs to allocate enough room for this.  </param>
        /// <param name="pSizeOfData"> Size of the data, in bytes. To get the buffer size that is needed to retrieve the data, set pData = NULL when calling GetFunction. Then call GetFunction with the returned size, to get the buffer data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetFunction([None] void* arg0,[Out] UINT* pSizeOfData)</unmanaged>
        public SlimDX2.Result GetFunction(IntPtr arg0, out int pSizeOfData) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pSizeOfData_ = &pSizeOfData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)arg0, pSizeOfData_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DPixelShader9</unmanaged>
    [Guid("6D3BDBDC-5B02-4415-B852-CE5E8BCCB289")]
    public partial class PixelShader : SlimDX2.ComObject {
        public PixelShader(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the device.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the device.	
        /// </summary>	
        /// <param name="ppDevice"> Pointer to the IDirect3DDevice9 interface that is returned. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device ppDevice) {
            unsafe {
                IntPtr ppDevice_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &ppDevice_);
                ppDevice = (ppDevice_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppDevice_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a pointer to the shader data.	
        /// </summary>	
        /// <param name="arg0"> Pointer to a buffer that contains the shader data. The application needs to allocate enough room for this.  </param>
        /// <param name="pSizeOfData"> Size of the data, in bytes. To get the buffer size that is needed to retrieve the data, set pData = NULL when calling GetFunction. Then call GetFunction with the returned size, to get the buffer data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetFunction([None] void* arg0,[Out] UINT* pSizeOfData)</unmanaged>
        public SlimDX2.Result GetFunction(IntPtr arg0, out int pSizeOfData) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pSizeOfData_ = &pSizeOfData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)arg0, pSizeOfData_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DBaseTexture9</unmanaged>
    [Guid("580CA87E-1D3C-4d54-991D-B7D3E3C298CE")]
    public partial class BaseTexture : SlimDX2.Direct3D9.Resource {
        public BaseTexture(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Returns a value clamped to the maximum level-of-detail set for a managed texture (this method is not supported for an unmanaged texture).	
        /// </summary>	
        /// <unmanaged>int GetLOD()</unmanaged>
        public int LOD {
                get { return GetLOD(); }
        }
        
        /// <summary>	
        /// Returns the number of texture levels in a multilevel texture.	
        /// </summary>	
        /// <remarks>	
        ///  This method applies to the following interfaces, which inherit from <see cref="SlimDX2.Direct3D9.BaseTexture"/>.   <see cref="SlimDX2.Direct3D9.CubeTexture"/>   <see cref="SlimDX2.Direct3D9.Texture"/>   <see cref="SlimDX2.Direct3D9.VolumeTexture"/>   	
        /// </remarks>	
        /// <unmanaged>int GetLevelCount()</unmanaged>
        public int LevelCount {
                get { return GetLevelCount(); }
        }
        
        /// <summary>	
        /// Get the filter type that is used for automatically generated mipmap sublevels.	
        /// </summary>	
        /// <remarks>	
        ///  Changing the filter type "dirties" the mipmap sublevels and causes them to be regenerated. The (default) filter type set at texture creation time is D3DTEXF_LINEAR. If the driver doesn't support a linear filter, the filter type will be set to D3DTEXF_POINT. All filter types supported by the driver for regular texture filtering are supported for autogeneration except D3DTEXF_NONE. For each resource type, drivers should support all the filter types reported in the corresponding texture, CubeTexture, and volumetexture filter caps. For more information about texture types, see <see cref="SlimDX2.Direct3D9.Texturefiltertype"/>. This method has no effect if the texture is not created with {{D3DUSAGE_AUTOGENMIPMAP}}. 	
        /// </remarks>	
        /// <unmanaged>D3DTEXTUREFILTERTYPE GetAutoGenFilterType()</unmanaged>
        public SlimDX2.Direct3D9.Texturefiltertype AutoGenFilterType {
                get { return GetAutoGenFilterType(); }
                set { SetAutoGenFilterType(value); }
        }
        
        /// <summary>	
        /// Sets the most detailed level-of-detail for a managed texture. 	
        /// </summary>	
        /// <remarks>	
        ///  This method applies to the following interfaces, which inherit from <see cref="SlimDX2.Direct3D9.BaseTexture"/>.   <see cref="SlimDX2.Direct3D9.CubeTexture"/>   <see cref="SlimDX2.Direct3D9.Texture"/>   <see cref="SlimDX2.Direct3D9.VolumeTexture"/>   <see cref="SlimDX2.Direct3D9.Resource"/>   SetLOD is used for level-of-detail control of managed textures. This method returns 0 on nonmanaged textures. SetLOD communicates to the Direct3D texture manager the most detailed mipmap in the chain that should be loaded into local video memory. For example, in a five-level mipmap chain, setting LODNew to 2 indicates that the texture manager should load only mipmap levels 2 through 4 into local video memory at any given time.  More specifically, if the texture was created with the dimensions of 256x256, setting the most detailed level to 0 indicates that 256 x 256 is the largest mipmap available, setting the most detailed level to 1 indicates that 128 x 128 is the largest mipmap available, and so on, up to the most detailed mip level (the smallest texture size) for the chain. 	
        /// </remarks>	
        /// <param name="lODNew"> Most detailed level-of-detail value to set for the mipmap chain.  </param>
        /// <returns>  <see cref="int"/>  A DWORD value, clamped to the maximum level-of-detail value (one less than the total number of levels). Subsequent calls to this method will return the clamped value, not the level-of-detail value that was previously set. </returns>
        /// <unmanaged>int SetLOD([None] int LODNew)</unmanaged>
        public int SetLOD(int lODNew) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, lODNew);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns a value clamped to the maximum level-of-detail set for a managed texture (this method is not supported for an unmanaged texture).	
        /// </summary>	
        /// <returns>  <see cref="int"/>  A DWORD value, clamped to the maximum level-of-detail value (one less than the total number of levels). Calling GetLOD on an unmanaged texture is not supported and will result in a {{D3DERR}} error code being returned. </returns>
        /// <unmanaged>int GetLOD()</unmanaged>
        internal int GetLOD() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns the number of texture levels in a multilevel texture.	
        /// </summary>	
        /// <remarks>	
        ///  This method applies to the following interfaces, which inherit from <see cref="SlimDX2.Direct3D9.BaseTexture"/>.   <see cref="SlimDX2.Direct3D9.CubeTexture"/>   <see cref="SlimDX2.Direct3D9.Texture"/>   <see cref="SlimDX2.Direct3D9.VolumeTexture"/>   	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  A DWORD value indicating the number of texture levels in a multilevel texture. </returns>
        /// <unmanaged>int GetLevelCount()</unmanaged>
        internal int GetLevelCount() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set the filter type that is used for automatically generated mipmap sublevels.	
        /// </summary>	
        /// <remarks>	
        ///  Changing the filter type "dirties" the mipmap sublevels and causes them to be regenerated. The (default) filter type set at texture creation time is D3DTEXF_LINEAR. If the driver does not support a linear filter, the filter type will be set to D3DTEXF_POINT. All filter types supported by the driver for regular texture filtering are supported for autogeneration except D3DTEXF_NONE. SetAutoGenFilterType will fail unless the driver sets the appropriate D3DPTFILTERCAPS_MINFxxx caps. These values are specified in the TextureFilterCaps and/or  CubeTextureFilterCaps members of <see cref="SlimDX2.Direct3D9.Caps9"/>.  For more information about texture filter types, see <see cref="SlimDX2.Direct3D9.Texturefiltertype"/>. This method has no effect if the texture is not created with D3DUSAGE_AUTOGENMIPMAP. In this case, no failure is returned. For more information about usage constants, see {{D3DUSAGE}}. 	
        /// </remarks>	
        /// <param name="filterType"> Filter type. See <see cref="SlimDX2.Direct3D9.Texturefiltertype"/>. This method will fail if the filter type is invalid or not supported. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT SetAutoGenFilterType([None] D3DTEXTUREFILTERTYPE FilterType)</unmanaged>
        internal SlimDX2.Result SetAutoGenFilterType(SlimDX2.Direct3D9.Texturefiltertype filterType) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, unchecked((int)filterType));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the filter type that is used for automatically generated mipmap sublevels.	
        /// </summary>	
        /// <remarks>	
        ///  Changing the filter type "dirties" the mipmap sublevels and causes them to be regenerated. The (default) filter type set at texture creation time is D3DTEXF_LINEAR. If the driver doesn't support a linear filter, the filter type will be set to D3DTEXF_POINT. All filter types supported by the driver for regular texture filtering are supported for autogeneration except D3DTEXF_NONE. For each resource type, drivers should support all the filter types reported in the corresponding texture, CubeTexture, and volumetexture filter caps. For more information about texture types, see <see cref="SlimDX2.Direct3D9.Texturefiltertype"/>. This method has no effect if the texture is not created with {{D3DUSAGE_AUTOGENMIPMAP}}. 	
        /// </remarks>	
        /// <returns>  <see cref="SlimDX2.Direct3D9.Texturefiltertype"/>  Filter type. See <see cref="SlimDX2.Direct3D9.Texturefiltertype"/>. A texture must be created with {{D3DUSAGE_AUTOGENMIPMAP}} to use this method. Any other usage value will cause this method to return D3DTEXF_NONE.  </returns>
        /// <unmanaged>D3DTEXTUREFILTERTYPE GetAutoGenFilterType()</unmanaged>
        internal SlimDX2.Direct3D9.Texturefiltertype GetAutoGenFilterType() {
            unsafe {
                SlimDX2.Direct3D9.Texturefiltertype __result__;
                __result__= (SlimDX2.Direct3D9.Texturefiltertype)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Generate mipmap sublevels.	
        /// </summary>	
        /// <remarks>	
        ///  An application can generate mipmap sublevels at any time by calling GenerateMipSubLevels. To have mipmap sublevels generated automatically at texture creation time (see {{Automatic Generation of Mipmaps (Direct3D 9)}}), specify  D3DUSAGE_AUTOGENMIPMAP during {{CreateTexture}}, {{CreateCubeTexture}}, and {{CreateVolumeTexture}}. For more information about usage constants, see {{D3DUSAGE}}. 	
        /// </remarks>	
        /// <unmanaged>void GenerateMipSubLevels()</unmanaged>
        public void GenerateMipSubLevels() {
            unsafe {
                SlimDX2.Direct3D9.LocalInterop.Callivoid(_nativePointer, 16 * 4);
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DTexture9</unmanaged>
    [Guid("85C31227-3DE5-4f00-9B3A-F11AC38C18B5")]
    public partial class Texture : SlimDX2.Direct3D9.BaseTexture {
        public Texture(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves a level description of a texture resource.	
        /// </summary>	
        /// <param name="level"> Identifies a level of the texture resource. This method returns a surface description for the level specified by this parameter.  </param>
        /// <param name="pDesc"> Pointer to a <see cref="SlimDX2.Direct3D9.SurfaceDescription"/> structure, describing the returned level.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one of the arguments is invalid.  </returns>
        /// <unmanaged>HRESULT GetLevelDesc([None] UINT Level,[Out] D3DSURFACE_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetLevelDescription(int level, out SlimDX2.Direct3D9.SurfaceDescription pDesc) {
            unsafe {
                pDesc = new SlimDX2.Direct3D9.SurfaceDescription();
                SlimDX2.Result __result__;
                fixed (void* pDesc_ = &pDesc)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, level, pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the specified texture surface level.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DSurface9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="level"> Identifies a level of the texture resource. This method returns a surface for the level specified by this parameter. The top-level surface is denoted by 0.  </param>
        /// <param name="ppSurfaceLevel"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the returned surface.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetSurfaceLevel([None] UINT Level,[Out] IDirect3DSurface9** ppSurfaceLevel)</unmanaged>
        public SlimDX2.Result GetSurfaceLevel(int level, out SlimDX2.Direct3D9.Surface ppSurfaceLevel) {
            unsafe {
                IntPtr ppSurfaceLevel_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, level, &ppSurfaceLevel_);
                ppSurfaceLevel = (ppSurfaceLevel_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(ppSurfaceLevel_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Locks a rectangle on a texture resource.	
        /// </summary>	
        /// <remarks>	
        ///  Textures created with D3DPOOL_DEFAULT are not lockable. Textures created in video memory are lockable when created with {{USAGE_DYNAMIC}}. For performance reasons, dirty regions are recorded only for level zero of a texture. Dirty regions are automatically recorded when IDirect3DTexture9::LockRect is called without {{D3DLOCK_NO_DIRTY_UPDATE}} or D3DLOCK_READONLY. See <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/> for more information. The only lockable format for a depth-stencil texture is {{D3DLOCK_D16_LOCKABLE}}. Video memory textures cannot be locked, but must be modified by calling <see cref="SlimDX2.Direct3D9.Device.UpdateSurface"/> or <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/>. There are exceptions for some proprietary driver pixel formats that Direct3D 9 does not recognize. These can be locked. This method cannot retrieve data from a texture resource created with {{D3DUSAGE_RENDERTARGET}} because such a texture must be assigned to D3DPOOL_DEFAULT memory and is therefore not lockable. In this case, use instead <see cref="SlimDX2.Direct3D9.Device.GetRenderTargetData"/> to copy texture data from device memory to system memory. 	
        /// </remarks>	
        /// <param name="level"> Specifies the level of the texture resource to lock.  </param>
        /// <param name="pLockedRect"> Pointer to a <see cref="SlimDX2.Direct3D9.LockedRect"/> structure, describing the locked region.  </param>
        /// <param name="pRect"> Pointer to a rectangle to lock. Specified by a pointer to a RECT structure. Specifying NULL for this parameter expands the dirty region to cover the entire texture.  </param>
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY   You may not specify a subrect when using D3DLOCK_DISCARD. For a description of the flags, see {{D3DLOCK}}.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT LockRect([None] UINT Level,[None] D3DLOCKED_RECT* pLockedRect,[None] const RECT* pRect,[None] int Flags)</unmanaged>
        public SlimDX2.Result LockRect(int level, ref SlimDX2.Direct3D9.LockedRect pLockedRect, ref SlimDX2.Rectangle pRect, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pLockedRect_ = &pLockedRect)
                    fixed (void* pRect_ = &pRect)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, level, pLockedRect_, pRect_, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks a rectangle on a texture resource.	
        /// </summary>	
        /// <param name="level"> Specifies the level of the texture resource to unlock.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT UnlockRect([None] UINT Level)</unmanaged>
        public SlimDX2.Result UnlockRect(int level) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, level);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds a dirty region to a texture resource.	
        /// </summary>	
        /// <remarks>	
        ///  For performance reasons, dirty regions are only recorded for level zero of a texture. For sublevels, it is assumed that the corresponding (scaled) rectangle or box is also dirty. Dirty regions are automatically recorded when <see cref="SlimDX2.Direct3D9.Texture.LockRect"/> is called without {{D3DLOCK_NO_DIRTY_UPDATE}} or {{D3DLOCK_READONLY}}. The destination surface of <see cref="SlimDX2.Direct3D9.Device.UpdateSurface"/> is also marked dirty automatically. Using {{D3DLOCK_NO_DIRTY_UPDATE}} and explicitly specifying dirty regions can be used to increase the efficiency of <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/>. Using this method, applications can optimize what subset of a resource is copied by specifying dirty regions on the resource. However, the dirty regions may be expanded to optimize alignment. 	
        /// </remarks>	
        /// <param name="pDirtyRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure, specifying the dirty region to add. Specifying NULL expands the dirty region to cover the entire texture.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT AddDirtyRect([None] const RECT* pDirtyRect)</unmanaged>
        public SlimDX2.Result AddDirtyRect(ref SlimDX2.Rectangle pDirtyRect) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pDirtyRect_ = &pDirtyRect)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, pDirtyRect_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DVolumeTexture9</unmanaged>
    [Guid("2518526C-E789-4111-A7B9-47EF328D13E6")]
    public partial class VolumeTexture : SlimDX2.Direct3D9.BaseTexture {
        public VolumeTexture(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves a level description of a volume texture resource.	
        /// </summary>	
        /// <param name="level"> Identifies a level of the volume texture resource. This method returns a volume description for the level specified by this parameter.  </param>
        /// <param name="pDesc"> Pointer to a <see cref="SlimDX2.Direct3D9.VolumeDescription"/> structure, describing the returned volume texture level.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one or more of the arguments are invalid.  </returns>
        /// <unmanaged>HRESULT GetLevelDesc([None] UINT Level,[Out] D3DVOLUME_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetLevelDescription(int level, out SlimDX2.Direct3D9.VolumeDescription pDesc) {
            unsafe {
                pDesc = new SlimDX2.Direct3D9.VolumeDescription();
                SlimDX2.Result __result__;
                fixed (void* pDesc_ = &pDesc)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, level, pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the specified volume texture level.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Volume"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DVolume9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="level"> Identifies a level of the volume texture resource. This method returns a volume for the level specified by this parameter.  </param>
        /// <param name="ppVolumeLevel"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface, representing the returned volume level.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetVolumeLevel([None] UINT Level,[Out] IDirect3DVolume9** ppVolumeLevel)</unmanaged>
        public SlimDX2.Result GetVolumeLevel(int level, out SlimDX2.Direct3D9.Volume ppVolumeLevel) {
            unsafe {
                IntPtr ppVolumeLevel_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, level, &ppVolumeLevel_);
                ppVolumeLevel = (ppVolumeLevel_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Volume(ppVolumeLevel_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Locks a box on a volume texture resource.	
        /// </summary>	
        /// <remarks>	
        ///  For performance reasons, dirty regions are only recorded for level zero of a texture. Dirty regions are automatically recorded when LockBox is called without D3DLOCK_NO_DIRTY_UPDATE or D3DLOCK_READONLY. For more information, see {{UpdateTexture}}. 	
        /// </remarks>	
        /// <param name="level"> Specifies the level of the volume texture resource to lock.  </param>
        /// <param name="pLockedVolume"> Pointer to a <see cref="SlimDX2.Direct3D9.LockedBox"/> structure, describing the locked region.  </param>
        /// <param name="pBox"> Pointer to the volume to lock. This parameter is specified by a pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifying NULL for this parameter locks the entire volume level.  </param>
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY   For a description of the flags, see {{D3DLOCK}}.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT LockBox([None] UINT Level,[None] D3DLOCKED_BOX* pLockedVolume,[None] const D3DBOX* pBox,[None] int Flags)</unmanaged>
        public SlimDX2.Result LockBox(int level, ref SlimDX2.Direct3D9.LockedBox pLockedVolume, ref SlimDX2.Direct3D9.Box pBox, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pLockedVolume_ = &pLockedVolume)
                    fixed (void* pBox_ = &pBox)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, level, pLockedVolume_, pBox_, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks a box on a volume texture resource.	
        /// </summary>	
        /// <param name="level"> Specifies the level of the volume texture resource to unlock.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT UnlockBox([None] UINT Level)</unmanaged>
        public SlimDX2.Result UnlockBox(int level) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, level);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds a dirty region to a volume texture resource.	
        /// </summary>	
        /// <remarks>	
        ///  For performance reasons, dirty regions are only recorded for level zero of a texture. For sublevels, it is assumed that the corresponding (scaled) box is also dirty. Dirty regions are automatically recorded when {{LockBox}} is called without {{D3DLOCK_NO_DIRTY_UPDATE}} or {{D3DLOCK_READONLY}}. Using {{D3DLOCK_NO_DIRTY_UPDATE}} and explicitly specifying dirty regions can be used to increase the efficiency of {{UpdateTexture}}. Using this method, applications can optimize what subset of a resource is copied by specifying dirty boxes on the resource. However, the dirty regions may be expanded to optimize alignment. 	
        /// </remarks>	
        /// <param name="pDirtyBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure, specifying the dirty region to add. Specifying NULL expands the dirty region to cover the entire volume texture.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT AddDirtyBox([None] const D3DBOX* pDirtyBox)</unmanaged>
        public SlimDX2.Result AddDirtyBox(ref SlimDX2.Direct3D9.Box pDirtyBox) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pDirtyBox_ = &pDirtyBox)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, pDirtyBox_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DCubeTexture9</unmanaged>
    [Guid("FFF32F81-D953-473a-9223-93D652ABA93F")]
    public partial class CubeTexture : SlimDX2.Direct3D9.BaseTexture {
        public CubeTexture(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves a description of one face of the specified cube texture level.	
        /// </summary>	
        /// <remarks>	
        ///  The <see cref="SlimDX2.Direct3D9.SurfaceDescription"/> structure contains Width and Height members, which describe the size of one face in the cube. To get the size of the entire cube, multiply six (the number of cube faces) by the product of Width and Height. 	
        /// </remarks>	
        /// <param name="level"> Specifies a level of a mipmapped cube texture. </param>
        /// <param name="pDesc"> Pointer to a <see cref="SlimDX2.Direct3D9.SurfaceDescription"/> structure, describing one face of the specified cube texture level. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetLevelDesc([None] UINT Level,[Out] D3DSURFACE_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetLevelDescription(int level, out SlimDX2.Direct3D9.SurfaceDescription pDesc) {
            unsafe {
                pDesc = new SlimDX2.Direct3D9.SurfaceDescription();
                SlimDX2.Result __result__;
                fixed (void* pDesc_ = &pDesc)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, level, pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a cube texture map surface.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DSurface9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="faceType"> Member of the <see cref="SlimDX2.Direct3D9.CubemapFaces"/> enumerated type, identifying a cube map face.  </param>
        /// <param name="level"> Specifies a level of a mipmapped cube texture.  </param>
        /// <param name="ppCubeMapSurface"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the returned cube texture map surface.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetCubeMapSurface([None] D3DCUBEMAP_FACES FaceType,[None] UINT Level,[Out] IDirect3DSurface9** ppCubeMapSurface)</unmanaged>
        public SlimDX2.Result GetCubeMapSurface(SlimDX2.Direct3D9.CubemapFaces faceType, int level, out SlimDX2.Direct3D9.Surface ppCubeMapSurface) {
            unsafe {
                IntPtr ppCubeMapSurface_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, unchecked((int)faceType), level, &ppCubeMapSurface_);
                ppCubeMapSurface = (ppCubeMapSurface_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(ppCubeMapSurface_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Locks a rectangle on a cube texture resource.	
        /// </summary>	
        /// <remarks>	
        ///  For performance reasons, dirty regions are only recorded for level zero of a texture. Dirty regions are automatically recorded when IDirect3DCubeTexture9::LockRect is called without D3DLOCK_NO_DIRTY_UPDATE or D3DLOCK_READONLY. See <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/> for more information. Cube textures created with D3DPOOL_DEFAULT are not lockable. Cube textures created in video memory are lockable when created with {{USAGE_DYNAMIC}}. The only lockable format for a depth-stencil texture is <see cref="SlimDX2.Direct3D9.Format.MtD16Lockable"/>. 	
        /// </remarks>	
        /// <param name="faceType"> Member of the <see cref="SlimDX2.Direct3D9.CubemapFaces"/> enumerated type, identifying a cube map face.  </param>
        /// <param name="level"> Specifies a level of a mipmapped cube texture.  </param>
        /// <param name="pLockedRect"> Pointer to a <see cref="SlimDX2.Direct3D9.LockedRect"/> structure, describing the region to lock.  </param>
        /// <param name="pRect"> Pointer to a rectangle to lock. Specified by a pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifying NULL for this parameter expands the dirty region to cover the entire cube texture. </param>
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY   You may not specify a subrect when using D3DLOCK_DISCARD. For a description of the flags, see {{D3DLOCK}}.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if one or more of the arguments is invalid. </returns>
        /// <unmanaged>HRESULT LockRect([None] D3DCUBEMAP_FACES FaceType,[None] UINT Level,[None] D3DLOCKED_RECT* pLockedRect,[None] const RECT* pRect,[None] int Flags)</unmanaged>
        public SlimDX2.Result LockRect(SlimDX2.Direct3D9.CubemapFaces faceType, int level, ref SlimDX2.Direct3D9.LockedRect pLockedRect, ref SlimDX2.Rectangle pRect, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pLockedRect_ = &pLockedRect)
                    fixed (void* pRect_ = &pRect)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, unchecked((int)faceType), level, pLockedRect_, pRect_, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks a rectangle on a cube texture resource.	
        /// </summary>	
        /// <param name="faceType"> Member of the <see cref="SlimDX2.Direct3D9.CubemapFaces"/> enumerated type, identifying a cube map face.  </param>
        /// <param name="level"> Specifies a level of a mipmapped cube texture.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT UnlockRect([None] D3DCUBEMAP_FACES FaceType,[None] UINT Level)</unmanaged>
        public SlimDX2.Result UnlockRect(SlimDX2.Direct3D9.CubemapFaces faceType, int level) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, unchecked((int)faceType), level);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds a dirty region to a cube texture resource.	
        /// </summary>	
        /// <remarks>	
        ///  For performance reasons, dirty regions are only recorded for level zero of a texture. For sublevels, it is assumed that the corresponding (scaled) rectangle or box is also dirty. Dirty regions are automatically recorded when <see cref="SlimDX2.Direct3D9.CubeTexture.LockRect"/> is called without {{D3DLOCK_NO_DIRTY_UPDATE}} or {{D3DLOCK_READONLY}}. The destination surface of <see cref="SlimDX2.Direct3D9.Device.UpdateSurface"/> is also marked dirty automatically. Using {{D3DLOCK_NO_DIRTY_UPDATE}} and explicitly specifying dirty regions can be used to increase the efficiency of <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/>. Using this method, applications can optimize what subset of a resource is copied by specifying dirty regions on the resource. However, the dirty regions may be expanded to optimize alignment. 	
        /// </remarks>	
        /// <param name="faceType"> Member of the <see cref="SlimDX2.Direct3D9.CubemapFaces"/> enumerated type, identifying the cube map face.  </param>
        /// <param name="pDirtyRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure, specifying the dirty region. Specifying NULL expands the dirty region to cover the entire cube texture.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT AddDirtyRect([None] D3DCUBEMAP_FACES FaceType,[None] const RECT* pDirtyRect)</unmanaged>
        public SlimDX2.Result AddDirtyRect(SlimDX2.Direct3D9.CubemapFaces faceType, ref SlimDX2.Rectangle pDirtyRect) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pDirtyRect_ = &pDirtyRect)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, unchecked((int)faceType), pDirtyRect_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DVertexBuffer9</unmanaged>
    [Guid("B64BB1B5-FD70-4df6-BF91-19D0A12455E3")]
    public partial class VertexBuffer : SlimDX2.Direct3D9.Resource {
        public VertexBuffer(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves a description of the vertex buffer resource.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDesc([Out] D3DVERTEXBUFFER_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.VertexbufferDescription Description {
                get { SlimDX2.Direct3D9.VertexbufferDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Locks a range of vertex data and obtains a pointer to the vertex buffer memory.	
        /// </summary>	
        /// <remarks>	
        ///  As a general rule, do not hold a lock across more than one frame. When working with vertex buffers, you are allowed to make multiple lock calls; however, you must ensure that the number of lock calls match the number of unlock calls. DrawPrimitive calls will not succeed with any outstanding lock count on any currently set vertex buffer. The D3DLOCK_DISCARD and D3DLOCK_NOOVERWRITE flags are valid only on buffers created with D3DUSAGE_DYNAMIC. For information about using D3DLOCK_DISCARD or D3DLOCK_NOOVERWRITE with IDirect3DVertexBuffer9::Lock, see {{Using Dynamic Vertex and Index Buffers}}. 	
        /// </remarks>	
        /// <param name="offsetToLock"> Offset into the vertex data to lock, in bytes. To lock the entire vertex buffer, specify 0 for both parameters, SizeToLock and OffsetToLock. </param>
        /// <param name="sizeToLock"> Size of the vertex data to lock, in bytes. To lock the entire vertex buffer, specify 0 for both parameters, SizeToLock and OffsetToLock. </param>
        /// <param name="ppbData"> VOID* pointer to a memory buffer containing the returned vertex data.  </param>
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY D3DLOCK_NOOVERWRITE   For a description of the flags, see {{D3DLOCK}}.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT Lock([None] UINT OffsetToLock,[None] UINT SizeToLock,[None] void** ppbData,[None] int Flags)</unmanaged>
        public SlimDX2.Result Lock(int offsetToLock, int sizeToLock, IntPtr ppbData, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, offsetToLock, sizeToLock, (void*)ppbData, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks vertex data.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT Unlock()</unmanaged>
        public SlimDX2.Result Unlock() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a description of the vertex buffer resource.	
        /// </summary>	
        /// <param name="pDesc"> Pointer to a <see cref="SlimDX2.Direct3D9.VertexbufferDescription"/> structure, describing the returned vertex buffer.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the argument is invalid. </returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3DVERTEXBUFFER_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.VertexbufferDescription pDesc) {
            unsafe {
                pDesc = new SlimDX2.Direct3D9.VertexbufferDescription();
                SlimDX2.Result __result__;
                fixed (void* pDesc_ = &pDesc)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DIndexBuffer9</unmanaged>
    [Guid("7C9DD65E-D3F7-4529-ACEE-785830ACDE35")]
    public partial class IndexBuffer : SlimDX2.Direct3D9.Resource {
        public IndexBuffer(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves a description of the index buffer resource.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDesc([Out] D3DINDEXBUFFER_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.IndexbufferDescription Description {
                get { SlimDX2.Direct3D9.IndexbufferDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Locks a range of index data and obtains a pointer to the index buffer memory.	
        /// </summary>	
        /// <remarks>	
        ///  As a general rule, do not hold a lock across more than one frame. When working with index buffers, you are allowed to make multiple lock calls. However, you must ensure that the number of lock calls match the number of unlock calls. <see cref="SlimDX2.Direct3D9.Device.DrawIndexedPrimitive"/> calls will not succeed with any outstanding lock count on any currently set index buffer.  The D3DLOCK_DISCARD and D3DLOCK_NOOVERWRITE flags are valid only on buffers created with D3DUSAGE_DYNAMIC. See {{Programming Tips (Direct3D 9)}} for information about using D3DLOCK_DISCARD or D3DLOCK_NOOVERWRITE. 	
        /// </remarks>	
        /// <param name="offsetToLock"> Offset into the index data to lock, in bytes. Lock the entire index buffer by specifying 0 for both parameters, SizeToLock and OffsetToLock.  </param>
        /// <param name="sizeToLock"> Size of the index data to lock, in bytes. Lock the entire index buffer by specifying 0 for both parameters, SizeToLock and OffsetToLock. </param>
        /// <param name="ppbData"> VOID* pointer to a memory buffer containing the returned index data.  </param>
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY D3DLOCK_NOOVERWRITE   For a description of the flags, see {{D3DLOCK}}.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT Lock([None] UINT OffsetToLock,[None] UINT SizeToLock,[None] void** ppbData,[None] int Flags)</unmanaged>
        public SlimDX2.Result Lock(int offsetToLock, int sizeToLock, IntPtr ppbData, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, offsetToLock, sizeToLock, (void*)ppbData, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks index data.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT Unlock()</unmanaged>
        public SlimDX2.Result Unlock() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a description of the index buffer resource.	
        /// </summary>	
        /// <param name="pDesc"> Pointer to a <see cref="SlimDX2.Direct3D9.IndexbufferDescription"/> structure, describing the returned index buffer.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the argument is invalid. </returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3DINDEXBUFFER_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.IndexbufferDescription pDesc) {
            unsafe {
                pDesc = new SlimDX2.Direct3D9.IndexbufferDescription();
                SlimDX2.Result __result__;
                fixed (void* pDesc_ = &pDesc)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DSurface9</unmanaged>
    [Guid("0CFBAF3A-9FF6-429a-99B3-A2796AF8B89B")]
    public partial class Surface : SlimDX2.Direct3D9.Resource {
        public Surface(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves a description of the surface.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDesc([Out] D3DSURFACE_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.SurfaceDescription Description {
                get { SlimDX2.Direct3D9.SurfaceDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves a device context.	
        /// </summary>	
        /// <remarks>	
        ///  The following restrictions apply.  IDirect3DSurface9::GetDC is valid on the following formats only: D3DFMT_R5G6B5, D3DFMT_X1R5G5B5, D3DFMT_R8G8B8, and D3DFMT_X8R8G8B8. Formats that contain Alpha are not supported because the GDI implementations don't have a well-defined behavior on the alpha channel. For more information about formats, see <see cref="SlimDX2.Direct3D9.Format"/>. Only one device context per surface can be returned at a time. IDirect3DSurface9::GetDC will fail if the surface is already locked. If the surface is a member of a mipmap or cubemap, IDirect3DSurface9::GetDC fails if any other mipmap or cubemap member is locked. IDirect3DSurface9::GetDC fails on render targets unless they were created lockable (or, in the case of back buffers, with the D3DPRESENTFLAG_LOCKABLE_BACKBUFFER flag). For surfaces not created with <see cref="SlimDX2.Direct3D9.Device.CreateOffscreenPlainSurface"/>, IDirect3DSurface9::GetDC will fail on default pool (D3DPOOL_DEFAULT) surfaces unless they are dynamic (D3DUSAGE_DYNAMIC) or are lockable render targets. IDirect3DSurface9::GetDC will fail on D3DPOOL_SCRATCH surfaces.  When a device context is outstanding on a surface, the application may not call these methods:  IDirect3DCubeTexture9 <see cref="SlimDX2.Direct3D9.CubeTexture.LockRect"/>  IDirect3DDevice9 <see cref="SlimDX2.Direct3D9.Device.ColorFill"/>   <see cref="SlimDX2.Direct3D9.Device.StretchRect"/>   <see cref="SlimDX2.Direct3D9.Device.UpdateSurface"/>   <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/>  IDirect3DSurface9 <see cref="SlimDX2.Direct3D9.Surface.LockRect"/>  IDirect3DSwapChain9 <see cref="SlimDX2.Direct3D9.SwapChain.Present"/> * IDirect3DTexture9 <see cref="SlimDX2.Direct3D9.Texture.LockRect"/>     * (on a swap chain that contains the surface) IDirect3DSurface9::GetDC causes an implicit lock; do not retain the device context for later use. Call <see cref="SlimDX2.Direct3D9.Surface.ReleaseDC"/> to release it.	 It is valid to call IDirect3DSurface9::GetDC/<see cref="SlimDX2.Direct3D9.Surface.ReleaseDC"/> on levels of a mipmap or cubemap, however, these calls will be slow to all miplevels except the topmost level, and GDI operations to these miplevels will not be accelerated. The hdc provides access to Win32 and GDI functionality. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDC([Out] HDC* phdc)</unmanaged>
        public IntPtr DC {
                get { IntPtr __output__; GetDC(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Provides access to the parent cube texture or texture (mipmap) object, if this surface is a child level of a cube texture or a mipmap. This method can also provide access to the parent swap chain if the surface is a back-buffer child.	
        /// </summary>	
        /// <remarks>	
        ///  If the surface is created using {{CreateRenderTarget}} or {{CreateOffscreenPlainSurface}} or {{CreateDepthStencilSurface}}, the surface is considered stand alone. In this case, GetContainer will return the Direct3D device used to create the surface. If the call succeeds, the reference count of the container is increased by one. Here's an example getting the parent texture of a mip surface. 	
        /// <code> // Assumes pSurface is a valid IDirect3DSurface9 pointer	
        /// void *pContainer = NULL;	
        /// IDirect3DTexture9 *pTexture = NULL;	
        /// HRESULT hr = pSurface-&gt;GetContainer(IID_IDirect3DTexture9, &amp;pContainer);	
        /// if (SUCCEEDED(hr) &amp;&amp; pContainer)	
        /// { pTexture = (IDirect3DTexture9 *)pContainer;	
        /// } </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="riid"> Reference identifier of the container being requested.  </param>
        /// <param name="ppContainer"> Address of a pointer to fill with the container pointer if the query succeeds. See Remarks.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetContainer([None] REFIID riid,[None] void** ppContainer)</unmanaged>
        public SlimDX2.Result GetContainer(Guid riid, IntPtr ppContainer) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, &riid, (void*)ppContainer);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a description of the surface.	
        /// </summary>	
        /// <param name="pDesc"> Pointer to a <see cref="SlimDX2.Direct3D9.SurfaceDescription"/> structure, describing the surface.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the argument is invalid. </returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3DSURFACE_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.SurfaceDescription pDesc) {
            unsafe {
                pDesc = new SlimDX2.Direct3D9.SurfaceDescription();
                SlimDX2.Result __result__;
                fixed (void* pDesc_ = &pDesc)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Locks a rectangle on a surface.	
        /// </summary>	
        /// <remarks>	
        ///  If the {{D3DLOCK_DONOTWAIT}} flag is specified and the driver cannot lock the surface immediately, IDirect3DSurface9::LockRect will return D3DERR_WASSTILLDRAWING so that an application can use the CPU cycles while waiting for the driver to lock the surface. The only lockable format for a depth-stencil surface is D3DFMT_D16_LOCKABLE. See <see cref="SlimDX2.Direct3D9.Format"/>. For performance reasons, dirty regions are recorded only for level zero of a texture. Dirty regions are automatically recorded when IDirect3DSurface9::LockRect is called without {{D3DLOCK_NO_DIRTY_UPDATE}} or {{D3DLOCK_READONLY}}. See <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/> for more information. A multisample back buffer cannot be locked. This method cannot retrieve data from a surface that is is contained by a texture resource created with {{D3DUSAGE_RENDERTARGET}} because such a texture must be assigned to D3DPOOL_DEFAULT memory and is therefore not lockable. In this case, use instead <see cref="SlimDX2.Direct3D9.Device.GetRenderTargetData"/> to copy texture data from device memory to system memory. 	
        /// </remarks>	
        /// <param name="pLockedRect"> Pointer to a <see cref="SlimDX2.Direct3D9.LockedRect"/> structure that describes the locked region.  </param>
        /// <param name="pRect"> Pointer to a rectangle to lock. Specified by a pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifying NULL for this parameter expands the dirty region to cover the entire surface.  </param>
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_DONOTWAIT D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY   You may not specify a subrect when using D3DLOCK_DISCARD. For a description of the flags, see {{D3DLOCK}}.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL or D3DERR_WASSTILLDRAWING. </returns>
        /// <unmanaged>HRESULT LockRect([None] D3DLOCKED_RECT* pLockedRect,[None] const RECT* pRect,[None] int Flags)</unmanaged>
        public SlimDX2.Result LockRect(ref SlimDX2.Direct3D9.LockedRect pLockedRect, ref SlimDX2.Rectangle pRect, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pLockedRect_ = &pLockedRect)
                    fixed (void* pRect_ = &pRect)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, pLockedRect_, pRect_, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks a rectangle on a surface.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT UnlockRect()</unmanaged>
        public SlimDX2.Result UnlockRect() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a device context.	
        /// </summary>	
        /// <remarks>	
        ///  The following restrictions apply.  IDirect3DSurface9::GetDC is valid on the following formats only: D3DFMT_R5G6B5, D3DFMT_X1R5G5B5, D3DFMT_R8G8B8, and D3DFMT_X8R8G8B8. Formats that contain Alpha are not supported because the GDI implementations don't have a well-defined behavior on the alpha channel. For more information about formats, see <see cref="SlimDX2.Direct3D9.Format"/>. Only one device context per surface can be returned at a time. IDirect3DSurface9::GetDC will fail if the surface is already locked. If the surface is a member of a mipmap or cubemap, IDirect3DSurface9::GetDC fails if any other mipmap or cubemap member is locked. IDirect3DSurface9::GetDC fails on render targets unless they were created lockable (or, in the case of back buffers, with the D3DPRESENTFLAG_LOCKABLE_BACKBUFFER flag). For surfaces not created with <see cref="SlimDX2.Direct3D9.Device.CreateOffscreenPlainSurface"/>, IDirect3DSurface9::GetDC will fail on default pool (D3DPOOL_DEFAULT) surfaces unless they are dynamic (D3DUSAGE_DYNAMIC) or are lockable render targets. IDirect3DSurface9::GetDC will fail on D3DPOOL_SCRATCH surfaces.  When a device context is outstanding on a surface, the application may not call these methods:  IDirect3DCubeTexture9 <see cref="SlimDX2.Direct3D9.CubeTexture.LockRect"/>  IDirect3DDevice9 <see cref="SlimDX2.Direct3D9.Device.ColorFill"/>   <see cref="SlimDX2.Direct3D9.Device.StretchRect"/>   <see cref="SlimDX2.Direct3D9.Device.UpdateSurface"/>   <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/>  IDirect3DSurface9 <see cref="SlimDX2.Direct3D9.Surface.LockRect"/>  IDirect3DSwapChain9 <see cref="SlimDX2.Direct3D9.SwapChain.Present"/> * IDirect3DTexture9 <see cref="SlimDX2.Direct3D9.Texture.LockRect"/>     * (on a swap chain that contains the surface) IDirect3DSurface9::GetDC causes an implicit lock; do not retain the device context for later use. Call <see cref="SlimDX2.Direct3D9.Surface.ReleaseDC"/> to release it.	 It is valid to call IDirect3DSurface9::GetDC/<see cref="SlimDX2.Direct3D9.Surface.ReleaseDC"/> on levels of a mipmap or cubemap, however, these calls will be slow to all miplevels except the topmost level, and GDI operations to these miplevels will not be accelerated. The hdc provides access to Win32 and GDI functionality. 	
        /// </remarks>	
        /// <param name="phdc"> Pointer to the device context for the surface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the argument is invalid. </returns>
        /// <unmanaged>HRESULT GetDC([Out] HDC* phdc)</unmanaged>
        internal SlimDX2.Result GetDC(out IntPtr phdc) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* phdc_ = &phdc)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, phdc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Release a device context handle.	
        /// </summary>	
        /// <remarks>	
        ///  An hdc is a Windows resource. It must be released after use so Windows can return it to the pool of available resources. This method will release only the device context returned by <see cref="SlimDX2.Direct3D9.Surface.GetDC"/>. Otherwise, this method will fail. 	
        /// </remarks>	
        /// <param name="hdc"> Handle to a device context. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the argument is invalid. </returns>
        /// <unmanaged>HRESULT ReleaseDC([None] HDC hdc)</unmanaged>
        public SlimDX2.Result ReleaseDC(IntPtr hdc) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, (void*)hdc);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DVolume9</unmanaged>
    [Guid("24F416E6-1F67-4aa7-B88E-D33F6F3128A1")]
    public partial class Volume : SlimDX2.ComObject {
        public Volume(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the device associated with a volume.	
        /// </summary>	
        /// <remarks>	
        ///  This method allows navigation to the owning device object.  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DDevice9 interface results in a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves a description of the volume.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDesc([Out] D3DVOLUME_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.VolumeDescription Description {
                get { SlimDX2.Direct3D9.VolumeDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the device associated with a volume.	
        /// </summary>	
        /// <remarks>	
        ///  This method allows navigation to the owning device object.  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DDevice9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="ppDevice"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface to fill with the device pointer, if the query succeeds.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device ppDevice) {
            unsafe {
                IntPtr ppDevice_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &ppDevice_);
                ppDevice = (ppDevice_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppDevice_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Associates data with the volume that is intended for use by the application, not by Direct3D.	
        /// </summary>	
        /// <remarks>	
        ///  Direct3D does not manage the memory at pData. If this buffer was dynamically allocated, it is the calling application's responsibility to free the memory. Data is passed by value, and multiple sets of data can be associated with a single volume. 	
        /// </remarks>	
        /// <param name="refguid"> Reference to the globally unique identifier that identifies the private data to set. </param>
        /// <param name="pData"> Pointer to a buffer that contains the data to associate with the volume.  </param>
        /// <param name="sizeOfData"> Size of the buffer at pData in bytes.  </param>
        /// <param name="flags"> Value that describes the type of data being passed, or indicates to the application that the data should be invalidated when the resource changes.    ItemDescription  (none)  If no flags are specified, Direct3D allocates memory to hold the data within the buffer and copies the data into the new buffer. The buffer allocated by Direct3D is automatically freed, as appropriate.   D3DSPD_IUNKNOWN  The data at pData is a pointer to an <see cref="SlimDX2.ComObject"/> interface. SizeOfData must be set to the size of a pointer to an IUnknown interface, sizeof(IUnknown*). Direct3D automatically calls IUnknown through pData and IUnknown when the private data is destroyed. Private data will be destroyed by a subsequent call to IDirect3DVolume9::SetPrivateData with the same GUID, a subsequent call to <see cref="SlimDX2.Direct3D9.Volume.FreePrivateData"/>, or when the <see cref="SlimDX2.Direct3D9.Direct3D9"/> object is released. For more information, see Remarks.     </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT SetPrivateData([None] REFGUID refguid,[None] const void* pData,[None] int SizeOfData,[None] int Flags)</unmanaged>
        public SlimDX2.Result SetPrivateData(Guid refguid, IntPtr pData, int sizeOfData, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, &refguid, (void*)pData, sizeOfData, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copies the private data associated with the volume to a provided buffer.	
        /// </summary>	
        /// <param name="refguid"> Reference to (C++) or address of (C) the globally unique identifier that identifies the private data to retrieve.  </param>
        /// <param name="pData"> Pointer to a previously allocated buffer to fill with the requested private data if the call succeeds. The application calling this method is responsible for allocating and releasing this buffer. If this parameter is NULL, this method will return the buffer size in pSizeOfData. </param>
        /// <param name="pSizeOfData"> Pointer to the size of the buffer at  pData, in bytes. If this value is less than the actual size of the private data, such as 0, the method sets this parameter to the required buffer size, and the method returns D3DERR_MOREDATA.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_MOREDATA, D3DERR_NOTFOUND. </returns>
        /// <unmanaged>HRESULT GetPrivateData([None] REFGUID refguid,[None] void* pData,[Out] int* pSizeOfData)</unmanaged>
        public SlimDX2.Result GetPrivateData(Guid refguid, IntPtr pData, out int pSizeOfData) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pSizeOfData_ = &pSizeOfData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, &refguid, (void*)pData, pSizeOfData_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Frees the specified private data associated with this volume.	
        /// </summary>	
        /// <remarks>	
        ///  Direct3D calls this method automatically when a volume is released.  	
        /// </remarks>	
        /// <param name="refguid"> Reference to the globally unique identifier that identifies the private data to free. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTFOUND. </returns>
        /// <unmanaged>HRESULT FreePrivateData([None] REFGUID refguid)</unmanaged>
        public SlimDX2.Result FreePrivateData(Guid refguid) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, &refguid);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Provides access to the parent volume texture object, if this surface is a child level of a volume texture.	
        /// </summary>	
        /// <remarks>	
        ///  If the call succeeds, the reference count of the container is increased by one. Here's an example getting the parent volume texture of a volume texture. 	
        /// <code> // Assumes pSurface is a valid IDirect3DVolume9 pointer	
        /// void *pContainer = NULL;	
        /// IDirect3DVolumeTexture9 *pVolumeTexture = NULL;	
        /// HRESULT hr = pVolume-&gt;GetContainer(IID_IDirect3DVolumeTexture9, &amp;pContainer);	
        /// if (SUCCEEDED(hr) &amp;&amp; pContainer)	
        /// { pVolumeTexture = (IDirect3DVolumeTexture9 *)pContainer; </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="riid"> Reference identifier of the volume being requested.  </param>
        /// <param name="ppContainer"> Address of a pointer to fill with the container pointer, if the query succeeds.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetContainer([None] REFIID riid,[None] void** ppContainer)</unmanaged>
        public SlimDX2.Result GetContainer(Guid riid, IntPtr ppContainer) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, &riid, (void*)ppContainer);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a description of the volume.	
        /// </summary>	
        /// <param name="pDesc"> Pointer to a <see cref="SlimDX2.Direct3D9.VolumeDescription"/> structure, describing the volume.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if the argument is invalid. </returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3DVOLUME_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.VolumeDescription pDesc) {
            unsafe {
                pDesc = new SlimDX2.Direct3D9.VolumeDescription();
                SlimDX2.Result __result__;
                fixed (void* pDesc_ = &pDesc)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Locks a box on a volume resource.	
        /// </summary>	
        /// <remarks>	
        ///  For performance reasons, dirty regions are only recorded for level zero of a texture. Dirty regions are automatically recorded when IDirect3DVolume9::LockBox is called without D3DLOCK_NO_DIRTY_UPDATE or D3DLOCK_READONLY. See <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/> for more information. 	
        /// </remarks>	
        /// <param name="pLockedVolume"> Pointer to a <see cref="SlimDX2.Direct3D9.LockedBox"/> structure, describing the locked region.  </param>
        /// <param name="pBox"> Pointer to a box to lock. Specified by a pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifying NULL for this parameter locks the entire volume.  </param>
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY   For a description of the flags, see {{D3DLOCK}}.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT LockBox([None] D3DLOCKED_BOX* pLockedVolume,[None] const D3DBOX* pBox,[None] int Flags)</unmanaged>
        public SlimDX2.Result LockBox(ref SlimDX2.Direct3D9.LockedBox pLockedVolume, ref SlimDX2.Direct3D9.Box pBox, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pLockedVolume_ = &pLockedVolume)
                    fixed (void* pBox_ = &pBox)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, pLockedVolume_, pBox_, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks a box on a volume resource.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT UnlockBox()</unmanaged>
        public SlimDX2.Result UnlockBox() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DSwapChain9</unmanaged>
    [Guid("794950F2-ADFC-458a-905E-10A10B0B503B")]
    public partial class SwapChain : SlimDX2.ComObject {
        public SwapChain(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Generates a copy of the swapchain's front buffer and places that copy in a system memory buffer provided by the application.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DSurface9 interface results in a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetFrontBufferData([Out] IDirect3DSurface9* pDestSurface)</unmanaged>
        public SlimDX2.Direct3D9.Surface FrontBufferData {
                get { SlimDX2.Direct3D9.Surface __output__; GetFrontBufferData(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Returns information describing the raster of the monitor on which the swap chain is presented.	
        /// </summary>	
        /// <unmanaged>HRESULT GetRasterStatus([Out] D3DRASTER_STATUS* pRasterStatus)</unmanaged>
        public SlimDX2.Direct3D9.RasterStatus RasterStatus {
                get { SlimDX2.Direct3D9.RasterStatus __output__; GetRasterStatus(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the display mode's spatial resolution, color resolution, and refresh frequency.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDisplayMode([Out] D3DDISPLAYMODE* pMode)</unmanaged>
        public SlimDX2.Direct3D9.Displaymode DisplayMode {
                get { SlimDX2.Direct3D9.Displaymode __output__; GetDisplayMode(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the device associated with the swap chain.	
        /// </summary>	
        /// <remarks>	
        ///  This method allows navigation to the owning device object. Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DDevice9 interface results in a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the presentation parameters associated with a swap chain.	
        /// </summary>	
        /// <remarks>	
        ///  This method can be used to see the presentation parameters of the parent swap chain of a surface (a back buffer, for instance). The parent swap chain can be retrieved with <see cref="SlimDX2.Direct3D9.Surface.GetContainer"/>. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetPresentParameters([Out] D3DPRESENT_PARAMETERS* pPresentationParameters)</unmanaged>
        public SlimDX2.Direct3D9.PresentParameters PresentParameters {
                get { SlimDX2.Direct3D9.PresentParameters __output__; GetPresentParameters(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Presents the contents of the next buffer in the sequence of back buffers owned by the swap chain.	
        /// </summary>	
        /// <remarks>	
        ///  The {{Present}} method is a shortcut to Present. Present has been updated to take a flag allowing the application to request that the method return immediately when the driver reports that it cannot schedule a presentation. If necessary, a stretch operation is applied to transfer the pixels within the source rectangle to the destination rectangle in the client area of the target window. Present will fail if called between {{BeginScene}} and {{EndScene}} pairs unless the render target is not the current render target (such as the back buffer you get from creating an additional swap chain). This is a new behavior for Direct3D 9. 	
        /// </remarks>	
        /// <param name="pSourceRect"> Pointer to the source rectangle (see <see cref="SlimDX2.Rectangle"/>). Use NULL to present the entire surface. This value must be NULL unless the swap chain was created with D3DSWAPEFFECT_COPY. If the rectangle exceeds the source surface, the rectangle is clipped to the source surface.  </param>
        /// <param name="pDestRect"> Pointer to the destination rectangle in client coordinates (see <see cref="SlimDX2.Rectangle"/>). This value must be NULL unless the swap chain was created with D3DSWAPEFFECT_COPY. Use NULL to fill the entire client area. If the rectangle exceeds the destination client area, the rectangle is clipped to the destination client area.  </param>
        /// <param name="hDestWindowOverride"> Destination window whose client area is taken as the target for this presentation. If this value is NULL, the hWndDeviceWindow member of <see cref="SlimDX2.Direct3D9.PresentParameters"/> is taken.  </param>
        /// <param name="pDirtyRegion"> This value must be NULL unless the swap chain was created with <see cref="SlimDX2.Direct3D9.Swapeffect.Copy"/>. See {{Flipping Surfaces (Direct3D 9)}}. If this value is non-NULL, the contained region is expressed in back buffer coordinates. The rectangles within the region are the minimal set of pixels that need to be updated. This method takes these rectangles into account when optimizing the presentation by copying only the pixels within the region, or some suitably expanded set of rectangles. This is an aid to optimization only, and the application should not rely on the region being copied exactly. The implementation may choose to copy the whole source rectangle. </param>
        /// <param name="dwFlags"> Allows the application to request that the method return immediately when the driver reports that it cannot schedule a presentation. Valid values are 0, or any combination of {{D3DPRESENT_DONOTWAIT}} or {{D3DPRESENT_LINEAR_CONTENT}}.   If dwFlags = 0, this method behaves as it did prior to Direct3D 9. Present will spin until the hardware is free, without returning an error. If dwFlags = {{D3DPRESENT_DONOTWAIT}}, and the hardware is busy processing or waiting for a vertical sync interval, the method will return D3DERR_WASSTILLDRAWING. If dwFlags = {{D3DPRESENT_LINEAR_CONTENT}}, gamma correction is performed from linear space to sRGB for windowed swap chains. This flag will take effect only when the driver exposes {{D3DCAPS3_LINEAR_TO_SRGB_PRESENTATION}} (see {{Gamma (Direct3D 9)}}). Appliations should specify this flag if the backbuffer format is 16-bit floating point in order to match windowed mode present to fullscreen gamma behavior.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_DEVICELOST, D3DERR_DRIVERINTERNALERROR, D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT Present([None] const RECT* pSourceRect,[None] const RECT* pDestRect,[None] HWND hDestWindowOverride,[None] const RGNDATA* pDirtyRegion,[None] int dwFlags)</unmanaged>
        public SlimDX2.Result Present(ref SlimDX2.Rectangle pSourceRect, ref SlimDX2.Rectangle pDestRect, IntPtr hDestWindowOverride, ref SlimDX2.Windows.Rgndata pDirtyRegion, int dwFlags) {
            unsafe {
                SlimDX2.Windows.Rgndata.__Native pDirtyRegion_ = new SlimDX2.Windows.Rgndata.__Native();
                pDirtyRegion.__MarshalTo(ref pDirtyRegion_);
                SlimDX2.Result __result__;
                fixed (void* pSourceRect_ = &pSourceRect)
                    fixed (void* pDestRect_ = &pDestRect)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, pSourceRect_, pDestRect_, (void*)hDestWindowOverride, &pDirtyRegion_, dwFlags);
                pDirtyRegion.__MarshalFrom(ref pDirtyRegion_);
                pDirtyRegion_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Generates a copy of the swapchain's front buffer and places that copy in a system memory buffer provided by the application.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DSurface9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="pDestSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface that will receive a copy of the swapchain's front buffer. The data is returned in successive rows with no intervening space, starting from the vertically highest row to the lowest.  For windowed mode, the size of the destination surface should be the size of the desktop. For full screen mode, the size of the destination surface should be the screen size.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If BackBuffer exceeds or equals the total number of back buffers, the function fails and returns D3DERR_INVALIDCALL.   </returns>
        /// <unmanaged>HRESULT GetFrontBufferData([Out] IDirect3DSurface9* pDestSurface)</unmanaged>
        internal SlimDX2.Result GetFrontBufferData(out SlimDX2.Direct3D9.Surface pDestSurface) {
            unsafe {
                IntPtr pDestSurface_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, &pDestSurface_);
                pDestSurface = (pDestSurface_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(pDestSurface_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a back buffer from the swap chain of the device.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Surface"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DSurface9 interface results in a memory leak. You must release any surfaces obtained through this method before releasing the swap chain it belongs to. 	
        /// </remarks>	
        /// <param name="iBackBuffer"> Index of the back buffer object to return. Back buffers are numbered from 0 to the total number of back buffers - 1. A value of 0 returns the first back buffer, not the front buffer. The front buffer is not accessible through this method. Use <see cref="SlimDX2.Direct3D9.SwapChain.GetFrontBufferData"/> to retrieve a copy of the front buffer. </param>
        /// <param name="type"> Stereo view is not supported in Direct3D 9, so the only valid value for this parameter is D3DBACKBUFFER_TYPE_MONO.  </param>
        /// <param name="ppBackBuffer"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the returned back buffer surface.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If BackBuffer exceeds or equals the total number of back buffers, then the function fails and returns D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetBackBuffer([None] UINT iBackBuffer,[None] D3DBACKBUFFER_TYPE Type,[Out] IDirect3DSurface9** ppBackBuffer)</unmanaged>
        public SlimDX2.Result GetBackBuffer(int iBackBuffer, SlimDX2.Direct3D9.BackbufferType type, out SlimDX2.Direct3D9.Surface ppBackBuffer) {
            unsafe {
                IntPtr ppBackBuffer_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, iBackBuffer, unchecked((int)type), &ppBackBuffer_);
                ppBackBuffer = (ppBackBuffer_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(ppBackBuffer_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns information describing the raster of the monitor on which the swap chain is presented.	
        /// </summary>	
        /// <param name="pRasterStatus"> Pointer to a <see cref="SlimDX2.Direct3D9.RasterStatus"/> structure filled with information about the position or other status of the raster on the monitor driven by this adapter.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. D3DERR_INVALIDCALL is returned if pRasterStatus is invalid or if the device does not support reading the current scan line. To determine if the device supports reading the scan line, check for the D3DCAPS_READ_SCANLINE flag in the Caps member of <see cref="SlimDX2.Direct3D9.Caps9"/>.  </returns>
        /// <unmanaged>HRESULT GetRasterStatus([Out] D3DRASTER_STATUS* pRasterStatus)</unmanaged>
        internal SlimDX2.Result GetRasterStatus(out SlimDX2.Direct3D9.RasterStatus pRasterStatus) {
            unsafe {
                pRasterStatus = new SlimDX2.Direct3D9.RasterStatus();
                SlimDX2.Result __result__;
                fixed (void* pRasterStatus_ = &pRasterStatus)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, pRasterStatus_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the display mode's spatial resolution, color resolution, and refresh frequency.	
        /// </summary>	
        /// <param name="pMode"> Pointer to a <see cref="SlimDX2.Direct3D9.Displaymode"/> structure containing data about the display mode of the adapter. As opposed to the display mode of the device, which may not be active if the device does not own full-screen mode.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetDisplayMode([Out] D3DDISPLAYMODE* pMode)</unmanaged>
        internal SlimDX2.Result GetDisplayMode(out SlimDX2.Direct3D9.Displaymode pMode) {
            unsafe {
                pMode = new SlimDX2.Direct3D9.Displaymode();
                SlimDX2.Result __result__;
                fixed (void* pMode_ = &pMode)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, pMode_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the device associated with the swap chain.	
        /// </summary>	
        /// <remarks>	
        ///  This method allows navigation to the owning device object. Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Failure to call {{IUnknown::Release}} when finished using this IDirect3DDevice9 interface results in a memory leak. 	
        /// </remarks>	
        /// <param name="ppDevice"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface to fill with the device pointer, if the query succeeds.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device ppDevice) {
            unsafe {
                IntPtr ppDevice_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, &ppDevice_);
                ppDevice = (ppDevice_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppDevice_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the presentation parameters associated with a swap chain.	
        /// </summary>	
        /// <remarks>	
        ///  This method can be used to see the presentation parameters of the parent swap chain of a surface (a back buffer, for instance). The parent swap chain can be retrieved with <see cref="SlimDX2.Direct3D9.Surface.GetContainer"/>. 	
        /// </remarks>	
        /// <param name="pPresentationParameters"> Pointer to the presentation parameters. See <see cref="SlimDX2.Direct3D9.PresentParameters"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetPresentParameters([Out] D3DPRESENT_PARAMETERS* pPresentationParameters)</unmanaged>
        internal SlimDX2.Result GetPresentParameters(out SlimDX2.Direct3D9.PresentParameters pPresentationParameters) {
            unsafe {
                pPresentationParameters = new SlimDX2.Direct3D9.PresentParameters();
                SlimDX2.Result __result__;
                fixed (void* pPresentationParameters_ = &pPresentationParameters)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, pPresentationParameters_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>IDirect3DQuery9</unmanaged>
    [Guid("d9771460-a695-4f26-bbd3-27b840b541cc")]
    public partial class Query : SlimDX2.ComObject {
        public Query(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the device that is being queried.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the query type.	
        /// </summary>	
        /// <unmanaged>D3DQUERYTYPE GetType()</unmanaged>
        public SlimDX2.Direct3D9.Querytype TypeInfo {
                get { return GetTypeInfo(); }
        }
        
        /// <summary>	
        /// Gets the number of bytes in the query data.	
        /// </summary>	
        /// <unmanaged>int GetDataSize()</unmanaged>
        public int DataSize {
                get { return GetDataSize(); }
        }
        
        /// <summary>	
        /// Gets the device that is being queried.	
        /// </summary>	
        /// <param name="ppDevice"> Pointer to the device being queried. See <see cref="SlimDX2.Direct3D9.Device"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device ppDevice) {
            unsafe {
                IntPtr ppDevice_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &ppDevice_);
                ppDevice = (ppDevice_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppDevice_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the query type.	
        /// </summary>	
        /// <returns>  <see cref="SlimDX2.Direct3D9.Querytype"/>  Returns the query type. See <see cref="SlimDX2.Direct3D9.Querytype"/>. </returns>
        /// <unmanaged>D3DQUERYTYPE GetType()</unmanaged>
        internal SlimDX2.Direct3D9.Querytype GetTypeInfo() {
            unsafe {
                SlimDX2.Direct3D9.Querytype __result__;
                __result__= (SlimDX2.Direct3D9.Querytype)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of bytes in the query data.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns the number of bytes of query data. </returns>
        /// <unmanaged>int GetDataSize()</unmanaged>
        internal int GetDataSize() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Issue a query.	
        /// </summary>	
        /// <remarks>	
        ///  A signaled query means the query has completed, the data is available, and <see cref="SlimDX2.Direct3D9.Query.GetData"/> will return S_OK.  	
        /// </remarks>	
        /// <param name="dwIssueFlags"> Query flags specify the type of state change for the query. See {{D3DISSUE_BEGIN}} and {{D3DISSUE_END}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT Issue([None] int dwIssueFlags)</unmanaged>
        public SlimDX2.Result Issue(int dwIssueFlags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, dwIssueFlags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Polls a queried resource to get the query state or a query result. For more information about queries, see {{Queries (Direct3D 9)}}.	
        /// </summary>	
        /// <remarks>	
        ///  It is possible to lose the device while polling for query status. When {{D3DGETDATA_FLUSH}} is specified, this method will return D3DERR_DEVICELOST in response to a lost device. This allows an application to prevent threads from endlessly polling due to a lost device (which cannot respond to the query). An application must never write code that only invokes GetData ( ... , 0 ), expecting that GetData will eventually return S_OK by itself over time. This is true, even if the application has used the FLUSH flag with GetData in the past. For example: 	
        /// <code> // Enables an infinite loop:	
        /// while( pQuery-&gt;GetData( ... , 0 ) == S_FALSE ) ; // Still enables an infinite loop:	
        /// pQuery-&gt;GetData( ... , D3DGETDATA_FLUSH );	
        /// while( pQuery-&gt;GetData( ... , 0 ) == S_FALSE ) ; // Does not enable an infinite loop because eventually the command	
        /// // buffer will fill up and that will cause a flush to occur.	
        /// while( pQuery-&gt;GetData( ..., 0 ) == S_FALSE ) { pDevice-&gt;SetTexture(...); pDevice-&gt;Draw(...);	
        /// } </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="pData"> Pointer to a buffer containing the query data. The user is responsible for allocating this. pData may be NULL only if dwSize is 0. </param>
        /// <param name="dwSize"> Number of bytes of data in pData. If you set dwSize to zero, you can use this method to poll the resource for the query status. See remarks. </param>
        /// <param name="dwGetDataFlags"> Data flags specifying the query type. Valid values are either 0 or {{D3DGETDATA_FLUSH}}. Use 0 to avoid flushing batched queries to the driver and use D3DGETDATA_FLUSH to go ahead and flush them. For applications writing their own version of waiting, a query result is not realized until the driver receives a flush. </param>
        /// <returns>  <see cref="int"/>  The return type identifies the query state (see {{Queries (Direct3D 9)}}). The method returns S_OK if the query data is available and S_FALSE if it is not.  These are considered successful return values. If the method fails when {{D3DGETDATA_FLUSH}} is used, the return value can be D3DERR_DEVICELOST.  </returns>
        /// <unmanaged>HRESULT GetData([None] void* pData,[None] int dwSize,[None] int dwGetDataFlags)</unmanaged>
        public SlimDX2.Result GetData(IntPtr pData, int dwSize, int dwGetDataFlags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)pData, dwSize, dwGetDataFlags);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Applications use the methods of the IDirect3D9Ex interface (which inherits from <see cref="SlimDX2.Direct3D9.Direct3D9"/>) to create Microsoft Direct3D 9Ex objects and set up the environment. This interface includes methods for enumerating and retrieving capabilities of the device and is available when the underlying device implementation is compliant with Windows Vista.	
    /// </summary>	
    /// <unmanaged>IDirect3D9Ex</unmanaged>
    [Guid("02177241-69FC-400C-8FF1-93A44DF6861D")]
    public partial class Direct3D9Ex : SlimDX2.Direct3D9.Direct3D9 {
        public Direct3D9Ex(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Returns the number of display modes available.	
        /// </summary>	
        /// <remarks>	
        ///  Events such as display mode changes on other heads of the same hardware, monitor change or its connection status change, and desktop extension/unextension could all affect the number of display mode available. To fullscreen applications, S_PRESENT_MODE_CHANGED returned from {{PresentEx}} or {{CheckDeviceState}} is the indication of display mode setting failure due to those events. To increase the chance of setting a currently available display mode successfully, fullscreen applications should try to requery the available display mode list upon receiving S_PRESENT_MODE_CHANGED. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number denoting the display adapter from which to retrieve the display mode count. </param>
        /// <param name="pFilter"> Specifies the characteristics of the desired display mode. See <see cref="SlimDX2.Direct3D9.Displaymodefilter"/>. </param>
        /// <returns>  {{UINT}}  The number of display modes available. A return of value zero from this method is an indication that no such display mode is supported or simply this monitor is no longer available. </returns>
        /// <unmanaged>UINT GetAdapterModeCountEx([None] UINT Adapter,[Out] const D3DDISPLAYMODEFILTER* pFilter)</unmanaged>
        public int GetAdapterModeCountEx(int adapter, out SlimDX2.Direct3D9.Displaymodefilter pFilter) {
            unsafe {
                pFilter = new SlimDX2.Direct3D9.Displaymodefilter();
                int __result__;
                fixed (void* pFilter_ = &pFilter)
                    __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, adapter, pFilter_);
                return __result__;
            }
        }
        
        /// <summary>	
        /// This method returns the actual display mode info based on the given mode index.	
        /// </summary>	
        /// <param name="adapter"> Ordinal number denoting the display adapter to enumerate. D3DADAPTER_DEFAULT is always the primary display adapter. This method returns D3DERR_INVALIDCALL when this value equals or exceeds the number of display adapters in the system. </param>
        /// <param name="pFilter"> See <see cref="SlimDX2.Direct3D9.Displaymodefilter"/>. </param>
        /// <param name="mode"> Represents the display-mode index which is an unsigned integer between zero and the value returned by GetAdapterModeCount minus one. </param>
        /// <param name="pMode"> A pointer to the available display mode of type <see cref="SlimDX2.Direct3D9.Displaymodeex"/>. </param>
        /// <returns>  <see cref="int"/>   If the device can be used on this adapter, D3D_OK is returned. If the Adapter equals or exceeds the number of display adapters in the system, D3DERR_INVALIDCALL is returned.  </returns>
        /// <unmanaged>HRESULT EnumAdapterModesEx([None] UINT Adapter,[None] const D3DDISPLAYMODEFILTER* pFilter,[None] UINT Mode,[None] D3DDISPLAYMODEEX* pMode)</unmanaged>
        public SlimDX2.Result EnumAdapterModesEx(int adapter, ref SlimDX2.Direct3D9.Displaymodefilter pFilter, int mode, ref SlimDX2.Direct3D9.Displaymodeex pMode) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pFilter_ = &pFilter)
                    fixed (void* pMode_ = &pMode)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, adapter, pFilter_, mode, pMode_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the current display mode and rotation settings of the adapter.	
        /// </summary>	
        /// <remarks>	
        ///  GetAdapterDisplayModeEx does not return the correct format when the display is in an extended format, such as 2:10:10:10. Instead, it returns the format X8R8G8B8. To windowed applications, a value of S_PRESENT_MODE_CHANGED returned from {{PresentEx}} or {{CheckDeviceState}} indicates that the display mode changed and that the current display mode might have a different format. To avoid a color-converting Present blt, windowed applications can optionally get new display mode information by using this method and adjusting its swap chain format accordingly. This method returns D3DERR_NOTAVAILABLE if this head is no longer part of the desktop or if the monitor is disconnected. 	
        /// </remarks>	
        /// <param name="adapter"> Ordinal number that denotes the display adapter to query. D3DADAPTER_DEFAULT is always the primary display adapter.  </param>
        /// <param name="pMode"> Pointer to a <see cref="SlimDX2.Direct3D9.Displaymodeex"/> structure containing data about the display mode of the adapter. As opposed to the display mode of the device, which may not be active if the device does not own full-screen mode. Can be set to NULL. </param>
        /// <param name="pRotation"> Pointer to a <see cref="SlimDX2.Direct3D9.Displayrotation"/> structure indicating the type of screen rotation the application will do. The value returned through this pointer is important when the {{D3DPRESENTFLAG_NOAUTOROTATE}} flag is used; otherwise, it can be set to NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK.   If Adapter is out of range or pMode is invalid, this method returns D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetAdapterDisplayModeEx([None] UINT Adapter,[Out] D3DDISPLAYMODEEX* pMode,[Out] D3DDISPLAYROTATION* pRotation)</unmanaged>
        public SlimDX2.Result GetAdapterDisplayModeEx(int adapter, out SlimDX2.Direct3D9.Displaymodeex pMode, out SlimDX2.Direct3D9.Displayrotation pRotation) {
            unsafe {
                pMode = new SlimDX2.Direct3D9.Displaymodeex();
                SlimDX2.Result __result__;
                fixed (void* pMode_ = &pMode)
                    fixed (void* pRotation_ = &pRotation)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, adapter, pMode_, pRotation_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a device to represent the display adapter.	
        /// </summary>	
        /// <param name="adapter"> Ordinal number that denotes the display adapter. {{D3DADAPTER_DEFAULT}} is always the primary display adapter. </param>
        /// <param name="deviceType"> Specifies the type of device. See <see cref="SlimDX2.Direct3D9.Devtype"/>. If the desired device type is not available, the method will fail. </param>
        /// <param name="hFocusWindow"> The focus window alerts Direct3D when an application switches from foreground mode to background mode. For full-screen mode, the window specified must be a top-level window. For windowed mode, this parameter may be NULL only if the hDeviceWindow member of pPresentationParameters is set to a valid, non-NULL value. </param>
        /// <param name="behaviorFlags"> Combination of one or more options (see {{D3DCREATE}}) that control device creation. </param>
        /// <param name="pPresentationParameters"> Pointer to a <see cref="SlimDX2.Direct3D9.PresentParameters"/> structure, describing the presentation parameters for the device to be created. If BehaviorFlags specifies {{D3DCREATE_ADAPTERGROUP_DEVICE}}, this parameter is an array. Regardless of the number of heads that exist, only one depth/stencil surface is automatically created. This parameter is both an input and an output parameter. Calling this method may change several members including:  If BackBufferCount, BackBufferWidth, and BackBufferHeight are 0 before the method is called, they will be changed when the method returns. If BackBufferFormat equals <see cref="SlimDX2.Direct3D9.Format.MtUnknown"/> before the method is called, it will be changed when the method returns.  </param>
        /// <param name="pFullscreenDisplayMode"> The display mode for when the device is set to fullscreen. See <see cref="SlimDX2.Direct3D9.Displaymodeex"/>. If BehaviorFlags specifies {{D3DCREATE_ADAPTERGROUP_DEVICE}}, this parameter is an array. </param>
        /// <param name="ppReturnedDeviceInterface"> Address of a pointer to the returned <see cref="SlimDX2.Direct3D9.Device9Ex"/>, which represents the created device. </param>
        /// <returns>  <see cref="int"/>  This method returns S_OK when rendering device along with swapchain buffers are created successfully. D3DERR_DEVICELOST is returned when any error other than invalid caller input is encountered. </returns>
        /// <unmanaged>HRESULT CreateDeviceEx([None] UINT Adapter,[None] D3DDEVTYPE DeviceType,[None] HWND hFocusWindow,[None] int BehaviorFlags,[None] D3DPRESENT_PARAMETERS* pPresentationParameters,[None] D3DDISPLAYMODEEX* pFullscreenDisplayMode,[None] IDirect3DDevice9Ex** ppReturnedDeviceInterface)</unmanaged>
        public SlimDX2.Result CreateDeviceEx(int adapter, SlimDX2.Direct3D9.Devtype deviceType, IntPtr hFocusWindow, int behaviorFlags, ref SlimDX2.Direct3D9.PresentParameters pPresentationParameters, ref SlimDX2.Direct3D9.Displaymodeex pFullscreenDisplayMode, out SlimDX2.Direct3D9.Device9Ex ppReturnedDeviceInterface) {
            unsafe {
                IntPtr ppReturnedDeviceInterface_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pPresentationParameters_ = &pPresentationParameters)
                    fixed (void* pFullscreenDisplayMode_ = &pFullscreenDisplayMode)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, adapter, unchecked((int)deviceType), (void*)hFocusWindow, behaviorFlags, pPresentationParameters_, pFullscreenDisplayMode_, &ppReturnedDeviceInterface_);
                ppReturnedDeviceInterface = (ppReturnedDeviceInterface_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device9Ex(ppReturnedDeviceInterface_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// This method returns a unique identifier for the adapter that is specific to the adapter hardware. Applications can use this identifier to define robust mappings across various APIs (Direct3D 9, DXGI).	
        /// </summary>	
        /// <param name="adapter"> Ordinal number denoting the display adapter from which to retrieve the LUID. </param>
        /// <param name="pLUID"> A unique identifier for the given adapter. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
        /// <unmanaged>HRESULT GetAdapterLUID([None] UINT Adapter,[Out] LUID* pLUID)</unmanaged>
        public SlimDX2.Result GetAdapterLUID(int adapter, out long pLUID) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pLUID_ = &pLUID)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, adapter, pLUID_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Applications use the methods of the IDirect3DDevice9Ex interface to render primitives, create resources, work with system-level variables, adjust gamma ramp levels, work with palettes, and create shaders. The IDirect3DDevice9Ex interface derives from the <see cref="SlimDX2.Direct3D9.Device"/> interface.	
    /// </summary>	
    /// <unmanaged>IDirect3DDevice9Ex</unmanaged>
    [Guid("B18B10CE-2649-405a-870F-95F777D4313A")]
    public partial class Device9Ex : SlimDX2.Direct3D9.Device {
        public Device9Ex(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the priority of the GPU thread.	
        /// </summary>	
        /// <remarks>	
        ///  Use <see cref="SlimDX2.Direct3D9.Device9Ex.SetGPUThreadPriority"/> to set the priority of a thread. This method will retrieve the priority of the thread stored with the Direct3D device even if it was created with the {{D3DCREATE_PUREDEVICE}} flag. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetGPUThreadPriority([Out] INT* pPriority)</unmanaged>
        public int GPUThreadPriority {
                get { int __output__; GetGPUThreadPriority(out __output__); return __output__; }
                set { SetGPUThreadPriority(value); }
        }
        
        /// <summary>	
        /// Retrieves the number of frames of data that the system is allowed to queue.	
        /// </summary>	
        /// <remarks>	
        ///  Frame latency is the number of frames that are allowed to be stored in a queue, before submission for rendering. Latency is often used to control how the CPU chooses between responding to user input and frames that are in the render queue. It is often beneficial for applications that have no user input (for example, video playback) to queue more than 3 frames of data. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetMaximumFrameLatency([Out] UINT* pMaxLatency)</unmanaged>
        public int MaximumFrameLatency {
                get { int __output__; GetMaximumFrameLatency(out __output__); return __output__; }
                set { SetMaximumFrameLatency(value); }
        }
        
        /// <summary>	
        /// Prepare the texture sampler for monochrome convolution filtering on a single-color texture.	
        /// </summary>	
        /// <remarks>	
        ///  This method is designed to filter a single color texture. A monochrome convolution filter is a 2D box filter with all of the weights set to 1.0;  the filter kernel resolution ranges from 1 x 1 to 7 x 7. When monochrome texture filtering is set to a texture sampler and texture sampling is performed at location, then Direct3D performs convolution.  Restrictions include:  The filter specified by this method is recorded in state blocks as a part of <see cref="SlimDX2.Direct3D9.Stateblocktype.BtPixelstate"/>. The only texture address mode supported is: {{D3DPTADDRESSCAPS_BORDER}}; the border color is always 0. This method is not supported for mipmaps. Using a non-monochrome texture with convolution filtering will generate a driver error.  	
        /// </remarks>	
        /// <param name="width"> The width of the filter kernel; ranging from 1 - {{D3DCONVOLUTIONMONO_MAXWIDTH}}. The default value is 1. </param>
        /// <param name="height"> The height of the filter kernel; ranging from 1 - {{D3DCONVOLUTIONMONO_MAXHEIGHT}}. The default value is 1. </param>
        /// <param name="rows"> An array of weights, one weight for each kernel sub-element in the width. This parameter must be NULL, which will set the weights equal to the default value. </param>
        /// <param name="columns"> An array of weights, one weight for each kernel sub-element in the height. This parameter must be NULL, which will set the weights equal to the default value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. </returns>
        /// <unmanaged>HRESULT SetConvolutionMonoKernel([None] UINT width,[None] UINT height,[None] float* rows,[None] float* columns)</unmanaged>
        public SlimDX2.Result SetConvolutionMonoKernel(int width, int height, ref float rows, ref float columns) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* rows_ = &rows)
                    fixed (void* columns_ = &columns)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 119 * 4, width, height, rows_, columns_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copy a text string to one surface using an alphabet of glyphs on another surface. Composition is done by the GPU using bitwise operations.	
        /// </summary>	
        /// <remarks>	
        ///  Glyphs from a one-bit source surface are put together into another one-bit texture surface with this method. The destination surface can then be used as the source for a normal texturing operation that will filter and scale the strings of text onto some other non-monochrome surface. This method has several constraints (which are similar to {{StretchRect}}):  Surfaces cannot be locked. The source and destination surfaces cannot be the same surface. The source and destination surfaces must be created with the <see cref="SlimDX2.Direct3D9.Format.MtA1"/> format. The source surface and both vertex buffers must be created with the <see cref="SlimDX2.Direct3D9.Pool.Default"/> flag. The destination surface must be created with either the <see cref="SlimDX2.Direct3D9.Pool.Default"/> or <see cref="SlimDX2.Direct3D9.Pool.Systemmem"/> flags. The source rectangles must be within the source surface.  The method is not recorded in state blocks. 	
        /// </remarks>	
        /// <param name="pSrc"> A pointer to a source surface (prepared by <see cref="SlimDX2.Direct3D9.Surface"/>) that supplies the alphabet glyphs. This surface must be created with the {{D3DUSAGE_TEXTAPI}} flag. </param>
        /// <param name="pDst"> A pointer to the destination surface (prepared by <see cref="SlimDX2.Direct3D9.Surface"/>) that receives the glyph data. The surface must be part of a texture. </param>
        /// <param name="pSrcRectDescs"> A pointer to a vertex buffer (see <see cref="SlimDX2.Direct3D9.VertexBuffer"/>) containing rectangles (see <see cref="SlimDX2.Direct3D9.Composerectdesc"/>) that enclose the desired glyphs in the source surface. </param>
        /// <param name="numRects"> The number of rectangles or glyphs that are used in the operation. The number applies to both the source and destination surfaces. The range is 0 to {{D3DCOMPOSERECTS_MAXNUMRECTS}}. </param>
        /// <param name="pDstRectDescs"> A pointer to a vertex buffer (see <see cref="SlimDX2.Direct3D9.VertexBuffer"/>) containing rectangles (see <see cref="SlimDX2.Direct3D9.Composerectdestination"/>) that describe the destination to which the indicated glyph from the source surface will be copied. </param>
        /// <param name="operation"> Specifies how to combine the source and destination surfaces. See <see cref="SlimDX2.Direct3D9.Composerectsop"/>. </param>
        /// <param name="xoffset"> A value added to the x coordinates of all destination rectangles. This value can be negative, which may cause the glyph to be rejected or clipped if the result is beyond the bounds of the surface. </param>
        /// <param name="yoffset"> A value added to the y coordinates of all destination rectangles. This value can be negative, which may cause the glyph to be rejected or clipped if the result is beyond the bounds of the surface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. </returns>
        /// <unmanaged>HRESULT ComposeRects([None] IDirect3DSurface9* pSrc,[None] IDirect3DSurface9* pDst,[None] IDirect3DVertexBuffer9* pSrcRectDescs,[None] UINT NumRects,[None] IDirect3DVertexBuffer9* pDstRectDescs,[None] D3DCOMPOSERECTSOP Operation,[None] int Xoffset,[None] int Yoffset)</unmanaged>
        public SlimDX2.Result ComposeRects(SlimDX2.Direct3D9.Surface pSrc, SlimDX2.Direct3D9.Surface pDst, SlimDX2.Direct3D9.VertexBuffer pSrcRectDescs, int numRects, SlimDX2.Direct3D9.VertexBuffer pDstRectDescs, SlimDX2.Direct3D9.Composerectsop operation, int xoffset, int yoffset) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 120 * 4, (void*)((pSrc == null)?IntPtr.Zero:pSrc.NativePointer), (void*)((pDst == null)?IntPtr.Zero:pDst.NativePointer), (void*)((pSrcRectDescs == null)?IntPtr.Zero:pSrcRectDescs.NativePointer), numRects, (void*)((pDstRectDescs == null)?IntPtr.Zero:pDstRectDescs.NativePointer), unchecked((int)operation), xoffset, yoffset);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Swap the swapchain's next buffer with the front buffer.	
        /// </summary>	
        /// <remarks>	
        ///  Similar to the <see cref="SlimDX2.Direct3D9.Device.Present"/> Method, PresentEx adds a dwflags parameter. When the swapchain is created with <see cref="SlimDX2.Direct3D9.Swapeffect.Flipex"/> flag, pSourceRect, pDestRect and pDirtyRegion values must be set to NULL. 	
        /// </remarks>	
        /// <param name="pSourceRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure indicating region on the source surface to copy in window client coordinates. Only applies when the swapchain was created with the <see cref="SlimDX2.Direct3D9.Swapeffect.Copy"/> flag. If NULL, the entire source surface is presented. If the rectangle exceeds the source surface, it is clipped to the source surface. </param>
        /// <param name="pDestRect"> Pointer to <see cref="SlimDX2.Rectangle"/> structure indicating the target region on the destination surface in window client coordinates. Only applies when the swapchain was created with the <see cref="SlimDX2.Direct3D9.Swapeffect.Copy"/> flag. If NULL, the entire client area is filled. If the rectangle exceeds the destination client area, it is clipped to the destination client area. </param>
        /// <param name="hDestWindowOverride"> Pointer to a destination window handle whose client area is taken as the target for this presentation. If this value is NULL, then the hWndDeviceWindow member of <see cref="SlimDX2.Direct3D9.PresentParameters"/> is taken. </param>
        /// <param name="pDirtyRegion"> Pointer to a <see cref="SlimDX2.Windows.Rgndata"/> structure indicating the smallest set of pixels that need to be transferred. This value must be NULL unless the swapchain was created with the <see cref="SlimDX2.Direct3D9.Swapeffect.Copy"/> flag. For more information about swapchains, see {{Flipping Surfaces (Direct3D 9)}}. If this value is non-NULL, the contained region is expressed in back buffer coordinates. The method takes these rectangles into account when optimizing the presentation by copying only the pixels within the region, or some suitably expanded set of rectangles. This is an aid to optimization only, and the application should not rely on the region being copied exactly. The implementation can choose to copy the whole source rectangle. </param>
        /// <param name="dwFlags"> Allows the application to request that the method return immediately when the driver reports that it cannot schedule a presentation. Valid values are 0, or any combination of {{D3DPRESENT}} flags.   If dwFlags = 0, this method behaves as it did prior to Direct3D 9. Present will spin until the hardware is free, without returning an error. If dwFlags = {{D3DPRESENT_DONOTFLIP}} the display driver is called with the front buffer as both the source and target surface. The driver responds by scheduling a frame synch, but not changing the displayed surface. This flag is only available in full-screen mode or when using D3DSWAPEFFECT_FLIPEX in windowed mode. If dwFlags = {{D3DPRESENT_DONOTWAIT}}, and the hardware is busy processing or waiting for a vertical sync interval, the method will return D3DERR_WASSTILLDRAWING. If dwFlags = {{D3DPRESENT_FORCEIMMEDIATE}}, D3DPRESENT_INTERVAL_IMMEDIATE is enforced on this Present call. This flag can only be specified when using D3DSWAPEFFECT_FLIPEX. This behavior is the same for windowed and full-screen modes. If dwFlags = {{D3DPRESENT_LINEAR_CONTENT}}, gamma correction is performed from linear space to sRGB for windowed swap chains. This flag will take effect only when the driver exposes {{D3DCAPS3_LINEAR_TO_SRGB_PRESENTATION}} (see {{Gamma (Direct3D 9)}}).  </param>
        /// <returns>  <see cref="int"/>  Possible return values include: S_OK, D3DERR_DEVICELOST, D3DERR_DEVICEHUNG, D3DERR_DEVICEREMOVED, or D3DERR_OUTOFVIDEOMEMORY (see {{D3DERR}}). See {{Lost Device Behavior Changes}} for more information about lost, hung, and removed devices.   Differences between Direct3D 9 and Direct3D 9Ex: <see cref="SlimDX2.Direct3D9.Swapeffect.Flipex"/> is only available in Direct3D9Ex running on Windows 7 (or more current operating system).     </returns>
        /// <unmanaged>HRESULT PresentEx([None] const RECT* pSourceRect,[None] const RECT* pDestRect,[None] HWND hDestWindowOverride,[None] const RGNDATA* pDirtyRegion,[None] int dwFlags)</unmanaged>
        public SlimDX2.Result PresentEx(ref SlimDX2.Rectangle pSourceRect, ref SlimDX2.Rectangle pDestRect, IntPtr hDestWindowOverride, ref SlimDX2.Windows.Rgndata pDirtyRegion, int dwFlags) {
            unsafe {
                SlimDX2.Windows.Rgndata.__Native pDirtyRegion_ = new SlimDX2.Windows.Rgndata.__Native();
                pDirtyRegion.__MarshalTo(ref pDirtyRegion_);
                SlimDX2.Result __result__;
                fixed (void* pSourceRect_ = &pSourceRect)
                    fixed (void* pDestRect_ = &pDestRect)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 121 * 4, pSourceRect_, pDestRect_, (void*)hDestWindowOverride, &pDirtyRegion_, dwFlags);
                pDirtyRegion.__MarshalFrom(ref pDirtyRegion_);
                pDirtyRegion_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the priority of the GPU thread.	
        /// </summary>	
        /// <remarks>	
        ///  Use <see cref="SlimDX2.Direct3D9.Device9Ex.SetGPUThreadPriority"/> to set the priority of a thread. This method will retrieve the priority of the thread stored with the Direct3D device even if it was created with the {{D3DCREATE_PUREDEVICE}} flag. 	
        /// </remarks>	
        /// <param name="pPriority"> Current GPU priority. Valid values range from -7 to 7. </param>
        /// <returns>  <see cref="int"/>  Possible return values include: D3D_OK or D3DERR_DEVICEREMOVED (see {{D3DERR}}). </returns>
        /// <unmanaged>HRESULT GetGPUThreadPriority([Out] INT* pPriority)</unmanaged>
        internal SlimDX2.Result GetGPUThreadPriority(out int pPriority) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pPriority_ = &pPriority)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 122 * 4, pPriority_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set the priority on the GPU thread.	
        /// </summary>	
        /// <remarks>	
        ///  GPU thread priority is not reset when a device is lost. The effects of calls to this method are not recorded in state blocks. 	
        /// </remarks>	
        /// <param name="priority"> The thread priority, ranging from -7 to 7. </param>
        /// <returns>  <see cref="int"/>  Possible return values include: D3D_OK, D3DERR_INVALIDCALL, or D3DERR_DEVICEREMOVED (see {{D3DERR}}). </returns>
        /// <unmanaged>HRESULT SetGPUThreadPriority([None] INT Priority)</unmanaged>
        internal SlimDX2.Result SetGPUThreadPriority(int priority) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 123 * 4, priority);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Suspend execution of the calling thread until the next vertical blank signal.	
        /// </summary>	
        /// <remarks>	
        ///  This method allows applications to efficiently throttle their frame rate to that of the monitor associated with the device. Following a vertical blank, the amount of time it takes for the thread to wake up is typically very short. In some scenarios the hardware may stop generating vertical blank signals when nothing is being displayed on the monitor. In this case, the method will wait approximately 100ms and return with D3D_OK. 	
        /// </remarks>	
        /// <param name="iSwapChain"> Swap chain index. This is an optional, zero-based index used to specify a swap chain on a multihead card. </param>
        /// <returns>  <see cref="int"/>  This method will always return D3D_OK. </returns>
        /// <unmanaged>HRESULT WaitForVBlank([None] UINT iSwapChain)</unmanaged>
        public SlimDX2.Result WaitForVBlank(int iSwapChain) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 124 * 4, iSwapChain);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Checks an array of resources to determine if it is likely that they will cause a large stall at Draw time because the system must make the resources GPU-accessible.	
        /// </summary>	
        /// <remarks>	
        ///  This API is no more than a reasonable guess at residency, since resources may have been demoted by the time the application uses them. The expected usage pattern is as follows. If the application determines that a set of resources are not resident, then the application will substitute a lower-LOD version of the resource and continue with rendering. The video memory manager API, offers a feature to allow the application to express that it would like these lower-LOD resources to be made more likely to stay resident in GPU-accessible memory. It is the app's responsibility to create, fill and destroy these lower-LOD versions, if it so chooses. The application also needs to begin promotion of the higher-LOD versions when the residency check indicates that the resource is not resident in GPU-accessible memory. Since a per-process lock exists in kernel mode, a performant implementation will spawn a separate process whose sole job is to promote resources. The application communicates resource identity between the two process by means of the {{Sharing Resources}} shared surfaces API and promotes them by means of the {{SetPriority}}. 	
        /// </remarks>	
        /// <param name="pResourceArray"> An array of IDirect3DResource9 pointers that indicate the resources to check (for a description of IDirect3DResource9, see the DirectX SDK documentation). </param>
        /// <param name="numResources"> A value indicating the number of resources passed into the pResourceArray parameter up to a maximum of 65535. </param>
        /// <returns>  <see cref="int"/>  If all the resources are in GPU-accessible memory, the method will return S_OK. The system may need to perform a remapping operation to promote the resources, but will not have to copy data.  If no allocation that comprises the resources is on disk, but at least one allocation is not in GPU-accessible memory, the method will return S_RESIDENT_IN_SHARED_MEMORY. The system may need to perform a copy to promote the resource.  If at least one allocation that comprises the resources is on disk, this method will return S_NOT_RESIDENT.  The system may need to perform a copy to promote the resource. </returns>
        /// <unmanaged>HRESULT CheckResourceResidency([None] IDirect3DResource9** pResourceArray,[None] UINT32 NumResources)</unmanaged>
        public SlimDX2.Result CheckResourceResidency(out SlimDX2.Direct3D9.Resource pResourceArray, int numResources) {
            unsafe {
                IntPtr pResourceArray_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 125 * 4, &pResourceArray_, numResources);
                pResourceArray = (pResourceArray_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Resource(pResourceArray_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set the number of frames that the system is allowed to queue for rendering.	
        /// </summary>	
        /// <remarks>	
        ///  Frame latency is the number of frames that are allowed to be stored in a queue, before submission for rendering. Latency is often used to control how the CPU chooses between responding to user input and frames that are in the render queue. It is often beneficial for applications that have no user input (for example, video playback) to queue more than 3 frames of data. 	
        /// </remarks>	
        /// <param name="maxLatency"> The maximum number of back buffer frames that a driver can queue. The value is typically 3, but can range from 1 to 20. A value of 0 will reset latency to the default. For multi-head devices, MaxLatency is specified per-head. </param>
        /// <returns>  <see cref="int"/>  Possible return values include: D3D_OK or D3DERR_DEVICEREMOVED (see {{D3DERR}}). </returns>
        /// <unmanaged>HRESULT SetMaximumFrameLatency([None] UINT MaxLatency)</unmanaged>
        internal SlimDX2.Result SetMaximumFrameLatency(int maxLatency) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 126 * 4, maxLatency);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of frames of data that the system is allowed to queue.	
        /// </summary>	
        /// <remarks>	
        ///  Frame latency is the number of frames that are allowed to be stored in a queue, before submission for rendering. Latency is often used to control how the CPU chooses between responding to user input and frames that are in the render queue. It is often beneficial for applications that have no user input (for example, video playback) to queue more than 3 frames of data. 	
        /// </remarks>	
        /// <param name="pMaxLatency"> Returns the number of frames that can be queued for render. The value is typically 3, but can range from 1 to 20. </param>
        /// <returns>  <see cref="int"/>  Possible return values include: D3D_OK, D3DERR_DEVICELOST, D3DERR_DEVICEREMOVED, D3DERR_DRIVERINTERNALERROR, D3DERR_INVALIDCALL, or D3DERR_OUTOFVIDEOMEMORY (see {{D3DERR}}). </returns>
        /// <unmanaged>HRESULT GetMaximumFrameLatency([Out] UINT* pMaxLatency)</unmanaged>
        internal SlimDX2.Result GetMaximumFrameLatency(out int pMaxLatency) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pMaxLatency_ = &pMaxLatency)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 127 * 4, pMaxLatency_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Reports the current cooperative-level status of the Direct3D device for a windowed or full-screen application.	
        /// </summary>	
        /// <remarks>	
        ///  This method replaces <see cref="SlimDX2.Direct3D9.Device.TestCooperativeLevel"/>, which always returns S_OK in Direct3D 9Ex applications. See {{Lost Device Behavior Changes}} for more information about lost, hung, and removed devices. 	
        /// </remarks>	
        /// <param name="hDestinationWindow"> The destination window handle to check for occlusion. When this parameter is NULL, S_PRESENT_OCCLUDED is returned when another device has fullscreen ownership. When the window handle is not NULL, window's client area is checked for occlusion. A window is occluded if any part of it is obscured by another application. </param>
        /// <returns>  <see cref="int"/>  Possible return values include: D3D_OK, D3DERR_DEVICELOST, D3DERR_DEVICEHUNG, D3DERR_DEVICEREMOVED, or D3DERR_OUTOFVIDEOMEMORY (see {{D3DERR}}), or S_PRESENT_MODE_CHANGED, or S_PRESENT_OCCLUDED (see {{S_PRESENT}}). </returns>
        /// <unmanaged>HRESULT CheckDeviceState([None] HWND hDestinationWindow)</unmanaged>
        public SlimDX2.Result CheckDeviceState(IntPtr hDestinationWindow) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 128 * 4, (void*)hDestinationWindow);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a render-target surface.	
        /// </summary>	
        /// <remarks>	
        ///  Render-target surfaces are placed in the D3DPOOL_DEFAULT memory class. The creation of lockable, multisampled render targets is not supported. 	
        /// </remarks>	
        /// <param name="width"> Width of the render-target surface, in pixels.  </param>
        /// <param name="height"> Height of the render-target surface, in pixels.  </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of the render target.  </param>
        /// <param name="multiSample"> Member of the <see cref="SlimDX2.Direct3D9.MultisampleType"/> enumerated type, which describes the multisampling buffer type. This parameter specifies the antialiasing type for this render target. When this surface is passed to <see cref="SlimDX2.Direct3D9.Device.SetRenderTarget"/>, its multisample type must be the same as that of the depth-stencil set by <see cref="SlimDX2.Direct3D9.Device.SetDepthStencilSurface"/>.  </param>
        /// <param name="multisampleQuality"> Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by  <see cref="SlimDX2.Direct3D9.Direct3D9.CheckDeviceMultiSampleType"/>. Passing a larger value returns the error, D3DERR_INVALIDCALL. The MultisampleQuality values of paired render targets, depth stencil surfaces, and the multisample type must all match. </param>
        /// <param name="lockable"> Render targets are not lockable unless the application specifies TRUE for Lockable. Note that lockable render targets reduce performance on some graphics hardware. The readback performance (moving data from video memory to system memory) depends on the type of hardware used (AGP vs. PCI Express) and is usually far lower than upload performance (moving data from system to video memory). If you need read access to render targets, use {{GetRenderTargetData}} instead of lockable render targets. </param>
        /// <param name="ppSurface"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface.  </param>
        /// <param name="pSharedHandle"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <param name="usage"> Combination of one or more {{D3DUSAGE}} constants which can be OR'd together. Value of 0 indicates no usage. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT CreateRenderTargetEx([None] UINT Width,[None] UINT Height,[None] D3DFORMAT Format,[None] D3DMULTISAMPLE_TYPE MultiSample,[None] int MultisampleQuality,[None] BOOL Lockable,[None] IDirect3DSurface9** ppSurface,[None] HANDLE* pSharedHandle,[None] int Usage)</unmanaged>
        public SlimDX2.Result CreateRenderTargetEx(int width, int height, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.MultisampleType multiSample, int multisampleQuality, bool lockable, out SlimDX2.Direct3D9.Surface ppSurface, IntPtr pSharedHandle, int usage) {
            unsafe {
                IntPtr ppSurface_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 129 * 4, width, height, unchecked((int)format), unchecked((int)multiSample), multisampleQuality, (lockable?1:0), &ppSurface_, (void*)pSharedHandle, usage);
                ppSurface = (ppSurface_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(ppSurface_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create an off-screen surface.	
        /// </summary>	
        /// <remarks>	
        ///  D3DPOOL_SCRATCH will return a surface that has identical characteristics to a surface created by the DirectX 8.x method CreateImageSurface. D3DPOOL_DEFAULT is the appropriate pool for use with the <see cref="SlimDX2.Direct3D9.Device.StretchRect"/> and <see cref="SlimDX2.Direct3D9.Device.ColorFill"/>. D3DPOOL_MANAGED is not allowed when creating an offscreen plain surface. For more information about memory pools, see <see cref="SlimDX2.Direct3D9.Pool"/>. Off-screen plain surfaces are always lockable, regardless of their pool types. 	
        /// </remarks>	
        /// <param name="width"> Width of the surface. </param>
        /// <param name="height"> Height of the surface. </param>
        /// <param name="format"> Format of the surface. See <see cref="SlimDX2.Direct3D9.Format"/>.  </param>
        /// <param name="pool"> Surface pool type. See <see cref="SlimDX2.Direct3D9.Pool"/>. </param>
        /// <param name="ppSurface"> Pointer to the <see cref="SlimDX2.Direct3D9.Surface"/> interface created. </param>
        /// <param name="pSharedHandle"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <param name="usage"> Combination of one or more {{D3DUSAGE}} constants which can be OR'd together. Value of 0 indicates no usage. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT CreateOffscreenPlainSurfaceEx([None] UINT Width,[None] UINT Height,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] IDirect3DSurface9** ppSurface,[None] HANDLE* pSharedHandle,[None] int Usage)</unmanaged>
        public SlimDX2.Result CreateOffscreenPlainSurfaceEx(int width, int height, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.Surface ppSurface, IntPtr pSharedHandle, int usage) {
            unsafe {
                IntPtr ppSurface_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 130 * 4, width, height, unchecked((int)format), unchecked((int)pool), &ppSurface_, (void*)pSharedHandle, usage);
                ppSurface = (ppSurface_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(ppSurface_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a depth-stencil surface.	
        /// </summary>	
        /// <remarks>	
        ///  The memory class of the depth-stencil buffer is always D3DPOOL_DEFAULT. 	
        /// </remarks>	
        /// <param name="width"> Width of the depth-stencil surface, in pixels.  </param>
        /// <param name="height"> Height of the depth-stencil surface, in pixels.  </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the format of the depth-stencil surface. This value must be one of the enumerated depth-stencil formats for this device. </param>
        /// <param name="multiSample"> Member of the <see cref="SlimDX2.Direct3D9.MultisampleType"/> enumerated type, describing the multisampling buffer type. This value must be one of the allowed multisample types. When this surface is passed to <see cref="SlimDX2.Direct3D9.Device.SetDepthStencilSurface"/>, its multisample type must be the same as that of the render target set by <see cref="SlimDX2.Direct3D9.Device.SetRenderTarget"/>. </param>
        /// <param name="multisampleQuality"> Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by  <see cref="SlimDX2.Direct3D9.Direct3D9.CheckDeviceMultiSampleType"/>. Passing a larger value returns the error D3DERR_INVALIDCALL. The MultisampleQuality values of paired render targets, depth stencil surfaces, and the MultiSample type must all match. </param>
        /// <param name="discard"> Set this flag to TRUE to enable z-buffer discarding, and FALSE otherwise.				If this flag is set, the contents of the depth stencil buffer will be invalid after calling either <see cref="SlimDX2.Direct3D9.Device.Present"/> or <see cref="SlimDX2.Direct3D9.Device.SetDepthStencilSurface"/> with a different depth surface. This flag has the same behavior as the constant,  D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL, in {{D3DPRESENTFLAG}}. </param>
        /// <param name="ppSurface"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the created depth-stencil surface resource.  </param>
        /// <param name="pSharedHandle"> Reserved. Set this parameter to NULL. This parameter can be used in Direct3D 9 for Windows Vista to {{share resources}}. </param>
        /// <param name="usage"> Combination of one or more {{D3DUSAGE}} constants which can be OR'd together. Value of 0 indicates no usage. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT CreateDepthStencilSurfaceEx([None] UINT Width,[None] UINT Height,[None] D3DFORMAT Format,[None] D3DMULTISAMPLE_TYPE MultiSample,[None] int MultisampleQuality,[None] BOOL Discard,[None] IDirect3DSurface9** ppSurface,[None] HANDLE* pSharedHandle,[None] int Usage)</unmanaged>
        public SlimDX2.Result CreateDepthStencilSurfaceEx(int width, int height, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.MultisampleType multiSample, int multisampleQuality, bool discard, out SlimDX2.Direct3D9.Surface ppSurface, IntPtr pSharedHandle, int usage) {
            unsafe {
                IntPtr ppSurface_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 131 * 4, width, height, unchecked((int)format), unchecked((int)multiSample), multisampleQuality, (discard?1:0), &ppSurface_, (void*)pSharedHandle, usage);
                ppSurface = (ppSurface_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(ppSurface_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Resets the type, size, and format of the swap chain with all other surfaces persistent.	
        /// </summary>	
        /// <remarks>	
        ///  If a call to IDirect3DDevice9Ex::ResetEx fails, the device will be placed in the lost state (as indicated by a return value of D3DERR_DEVICELOST from a call to <see cref="SlimDX2.Direct3D9.Device9Ex.CheckDeviceState"/>). Refer to IDirect3DDevice9Ex::CheckDeviceState and {{Lost Device Behavior Changes}} for further information concerning the use of IDirect3DDevice9Ex::ResetEx in the context of lost devices. Unlike previous versions of DirectX, calling IDirect3DDevice9Ex::ResetEx does not cause surfaces, textures or state information to be lost. Pixel shaders and vertex shaders survive IDirect3DDevice9Ex::ResetEx calls for Direct3D 9. They do not need to be re-created explicitly by the application. There are two different types of swap chains: full-screen or windowed. If the new swap chain is full-screen, the adapter will be placed in the display mode that matches the new size. Applications can expect messages to be sent to them during this call (for example, before this call is returned); applications should take precautions not to call into Direct3D at this time. A call to IDirect3DDevice9Ex::ResetEx will fail if called on a different thread than that used to create the device being reset. D3DFMT_UNKNOWN can be specified for the windowed mode back buffer format when calling <see cref="SlimDX2.Direct3D9.Direct3D9Ex.CreateDeviceEx"/>, IDirect3DDevice9Ex::ResetEx, and <see cref="SlimDX2.Direct3D9.Device.CreateAdditionalSwapChain"/>. This means the application does not have to query the current desktop format before calling IDirect3D9Ex::CreateDeviceEx for windowed mode. For full-screen mode, the back buffer format must be specified. Setting BackBufferCount equal to zero (BackBufferCount = 0) results in one back buffer. When trying to reset more than one display adapter in a group, set pPresentationParameters to point to an array of <see cref="SlimDX2.Direct3D9.PresentParameters"/> structures, one for each display in the adapter group. If a multihead device was created with {{D3DCREATE_ADAPTERGROUP_DEVICE}}, IDirect3DDevice9Ex::ResetEx requires an array of <see cref="SlimDX2.Direct3D9.PresentParameters"/> structures wherein each structure must specify a full-screen display. To switch back to windowed mode, the application must destroy the device and re-create a non-multihead device in windowed mode. 	
        /// </remarks>	
        /// <param name="pPresentationParameters"> Pointer to a <see cref="SlimDX2.Direct3D9.PresentParameters"/> structure, describing the new presentation parameters. This value cannot be NULL.   When switching to full-screen mode, Direct3D will try to find a desktop format that matches the back buffer format, so that back buffer and front buffer formats will be identical (to eliminate the need for color conversion). When this method returns:  BackBufferCount, BackBufferWidth, and BackBufferHeight are set to zero. BackBufferFormat is set to <see cref="SlimDX2.Direct3D9.Format"/> for windowed mode only; a full-screen mode must specify a format.  </param>
        /// <param name="pFullscreenDisplayMode"> Pointer to a <see cref="SlimDX2.Direct3D9.Displaymodeex"/> structure that describes the properties of the desired display mode. This value must be provided for fullscreen applications, but can be NULL for windowed applications.  </param>
        /// <returns>  <see cref="int"/>  The method can return: D3D_OK, D3DERR_DEVICELOST or D3DERR_DEVICEHUNG (see {{D3DERR}}).  If this method returns D3DERR_DEVICELOST or D3DERR_DEVICEHUNG then the application can only call IDirect3DDevice9Ex::ResetEx, <see cref="SlimDX2.Direct3D9.Device9Ex.CheckDeviceState"/> or release the interface pointer; any other API call will cause an exception. </returns>
        /// <unmanaged>HRESULT ResetEx([None] D3DPRESENT_PARAMETERS* pPresentationParameters,[None] D3DDISPLAYMODEEX* pFullscreenDisplayMode)</unmanaged>
        public SlimDX2.Result ResetEx(ref SlimDX2.Direct3D9.PresentParameters pPresentationParameters, ref SlimDX2.Direct3D9.Displaymodeex pFullscreenDisplayMode) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pPresentationParameters_ = &pPresentationParameters)
                    fixed (void* pFullscreenDisplayMode_ = &pFullscreenDisplayMode)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 132 * 4, pPresentationParameters_, pFullscreenDisplayMode_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the display mode's spatial resolution, color resolution, refresh frequency, and rotation settings.	
        /// </summary>	
        /// <param name="iSwapChain"> An unsigned integer specifying the swap chain. </param>
        /// <param name="pMode"> Pointer to a <see cref="SlimDX2.Direct3D9.Displaymodeex"/> structure containing data about the display mode of the adapter. As opposed to the display mode of the device, which may not be active if the device does not own full-screen mode. Can be set to NULL. </param>
        /// <param name="pRotation"> Pointer to a <see cref="SlimDX2.Direct3D9.Displayrotation"/> indicating the type of screen rotation the application will do. The value returned through this pointer is important when the {{D3DPRESENTFLAG_NOAUTOROTATE}} flag is used; otherwise, it can be set to NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.  </returns>
        /// <unmanaged>HRESULT GetDisplayModeEx([None] UINT iSwapChain,[Out] D3DDISPLAYMODEEX* pMode,[Out] D3DDISPLAYROTATION* pRotation)</unmanaged>
        public SlimDX2.Result GetDisplayModeEx(int iSwapChain, out SlimDX2.Direct3D9.Displaymodeex pMode, out SlimDX2.Direct3D9.Displayrotation pRotation) {
            unsafe {
                pMode = new SlimDX2.Direct3D9.Displaymodeex();
                SlimDX2.Result __result__;
                fixed (void* pMode_ = &pMode)
                    fixed (void* pRotation_ = &pRotation)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 133 * 4, iSwapChain, pMode_, pRotation_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Applications use the methods of the IDirect3DSwapChain9Ex interface to manipulate a swap chain.	
    /// </summary>	
    /// <unmanaged>IDirect3DSwapChain9Ex</unmanaged>
    [Guid("91886CAF-1C3D-4d2e-A0AB-3E4C7D8D3303")]
    public partial class SwapChain9Ex : SlimDX2.Direct3D9.SwapChain {
        public SwapChain9Ex(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Returns the number of times the swapchain has been processed.	
        /// </summary>	
        /// <unmanaged>HRESULT GetLastPresentCount([Out] UINT* pLastPresentCount)</unmanaged>
        public int LastPresentCount {
                get { int __output__; GetLastPresentCount(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>HRESULT GetPresentStats([Out] D3DPRESENTSTATS* pPresentationStatistics)</unmanaged>
        public SlimDX2.Direct3D9.Presentstats PresentStats {
                get { SlimDX2.Direct3D9.Presentstats __output__; GetPresentStats(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Returns the number of times the swapchain has been processed.	
        /// </summary>	
        /// <param name="pLastPresentCount"> Pointer to a UINT to be filled with the number of times the <see cref="SlimDX2.Direct3D9.Device9Ex.PresentEx"/> method has been called. The count will also be incremented by calling some other APIs such as <see cref="SlimDX2.Direct3D9.Device.SetDialogBoxMode"/>. </param>
        /// <returns>  <see cref="int"/>  S_OK the method was successful. </returns>
        /// <unmanaged>HRESULT GetLastPresentCount([Out] UINT* pLastPresentCount)</unmanaged>
        internal SlimDX2.Result GetLastPresentCount(out int pLastPresentCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pLastPresentCount_ = &pLastPresentCount)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, pLastPresentCount_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="pPresentationStatistics">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT GetPresentStats([Out] D3DPRESENTSTATS* pPresentationStatistics)</unmanaged>
        internal SlimDX2.Result GetPresentStats(out SlimDX2.Direct3D9.Presentstats pPresentationStatistics) {
            unsafe {
                pPresentationStatistics = new SlimDX2.Direct3D9.Presentstats();
                SlimDX2.Result __result__;
                fixed (void* pPresentationStatistics_ = &pPresentationStatistics)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, pPresentationStatistics_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the display mode's spatial resolution, color resolution, refresh frequency, and rotation settings.	
        /// </summary>	
        /// <param name="pMode"> Pointer to a <see cref="SlimDX2.Direct3D9.Displaymodeex"/> structure containing data about the display mode of the adapter. As opposed to the display mode of the device, which may not be active if the device does not own full-screen mode.  </param>
        /// <param name="pRotation"> Pointer to a <see cref="SlimDX2.Direct3D9.Displayrotation"/> indicating the type of screen rotation the application will do. The value returned through this pointer is important when the {{D3DPRESENTFLAG_NOAUTOROTATE}} flag is used; otherwise, it can be set to NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetDisplayModeEx([Out] D3DDISPLAYMODEEX* pMode,[Out] D3DDISPLAYROTATION* pRotation)</unmanaged>
        public SlimDX2.Result GetDisplayModeEx(out SlimDX2.Direct3D9.Displaymodeex pMode, out SlimDX2.Direct3D9.Displayrotation pRotation) {
            unsafe {
                pMode = new SlimDX2.Direct3D9.Displaymodeex();
                SlimDX2.Result __result__;
                fixed (void* pMode_ = &pMode)
                    fixed (void* pRotation_ = &pRotation)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, pMode_, pRotation_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Queries the overlay hardware capabilities of a Direct3D device.	
    /// </summary>	
    /// <unmanaged>IDirect3D9ExOverlayExtension</unmanaged>
    [Guid("187AEB13-AAF5-4C59-876D-E059088C0DF8")]
    public partial class OverlayExtension : SlimDX2.ComObject {
        public OverlayExtension(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Queries the overlay hardware capabilities of a Direct3D device.	
        /// </summary>	
        /// <param name="adapter"> An ordinal number that denotes the display adapter. D3DADAPTER_DEFAULT is always the primary display adapter.  </param>
        /// <param name="devType"> Specifies the Direct3D device type as a member of the D3DDEVTYPE enumerated type.  </param>
        /// <param name="overlayWidth"> The width of the overlay to create, in pixels. </param>
        /// <param name="overlayHeight"> The height of the overlay to create, in pixels. </param>
        /// <param name="overlayFormat"> The surface format of the overlay. </param>
        /// <param name="pDisplayMode"> A pointer to a D3DDISPLAYMODEEX structure that specifies the display mode that will be used. If this parameter is NULL, the current display mode is assumed. </param>
        /// <param name="displayRotation"> Specifies the display rotation mode as a member of the D3DDISPLAYROTATION enumerated type. </param>
        /// <param name="pOverlayCaps"> A pointer to a <see cref="SlimDX2.Direct3D9.Overlaycaps"/> structure. If the driver supports the overlay settings specified in the input parameters, the method fills this structure with the capabilities of the overlay hardware. </param>
        /// <returns> The method can return one of the following values.  Return codeDescription   D3DERR_INVALIDCALL   Invalid parameter, or the device does not support hardware overlay.    D3DERR_UNSUPPORTEDOVERLAY   The device does not support overlay for the specified size or display mode.    D3DERR_UNSUPPORTEDOVERLAYFORMAT   The device does not support overlay for the specified surface format.     </returns>
        /// <unmanaged>HRESULT CheckDeviceOverlayType([None] UINT Adapter,[None] D3DDEVTYPE DevType,[None] UINT OverlayWidth,[None] UINT OverlayHeight,[None] D3DFORMAT OverlayFormat,[None] D3DDISPLAYMODEEX* pDisplayMode,[None] D3DDISPLAYROTATION DisplayRotation,[None] D3DOVERLAYCAPS* pOverlayCaps)</unmanaged>
        public SlimDX2.Result CheckDeviceOverlayType(int adapter, SlimDX2.Direct3D9.Devtype devType, int overlayWidth, int overlayHeight, SlimDX2.Direct3D9.Format overlayFormat, ref SlimDX2.Direct3D9.Displaymodeex pDisplayMode, SlimDX2.Direct3D9.Displayrotation displayRotation, ref SlimDX2.Direct3D9.Overlaycaps pOverlayCaps) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pDisplayMode_ = &pDisplayMode)
                    fixed (void* pOverlayCaps_ = &pOverlayCaps)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, adapter, unchecked((int)devType), overlayWidth, overlayHeight, unchecked((int)overlayFormat), pDisplayMode_, unchecked((int)displayRotation), pOverlayCaps_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Represents a cryptographic session.	
    /// </summary>	
    /// <unmanaged>IDirect3DCryptoSession9</unmanaged>
    [Guid("FA0AB799-7A9C-48CA-8C5B-237E71A54434")]
    public partial class CryptoSession : SlimDX2.ComObject {
        public CryptoSession(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the size of the driver's certificate chain.	
        /// </summary>	
        /// <remarks>	
        ///  To get the certificate, call <see cref="SlimDX2.Direct3D9.CryptoSession.GetCertificate"/>. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetCertificateSize([Out] UINT* pCertificateSize)</unmanaged>
        public int CertificateSize {
                get { int __output__; GetCertificateSize(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the size of the driver's certificate chain.	
        /// </summary>	
        /// <remarks>	
        ///  To get the certificate, call <see cref="SlimDX2.Direct3D9.CryptoSession.GetCertificate"/>. 	
        /// </remarks>	
        /// <param name="pCertificateSize"> Receives the size of the certificate chain, in bytes. </param>
        /// <returns> If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
        /// <unmanaged>HRESULT GetCertificateSize([Out] UINT* pCertificateSize)</unmanaged>
        internal SlimDX2.Result GetCertificateSize(out int pCertificateSize) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pCertificateSize_ = &pCertificateSize)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, pCertificateSize_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the driver's certificate chain. 	
        /// </summary>	
        /// <remarks>	
        ///  The standard key-exchange mechanism uses the driver's Output Protection Manager (OPM) certificate, which is an X.509 certificate. The type of key exchange is given in the capabilities information returned by the {{IDirect3DDevice9Video::GetContentProtectionCaps}} method. The key-exchange mechanism is specified by the KeyExchangeType member of the <see cref="SlimDX2.Direct3D9.Contentprotectioncaps"/> structure. If the value is D3DKEYEXCHANGE_RSAES_OAEP, an X.509 certificate is used. For other types of key exhange, the driver might use some other type of certificate, or might not provide a certificate. 	
        /// </remarks>	
        /// <param name="certifacteSize"> The size of the ppCertificate array, in bytes. To get the size of the certificate chain, call <see cref="SlimDX2.Direct3D9.CryptoSession.GetCertificateSize"/>.  </param>
        /// <param name="ppCertificate"> A pointer to a buffer that receives the driver's certificate chain. The caller must allocate the array. </param>
        /// <returns> If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
        /// <unmanaged>HRESULT GetCertificate([None] UINT CertifacteSize,[Out] byte* ppCertificate)</unmanaged>
        public SlimDX2.Result GetCertificate(int certifacteSize, out byte ppCertificate) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* ppCertificate_ = &ppCertificate)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, certifacteSize, ppCertificate_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Establishes the session key for the cryptographic session.	
        /// </summary>	
        /// <remarks>	
        ///  To find out which key-exchange mechanism to use, call  the {{IDirect3DDevice9Video::GetContentProtectionCaps}} method. The key-exchange mechanism is specified in the KeyExchangeType member of the <see cref="SlimDX2.Direct3D9.Contentprotectioncaps"/> structure. If the value is D3DKEYEXCHANGE_RSAES_OAEP, use RSA Encryption Scheme - Optimal Asymmetric Encryption Padding (RSAES-OAEP) to encrypt the session key. Pass this encrypted cyphertext in the pData parameter. If the key-exchange type is D3DKEYEXCHANGE_DXVA, do not call this method to establish the session key. Instead, use the key-exchange mechanism that is defined for DirectX Video Acceleration 2 (DXVA-2) decoding. The driver might also use a proprietary key-exhange mechanism. 	
        /// </remarks>	
        /// <param name="dataSize"> The size of the pData byte array, in bytes. </param>
        /// <param name="pData"> A pointer to a byte array that contains the encrypted session key. </param>
        /// <returns> If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
        /// <unmanaged>HRESULT NegotiateKeyExchange([None] UINT DataSize,[None] VOID* pData)</unmanaged>
        public SlimDX2.Result NegotiateKeyExchange(int dataSize, IntPtr pData) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, dataSize, (void*)pData);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Reads encrypted data from a protected surface.	
        /// </summary>	
        /// <remarks>	
        ///  If the driver supports this method, it sets the D3DCPCAPS_ENCRYPTEDREADBACK flag in the capabilities structure returned by the {{IDirect3DDevice9Video::GetContentProtectionCaps}} method. If the driver sets the D3DCPCAPS_ENCRYPTEDREADBACKKEY capabilities flag, it means the driver uses a separate key to encrypt the data. To get this key, call the <see cref="SlimDX2.Direct3D9.CryptoSession.GetEncryptionBltKey"/> method. Otherwise, the driver uses the session key to encrypt the data. Allocate the destination surface (pDstSurface) as follows:  Call <see cref="SlimDX2.Direct3D9.CryptoSession.GetSurfacePitch"/> to get the stride of the protected surface. Call the {{GetContentProtectionCaps}} method to get the value of the BufferAlignmentStart and BlockAlignmentSize members in the <see cref="SlimDX2.Direct3D9.Contentprotectioncaps"/> structure.  Calculate the minimum size of the surface memory as SysMemSize = protected surface stride ? protected surface height. Add padding to accommodate the values of BufferAlignmentStart and BlockAlignmentSize. Allocate a buffer in system memory, with size equal to SysMemSize (including padding).  If the address of the system memory buffer is not aligned to the value of BufferAlignmentStart, calculate a memory-aligned pointer that is an offset from the start of the buffer. Call IDirect3DDevice9Ex::CreateOffscreenPlainSurfaceEx to create the destination surface. Pass the memory-aligned pointer as the shared-resource handle (pSharedHandle).  This method has the following limitations:  The method cannot read back  subrectangles or partially encrypted surfaces. The protected surface must be either an offscreen plain surface or a render target. The destination surface must be a system-memory surface, created with the proper alignment, as described earlier. The protected surface cannot be multisampled. The method does not support stretching or colorspace conversion.  If you lock the destination surface, the stride reported in the D3DLOCKED_RECT structure might not match the stride of the protected surface. When you interpret the data, however, always use the stride of the protected surface. 	
        /// </remarks>	
        /// <param name="pSrcSurface"> Pointer to the protected surface. </param>
        /// <param name="pDstSurface"> Pointer to a surface that receives the encrypted data. </param>
        /// <param name="dstSurfaceSize"> The size of the surface memory that pDstSurface points to, in bytes. The size must be aligned to the value of BlockAlignmentSize in the driver capabilities structure; see Remarks. </param>
        /// <param name="pIV"> Pointer to a buffer that receives the initialization vector (IV). If the encryption type is D3DCRYPTOTYPE_AES128_CTR, the buffer is a <see cref="SlimDX2.Direct3D9.AesCtrIv"/> structure, allocated by the caller. The driver fills this structure with the  IV. For other encryption types, a different structure might be used, or the encryption might not use an IV. </param>
        /// <returns> If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
        /// <unmanaged>HRESULT EncryptionBlt([None] IDirect3DSurface9* pSrcSurface,[None] IDirect3DSurface9* pDstSurface,[None] UINT DstSurfaceSize,[None] VOID* pIV)</unmanaged>
        public SlimDX2.Result EncryptionBlt(SlimDX2.Direct3D9.Surface pSrcSurface, SlimDX2.Direct3D9.Surface pDstSurface, int dstSurfaceSize, IntPtr pIV) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)((pSrcSurface == null)?IntPtr.Zero:pSrcSurface.NativePointer), (void*)((pDstSurface == null)?IntPtr.Zero:pDstSurface.NativePointer), dstSurfaceSize, (void*)pIV);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Writes encrypted data to a protected surface.	
        /// </summary>	
        /// <remarks>	
        ///  Allocate the source surface (pSrcSurface) as follows:  Call <see cref="SlimDX2.Direct3D9.CryptoSession.GetSurfacePitch"/> to get the stride of the protected surface. Call the {{IDirect3DDevice9Video::GetContentProtectionCaps}} method to get the value of the BufferAlignmentStart and BlockAlignmentSize members in the <see cref="SlimDX2.Direct3D9.Contentprotectioncaps"/> structure.  Calculate the minimum size of the surface memory as SysMemSize = protected surface stride ? protected surface height. Add padding to accommodate the values of BufferAlignmentStart and BlockAlignmentSize. Allocate a buffer in system memory, with size equal to SysMemSize (including padding).  If the address of the system memory buffer is not aligned to the value of BufferAlignmentStart, calculate a memory-aligned pointer that is an offset from the start of the buffer. Call IDirect3DDevice9Ex::CreateOffscreenPlainSurfaceEx to create the destination surface. Pass the memory-aligned pointer as the shared-resource handle (pSharedHandle).  If you lock the surface, the stride reported in the D3DLOCKED_RECT structure might not match the stride of the protected surface. When you interpret the data, however, always use the stride of the protected surface. If the driver supports partial encryption, it sets the D3DCPCAPS_PARTIALDECRYPTION	
        /// capabilities flag. Use the pEncryptedBlockInfo parameter to specify which bytes are encrypted. This method does not support writing to subrectangles of the surface. 	
        /// </remarks>	
        /// <param name="pSrcSurface"> Pointer to the surface that contains the data. </param>
        /// <param name="pDstSurface"> Pointer to the protected surface. </param>
        /// <param name="srcSurfaceSize"> The size of the surface memory that pSrcSurface points to, in bytes. The size must be aligned to the value of BlockAlignmentSize in the driver capabilities structure; see Remarks. </param>
        /// <param name="pEncryptedBlockInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.EncryptedBlockInformation"/> structure that specifies which bytes of pSrcSurface are encrypted. If the entire surface is encrypted, set this parameter to NULL. </param>
        /// <param name="pContentKey"> Optionally, a pointer to a buffer that contains the content encryption key. A content encryption key is a separate key that is used to encrypt the data. If you use a content encryption key, use the session key to encrypt the pContentKey buffer. If you do not use a content encryption key, use the session key to encrypt the surface data and set pContentKey to NULL. Not every driver supports content encryption keys. If the driver supports content encryption keys, it sets the D3DCPCAPS_CONTENTKEY capabilities flag in the capabilities structure returned by the {{IDirect3DDevice9Video::GetContentProtectionCaps}} method. </param>
        /// <param name="pIV"> Pointer to a buffer that contains the initialization vector (IV). If the encryption type is D3DCRYPTOTYPE_AES128_CTR, the buffer is a <see cref="SlimDX2.Direct3D9.AesCtrIv"/> structure, allocated by the caller. The driver fills this structure with the  IV. For other encryption types, a different structure might be used, or the encryption might not use an IV. </param>
        /// <returns> If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
        /// <unmanaged>HRESULT DecryptionBlt([None] IDirect3DSurface9* pSrcSurface,[None] IDirect3DSurface9* pDstSurface,[None] UINT SrcSurfaceSize,[None] D3DENCRYPTED_BLOCK_INFO* pEncryptedBlockInfo,[None] VOID* pContentKey,[None] VOID* pIV)</unmanaged>
        public SlimDX2.Result DecryptionBlt(SlimDX2.Direct3D9.Surface pSrcSurface, SlimDX2.Direct3D9.Surface pDstSurface, int srcSurfaceSize, ref SlimDX2.Direct3D9.EncryptedBlockInformation pEncryptedBlockInfo, IntPtr pContentKey, IntPtr pIV) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pEncryptedBlockInfo_ = &pEncryptedBlockInfo)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)((pSrcSurface == null)?IntPtr.Zero:pSrcSurface.NativePointer), (void*)((pDstSurface == null)?IntPtr.Zero:pDstSurface.NativePointer), srcSurfaceSize, pEncryptedBlockInfo_, (void*)pContentKey, (void*)pIV);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the stride of a protected surface.	
        /// </summary>	
        /// <remarks>	
        ///  A protected surface cannot be locked, so this method provides a way to get the surface stride without locking the surface. 	
        /// </remarks>	
        /// <param name="pSrcSurface"> Pointer to the protected surface. </param>
        /// <param name="pSurfacePitch"> Receives the stride, in bytes. </param>
        /// <returns> If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
        /// <unmanaged>HRESULT GetSurfacePitch([Out] IDirect3DSurface9* pSrcSurface,[Out] UINT* pSurfacePitch)</unmanaged>
        public SlimDX2.Result GetSurfacePitch(out SlimDX2.Direct3D9.Surface pSrcSurface, out int pSurfacePitch) {
            unsafe {
                IntPtr pSrcSurface_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pSurfacePitch_ = &pSurfacePitch)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, &pSrcSurface_, pSurfacePitch_);
                pSrcSurface = (pSrcSurface_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Surface(pSrcSurface_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a random number that can be used to refresh the session key.	
        /// </summary>	
        /// <remarks>	
        ///  To generate a new session key, perform a bitwise XOR between the previous session key and the random number. The new session key does not take affect until the application calls <see cref="SlimDX2.Direct3D9.CryptoSession.FinishSessionKeyRefresh"/>. If the driver supports this method, the driver sets the D3DCPCAPS_FRESHENSESSIONKEY	
        /// capabilities flag in  the {{IDirect3DDevice9Video::GetContentProtectionCaps}} method. 	
        /// </remarks>	
        /// <param name="pRandomNumber"> Pointer to a byte array that receives a random number. </param>
        /// <param name="randomNumberSize"> The size of the pRandomNumber array, in bytes. </param>
        /// <returns> If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
        /// <unmanaged>HRESULT StartSessionKeyRefresh([None] VOID* pRandomNumber,[None] UINT RandomNumberSize)</unmanaged>
        public SlimDX2.Result StartSessionKeyRefresh(IntPtr pRandomNumber, int randomNumberSize) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, (void*)pRandomNumber, randomNumberSize);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Switches to a new session key.	
        /// </summary>	
        /// <remarks>	
        ///  Before calling this method, call the <see cref="SlimDX2.Direct3D9.CryptoSession.StartSessionKeyRefresh"/> method. The StartSessionKeyRefresh method gets a random number from the driver, which is used to create a new session key. The new session key does not become active until the application calls  FinishSessionKeyRefresh. After the application calls FinishSessionKeyRefresh, all protected surfaces are encrypted using the new session key. 	
        /// </remarks>	
        /// <returns> If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
        /// <unmanaged>HRESULT FinishSessionKeyRefresh()</unmanaged>
        public SlimDX2.Result FinishSessionKeyRefresh() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the key that is used to decrypt the data returned by the <see cref="SlimDX2.Direct3D9.CryptoSession.EncryptionBlt"/> method.	
        /// </summary>	
        /// <remarks>	
        ///  This method applies only when the driver requires a separate key for the {{EncryptionBlt}} method. If the driver requires a separate key, it sets the D3DCPCAPS_ENCRYPTEDREADBACKKEY flag in the capabilities structure returned by the {{IDirect3DDevice9Video::GetContentProtectionCaps}} method. Otherwise, the driver uses the session key to encrypt the data. Each time this method is called, the driver generates a new key. 	
        /// </remarks>	
        /// <param name="pReadbackKey"> Pointer to a byte array that receives the key. The key is encrypted using the session key. </param>
        /// <param name="keySize"> The size of the pReadbackKey array, in bytes. </param>
        /// <returns> If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
        /// <unmanaged>HRESULT GetEncryptionBltKey([Out] VOID* pReadbackKey,[None] UINT KeySize)</unmanaged>
        public SlimDX2.Result GetEncryptionBltKey(out IntPtr pReadbackKey, int keySize) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pReadbackKey_ = &pReadbackKey)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, pReadbackKey_, keySize);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXBuffer</unmanaged>
    [Guid("8ba5fb08-5195-40e2-ac58-0d989c3a0102")]
    public partial class Buffer : SlimDX2.ComObject {
        public Buffer(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves a pointer to the data in the buffer.	
        /// </summary>	
        /// <unmanaged>void* GetBufferPointer()</unmanaged>
        public IntPtr BufferPointer {
                get { return GetBufferPointer(); }
        }
        
        /// <summary>	
        /// Retrieves the total size of the data in the buffer.	
        /// </summary>	
        /// <unmanaged>int GetBufferSize()</unmanaged>
        public int BufferSize {
                get { return GetBufferSize(); }
        }
        
        /// <summary>	
        /// Retrieves a pointer to the data in the buffer.	
        /// </summary>	
        /// <returns>  {{LPVOID}}  Returns a pointer to the data in the buffer. </returns>
        /// <unmanaged>void* GetBufferPointer()</unmanaged>
        internal IntPtr GetBufferPointer() {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the total size of the data in the buffer.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns the total size of the data in the buffer, in bytes. </returns>
        /// <unmanaged>int GetBufferSize()</unmanaged>
        internal int GetBufferSize() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXSprite</unmanaged>
    [Guid("ba0b762d-7d28-43ec-b9dc-2f84443b0614")]
    public partial class Sprite : SlimDX2.ComObject {
        public Sprite(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the device associated with the sprite object.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the sprite transform.	
        /// </summary>	
        /// <unmanaged>HRESULT GetTransform([Out] D3DXMATRIX* pTransform)</unmanaged>
        public SlimMath.Matrix Transform {
                get { SlimMath.Matrix __output__; GetTransform(out __output__); return __output__; }
                set { SetTransform(ref value); }
        }
        
        /// <summary>	
        /// Retrieves the device associated with the sprite object.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. 	
        /// </remarks>	
        /// <param name="ppDevice"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the Direct3D device object associated with the sprite object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device ppDevice) {
            unsafe {
                IntPtr ppDevice_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &ppDevice_);
                ppDevice = (ppDevice_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppDevice_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the sprite transform.	
        /// </summary>	
        /// <param name="pTransform"> Pointer to a <see cref="SlimMath.Matrix"/> that contains a transform of the sprite from the original world space. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT GetTransform([Out] D3DXMATRIX* pTransform)</unmanaged>
        internal SlimDX2.Result GetTransform(out SlimMath.Matrix pTransform) {
            unsafe {
                pTransform = new SlimMath.Matrix();
                SlimDX2.Result __result__;
                fixed (void* pTransform_ = &pTransform)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, pTransform_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the sprite transform.	
        /// </summary>	
        /// <param name="pTransform"> Pointer to a <see cref="SlimMath.Matrix"/> that contains a transform of the sprite from the original world space. Use this transform to scale, rotate, or transform the sprite. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT SetTransform([None] const D3DXMATRIX* pTransform)</unmanaged>
        internal SlimDX2.Result SetTransform(ref SlimMath.Matrix pTransform) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pTransform_ = &pTransform)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, pTransform_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the right-handed world-view transform for a sprite. A call to this method is required before billboarding or sorting sprites.	
        /// </summary>	
        /// <remarks>	
        ///  A call to this method (or to <see cref="SlimDX2.Direct3D9.Sprite.SetWorldViewLH"/>) is required if the sprite will be rendered with the {{D3DXSprite__BILLBOARD}}, D3DXSprite__SORT_DEPTH_FRONTTOBACK, or D3DXSprite__SORT_DEPTH_BACKTOFRONT flag value in <see cref="SlimDX2.Direct3D9.Sprite.Begin"/>. 	
        /// </remarks>	
        /// <param name="pWorld"> Pointer to a <see cref="SlimMath.Matrix"/> that contains a world transform. If NULL, the identity matrix is used for the world transform. </param>
        /// <param name="pView"> Pointer to a <see cref="SlimMath.Matrix"/> that contains a view transform. If NULL, the identity matrix is used for the view transform. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT SetWorldViewRH([None] const D3DXMATRIX* pWorld,[None] const D3DXMATRIX* pView)</unmanaged>
        public SlimDX2.Result SetWorldViewRH(ref SlimMath.Matrix pWorld, ref SlimMath.Matrix pView) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pWorld_ = &pWorld)
                    fixed (void* pView_ = &pView)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, pWorld_, pView_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the left-handed world-view transform for a sprite. A call to this method is required before billboarding or sorting sprites.	
        /// </summary>	
        /// <remarks>	
        ///  A call to this method (or to <see cref="SlimDX2.Direct3D9.Sprite.SetWorldViewRH"/>) is required if the sprite will be rendered with the {{D3DXSprite__BILLBOARD}}, D3DXSprite__SORT_DEPTH_FRONTTOBACK, or D3DXSprite__SORT_DEPTH_BACKTOFRONT flag value in <see cref="SlimDX2.Direct3D9.Sprite.Begin"/>. 	
        /// </remarks>	
        /// <param name="pWorld"> Pointer to a <see cref="SlimMath.Matrix"/> that contains a world transform. If NULL, the identity matrix is used for the world transform. </param>
        /// <param name="pView"> Pointer to a <see cref="SlimMath.Matrix"/> that contains a view transform. If NULL, the identity matrix is used for the view transform. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT SetWorldViewLH([None] const D3DXMATRIX* pWorld,[None] const D3DXMATRIX* pView)</unmanaged>
        public SlimDX2.Result SetWorldViewLH(ref SlimMath.Matrix pWorld, ref SlimMath.Matrix pView) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pWorld_ = &pWorld)
                    fixed (void* pView_ = &pView)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, pWorld_, pView_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Prepares a device for drawing sprites.	
        /// </summary>	
        /// <remarks>	
        ///  This method must be called from inside a <see cref="SlimDX2.Direct3D9.Device.BeginScene"/> . . . <see cref="SlimDX2.Direct3D9.Device.EndScene"/> sequence. ID3DXSprite::Begin cannot be used as a substitute for either IDirect3DDevice9::BeginScene or <see cref="SlimDX2.Direct3D9.RenderToSurface.BeginScene"/>. This method will set the following states on the device. Render States:  Type (<see cref="SlimDX2.Direct3D9.Renderstatetype"/>)Value D3DRS_ALPHABLENDENABLETRUE D3DRS_ALPHAFUNCD3DCMP_GREATER D3DRS_ALPHAREF0x00 D3DRS_ALPHATESTENABLEAlphaCmpCaps D3DRS_BLENDOPD3DBLENDOP_ADD D3DRS_CLIPPINGTRUE D3DRS_CLIPPLANEENABLEFALSE D3DRS_COLORWRITEENABLED3DCOLORWRITEENABLE_ALPHA | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_RED D3DRS_CULLMODED3DCULL_NONE D3DRS_DESTBLENDD3DBLEND_INVSRCALPHA D3DRS_DIFFUSEMATERIALSOURCED3DMCS_COLOR1 D3DRS_ENABLEADAPTIVETESSELLATIONFALSE D3DRS_FILLMODED3DFILL_SOLID D3DRS_FOGENABLEFALSE D3DRS_INDEXEDVERTEXBLENDENABLEFALSE D3DRS_LIGHTINGFALSE D3DRS_RANGEFOGENABLEFALSE D3DRS_SEPARATEALPHABLENDENABLEFALSE D3DRS_SHADEMODED3DSHADE_GOURAUD D3DRS_SPECULARENABLEFALSE D3DRS_SRCBLENDD3DBLEND_SRCALPHA D3DRS_SRGBWRITEENABLEFALSE D3DRS_STENCILENABLEFALSE D3DRS_VERTEXBLENDFALSE D3DRS_WRAP00    Texture Stage States:  Stage IdentifierType (<see cref="SlimDX2.Direct3D9.Texturestagestatetype"/>)Value 0D3DTSS_ALPHAARG1D3DTA_TEXTURE 0D3DTSS_ALPHAARG2D3DTA_DIFFUSE 0D3DTSS_ALPHAOPD3DTOP_MODULATE 0D3DTSS_COLORARG1D3DTA_TEXTURE 0D3DTSS_COLORARG2D3DTA_DIFFUSE 0D3DTSS_COLOROPD3DTOP_MODULATE 0D3DTSS_TEXCOORDINDEX0 0D3DTSS_TEXTURETRANSFORMFLAGSD3DTTFF_DISABLE 1D3DTSS_ALPHAOPD3DTOP_DISABLE 1D3DTSS_COLOROPD3DTOP_DISABLE    Sampler States:  Sampler Stage IndexType (<see cref="SlimDX2.Direct3D9.Samplerstatetype"/>)Value 0D3DSAMP_ADDRESSUD3DTADDRESS_CLAMP 0D3DSAMP_ADDRESSVD3DTADDRESS_CLAMP 0D3DSAMP_MAGFILTERD3DTEXF_ANISOTROPIC if TextureFilterCaps includes D3DPTFILTERCAPS_MAGFANISOTROPIC; otherwise D3DTEXF_LINEAR 0D3DSAMP_MAXMIPLEVEL0 0D3DSAMP_MAXANISOTROPYMaxAnisotropy 0D3DSAMP_MINFILTERD3DTEXF_ANISOTROPIC if TextureFilterCaps includes D3DPTFILTERCAPS_MINFANISOTROPIC; otherwise D3DTEXF_LINEAR 0D3DSAMP_MIPFILTERD3DTEXF_LINEAR if TextureFilterCaps includes D3DPTFILTERCAPS_MIPFLINEAR; otherwise D3DTEXF_POINT 0D3DSAMP_MIPMAPLODBIAS0 0D3DSAMP_SRGBTEXTURE0    Note This method disables N-patches. 	
        /// </remarks>	
        /// <param name="flags"> Combination of zero or more flags that describe sprite rendering options. For this method, the valid flags are:  D3DXSPRITE_ALPHABLEND D3DXSPRITE__BILLBOARD D3DXSPRITE_DONOTMODIFY_RENDERSTATE D3DXSPRITE_DONOTSAVESTATE D3DXSPRITE_OBJECTSPACE D3DXSPRITE__SORT_DEPTH_BACKTOFRONT D3DXSPRITE__SORT_DEPTH_FRONTTOBACK D3DXSPRITE__SORT_TEXTURE   For a description of the flags and for information on how to control device state capture and device view transforms, see {{D3DXSPRITE}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT Begin([None] int Flags)</unmanaged>
        public SlimDX2.Result Begin(int flags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds a sprite to the list of batched sprites.	
        /// </summary>	
        /// <remarks>	
        ///  To scale, rotate, or translate a sprite, call <see cref="SlimDX2.Direct3D9.Sprite.SetTransform"/> with a matrix that contains the scale, rotate, and translate (SRT) values, before calling ID3DXSprite::Draw. For information about setting SRT values in a matrix, see {{Matrix Transforms}}. 	
        /// </remarks>	
        /// <param name="pTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface that represents the sprite texture. </param>
        /// <param name="pSrcRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure that indicates the portion of the source texture to use for the sprite. If this parameter is NULL, then the entire source image is used for the sprite. </param>
        /// <param name="pCenter"> Pointer to a <see cref="SlimMath.Vector3"/> vector that identifies the center of the sprite. If this argument is NULL, the point (0,0,0) is used, which is the upper-left corner. </param>
        /// <param name="pPosition"> Pointer to a <see cref="SlimMath.Vector3"/> vector that identifies the position of the sprite. If this argument is NULL, the point (0,0,0) is used, which is the upper-left corner. </param>
        /// <param name="color">  <see cref="int"/> type. The color and alpha channels are modulated by this value. A value of 0xFFFFFFFF maintains the original source color and alpha data. Use the {{D3DCOLOR_RGBA}} macro to help generate this color. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT Draw([None] LPDIRECT3DTEXTURE9 pTexture,[None] const RECT* pSrcRect,[None] const D3DXVECTOR3* pCenter,[None] const D3DXVECTOR3* pPosition,[None] D3DCOLOR Color)</unmanaged>
        public SlimDX2.Result Draw(SlimDX2.Direct3D9.Texture pTexture, ref SlimDX2.Rectangle pSrcRect, ref SlimMath.Vector3 pCenter, ref SlimMath.Vector3 pPosition, int color) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pSrcRect_ = &pSrcRect)
                    fixed (void* pCenter_ = &pCenter)
                        fixed (void* pPosition_ = &pPosition)
                            __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, (void*)((pTexture == null)?IntPtr.Zero:pTexture.NativePointer), pSrcRect_, pCenter_, pPosition_, color);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Forces all batched sprites to be submitted to the device. Device states remain as they were after the last call to <see cref="SlimDX2.Direct3D9.Sprite.Begin"/>. The list of batched sprites is then cleared.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT Flush()</unmanaged>
        public SlimDX2.Result Flush() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Calls <see cref="SlimDX2.Direct3D9.Sprite.Flush"/> and restores the device state to how it was before <see cref="SlimDX2.Direct3D9.Sprite.Begin"/> was called.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXSprite::End cannot be used as a substitute for either <see cref="SlimDX2.Direct3D9.Device.EndScene"/> or <see cref="SlimDX2.Direct3D9.RenderToSurface.EndScene"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT End()</unmanaged>
        public SlimDX2.Result End() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost or before resetting a device.	
        /// </summary>	
        /// <remarks>	
        ///  This method should be called whenever the device is lost or before the user calls <see cref="SlimDX2.Direct3D9.Device.Reset"/>. Even if the device was not actually lost, ID3DXSprite::OnLostDevice is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling IDirect3DDevice9::Reset and then <see cref="SlimDX2.Direct3D9.Sprite.OnResetDevice"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT OnLostDevice()</unmanaged>
        public SlimDX2.Result OnLostDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to re-acquire resources and save initial state.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXSprite::OnResetDevice should be called each time the device is reset (using <see cref="SlimDX2.Direct3D9.Device.Reset"/>), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT OnResetDevice()</unmanaged>
        public SlimDX2.Result OnResetDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXFont</unmanaged>
    [Guid("d79dbb70-5f21-4d36-bbc2-ff525c213cdc")]
    public partial class Font : SlimDX2.ComObject {
        public Font(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the Direct3D device associated with the font object.	
        /// </summary>	
        /// <remarks>	
        ///  Note Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Be sure to call <see cref="SlimDX2.ComObject"/> when you are done using this IDirect3DDevice9 interface or you will have a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets a description of the current font object. GetDescW and GetDescA are identical to this method, except that a pointer is returned to a <see cref="SlimDX2.Direct3D9.FontDescw"/> or D3DXFONT_DESCA structure, respectively.	
        /// </summary>	
        /// <remarks>	
        ///  This method describes Unicode font objects if UNICODE is defined. Otherwise GetDescA is called, which returns a pointer to the <see cref="SlimDX2.Direct3D9.FontDesca"/> structure. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDescA([Out] D3DXFONT_DESCA* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.FontDesca DescA {
                get { SlimDX2.Direct3D9.FontDesca __output__; GetDescA(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets a description of the current font object. GetDescW and GetDescA are identical to this method, except that a pointer is returned to a <see cref="SlimDX2.Direct3D9.FontDescw"/> or D3DXFONT_DESCA structure, respectively.	
        /// </summary>	
        /// <remarks>	
        ///  This method describes Unicode font objects if UNICODE is defined. Otherwise GetDescA is called, which returns a pointer to the <see cref="SlimDX2.Direct3D9.FontDesca"/> structure. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDescW([Out] D3DXFONT_DESCW* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.FontDescw Description {
                get { SlimDX2.Direct3D9.FontDescw __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Returns a handle to a display device context (DC) that has the font set.	
        /// </summary>	
        /// <unmanaged>HDC GetDC()</unmanaged>
        public IntPtr DC {
                get { return GetDC(); }
        }
        
        /// <summary>	
        /// Retrieves the Direct3D device associated with the font object.	
        /// </summary>	
        /// <remarks>	
        ///  Note Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Be sure to call <see cref="SlimDX2.ComObject"/> when you are done using this IDirect3DDevice9 interface or you will have a memory leak. 	
        /// </remarks>	
        /// <param name="ppDevice"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the Direct3D device object associated with the font object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device ppDevice) {
            unsafe {
                IntPtr ppDevice_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &ppDevice_);
                ppDevice = (ppDevice_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppDevice_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a description of the current font object. GetDescW and GetDescA are identical to this method, except that a pointer is returned to a <see cref="SlimDX2.Direct3D9.FontDescw"/> or D3DXFONT_DESCA structure, respectively.	
        /// </summary>	
        /// <remarks>	
        ///  This method describes Unicode font objects if UNICODE is defined. Otherwise GetDescA is called, which returns a pointer to the <see cref="SlimDX2.Direct3D9.FontDesca"/> structure. 	
        /// </remarks>	
        /// <param name="pDesc"> Pointer to a <see cref="SlimDX2.Direct3D9.FontDesca"/> structure that describes the font object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetDescA([Out] D3DXFONT_DESCA* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescA(out SlimDX2.Direct3D9.FontDesca pDesc) {
            unsafe {
                SlimDX2.Direct3D9.FontDesca.__Native pDesc_ = new SlimDX2.Direct3D9.FontDesca.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, &pDesc_);
                pDesc = new SlimDX2.Direct3D9.FontDesca();
                pDesc.__MarshalFrom(ref pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a description of the current font object. GetDescW and GetDescA are identical to this method, except that a pointer is returned to a <see cref="SlimDX2.Direct3D9.FontDescw"/> or D3DXFONT_DESCA structure, respectively.	
        /// </summary>	
        /// <remarks>	
        ///  This method describes Unicode font objects if UNICODE is defined. Otherwise GetDescA is called, which returns a pointer to the <see cref="SlimDX2.Direct3D9.FontDesca"/> structure. 	
        /// </remarks>	
        /// <param name="pDesc"> Pointer to a <see cref="SlimDX2.Direct3D9.FontDesca"/> structure that describes the font object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetDescW([Out] D3DXFONT_DESCW* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.FontDescw pDesc) {
            unsafe {
                SlimDX2.Direct3D9.FontDescw.__Native pDesc_ = new SlimDX2.Direct3D9.FontDescw.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, &pDesc_);
                pDesc = new SlimDX2.Direct3D9.FontDescw();
                pDesc.__MarshalFrom(ref pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves font characteristics that are identified in a {{TEXTMETRIC}} structure. This method supports ANSI and Unicode compiler settings.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the structure type. If Unicode is defined, the function returns a TEXTMETRICW structure. Otherwise, the function call returns a TEXTMETRICA structure. 	
        /// </remarks>	
        /// <param name="pTextMetrics"> Pointer to a {{TEXTMETRIC}} structure, which contains font properties. </param>
        /// <returns>  {{BOOL}}  Nonzero if the function is successful; otherwise 0. </returns>
        /// <unmanaged>BOOL GetTextMetricsA([Out] TEXTMETRICA* pTextMetrics)</unmanaged>
        internal bool GetTextMetricsA(out SlimDX2.Windows.Win32.Textmetrica pTextMetrics) {
            unsafe {
                pTextMetrics = new SlimDX2.Windows.Win32.Textmetrica();
                bool __result__;
                fixed (void* pTextMetrics_ = &pTextMetrics)
                    __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, pTextMetrics_));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves font characteristics that are identified in a {{TEXTMETRIC}} structure. This method supports ANSI and Unicode compiler settings.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the structure type. If Unicode is defined, the function returns a TEXTMETRICW structure. Otherwise, the function call returns a TEXTMETRICA structure. 	
        /// </remarks>	
        /// <param name="pTextMetrics"> Pointer to a {{TEXTMETRIC}} structure, which contains font properties. </param>
        /// <returns>  {{BOOL}}  Nonzero if the function is successful; otherwise 0. </returns>
        /// <unmanaged>BOOL GetTextMetricsW([Out] TEXTMETRICW* pTextMetrics)</unmanaged>
        internal bool GetTextMetricsW(out SlimDX2.Windows.Win32.Textmetricw pTextMetrics) {
            unsafe {
                pTextMetrics = new SlimDX2.Windows.Win32.Textmetricw();
                bool __result__;
                fixed (void* pTextMetrics_ = &pTextMetrics)
                    __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, pTextMetrics_));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns a handle to a display device context (DC) that has the font set.	
        /// </summary>	
        /// <returns>  {{HDC}}  Handle to a display DC. </returns>
        /// <unmanaged>HDC GetDC()</unmanaged>
        internal IntPtr GetDC() {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 8 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns information about the placement and orientation of a glyph in a character cell.	
        /// </summary>	
        /// <param name="glyph"> Glyph identifier. </param>
        /// <param name="ppTexture"> Address of a pointer to a <see cref="SlimDX2.Direct3D9.Texture"/> object that contains the glyph. </param>
        /// <param name="pBlackBox"> Pointer to the smallest rectangle object that completely encloses the glyph. </param>
        /// <param name="pCellInc"> Pointer to the two-dimensional vector that connects the origin of the current character cell to the origin of the next character cell. See <see cref="System.Drawing.Point"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT GetGlyphData([None] UINT Glyph,[Out] LPDIRECT3DTEXTURE9* ppTexture,[Out] RECT* pBlackBox,[Out] POINT* pCellInc)</unmanaged>
        public SlimDX2.Result GetGlyphData(int glyph, out SlimDX2.Direct3D9.Texture ppTexture, out SlimDX2.Rectangle pBlackBox, out System.Drawing.Point pCellInc) {
            unsafe {
                IntPtr ppTexture_ = IntPtr.Zero;
                pBlackBox = new SlimDX2.Rectangle();
                pCellInc = new System.Drawing.Point();
                SlimDX2.Result __result__;
                fixed (void* pBlackBox_ = &pBlackBox)
                    fixed (void* pCellInc_ = &pCellInc)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, glyph, &ppTexture_, pBlackBox_, pCellInc_);
                ppTexture = (ppTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(ppTexture_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Loads a series of characters into video memory to improve the efficiency of rendering to the device.	
        /// </summary>	
        /// <remarks>	
        ///  This method generates textures containing glyphs that represent the input characters. The glyphs are drawn as a series of triangles. Characters will not be rendered to the device; {{DrawText}} must still be called to render the characters. However, by pre-loading characters into video memory, DrawText will use substantially fewer CPU resources. This method internally converts characters to glyphs using the GDI function {{GetCharacterPlacement}}. 	
        /// </remarks>	
        /// <param name="first"> ID of the first character to be loaded into video memory. </param>
        /// <param name="last"> ID of the last character to be loaded into video memory. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT PreloadCharacters([None] UINT First,[None] UINT Last)</unmanaged>
        public SlimDX2.Result PreloadCharacters(int first, int last) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, first, last);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Loads a series of glyphs into video memory to improve the efficiency of rendering to the device.	
        /// </summary>	
        /// <remarks>	
        ///  This method generates textures that contain the input glyphs. The glyphs are drawn as a series of triangles. Glyphs will not be rendered to the device; {{DrawText}} must still be called to render the glyphs. However, by pre-loading glyphs into video memory, DrawText will use substantially fewer CPU resources. 	
        /// </remarks>	
        /// <param name="first"> ID of the first glyph to be loaded into video memory. </param>
        /// <param name="last"> ID of the last glyph to be loaded into video memory. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT PreloadGlyphs([None] UINT First,[None] UINT Last)</unmanaged>
        public SlimDX2.Result PreloadGlyphs(int first, int last) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, first, last);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Loads formatted text into video memory to improve the efficiency of rendering to the device. This method supports ANSI and Unicode strings.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to PreloadTextW. Otherwise, the function call resolves to PreloadTextA because ANSI strings are being used. This method generates textures that contain glyphs that represent the input text. The glyphs are drawn as a series of triangles. Text will not be rendered to the device; {{DrawText}} must still be called to render the text. However, by preloading text into video memory, DrawText will use substantially fewer CPU resources. This method internally converts characters to glyphs using the GDI function {{GetCharacterPlacement}}. 	
        /// </remarks>	
        /// <param name="pString"> Pointer to a string of characters to be loaded into video memory. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR; otherwise, the data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="count"> Number of characters in the text string. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT PreloadTextA([None] const char* pString,[None] INT Count)</unmanaged>
        public SlimDX2.Result PreloadTextA(string pString, int count) {
            unsafe {
                IntPtr pString_ = Marshal.StringToHGlobalAnsi(pString);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, (void*)pString_, count);
                Marshal.FreeHGlobal(pString_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Loads formatted text into video memory to improve the efficiency of rendering to the device. This method supports ANSI and Unicode strings.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to PreloadTextW. Otherwise, the function call resolves to PreloadTextA because ANSI strings are being used. This method generates textures that contain glyphs that represent the input text. The glyphs are drawn as a series of triangles. Text will not be rendered to the device; {{DrawText}} must still be called to render the text. However, by preloading text into video memory, DrawText will use substantially fewer CPU resources. This method internally converts characters to glyphs using the GDI function {{GetCharacterPlacement}}. 	
        /// </remarks>	
        /// <param name="pString"> Pointer to a string of characters to be loaded into video memory. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR; otherwise, the data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="count"> Number of characters in the text string. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT PreloadTextW([None] const wchar* pString,[None] INT Count)</unmanaged>
        public SlimDX2.Result PreloadTextW(string pString, int count) {
            unsafe {
                IntPtr pString_ = Marshal.StringToHGlobalUni(pString);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, (void*)pString_, count);
                Marshal.FreeHGlobal(pString_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Draws formatted text. This method supports ANSI and Unicode strings.	
        /// </summary>	
        /// <remarks>	
        ///  The parameters of this method are very similar to those of the GDI {{DrawText}} function. This method supports both ANSI and Unicode strings. This method must be called inside a  {{BeginScene}} ... {{EndScene}} block. The only exception is when an application calls DrawText with DT_CALCRECT to calculate the size of a given block of text. Unless the DT_NOCLIP format is used, this method clips the text so that it does not appear outside the specified rectangle. All formatting is assumed to have multiple lines unless the DT_SINGLELINE format is specified. If the selected font is too large for the rectangle, this method does not attempt to substitute a smaller font. This method supports only fonts whose escapement and orientation are both zero. 	
        /// </remarks>	
        /// <param name="pSprite"> Pointer to an <see cref="SlimDX2.Direct3D9.Sprite"/> object that contains the string. Can be NULL, in which case Direct3D will render the string with its own sprite object. To improve efficiency, a sprite object should be specified if DrawText is to be called more than once in a row. </param>
        /// <param name="pString"> Pointer to a string to draw. If the Count parameter is -1, the string must be null-terminated. </param>
        /// <param name="count"> Specifies the number of characters in the string. If Count is -1, then the pString parameter is assumed to be a pointer to a null-terminated string and DrawText computes the character count automatically. </param>
        /// <param name="pRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure that contains the rectangle, in logical coordinates, in which the text is to be formatted. The coordinate value of the rectangle's right side must be greater than that of its left side. Likewise, the coordinate value of the bottom must be greater than that of the top. </param>
        /// <param name="format">  Specifies the method of formatting the text. It can be any combination of the following values:  ValueMeaning  DT_BOTTOM   Justifies the text to the bottom of the rectangle. This value must be combined with DT_SINGLELINE.   DT_CALCRECT   Determines the width and height of the rectangle. If there are multiple lines of text, DrawText uses the width of the rectangle pointed to by the pRect parameter and extends the base of the rectangle to bound the last line of text. If there is only one line of text, DrawText modifies the right side of the rectangle so that it bounds the last character in the line. In either case, DrawText returns the height of the formatted text but does not draw the text.   DT_CENTER   Centers text horizontally in the rectangle.   DT_EXPANDTABS   Expands tab characters. The default number of characters per tab is eight.   DT_LEFT   Aligns text to the left.   DT_NOCLIP   Draws without clipping. DrawText is somewhat faster when DT_NOCLIP is used.   DT_RIGHT   Aligns text to the right.   DT_RTLREADING   Displays text in right-to-left reading order for bidirectional text when a Hebrew or Arabic font is selected. The default reading order for all text is left-to-right.   DT_SINGLELINE   Displays text on a single line only. Carriage returns and line feeds do not break the line.   DT_TOP   Top-justifies text.   DT_VCENTER   Centers text vertically (single line only).   DT_WORDBREAK   Breaks words. Lines are automatically broken between words if a word would extend past the edge of the rectangle specified by the pRect parameter. A carriage return/line feed sequence also breaks the line.     </param>
        /// <param name="color"> Color of the text. For more information, see <see cref="int"/>. </param>
        /// <returns>  {{INT}}  If the function succeeds, the return value is the height of the text in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from pRect (top to the bottom) of the drawn text. If the function fails, the return value is zero. </returns>
        /// <unmanaged>INT DrawTextA([None] LPD3DXSPRITE pSprite,[None] const char* pString,[None] INT Count,[None] RECT* pRect,[None] int Format,[None] D3DCOLOR Color)</unmanaged>
        public int DrawTextA(SlimDX2.Direct3D9.Sprite pSprite, string pString, int count, ref SlimDX2.Rectangle pRect, int format, int color) {
            unsafe {
                IntPtr pString_ = Marshal.StringToHGlobalAnsi(pString);
                int __result__;
                fixed (void* pRect_ = &pRect)
                    __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, (void*)((pSprite == null)?IntPtr.Zero:pSprite.NativePointer), (void*)pString_, count, pRect_, format, color);
                Marshal.FreeHGlobal(pString_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Draws formatted text. This method supports ANSI and Unicode strings.	
        /// </summary>	
        /// <remarks>	
        ///  The parameters of this method are very similar to those of the GDI {{DrawText}} function. This method supports both ANSI and Unicode strings. This method must be called inside a  {{BeginScene}} ... {{EndScene}} block. The only exception is when an application calls DrawText with DT_CALCRECT to calculate the size of a given block of text. Unless the DT_NOCLIP format is used, this method clips the text so that it does not appear outside the specified rectangle. All formatting is assumed to have multiple lines unless the DT_SINGLELINE format is specified. If the selected font is too large for the rectangle, this method does not attempt to substitute a smaller font. This method supports only fonts whose escapement and orientation are both zero. 	
        /// </remarks>	
        /// <param name="pSprite"> Pointer to an <see cref="SlimDX2.Direct3D9.Sprite"/> object that contains the string. Can be NULL, in which case Direct3D will render the string with its own sprite object. To improve efficiency, a sprite object should be specified if DrawText is to be called more than once in a row. </param>
        /// <param name="pString"> Pointer to a string to draw. If the Count parameter is -1, the string must be null-terminated. </param>
        /// <param name="count"> Specifies the number of characters in the string. If Count is -1, then the pString parameter is assumed to be a pointer to a null-terminated string and DrawText computes the character count automatically. </param>
        /// <param name="pRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure that contains the rectangle, in logical coordinates, in which the text is to be formatted. The coordinate value of the rectangle's right side must be greater than that of its left side. Likewise, the coordinate value of the bottom must be greater than that of the top. </param>
        /// <param name="format">  Specifies the method of formatting the text. It can be any combination of the following values:  ValueMeaning  DT_BOTTOM   Justifies the text to the bottom of the rectangle. This value must be combined with DT_SINGLELINE.   DT_CALCRECT   Determines the width and height of the rectangle. If there are multiple lines of text, DrawText uses the width of the rectangle pointed to by the pRect parameter and extends the base of the rectangle to bound the last line of text. If there is only one line of text, DrawText modifies the right side of the rectangle so that it bounds the last character in the line. In either case, DrawText returns the height of the formatted text but does not draw the text.   DT_CENTER   Centers text horizontally in the rectangle.   DT_EXPANDTABS   Expands tab characters. The default number of characters per tab is eight.   DT_LEFT   Aligns text to the left.   DT_NOCLIP   Draws without clipping. DrawText is somewhat faster when DT_NOCLIP is used.   DT_RIGHT   Aligns text to the right.   DT_RTLREADING   Displays text in right-to-left reading order for bidirectional text when a Hebrew or Arabic font is selected. The default reading order for all text is left-to-right.   DT_SINGLELINE   Displays text on a single line only. Carriage returns and line feeds do not break the line.   DT_TOP   Top-justifies text.   DT_VCENTER   Centers text vertically (single line only).   DT_WORDBREAK   Breaks words. Lines are automatically broken between words if a word would extend past the edge of the rectangle specified by the pRect parameter. A carriage return/line feed sequence also breaks the line.     </param>
        /// <param name="color"> Color of the text. For more information, see <see cref="int"/>. </param>
        /// <returns>  {{INT}}  If the function succeeds, the return value is the height of the text in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from pRect (top to the bottom) of the drawn text. If the function fails, the return value is zero. </returns>
        /// <unmanaged>INT DrawTextW([None] LPD3DXSPRITE pSprite,[None] const wchar* pString,[None] INT Count,[None] RECT* pRect,[None] int Format,[None] D3DCOLOR Color)</unmanaged>
        public int DrawTextW(SlimDX2.Direct3D9.Sprite pSprite, string pString, int count, ref SlimDX2.Rectangle pRect, int format, int color) {
            unsafe {
                IntPtr pString_ = Marshal.StringToHGlobalUni(pString);
                int __result__;
                fixed (void* pRect_ = &pRect)
                    __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, (void*)((pSprite == null)?IntPtr.Zero:pSprite.NativePointer), (void*)pString_, count, pRect_, format, color);
                Marshal.FreeHGlobal(pString_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost, or before resetting a device.	
        /// </summary>	
        /// <remarks>	
        ///  This method should be called whenever the device is lost or before the user calls {{Reset}}. Even if the device was not actually lost, OnLostDevice is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling Reset and then {{OnResetDevice}}. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT OnLostDevice()</unmanaged>
        public SlimDX2.Result OnLostDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to re-acquire resources and save initial state.	
        /// </summary>	
        /// <remarks>	
        ///  OnResetDevice should be called each time the device is reset (using {{Reset}}), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT OnResetDevice()</unmanaged>
        public SlimDX2.Result OnResetDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXRenderToSurface</unmanaged>
    [Guid("6985f346-2c3d-43b3-be8b-daae8a03d894")]
    public partial class RenderToSurface : SlimDX2.ComObject {
        public RenderToSurface(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the Direct3D device associated with the render surface.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the parameters of the render surface.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDesc([Out] D3DXRTS_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.RtsDescription Description {
                get { SlimDX2.Direct3D9.RtsDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the Direct3D device associated with the render surface.	
        /// </summary>	
        /// <param name="ppDevice"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the Direct3D device object associated with the render surface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Be sure to call <see cref="SlimDX2.ComObject"/> when you are done using this IDirect3DDevice9 interface or you will have a memory leak. </returns>
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device ppDevice) {
            unsafe {
                IntPtr ppDevice_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &ppDevice_);
                ppDevice = (ppDevice_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppDevice_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the parameters of the render surface.	
        /// </summary>	
        /// <param name="pDesc"> Pointer to a <see cref="SlimDX2.Direct3D9.RtsDescription"/> structure, describing the parameters of the render surface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3DXRTS_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.RtsDescription pDesc) {
            unsafe {
                pDesc = new SlimDX2.Direct3D9.RtsDescription();
                SlimDX2.Result __result__;
                fixed (void* pDesc_ = &pDesc)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Begins a scene.	
        /// </summary>	
        /// <param name="pSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the render surface. </param>
        /// <param name="pViewport"> Pointer to a <see cref="SlimDX2.Direct3D9.Viewport9"/> structure, describing the viewport for the scene. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL.D3DERR_OUTOFVIDEOMEMORY D3DXERR_INVALIDDATA E_OUTOFMEMORY </returns>
        /// <unmanaged>HRESULT BeginScene([None] LPDIRECT3DSURFACE9 pSurface,[None] const D3DVIEWPORT9* pViewport)</unmanaged>
        public SlimDX2.Result BeginScene(SlimDX2.Direct3D9.Surface pSurface, ref SlimDX2.Direct3D9.Viewport9 pViewport) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pViewport_ = &pViewport)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)((pSurface == null)?IntPtr.Zero:pSurface.NativePointer), pViewport_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Ends a scene.	
        /// </summary>	
        /// <param name="mipFilter"> Filter options, enumerated in {{D3DX_FILTER}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT EndScene([None] int MipFilter)</unmanaged>
        public SlimDX2.Result EndScene(int mipFilter) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, mipFilter);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost or before resetting a device.	
        /// </summary>	
        /// <remarks>	
        ///  This method should be called whenever the device is lost or before the user calls <see cref="SlimDX2.Direct3D9.Device.Reset"/>. Even if the device was not actually lost, ID3DXRenderToSurface::OnLostDevice is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling IDirect3DDevice9::Reset and then ID3DXRenderToSurface::OnResetDevice. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT OnLostDevice()</unmanaged>
        public SlimDX2.Result OnLostDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to re-acquire resources and save initial state.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXRenderToSurface::OnResetDevice should be called each time the device is reset (using <see cref="SlimDX2.Direct3D9.Device.Reset"/>), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT OnResetDevice()</unmanaged>
        public SlimDX2.Result OnResetDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXRenderToEnvMap</unmanaged>
    [Guid("313f1b4b-c7b0-4fa2-9d9d-8d380b64385e")]
    public partial class RenderToEnvMap : SlimDX2.ComObject {
        public RenderToEnvMap(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the Direct3D device associated with the environment map.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the description of the render surface.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDesc([Out] D3DXRTE_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.RteDescription Description {
                get { SlimDX2.Direct3D9.RteDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the Direct3D device associated with the environment map.	
        /// </summary>	
        /// <param name="ppDevice"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface that represents the Direct3D device object associated with the environment map. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. Calling this method increases the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Be sure to call <see cref="SlimDX2.ComObject"/> when you are done using this IDirect3DDevice9 interface or you will have a memory leak. </returns>
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device ppDevice) {
            unsafe {
                IntPtr ppDevice_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &ppDevice_);
                ppDevice = (ppDevice_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppDevice_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the description of the render surface.	
        /// </summary>	
        /// <param name="pDesc"> Pointer to a <see cref="SlimDX2.Direct3D9.RteDescription"/> structure that describes the rendering surface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3DXRTE_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.RteDescription pDesc) {
            unsafe {
                pDesc = new SlimDX2.Direct3D9.RteDescription();
                SlimDX2.Result __result__;
                fixed (void* pDesc_ = &pDesc)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Initiate the rendering of a cubic environment map.	
        /// </summary>	
        /// <remarks>	
        ///  See <see cref="SlimDX2.Direct3D9.RenderToEnvMap.Face"/> to draw each of the 6 faces. 	
        /// </remarks>	
        /// <param name="pCubeTex"> Pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface that represents the cube texture to which to render. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT BeginCube([None] LPDIRECT3DCUBETEXTURE9 pCubeTex)</unmanaged>
        public SlimDX2.Result BeginCube(SlimDX2.Direct3D9.CubeTexture pCubeTex) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)((pCubeTex == null)?IntPtr.Zero:pCubeTex.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Initiate the rendering of a spherical environment map.	
        /// </summary>	
        /// <remarks>	
        ///  See <see cref="SlimDX2.Direct3D9.RenderToEnvMap.Face"/> to draw the face. 	
        /// </remarks>	
        /// <param name="pTex"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface that represents the texture to which to render. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL.E_FAIL </returns>
        /// <unmanaged>HRESULT BeginSphere([None] LPDIRECT3DTEXTURE9 pTex)</unmanaged>
        public SlimDX2.Result BeginSphere(SlimDX2.Direct3D9.Texture pTex) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)((pTex == null)?IntPtr.Zero:pTex.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Initiate the rendering of a hemispheric environment map.	
        /// </summary>	
        /// <remarks>	
        ///  See <see cref="SlimDX2.Direct3D9.RenderToEnvMap.Face"/> to draw the face. 	
        /// </remarks>	
        /// <param name="pTexZPos"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface that represents the positive texture render surface. </param>
        /// <param name="pTexZNeg"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface that represents the negative texture render surface. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL.E_FAIL </returns>
        /// <unmanaged>HRESULT BeginHemisphere([None] LPDIRECT3DTEXTURE9 pTexZPos,[None] LPDIRECT3DTEXTURE9 pTexZNeg)</unmanaged>
        public SlimDX2.Result BeginHemisphere(SlimDX2.Direct3D9.Texture pTexZPos, SlimDX2.Direct3D9.Texture pTexZNeg) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)((pTexZPos == null)?IntPtr.Zero:pTexZPos.NativePointer), (void*)((pTexZNeg == null)?IntPtr.Zero:pTexZNeg.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Initiate the rendering of a parabolic environment map.	
        /// </summary>	
        /// <remarks>	
        ///  See <see cref="SlimDX2.Direct3D9.RenderToEnvMap.Face"/> to draw the faces. 	
        /// </remarks>	
        /// <param name="pTexZPos"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface that represents the positive render texture. </param>
        /// <param name="pTexZNeg"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface that represents the negative render texture. </param>
        /// <returns>  <see cref="int"/>  If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL.E_FAIL </returns>
        /// <unmanaged>HRESULT BeginParabolic([None] LPDIRECT3DTEXTURE9 pTexZPos,[None] LPDIRECT3DTEXTURE9 pTexZNeg)</unmanaged>
        public SlimDX2.Result BeginParabolic(SlimDX2.Direct3D9.Texture pTexZPos, SlimDX2.Direct3D9.Texture pTexZNeg) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, (void*)((pTexZPos == null)?IntPtr.Zero:pTexZPos.NativePointer), (void*)((pTexZNeg == null)?IntPtr.Zero:pTexZNeg.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Initiate the drawing of each face of an environment map.	
        /// </summary>	
        /// <remarks>	
        ///  This method must be called once for each type of environment map. The only exception is a cubic environment map which requires this method to be called six times, once for each face in D3DCUBEMAP_FACES. For more information, see {{Environment Mapping (Direct3D 9)}}.  	
        /// </remarks>	
        /// <param name="face"> The first face of the environmental cube map. See <see cref="SlimDX2.Direct3D9.CubemapFaces"/>. </param>
        /// <param name="mipFilter"> A valid combination of one or more {{D3DX_FILTER}} flags. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT Face([None] D3DCUBEMAP_FACES Face,[None] int MipFilter)</unmanaged>
        public SlimDX2.Result Face(SlimDX2.Direct3D9.CubemapFaces face, int mipFilter) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, unchecked((int)face), mipFilter);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Restore all render targets and, if needed, compose all the rendered faces into the environment map surface.	
        /// </summary>	
        /// <param name="mipFilter"> A valid combination of one or more {{D3DX_FILTER}} flags. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT End([None] int MipFilter)</unmanaged>
        public SlimDX2.Result End(int mipFilter) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, mipFilter);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost, or before resetting a device.	
        /// </summary>	
        /// <remarks>	
        ///  This method should be called whenever the device is lost or before the user calls <see cref="SlimDX2.Direct3D9.Device.Reset"/>. Even if the device was not actually lost, ID3DXRenderToEnvMap::OnLostDevice is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling IDirect3DDevice9::Reset and then <see cref="SlimDX2.Direct3D9.RenderToEnvMap.OnResetDevice"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT OnLostDevice()</unmanaged>
        public SlimDX2.Result OnLostDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to re-acquire resources and save initial state.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXRenderToEnvMap::OnResetDevice should be called each time the device is reset (using <see cref="SlimDX2.Direct3D9.Device.Reset"/>), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT OnResetDevice()</unmanaged>
        public SlimDX2.Result OnResetDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXLine</unmanaged>
    [Guid("d379ba7f-9042-4ac4-9f5e-58192a4c6bd8")]
    public partial class Line : SlimDX2.ComObject {
        public Line(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the Direct3D device associated with the line object.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the line stipple pattern.	
        /// </summary>	
        /// <unmanaged>int GetPattern()</unmanaged>
        public int Pattern {
                get { return GetPattern(); }
                set { SetPattern(value); }
        }
        
        /// <summary>	
        /// Gets the stipple-pattern scale value.	
        /// </summary>	
        /// <unmanaged>FLOAT GetPatternScale()</unmanaged>
        public float PatternScale {
                get { return GetPatternScale(); }
                set { SetPatternScale(value); }
        }
        
        /// <summary>	
        /// Gets the thickness of the line.	
        /// </summary>	
        /// <unmanaged>FLOAT GetWidth()</unmanaged>
        public float Width {
                get { return GetWidth(); }
                set { SetWidth(value); }
        }
        
        /// <summary>	
        /// Gets the line antialiasing state.	
        /// </summary>	
        /// <unmanaged>BOOL GetAntialias()</unmanaged>
        public bool Antialias {
                get { return GetAntialias(); }
                set { SetAntialias(value); }
        }
        
        /// <summary>	
        /// Gets the OpenGL-style line-drawing mode.	
        /// </summary>	
        /// <unmanaged>BOOL GetGLLines()</unmanaged>
        public bool GLLines {
                get { return GetGLLines(); }
                set { SetGLLines(value); }
        }
        
        /// <summary>	
        /// Retrieves the Direct3D device associated with the line object.	
        /// </summary>	
        /// <param name="ppDevice"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the Direct3D device object associated with the line object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device ppDevice) {
            unsafe {
                IntPtr ppDevice_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &ppDevice_);
                ppDevice = (ppDevice_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppDevice_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Prepares a device for drawing lines.	
        /// </summary>	
        /// <remarks>	
        ///  Calling ID3DXLine::Begin is optional. If called outside of a ID3DXLine::Begin/ID3DXLine::End sequence, the draw functions will internally call ID3DXLine::Begin and ID3DXLine::End. To avoid extra overhead, this method should be used if more than one draw function will be called successively. This method must be called from inside an <see cref="SlimDX2.Direct3D9.Device.BeginScene"/> and <see cref="SlimDX2.Direct3D9.Device.EndScene"/> sequence. ID3DXLine::Begin cannot be used as a substitute for either <see cref="SlimDX2.Direct3D9.Device.BeginScene"/> or <see cref="SlimDX2.Direct3D9.RenderToSurface.BeginScene"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT Begin()</unmanaged>
        public SlimDX2.Result Begin() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Draws a line strip in screen space. Input is in the form of an array that defines points (of <see cref="SlimMath.Vector2"/>) on the line strip.	
        /// </summary>	
        /// <param name="pVertexList"> Array of vertices that make up the line. See <see cref="SlimMath.Vector2"/>. </param>
        /// <param name="dwVertexListCount"> Number of vertices in the vertex list. </param>
        /// <param name="color"> Color of the line. See <see cref="int"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT Draw([None] const D3DXVECTOR2* pVertexList,[None] int dwVertexListCount,[None] D3DCOLOR Color)</unmanaged>
        public SlimDX2.Result Draw(ref SlimMath.Vector2 pVertexList, int dwVertexListCount, int color) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pVertexList_ = &pVertexList)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, pVertexList_, dwVertexListCount, color);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Draws a line strip in screen space with a specified input transformation matrix.	
        /// </summary>	
        /// <param name="pVertexList"> Array of vertices that make up the line. See <see cref="SlimMath.Vector3"/>. </param>
        /// <param name="dwVertexListCount"> Number of vertices in the vertex list. </param>
        /// <param name="pTransform"> A scale, rotate, and translate (SRT) matrix for transforming the points. See <see cref="SlimMath.Matrix"/>. If this matrix is a projection matrix, any stippled lines will be drawn with a perspective-correct stippling pattern. Or, you can transform the vertices and use <see cref="SlimDX2.Direct3D9.Line.Draw"/> to draw the line with a nonperspective-correct stipple pattern. </param>
        /// <param name="color"> Color of the line. See <see cref="int"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT DrawTransform([None] const D3DXVECTOR3* pVertexList,[None] int dwVertexListCount,[None] const D3DXMATRIX* pTransform,[None] D3DCOLOR Color)</unmanaged>
        public SlimDX2.Result DrawTransform(ref SlimMath.Vector3 pVertexList, int dwVertexListCount, ref SlimMath.Matrix pTransform, int color) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pVertexList_ = &pVertexList)
                    fixed (void* pTransform_ = &pTransform)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, pVertexList_, dwVertexListCount, pTransform_, color);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Applies a stipple pattern to the line.	
        /// </summary>	
        /// <param name="dwPattern"> Describes the stipple pattern: 1 is opaque, 0 is transparent. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT SetPattern([None] int dwPattern)</unmanaged>
        internal SlimDX2.Result SetPattern(int dwPattern) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, dwPattern);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the line stipple pattern.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns the line stipple pattern: 1 is opaque, 0 is transparent. </returns>
        /// <unmanaged>int GetPattern()</unmanaged>
        internal int GetPattern() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Stretches the stipple pattern along the line direction.	
        /// </summary>	
        /// <param name="fPatternScale"> Stipple pattern scaling value. 1.0f is the default value and represents no scaling. A value less than 1.0f shrinks the pattern, and a value greater than 1.0 stretches the pattern. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT SetPatternScale([None] FLOAT fPatternScale)</unmanaged>
        internal SlimDX2.Result SetPatternScale(float fPatternScale) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, fPatternScale);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the stipple-pattern scale value.	
        /// </summary>	
        /// <returns>  {{FLOAT}}  Returns the value used to scale the stipple-pattern. 1.0f is the default value and represents no scaling. A value less than 1.0f shrinks the pattern, and a value greater than 1.0 stretches the pattern. </returns>
        /// <unmanaged>FLOAT GetPatternScale()</unmanaged>
        internal float GetPatternScale() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct3D9.LocalInterop.Callifloat(_nativePointer, 10 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Specifies the thickness of the line.	
        /// </summary>	
        /// <param name="fWidth"> Describes the line width. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT SetWidth([None] FLOAT fWidth)</unmanaged>
        internal SlimDX2.Result SetWidth(float fWidth) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, fWidth);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the thickness of the line.	
        /// </summary>	
        /// <returns>  {{FLOAT}}  The line thickness. </returns>
        /// <unmanaged>FLOAT GetWidth()</unmanaged>
        internal float GetWidth() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct3D9.LocalInterop.Callifloat(_nativePointer, 12 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Toggles line antialiasing.	
        /// </summary>	
        /// <param name="bAntialias"> Toggles antialiasing on and off. TRUE turns antialiasing on, and FALSE turns antialiasing off. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT SetAntialias([None] BOOL bAntialias)</unmanaged>
        internal SlimDX2.Result SetAntialias(bool bAntialias) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, (bAntialias?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the line antialiasing state.	
        /// </summary>	
        /// <returns>  {{BOOL}}  Returns the antialiasing switch value. TRUE means antialiasing is on, and FALSE means antialiasing is off. </returns>
        /// <unmanaged>BOOL GetAntialias()</unmanaged>
        internal bool GetAntialias() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Toggles the mode to draw OpenGL-style lines.	
        /// </summary>	
        /// <param name="bGLLines"> Toggles OpenGL-style line drawing. TRUE enables OpenGL-style lines, and FALSE enables Direct3D-style lines. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT SetGLLines([None] BOOL bGLLines)</unmanaged>
        internal SlimDX2.Result SetGLLines(bool bGLLines) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, (bGLLines?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the OpenGL-style line-drawing mode.	
        /// </summary>	
        /// <returns>  {{BOOL}}  Returns TRUE if OpenGL-style lines are enabled, and FALSE if Direct3D-style lines are enabled. </returns>
        /// <unmanaged>BOOL GetGLLines()</unmanaged>
        internal bool GetGLLines() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Restores the device state to how it was when <see cref="SlimDX2.Direct3D9.Line.Begin"/> was called.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXLine::End cannot be used as a substitute for either <see cref="SlimDX2.Direct3D9.Device.EndScene"/> or <see cref="SlimDX2.Direct3D9.RenderToSurface.EndScene"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT End()</unmanaged>
        public SlimDX2.Result End() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost, or before resetting a device.	
        /// </summary>	
        /// <remarks>	
        ///  This method should be called whenever the device is lost or before the user calls <see cref="SlimDX2.Direct3D9.Device.Reset"/>. Even if the device was not actually lost, ID3DXLine::OnLostDevice is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling IDirect3DDevice9::Reset and then <see cref="SlimDX2.Direct3D9.Line.OnResetDevice"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT OnLostDevice()</unmanaged>
        public SlimDX2.Result OnLostDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to re-acquire resources and save initial state.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXLine::OnResetDevice should be called each time the device is reset (using <see cref="SlimDX2.Direct3D9.Device.Reset"/>), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT OnResetDevice()</unmanaged>
        public SlimDX2.Result OnResetDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXFile</unmanaged>
    [Guid("cef08cf9-7b4f-4429-9624-2a690a933201")]
    public partial class File : SlimDX2.ComObject {
        public File(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Creates an enumerator object that will read a .x file.	
        /// </summary>	
        /// <remarks>	
        ///  After using this method, use one of the <see cref="SlimDX2.Direct3D9.FileEnumObject"/> methods to retrieve a data object. 	
        /// </remarks>	
        /// <param name="arg0"> The data source. Either:  A file name A <see cref="SlimDX2.Direct3D9.FFileloadmemory"/> structure A <see cref="SlimDX2.Direct3D9.FFileloadresource"/> structure   Depending on the value of loadflags. </param>
        /// <param name="arg1"> Value that specifies the source of the data. This value can be one of the {{D3DXF_FILELOADOPTIONS}} flags. </param>
        /// <param name="arg2"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.FileEnumObject"/> interface, representing the created enumerator object.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADVALUE, D3DXFERR_PARSEERROR. </returns>
        /// <unmanaged>HRESULT CreateEnumObject([None] LPCVOID arg0,[None] D3DXF_FILELOADOPTIONS arg1,[None] ID3DXFileEnumObject** arg2)</unmanaged>
        public SlimDX2.Result CreateEnumObject(IntPtr arg0, int arg1, out SlimDX2.Direct3D9.FileEnumObject arg2) {
            unsafe {
                IntPtr arg2_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, (void*)arg0, arg1, &arg2_);
                arg2 = (arg2_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileEnumObject(arg2_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a save object that will be used to save data to a .x file.	
        /// </summary>	
        /// <remarks>	
        ///  After using this method, use methods of the <see cref="SlimDX2.Direct3D9.FileSaveObject"/> interface to create data objects and to save templates or data. For the saved file format dwFileFormat, one of the binary, legacy binary, or text flags in {{File Formats}} must be specified. The file can be compressed by using the optional D3DXF_FILEFORMAT_COMPRESSED flag. The file format values can be combined in a logical OR to create compressed text or compressed binary files. If you indicate that the file format should be text and compressed, the file will be written out first as text and then compressed. However, compressed text files are not as efficient as binary text files; in most cases, therefore, you will want to indicate binary and compressed. 	
        /// </remarks>	
        /// <param name="arg0"> Pointer to the name of the file to use for saving data. </param>
        /// <param name="arg1"> Value that specifies the name of the file to which data is to be saved. This value can be one of the {{File Save Options}} flags. </param>
        /// <param name="arg2"> Indicates the format to use when saving the .x file. This value can be one of the {{File Formats}} flags. For more information, see Remarks. </param>
        /// <param name="arg3"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.FileSaveObject"/> interface, representing the created save object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADVALUE, D3DXFERR_PARSEERROR. </returns>
        /// <unmanaged>HRESULT CreateSaveObject([None] LPCVOID arg0,[None] D3DXF_FILESAVEOPTIONS arg1,[None] D3DXF_FILEFORMAT arg2,[None] ID3DXFileSaveObject** arg3)</unmanaged>
        public SlimDX2.Result CreateSaveObject(IntPtr arg0, int arg1, int arg2, out SlimDX2.Direct3D9.FileSaveObject arg3) {
            unsafe {
                IntPtr arg3_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)arg0, arg1, arg2, &arg3_);
                arg3 = (arg3_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileSaveObject(arg3_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Registers custom templates.	
        /// </summary>	
        /// <remarks>	
        ///  The following code fragment provides an example call to RegisterTemplates And example contents for the buffer to which pvData points. 	
        /// <code> #define XSKINEXP_TEMPLATES \ "xof 0303txt 0032\ template XSkinMeshHeader \ { \ &lt;3CF169CE-FF7C-44ab-93C0-F78F62D172E2&gt; \ WORD nMaxSkinWeightsPerVertex; \ WORD nMaxSkinWeightsPerFace; \ WORD nBones; \ } \ template VertexDuplicationIndices \ { \ &lt;B8D65549-D7C9-4995-89CF-53A9A8B031E3&gt; \ DWORD nIndices; \ DWORD nOriginalVertices; \ array DWORD indices[nIndices]; \ } \ template SkinWeights \ { \ &lt;6F0D123B-BAD2-4167-A0D0-80224F25FABB&gt; \ STRING transformNodeName;\ DWORD nWeights; \ array DWORD vertexIndices[nWeights]; \ array float weights[nWeights]; \ Matrix4x4 matrixOffset; \ }"	
        /// .	
        /// .	
        /// . LPD3DXFILE pD3DXFile = NULL; if ( FAILED  (hr = pD3DXFile-&gt;RegisterTemplates(  (LPVOID)XSKINEXP_TEMPLATES, sizeof( XSKINEXP_TEMPLATES ) - 1 ) ) )	
        /// goto End; </code>	
        /// 	
        ///  All templates must specify a name and a UUID. This method calls the {{RegisterEnumTemplates}} method, obtaining an <see cref="SlimDX2.Direct3D9.FileEnumObject"/> interface pointer by calling {{CreateEnumObject}} with pvData as the first parameter. 	
        /// </remarks>	
        /// <param name="arg0"> Pointer to a buffer consisting of a .x file in text or binary format that contains templates. </param>
        /// <param name="arg1"> Size of the buffer pointed to by pvData, in bytes. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADVALUE, D3DXFERR_PARSEERROR. </returns>
        /// <unmanaged>HRESULT RegisterTemplates([None] LPCVOID arg0,[None] SIZE_T arg1)</unmanaged>
        public SlimDX2.Result RegisterTemplates(IntPtr arg0, SlimDX2.Size arg1) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)arg0, (void*)arg1);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Registers custom templates, given an <see cref="SlimDX2.Direct3D9.FileEnumObject"/> enumeration object.	
        /// </summary>	
        /// <remarks>	
        ///  When this method is called, it copies templates stored with the ID3DXFileEnumObject, representing the file, to the local template store of the <see cref="SlimDX2.Direct3D9.File"/> object. If an <see cref="SlimDX2.Direct3D9.FileEnumObject"/> pointer is not available, call the {{RegisterTemplates}} method instead. 	
        /// </remarks>	
        /// <param name="arg0"> Pointer to an <see cref="SlimDX2.Direct3D9.FileEnumObject"/> enumeration object that contains templates. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK . If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT RegisterEnumTemplates([None] ID3DXFileEnumObject* arg0)</unmanaged>
        public SlimDX2.Result RegisterEnumTemplates(SlimDX2.Direct3D9.FileEnumObject arg0) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)((arg0 == null)?IntPtr.Zero:arg0.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXFileSaveObject</unmanaged>
    [Guid("cef08cfa-7b4f-4429-9624-2a690a933201")]
    public partial class FileSaveObject : SlimDX2.ComObject {
        public FileSaveObject(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the <see cref="SlimDX2.Direct3D9.File"/> interface of the object that created this <see cref="SlimDX2.Direct3D9.FileSaveObject"/> object.	
        /// </summary>	
        /// <unmanaged>HRESULT GetFile([Out] ID3DXFile** arg0)</unmanaged>
        public SlimDX2.Direct3D9.File File {
                get { SlimDX2.Direct3D9.File __output__; GetFile(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the <see cref="SlimDX2.Direct3D9.File"/> interface of the object that created this <see cref="SlimDX2.Direct3D9.FileSaveObject"/> object.	
        /// </summary>	
        /// <param name="arg0"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.File"/> object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADVALUE, E_NOINTERFACE, E_POINTER. </returns>
        /// <unmanaged>HRESULT GetFile([Out] ID3DXFile** arg0)</unmanaged>
        internal SlimDX2.Result GetFile(out SlimDX2.Direct3D9.File arg0) {
            unsafe {
                IntPtr arg0_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &arg0_);
                arg0 = (arg0_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.File(arg0_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds a data object as a child of the <see cref="SlimDX2.Direct3D9.FileSaveData"/> object.	
        /// </summary>	
        /// <remarks>	
        ///  If a data reference object will reference the data object, either the szName or pId parameter must be non-NULL. Save the created data to disk by using the <see cref="SlimDX2.Direct3D9.FileSaveObject.Save"/> method. 	
        /// </remarks>	
        /// <param name="arg0"> GUID representing the data object's template. </param>
        /// <param name="arg1"> Pointer to the name of the data object. Specify NULL if the object does not have a name. </param>
        /// <param name="arg2"> Pointer to a GUID representing the data object. Specify NULL if the object does not have a GUID. </param>
        /// <param name="arg3"> Size of the data object, in bytes. </param>
        /// <param name="arg4"> Pointer to a buffer containing all required data in the data object. </param>
        /// <param name="arg5"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.FileSaveData"/> interface, representing the file data node to which the data object will be added. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADOBJECT, DXFILEERR_BADVALUE, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT AddDataObject([None] REFGUID arg0,[None] const char* arg1,[None] const GUID* arg2,[None] SIZE_T arg3,[None] LPCVOID arg4,[None] ID3DXFileSaveData** arg5)</unmanaged>
        public SlimDX2.Result AddDataObject(Guid arg0, string arg1, ref Guid arg2, SlimDX2.Size arg3, IntPtr arg4, out SlimDX2.Direct3D9.FileSaveData arg5) {
            unsafe {
                IntPtr arg1_ = Marshal.StringToHGlobalAnsi(arg1);
                IntPtr arg5_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* arg2_ = &arg2)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, &arg0, (void*)arg1_, arg2_, (void*)arg3, (void*)arg4, &arg5_);
                Marshal.FreeHGlobal(arg1_ );
                arg5 = (arg5_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileSaveData(arg5_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Saves a data object and its children to a .x file on disk.	
        /// </summary>	
        /// <remarks>	
        ///  After this method succeeds, <see cref="SlimDX2.Direct3D9.FileSaveObject.AddDataObject"/>, <see cref="SlimDX2.Direct3D9.FileSaveData.AddDataObject"/> and <see cref="SlimDX2.Direct3D9.FileSaveData.AddDataReference"/> can no longer be called until a new <see cref="SlimDX2.Direct3D9.File"/> object is created. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be the following: D3DXFERR_BADOBJECT. </returns>
        /// <unmanaged>HRESULT Save()</unmanaged>
        public SlimDX2.Result Save() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXFileSaveData</unmanaged>
    [Guid("cef08cfb-7b4f-4429-9624-2a690a933201")]
    public partial class FileSaveData : SlimDX2.ComObject {
        public FileSaveData(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves a pointer to this <see cref="SlimDX2.Direct3D9.FileSaveObject"/> file data node.	
        /// </summary>	
        /// <unmanaged>HRESULT GetSave([Out] ID3DXFileSaveObject** arg0)</unmanaged>
        public SlimDX2.Direct3D9.FileSaveObject Save {
                get { SlimDX2.Direct3D9.FileSaveObject __output__; GetSave(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the template ID of this file data node.	
        /// </summary>	
        /// <unmanaged>HRESULT GetType([Out] GUID* arg0)</unmanaged>
        public Guid TypeInfo {
                get { Guid __output__; GetTypeInfo(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves a pointer to this <see cref="SlimDX2.Direct3D9.FileSaveObject"/> file data node.	
        /// </summary>	
        /// <param name="arg0"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.FileSaveObject"/> interface representing this file data node. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT GetSave([Out] ID3DXFileSaveObject** arg0)</unmanaged>
        internal SlimDX2.Result GetSave(out SlimDX2.Direct3D9.FileSaveObject arg0) {
            unsafe {
                IntPtr arg0_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &arg0_);
                arg0 = (arg0_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileSaveObject(arg0_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the name of this <see cref="SlimDX2.Direct3D9.FileSaveData"/> file data node.	
        /// </summary>	
        /// <remarks>	
        ///  For this method to succeed, either szName or puiSize must be non-NULL. 	
        /// </remarks>	
        /// <param name="arg0"> Address of a pointer to receive the name of this file data node. If this parameter is NULL, then puiSize will return the size of the string. If szName points to valid memory, the name of this file data node will be copied into szName up to the number of characters given by puiSize .  </param>
        /// <param name="arg1"> Pointer to the size of the string that represents the name of this file data node. This parameter can be NULL if szName provides a reference to the name. This parameter will return the size of the string if szName is NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT GetName([None] LPSTR arg0,[Out] SIZE_T* arg1)</unmanaged>
        public SlimDX2.Result GetName(string arg0, out SlimDX2.Size arg1) {
            unsafe {
                IntPtr arg0_ = Marshal.StringToHGlobalAnsi(arg0);
                SlimDX2.Result __result__;
                fixed (void* arg1_ = &arg1)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)arg0_, arg1_);
                Marshal.FreeHGlobal(arg0_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the GUID of this <see cref="SlimDX2.Direct3D9.FileSaveData"/> file data node.	
        /// </summary>	
        /// <param name="arg0"> Pointer to a GUID to receive the ID of this file data node. If the object has no ID, the returned parameter value will be GUID_NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT GetId([None] LPGUID arg0)</unmanaged>
        public SlimDX2.Result GetId(Guid arg0) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, &arg0);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the template ID of this file data node.	
        /// </summary>	
        /// <param name="arg0"> Pointer to the GUID representing the template in this file data node. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADOBJECT, D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT GetType([Out] GUID* arg0)</unmanaged>
        internal SlimDX2.Result GetTypeInfo(out Guid arg0) {
            unsafe {
                arg0 = new Guid();
                SlimDX2.Result __result__;
                fixed (void* arg0_ = &arg0)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, arg0_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds a data object as a child of the <see cref="SlimDX2.Direct3D9.FileSaveData"/> file data node.	
        /// </summary>	
        /// <param name="arg0"> GUID representing the data object's template. </param>
        /// <param name="arg1"> Pointer to the name of the data object to add. Specify NULL if the object does not have a name. </param>
        /// <param name="arg2"> Pointer to a GUID representing the data object. The data object must have been registered with <see cref="SlimDX2.Direct3D9.File.RegisterTemplates"/> or <see cref="SlimDX2.Direct3D9.File.RegisterEnumTemplates"/>. Specify NULL if the object does not have a GUID. </param>
        /// <param name="arg3"> Size of the data object, in bytes. </param>
        /// <param name="arg4"> Pointer to a buffer containing all required data in the data object. </param>
        /// <param name="arg5"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.FileSaveData"/> interface, representing the file data node to which the data object will be added. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADOBJECT, D3DXFERR_BADVALUE, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT AddDataObject([None] REFGUID arg0,[None] const char* arg1,[None] const GUID* arg2,[None] SIZE_T arg3,[None] LPCVOID arg4,[None] ID3DXFileSaveData** arg5)</unmanaged>
        public SlimDX2.Result AddDataObject(Guid arg0, string arg1, ref Guid arg2, SlimDX2.Size arg3, IntPtr arg4, out SlimDX2.Direct3D9.FileSaveData arg5) {
            unsafe {
                IntPtr arg1_ = Marshal.StringToHGlobalAnsi(arg1);
                IntPtr arg5_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* arg2_ = &arg2)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, &arg0, (void*)arg1_, arg2_, (void*)arg3, (void*)arg4, &arg5_);
                Marshal.FreeHGlobal(arg1_ );
                arg5 = (arg5_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileSaveData(arg5_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds a data reference as a child of this <see cref="SlimDX2.Direct3D9.FileSaveData"/> file data node. The data reference points to a file data object.	
        /// </summary>	
        /// <remarks>	
        ///  The file data object being referenced must have either a name or a GUID. The file data object must also derive from a different parent <see cref="SlimDX2.Direct3D9.FileSaveData"/> object. 	
        /// </remarks>	
        /// <param name="arg0"> Pointer to the name of the data object to add by reference. Specify NULL if the data object does not have a name. </param>
        /// <param name="arg1"> Pointer to a GUID representing the data object to add by reference. If NULL, a reference will be added that points to the data object with the name given by szName. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADOBJECT, D3DXFERR_BADVALUE, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT AddDataReference([None] const char* arg0,[None] const GUID* arg1)</unmanaged>
        public SlimDX2.Result AddDataReference(string arg0, ref Guid arg1) {
            unsafe {
                IntPtr arg0_ = Marshal.StringToHGlobalAnsi(arg0);
                SlimDX2.Result __result__;
                fixed (void* arg1_ = &arg1)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, (void*)arg0_, arg1_);
                Marshal.FreeHGlobal(arg0_ );
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXFileEnumObject</unmanaged>
    [Guid("cef08cfc-7b4f-4429-9624-2a690a933201")]
    public partial class FileEnumObject : SlimDX2.ComObject {
        public FileEnumObject(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the <see cref="SlimDX2.Direct3D9.File"/> object.	
        /// </summary>	
        /// <unmanaged>HRESULT GetFile([Out] ID3DXFile** arg0)</unmanaged>
        public SlimDX2.Direct3D9.File File {
                get { SlimDX2.Direct3D9.File __output__; GetFile(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the number of child objects in this file data object.	
        /// </summary>	
        /// <unmanaged>HRESULT GetChildren([Out] SIZE_T* arg0)</unmanaged>
        public SlimDX2.Size Children {
                get { SlimDX2.Size __output__; GetChildren(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the <see cref="SlimDX2.Direct3D9.File"/> object.	
        /// </summary>	
        /// <param name="arg0"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.File"/> interface, representing the returned object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT GetFile([Out] ID3DXFile** arg0)</unmanaged>
        internal SlimDX2.Result GetFile(out SlimDX2.Direct3D9.File arg0) {
            unsafe {
                IntPtr arg0_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &arg0_);
                arg0 = (arg0_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.File(arg0_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of child objects in this file data object.	
        /// </summary>	
        /// <param name="arg0"> Address of a pointer to receive the number of child objects in this file data object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT GetChildren([Out] SIZE_T* arg0)</unmanaged>
        internal SlimDX2.Result GetChildren(out SlimDX2.Size arg0) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* arg0_ = &arg0)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, arg0_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a child object in this file data object.	
        /// </summary>	
        /// <param name="arg0"> ID of the child object to retrieve. </param>
        /// <param name="arg1"> Address of a pointer to receive the child object's interface pointer. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DXFERR_BADVALUE, D3DXFERR_NOMOREOBJECTS. </returns>
        /// <unmanaged>HRESULT GetChild([None] SIZE_T arg0,[Out] ID3DXFileData** arg1)</unmanaged>
        public SlimDX2.Result GetChild(SlimDX2.Size arg0, out SlimDX2.Direct3D9.FileData arg1) {
            unsafe {
                IntPtr arg1_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)arg0, &arg1_);
                arg1 = (arg1_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileData(arg1_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the data object that has the specified GUID.	
        /// </summary>	
        /// <remarks>	
        ///  Obtain the GUID rguid of the current file data object with the <see cref="SlimDX2.Direct3D9.FileData.GetId"/> method. 	
        /// </remarks>	
        /// <param name="arg0"> Reference to the requested GUID.  </param>
        /// <param name="arg1"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.FileData"/> interface, representing the returned file data object.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following:DXFILEERR_BADVALUE, DXFILEERR_NOTFOUND. </returns>
        /// <unmanaged>HRESULT GetDataObjectById([None] REFGUID arg0,[Out] ID3DXFileData** arg1)</unmanaged>
        public SlimDX2.Result GetDataObjectById(Guid arg0, out SlimDX2.Direct3D9.FileData arg1) {
            unsafe {
                IntPtr arg1_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, &arg0, &arg1_);
                arg1 = (arg1_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileData(arg1_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the data object that has the specified name.	
        /// </summary>	
        /// <remarks>	
        ///  Obtain the name szName of the current file data object with the <see cref="SlimDX2.Direct3D9.FileData.GetName"/> method. 	
        /// </remarks>	
        /// <param name="arg0"> Pointer to the requested name.  </param>
        /// <param name="arg1"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.FileData"/> interface, representing the returned file data object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following:DXFILEERR_BADVALUE, DXFILEERR_NOTFOUND. </returns>
        /// <unmanaged>HRESULT GetDataObjectByName([Out] const char* arg0,[Out] ID3DXFileData** arg1)</unmanaged>
        public SlimDX2.Result GetDataObjectByName(IntPtr arg0, out SlimDX2.Direct3D9.FileData arg1) {
            unsafe {
                IntPtr arg1_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)arg0, &arg1_);
                arg1 = (arg1_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileData(arg1_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXFileData</unmanaged>
    [Guid("cef08cfd-7b4f-4429-9624-2a690a933201")]
    public partial class FileData : SlimDX2.ComObject {
        public FileData(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the enumeration object in this file data object.	
        /// </summary>	
        /// <unmanaged>HRESULT GetEnum([Out] ID3DXFileEnumObject** arg0)</unmanaged>
        public SlimDX2.Direct3D9.FileEnumObject Enum {
                get { SlimDX2.Direct3D9.FileEnumObject __output__; GetEnum(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the template ID in this file data object.	
        /// </summary>	
        /// <unmanaged>HRESULT GetType([Out] GUID* arg0)</unmanaged>
        public Guid TypeInfo {
                get { Guid __output__; GetTypeInfo(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Indicates whether this file data object is a reference object that points to another child data object.	
        /// </summary>	
        /// <unmanaged>BOOL IsReference()</unmanaged>
        public bool IsReference {
                get { return IsReference_(); }
        }
        
        /// <summary>	
        /// Retrieves the number of children in this file data object.	
        /// </summary>	
        /// <unmanaged>HRESULT GetChildren([Out] SIZE_T* arg0)</unmanaged>
        public SlimDX2.Size Children {
                get { SlimDX2.Size __output__; GetChildren(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the enumeration object in this file data object.	
        /// </summary>	
        /// <param name="arg0"> Address of a pointer to receive the enumeration object in this file data object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT GetEnum([Out] ID3DXFileEnumObject** arg0)</unmanaged>
        internal SlimDX2.Result GetEnum(out SlimDX2.Direct3D9.FileEnumObject arg0) {
            unsafe {
                IntPtr arg0_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &arg0_);
                arg0 = (arg0_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileEnumObject(arg0_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the name of this file data object.	
        /// </summary>	
        /// <remarks>	
        ///  For this method to succeed, either szName or puiSize must be non-NULL. 	
        /// </remarks>	
        /// <param name="arg0"> Address of a pointer to receive the name of this file data object. If this parameter is NULL, then puiSize will return the size of the string. If szName points to valid memory, the name of this file data object will be copied into szName up to the number of characters given by puiSize.  </param>
        /// <param name="arg1"> Pointer to the size of the string that represents the name of this file data object. This parameter can be NULL if szName provides a reference to the name. This parameter will return the size of the string if szName is NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT GetName([None] LPSTR arg0,[Out] SIZE_T* arg1)</unmanaged>
        public SlimDX2.Result GetName(string arg0, out SlimDX2.Size arg1) {
            unsafe {
                IntPtr arg0_ = Marshal.StringToHGlobalAnsi(arg0);
                SlimDX2.Result __result__;
                fixed (void* arg1_ = &arg1)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)arg0_, arg1_);
                Marshal.FreeHGlobal(arg0_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the GUID of this file data object.	
        /// </summary>	
        /// <param name="arg0"> Pointer to a GUID to receive the ID of this file data object. If the file data object has no ID, the returned parameter value will be GUID_NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT GetId([None] LPGUID arg0)</unmanaged>
        public SlimDX2.Result GetId(Guid arg0) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, &arg0);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Accesses the .x file data.	
        /// </summary>	
        /// <remarks>	
        ///  The ppData pointer is only valid during a ID3DXFileData::Lock ... <see cref="SlimDX2.Direct3D9.FileData.Unlock"/> sequence. You can make multiple lock calls. However, you must ensure that the number of lock calls matches the number of unlock calls. Because file data is not guaranteed to be aligned properly with byte boundaries, you should access ppData with UNALIGNED pointers. Returned parameter values are not guaranteed to be valid due to possible file corruption; therefore, your code should verify the returned parameter values. 	
        /// </remarks>	
        /// <param name="arg0"> Pointer to the size of the .x file data. </param>
        /// <param name="arg1"> Address of a pointer to receive the <see cref="SlimDX2.Direct3D9.FileData"/> file data object's interface pointer. See Remarks. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT Lock([None] SIZE_T* arg0,[None] LPCVOID* arg1)</unmanaged>
        public SlimDX2.Result Lock(SlimDX2.Size arg0, IntPtr arg1) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)arg0, (void*)arg1);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Ends the lifespan of the ppData pointer returned by <see cref="SlimDX2.Direct3D9.FileData.Lock"/>.	
        /// </summary>	
        /// <remarks>	
        ///  You must ensure that the number of <see cref="SlimDX2.Direct3D9.FileData.Lock"/> calls matches the number of ID3DXFileData::Unlock calls. After calling Unlock, the ppData pointer returned by ID3DXFileData::Lock should no longer be used. 	
        /// </remarks>	
        /// <returns>  {{BOOL}}  The return value is S_OK. </returns>
        /// <unmanaged>HRESULT Unlock()</unmanaged>
        public SlimDX2.Result Unlock() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the template ID in this file data object.	
        /// </summary>	
        /// <param name="arg0"> Pointer to the GUID representing the template in this file data object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT GetType([Out] GUID* arg0)</unmanaged>
        internal SlimDX2.Result GetTypeInfo(out Guid arg0) {
            unsafe {
                arg0 = new Guid();
                SlimDX2.Result __result__;
                fixed (void* arg0_ = &arg0)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, arg0_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Indicates whether this file data object is a reference object that points to another child data object.	
        /// </summary>	
        /// <returns>  {{BOOL}}  Returns TRUE if the file data object is a reference object; returns FALSE otherwise. </returns>
        /// <unmanaged>BOOL IsReference()</unmanaged>
        internal bool IsReference_() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of children in this file data object.	
        /// </summary>	
        /// <param name="arg0"> Address of a pointer to receive the number of children in this file data object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DXFERR_BADVALUE. </returns>
        /// <unmanaged>HRESULT GetChildren([Out] SIZE_T* arg0)</unmanaged>
        internal SlimDX2.Result GetChildren(out SlimDX2.Size arg0) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* arg0_ = &arg0)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, arg0_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a child object in this file data object.	
        /// </summary>	
        /// <param name="arg0"> ID of the child object to retrieve. </param>
        /// <param name="arg1"> Address of a pointer to receive the child object's interface pointer. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following values: D3DXFERR_BADVALUE, D3DXFERR_NOMOREOBJECTS. </returns>
        /// <unmanaged>HRESULT GetChild([None] SIZE_T arg0,[Out] ID3DXFileData** arg1)</unmanaged>
        public SlimDX2.Result GetChild(SlimDX2.Size arg0, out SlimDX2.Direct3D9.FileData arg1) {
            unsafe {
                IntPtr arg1_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, (void*)arg0, &arg1_);
                arg1 = (arg1_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.FileData(arg1_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXBaseMesh</unmanaged>
    [Guid("7ed943dd-52e8-40b5-a8d8-76685c406330")]
    public partial class BaseMesh : SlimDX2.ComObject {
        public BaseMesh(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the number of faces in the mesh.	
        /// </summary>	
        /// <unmanaged>int GetNumFaces()</unmanaged>
        public int NumFaces {
                get { return GetNumFaces(); }
        }
        
        /// <summary>	
        /// Retrieves the number of vertices in the mesh.	
        /// </summary>	
        /// <unmanaged>int GetNumVertices()</unmanaged>
        public int NumVertices {
                get { return GetNumVertices(); }
        }
        
        /// <summary>	
        /// Gets the fixed function vertex value.	
        /// </summary>	
        /// <remarks>	
        ///  This method can return 0 if the vertex format cannot be mapped directly to an FVF code.  This will occur for a mesh created from a vertex declaration that doesn't have the same order and elements supported by the FVF codes. 	
        /// </remarks>	
        /// <unmanaged>int GetFVF()</unmanaged>
        public int FVF {
                get { return GetFVF(); }
        }
        
        /// <summary>	
        /// Gets the number of bytes per vertex.	
        /// </summary>	
        /// <unmanaged>int GetNumBytesPerVertex()</unmanaged>
        public int NumBytesPerVertex {
                get { return GetNumBytesPerVertex(); }
        }
        
        /// <summary>	
        /// Retrieves the mesh options enabled for this mesh at creation time.	
        /// </summary>	
        /// <unmanaged>int GetOptions()</unmanaged>
        public int Options {
                get { return GetOptions(); }
        }
        
        /// <summary>	
        /// Retrieves the device associated with the mesh.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Be sure to call <see cref="SlimDX2.ComObject"/> when you are done using this IDirect3DDevice9 interface or you will have a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the vertex buffer associated with the mesh.	
        /// </summary>	
        /// <unmanaged>HRESULT GetVertexBuffer([Out] LPDIRECT3DVERTEXBUFFER9* ppVB)</unmanaged>
        public SlimDX2.Direct3D9.VertexBuffer VertexBuffer {
                get { SlimDX2.Direct3D9.VertexBuffer __output__; GetVertexBuffer(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the data in an index buffer.	
        /// </summary>	
        /// <unmanaged>HRESULT GetIndexBuffer([Out] LPDIRECT3DINDEXBUFFER9* ppIB)</unmanaged>
        public SlimDX2.Direct3D9.IndexBuffer IndexBuffer {
                get { SlimDX2.Direct3D9.IndexBuffer __output__; GetIndexBuffer(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Draws a subset of a mesh.	
        /// </summary>	
        /// <remarks>	
        ///  The subset that is specified by AttribId will be rendered by the <see cref="SlimDX2.Direct3D9.Device.DrawIndexedPrimitive"/> method, using the D3DPT_TRIANGLELIST primitive type, so an index buffer must be properly initialized. An attribute table is used to identify areas of the mesh that need to be drawn with different textures, render states, materials, and so on. In addition, the application can use the attribute table to hide portions of a mesh by not drawing a given attribute identifier (AttribId) when drawing the frame. 	
        /// </remarks>	
        /// <param name="attribId">  DWORD that specifies which subset of the mesh to draw. This value is used to differentiate faces in a mesh as belonging to one or more attribute groups. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT DrawSubset([None] int AttribId)</unmanaged>
        public SlimDX2.Result DrawSubset(int attribId) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, attribId);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of faces in the mesh.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns the number of faces in the mesh. </returns>
        /// <unmanaged>int GetNumFaces()</unmanaged>
        internal int GetNumFaces() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of vertices in the mesh.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns the number of vertices in the mesh. </returns>
        /// <unmanaged>int GetNumVertices()</unmanaged>
        internal int GetNumVertices() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the fixed function vertex value.	
        /// </summary>	
        /// <remarks>	
        ///  This method can return 0 if the vertex format cannot be mapped directly to an FVF code.  This will occur for a mesh created from a vertex declaration that doesn't have the same order and elements supported by the FVF codes. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  Returns the flexible vertex format (FVF) codes. </returns>
        /// <unmanaged>int GetFVF()</unmanaged>
        internal int GetFVF() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a declaration describing the vertices in the mesh.	
        /// </summary>	
        /// <remarks>	
        ///  The array of elements includes the {{D3DDECL_END}} macro, which ends the declaration. 	
        /// </remarks>	
        /// <param name="declaration"> Array of <see cref="SlimDX2.Direct3D9.Vertexelement9"/> elements describing the vertex format of the mesh vertices. The upper limit of this declarator array is {{MAX_FVF_DECL_SIZE}}. The vertex element array ends with the {{D3DDECL_END}} macro.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetDeclaration([None] D3DVERTEXELEMENT9 Declaration[65])</unmanaged>
        public SlimDX2.Result GetDeclaration(SlimDX2.Direct3D9.Vertexelement9[] declaration) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* declaration_ = &declaration[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, declaration_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of bytes per vertex.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns the number of bytes per vertex. </returns>
        /// <unmanaged>int GetNumBytesPerVertex()</unmanaged>
        internal int GetNumBytesPerVertex() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the mesh options enabled for this mesh at creation time.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns a combination of one or more of the following flags, indicating the options enabled for this mesh at creation time.  ValueDescription D3DXMESH_32BITUse 32-bit indices. D3DXMESH_DONOTCLIPUse the D3DUSAGE_DONOTCLIP usage flag for vertex and index buffers. D3DXMESH_DYNAMICEquivalent to specifying both D3DXMESH_VB_DYNAMIC and D3DXMESH_IB_DYNAMIC. D3DXMESH_RTPATCHESUse the D3DUSAGE_RTPATCHES usage flag for vertex and index buffers. D3DXMESH_NPATCHESSpecifying this flag causes the vertex and index buffer of the mesh to be created with D3DUSAGE_NPATCHES flag. This is required if the mesh object is to be rendered using N-Patch enhancement. D3DXMESH_MANAGEDEquivalent to specifying both D3DXMESH_VB_MANAGED and D3DXMESH_IB_MANAGED. D3DXMESH_POINTSUse the D3DUSAGE_POINTS usage flag for vertex and index buffers. D3DXMESH_IB_DYNAMICUse the D3DUSAGE_DYNAMIC usage flag for index buffers. D3DXMESH_IB_MANAGEDUse the D3DPOOL_MANAGED memory class for index buffers. D3DXMESH_IB_SYSTEMMEMUse the D3DPOOL_SYSTEMMEM memory class for index buffers. D3DXMESH_IB_WRITEONLYUse the D3DUSAGE_WRITEONLY usage flag for index buffers. D3DXMESH_SYSTEMMEMEquivalent to specifying both D3DXMESH_VB_SYSTEMMEM and D3DXMESH_IB_SYSTEMMEM. D3DXMESH_VB_DYNAMICUse the D3DUSAGE_DYNAMIC usage flag for vertex buffers. D3DXMESH_VB_MANAGEDUse the D3DPOOL_MANAGED memory class for vertex buffers. D3DXMESH_VB_SYSTEMMEMUse the D3DPOOL_SYSTEMMEM memory class for vertex buffers. D3DXMESH_VB_WRITEONLYUse the D3DUSAGE_WRITEONLY usage flag for vertex buffers. D3DXMESH_WRITEONLYEquivalent to specifying both D3DXMESH_VB_WRITEONLY and D3DXMESH_IB_WRITEONLY.    </returns>
        /// <unmanaged>int GetOptions()</unmanaged>
        internal int GetOptions() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the device associated with the mesh.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count on the <see cref="SlimDX2.Direct3D9.Device"/> interface. Be sure to call <see cref="SlimDX2.ComObject"/> when you are done using this IDirect3DDevice9 interface or you will have a memory leak. 	
        /// </remarks>	
        /// <param name="ppDevice"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the Direct3D device object associated with the mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device ppDevice) {
            unsafe {
                IntPtr ppDevice_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, &ppDevice_);
                ppDevice = (ppDevice_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppDevice_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Clones a mesh using a flexible vertex format (FVF) code.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXBaseMesh::CloneMeshFVF is used to reformat and change the vertex data layout. This is done by creating a new mesh object. For example, use it to to add space for normals, texture coordinates, colors, weights, etc. that were not present before.   <see cref="SlimDX2.Direct3D9.BaseMesh.UpdateSemantics"/> updates the vertex declaration with different semantic information without changing the layout of the vertex buffer. This method does not modify the contents of the vertex buffer. For example, use it to relabel a 3D texture coordinate as a binormal or tangent or vice versa. 	
        /// </remarks>	
        /// <param name="options"> A combination of one or more {{D3DXMESH}} flags specifying creation options for the mesh. </param>
        /// <param name="fvf"> Combination of FVF codes, which specifies the vertex format for the vertices in the output mesh. For the values of the codes, see {{D3DFVF}}. </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface representing the device object associated with the mesh. </param>
        /// <param name="ppCloneMesh"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the cloned mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT CloneMeshFVF([None] int Options,[None] int FVF,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXMESH* ppCloneMesh)</unmanaged>
        public SlimDX2.Result CloneMeshFVF(int options, int fvf, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.Mesh ppCloneMesh) {
            unsafe {
                IntPtr ppCloneMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, options, fvf, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), &ppCloneMesh_);
                ppCloneMesh = (ppCloneMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppCloneMesh_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Clones a mesh using a declarator.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXBaseMesh::CloneMesh is used to reformat and change the vertex data layout. This is done by creating a new mesh object. For example, use it to add space for normals, texture coordinates, colors, weights, etc. that were not present before.   <see cref="SlimDX2.Direct3D9.BaseMesh.UpdateSemantics"/> updates the vertex declaration with different semantic information without changing the layout of the vertex buffer. This method does not modify the contents of the vertex buffer. For example, use it to relabel a 3D texture coordinate as a binormal or tangent or vice versa. 	
        /// </remarks>	
        /// <param name="options"> A combination of one or more {{D3DXMESH}} flags specifying creation options for the mesh. </param>
        /// <param name="pDeclaration"> An array of <see cref="SlimDX2.Direct3D9.Vertexelement9"/> elements, which specify the vertex format for the vertices in the output mesh. </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device object associated with the mesh. </param>
        /// <param name="ppCloneMesh"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the cloned mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT CloneMesh([None] int Options,[None] const D3DVERTEXELEMENT9* pDeclaration,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXMESH* ppCloneMesh)</unmanaged>
        public SlimDX2.Result CloneMesh(int options, ref SlimDX2.Direct3D9.Vertexelement9 pDeclaration, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.Mesh ppCloneMesh) {
            unsafe {
                IntPtr ppCloneMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pDeclaration_ = &pDeclaration)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, options, pDeclaration_, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), &ppCloneMesh_);
                ppCloneMesh = (ppCloneMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppCloneMesh_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the vertex buffer associated with the mesh.	
        /// </summary>	
        /// <param name="ppVB"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VertexBuffer"/> interface, representing the vertex buffer object associated with the mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetVertexBuffer([Out] LPDIRECT3DVERTEXBUFFER9* ppVB)</unmanaged>
        internal SlimDX2.Result GetVertexBuffer(out SlimDX2.Direct3D9.VertexBuffer ppVB) {
            unsafe {
                IntPtr ppVB_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, &ppVB_);
                ppVB = (ppVB_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexBuffer(ppVB_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the data in an index buffer.	
        /// </summary>	
        /// <param name="ppIB"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.IndexBuffer"/> interface, representing the index buffer object associated with the mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetIndexBuffer([Out] LPDIRECT3DINDEXBUFFER9* ppIB)</unmanaged>
        internal SlimDX2.Result GetIndexBuffer(out SlimDX2.Direct3D9.IndexBuffer ppIB) {
            unsafe {
                IntPtr ppIB_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, &ppIB_);
                ppIB = (ppIB_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.IndexBuffer(ppIB_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Locks a vertex buffer and obtains a pointer to the vertex buffer memory.	
        /// </summary>	
        /// <remarks>	
        ///  When working with vertex buffers, you are allowed to make multiple lock calls; however, you must ensure that the number of lock calls match the number of unlock calls. DrawPrimitive calls will not succeed with any outstanding lock count on any currently set vertex buffer. 	
        /// </remarks>	
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY D3DLOCK_NOOVERWRITE  For a description of the flags, see {{D3DLOCK}}. </param>
        /// <param name="ppData"> VOID* pointer to a buffer containing the vertex data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT LockVertexBuffer([None] int Flags,[None] void** ppData)</unmanaged>
        public SlimDX2.Result LockVertexBuffer(int flags, IntPtr ppData) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, flags, (void*)ppData);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks a vertex buffer.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT UnlockVertexBuffer()</unmanaged>
        public SlimDX2.Result UnlockVertexBuffer() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Locks an index buffer and obtains a pointer to the index buffer memory.	
        /// </summary>	
        /// <remarks>	
        ///  When working with index buffers, you are allowed to make multiple lock calls. However, you must ensure that the number of lock calls match the number of unlock calls. DrawPrimitive calls will not succeed with any outstanding lock count on any currently set index buffer. 	
        /// </remarks>	
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:   D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY  For a description of the flags, see {{D3DLOCK}}. </param>
        /// <param name="ppData"> VOID* pointer to a buffer containing the index data. The count of indices in this buffer will be equal to <see cref="SlimDX2.Direct3D9.BaseMesh.GetNumFaces"/> * 3. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT LockIndexBuffer([None] int Flags,[None] void** ppData)</unmanaged>
        public SlimDX2.Result LockIndexBuffer(int flags, IntPtr ppData) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, flags, (void*)ppData);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks an index buffer.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT UnlockIndexBuffer()</unmanaged>
        public SlimDX2.Result UnlockIndexBuffer() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves either an attribute table for a mesh, or the number of entries stored in an attribute table for a mesh.	
        /// </summary>	
        /// <remarks>	
        ///  An attribute table is created by <see cref="SlimDX2.Direct3D9.Mesh.Optimize"/> and passing D3DXMESHOPT_ATTRSORT for the Flags parameter. An attribute table is used to identify areas of the mesh that need to be drawn with different textures, render states, materials, and so on. In addition, the application can use the attribute table to hide portions of a mesh by not drawing a given attribute identifier when drawing the frame. 	
        /// </remarks>	
        /// <param name="pAttribTable"> Pointer to an array of <see cref="SlimDX2.Direct3D9.Attributerange"/> structures, representing the entries in the mesh's attribute table. Specify NULL to retrieve the value for pAttribTableSize. </param>
        /// <param name="pAttribTableSize"> Pointer to either the number of entries stored in pAttribTable or a value to be filled in with the number of entries stored in the attribute table for the mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetAttributeTable([Out] D3DXATTRIBUTERANGE* pAttribTable,[Out] int* pAttribTableSize)</unmanaged>
        public SlimDX2.Result GetAttributeTable(out SlimDX2.Direct3D9.Attributerange pAttribTable, out int pAttribTableSize) {
            unsafe {
                pAttribTable = new SlimDX2.Direct3D9.Attributerange();
                SlimDX2.Result __result__;
                fixed (void* pAttribTable_ = &pAttribTable)
                    fixed (void* pAttribTableSize_ = &pAttribTableSize)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, pAttribTable_, pAttribTableSize_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Converts point representative data to mesh adjacency information.	
        /// </summary>	
        /// <param name="pPRep"> Pointer to an array of one DWORD per vertex of the mesh that contains point representative data. This parameter is optional. Supplying a NULL value will cause this parameter to be interpreted as an "identity" array. </param>
        /// <param name="pAdjacency"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh. The number of bytes in this array must be at least 3 * <see cref="SlimDX2.Direct3D9.BaseMesh.GetNumFaces"/> * sizeof(DWORD). </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ConvertPointRepsToAdjacency([None] const int* pPRep,[None] int* pAdjacency)</unmanaged>
        public SlimDX2.Result ConvertPointRepsToAdjacency(ref int pPRep, ref int pAdjacency) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pPRep_ = &pPRep)
                    fixed (void* pAdjacency_ = &pAdjacency)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, pPRep_, pAdjacency_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Converts mesh adjacency information to an array of point representatives.	
        /// </summary>	
        /// <param name="pAdjacency"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh. The number of bytes in this array must be at least 3 * <see cref="SlimDX2.Direct3D9.BaseMesh.GetNumFaces"/> * sizeof(DWORD). </param>
        /// <param name="pPRep"> Pointer to an array of one DWORD per vertex of the mesh that will be filled with point representative data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ConvertAdjacencyToPointReps([None] const int* pAdjacency,[None] int* pPRep)</unmanaged>
        public SlimDX2.Result ConvertAdjacencyToPointReps(ref int pAdjacency, ref int pPRep) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pAdjacency_ = &pAdjacency)
                    fixed (void* pPRep_ = &pPRep)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, pAdjacency_, pPRep_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Generate a list of mesh edges, as well as a list of faces that share each edge.	
        /// </summary>	
        /// <remarks>	
        ///  After an application generates adjacency information for a mesh, the mesh data can be optimized for better drawing performance. The order of the entries in the adjacency buffer is determined by the order of the vertex indices in the index buffer. The adjacent triangle 0 always corresponds to the edge between the indices of the corners 0 and 1. The adjacent triangle 1 always corresponds to the edge between the indices of the corners 1 and 2 while the adjacent triangle 2 corresponds to the edge between the indices of the corners 2 and 0. 	
        /// </remarks>	
        /// <param name="epsilon"> Specifies that vertices that differ in position by less than epsilon should be treated as coincident. </param>
        /// <param name="pAdjacency"> Pointer to an array of three DWORDs per face to be filled with the indices of adjacent faces. The number of bytes in this array must be at least 3 * <see cref="SlimDX2.Direct3D9.BaseMesh.GetNumFaces"/> * sizeof(DWORD). </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT GenerateAdjacency([None] FLOAT Epsilon,[None] int* pAdjacency)</unmanaged>
        public SlimDX2.Result GenerateAdjacency(float epsilon, ref int pAdjacency) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pAdjacency_ = &pAdjacency)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 22 * 4, epsilon, pAdjacency_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// This method allows the user to change the mesh declaration without changing the data layout of the vertex buffer. The call is valid only if the old and new declaration formats have the same vertex size.	
        /// </summary>	
        /// <remarks>	
        ///   <see cref="SlimDX2.Direct3D9.BaseMesh.CloneMesh"/> is used to reformat and change the vertex data layout. For example, use it to to add space for normals, texture coordinates, colors, weights, etc. that were not present before. ID3DXBaseMesh::UpdateSemantics is a method for updating the vertex declaration with different semantic information, without changing the layout of the vertex buffer. For example, use it to relabel a 3D texture coordinate as a binormal or tangent, or vice versa. 	
        /// </remarks>	
        /// <param name="declaration"> An array of <see cref="SlimDX2.Direct3D9.Vertexelement9"/> elements, describing the vertex format of the mesh vertices. The upper limit of this declarator array is {{MAX_FVF_DECL_SIZE}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT UpdateSemantics([None] D3DVERTEXELEMENT9 Declaration[65])</unmanaged>
        public SlimDX2.Result UpdateSemantics(SlimDX2.Direct3D9.Vertexelement9[] declaration) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* declaration_ = &declaration[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, declaration_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXMesh</unmanaged>
    [Guid("4020e5c2-1403-4929-883f-e2e849fac195")]
    public partial class Mesh : SlimDX2.Direct3D9.BaseMesh {
        public Mesh(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Locks the mesh buffer that contains the mesh attribute data, and returns a pointer to it.	
        /// </summary>	
        /// <remarks>	
        ///  If <see cref="SlimDX2.Direct3D9.Mesh.Optimize"/> has been called, the mesh will also have an attribute table that can be accessed using the <see cref="SlimDX2.Direct3D9.BaseMesh.GetAttributeTable"/> method.  	
        /// </remarks>	
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY  For a description of the flags, see {{D3DLOCK}}. </param>
        /// <param name="ppData"> Address of a pointer to a buffer containing a DWORD for each face in the mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT LockAttributeBuffer([None] int Flags,[None] int** ppData)</unmanaged>
        public SlimDX2.Result LockAttributeBuffer(int flags, ref int ppData) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* ppData_ = &ppData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, flags, ppData_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlocks an attribute buffer.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT UnlockAttributeBuffer()</unmanaged>
        public SlimDX2.Result UnlockAttributeBuffer() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Generates a new mesh with reordered faces and vertices to optimize drawing performance.	
        /// </summary>	
        /// <remarks>	
        ///  This method generates a new mesh. Before running Optimize, an application must generate an adjacency buffer by calling <see cref="SlimDX2.Direct3D9.BaseMesh.GenerateAdjacency"/>. The adjacency buffer contains adjacency data, such as a list of edges and the faces that are adjacent to each other. This method is very similar to the <see cref="SlimDX2.Direct3D9.BaseMesh.CloneMesh"/> method, except that it can perform optimization while generating the new clone of the mesh. The output mesh inherits all of the creation parameters of the input mesh. 	
        /// </remarks>	
        /// <param name="flags"> Specifies the type of optimization to perform. This parameter can be set to a combination of one or more flags from {{D3DXMESHOPT}} and {{D3DXMESH}} (except D3DXMESH_32BIT, D3DXMESH_IB_WRITEONLY, and D3DXMESH_WRITEONLY). </param>
        /// <param name="pAdjacencyIn"> Pointer to an array of three DWORDs per face that specifies the three neighbors for each face in the source mesh. If the edge has no adjacent faces, the value is 0xffffffff. See Remarks. </param>
        /// <param name="pAdjacencyOut"> Pointer to an array of three DWORDs per face that specifies the three neighbors for each face in the optimized mesh. If the edge has no adjacent faces, the value is 0xffffffff. </param>
        /// <param name="pFaceRemap"> An array of DWORDs, one per face, that identifies the original mesh face that corresponds to each face in the optimized mesh. If the value supplied for this argument is NULL, face remap data is not returned. </param>
        /// <param name="ppVertexRemap"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface, which contains a DWORD for each vertex that specifies how the new vertices map to the old vertices. This remap is useful if you need to alter external data based on the new vertex mapping. </param>
        /// <param name="ppOptMesh"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the optimized mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT Optimize([None] int Flags,[None] const int* pAdjacencyIn,[None] int* pAdjacencyOut,[None] int* pFaceRemap,[None] LPD3DXBUFFER* ppVertexRemap,[None] LPD3DXMESH* ppOptMesh)</unmanaged>
        public SlimDX2.Result Optimize(int flags, ref int pAdjacencyIn, ref int pAdjacencyOut, ref int pFaceRemap, out SlimDX2.Direct3D9.Buffer ppVertexRemap, out SlimDX2.Direct3D9.Mesh ppOptMesh) {
            unsafe {
                IntPtr ppVertexRemap_ = IntPtr.Zero;
                IntPtr ppOptMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pAdjacencyIn_ = &pAdjacencyIn)
                    fixed (void* pAdjacencyOut_ = &pAdjacencyOut)
                        fixed (void* pFaceRemap_ = &pFaceRemap)
                            __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 26 * 4, flags, pAdjacencyIn_, pAdjacencyOut_, pFaceRemap_, &ppVertexRemap_, &ppOptMesh_);
                ppVertexRemap = (ppVertexRemap_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppVertexRemap_);	
                ppOptMesh = (ppOptMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppOptMesh_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Generates a mesh with reordered faces and vertices to optimize drawing performance. This method reorders the existing mesh.	
        /// </summary>	
        /// <remarks>	
        ///  Before running ID3DXMesh::OptimizeInplace, an application must generate an adjacency buffer by calling <see cref="SlimDX2.Direct3D9.BaseMesh.GenerateAdjacency"/>. The adjacency buffer contains adjacency data, such as a list of edges and the faces that are adjacent to each other. Note This method will fail if the mesh is sharing its vertex buffer with another mesh, unless the D3DXMESHOPT_IGNOREVERTS is set in Flags. 	
        /// </remarks>	
        /// <param name="flags"> Combination of one or more {{D3DXMESHOPT}} flags, specifying the type of optimization to perform. </param>
        /// <param name="pAdjacencyIn"> Pointer to an array of three DWORDs per face that specifies the three neighbors for each face in the source mesh. If the edge has no adjacent faces, the value is 0xffffffff. </param>
        /// <param name="pAdjacencyOut"> Pointer to an array of three DWORDs per face that specifies the three neighbors for each face in the optimized mesh. If the edge has no adjacent faces, the value is 0xffffffff. If the value supplied for this argument is NULL, adjacency data is not returned. </param>
        /// <param name="pFaceRemap"> An array of DWORDs, one per face, that identifies the original mesh face that corresponds to each face in the optimized mesh. If the value supplied for this argument is NULL, face remap data is not returned. </param>
        /// <param name="ppVertexRemap"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface, which contains a DWORD for each vertex that specifies how the new vertices map to the old vertices. This remap is useful if you need to alter external data based on the new vertex mapping. If the value supplied for this argument is NULL, vertex remap data is not returned. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_CANNOTATTRSORT, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT OptimizeInplace([None] int Flags,[None] const int* pAdjacencyIn,[None] int* pAdjacencyOut,[None] int* pFaceRemap,[None] LPD3DXBUFFER* ppVertexRemap)</unmanaged>
        public SlimDX2.Result OptimizeInplace(int flags, ref int pAdjacencyIn, ref int pAdjacencyOut, ref int pFaceRemap, out SlimDX2.Direct3D9.Buffer ppVertexRemap) {
            unsafe {
                IntPtr ppVertexRemap_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pAdjacencyIn_ = &pAdjacencyIn)
                    fixed (void* pAdjacencyOut_ = &pAdjacencyOut)
                        fixed (void* pFaceRemap_ = &pFaceRemap)
                            __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 27 * 4, flags, pAdjacencyIn_, pAdjacencyOut_, pFaceRemap_, &ppVertexRemap_);
                ppVertexRemap = (ppVertexRemap_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppVertexRemap_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the attribute table for a mesh and the number of entries stored in the table.	
        /// </summary>	
        /// <remarks>	
        ///  If an application keeps track of the information in an attribute table, and rearranges the table as a result of changes to attributes or faces, this method allows the application to update the attribute tables instead of calling <see cref="SlimDX2.Direct3D9.Mesh.Optimize"/> again. 	
        /// </remarks>	
        /// <param name="pAttribTable"> Pointer to an array of <see cref="SlimDX2.Direct3D9.Attributerange"/> structures, representing the entries in the mesh attribute table. </param>
        /// <param name="cAttribTableSize"> Number of attributes in the mesh attribute table. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT SetAttributeTable([None] const D3DXATTRIBUTERANGE* pAttribTable,[None] int cAttribTableSize)</unmanaged>
        public SlimDX2.Result SetAttributeTable(ref SlimDX2.Direct3D9.Attributerange pAttribTable, int cAttribTableSize) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pAttribTable_ = &pAttribTable)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 28 * 4, pAttribTable_, cAttribTableSize);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXPMesh</unmanaged>
    [Guid("8875769a-d579-4088-aaeb-534d1ad84e96")]
    public partial class PMesh : SlimDX2.Direct3D9.BaseMesh {
        public PMesh(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>HRESULT SetNumFaces([None] int Faces)</unmanaged>
        public int NumFaces {
                set { SetNumFaces(value); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>HRESULT SetNumVertices([None] int Vertices)</unmanaged>
        public int NumVertices {
                set { SetNumVertices(value); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int GetMaxFaces()</unmanaged>
        public int MaxFaces {
                get { return GetMaxFaces(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int GetMinFaces()</unmanaged>
        public int MinFaces {
                get { return GetMinFaces(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int GetMaxVertices()</unmanaged>
        public int MaxVertices {
                get { return GetMaxVertices(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int GetMinVertices()</unmanaged>
        public int MinVertices {
                get { return GetMinVertices(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>HRESULT GetAdjacency([Out] int* pAdjacency)</unmanaged>
        public int Adjacency {
                get { int __output__; GetAdjacency(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>
        /// <param name="fvf">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="ppCloneMesh">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ClonePMeshFVF([None] int Options,[None] int FVF,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXPMESH* ppCloneMesh)</unmanaged>
        public SlimDX2.Result ClonePMeshFVF(int options, int fvf, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.PMesh ppCloneMesh) {
            unsafe {
                IntPtr ppCloneMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, options, fvf, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), &ppCloneMesh_);
                ppCloneMesh = (ppCloneMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PMesh(ppCloneMesh_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>
        /// <param name="pDeclaration">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="ppCloneMesh">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ClonePMesh([None] int Options,[None] const D3DVERTEXELEMENT9* pDeclaration,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXPMESH* ppCloneMesh)</unmanaged>
        public SlimDX2.Result ClonePMesh(int options, ref SlimDX2.Direct3D9.Vertexelement9 pDeclaration, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.PMesh ppCloneMesh) {
            unsafe {
                IntPtr ppCloneMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pDeclaration_ = &pDeclaration)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4, options, pDeclaration_, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), &ppCloneMesh_);
                ppCloneMesh = (ppCloneMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PMesh(ppCloneMesh_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="faces">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT SetNumFaces([None] int Faces)</unmanaged>
        internal SlimDX2.Result SetNumFaces(int faces) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 26 * 4, faces);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="vertices">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT SetNumVertices([None] int Vertices)</unmanaged>
        internal SlimDX2.Result SetNumVertices(int vertices) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 27 * 4, vertices);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int GetMaxFaces()</unmanaged>
        internal int GetMaxFaces() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 28 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int GetMinFaces()</unmanaged>
        internal int GetMinFaces() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 29 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int GetMaxVertices()</unmanaged>
        internal int GetMaxVertices() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 30 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int GetMinVertices()</unmanaged>
        internal int GetMinVertices() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 31 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="pStream">No documentation.</param>
        /// <param name="pMaterials">No documentation.</param>
        /// <param name="pEffectInstances">No documentation.</param>
        /// <param name="numMaterials">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT Save([None] void* pStream,[None] const D3DXMATERIAL* pMaterials,[None] const D3DXEFFECTINSTANCE* pEffectInstances,[None] int NumMaterials)</unmanaged>
        public SlimDX2.Result Save(IntPtr pStream, ref SlimDX2.Direct3D9.Material pMaterials, ref SlimDX2.Direct3D9.Effectinstance pEffectInstances, int numMaterials) {
            unsafe {
                SlimDX2.Direct3D9.Material.__Native pMaterials_ = new SlimDX2.Direct3D9.Material.__Native();
                pMaterials.__MarshalTo(ref pMaterials_);
                SlimDX2.Direct3D9.Effectinstance.__Native pEffectInstances_ = new SlimDX2.Direct3D9.Effectinstance.__Native();
                pEffectInstances.__MarshalTo(ref pEffectInstances_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 32 * 4, (void*)pStream, &pMaterials_, &pEffectInstances_, numMaterials);
                pMaterials.__MarshalFrom(ref pMaterials_);
                pMaterials_.__MarshalFree();
                pEffectInstances.__MarshalFrom(ref pEffectInstances_);
                pEffectInstances_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="flags">No documentation.</param>
        /// <param name="pAdjacencyOut">No documentation.</param>
        /// <param name="pFaceRemap">No documentation.</param>
        /// <param name="ppVertexRemap">No documentation.</param>
        /// <param name="ppOptMesh">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT Optimize([None] int Flags,[None] int* pAdjacencyOut,[None] int* pFaceRemap,[None] LPD3DXBUFFER* ppVertexRemap,[None] LPD3DXMESH* ppOptMesh)</unmanaged>
        public SlimDX2.Result Optimize(int flags, ref int pAdjacencyOut, ref int pFaceRemap, out SlimDX2.Direct3D9.Buffer ppVertexRemap, out SlimDX2.Direct3D9.Mesh ppOptMesh) {
            unsafe {
                IntPtr ppVertexRemap_ = IntPtr.Zero;
                IntPtr ppOptMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pAdjacencyOut_ = &pAdjacencyOut)
                    fixed (void* pFaceRemap_ = &pFaceRemap)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 33 * 4, flags, pAdjacencyOut_, pFaceRemap_, &ppVertexRemap_, &ppOptMesh_);
                ppVertexRemap = (ppVertexRemap_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppVertexRemap_);	
                ppOptMesh = (ppOptMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppOptMesh_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="flags">No documentation.</param>
        /// <param name="pFaceRemap">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT OptimizeBaseLOD([None] int Flags,[None] int* pFaceRemap)</unmanaged>
        public SlimDX2.Result OptimizeBaseLOD(int flags, ref int pFaceRemap) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pFaceRemap_ = &pFaceRemap)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 34 * 4, flags, pFaceRemap_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="newFacesMin">No documentation.</param>
        /// <param name="newFacesMax">No documentation.</param>
        /// <param name="rgiFaceRemap">No documentation.</param>
        /// <param name="rgiVertRemap">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT TrimByFaces([None] int NewFacesMin,[None] int NewFacesMax,[None] int* rgiFaceRemap,[None] int* rgiVertRemap)</unmanaged>
        public SlimDX2.Result TrimByFaces(int newFacesMin, int newFacesMax, ref int rgiFaceRemap, ref int rgiVertRemap) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* rgiFaceRemap_ = &rgiFaceRemap)
                    fixed (void* rgiVertRemap_ = &rgiVertRemap)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 35 * 4, newFacesMin, newFacesMax, rgiFaceRemap_, rgiVertRemap_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="newVerticesMin">No documentation.</param>
        /// <param name="newVerticesMax">No documentation.</param>
        /// <param name="rgiFaceRemap">No documentation.</param>
        /// <param name="rgiVertRemap">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT TrimByVertices([None] int NewVerticesMin,[None] int NewVerticesMax,[None] int* rgiFaceRemap,[None] int* rgiVertRemap)</unmanaged>
        public SlimDX2.Result TrimByVertices(int newVerticesMin, int newVerticesMax, ref int rgiFaceRemap, ref int rgiVertRemap) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* rgiFaceRemap_ = &rgiFaceRemap)
                    fixed (void* rgiVertRemap_ = &rgiVertRemap)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 36 * 4, newVerticesMin, newVerticesMax, rgiFaceRemap_, rgiVertRemap_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="pAdjacency">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT GetAdjacency([Out] int* pAdjacency)</unmanaged>
        internal SlimDX2.Result GetAdjacency(out int pAdjacency) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pAdjacency_ = &pAdjacency)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 37 * 4, pAdjacency_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="pVertexHistory">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT GenerateVertexHistory([None] int* pVertexHistory)</unmanaged>
        public SlimDX2.Result GenerateVertexHistory(ref int pVertexHistory) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pVertexHistory_ = &pVertexHistory)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 38 * 4, pVertexHistory_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXSPMesh</unmanaged>
    [Guid("667ea4c7-f1cd-4386-b523-7c0290b83cc5")]
    public partial class SPMesh : SlimDX2.ComObject {
        public SPMesh(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int GetNumFaces()</unmanaged>
        public int NumFaces {
                get { return GetNumFaces(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int GetNumVertices()</unmanaged>
        public int NumVertices {
                get { return GetNumVertices(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int GetFVF()</unmanaged>
        public int FVF {
                get { return GetFVF(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int GetOptions()</unmanaged>
        public int Options {
                get { return GetOptions(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int GetMaxFaces()</unmanaged>
        public int MaxFaces {
                get { return GetMaxFaces(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int GetMaxVertices()</unmanaged>
        public int MaxVertices {
                get { return GetMaxVertices(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>HRESULT GetVertexWeights([Out] FLOAT* pVertexWeights)</unmanaged>
        public float VertexWeights {
                get { float __output__; GetVertexWeights(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int GetNumFaces()</unmanaged>
        internal int GetNumFaces() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int GetNumVertices()</unmanaged>
        internal int GetNumVertices() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int GetFVF()</unmanaged>
        internal int GetFVF() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="declaration">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT GetDeclaration([None] D3DVERTEXELEMENT9 Declaration[65])</unmanaged>
        public SlimDX2.Result GetDeclaration(SlimDX2.Direct3D9.Vertexelement9[] declaration) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* declaration_ = &declaration[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, declaration_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int GetOptions()</unmanaged>
        internal int GetOptions() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="ppDevice">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device ppDevice) {
            unsafe {
                IntPtr ppDevice_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, &ppDevice_);
                ppDevice = (ppDevice_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppDevice_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>
        /// <param name="fvf">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="pAdjacencyOut">No documentation.</param>
        /// <param name="pVertexRemapOut">No documentation.</param>
        /// <param name="ppCloneMesh">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT CloneMeshFVF([None] int Options,[None] int FVF,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] int* pAdjacencyOut,[None] int* pVertexRemapOut,[None] LPD3DXMESH* ppCloneMesh)</unmanaged>
        public SlimDX2.Result CloneMeshFVF(int options, int fvf, SlimDX2.Direct3D9.Device pD3DDevice, ref int pAdjacencyOut, ref int pVertexRemapOut, out SlimDX2.Direct3D9.Mesh ppCloneMesh) {
            unsafe {
                IntPtr ppCloneMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pAdjacencyOut_ = &pAdjacencyOut)
                    fixed (void* pVertexRemapOut_ = &pVertexRemapOut)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, options, fvf, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), pAdjacencyOut_, pVertexRemapOut_, &ppCloneMesh_);
                ppCloneMesh = (ppCloneMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppCloneMesh_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>
        /// <param name="pDeclaration">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="pAdjacencyOut">No documentation.</param>
        /// <param name="pVertexRemapOut">No documentation.</param>
        /// <param name="ppCloneMesh">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT CloneMesh([None] int Options,[None] const D3DVERTEXELEMENT9* pDeclaration,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] int* pAdjacencyOut,[None] int* pVertexRemapOut,[None] LPD3DXMESH* ppCloneMesh)</unmanaged>
        public SlimDX2.Result CloneMesh(int options, ref SlimDX2.Direct3D9.Vertexelement9 pDeclaration, SlimDX2.Direct3D9.Device pD3DDevice, ref int pAdjacencyOut, ref int pVertexRemapOut, out SlimDX2.Direct3D9.Mesh ppCloneMesh) {
            unsafe {
                IntPtr ppCloneMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pDeclaration_ = &pDeclaration)
                    fixed (void* pAdjacencyOut_ = &pAdjacencyOut)
                        fixed (void* pVertexRemapOut_ = &pVertexRemapOut)
                            __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, options, pDeclaration_, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), pAdjacencyOut_, pVertexRemapOut_, &ppCloneMesh_);
                ppCloneMesh = (ppCloneMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppCloneMesh_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>
        /// <param name="fvf">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="pVertexRemapOut">No documentation.</param>
        /// <param name="pErrorsByFace">No documentation.</param>
        /// <param name="ppCloneMesh">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ClonePMeshFVF([None] int Options,[None] int FVF,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] int* pVertexRemapOut,[None] FLOAT* pErrorsByFace,[None] LPD3DXPMESH* ppCloneMesh)</unmanaged>
        public SlimDX2.Result ClonePMeshFVF(int options, int fvf, SlimDX2.Direct3D9.Device pD3DDevice, ref int pVertexRemapOut, ref float pErrorsByFace, out SlimDX2.Direct3D9.PMesh ppCloneMesh) {
            unsafe {
                IntPtr ppCloneMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pVertexRemapOut_ = &pVertexRemapOut)
                    fixed (void* pErrorsByFace_ = &pErrorsByFace)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, options, fvf, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), pVertexRemapOut_, pErrorsByFace_, &ppCloneMesh_);
                ppCloneMesh = (ppCloneMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PMesh(ppCloneMesh_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>
        /// <param name="pDeclaration">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="pVertexRemapOut">No documentation.</param>
        /// <param name="pErrorsbyFace">No documentation.</param>
        /// <param name="ppCloneMesh">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ClonePMesh([None] int Options,[None] const D3DVERTEXELEMENT9* pDeclaration,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] int* pVertexRemapOut,[None] FLOAT* pErrorsbyFace,[None] LPD3DXPMESH* ppCloneMesh)</unmanaged>
        public SlimDX2.Result ClonePMesh(int options, ref SlimDX2.Direct3D9.Vertexelement9 pDeclaration, SlimDX2.Direct3D9.Device pD3DDevice, ref int pVertexRemapOut, ref float pErrorsbyFace, out SlimDX2.Direct3D9.PMesh ppCloneMesh) {
            unsafe {
                IntPtr ppCloneMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pDeclaration_ = &pDeclaration)
                    fixed (void* pVertexRemapOut_ = &pVertexRemapOut)
                        fixed (void* pErrorsbyFace_ = &pErrorsbyFace)
                            __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, options, pDeclaration_, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), pVertexRemapOut_, pErrorsbyFace_, &ppCloneMesh_);
                ppCloneMesh = (ppCloneMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PMesh(ppCloneMesh_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="faces">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ReduceFaces([None] int Faces)</unmanaged>
        public SlimDX2.Result ReduceFaces(int faces) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, faces);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="vertices">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ReduceVertices([None] int Vertices)</unmanaged>
        public SlimDX2.Result ReduceVertices(int vertices) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, vertices);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int GetMaxFaces()</unmanaged>
        internal int GetMaxFaces() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int GetMaxVertices()</unmanaged>
        internal int GetMaxVertices() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="pVertexAttributeWeights">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT GetVertexAttributeWeights([None] LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights)</unmanaged>
        public SlimDX2.Result GetVertexAttributeWeights(ref SlimDX2.Direct3D9.Attributeweights pVertexAttributeWeights) {
            unsafe {
                SlimDX2.Direct3D9.Attributeweights.__Native pVertexAttributeWeights_ = new SlimDX2.Direct3D9.Attributeweights.__Native();
                pVertexAttributeWeights.__MarshalTo(ref pVertexAttributeWeights_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, &pVertexAttributeWeights_);
                pVertexAttributeWeights.__MarshalFrom(ref pVertexAttributeWeights_);
                pVertexAttributeWeights_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="pVertexWeights">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT GetVertexWeights([Out] FLOAT* pVertexWeights)</unmanaged>
        internal SlimDX2.Result GetVertexWeights(out float pVertexWeights) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pVertexWeights_ = &pVertexWeights)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, pVertexWeights_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXPatchMesh</unmanaged>
    [Guid("3ce6cc22-dbf2-44f4-894d-f9c34a337139")]
    public partial class PatchMesh : SlimDX2.ComObject {
        public PatchMesh(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the number of patches in the mesh.	
        /// </summary>	
        /// <unmanaged>int GetNumPatches()</unmanaged>
        public int NumPatches {
                get { return GetNumPatches(); }
        }
        
        /// <summary>	
        /// Gets the number of vertices in the mesh.	
        /// </summary>	
        /// <unmanaged>int GetNumVertices()</unmanaged>
        public int NumVertices {
                get { return GetNumVertices(); }
        }
        
        /// <summary>	
        /// Gets the number of control vertices per patch.	
        /// </summary>	
        /// <unmanaged>int GetControlVerticesPerPatch()</unmanaged>
        public int ControlVerticesPerPatch {
                get { return GetControlVerticesPerPatch(); }
        }
        
        /// <summary>	
        /// Gets the type of patch.	
        /// </summary>	
        /// <remarks>	
        ///  For more information about patch types, see <see cref="SlimDX2.Direct3D9.Patchmeshtype"/>. 	
        /// </remarks>	
        /// <unmanaged>int GetOptions()</unmanaged>
        public int Options {
                get { return GetOptions(); }
        }
        
        /// <summary>	
        /// Gets the device that created the mesh.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the mesh vertex buffer.	
        /// </summary>	
        /// <remarks>	
        ///  This method assumes uniform tessellation. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetVertexBuffer([Out] LPDIRECT3DVERTEXBUFFER9* ppVB)</unmanaged>
        public SlimDX2.Direct3D9.VertexBuffer VertexBuffer {
                get { SlimDX2.Direct3D9.VertexBuffer __output__; GetVertexBuffer(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the mesh index buffer.	
        /// </summary>	
        /// <remarks>	
        ///   The index buffer contains the vertex ordering in the vertex buffer. The index buffer is used to access the vertex buffer when the mesh is rendered. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetIndexBuffer([Out] LPDIRECT3DINDEXBUFFER9* ppIB)</unmanaged>
        public SlimDX2.Direct3D9.IndexBuffer IndexBuffer {
                get { SlimDX2.Direct3D9.IndexBuffer __output__; GetIndexBuffer(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the number of patches in the mesh.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  The number of patches. </returns>
        /// <unmanaged>int GetNumPatches()</unmanaged>
        internal int GetNumPatches() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of vertices in the mesh.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  The number of vertices. </returns>
        /// <unmanaged>int GetNumVertices()</unmanaged>
        internal int GetNumVertices() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the vertex declaration.	
        /// </summary>	
        /// <remarks>	
        ///  The array of elements includes the {{D3DDECL_END}} macro, which ends the declaration. 	
        /// </remarks>	
        /// <param name="declaration"> Array of <see cref="SlimDX2.Direct3D9.Vertexelement9"/> elements describing the vertex format of the mesh vertices. The dimension of this declarator array is {{MAX_FVF_DECL_SIZE}}. The vertex element array ends with the {{D3DDECL_END}} macro. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT GetDeclaration([None] D3DVERTEXELEMENT9 Declaration[65])</unmanaged>
        public SlimDX2.Result GetDeclaration(SlimDX2.Direct3D9.Vertexelement9[] declaration) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* declaration_ = &declaration[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, declaration_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of control vertices per patch.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  The number of control vertices per patch. </returns>
        /// <unmanaged>int GetControlVerticesPerPatch()</unmanaged>
        internal int GetControlVerticesPerPatch() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the type of patch.	
        /// </summary>	
        /// <remarks>	
        ///  For more information about patch types, see <see cref="SlimDX2.Direct3D9.Patchmeshtype"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  The patch type. </returns>
        /// <unmanaged>int GetOptions()</unmanaged>
        internal int GetOptions() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the device that created the mesh.	
        /// </summary>	
        /// <param name="ppDevice"> Pointer to the device. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device ppDevice) {
            unsafe {
                IntPtr ppDevice_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, &ppDevice_);
                ppDevice = (ppDevice_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppDevice_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the attributes of the patch.	
        /// </summary>	
        /// <param name="patchInfo"> Pointer to the structures containing the patch attributes. For more information about patch attributes, see <see cref="SlimDX2.Direct3D9.Patchinfo"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT GetPatchInfo([None] LPD3DXPATCHINFO PatchInfo)</unmanaged>
        public SlimDX2.Result GetPatchInfo(ref SlimDX2.Direct3D9.Patchinfo patchInfo) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* patchInfo_ = &patchInfo)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, patchInfo_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the mesh vertex buffer.	
        /// </summary>	
        /// <remarks>	
        ///  This method assumes uniform tessellation. 	
        /// </remarks>	
        /// <param name="ppVB"> Pointer to the vertex buffer. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT GetVertexBuffer([Out] LPDIRECT3DVERTEXBUFFER9* ppVB)</unmanaged>
        internal SlimDX2.Result GetVertexBuffer(out SlimDX2.Direct3D9.VertexBuffer ppVB) {
            unsafe {
                IntPtr ppVB_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, &ppVB_);
                ppVB = (ppVB_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexBuffer(ppVB_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the mesh index buffer.	
        /// </summary>	
        /// <remarks>	
        ///   The index buffer contains the vertex ordering in the vertex buffer. The index buffer is used to access the vertex buffer when the mesh is rendered. 	
        /// </remarks>	
        /// <param name="ppIB"> Pointer to the index buffer. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT GetIndexBuffer([Out] LPDIRECT3DINDEXBUFFER9* ppIB)</unmanaged>
        internal SlimDX2.Result GetIndexBuffer(out SlimDX2.Direct3D9.IndexBuffer ppIB) {
            unsafe {
                IntPtr ppIB_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, &ppIB_);
                ppIB = (ppIB_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.IndexBuffer(ppIB_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Lock the vertex buffer.	
        /// </summary>	
        /// <remarks>	
        ///  The vertex buffer is usually locked, written to, and then unlocked for reading. Patch meshes use 16-bit index buffers. 	
        /// </remarks>	
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:   D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY D3DLOCK_NOOVERWRITE   For a description of the flags, see {{D3DLOCK}}. </param>
        /// <param name="ppData"> VOID* pointer to a memory buffer containing the returned vertex data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT LockVertexBuffer([None] int flags,[None] void** ppData)</unmanaged>
        public SlimDX2.Result LockVertexBuffer(int flags, IntPtr ppData) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, flags, (void*)ppData);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlock the vertex buffer.	
        /// </summary>	
        /// <remarks>	
        ///  The vertex buffer is usually locked, written to, and then unlocked for reading. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT UnlockVertexBuffer()</unmanaged>
        public SlimDX2.Result UnlockVertexBuffer() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Lock the index buffer.	
        /// </summary>	
        /// <remarks>	
        ///  The index buffer is usually locked, written to, and then unlocked for reading. Patch mesh index buffers are 16-bit buffers. 	
        /// </remarks>	
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY   For a description of the flags, see {{D3DLOCK}}. </param>
        /// <param name="ppData"> VOID* pointer to a memory buffer containing the returned index data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT LockIndexBuffer([None] int flags,[None] void** ppData)</unmanaged>
        public SlimDX2.Result LockIndexBuffer(int flags, IntPtr ppData) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, flags, (void*)ppData);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlock the index buffer.	
        /// </summary>	
        /// <remarks>	
        ///  The index buffer is usually locked, written to, and then unlocked for reading. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT UnlockIndexBuffer()</unmanaged>
        public SlimDX2.Result UnlockIndexBuffer() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Locks the attribute buffer.	
        /// </summary>	
        /// <remarks>	
        ///  The attribute buffer is usually locked, written to, and then unlocked for reading. 	
        /// </remarks>	
        /// <param name="flags"> Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:    D3DLOCK_DISCARD D3DLOCK_NO_DIRTY_UPDATE D3DLOCK_NOSYSLOCK D3DLOCK_READONLY   For a description of the flags, see {{D3DLOCK}}. </param>
        /// <param name="ppData"> Address of a pointer to a buffer containing a DWORD for each face in the mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT LockAttributeBuffer([None] int flags,[None] int** ppData)</unmanaged>
        public SlimDX2.Result LockAttributeBuffer(int flags, ref int ppData) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* ppData_ = &ppData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, flags, ppData_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unlock the attribute buffer.	
        /// </summary>	
        /// <remarks>	
        ///  The attribute buffer is usually locked, written to, and then unlocked for reading. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT UnlockAttributeBuffer()</unmanaged>
        public SlimDX2.Result UnlockAttributeBuffer() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the size of the tessellated mesh, given a tessellation level.	
        /// </summary>	
        /// <remarks>	
        ///  This method assumes uniform tessellation. 	
        /// </remarks>	
        /// <param name="fTessLevel"> Tessellation level. </param>
        /// <param name="adaptive"> Adaptive tessellation. For adaptive tessellation, set this value to TRUE and set fTessLevel to the maximum tessellation value. This will result in the maximum mesh size necessary for adaptive tessellation. </param>
        /// <param name="numTriangles"> Pointer to the number of triangles generated by the tessellated mesh. </param>
        /// <param name="numVertices"> Pointer to the number of vertices generated by the tessellated mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT GetTessSize([None] FLOAT fTessLevel,[None] int Adaptive,[Out] int* NumTriangles,[Out] int* NumVertices)</unmanaged>
        public SlimDX2.Result GetTessSize(float fTessLevel, int adaptive, out int numTriangles, out int numVertices) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* numTriangles_ = &numTriangles)
                    fixed (void* numVertices_ = &numVertices)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, fTessLevel, adaptive, numTriangles_, numVertices_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Generate a list of mesh edges and the patches that share each edge.	
        /// </summary>	
        /// <remarks>	
        ///  After an application generates adjacency information for a mesh, the mesh data can be optimized for better drawing performance. This method determines which patches are adjacent (within the provided tolerance). This information is used internally to optimize tessellation. 	
        /// </remarks>	
        /// <param name="tolerance"> Specifies that vertices that differ in position by less than the tolerance should be treated as coincident. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT GenerateAdjacency([None] FLOAT Tolerance)</unmanaged>
        public SlimDX2.Result GenerateAdjacency(float tolerance) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, tolerance);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a new patch mesh with the specified vertex declaration.	
        /// </summary>	
        /// <remarks>	
        ///  CloneMesh converts the vertex buffer to the new vertex declaration. Entries in the vertex declaration that are new to the original mesh are set to 0. If the current mesh has adjacency, the new mesh will also have adjacency. 	
        /// </remarks>	
        /// <param name="options"> Combination of one or more {{D3DXMESH}} flags that specify creation options for the mesh. </param>
        /// <param name="pDecl"> Array of <see cref="SlimDX2.Direct3D9.Vertexelement9"/> elements that specify the vertex format for the vertices in the output mesh. </param>
        /// <param name="pMesh"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.PatchMesh"/> interface that represents the cloned mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT CloneMesh([None] int Options,[None] const D3DVERTEXELEMENT9* pDecl,[None] LPD3DXPATCHMESH* pMesh)</unmanaged>
        public SlimDX2.Result CloneMesh(int options, ref SlimDX2.Direct3D9.Vertexelement9 pDecl, out SlimDX2.Direct3D9.PatchMesh pMesh) {
            unsafe {
                IntPtr pMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pDecl_ = &pDecl)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, options, pDecl_, &pMesh_);
                pMesh = (pMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PatchMesh(pMesh_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Optimizes the patch mesh for efficient tessellation.	
        /// </summary>	
        /// <remarks>	
        ///  After an application generates adjacency information for a mesh, the mesh data can be optimized (reordered) for better drawing performance. This method determines which patches are adjacent (within the provided tolerance). Adjacency information is also used to optimize tessellation. Generate adjacency information once and tessellate repeatedly by calling <see cref="SlimDX2.Direct3D9.PatchMesh.Tessellate"/>. The optimization performed is independent of the actual tessellation level used. However, if the mesh vertices are changed, you must regenerate the adjacency information. 	
        /// </remarks>	
        /// <param name="flags"> Currently unused. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_CANNOTATTRSORT. </returns>
        /// <unmanaged>HRESULT Optimize([None] int flags)</unmanaged>
        public SlimDX2.Result Optimize(int flags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets mesh geometry displacement parameters.	
        /// </summary>	
        /// <remarks>	
        ///  Displacement maps can only be 2D textures. Mipmapping is ignored for nonadaptive tessellation. 	
        /// </remarks>	
        /// <param name="texture"> Texture containing the displacement data. </param>
        /// <param name="minFilter"> Minification level. For more information, see <see cref="SlimDX2.Direct3D9.Texturefiltertype"/>. </param>
        /// <param name="magFilter"> Magnification level. For more information, see <see cref="SlimDX2.Direct3D9.Texturefiltertype"/>. </param>
        /// <param name="mipFilter"> Mip filter level. For more information, see <see cref="SlimDX2.Direct3D9.Texturefiltertype"/>. </param>
        /// <param name="wrap"> Texture address wrap mode. For more information, see <see cref="SlimDX2.Direct3D9.Textureaddress"/>  </param>
        /// <param name="dwLODBias"> Level of detail bias value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT SetDisplaceParam([None] LPDIRECT3DBASETEXTURE9 Texture,[None] D3DTEXTUREFILTERTYPE MinFilter,[None] D3DTEXTUREFILTERTYPE MagFilter,[None] D3DTEXTUREFILTERTYPE MipFilter,[None] D3DTEXTUREADDRESS Wrap,[None] int dwLODBias)</unmanaged>
        public SlimDX2.Result SetDisplaceParam(SlimDX2.Direct3D9.BaseTexture texture, SlimDX2.Direct3D9.Texturefiltertype minFilter, SlimDX2.Direct3D9.Texturefiltertype magFilter, SlimDX2.Direct3D9.Texturefiltertype mipFilter, SlimDX2.Direct3D9.Textureaddress wrap, int dwLODBias) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 22 * 4, (void*)((texture == null)?IntPtr.Zero:texture.NativePointer), unchecked((int)minFilter), unchecked((int)magFilter), unchecked((int)mipFilter), unchecked((int)wrap), dwLODBias);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets mesh geometry displacement parameters.	
        /// </summary>	
        /// <remarks>	
        ///  Displacement maps can only be 2D textures. Mipmapping is ignored for nonadaptive tessellation. 	
        /// </remarks>	
        /// <param name="texture"> Texture containing the displacement data. </param>
        /// <param name="minFilter"> Minification level. For more information, see <see cref="SlimDX2.Direct3D9.Texturefiltertype"/>. </param>
        /// <param name="magFilter"> Magnification level. For more information, see <see cref="SlimDX2.Direct3D9.Texturefiltertype"/>. </param>
        /// <param name="mipFilter"> Mip filter level. For more information, see <see cref="SlimDX2.Direct3D9.Texturefiltertype"/>. </param>
        /// <param name="wrap"> Texture address wrap mode. For more information, see <see cref="SlimDX2.Direct3D9.Textureaddress"/>. </param>
        /// <param name="dwLODBias"> Level of detail bias value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT GetDisplaceParam([Out] LPDIRECT3DBASETEXTURE9* Texture,[Out] D3DTEXTUREFILTERTYPE* MinFilter,[Out] D3DTEXTUREFILTERTYPE* MagFilter,[Out] D3DTEXTUREFILTERTYPE* MipFilter,[Out] D3DTEXTUREADDRESS* Wrap,[Out] int* dwLODBias)</unmanaged>
        public SlimDX2.Result GetDisplaceParam(out SlimDX2.Direct3D9.BaseTexture texture, out SlimDX2.Direct3D9.Texturefiltertype minFilter, out SlimDX2.Direct3D9.Texturefiltertype magFilter, out SlimDX2.Direct3D9.Texturefiltertype mipFilter, out SlimDX2.Direct3D9.Textureaddress wrap, out int dwLODBias) {
            unsafe {
                IntPtr texture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* minFilter_ = &minFilter)
                    fixed (void* magFilter_ = &magFilter)
                        fixed (void* mipFilter_ = &mipFilter)
                            fixed (void* wrap_ = &wrap)
                                fixed (void* dwLODBias_ = &dwLODBias)
                                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, &texture_, minFilter_, magFilter_, mipFilter_, wrap_, dwLODBias_);
                texture = (texture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.BaseTexture(texture_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Performs uniform tessellation based on the tessellation level.	
        /// </summary>	
        /// <remarks>	
        ///  This function will perform more efficiently if the patch mesh has been optimized using <see cref="SlimDX2.Direct3D9.PatchMesh.Optimize"/>.  	
        /// </remarks>	
        /// <param name="fTessLevel"> Tessellation level. This is the number of vertices introduced between existing vertices. The range of this float parameter is 0 &lt; fTessLevel &lt;= 32. </param>
        /// <param name="pMesh"> Resulting tessellated mesh. See <see cref="SlimDX2.Direct3D9.Mesh"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT Tessellate([None] FLOAT fTessLevel,[None] LPD3DXMESH pMesh)</unmanaged>
        public SlimDX2.Result Tessellate(float fTessLevel, SlimDX2.Direct3D9.Mesh pMesh) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, fTessLevel, (void*)((pMesh == null)?IntPtr.Zero:pMesh.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Performs adaptive tessellation based on the z-based adaptive tessellation criterion.	
        /// </summary>	
        /// <remarks>	
        ///  This function will perform more efficiently if the patch mesh has been optimized using <see cref="SlimDX2.Direct3D9.PatchMesh.Optimize"/>.  	
        /// </remarks>	
        /// <param name="pTrans"> Specifies a 4D vector that is dotted with the vertices to get the per-vertex adaptive tessellation amount. Each edge is tessellated to the average value of the tessellation levels for the two vertices it connects. </param>
        /// <param name="dwMaxTessLevel"> Maximum limit for adaptive tessellation. This is the number of vertices introduced between existing vertices. This integer value can range from 1 to 32, inclusive. </param>
        /// <param name="dwMinTessLevel"> Minimum limit for adaptive tessellation. This is the number of vertices introduced between existing vertices. This integer value can range from 1 to 32, inclusive. </param>
        /// <param name="pMesh"> Resulting tessellated mesh. See <see cref="SlimDX2.Direct3D9.Mesh"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT TessellateAdaptive([None] const D3DXVECTOR4* pTrans,[None] int dwMaxTessLevel,[None] int dwMinTessLevel,[None] LPD3DXMESH pMesh)</unmanaged>
        public SlimDX2.Result TessellateAdaptive(ref SlimMath.Vector4 pTrans, int dwMaxTessLevel, int dwMinTessLevel, SlimDX2.Direct3D9.Mesh pMesh) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pTrans_ = &pTrans)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4, pTrans_, dwMaxTessLevel, dwMinTessLevel, (void*)((pMesh == null)?IntPtr.Zero:pMesh.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXSkinInfo</unmanaged>
    [Guid("11eaa540-f9a6-4d49-ae6a-e19221f70cc4")]
    public partial class SkinInfo : SlimDX2.ComObject {
        public SkinInfo(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the maximum number of influences for any vertex in the mesh.	
        /// </summary>	
        /// <unmanaged>HRESULT GetMaxVertexInfluences([Out] int* maxVertexInfluences)</unmanaged>
        public int MaxVertexInfluences {
                get { int __output__; GetMaxVertexInfluences(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the number of bones.	
        /// </summary>	
        /// <unmanaged>int GetNumBones()</unmanaged>
        public int NumBones {
                get { return GetNumBones(); }
        }
        
        /// <summary>	
        /// Gets the minimum bone influence. Influence values smaller than this are ignored.	
        /// </summary>	
        /// <unmanaged>FLOAT GetMinBoneInfluence()</unmanaged>
        public float MinBoneInfluence {
                get { return GetMinBoneInfluence(); }
                set { SetMinBoneInfluence(value); }
        }
        
        /// <summary>	
        /// Gets the fixed function vertex value.	
        /// </summary>	
        /// <remarks>	
        ///  This method can return 0 if the vertex format cannot be mapped directly to an FVF code.  This will occur for a mesh created from a vertex declaration that doesn't have the same order and elements supported by the FVF codes. 	
        /// </remarks>	
        /// <unmanaged>int GetFVF()</unmanaged>
        public int FVF {
                get { return GetFVF(); }
                set { SetFVF(value); }
        }
        
        /// <summary>	
        /// Sets the influence value for a bone.	
        /// </summary>	
        /// <param name="bone"> Bone number. </param>
        /// <param name="numInfluences"> Number of influences. </param>
        /// <param name="vertices"> The array of vertices influenced by a bone. </param>
        /// <param name="weights"> The array of weights influenced by a bone. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetBoneInfluence([None] int bone,[None] int numInfluences,[None] const int* vertices,[None] const FLOAT* weights)</unmanaged>
        public SlimDX2.Result SetBoneInfluence(int bone, int numInfluences, ref int vertices, ref float weights) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* vertices_ = &vertices)
                    fixed (void* weights_ = &weights)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, bone, numInfluences, vertices_, weights_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an influence value of a bone on a single vertex.	
        /// </summary>	
        /// <param name="boneNum"> Index of the bone. Must be between 0 and the number of bones. </param>
        /// <param name="influenceNum"> Index of the influence array of the specified bone. </param>
        /// <param name="weight"> Blend factor of the specified bone influence. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetBoneVertexInfluence([None] int boneNum,[None] int influenceNum,[None] float weight)</unmanaged>
        public SlimDX2.Result SetBoneVertexInfluence(int boneNum, int influenceNum, float weight) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, boneNum, influenceNum, weight);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of influences for a bone.	
        /// </summary>	
        /// <param name="bone"> Bone number. </param>
        /// <returns>  <see cref="int"/>  Returns the number of influences for a bone. </returns>
        /// <unmanaged>int GetNumBoneInfluences([None] int bone)</unmanaged>
        public int GetNumBoneInfluences(int bone) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, bone);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the vertices and weights that a bone influences.	
        /// </summary>	
        /// <remarks>	
        ///  Use <see cref="SlimDX2.Direct3D9.SkinInfo.GetNumBoneInfluences"/> to find out how many vertices the bone influences.  	
        /// </remarks>	
        /// <param name="bone"> Bone number. </param>
        /// <param name="vertices"> Get the array of vertices influenced by a bone. </param>
        /// <param name="weights"> Get the array of weights influenced by a bone. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetBoneInfluence([None] int bone,[Out] int* vertices,[Out] FLOAT* weights)</unmanaged>
        public SlimDX2.Result GetBoneInfluence(int bone, out int vertices, out float weights) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* vertices_ = &vertices)
                    fixed (void* weights_ = &weights)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, bone, vertices_, weights_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the blend factor and vertex affected by a specified bone influence.	
        /// </summary>	
        /// <param name="boneNum"> Index of the bone. Must be between 0 and the number of bones. </param>
        /// <param name="influenceNum"> Index of the influence array of the specified bone. </param>
        /// <param name="pWeight"> Pointer to the blend factor influenced by influenceNum. </param>
        /// <param name="pVertexNum"> Pointer to the vertex influenced by influenceNum. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetBoneVertexInfluence([None] int boneNum,[None] int influenceNum,[Out] float* pWeight,[Out] int* pVertexNum)</unmanaged>
        public SlimDX2.Result GetBoneVertexInfluence(int boneNum, int influenceNum, out float pWeight, out int pVertexNum) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pWeight_ = &pWeight)
                    fixed (void* pVertexNum_ = &pVertexNum)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, boneNum, influenceNum, pWeight_, pVertexNum_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the maximum number of influences for any vertex in the mesh.	
        /// </summary>	
        /// <param name="maxVertexInfluences"> Pointer to the maximum vertex influence. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetMaxVertexInfluences([Out] int* maxVertexInfluences)</unmanaged>
        internal SlimDX2.Result GetMaxVertexInfluences(out int maxVertexInfluences) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* maxVertexInfluences_ = &maxVertexInfluences)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, maxVertexInfluences_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of bones.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns the number of bones. </returns>
        /// <unmanaged>int GetNumBones()</unmanaged>
        internal int GetNumBones() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the index of the bone influence affecting a single vertex.	
        /// </summary>	
        /// <param name="boneNum"> Index of the bone. Must be between 0 and the number of bones. </param>
        /// <param name="vertexNum"> Index of the vertex for which the bone influence is to be found. Must be between 0 and the number of vertices in the mesh. </param>
        /// <param name="pInfluenceIndex"> Pointer to the index of the bone influence that affects vertexNum. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the specified bone does not influence the given vertex, S_FALSE is returned. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT FindBoneVertexInfluenceIndex([None] int boneNum,[None] int vertexNum,[None] int* pInfluenceIndex)</unmanaged>
        public SlimDX2.Result FindBoneVertexInfluenceIndex(int boneNum, int vertexNum, ref int pInfluenceIndex) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pInfluenceIndex_ = &pInfluenceIndex)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, boneNum, vertexNum, pInfluenceIndex_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the maximum face influences in a triangle mesh with the specified index buffer.	
        /// </summary>	
        /// <param name="pIB"> Pointer to the index buffer that contains the mesh index data. </param>
        /// <param name="numFaces"> Number of faces in the mesh. </param>
        /// <param name="maxFaceInfluences"> Pointer to the maximum face influences. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetMaxFaceInfluences([None] LPDIRECT3DINDEXBUFFER9 pIB,[None] int NumFaces,[Out] int* maxFaceInfluences)</unmanaged>
        public SlimDX2.Result GetMaxFaceInfluences(SlimDX2.Direct3D9.IndexBuffer pIB, int numFaces, out int maxFaceInfluences) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* maxFaceInfluences_ = &maxFaceInfluences)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, (void*)((pIB == null)?IntPtr.Zero:pIB.NativePointer), numFaces, maxFaceInfluences_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the minimum bone influence. Influence values smaller than this are ignored.	
        /// </summary>	
        /// <param name="minInfl"> Minimum influence value. Influence values smaller than this are ignored. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMinBoneInfluence([None] FLOAT MinInfl)</unmanaged>
        internal SlimDX2.Result SetMinBoneInfluence(float minInfl) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, minInfl);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the minimum bone influence. Influence values smaller than this are ignored.	
        /// </summary>	
        /// <returns>  {{FLOAT}}  Returns the minimum bone influence value. </returns>
        /// <unmanaged>FLOAT GetMinBoneInfluence()</unmanaged>
        internal float GetMinBoneInfluence() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct3D9.LocalInterop.Callifloat(_nativePointer, 13 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the bone name.	
        /// </summary>	
        /// <remarks>	
        ///  Bone names are returned by <see cref="SlimDX2.Direct3D9.D3DX9.LoadMeshFromXof"/>. 	
        /// </remarks>	
        /// <param name="bone"> Bone number </param>
        /// <param name="pName"> Bone name </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetBoneName([None] int Bone,[None] const char* pName)</unmanaged>
        public SlimDX2.Result SetBoneName(int bone, string pName) {
            unsafe {
                IntPtr pName_ = Marshal.StringToHGlobalAnsi(pName);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, bone, (void*)pName_);
                Marshal.FreeHGlobal(pName_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the bone name, from the bone index.	
        /// </summary>	
        /// <param name="bone"> Bone number. </param>
        /// <returns>  {{LPCSTR}}  Returns the bone name. Do not free this string. </returns>
        /// <unmanaged>const char* GetBoneName([None] int Bone)</unmanaged>
        public IntPtr GetBoneName(int bone) {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 15 * 4, bone);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the bone offset matrix.	
        /// </summary>	
        /// <remarks>	
        ///  Bone names are returned by <see cref="SlimDX2.Direct3D9.D3DX9.LoadMeshFromXof"/>. 	
        /// </remarks>	
        /// <param name="bone"> Bone number. </param>
        /// <param name="pBoneTransform"> Pointer to the bone offset matrix. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetBoneOffsetMatrix([None] int Bone,[None] const D3DXMATRIX* pBoneTransform)</unmanaged>
        public SlimDX2.Result SetBoneOffsetMatrix(int bone, ref SlimMath.Matrix pBoneTransform) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pBoneTransform_ = &pBoneTransform)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, bone, pBoneTransform_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the bone offset matrix.	
        /// </summary>	
        /// <param name="bone"> Bone number. </param>
        /// <returns>  {{LPD3DXMATRIX}}  Returns a pointer to the bone offset matrix. Do not free this pointer. </returns>
        /// <unmanaged>LPD3DXMATRIX GetBoneOffsetMatrix([None] int Bone)</unmanaged>
        public SlimMath.Matrix GetBoneOffsetMatrix(int bone) {
            unsafe {
                SlimMath.Matrix __result__;
                SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 17 * 4,(void*)&__result__, bone);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Clones a skin info object.	
        /// </summary>	
        /// <param name="ppSkinInfo"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.SkinInfo"/> object, which will contain the cloned object if the method is successful. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT Clone([None] LPD3DXSKININFO* ppSkinInfo)</unmanaged>
        public SlimDX2.Result Clone(out SlimDX2.Direct3D9.SkinInfo ppSkinInfo) {
            unsafe {
                IntPtr ppSkinInfo_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, &ppSkinInfo_);
                ppSkinInfo = (ppSkinInfo_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.SkinInfo(ppSkinInfo_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Updates bone influence information to match vertices after they are reordered. This method should be called if the target vertex buffer has been reordered externally.	
        /// </summary>	
        /// <remarks>	
        ///  Each element in pVertexRemap specifies the previous vertex index for that position.  For example, if a vertex was in position 3 but has been remapped to position 5, then the fifth element of pVertexRemap should contain 3.  The vertex remap array returned by <see cref="SlimDX2.Direct3D9.Mesh.Optimize"/> can be used. 	
        /// </remarks>	
        /// <param name="numVertices"> Number of vertices to remap. </param>
        /// <param name="pVertexRemap"> Array of DWORDS whose length is specified by NumVertices. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT Remap([None] int NumVertices,[None] int* pVertexRemap)</unmanaged>
        public SlimDX2.Result Remap(int numVertices, ref int pVertexRemap) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pVertexRemap_ = &pVertexRemap)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, numVertices, pVertexRemap_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the flexible vertex format (FVF) type.	
        /// </summary>	
        /// <param name="fvf"> Flexible vertex format. See {{D3DFVF}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetFVF([None] int FVF)</unmanaged>
        internal SlimDX2.Result SetFVF(int fvf) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, fvf);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the vertex declaration.	
        /// </summary>	
        /// <param name="pDeclaration"> Pointer to an array of <see cref="SlimDX2.Direct3D9.Vertexelement9"/> elements. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetDeclaration([None] const D3DVERTEXELEMENT9* pDeclaration)</unmanaged>
        public SlimDX2.Result SetDeclaration(ref SlimDX2.Direct3D9.Vertexelement9 pDeclaration) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pDeclaration_ = &pDeclaration)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, pDeclaration_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the fixed function vertex value.	
        /// </summary>	
        /// <remarks>	
        ///  This method can return 0 if the vertex format cannot be mapped directly to an FVF code.  This will occur for a mesh created from a vertex declaration that doesn't have the same order and elements supported by the FVF codes. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  Returns the flexible vertex format (FVF) codes. </returns>
        /// <unmanaged>int GetFVF()</unmanaged>
        internal int GetFVF() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 22 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the vertex declaration.	
        /// </summary>	
        /// <remarks>	
        ///  The array of elements includes the {{D3DDECL_END}} macro, which ends the declaration. 	
        /// </remarks>	
        /// <param name="declaration"> Array of <see cref="SlimDX2.Direct3D9.Vertexelement9"/> elements describing the vertex format of the mesh vertices. The upper limit of this declarator array is {{MAX_FVF_DECL_SIZE}}. The vertex element array ends with the {{D3DDECL_END}} macro.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetDeclaration([None] D3DVERTEXELEMENT9 Declaration[65])</unmanaged>
        public SlimDX2.Result GetDeclaration(SlimDX2.Direct3D9.Vertexelement9[] declaration) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* declaration_ = &declaration[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, declaration_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Applies software skinning to the target vertices based on the current matrices.	
        /// </summary>	
        /// <remarks>	
        ///  When used to skin vertices with two position elements, this method skins the second position element with the inverse of the bone instead of the bone itself. 	
        /// </remarks>	
        /// <param name="pBoneTransforms"> Bone transform matrix. </param>
        /// <param name="pBoneInvTransposeTransforms"> Inverse transpose of the bone transform matrix. </param>
        /// <param name="pVerticesSrc"> Pointer to the buffer containing the source vertices. </param>
        /// <param name="pVerticesDst"> Pointer to the buffer containing the destination vertices. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT UpdateSkinnedMesh([None] const D3DXMATRIX* pBoneTransforms,[None] const D3DXMATRIX* pBoneInvTransposeTransforms,[None] LPCVOID pVerticesSrc,[None] PVOID pVerticesDst)</unmanaged>
        public SlimDX2.Result UpdateSkinnedMesh(ref SlimMath.Matrix pBoneTransforms, ref SlimMath.Matrix pBoneInvTransposeTransforms, IntPtr pVerticesSrc, IntPtr pVerticesDst) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pBoneTransforms_ = &pBoneTransforms)
                    fixed (void* pBoneInvTransposeTransforms_ = &pBoneInvTransposeTransforms)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, pBoneTransforms_, pBoneInvTransposeTransforms_, (void*)pVerticesSrc, (void*)pVerticesDst);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Takes a mesh and returns a new mesh with per-vertex blend weights and a bone combination table. The table describes which bones affect which subsets of the mesh.	
        /// </summary>	
        /// <remarks>	
        ///  Each element in the remap array specifies the previous index for that position. For example, if a vertex was in position 3 but has been remapped to position 5, then the fifth element of pVertexRemap will contain 3. This method does not run on hardware that does not support fixed-function vertex blending. 	
        /// </remarks>	
        /// <param name="pMesh"> Input mesh. See <see cref="SlimDX2.Direct3D9.Mesh"/>. </param>
        /// <param name="options"> Currently unused. </param>
        /// <param name="pAdjacencyIn"> Input mesh adjacency information. </param>
        /// <param name="pAdjacencyOut"> Output mesh adjacency information. </param>
        /// <param name="pFaceRemap"> An array of DWORDs, one per face, that identifies the original mesh face that corresponds to each face in the blended mesh. If the value supplied for this argument is NULL, face remap data is not returned. </param>
        /// <param name="ppVertexRemap"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface, which contains a DWORD for each vertex that specifies how the new vertices map to the old vertices. This remap is useful if you need to alter external data based on the new vertex mapping. This parameter is optional; NULL may be used. </param>
        /// <param name="pMaxFaceInfl"> Pointer to a DWORD that will contain the maximum number of bone influences required per vertex for this skinning method. </param>
        /// <param name="pNumBoneCombinations"> Pointer to the number of bones in the bone combination table. </param>
        /// <param name="ppBoneCombinationTable"> Pointer to the bone combination table. The data is organized in a <see cref="SlimDX2.Direct3D9.Bonecombination"/> structure. </param>
        /// <param name="ppMesh"> Pointer to the new mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ConvertToBlendedMesh([None] LPD3DXMESH pMesh,[None] int Options,[None] const int* pAdjacencyIn,[None] LPDWORD pAdjacencyOut,[None] int* pFaceRemap,[None] LPD3DXBUFFER* ppVertexRemap,[None] int* pMaxFaceInfl,[None] int* pNumBoneCombinations,[None] LPD3DXBUFFER* ppBoneCombinationTable,[None] LPD3DXMESH* ppMesh)</unmanaged>
        public SlimDX2.Result ConvertToBlendedMesh(SlimDX2.Direct3D9.Mesh pMesh, int options, ref int pAdjacencyIn, ref int pAdjacencyOut, ref int pFaceRemap, out SlimDX2.Direct3D9.Buffer ppVertexRemap, ref int pMaxFaceInfl, ref int pNumBoneCombinations, out SlimDX2.Direct3D9.Buffer ppBoneCombinationTable, out SlimDX2.Direct3D9.Mesh ppMesh) {
            unsafe {
                IntPtr ppVertexRemap_ = IntPtr.Zero;
                IntPtr ppBoneCombinationTable_ = IntPtr.Zero;
                IntPtr ppMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pAdjacencyIn_ = &pAdjacencyIn)
                    fixed (void* pAdjacencyOut_ = &pAdjacencyOut)
                        fixed (void* pFaceRemap_ = &pFaceRemap)
                            fixed (void* pMaxFaceInfl_ = &pMaxFaceInfl)
                                fixed (void* pNumBoneCombinations_ = &pNumBoneCombinations)
                                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4, (void*)((pMesh == null)?IntPtr.Zero:pMesh.NativePointer), options, pAdjacencyIn_, pAdjacencyOut_, pFaceRemap_, &ppVertexRemap_, pMaxFaceInfl_, pNumBoneCombinations_, &ppBoneCombinationTable_, &ppMesh_);
                ppVertexRemap = (ppVertexRemap_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppVertexRemap_);	
                ppBoneCombinationTable = (ppBoneCombinationTable_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppBoneCombinationTable_);	
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Takes a mesh and returns a new mesh with per-vertex blend weights, indices, and a bone combination table. The table describes which bone palettes affect which subsets of the mesh.	
        /// </summary>	
        /// <remarks>	
        ///  Each element in the remap arrays specifies the previous index for that position. For example, if a vertex was in position 3 but has been remapped to position 5, then the fifth element of pVertexRemap will contain 3. This method does not run on hardware that does not support fixed-function vertex blending. 	
        /// </remarks>	
        /// <param name="pMesh"> The input mesh. See <see cref="SlimDX2.Direct3D9.Mesh"/>. </param>
        /// <param name="options"> Currently unused. </param>
        /// <param name="paletteSize"> Number of bone matrices available for matrix palette skinning. </param>
        /// <param name="pAdjacencyIn"> Input mesh adjacency information. </param>
        /// <param name="pAdjacencyOut"> Output mesh adjacency information. </param>
        /// <param name="pFaceRemap"> An array of DWORDs, one per face, that identifies the original mesh face that corresponds to each face in the blended mesh. If the value supplied for this argument is NULL, face remap data is not returned. </param>
        /// <param name="ppVertexRemap"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface, which contains a DWORD for each vertex that specifies how the new vertices map to the old vertices. This remap is useful if you need to alter external data based on the new vertex mapping. This parameter is optional; NULL may be used. </param>
        /// <param name="pMaxVertexInfl"> Pointer to a DWORD that will contain the maximum number of bone influences required per vertex for this skinning method. </param>
        /// <param name="pNumBoneCombinations"> Pointer to the number of bones in the bone combination table. </param>
        /// <param name="ppBoneCombinationTable"> Pointer to the bone combination table. The data is organized in a <see cref="SlimDX2.Direct3D9.Bonecombination"/> structure. </param>
        /// <param name="ppMesh"> Pointer to the new mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ConvertToIndexedBlendedMesh([None] LPD3DXMESH pMesh,[None] int Options,[None] int paletteSize,[None] const int* pAdjacencyIn,[None] LPDWORD pAdjacencyOut,[None] int* pFaceRemap,[None] LPD3DXBUFFER* ppVertexRemap,[None] int* pMaxVertexInfl,[None] int* pNumBoneCombinations,[None] LPD3DXBUFFER* ppBoneCombinationTable,[None] LPD3DXMESH* ppMesh)</unmanaged>
        public SlimDX2.Result ConvertToIndexedBlendedMesh(SlimDX2.Direct3D9.Mesh pMesh, int options, int paletteSize, ref int pAdjacencyIn, ref int pAdjacencyOut, ref int pFaceRemap, out SlimDX2.Direct3D9.Buffer ppVertexRemap, ref int pMaxVertexInfl, ref int pNumBoneCombinations, out SlimDX2.Direct3D9.Buffer ppBoneCombinationTable, out SlimDX2.Direct3D9.Mesh ppMesh) {
            unsafe {
                IntPtr ppVertexRemap_ = IntPtr.Zero;
                IntPtr ppBoneCombinationTable_ = IntPtr.Zero;
                IntPtr ppMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pAdjacencyIn_ = &pAdjacencyIn)
                    fixed (void* pAdjacencyOut_ = &pAdjacencyOut)
                        fixed (void* pFaceRemap_ = &pFaceRemap)
                            fixed (void* pMaxVertexInfl_ = &pMaxVertexInfl)
                                fixed (void* pNumBoneCombinations_ = &pNumBoneCombinations)
                                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 26 * 4, (void*)((pMesh == null)?IntPtr.Zero:pMesh.NativePointer), options, paletteSize, pAdjacencyIn_, pAdjacencyOut_, pFaceRemap_, &ppVertexRemap_, pMaxVertexInfl_, pNumBoneCombinations_, &ppBoneCombinationTable_, &ppMesh_);
                ppVertexRemap = (ppVertexRemap_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppVertexRemap_);	
                ppBoneCombinationTable = (ppBoneCombinationTable_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppBoneCombinationTable_);	
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXPRTBuffer</unmanaged>
    [Guid("f1827e47-00a8-49cd-908c-9d11955f8728")]
    public partial class PRTBuffer : SlimDX2.ComObject {
        public PRTBuffer(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the number of vertices (or texels) sampled.	
        /// </summary>	
        /// <unmanaged>UINT GetNumSamples()</unmanaged>
        public int NumSamples {
                get { return GetNumSamples(); }
        }
        
        /// <summary>	
        /// Retrieves the number of scalars per color channel used in memory to store samples.	
        /// </summary>	
        /// <unmanaged>UINT GetNumCoeffs()</unmanaged>
        public int NumCoeffs {
                get { return GetNumCoeffs(); }
        }
        
        /// <summary>	
        /// Retrieves the number of color channels used in memory to store samples.	
        /// </summary>	
        /// <unmanaged>UINT GetNumChannels()</unmanaged>
        public int NumChannels {
                get { return GetNumChannels(); }
        }
        
        /// <summary>	
        /// Indicates whether the buffer contains a texture.	
        /// </summary>	
        /// <unmanaged>BOOL IsTexture()</unmanaged>
        public bool IsTexture {
                get { return IsTexture_(); }
        }
        
        /// <summary>	
        /// Retrieves the width of the texture, in pixels.	
        /// </summary>	
        /// <unmanaged>UINT GetWidth()</unmanaged>
        public int Width {
                get { return GetWidth(); }
        }
        
        /// <summary>	
        /// Retrieves the height of the texture, in pixels.	
        /// </summary>	
        /// <unmanaged>UINT GetHeight()</unmanaged>
        public int Height {
                get { return GetHeight(); }
        }
        
        /// <summary>	
        /// Retrieves the number of vertices (or texels) sampled.	
        /// </summary>	
        /// <returns>  {{UINT}}  Returns the number of vertices (or texels) sampled. </returns>
        /// <unmanaged>UINT GetNumSamples()</unmanaged>
        internal int GetNumSamples() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of scalars per color channel used in memory to store samples.	
        /// </summary>	
        /// <returns>  {{UINT}}  Returns the number of scalars per color channel used in memory to store samples. </returns>
        /// <unmanaged>UINT GetNumCoeffs()</unmanaged>
        internal int GetNumCoeffs() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of color channels used in memory to store samples.	
        /// </summary>	
        /// <returns>  {{UINT}}  Returns the number of color channels used in memory to store samples. The value generally will be either 1 to represent luminance values, or 3 to represent RGB values. </returns>
        /// <unmanaged>UINT GetNumChannels()</unmanaged>
        internal int GetNumChannels() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Indicates whether the buffer contains a texture.	
        /// </summary>	
        /// <returns>  {{BOOL}}  Returns TRUE if the buffer contains a texture; returns FALSE otherwise. </returns>
        /// <unmanaged>BOOL IsTexture()</unmanaged>
        internal bool IsTexture_() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the width of the texture, in pixels.	
        /// </summary>	
        /// <returns>  {{UINT}}  Returns the width of the texture, in pixels. </returns>
        /// <unmanaged>UINT GetWidth()</unmanaged>
        internal int GetWidth() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the height of the texture, in pixels.	
        /// </summary>	
        /// <returns>  {{UINT}}  Returns the height of the texture, in pixels. </returns>
        /// <unmanaged>UINT GetHeight()</unmanaged>
        internal int GetHeight() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Changes the number of samples contained in the buffer.	
        /// </summary>	
        /// <param name="newSize"> Number of samples to be contained in the buffer. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the following value will be returned, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT Resize([None] UINT NewSize)</unmanaged>
        public SlimDX2.Result Resize(int newSize) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, newSize);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Locks a range of vertex or texel sample data and obtains a pointer to the location in buffer memory.	
        /// </summary>	
        /// <remarks>	
        ///  	
        /// </remarks>	
        /// <param name="start"> Index of the sample of vertex or texel data. </param>
        /// <param name="numSamples"> Number of vertices (or texels) sampled. </param>
        /// <param name="ppData"> Pointer to the location in memory where the Start sample begins. The memory layout of the buffer data is:	 <code> float fData[NumberSamples][NumberChannels][NumberCoefficients]		 </code> </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: </returns>
        /// <unmanaged>HRESULT LockBuffer([None] UINT Start,[None] UINT NumSamples,[None] FLOAT** ppData)</unmanaged>
        public SlimDX2.Result LockBuffer(int start, int numSamples, ref float ppData) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* ppData_ = &ppData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, start, numSamples, ppData_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Ends the lifespan of the ppData pointer returned by <see cref="SlimDX2.Direct3D9.PRTBuffer.LockBuffer"/>.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. </returns>
        /// <unmanaged>HRESULT UnlockBuffer()</unmanaged>
        public SlimDX2.Result UnlockBuffer() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Multiplies every value in the buffer by a constant value.	
        /// </summary>	
        /// <param name="scale"> Constant value used to scale the buffer. Every value in the buffer is replaced by the product of this value and the original buffer value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned. </returns>
        /// <unmanaged>HRESULT ScaleBuffer([None] FLOAT Scale)</unmanaged>
        public SlimDX2.Result ScaleBuffer(float scale) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, scale);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds another buffer to the <see cref="SlimDX2.Direct3D9.PRTBuffer"/> and stores the results in ID3DXPRTBuffer.	
        /// </summary>	
        /// <remarks>	
        ///  pBuffer and <see cref="SlimDX2.Direct3D9.PRTBuffer"/> must have the same number of samples, coefficients, and color channels; the method will fail otherwise. 	
        /// </remarks>	
        /// <param name="pBuffer"> Pointer to a buffer that contains members to be added to the respective members of the <see cref="SlimDX2.Direct3D9.PRTBuffer"/> buffer. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned. </returns>
        /// <unmanaged>HRESULT AddBuffer([None] LPD3DXPRTBUFFER pBuffer)</unmanaged>
        public SlimDX2.Result AddBuffer(SlimDX2.Direct3D9.PRTBuffer pBuffer) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, (void*)((pBuffer == null)?IntPtr.Zero:pBuffer.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Associates an <see cref="SlimDX2.Direct3D9.TextureGutterHelper"/> object with the <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object.	
        /// </summary>	
        /// <remarks>	
        ///  The reference count of the <see cref="SlimDX2.Direct3D9.TextureGutterHelper"/> object will automatically be incremented by one. Any existing ID3DXTextureGutterHelper pointers will be released. You must ensure that the number of ID3DXPRTBuffer::AttachGH calls matches the number of <see cref="SlimDX2.Direct3D9.PRTBuffer.ReleaseGH"/> calls. After calling ID3DXPRTBuffer::ReleaseGH, the pGH pointer returned by ID3DXPRTBuffer::AttachGH should no longer be used. 	
        /// </remarks>	
        /// <param name="arg0"> Pointer to the <see cref="SlimDX2.Direct3D9.TextureGutterHelper"/> interface of an object that contains texture gutter data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK.  </returns>
        /// <unmanaged>HRESULT AttachGH([None] LPD3DXTEXTUREGUTTERHELPER arg0)</unmanaged>
        public SlimDX2.Result AttachGH(SlimDX2.Direct3D9.TextureGutterHelper arg0) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, (void*)((arg0 == null)?IntPtr.Zero:arg0.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Unassociates an attached <see cref="SlimDX2.Direct3D9.TextureGutterHelper"/> object with the <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object.	
        /// </summary>	
        /// <remarks>	
        ///  This method releases the pointer to the <see cref="SlimDX2.Direct3D9.TextureGutterHelper"/> interface. You must ensure that the number of <see cref="SlimDX2.Direct3D9.PRTBuffer.AttachGH"/> calls matches the number of ID3DXPRTBuffer::ReleaseGH calls. After calling ID3DXPRTBuffer::ReleaseGH, the pGH pointer returned by ID3DXPRTBuffer::AttachGH should no longer be used. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK.  </returns>
        /// <unmanaged>HRESULT ReleaseGH()</unmanaged>
        public SlimDX2.Result ReleaseGH() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Applies stored texture gutter data to an <see cref="SlimDX2.Direct3D9.PRTBuffer"/> texture buffer.	
        /// </summary>	
        /// <remarks>	
        ///  This method makes an internal call to <see cref="SlimDX2.Direct3D9.TextureGutterHelper.ApplyGuttersFloat"/> to retrieve and apply texture gutter data. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned. </returns>
        /// <unmanaged>HRESULT EvalGH()</unmanaged>
        public SlimDX2.Result EvalGH() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Extracts coefficient data from a color channel of the buffer for a specified range of coefficients, and adds the data to an <see cref="SlimDX2.Direct3D9.Texture"/> object.	
        /// </summary>	
        /// <param name="channel"> Buffer color channel from which to extract texture data. </param>
        /// <param name="startCoefficient"> Starting value of the buffer coefficient from which to extract texture data. </param>
        /// <param name="numCoefficients"> Number of scalars, beginning at StartCoefficient, from which to extract texture data. </param>
        /// <param name="pTexture"> Pointer to a <see cref="SlimDX2.Direct3D9.Texture"/> texture object that will store coefficients. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ExtractTexture([None] UINT Channel,[None] UINT StartCoefficient,[None] UINT NumCoefficients,[None] LPDIRECT3DTEXTURE9 pTexture)</unmanaged>
        public SlimDX2.Result ExtractTexture(int channel, int startCoefficient, int numCoefficients, SlimDX2.Direct3D9.Texture pTexture) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, channel, startCoefficient, numCoefficients, (void*)((pTexture == null)?IntPtr.Zero:pTexture.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Extracts coefficient data from a single-channel buffer and adds the data to an <see cref="SlimDX2.Direct3D9.Mesh"/> object.	
        /// </summary>	
        /// <param name="numCoefficients"> Number of coefficients to extract from the buffer. When using spherical harmonic (SH) precomputed radiance transfer (PRT), the number of coefficients should be Order 2. Order must be in the range of {{D3DXSH_MINORDER}} to D3DXSH_MAXORDER, inclusive. </param>
        /// <param name="usage"> Vertex usage descriptions of the mesh. See <see cref="SlimDX2.Direct3D9.Declusage"/>. </param>
        /// <param name="usageIndexStart"> Starting index for coefficients to be stored in the mesh. </param>
        /// <param name="pScene"> Pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> mesh object that will store coefficients. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ExtractToMesh([None] UINT NumCoefficients,[None] D3DDECLUSAGE Usage,[None] UINT UsageIndexStart,[None] LPD3DXMESH pScene)</unmanaged>
        public SlimDX2.Result ExtractToMesh(int numCoefficients, SlimDX2.Direct3D9.Declusage usage, int usageIndexStart, SlimDX2.Direct3D9.Mesh pScene) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, numCoefficients, unchecked((int)usage), usageIndexStart, (void*)((pScene == null)?IntPtr.Zero:pScene.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXPRTCompBuffer</unmanaged>
    [Guid("a758d465-fe8d-45ad-9cf0-d01e56266a07")]
    public partial class PRTCompBuffer : SlimDX2.ComObject {
        public PRTCompBuffer(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the number of vertices (or texels) sampled.	
        /// </summary>	
        /// <unmanaged>UINT GetNumSamples()</unmanaged>
        public int NumSamples {
                get { return GetNumSamples(); }
        }
        
        /// <summary>	
        /// Retrieves the number of scalars per color channel used in memory to store samples.	
        /// </summary>	
        /// <unmanaged>UINT GetNumCoeffs()</unmanaged>
        public int NumCoeffs {
                get { return GetNumCoeffs(); }
        }
        
        /// <summary>	
        /// Retrieves the number of color channels used in memory to store samples.	
        /// </summary>	
        /// <remarks>	
        ///   	
        /// </remarks>	
        /// <unmanaged>UINT GetNumChannels()</unmanaged>
        public int NumChannels {
                get { return GetNumChannels(); }
        }
        
        /// <summary>	
        /// Indicates whether the buffer contains a texture.	
        /// </summary>	
        /// <unmanaged>BOOL IsTexture()</unmanaged>
        public bool IsTexture {
                get { return IsTexture_(); }
        }
        
        /// <summary>	
        /// Retrieves the width of the texture, in pixels.	
        /// </summary>	
        /// <unmanaged>UINT GetWidth()</unmanaged>
        public int Width {
                get { return GetWidth(); }
        }
        
        /// <summary>	
        /// Retrieves the height of the texture, in pixels.	
        /// </summary>	
        /// <unmanaged>UINT GetHeight()</unmanaged>
        public int Height {
                get { return GetHeight(); }
        }
        
        /// <summary>	
        /// Retrieves the number of clusters to use for compression.	
        /// </summary>	
        /// <unmanaged>UINT GetNumClusters()</unmanaged>
        public int NumClusters {
                get { return GetNumClusters(); }
        }
        
        /// <summary>	
        /// Retrieves the number of principal component analysis (PCA) basis vectors to use in each cluster.	
        /// </summary>	
        /// <unmanaged>UINT GetNumPCA()</unmanaged>
        public int NumPCA {
                get { return GetNumPCA(); }
        }
        
        /// <summary>	
        /// Retrieves the number of vertices (or texels) sampled.	
        /// </summary>	
        /// <returns>  {{UINT}}  Returns the number of vertices (or texels) sampled. </returns>
        /// <unmanaged>UINT GetNumSamples()</unmanaged>
        internal int GetNumSamples() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of scalars per color channel used in memory to store samples.	
        /// </summary>	
        /// <returns>  {{UINT}}  Returns the number of scalars per color channel used in memory to store samples. </returns>
        /// <unmanaged>UINT GetNumCoeffs()</unmanaged>
        internal int GetNumCoeffs() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of color channels used in memory to store samples.	
        /// </summary>	
        /// <remarks>	
        ///   	
        /// </remarks>	
        /// <returns>  {{UINT}}  Returns the number of color channels used in memory to store samples. The value generally will be either 1 to represent luminance values, or 3 to represent RGB values. </returns>
        /// <unmanaged>UINT GetNumChannels()</unmanaged>
        internal int GetNumChannels() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Indicates whether the buffer contains a texture.	
        /// </summary>	
        /// <returns>  {{BOOL}}  Returns TRUE if the buffer contains a texture; returns FALSE otherwise. </returns>
        /// <unmanaged>BOOL IsTexture()</unmanaged>
        internal bool IsTexture_() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the width of the texture, in pixels.	
        /// </summary>	
        /// <returns>  {{UINT}}  Returns the width of the texture, in pixels. </returns>
        /// <unmanaged>UINT GetWidth()</unmanaged>
        internal int GetWidth() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the height of the texture, in pixels.	
        /// </summary>	
        /// <returns>  {{UINT}}  Returns the height of the texture, in pixels. </returns>
        /// <unmanaged>UINT GetHeight()</unmanaged>
        internal int GetHeight() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of clusters to use for compression.	
        /// </summary>	
        /// <returns>  {{UINT}}  Returns the number of clusters to use for compression. </returns>
        /// <unmanaged>UINT GetNumClusters()</unmanaged>
        internal int GetNumClusters() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of principal component analysis (PCA) basis vectors to use in each cluster.	
        /// </summary>	
        /// <returns>  {{UINT}}  Returns the number of principal component analysis (PCA) basis vectors to use in each cluster. </returns>
        /// <unmanaged>UINT GetNumPCA()</unmanaged>
        internal int GetNumPCA() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Normalizes all principal component analysis (PCA) weights so that they are between -1 and 1. Basis vectors are modified to reflect this normalization.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned. </returns>
        /// <unmanaged>HRESULT NormalizeData()</unmanaged>
        public SlimDX2.Result NormalizeData() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Extracts the mean and principal component analysis (PCA) basis vectors for a given cluster from an <see cref="SlimDX2.Direct3D9.PRTCompBuffer"/> compressed data buffer.	
        /// </summary>	
        /// <param name="cluster"> Cluster for which the basis will be extracted. </param>
        /// <param name="pClusterBasis"> Pointer to an array of basis vector data for Cluster. The size of the FLOAT data stored will be: (1 + Number of PCA vectors per cluster) * (Number of coefficients) * (Number of color channels) </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned. </returns>
        /// <unmanaged>HRESULT ExtractBasis([None] UINT Cluster,[None] FLOAT* pClusterBasis)</unmanaged>
        public SlimDX2.Result ExtractBasis(int cluster, ref float pClusterBasis) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pClusterBasis_ = &pClusterBasis)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, cluster, pClusterBasis_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Extracts the per-sample cluster IDs from an <see cref="SlimDX2.Direct3D9.PRTCompBuffer"/> compressed data buffer.	
        /// </summary>	
        /// <param name="pClusterIDs"> Pointer to the location in memory where IDs are written. The length of memory required is the value returned by <see cref="SlimDX2.Direct3D9.PRTCompBuffer.GetNumSamples"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned. </returns>
        /// <unmanaged>HRESULT ExtractClusterIDs([None] UINT* pClusterIDs)</unmanaged>
        public SlimDX2.Result ExtractClusterIDs(ref int pClusterIDs) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pClusterIDs_ = &pClusterIDs)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, pClusterIDs_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Extracts the per-sample principal component analysis (PCA) projection coefficients from an <see cref="SlimDX2.Direct3D9.PRTCompBuffer"/> compressed data buffer.	
        /// </summary>	
        /// <param name="startPCA"> Starting index for PCA projection coefficients to extract from the buffer. </param>
        /// <param name="numExtract"> Number of PCA projection coefficients to extract from the buffer. </param>
        /// <param name="pPCACoefficients"> Pointer to the location where clustered principal component analysis (CPCA) coefficients are written. The size of the data written is (Number of Samples) * (Number of PCA Coefficients). </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned. </returns>
        /// <unmanaged>HRESULT ExtractPCA([None] UINT StartPCA,[None] UINT NumExtract,[None] FLOAT* pPCACoefficients)</unmanaged>
        public SlimDX2.Result ExtractPCA(int startPCA, int numExtract, ref float pPCACoefficients) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pPCACoefficients_ = &pPCACoefficients)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, startPCA, numExtract, pPCACoefficients_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Extracts the per-sample principal component analysis (PCA) projection coefficients from an <see cref="SlimDX2.Direct3D9.PRTCompBuffer"/> compressed data buffer and adds the data to an <see cref="SlimDX2.Direct3D9.Texture"/> object.	
        /// </summary>	
        /// <param name="startPCA"> Starting value of the buffer coefficient from which to extract texture data. </param>
        /// <param name="numpPCA"> Number of PCA coefficients to extract from the buffer. </param>
        /// <param name="pTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> texture object that will store PCA coefficients. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned. </returns>
        /// <unmanaged>HRESULT ExtractTexture([None] UINT StartPCA,[None] UINT NumpPCA,[None] LPDIRECT3DTEXTURE9 pTexture)</unmanaged>
        public SlimDX2.Result ExtractTexture(int startPCA, int numpPCA, SlimDX2.Direct3D9.Texture pTexture) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, startPCA, numpPCA, (void*)((pTexture == null)?IntPtr.Zero:pTexture.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Extracts the per-sample principal component analysis (PCA) projection coefficients from an <see cref="SlimDX2.Direct3D9.PRTCompBuffer"/> compressed data buffer and adds the data to an <see cref="SlimDX2.Direct3D9.Mesh"/> object.	
        /// </summary>	
        /// <param name="numPCA"> Number of PCA coefficients to extract from the buffer. </param>
        /// <param name="usage"> Vertex usage descriptions of the mesh. See <see cref="SlimDX2.Direct3D9.Declusage"/>. </param>
        /// <param name="usageIndexStart"> Starting index for PCA coefficients to be stored in the mesh. </param>
        /// <param name="pScene"> Pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> mesh object that will store PCA coefficients. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ExtractToMesh([None] UINT NumPCA,[None] D3DDECLUSAGE Usage,[None] UINT UsageIndexStart,[None] LPD3DXMESH pScene)</unmanaged>
        public SlimDX2.Result ExtractToMesh(int numPCA, SlimDX2.Direct3D9.Declusage usage, int usageIndexStart, SlimDX2.Direct3D9.Mesh pScene) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, numPCA, unchecked((int)usage), usageIndexStart, (void*)((pScene == null)?IntPtr.Zero:pScene.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXTextureGutterHelper</unmanaged>
    [Guid("838f01ec-9729-4527-aadb-df70ade7fea9")]
    public partial class TextureGutterHelper : SlimDX2.ComObject {
        public TextureGutterHelper(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the width of the texture, in pixels.	
        /// </summary>	
        /// <unmanaged>UINT GetWidth()</unmanaged>
        public int Width {
                get { return GetWidth(); }
        }
        
        /// <summary>	
        /// Retrieves the height of the texture, in pixels.	
        /// </summary>	
        /// <unmanaged>UINT GetHeight()</unmanaged>
        public int Height {
                get { return GetHeight(); }
        }
        
        /// <summary>	
        /// Retrieves the index of the mesh face to which each texel belongs.	
        /// </summary>	
        /// <remarks>	
        ///  The mesh face data returned by this method is valid only for valid (non-class 0) texels. <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetGutterMap"/> will return nonzero values for valid (non-class 0) texels. For {{class 2 texels}}, this method retrieves the closest face. The application must allocate and manage pFaceData. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetFaceMap([Out] UINT* pFaceData)</unmanaged>
        public int FaceMap {
                get { int __output__; GetFaceMap(out __output__); return __output__; }
                set { SetFaceMap(ref value); }
        }
        
        /// <summary>	
        /// Retrieves texel barycentric coordinates.	
        /// </summary>	
        /// <remarks>	
        ///  The third barycentric coordinate is given by:  	
        /// <code> 1 - ( pBaryData.x + pBaryData.y ) </code>	
        /// 	
        ///  Barycentric coordinates are always specified with respect to the triangle returned by <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetFaceMap"/>. The barycentric coordinates returned by this method are valid only for valid (non-class 0) texels. <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetGutterMap"/> will return nonzero values for valid texels.  {{Class 2 texels}} are mapped to the nearest point on the triangle in texel space. The application must allocate and manage pBaryData. Barycentric coordinates define a point inside a triangle in terms of the triangle's vertices. For a more in-depth description of barycentric coordinates, see {{Mathworld's Barycentric Coordinates Description}}. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetBaryMap([Out] D3DXVECTOR2* pBaryData)</unmanaged>
        public SlimMath.Vector2 BaryMap {
                get { SlimMath.Vector2 __output__; GetBaryMap(out __output__); return __output__; }
                set { SetBaryMap(ref value); }
        }
        
        /// <summary>	
        /// Retrieves the (u, v) texture coordinates of each texel.	
        /// </summary>	
        /// <remarks>	
        ///  For {{class 2 and 4 texels}}, the returned (u, v) texture coordinates correspond to the closest point on the closest triangle. The application must allocate and manage pTexelData. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetTexelMap([Out] D3DXVECTOR2* pTexelData)</unmanaged>
        public SlimMath.Vector2 TexelMap {
                get { SlimMath.Vector2 __output__; GetTexelMap(out __output__); return __output__; }
                set { SetTexelMap(ref value); }
        }
        
        /// <summary>	
        /// Receives a texel class value that indicates texel class according to each texel's location.	
        /// </summary>	
        /// <remarks>	
        ///  The application must allocate and manage pGutterData, with size given by: 	
        /// <code> texture width * texture height * sizeof(BYTE) </code>	
        /// 	
        ///  Texture width and height are returned by <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetWidth"/> and <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetHeight"/>. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetGutterMap([Out] byte* pGutterData)</unmanaged>
        public byte GutterMap {
                get { byte __output__; GetGutterMap(out __output__); return __output__; }
                set { SetGutterMap(ref value); }
        }
        
        /// <summary>	
        /// Retrieves the width of the texture, in pixels.	
        /// </summary>	
        /// <returns>  {{UINT}}  Returns the width of the texture, in pixels. </returns>
        /// <unmanaged>UINT GetWidth()</unmanaged>
        internal int GetWidth() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the height of the texture, in pixels.	
        /// </summary>	
        /// <returns>  {{UINT}}  Returns the height of the texture, in pixels. </returns>
        /// <unmanaged>UINT GetHeight()</unmanaged>
        internal int GetHeight() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Applies gutters to a FLOAT texture buffer.	
        /// </summary>	
        /// <remarks>	
        ///   {{Class 2 texels}} are generated by resampling class 1 and 4 texels. 	
        /// </remarks>	
        /// <param name="pDataIn"> Pointer to a buffer of FLOAT texture data. </param>
        /// <param name="numCoeffs"> Number of scalars per color channel used in memory to store samples. Each texel contains NumCoeffs  FLOAT values. </param>
        /// <param name="width"> Width of the texture, in pixels, obtained from <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetWidth"/>. </param>
        /// <param name="height"> Height of the texture, in pixels, obtained from <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetHeight"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT ApplyGuttersFloat([None] FLOAT* pDataIn,[None] UINT NumCoeffs,[None] UINT Width,[None] UINT Height)</unmanaged>
        public SlimDX2.Result ApplyGuttersFloat(ref float pDataIn, int numCoeffs, int width, int height) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pDataIn_ = &pDataIn)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, pDataIn_, numCoeffs, width, height);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Applies gutters to an <see cref="SlimDX2.Direct3D9.Texture"/> texture object.	
        /// </summary>	
        /// <remarks>	
        ///   {{Class 2 texels}} are generated by resampling class 1 and 4 texels. The width and height of the texture must be the same as those returned by <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetWidth"/> and <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetHeight"/>. 	
        /// </remarks>	
        /// <param name="pTexture"> Pointer to a <see cref="SlimDX2.Direct3D9.Texture"/> texture object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_WASSTILLDRAWING, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ApplyGuttersTex([None] LPDIRECT3DTEXTURE9 pTexture)</unmanaged>
        public SlimDX2.Result ApplyGuttersTex(SlimDX2.Direct3D9.Texture pTexture) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)((pTexture == null)?IntPtr.Zero:pTexture.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Applies gutters to an <see cref="SlimDX2.Direct3D9.PRTBuffer"/> buffer object.	
        /// </summary>	
        /// <remarks>	
        ///   {{Class 2 texels}} are generated by resampling class 1 and 4 texels. The width and height of the texture must be the same as those returned by <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetWidth"/> and <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetHeight"/>. 	
        /// </remarks>	
        /// <param name="pBuffer"> Pointer to an <see cref="SlimDX2.Direct3D9.PRTBuffer"/> buffer object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT ApplyGuttersPRT([None] LPD3DXPRTBUFFER pBuffer)</unmanaged>
        public SlimDX2.Result ApplyGuttersPRT(SlimDX2.Direct3D9.PRTBuffer pBuffer) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)((pBuffer == null)?IntPtr.Zero:pBuffer.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Resamples a texture into this gutterhelper's parameterization.	
        /// </summary>	
        /// <remarks>	
        ///  A parameterization in the case of this function is a set of texture coordinates that maps the triangles of a mesh to the triangles on a texture.  The new parameterization is the set of texture coordinates contained in the gutter helper interface, and the original parameterization is the set of texture coordinates contained within the input mesh. It is assumed that texture coordinates are between 0 and 1, inclusive, and the new parameterization must be declared in the vertex declaration as texture coordinate index 0. The original texture and the resampled texture must have the same width and height. For example, to prepare for resampling a texture:  Create the original texture interface (pOriginalTex below) using a function like {{D3DXCreateTextureFromFile}}. Create the new texture interface for the resampled texture (pResampledTex below). The size of this texture must match the size (width and height) of the gutter helper texture. Call <see cref="SlimDX2.Direct3D9.D3DX9.CreateTextureGutterHelper"/> to obtain the new parameterization as shown here:  	
        /// <code> // Given:	
        /// // pMesh points to a mesh that contains the original and new texture coordinates	
        /// ID3DXTextureGutterHelper * pGutterHelper; // Mesh vertex declaration	
        /// D3DVERTEXELEMENT9 decl[] = { {0,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0}, {0, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_NORMAL, 0}, // contains new set of texcoords {0, 24, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 0},  // contains original set of texcoords {0, 32, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 1},  D3DDECL_END()	
        /// }; // Create a gutter helper with the new parameterization	
        /// hr = D3DXCreateTextureGutterHelper(width, height, pMesh, 1, &amp;pGutterHelper);   // Resample the texture	
        /// hr = pGutterHelper-&gt;ResampleTex(pOriginalTex, pMesh, D3DDECLUSAGE_TEXCOORD,  1, pResampledTex);  // Release the gutter helper interface when done with it </code>	
        /// 	
        ///  One common scenario might be to use UVAtlas to create a texture atlas and then use ResampleTex to resample the texture into the new parameterization. For more information about atlases, see {{Using UVAtlas (Direct3D 9)}}. 	
        /// </remarks>	
        /// <param name="pTextureIn"> Texture that corresponds to the original parameterization in pMeshIn. This texture will be used to create pTextureOut. </param>
        /// <param name="pMeshIn"> Mesh containing the original and new parameterizations. It is required to store the new parameterization in D3DDECLUSAGE_TEXCOORD index 0. </param>
        /// <param name="usage"> Vertex data usage (used in combination with UsageIndex) which identifies the component of the vertex declaration that contains the original parameterization in pMeshIn. See <see cref="SlimDX2.Direct3D9.Declusage"/>. </param>
        /// <param name="usageIndex"> Zero-based index (used in combination with Usage), which identifies the component of the vertex declaration that contains the original parameterization in pMeshIn. The combination of D3DDECLUSAGE_TEXCOORD and index 0 is required for the new parameterization; any other usage/index combination may be used. </param>
        /// <param name="pTextureOut"> Resampled texture. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ResampleTex([None] LPDIRECT3DTEXTURE9 pTextureIn,[None] LPD3DXMESH pMeshIn,[None] D3DDECLUSAGE Usage,[None] UINT UsageIndex,[None] LPDIRECT3DTEXTURE9 pTextureOut)</unmanaged>
        public SlimDX2.Result ResampleTex(SlimDX2.Direct3D9.Texture pTextureIn, SlimDX2.Direct3D9.Mesh pMeshIn, SlimDX2.Direct3D9.Declusage usage, int usageIndex, SlimDX2.Direct3D9.Texture pTextureOut) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, (void*)((pTextureIn == null)?IntPtr.Zero:pTextureIn.NativePointer), (void*)((pMeshIn == null)?IntPtr.Zero:pMeshIn.NativePointer), unchecked((int)usage), usageIndex, (void*)((pTextureOut == null)?IntPtr.Zero:pTextureOut.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the index of the mesh face to which each texel belongs.	
        /// </summary>	
        /// <remarks>	
        ///  The mesh face data returned by this method is valid only for valid (non-class 0) texels. <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetGutterMap"/> will return nonzero values for valid (non-class 0) texels. For {{class 2 texels}}, this method retrieves the closest face. The application must allocate and manage pFaceData. 	
        /// </remarks>	
        /// <param name="pFaceData"> Pointer to the index of the mesh face to which each texel belongs. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT GetFaceMap([Out] UINT* pFaceData)</unmanaged>
        internal SlimDX2.Result GetFaceMap(out int pFaceData) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pFaceData_ = &pFaceData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, pFaceData_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves texel barycentric coordinates.	
        /// </summary>	
        /// <remarks>	
        ///  The third barycentric coordinate is given by:  	
        /// <code> 1 - ( pBaryData.x + pBaryData.y ) </code>	
        /// 	
        ///  Barycentric coordinates are always specified with respect to the triangle returned by <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetFaceMap"/>. The barycentric coordinates returned by this method are valid only for valid (non-class 0) texels. <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetGutterMap"/> will return nonzero values for valid texels.  {{Class 2 texels}} are mapped to the nearest point on the triangle in texel space. The application must allocate and manage pBaryData. Barycentric coordinates define a point inside a triangle in terms of the triangle's vertices. For a more in-depth description of barycentric coordinates, see {{Mathworld's Barycentric Coordinates Description}}. 	
        /// </remarks>	
        /// <param name="pBaryData"> Pointer to a <see cref="SlimMath.Vector2"/> structure that contains the first two barycentric coordinates of each texel. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT GetBaryMap([Out] D3DXVECTOR2* pBaryData)</unmanaged>
        internal SlimDX2.Result GetBaryMap(out SlimMath.Vector2 pBaryData) {
            unsafe {
                pBaryData = new SlimMath.Vector2();
                SlimDX2.Result __result__;
                fixed (void* pBaryData_ = &pBaryData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, pBaryData_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the (u, v) texture coordinates of each texel.	
        /// </summary>	
        /// <remarks>	
        ///  For {{class 2 and 4 texels}}, the returned (u, v) texture coordinates correspond to the closest point on the closest triangle. The application must allocate and manage pTexelData. 	
        /// </remarks>	
        /// <param name="pTexelData"> Pointer to the location in pixel (u, v) texture coordinates where each texel is located. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT GetTexelMap([Out] D3DXVECTOR2* pTexelData)</unmanaged>
        internal SlimDX2.Result GetTexelMap(out SlimMath.Vector2 pTexelData) {
            unsafe {
                pTexelData = new SlimMath.Vector2();
                SlimDX2.Result __result__;
                fixed (void* pTexelData_ = &pTexelData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, pTexelData_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Receives a texel class value that indicates texel class according to each texel's location.	
        /// </summary>	
        /// <remarks>	
        ///  The application must allocate and manage pGutterData, with size given by: 	
        /// <code> texture width * texture height * sizeof(BYTE) </code>	
        /// 	
        ///  Texture width and height are returned by <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetWidth"/> and <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetHeight"/>. 	
        /// </remarks>	
        /// <param name="pGutterData"> Pointer to the texel class. Possible texel classes are as follows. There is no texel class 3.   Texel ClassTexel Location 0Invalid point; texel will not be used. 1Inside triangle. 2Inside gutter. 4Inside gutter; texel will be evaluated as a full sample in the <see cref="SlimDX2.Direct3D9.TextureGutterHelper.ApplyGuttersFloat"/>, <see cref="SlimDX2.Direct3D9.TextureGutterHelper.ApplyGuttersTex"/>, or <see cref="SlimDX2.Direct3D9.TextureGutterHelper.ApplyGuttersPRT"/> methods.    </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT GetGutterMap([Out] byte* pGutterData)</unmanaged>
        internal SlimDX2.Result GetGutterMap(out byte pGutterData) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pGutterData_ = &pGutterData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, pGutterData_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the index of the mesh face to which each texel belongs.	
        /// </summary>	
        /// <remarks>	
        ///  The mesh face data input to this method is valid only for valid (non-class 0) texels. <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetGutterMap"/> will return non-zero values for valid texels. 	
        /// </remarks>	
        /// <param name="pFaceData"> Pointer to the index of the mesh face to which each texel belongs. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT SetFaceMap([None] UINT* pFaceData)</unmanaged>
        internal SlimDX2.Result SetFaceMap(ref int pFaceData) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pFaceData_ = &pFaceData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, pFaceData_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets texel barycentric coordinates.	
        /// </summary>	
        /// <remarks>	
        ///  The third barycentric coordinate is given by:   	
        /// <code> 1 - ( pBaryData.x + pBaryData.y ) </code>	
        /// 	
        ///  The barycentric coordinates input to this method are valid only for valid (non-class 0) texels. <see cref="SlimDX2.Direct3D9.TextureGutterHelper.GetGutterMap"/> will return non-zero values for valid texels. Barycentric coordinates define a point inside a triangle in terms of the triangle's vertices.  For a more in-depth description of barycentric coordinates, see {{Mathworld's Barycentric Coordinates Description}}. 	
        /// </remarks>	
        /// <param name="pBaryData"> Pointer to a <see cref="SlimMath.Vector2"/> structure that contains the first two barycentric coordinates of each texel. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT SetBaryMap([None] D3DXVECTOR2* pBaryData)</unmanaged>
        internal SlimDX2.Result SetBaryMap(ref SlimMath.Vector2 pBaryData) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pBaryData_ = &pBaryData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, pBaryData_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the (u, v) texture coordinates of each texel.	
        /// </summary>	
        /// <param name="pTexelData"> Pointer to the location in pixel (u, v) texture coordinates where each texel is located. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT SetTexelMap([None] D3DXVECTOR2* pTexelData)</unmanaged>
        internal SlimDX2.Result SetTexelMap(ref SlimMath.Vector2 pTexelData) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pTexelData_ = &pTexelData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, pTexelData_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a texel class value that indicates texel class according to each texel's location.	
        /// </summary>	
        /// <param name="pGutterData"> Pointer to the texel class. Possible texel classes are as follows. There is no texel class 3.   Texel ClassTexel Location 0Invalid point; texel will not be used. 1Inside triangle. 2Inside gutter. 4Inside gutter; texel will be evaluated as a full sample in the <see cref="SlimDX2.Direct3D9.TextureGutterHelper.ApplyGuttersFloat"/>, <see cref="SlimDX2.Direct3D9.TextureGutterHelper.ApplyGuttersTex"/>, or <see cref="SlimDX2.Direct3D9.TextureGutterHelper.ApplyGuttersPRT"/> methods.    </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT SetGutterMap([None] byte* pGutterData)</unmanaged>
        internal SlimDX2.Result SetGutterMap(ref byte pGutterData) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pGutterData_ = &pGutterData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, (int)pGutterData);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXPRTEngine</unmanaged>
    [Guid("683a4278-cd5f-4d24-90ad-c4e1b6855d53")]
    public partial class PRTEngine : SlimDX2.ComObject {
        public PRTEngine(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Sets a normal vector for each texel in a texture object. This method is used to store vertex normal vectors from a mesh (or interpolated vertex normals if pixel-based precomputed radiance transfer (PRT) is being computed).	
        /// </summary>	
        /// <unmanaged>HRESULT SetPerTexelNormal([None] LPDIRECT3DTEXTURE9 pNormalTexture)</unmanaged>
        public SlimDX2.Direct3D9.Texture PerTexelNormal {
                set { SetPerTexelNormal(value); }
        }
        
        /// <summary>	
        /// Retrieves the number of vertices in the mesh, including any new vertices added as a result of adaptive spatial sampling.	
        /// </summary>	
        /// <unmanaged>UINT GetNumVerts()</unmanaged>
        public int NumVerts {
                get { return GetNumVerts(); }
        }
        
        /// <summary>	
        /// Retrieves the number of faces in the mesh, including any new faces added as a result of adaptive spatial sampling.	
        /// </summary>	
        /// <unmanaged>UINT GetNumFaces()</unmanaged>
        public int NumFaces {
                get { return GetNumFaces(); }
        }
        
        /// <summary>	
        /// Sets mesh material properties in the 3D scene. Use this method to specify subsurface scattering parameters.	
        /// </summary>	
        /// <param name="ppMaterials"> Address of a pointer to desired mesh material properties. See <see cref="SlimDX2.Direct3D9.Shmaterial"/>. </param>
        /// <param name="numMeshes"> Index of the mesh on which to set material properties. </param>
        /// <param name="numChannels"> Number of color channels to set in the mesh. Set to 1 to specify gray materials (R = G = B), or 3 to enable color bleeding effects. If you intend to change this parameter, first set the albedo using another method such as <see cref="SlimDX2.Direct3D9.PRTEngine.SetPerTexelAlbedo"/> or <see cref="SlimDX2.Direct3D9.PRTEngine.SetPerVertexAlbedo"/>. </param>
        /// <param name="bSetAlbedo"> If TRUE, sets the albedo of the mesh to ppMaterials, overwriting all existing texel and vertex albedo values. If FALSE, preserves all existing texel and vertex albedo values set by other methods; NumChannels must match the NumChannels parameter used to create the buffer in <see cref="SlimDX2.Direct3D9.D3DX9.CreatePRTBuffer"/> or <see cref="SlimDX2.Direct3D9.D3DX9.CreatePRTBufferTex"/>. </param>
        /// <param name="fLengthScale"> Scale of the 3D scene relative to a 1-mm cube. Used for subsurface scattering computations. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT SetMeshMaterials([None] const D3DXSHMATERIAL** ppMaterials,[None] UINT NumMeshes,[None] UINT NumChannels,[None] BOOL bSetAlbedo,[None] FLOAT fLengthScale)</unmanaged>
        public SlimDX2.Result SetMeshMaterials(ref SlimDX2.Direct3D9.Shmaterial ppMaterials, int numMeshes, int numChannels, bool bSetAlbedo, float fLengthScale) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* ppMaterials_ = &ppMaterials)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, ppMaterials_, numMeshes, numChannels, (bSetAlbedo?1:0), fLengthScale);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an albedo value for each mesh 	
        /// vertex, overwriting previous albedo values.	
        /// </summary>	
        /// <param name="pDataIn"> Pointer to FLOAT albedo data of the first sample. </param>
        /// <param name="numChannels"> Number of color channels to set. Set to 1 to specify gray materials (R = G = B), or 3 to enable color bleeding effects. </param>
        /// <param name="stride"> Stride in bytes needed to get to next sample's albedo value. See {{Width vs. Pitch (Direct3D 9)}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT SetPerVertexAlbedo([None] const VOID* pDataIn,[None] UINT NumChannels,[None] UINT Stride)</unmanaged>
        public SlimDX2.Result SetPerVertexAlbedo(IntPtr pDataIn, int numChannels, int stride) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)pDataIn, numChannels, stride);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an albedo value for each texel, overwriting previous albedo values.	
        /// </summary>	
        /// <param name="pAlbedoTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> texture object in which to store albedo values. </param>
        /// <param name="numChannels"> Number of color channels to set. Set to 1 to specify gray materials (R = G = B), or 3 to enable color bleeding effects. </param>
        /// <param name="pGH"> Optional pointer to an <see cref="SlimDX2.Direct3D9.TextureGutterHelper"/> object. If not provided, a texture gutter helper object is created and destroyed internally. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLED3DERR_OUTOFVIDEOMEMORY, D3DERR_WASSTILLDRAWING, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT SetPerTexelAlbedo([None] LPDIRECT3DTEXTURE9 pAlbedoTexture,[None] UINT NumChannels,[None] LPD3DXTEXTUREGUTTERHELPER pGH)</unmanaged>
        public SlimDX2.Result SetPerTexelAlbedo(SlimDX2.Direct3D9.Texture pAlbedoTexture, int numChannels, SlimDX2.Direct3D9.TextureGutterHelper pGH) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)((pAlbedoTexture == null)?IntPtr.Zero:pAlbedoTexture.NativePointer), numChannels, (void*)((pGH == null)?IntPtr.Zero:pGH.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves albedo values of the mesh vertices.	
        /// </summary>	
        /// <param name="pVertColors"> Pointer to a destination array of albedo values of the mesh vertices. See <see cref="SlimMath.Color4"/>. </param>
        /// <param name="numVerts"> Number of vertices in the mesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT GetVertexAlbedo([Out] D3DXCOLOR* pVertColors,[None] UINT NumVerts)</unmanaged>
        public SlimDX2.Result GetVertexAlbedo(out SlimMath.Color4 pVertColors, int numVerts) {
            unsafe {
                pVertColors = new SlimMath.Color4();
                SlimDX2.Result __result__;
                fixed (void* pVertColors_ = &pVertColors)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, pVertColors_, numVerts);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a normal vector for each texel in a texture object. This method is used to store vertex normal vectors from a mesh (or interpolated vertex normals if pixel-based precomputed radiance transfer (PRT) is being computed).	
        /// </summary>	
        /// <param name="pNormalTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> texture object that serves as an object space normal map in which to store normal vectors. The texture must have the same dimensions as <see cref="SlimDX2.Direct3D9.PRTBuffer"/> and must be able to store signed texture formats. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT SetPerTexelNormal([None] LPDIRECT3DTEXTURE9 pNormalTexture)</unmanaged>
        internal SlimDX2.Result SetPerTexelNormal(SlimDX2.Direct3D9.Texture pNormalTexture) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)((pNormalTexture == null)?IntPtr.Zero:pNormalTexture.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copies per-vertex albedo values from a mesh.	
        /// </summary>	
        /// <param name="pMesh"> Pointer to the <see cref="SlimDX2.Direct3D9.Mesh"/> mesh object used in <see cref="SlimDX2.Direct3D9.D3DX9.CreatePRTEngine"/> to create the <see cref="SlimDX2.Direct3D9.PRTEngine"/> object. </param>
        /// <param name="usage"> Vertex usage descriptions to copy from the mesh. See <see cref="SlimDX2.Direct3D9.Declusage"/>. </param>
        /// <param name="numChannels"> Number of color channels to copy from the mesh. Set to 1 to specify gray materials (R = G = B), or 3 to enable color bleeding effects. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ExtractPerVertexAlbedo([None] LPD3DXMESH pMesh,[None] D3DDECLUSAGE Usage,[None] UINT NumChannels)</unmanaged>
        public SlimDX2.Result ExtractPerVertexAlbedo(SlimDX2.Direct3D9.Mesh pMesh, SlimDX2.Direct3D9.Declusage usage, int numChannels) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, (void*)((pMesh == null)?IntPtr.Zero:pMesh.NativePointer), unchecked((int)usage), numChannels);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Resamples an input <see cref="SlimDX2.Direct3D9.PRTBuffer"/> buffer and saves it to an output buffer. This method can be used to convert a vertex buffer to a texture buffer and vice-versa. It can also be used to convert single-channel buffers to 3-channel buffers and vice-versa.	
        /// </summary>	
        /// <param name="pBufferIn"> Pointer to the input <see cref="SlimDX2.Direct3D9.PRTBuffer"/> buffer. </param>
        /// <param name="pBufferOut"> Pointer to the output <see cref="SlimDX2.Direct3D9.PRTBuffer"/> buffer. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ResampleBuffer([None] LPD3DXPRTBUFFER pBufferIn,[None] LPD3DXPRTBUFFER pBufferOut)</unmanaged>
        public SlimDX2.Result ResampleBuffer(SlimDX2.Direct3D9.PRTBuffer pBufferIn, SlimDX2.Direct3D9.PRTBuffer pBufferOut) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, (void*)((pBufferIn == null)?IntPtr.Zero:pBufferIn.NativePointer), (void*)((pBufferOut == null)?IntPtr.Zero:pBufferOut.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns a mesh with modifications resulting from adaptive spatial sampling. The returned mesh contains only positions, normals, and texture coordinates (if defined).	
        /// </summary>	
        /// <remarks>	
        ///  pVertRemap and pfVertWeights can be used to interpolate any per-vertex value over the mesh. 	
        /// </remarks>	
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> device that is used to create the output mesh. </param>
        /// <param name="pFaceRemap"> Pointer to the original mesh face that was split to generate the current face. </param>
        /// <param name="pVertRemap"> Pointer to a destination array containing the three original mesh vertices that are the parents of the current vertex. </param>
        /// <param name="pfVertWeights"> Pointer to a destination array containing blending factors for the pVertRemap vertices. </param>
        /// <param name="ppMesh"> Pointer to the output <see cref="SlimDX2.Direct3D9.Mesh"/> mesh object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned.D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT GetAdaptedMesh([None] LPDIRECT3DDEVICE9 pD3DDevice,[Out] UINT* pFaceRemap,[Out] UINT* pVertRemap,[Out] FLOAT* pfVertWeights,[Out] LPD3DXMESH* ppMesh)</unmanaged>
        public SlimDX2.Result GetAdaptedMesh(SlimDX2.Direct3D9.Device pD3DDevice, out int pFaceRemap, out int pVertRemap, out float pfVertWeights, out SlimDX2.Direct3D9.Mesh ppMesh) {
            unsafe {
                IntPtr ppMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* pFaceRemap_ = &pFaceRemap)
                    fixed (void* pVertRemap_ = &pVertRemap)
                        fixed (void* pfVertWeights_ = &pfVertWeights)
                            __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), pFaceRemap_, pVertRemap_, pfVertWeights_, &ppMesh_);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of vertices in the mesh, including any new vertices added as a result of adaptive spatial sampling.	
        /// </summary>	
        /// <returns>  {{UINT}}  Number of vertices in the mesh, including any new vertices added as a result of adaptive sampling. </returns>
        /// <unmanaged>UINT GetNumVerts()</unmanaged>
        internal int GetNumVerts() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of faces in the mesh, including any new faces added as a result of adaptive spatial sampling.	
        /// </summary>	
        /// <returns>  {{UINT}}  Number of faces in the mesh, including any new faces added as a result of adaptive sampling. </returns>
        /// <unmanaged>UINT GetNumFaces()</unmanaged>
        internal int GetNumFaces() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the minimum and maximum distances of intersection between 3D objects. These distance values can be used to control the minimum or maximum distance that objects can shadow or reflect light. For example, the method can be used to limit the shadowing of nearby features of a 3D model.	
        /// </summary>	
        /// <remarks>	
        ///  This method cannot be used in precomputed radiance transfer (PRT) simulations that run in the GPU. See <see cref="SlimDX2.Direct3D9.PRTEngine.ComputeDirectLightingSHGPU"/>. 	
        /// </remarks>	
        /// <param name="fMin"> Minimum intersection distance. Must be positive and less than fMax. </param>
        /// <param name="fMax"> Maximum intersection distance. If 0.0f, the previous value will be used; otherwise, must be greater than fMin.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT SetMinMaxIntersection([None] FLOAT fMin,[None] FLOAT fMax)</unmanaged>
        public SlimDX2.Result SetMinMaxIntersection(float fMin, float fMax) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, fMin, fMax);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Subdivides faces on a mesh, allowing for conservative adaptive sampling that will not eliminate features on the mesh.	
        /// </summary>	
        /// <param name="minEdgeLength"> Minimum face edge length that will be generated in adaptive sampling. If zero, a reasonable default value will be substituted. </param>
        /// <param name="maxSubdiv"> Maximum level of subdivision of a face that will be used in adaptive sampling. If zero, a default value of 5 will be substituted. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT RobustMeshRefine([None] FLOAT MinEdgeLength,[None] UINT MaxSubdiv)</unmanaged>
        public SlimDX2.Result RobustMeshRefine(float minEdgeLength, int maxSubdiv) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, minEdgeLength, maxSubdiv);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets sampling properties used by the precomputed radiance transfer (PRT) simulator.	
        /// </summary>	
        /// <param name="numRays"> Number of light rays to direct at each sample. Must be greater than zero. </param>
        /// <param name="useSphere"> If TRUE, samples will be computed over a full sphere. If FALSE, samples will be computed over a hemisphere. </param>
        /// <param name="useCosine"> If TRUE, use a cosine weighting of samples. If both UseCosine and UseSphere are TRUE, the method will fail and an error will be returned. </param>
        /// <param name="adaptive"> Must be FALSE. Adaptive sampling is currently not implemented. </param>
        /// <param name="adaptiveThresh"> Ignored. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_NOTIMPL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT SetSamplingInfo([None] UINT NumRays,[None] BOOL UseSphere,[None] BOOL UseCosine,[None] BOOL Adaptive,[None] FLOAT AdaptiveThresh)</unmanaged>
        public SlimDX2.Result SetSamplingInfo(int numRays, bool useSphere, bool useCosine, bool adaptive, float adaptiveThresh) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, numRays, (useSphere?1:0), (useCosine?1:0), (adaptive?1:0), adaptiveThresh);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Computes the direct lighting contribution to 3D objects where the source radiance is represented by a spherical harmonic (SH) approximation.	
        /// </summary>	
        /// <remarks>	
        ///  The output does not include albedo, and only incoming light is integrated in the simulator. By not multiplying the albedo, you can model albedo variation at a finer scale than the source radiance, thereby yielding more accurate results from compression. Call <see cref="SlimDX2.Direct3D9.PRTEngine.MultiplyAlbedo"/> to multiply each precomputed radiance transfer (PRT) vector by the albedo. 	
        /// </remarks>	
        /// <param name="sHOrder"> Order of the SH evaluation. Must be in the range of {{D3DXSH_MINORDER}} to D3DXSH_MAXORDER, inclusive. The evaluation generates Order2 coefficients. The degree of the evaluation is Order - 1. </param>
        /// <param name="pDataOut"> Pointer to an output <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that models the direct lighting contribution with the SH approximation. This buffer must have the proper number of color channels allocated for the simulation. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ComputeDirectLightingSH([None] UINT SHOrder,[None] LPD3DXPRTBUFFER pDataOut)</unmanaged>
        public SlimDX2.Result ComputeDirectLightingSH(int sHOrder, SlimDX2.Direct3D9.PRTBuffer pDataOut) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, sHOrder, (void*)((pDataOut == null)?IntPtr.Zero:pDataOut.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Computes the direct lighting contribution to 3D objects where the source radiance is represented by a spherical harmonic (SH) approximation, using adaptive sampling. This method generates new vertices and faces on the mesh to more accurately approximate the precomputed radiance transfer (PRT) signal.	
        /// </summary>	
        /// <param name="sHOrder"> Order of the SH evaluation. Must be in the range of {{D3DXSH_MINORDER}} to D3DXSH_MAXORDER, inclusive. The evaluation generates Order2 coefficients. The degree of the evaluation is Order - 1. </param>
        /// <param name="adaptiveThresh"> Threshold on the PRT vector to use for subdividing mesh vertices and faces. If less than 1e-6f, a default value of 1e-6f is specified. </param>
        /// <param name="minEdgeLength"> Minimum face edge length that will be generated in adaptive sampling. If the method determines that the value is too small, a model-dependent value is specified. If zero, a default value of 4 is specified. </param>
        /// <param name="maxSubdiv"> Maximum level of subdivision of a face that will be used in adaptive sampling. </param>
        /// <param name="pDataOut"> Pointer to an output <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object. This buffer must have the proper number of color channels allocated for the simulation. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ComputeDirectLightingSHAdaptive([None] UINT SHOrder,[None] FLOAT AdaptiveThresh,[None] FLOAT MinEdgeLength,[None] UINT MaxSubdiv,[None] LPD3DXPRTBUFFER pDataOut)</unmanaged>
        public SlimDX2.Result ComputeDirectLightingSHAdaptive(int sHOrder, float adaptiveThresh, float minEdgeLength, int maxSubdiv, SlimDX2.Direct3D9.PRTBuffer pDataOut) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, sHOrder, adaptiveThresh, minEdgeLength, maxSubdiv, (void*)((pDataOut == null)?IntPtr.Zero:pDataOut.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Uses the GPU to compute the direct lighting contribution to 3D objects where the source radiance is represented by a spherical harmonic (SH) approximation. Computing the lighting on the GPU will generally be much faster than on the CPU.	
        /// </summary>	
        /// <remarks>	
        ///  In this method, the albedo is not multiplied by the light signal, and only incoming light is integrated in the simulator. By not multiplying the albedo, you can model albedo variation at a finer scale than the source radiance, thereby yielding more accurate results from compression. Call {{MultiplyAlbedo}} to multiply each precomputed radiance transfer (PRT) vector by the albedo. 	
        /// </remarks>	
        /// <param name="pD3DDevice"> Pointer to the <see cref="SlimDX2.Direct3D9.Device"/> device object used to run the simulation on the GPU. The device must support {{ps_2_0}} pixel shaders.   Note Callback functions should not use the <see cref="SlimDX2.Direct3D9.Device"/> device object used by the GPU simulator. </param>
        /// <param name="flags"> GPU simulation parameter that defines the resolution of the shadow z-buffer. Should be set to one of the constant values from <see cref="SlimDX2.Direct3D9.Shgpusimopt"/>. To specifiy higher precision simulation, the D3DXSHGPUSIMOPT_HIGHQUALITY value may be combined with one of the D3DXSHGPUSIMOPT_SHADOWRESxxx values. </param>
        /// <param name="sHOrder"> Order of the SH evaluation. Must be in the range of {{D3DXSH_MINORDER}} to D3DXSH_MAXORDER, inclusive. The evaluation generates Order2 coefficients. The degree of the evaluation is Order - 1. </param>
        /// <param name="zBias"> Bias in the normal direction. </param>
        /// <param name="zAngleBias"> Bias in the normal direction, scaled by one minus the cosine of the angle with the light ray. </param>
        /// <param name="pDataOut"> Pointer to an <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object. This buffer must have the proper number of color channels allocated for the simulation. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ComputeDirectLightingSHGPU([None] LPDIRECT3DDEVICE9 pD3DDevice,[None] UINT Flags,[None] UINT SHOrder,[None] FLOAT ZBias,[None] FLOAT ZAngleBias,[None] LPD3DXPRTBUFFER pDataOut)</unmanaged>
        public SlimDX2.Result ComputeDirectLightingSHGPU(SlimDX2.Direct3D9.Device pD3DDevice, int flags, int sHOrder, float zBias, float zAngleBias, SlimDX2.Direct3D9.PRTBuffer pDataOut) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, (void*)((pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer), flags, sHOrder, zBias, zAngleBias, (void*)((pDataOut == null)?IntPtr.Zero:pDataOut.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Computes the source radiance resulting from subsurface scattering, using material properties set by <see cref="SlimDX2.Direct3D9.PRTEngine.SetMeshMaterials"/>. This method can be used only for materials defined per-vertex in a mesh object.	
        /// </summary>	
        /// <remarks>	
        ///  To model subsurface scattering, call this method for each light bounce after an ID3DXPRTEngine::ComputeDirectLighting method is called. Use the following calling sequence to model subsurface scattering. 	
        /// <code> LPD3DXPRTBUFFER pDataA, pDataB, pDataC; // initialization	
        /// ID3DXPRTEngine* m_pPRTEngine; hr = m_pPRTEngine-&gt;ComputeDirectLightingSH( SHOrder, pDataA ); // *pDataC should be set to zero. The ComputeSS call will add together the    	
        /// // direct lighting results from pDataA for non-subsurface scattering elements   	
        /// // and subsurface scattering results for the subsurface scattering elements. hr = m_pPRTEngine-&gt;ComputeSS( pDataA, pDataB, pDataC );	
        /// if ( FAILED( hr ) ) goto Exit; </code>	
        /// 	
        ///  The output of this method does not include albedo, and only incoming light is integrated in the simulator. By not multiplying the albedo, you can model albedo variation at a finer scale than the source radiance, thereby yielding more accurate results from compression. Call <see cref="SlimDX2.Direct3D9.PRTEngine.MultiplyAlbedo"/> to multiply each precomputed radiance transfer (PRT) vector by the albedo. 	
        /// </remarks>	
        /// <param name="pDataIn"> Pointer to an input <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that represents the 3D object from the previous light bounce. This input buffer must have the proper number of color channels allocated for the simulation. </param>
        /// <param name="pDataOut"> Pointer to an output <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that models a single bounce of the subsurface-scattered light. This output buffer must have the proper number of color channels allocated for the simulation. </param>
        /// <param name="pDataTotal"> Pointer to an optional <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that is the running sum of all previous pDataOut outputs. May be NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ComputeSS([None] LPD3DXPRTBUFFER pDataIn,[None] LPD3DXPRTBUFFER pDataOut,[None] LPD3DXPRTBUFFER pDataTotal)</unmanaged>
        public SlimDX2.Result ComputeSS(SlimDX2.Direct3D9.PRTBuffer pDataIn, SlimDX2.Direct3D9.PRTBuffer pDataOut, SlimDX2.Direct3D9.PRTBuffer pDataTotal) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, (void*)((pDataIn == null)?IntPtr.Zero:pDataIn.NativePointer), (void*)((pDataOut == null)?IntPtr.Zero:pDataOut.NativePointer), (void*)((pDataTotal == null)?IntPtr.Zero:pDataTotal.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Computes a transfer vector that maps source radiance to exit radiance resulting from subsurface scattering, using adaptive sampling and material properties set by <see cref="SlimDX2.Direct3D9.PRTEngine.SetMeshMaterials"/>. The method generates new vertices and faces on the mesh to more accurately approximate the precomputed radiance transfer (PRT) signal. This method can be used only for materials defined per-vertex in a mesh object.	
        /// </summary>	
        /// <remarks>	
        ///  To model subsurface scattering, call this method for each light bounce after an <see cref="SlimDX2.Direct3D9.PRTEngine.ComputeDirectLightingSHAdaptive"/> method is called. The output of this method does not include albedo, and only incoming light is integrated in the simulator. By not multiplying the albedo, you can model albedo variation at a finer scale than the source radiance, thereby yielding more accurate results from compression. Call <see cref="SlimDX2.Direct3D9.PRTEngine.MultiplyAlbedo"/> to multiply each PRT vector by the albedo. 	
        /// </remarks>	
        /// <param name="pDataIn"> Pointer to an input <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that represents the 3D object from the previous light bounce. This input buffer must have the proper number of color channels allocated for the simulation. </param>
        /// <param name="adaptiveThresh"> Threshold on the PRT vector to use for subdividing mesh vertices and faces. If less than 1e-6f, a default value of 1e-6f is specified. </param>
        /// <param name="minEdgeLength"> Minimum face edge length that will be generated in adaptive sampling. If the method determines that the value is too small, a model-dependent value is specified. </param>
        /// <param name="maxSubdiv"> Maximum level of subdivision of a face that will be used in adaptive sampling. If zero, a default value of 4 is specified. </param>
        /// <param name="pDataOut"> Pointer to an output <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that models a single bounce of the subsurface-scattered light. This output buffer must have the proper number of color channels allocated for the simulation. </param>
        /// <param name="pDataTotal"> Pointer to an optional <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that is the running sum of all previous pDataOut outputs. May be NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ComputeSSAdaptive([None] LPD3DXPRTBUFFER pDataIn,[None] FLOAT AdaptiveThresh,[None] FLOAT MinEdgeLength,[None] UINT MaxSubdiv,[None] LPD3DXPRTBUFFER pDataOut,[None] LPD3DXPRTBUFFER pDataTotal)</unmanaged>
        public SlimDX2.Result ComputeSSAdaptive(SlimDX2.Direct3D9.PRTBuffer pDataIn, float adaptiveThresh, float minEdgeLength, int maxSubdiv, SlimDX2.Direct3D9.PRTBuffer pDataOut, SlimDX2.Direct3D9.PRTBuffer pDataTotal) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, (void*)((pDataIn == null)?IntPtr.Zero:pDataIn.NativePointer), adaptiveThresh, minEdgeLength, maxSubdiv, (void*)((pDataOut == null)?IntPtr.Zero:pDataOut.NativePointer), (void*)((pDataTotal == null)?IntPtr.Zero:pDataTotal.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Computes the source radiance resulting from a single bounce of interreflected light. This method can be used for any lit scene, including a spherical harmonic (SH)-based precomputed radiance transfer (PRT) model.	
        /// </summary>	
        /// <remarks>	
        ///  Use the following calling sequence to model multiple light bounces with direct lighting. 	
        /// <code> LPD3DXPRTBUFFER pDataA, pDataB, pDataC; // initialization	
        /// ID3DXPRTEngine* m_pPRTEngine; ComputeDirectLightingSH( SHOrder, pDataA );	
        /// // The accumulation buffer, pDataC, needs to be 	
        /// // initialized to the direct lighting result. pDataC-&gt;AddBuffer( pDataA );	
        /// hr = m_pPRTEngine-&gt;ComputeBounce( pDataA, pDataB, pDataC ); // first bounce	
        /// hr = m_pPRTEngine-&gt;ComputeBounce( pDataB, pDataA, pDataC ); // second bounce	
        /// hr = m_pPRTEngine-&gt;ComputeBounce( pDataA, pDataB, pDataC ); // third bounce	
        /// hr = m_pPRTEngine-&gt;ComputeBounce( pDataB, pDataA, pDataC ); // fourth bounce </code>	
        /// 	
        ///  Use the following calling sequence to model multiple light bounces with subsurface scattering. 	
        /// <code> LPD3DXPRTBUFFER pDataA, pDataB, pDataC; // initialization	
        /// ID3DXPRTEngine* m_pPRTEngine;	
        /// ComputeDirectLightingSH( SHOrder, pDataA ); // *pDataC should be set to zero. The ComputeSS call will add together     	
        /// // the direct lighting results from pDataA for non-subsurface scattering 	
        /// // elements and subsurface scattering results for the subsurface scattering	
        /// // elements. Perform proper error handling for each call. hr = m_pPRTEngine-&gt;ComputeSS    ( pDataA, pDataB, pDataC );	
        /// hr = m_pPRTEngine-&gt;ComputeBounce( pDataB, pDataA, NULL   ); // first bounce	
        /// hr = m_pPRTEngine-&gt;ComputeSS    ( pDataA, pDataB, pDataC );	
        /// hr = m_pPRTEngine-&gt;ComputeBounce( pDataB, pDataA, NULL   ); // second bounce	
        /// hr = m_pPRTEngine-&gt;ComputeSS    ( pDataA, pDataB, pDataC ); </code>	
        /// 	
        ///  The output of this method does not include albedo, and only incoming light is integrated in the simulator. By not multiplying the albedo, you can model albedo variation at a finer scale than the source radiance, thereby yielding more accurate results from compression. Call <see cref="SlimDX2.Direct3D9.PRTEngine.MultiplyAlbedo"/> to multiply each PRT vector by the albedo. 	
        /// </remarks>	
        /// <param name="pDataIn"> Pointer to an input <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that represents the 3D object from the previous light bounce. This input buffer must have the proper number of color channels allocated for the simulation. </param>
        /// <param name="pDataOut"> Pointer to an output <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that models a single bounce of the interreflected light. This output buffer must have the proper number of color channels allocated for the simulation. </param>
        /// <param name="pDataTotal"> Pointer to an optional <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that is the running sum of all previous pDataOut outputs. May be NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ComputeBounce([None] LPD3DXPRTBUFFER pDataIn,[None] LPD3DXPRTBUFFER pDataOut,[None] LPD3DXPRTBUFFER pDataTotal)</unmanaged>
        public SlimDX2.Result ComputeBounce(SlimDX2.Direct3D9.PRTBuffer pDataIn, SlimDX2.Direct3D9.PRTBuffer pDataOut, SlimDX2.Direct3D9.PRTBuffer pDataTotal) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, (void*)((pDataIn == null)?IntPtr.Zero:pDataIn.NativePointer), (void*)((pDataOut == null)?IntPtr.Zero:pDataOut.NativePointer), (void*)((pDataTotal == null)?IntPtr.Zero:pDataTotal.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Computes the source radiance resulting from a single bounce of interreflected light, using adaptive sampling. This method generates new vertices and faces on the mesh to more accurately approximate the precomputed radiance transfer (PRT) signal. This method can be used for any lit scene, including a spherical harmonic (SH)-based PRT model.	
        /// </summary>	
        /// <param name="pDataIn"> Pointer to an input <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that represents the 3D object from the previous light bounce. This input buffer must have the proper number of color channels allocated for the simulation. </param>
        /// <param name="adaptiveThresh"> Threshold on the PRT vector to use for subdividing mesh vertices and faces. If less than 1e-6f, a default value of 1e-6f is specified. </param>
        /// <param name="minEdgeLength"> Minimum face edge length that will be generated in adaptive sampling. If the method determines that the value is too small, a model-dependent value is specified. If zero, a default value of 4 is specified. </param>
        /// <param name="maxSubdiv"> Maximum level of subdivision of a face that will be used in adaptive sampling. </param>
        /// <param name="pDataOut"> Pointer to an output <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object. This output buffer must have the proper number of color channels allocated for the simulation. </param>
        /// <param name="pDataTotal"> Pointer to an optional <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that keeps a running sum of pDataOut with each light bounce computation. May be NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ComputeBounceAdaptive([None] LPD3DXPRTBUFFER pDataIn,[None] FLOAT AdaptiveThresh,[None] FLOAT MinEdgeLength,[None] UINT MaxSubdiv,[None] LPD3DXPRTBUFFER pDataOut,[None] LPD3DXPRTBUFFER pDataTotal)</unmanaged>
        public SlimDX2.Result ComputeBounceAdaptive(SlimDX2.Direct3D9.PRTBuffer pDataIn, float adaptiveThresh, float minEdgeLength, int maxSubdiv, SlimDX2.Direct3D9.PRTBuffer pDataOut, SlimDX2.Direct3D9.PRTBuffer pDataTotal) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 22 * 4, (void*)((pDataIn == null)?IntPtr.Zero:pDataIn.NativePointer), adaptiveThresh, minEdgeLength, maxSubdiv, (void*)((pDataOut == null)?IntPtr.Zero:pDataOut.NativePointer), (void*)((pDataTotal == null)?IntPtr.Zero:pDataTotal.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Computes a projection of distant lighting into spherical harmonic (SH) basis vectors that represent incident radiance at specified locations.	
        /// </summary>	
        /// <remarks>	
        ///  This method computes how light from a distant source arrives at each point in space specified by pSampleLocs. The SH coefficients represent the mapping, at each pSampleLocs point, of source radiance to transferred incident radiance. To use this method successfully, you must set sampling over a sphere with UseSphere = TRUE and UseCosine = FALSE in <see cref="SlimDX2.Direct3D9.PRTEngine.SetSamplingInfo"/>; otherwise, this method will return an error with D3DERR_INVALIDCALL. 	
        /// </remarks>	
        /// <param name="sHOrderIn"> Order of the SH representation of distant lighting. Must be in the range of {{D3DXSH_MINORDER}} to D3DXSH_MAXORDER, inclusive. The degree of the evaluation is OrderIn - 1. </param>
        /// <param name="sHOrderOut"> Order of the SH representation of local lighting. Must be in the range of {{D3DXSH_MINORDER}} to D3DXSH_MAXORDER, inclusive. The degree of the evaluation is OrderOut - 1. </param>
        /// <param name="numVolSamples"> Number of sample locations. </param>
        /// <param name="pSampleLocs"> Position for each sample. </param>
        /// <param name="pDataOut"> Pointer to an output <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that projects the distant lighting into SH basis vectors. This buffer must have the proper number of color channels allocated for the simulation. This method generates OrderIn2 * OrderOut"2 scalars per channel at each sample location. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ComputeVolumeSamplesDirectSH([None] UINT SHOrderIn,[None] UINT SHOrderOut,[None] UINT NumVolSamples,[None] const D3DXVECTOR3* pSampleLocs,[None] LPD3DXPRTBUFFER pDataOut)</unmanaged>
        public SlimDX2.Result ComputeVolumeSamplesDirectSH(int sHOrderIn, int sHOrderOut, int numVolSamples, ref SlimMath.Vector3 pSampleLocs, SlimDX2.Direct3D9.PRTBuffer pDataOut) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pSampleLocs_ = &pSampleLocs)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, sHOrderIn, sHOrderOut, numVolSamples, pSampleLocs_, (void*)((pDataOut == null)?IntPtr.Zero:pDataOut.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Computes a projection of the direct lighting from the previous light bounce into spherical harmonic (SH) basis vectors that represent incident radiance at specified locations.	
        /// </summary>	
        /// <remarks>	
        ///  This method computes how the light from the source radiance function is reflected off the surface that represents the scene (pSurfDataIn) and arrives at each point in space specified by pSampleLocs. The SH coefficients represent the mapping, at each pSampleLocs point, of source radiance to transferred incident radiance. 	
        /// </remarks>	
        /// <param name="pSurfDataIn"> Pointer to an input <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that represents the 3D object from the previous light bounce. </param>
        /// <param name="sHOrder"> Order of the SH evaluation. Must be in the range of {{D3DXSH_MINORDER}} to D3DXSH_MAXORDER, inclusive. The evaluation generates Order2 coefficients. The degree of the evaluation is Order - 1. </param>
        /// <param name="numVolSamples"> Number of sample locations. </param>
        /// <param name="pSampleLocs"> Position for each sample. If pSampleLocs is NULL, ComputeVolumeSamples will compute transfer matrices at every mesh vertex.  However, if pSampleLocs is not NULL, you must sample over a sphere (set UseSphere = TRUE and UseCosine = FALSE in <see cref="SlimDX2.Direct3D9.PRTEngine.SetSamplingInfo"/>); otherwise, ComputeVolumeSamples will return  D3DERR_INVALIDCALL. </param>
        /// <param name="pDataOut"> Pointer to an output <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that projects the direct lighting from the previous light bounce into SH basis vectors. This buffer must have the proper number of color channels allocated for the simulation. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ComputeVolumeSamples([None] LPD3DXPRTBUFFER pSurfDataIn,[None] UINT SHOrder,[None] UINT NumVolSamples,[None] const D3DXVECTOR3* pSampleLocs,[None] LPD3DXPRTBUFFER pDataOut)</unmanaged>
        public SlimDX2.Result ComputeVolumeSamples(SlimDX2.Direct3D9.PRTBuffer pSurfDataIn, int sHOrder, int numVolSamples, ref SlimMath.Vector3 pSampleLocs, SlimDX2.Direct3D9.PRTBuffer pDataOut) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pSampleLocs_ = &pSampleLocs)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, (void*)((pSurfDataIn == null)?IntPtr.Zero:pSurfDataIn.NativePointer), sHOrder, numVolSamples, pSampleLocs_, (void*)((pDataOut == null)?IntPtr.Zero:pDataOut.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Computes, at an arbitrary point not on a mesh, a transfer vector that maps source radiance (represented by a spherical harmonic (SH) approximation) to exit radiance.	
        /// </summary>	
        /// <remarks>	
        ///  Do not use a texture buffer when calling this method. 	
        /// </remarks>	
        /// <param name="sHOrder"> Order of the SH approximation to use. </param>
        /// <param name="numSamples"> Number of sample locations. </param>
        /// <param name="pSampleLocs"> Position for each sample. </param>
        /// <param name="pSampleNorms"> Normal vector for each sample location. </param>
        /// <param name="pDataOut"> Pointer to an output <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that models the direct lighting contribution to the point, using the SH approximation. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ComputeSurfSamplesDirectSH([None] UINT SHOrder,[None] UINT NumSamples,[None] const D3DXVECTOR3* pSampleLocs,[None] const D3DXVECTOR3* pSampleNorms,[None] LPD3DXPRTBUFFER pDataOut)</unmanaged>
        public SlimDX2.Result ComputeSurfSamplesDirectSH(int sHOrder, int numSamples, ref SlimMath.Vector3 pSampleLocs, ref SlimMath.Vector3 pSampleNorms, SlimDX2.Direct3D9.PRTBuffer pDataOut) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pSampleLocs_ = &pSampleLocs)
                    fixed (void* pSampleNorms_ = &pSampleNorms)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4, sHOrder, numSamples, pSampleLocs_, pSampleNorms_, (void*)((pDataOut == null)?IntPtr.Zero:pDataOut.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Computes precomputed radiance transfer (PRT) samples for an arbitrary point (and normal vector).	
        /// </summary>	
        /// <param name="pSurfDataIn"> Pointer to an input <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that represents the source radiance of the 3D object. This input buffer must have the proper number of color channels allocated for the simulation. </param>
        /// <param name="numSamples"> Number of sample locations. </param>
        /// <param name="pSampleLocs"> Position for each sample. </param>
        /// <param name="pSampleNorms"> Normal vector for each sample location. </param>
        /// <param name="pDataOut"> Pointer to an output <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that models the direct lighting contribution to the point, using the spherical harmonic (SH) approximation. </param>
        /// <param name="pDataTotal"> Pointer to an optional <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that is the running sum of all previous pDataOut outputs. May be NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ComputeSurfSamplesBounce([None] LPD3DXPRTBUFFER pSurfDataIn,[None] UINT NumSamples,[None] const D3DXVECTOR3* pSampleLocs,[None] const D3DXVECTOR3* pSampleNorms,[None] LPD3DXPRTBUFFER pDataOut,[None] LPD3DXPRTBUFFER pDataTotal)</unmanaged>
        public SlimDX2.Result ComputeSurfSamplesBounce(SlimDX2.Direct3D9.PRTBuffer pSurfDataIn, int numSamples, ref SlimMath.Vector3 pSampleLocs, ref SlimMath.Vector3 pSampleNorms, SlimDX2.Direct3D9.PRTBuffer pDataOut, SlimDX2.Direct3D9.PRTBuffer pDataTotal) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pSampleLocs_ = &pSampleLocs)
                    fixed (void* pSampleNorms_ = &pSampleNorms)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 26 * 4, (void*)((pSurfDataIn == null)?IntPtr.Zero:pSurfDataIn.NativePointer), numSamples, pSampleLocs_, pSampleNorms_, (void*)((pDataOut == null)?IntPtr.Zero:pDataOut.NativePointer), (void*)((pDataTotal == null)?IntPtr.Zero:pDataTotal.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Frees memory used for temporary subsurface light scattering simulation data.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  The return value is D3D_OK. </returns>
        /// <unmanaged>HRESULT FreeSSData()</unmanaged>
        public SlimDX2.Result FreeSSData() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 27 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Frees memory used for temporary bounced-light simulation data.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  The return value is S_OK. </returns>
        /// <unmanaged>HRESULT FreeBounceData()</unmanaged>
        public SlimDX2.Result FreeBounceData() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 28 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Computes locally-deformable precomputed radiance transfer (LDPRT) coefficients relative to per-sample normal vectors to minimize the least-squares error with respect to input <see cref="SlimDX2.Direct3D9.PRTBuffer"/> data. These coefficients can be used with skinned or transformed normal vectors to model global effects on dynamic objects.	
        /// </summary>	
        /// <remarks>	
        ///  Solutions for shading normal vectors can optionally be obtained with this method. These normal vectors, along with the LDPRT coefficients, can more accurately represent the PRT signal. In this case, the coefficients represent zonal harmonics oriented in the normal direction. This method cannot be used with results from <see cref="SlimDX2.Direct3D9.PRTEngine.ComputeSurfSamplesBounce"/> or <see cref="SlimDX2.Direct3D9.PRTEngine.ComputeSurfSamplesDirectSH"/>. 	
        /// </remarks>	
        /// <param name="pDataIn"> Pointer to an input <see cref="SlimDX2.Direct3D9.PRTBuffer"/> spherical harmonic (SH) precomputed radiance transfer (PRT) data object. </param>
        /// <param name="sHOrder"> Order of the SH evaluation. Must be in the range of {{D3DXSH_MINORDER}} to D3DXSH_MAXORDER, inclusive. The evaluation generates Order2 coefficients. The degree of the evaluation is Order - 1. </param>
        /// <param name="pNormOut"> Optional vector array to be filled with shader-optimal normal vectors for which LDPRT coefficients are optimized. This array must be the same size as the number of samples in pDataIn. If NULL, surface normal vectors are used. </param>
        /// <param name="pDataOut"> Pointer to an output <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that contains Order zonal harmonic coefficients per color channel per sample. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ComputeLDPRTCoeffs([None] LPD3DXPRTBUFFER pDataIn,[None] UINT SHOrder,[None] D3DXVECTOR3* pNormOut,[None] LPD3DXPRTBUFFER pDataOut)</unmanaged>
        public SlimDX2.Result ComputeLDPRTCoeffs(SlimDX2.Direct3D9.PRTBuffer pDataIn, int sHOrder, ref SlimMath.Vector3 pNormOut, SlimDX2.Direct3D9.PRTBuffer pDataOut) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pNormOut_ = &pNormOut)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 29 * 4, (void*)((pDataIn == null)?IntPtr.Zero:pDataIn.NativePointer), sHOrder, pNormOut_, (void*)((pDataOut == null)?IntPtr.Zero:pDataOut.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Scales all the samples associated with a given submesh. The method is useful for computing subsurface scattering.	
        /// </summary>	
        /// <param name="uMeshChunk"> Location in the mesh at which to start scaling samples. </param>
        /// <param name="fScale"> Value by which to multiply each vector in the submesh. </param>
        /// <param name="pDataOut"> Pointer to a <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object to receive rescaled samples in the submesh. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT ScaleMeshChunk([None] UINT uMeshChunk,[None] FLOAT fScale,[None] LPD3DXPRTBUFFER pDataOut)</unmanaged>
        public SlimDX2.Result ScaleMeshChunk(int uMeshChunk, float fScale, SlimDX2.Direct3D9.PRTBuffer pDataOut) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 30 * 4, uMeshChunk, fScale, (void*)((pDataOut == null)?IntPtr.Zero:pDataOut.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Multiplies each precomputed radiance transfer (PRT) vector by the per-vertex albedo.	
        /// </summary>	
        /// <remarks>	
        ///  The ID3DXPRTEngine::Computexxx methods compute output buffers in which the light signal has not been multiplied by albedo. By not multiplying the albedo, you can model albedo variation at a finer scale than the source radiance, thereby yielding more accurate results from compression. To include albedo in the rendered-light model, call this method after one of the Computexxx methods.  <see cref="SlimDX2.Direct3D9.PRTEngine.SetMeshMaterials"/> should be called before calling this method. 	
        /// </remarks>	
        /// <param name="pDataOut"> Pointer to an output <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that will contain PRT vectors multiplied by the per-vertex albedo. If this output buffer is a texture object, then care must be taken to store the albedo of the texture at the same resolution as the simulation buffer. You can set the proper resolution on the albedo with <see cref="SlimDX2.Direct3D9.D3DX9.LoadSurfaceFromSurface"/>, applying texture gutter regions if appropriate. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT MultiplyAlbedo([None] LPD3DXPRTBUFFER pDataOut)</unmanaged>
        public SlimDX2.Result MultiplyAlbedo(SlimDX2.Direct3D9.PRTBuffer pDataOut) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 31 * 4, (void*)((pDataOut == null)?IntPtr.Zero:pDataOut.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a pointer to an optional callback function that computes the percentage of spherical harmonic (SH) computations completed and gives the caller the option of aborting the simulator.	
        /// </summary>	
        /// <param name="pCB"> Pointer to the <see cref="IntPtr"/> callback function that computes the percentage of SH computations completed. The callback function must be implemented to return S_OK to keep running the simulator. Any other value will abort the simulator. </param>
        /// <param name="frequency"> Frequency of callback calls. The inverse of Frequency is approximately the number of times the callback function will be called. </param>
        /// <param name="lpUserContext"> Pointer to a user-defined value which is passed to the callback function. Typically used by an application to pass a pointer to a data structure that provides context information for the callback function. </param>
        /// <returns>  <see cref="int"/>  The return value is S_OK. </returns>
        /// <unmanaged>HRESULT SetCallBack([None] LPD3DXSHPRTSIMCB pCB,[None] FLOAT Frequency,[None] void* lpUserContext)</unmanaged>
        public SlimDX2.Result SetCallBack(IntPtr pCB, float frequency, IntPtr lpUserContext) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 32 * 4, (void*)pCB, frequency, (void*)lpUserContext);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Uses efficient ray-tracing in precomputed radiance transfer (PRT) simulations to determine whether a ray intersects a mesh. Typically used to determine whether a given point is in shadow.	
        /// </summary>	
        /// <remarks>	
        ///  Use <see cref="SlimDX2.Direct3D9.PRTEngine.SetMinMaxIntersection"/> to set minimum and maximum distances of intersection with the ray. This method executes faster than <see cref="SlimDX2.Direct3D9.PRTEngine.ClosestRayIntersects"/>. 	
        /// </remarks>	
        /// <param name="pRayPos"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the point where the ray begins. </param>
        /// <param name="pRayDir"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the normalized direction of the ray. </param>
        /// <returns>  {{BOOL}}  Returns TRUE if the ray intersects the current mesh; otherwise, returns FALSE. </returns>
        /// <unmanaged>BOOL ShadowRayIntersects([None] const D3DXVECTOR3* pRayPos,[None] const D3DXVECTOR3* pRayDir)</unmanaged>
        public bool ShadowRayIntersects(ref SlimMath.Vector3 pRayPos, ref SlimMath.Vector3 pRayDir) {
            unsafe {
                bool __result__;
                fixed (void* pRayPos_ = &pRayPos)
                    fixed (void* pRayDir_ = &pRayDir)
                        __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 33 * 4, pRayPos_, pRayDir_));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Uses efficient ray-tracing in precomputed radiance transfer (PRT) simulations to determine whether a ray intersects a mesh. If an intersection is found, the method returns the index of the closest mesh face hit by the ray and the barycentric coordinates of the intersection point.	
        /// </summary>	
        /// <remarks>	
        ///  Use <see cref="SlimDX2.Direct3D9.PRTEngine.SetMinMaxIntersection"/> to set minimum and maximum distances of intersection with the ray. The barycentric coordinate of the third vertex (vertex 2) of the triangle is 1 - ( U + V ). This method executes slower than <see cref="SlimDX2.Direct3D9.PRTEngine.ShadowRayIntersects"/>. Use ID3DXPRTEngine::ShadowRayIntersects if the location of the intersection point is not needed. Barycentric coordinates define a point inside a triangle in terms of the triangle's vertices.  For a more in-depth description of barycentric coordinates, see {{Mathworld's Barycentric Coordinates Description}}. 	
        /// </remarks>	
        /// <param name="pRayPos"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the point where the ray begins. </param>
        /// <param name="pRayDir"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the normalized direction of the ray. </param>
        /// <param name="pFaceIndex"> Pointer to the index of the current mesh face that is first hit by the given ray, based upon stacking all blocker mesh faces in front of the current mesh. </param>
        /// <param name="pU"> Pointer to a barycentric hit coordinate, U, for vertex 0 of the triangle. </param>
        /// <param name="pV"> Pointer to a barycentric hit coordinate, V, for vertex 1 of the triangle. </param>
        /// <param name="pDist"> Pointer to the distance of the intersection point along the ray. </param>
        /// <returns>  {{BOOL}}  Returns TRUE if the ray intersects the current mesh; otherwise, returns FALSE. </returns>
        /// <unmanaged>BOOL ClosestRayIntersects([None] const D3DXVECTOR3* pRayPos,[None] const D3DXVECTOR3* pRayDir,[None] int* pFaceIndex,[None] FLOAT* pU,[None] FLOAT* pV,[None] FLOAT* pDist)</unmanaged>
        public bool ClosestRayIntersects(ref SlimMath.Vector3 pRayPos, ref SlimMath.Vector3 pRayDir, ref int pFaceIndex, ref float pU, ref float pV, ref float pDist) {
            unsafe {
                bool __result__;
                fixed (void* pRayPos_ = &pRayPos)
                    fixed (void* pRayDir_ = &pRayDir)
                        fixed (void* pFaceIndex_ = &pFaceIndex)
                            fixed (void* pU_ = &pU)
                                fixed (void* pV_ = &pV)
                                    fixed (void* pDist_ = &pDist)
                                        __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 34 * 4, pRayPos_, pRayDir_, pFaceIndex_, pU_, pV_, pDist_));
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXConstantTable</unmanaged>
    [Guid("ab3c758f-093e-4356-b762-4db18f1b3a01")]
    public partial class ConstantTable : SlimDX2.ComObject {
        public ConstantTable(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets a pointer to the buffer that contains the constant table.	
        /// </summary>	
        /// <unmanaged>void* GetBufferPointer()</unmanaged>
        public IntPtr BufferPointer {
                get { return GetBufferPointer(); }
        }
        
        /// <summary>	
        /// Gets the buffer size of the constant table.	
        /// </summary>	
        /// <unmanaged>int GetBufferSize()</unmanaged>
        public int BufferSize {
                get { return GetBufferSize(); }
        }
        
        /// <summary>	
        /// Gets a description of the constant table.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDesc([Out] D3DXCONSTANTTABLE_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.ConstanttableDescription Description {
                get { SlimDX2.Direct3D9.ConstanttableDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Sets the constants to their default values. The default values are declared in the variable declarations in the shader.	
        /// </summary>	
        /// <unmanaged>HRESULT SetDefaults([None] LPDIRECT3DDEVICE9 pDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Defaults {
                set { SetDefaults(value); }
        }
        
        /// <summary>	
        /// Gets a pointer to the buffer that contains the constant table.	
        /// </summary>	
        /// <returns>  {{LPVOID}}  Returns a pointer the buffer. </returns>
        /// <unmanaged>void* GetBufferPointer()</unmanaged>
        internal IntPtr GetBufferPointer() {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the buffer size of the constant table.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  Returns the size of the buffer, in bytes. </returns>
        /// <unmanaged>int GetBufferSize()</unmanaged>
        internal int GetBufferSize() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a description of the constant table.	
        /// </summary>	
        /// <param name="pDesc"> Description of the constant table. See <see cref="SlimDX2.Direct3D9.ConstanttableDescription"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3DXCONSTANTTABLE_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.ConstanttableDescription pDesc) {
            unsafe {
                SlimDX2.Direct3D9.ConstanttableDescription.__Native pDesc_ = new SlimDX2.Direct3D9.ConstanttableDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, &pDesc_);
                pDesc = new SlimDX2.Direct3D9.ConstanttableDescription();
                pDesc.__MarshalFrom(ref pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a pointer to an array of constant descriptions in the constant table.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXConstantTable::GetConstantDesc will sometimes return a <see cref="SlimDX2.Direct3D9.ConstantDescription"/> with a Register_Count of 0.  This will happen with a constant appears in more than one Register_Set but does not have space in that register set allocated. Because a sampler can appear more than once in a constant table, this method can return an array of descriptions, each one with a different register index. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to a constant. See {{D3DXHANDLE}}. </param>
        /// <param name="pConstantDesc"> Returns a pointer to an array of descriptions. See <see cref="SlimDX2.Direct3D9.ConstantDescription"/>. </param>
        /// <param name="pCount"> The input supplied must be the maximum size of the array. The output is the number of elements that are filled in the array when the function returns. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT GetConstantDesc([None] D3DXHANDLE hConstant,[Out] D3DXCONSTANT_DESC* pConstantDesc,[Out] UINT* pCount)</unmanaged>
        public SlimDX2.Result GetConstantDescription(string hConstant, out SlimDX2.Direct3D9.ConstantDescription pConstantDesc, out int pCount) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Direct3D9.ConstantDescription.__Native pConstantDesc_ = new SlimDX2.Direct3D9.ConstantDescription.__Native();
                SlimDX2.Result __result__;
                fixed (void* pCount_ = &pCount)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)hConstant_, &pConstantDesc_, pCount_);
                Marshal.FreeHGlobal(hConstant_ );
                pConstantDesc = new SlimDX2.Direct3D9.ConstantDescription();
                pConstantDesc.__MarshalFrom(ref pConstantDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns the sampler index.	
        /// </summary>	
        /// <param name="hConstant"> The sampler handle. </param>
        /// <returns>  {{UINT}}  Returns the sampler index number from the constant table. </returns>
        /// <unmanaged>UINT GetSamplerIndex([None] D3DXHANDLE hConstant)</unmanaged>
        public int GetSamplerIndex(string hConstant) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)hConstant_);
                Marshal.FreeHGlobal(hConstant_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a constant by looking up its index.	
        /// </summary>	
        /// <remarks>	
        ///  To get a constant from an array of constants, use <see cref="SlimDX2.Direct3D9.ConstantTable.GetConstantElement"/>. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to the parent data structure. If the constant is a top-level parameter (there is no parent data structure), use NULL. </param>
        /// <param name="index"> Zero-based index of the constant. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns a unique identifier to the constant. </returns>
        /// <unmanaged>D3DXHANDLE GetConstant([None] D3DXHANDLE hConstant,[None] UINT Index)</unmanaged>
        public byte GetConstant(string hConstant, int index) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 8 * 4, (void*)hConstant_, index);
                Marshal.FreeHGlobal(hConstant_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a constant by looking up its name.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the parent data structure. If the constant is a top-level parameter (there is no parent data structure), use NULL. </param>
        /// <param name="pName"> Name of the constant. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns a unique identifier to the constant. </returns>
        /// <unmanaged>D3DXHANDLE GetConstantByName([None] D3DXHANDLE hConstant,[Out] const char* pName)</unmanaged>
        public byte GetConstantByName(string hConstant, IntPtr pName) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 9 * 4, (void*)hConstant_, (void*)pName);
                Marshal.FreeHGlobal(hConstant_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a constant from an array of constants. An array is made up of elements.	
        /// </summary>	
        /// <remarks>	
        ///  To get a constant that is not part of an array, use <see cref="SlimDX2.Direct3D9.ConstantTable.GetConstant"/> or <see cref="SlimDX2.Direct3D9.ConstantTable.GetConstantByName"/>. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to the array of constants.  This value may not be NULL. </param>
        /// <param name="index"> Zero-based index of the element in the array. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns a unique identifier to the element constant. </returns>
        /// <unmanaged>D3DXHANDLE GetConstantElement([None] D3DXHANDLE hConstant,[None] UINT Index)</unmanaged>
        public byte GetConstantElement(string hConstant, int index) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 10 * 4, (void*)hConstant_, index);
                Marshal.FreeHGlobal(hConstant_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the constants to their default values. The default values are declared in the variable declarations in the shader.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetDefaults([None] LPDIRECT3DDEVICE9 pDevice)</unmanaged>
        internal SlimDX2.Result SetDefaults(SlimDX2.Direct3D9.Device pDevice) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the contents of the buffer to the constant table.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to a constant. See {{D3DXHANDLE}}. </param>
        /// <param name="pData"> Buffer containing data. </param>
        /// <param name="bytes"> Size of the buffer, in bytes. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetValue([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] LPCVOID pData,[None] UINT Bytes)</unmanaged>
        public SlimDX2.Result SetValue(SlimDX2.Direct3D9.Device pDevice, string hConstant, IntPtr pData, int bytes) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, (void*)pData, bytes);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a Boolean value.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the constant. See {{D3DXHANDLE}}. </param>
        /// <param name="b"> Boolean value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetBool([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] BOOL b)</unmanaged>
        public SlimDX2.Result SetBool(SlimDX2.Direct3D9.Device pDevice, string hConstant, bool b) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, (b?1:0));
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of Boolean values.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the array of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="pb"> Array of Boolean values. </param>
        /// <param name="count"> Number of Boolean values in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetBoolArray([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const BOOL* pb,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetBoolArray(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref bool pb, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pb_ = &pb)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, (pb?1:0), count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an integer value.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the constant. See {{D3DXHANDLE}}. </param>
        /// <param name="n"> Integer. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetInt([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] INT n)</unmanaged>
        public SlimDX2.Result SetInt(SlimDX2.Direct3D9.Device pDevice, string hConstant, int n) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, n);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of integers.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the array of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="pn"> Array of integers. </param>
        /// <param name="count"> Number of integers in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetIntArray([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const INT* pn,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetIntArray(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref int pn, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pn_ = &pn)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, pn_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a floating-point number.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the constant. See {{D3DXHANDLE}}. </param>
        /// <param name="f"> Floating-point number. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetFloat([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] FLOAT f)</unmanaged>
        public SlimDX2.Result SetFloat(SlimDX2.Direct3D9.Device pDevice, string hConstant, float f) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, f);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of floating-point numbers.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the array of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="pf"> Array of floating-point numbers. </param>
        /// <param name="count"> Number of floating-point values in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetFloatArray([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const FLOAT* pf,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetFloatArray(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref float pf, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pf_ = &pf)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, pf_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a 4D vector.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the vector constant. See {{D3DXHANDLE}}. </param>
        /// <param name="pVector"> Pointer to a 4D vector. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetVector([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const D3DXVECTOR4* pVector)</unmanaged>
        public SlimDX2.Result SetVector(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref SlimMath.Vector4 pVector) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pVector_ = &pVector)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, pVector_);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of 4D vectors.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the array of vector constants. See {{D3DXHANDLE}}. </param>
        /// <param name="pVector"> Array of 4D vectors. </param>
        /// <param name="count"> Number of vectors in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetVectorArray([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const D3DXVECTOR4* pVector,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetVectorArray(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref SlimMath.Vector4 pVector, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pVector_ = &pVector)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, pVector_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a nontransposed matrix.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the matrix of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="pMatrix"> Pointer to a nontransposed matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrix([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const D3DXMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result SetMatrix(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref SlimMath.Matrix pMatrix) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, pMatrix_);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of nontransposed matrices.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the array of constant matrices. See {{D3DXHANDLE}}. </param>
        /// <param name="pMatrix"> Array of nontransposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrixArray([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const D3DXMATRIX* pMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixArray(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref SlimMath.Matrix pMatrix, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 22 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, pMatrix_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of pointers to nontransposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A nontransposed matrix contains row-major data; that is, each vector is contained in a row. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to an array of constant matrices. See {{D3DXHANDLE}}. </param>
        /// <param name="ppMatrix"> Array of pointers to nontransposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrixPointerArray([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const D3DXMATRIX** ppMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixPointerArray(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref SlimMath.Matrix ppMatrix, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* ppMatrix_ = &ppMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, ppMatrix_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a transposed matrix.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the matrix of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="pMatrix"> Pointer to a transposed matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrixTranspose([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const D3DXMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result SetMatrixTranspose(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref SlimMath.Matrix pMatrix) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, pMatrix_);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of transposed matrices.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the array of matrix constants. See {{D3DXHANDLE}}. </param>
        /// <param name="pMatrix"> Array of transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrixTransposeArray([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const D3DXMATRIX* pMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixTransposeArray(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref SlimMath.Matrix pMatrix, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, pMatrix_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of pointers to transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the constant table. </param>
        /// <param name="hConstant"> Unique identifier to the array of matrix constants. See {{D3DXHANDLE}}. </param>
        /// <param name="ppMatrix"> Array of pointers to transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrixTransposePointerArray([None] LPDIRECT3DDEVICE9 pDevice,[None] D3DXHANDLE hConstant,[None] const D3DXMATRIX** ppMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixTransposePointerArray(SlimDX2.Direct3D9.Device pDevice, string hConstant, ref SlimMath.Matrix ppMatrix, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* ppMatrix_ = &ppMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 26 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), (void*)hConstant_, ppMatrix_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXTextureShader</unmanaged>
    [Guid("3e3d67f8-aa7a-405d-a857-ba01d4758426")]
    public partial class TextureShader : SlimDX2.ComObject {
        public TextureShader(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets a pointer to the function DWORD stream.	
        /// </summary>	
        /// <unmanaged>HRESULT GetFunction([Out] LPD3DXBUFFER* ppFunction)</unmanaged>
        public SlimDX2.Direct3D9.Buffer Function {
                get { SlimDX2.Direct3D9.Buffer __output__; GetFunction(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a pointer to the constant table.	
        /// </summary>	
        /// <unmanaged>HRESULT GetConstantBuffer([Out] LPD3DXBUFFER* ppConstantBuffer)</unmanaged>
        public SlimDX2.Direct3D9.Buffer ConstantBuffer {
                get { SlimDX2.Direct3D9.Buffer __output__; GetConstantBuffer(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets a description of the constant table.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDesc([Out] D3DXCONSTANTTABLE_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.ConstanttableDescription Description {
                get { SlimDX2.Direct3D9.ConstanttableDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets a pointer to the function DWORD stream.	
        /// </summary>	
        /// <param name="ppFunction"> A pointer to the function DWORD stream. See <see cref="SlimDX2.Direct3D9.Buffer"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT GetFunction([Out] LPD3DXBUFFER* ppFunction)</unmanaged>
        internal SlimDX2.Result GetFunction(out SlimDX2.Direct3D9.Buffer ppFunction) {
            unsafe {
                IntPtr ppFunction_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &ppFunction_);
                ppFunction = (ppFunction_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppFunction_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a pointer to the constant table.	
        /// </summary>	
        /// <param name="ppConstantBuffer"> Pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface, which contains the constants. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT GetConstantBuffer([Out] LPD3DXBUFFER* ppConstantBuffer)</unmanaged>
        internal SlimDX2.Result GetConstantBuffer(out SlimDX2.Direct3D9.Buffer ppConstantBuffer) {
            unsafe {
                IntPtr ppConstantBuffer_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, &ppConstantBuffer_);
                ppConstantBuffer = (ppConstantBuffer_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppConstantBuffer_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a description of the constant table.	
        /// </summary>	
        /// <param name="pDesc"> The attributes of the constant table. See <see cref="SlimDX2.Direct3D9.ConstanttableDescription"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3DXCONSTANTTABLE_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.ConstanttableDescription pDesc) {
            unsafe {
                SlimDX2.Direct3D9.ConstanttableDescription.__Native pDesc_ = new SlimDX2.Direct3D9.ConstanttableDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, &pDesc_);
                pDesc = new SlimDX2.Direct3D9.ConstanttableDescription();
                pDesc.__MarshalFrom(ref pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a pointer to the array of constants in the constant table.	
        /// </summary>	
        /// <remarks>	
        ///  Samplers can appear more than once in a constant table, therefore, this method can return an array of descriptions each with a different register index. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to a constant. See {{D3DXHANDLE}}. </param>
        /// <param name="pConstantDesc"> Returns a pointer to an array of descriptions. See <see cref="SlimDX2.Direct3D9.ConstantDescription"/>. </param>
        /// <param name="pCount"> The input supplied must be the maximum size of the array. The output is the number of elements that are filled in the array when the function returns. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT GetConstantDesc([None] D3DXHANDLE hConstant,[Out] D3DXCONSTANT_DESC* pConstantDesc,[Out] UINT* pCount)</unmanaged>
        public SlimDX2.Result GetConstantDescription(string hConstant, out SlimDX2.Direct3D9.ConstantDescription pConstantDesc, out int pCount) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Direct3D9.ConstantDescription.__Native pConstantDesc_ = new SlimDX2.Direct3D9.ConstantDescription.__Native();
                SlimDX2.Result __result__;
                fixed (void* pCount_ = &pCount)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)hConstant_, &pConstantDesc_, pCount_);
                Marshal.FreeHGlobal(hConstant_ );
                pConstantDesc = new SlimDX2.Direct3D9.ConstantDescription();
                pConstantDesc.__MarshalFrom(ref pConstantDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a constant by looking up its index.	
        /// </summary>	
        /// <remarks>	
        ///  To get a constant from an array of constants, use <see cref="SlimDX2.Direct3D9.TextureShader.GetConstantElement"/>. 	
        /// </remarks>	
        /// <param name="hConstant"> A {{handle}} to the parent data structure. If the constant is a top-level parameter (there is no parent data structure), use NULL. </param>
        /// <param name="index"> Zero-based index of the constant. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns a unique identifier to the constant. </returns>
        /// <unmanaged>D3DXHANDLE GetConstant([None] D3DXHANDLE hConstant,[None] UINT Index)</unmanaged>
        public byte GetConstant(string hConstant, int index) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 7 * 4, (void*)hConstant_, index);
                Marshal.FreeHGlobal(hConstant_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a constant by looking up its name.	
        /// </summary>	
        /// <param name="hConstant"> A {{handle}} to the parent data structure. If the constant is a top-level parameter (there is no parent data structure), use NULL. </param>
        /// <param name="pName"> A string containing the name of the constant. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns a unique identifier to the constant. </returns>
        /// <unmanaged>D3DXHANDLE GetConstantByName([None] D3DXHANDLE hConstant,[Out] const char* pName)</unmanaged>
        public byte GetConstantByName(string hConstant, IntPtr pName) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 8 * 4, (void*)hConstant_, (void*)pName);
                Marshal.FreeHGlobal(hConstant_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a constant from the constant table.	
        /// </summary>	
        /// <remarks>	
        ///  To get a constant that is not part of an array, use <see cref="SlimDX2.Direct3D9.TextureShader.GetConstant"/> or <see cref="SlimDX2.Direct3D9.TextureShader.GetConstantByName"/>. 	
        /// </remarks>	
        /// <param name="hConstant"> A {{handle}} to the array of constants.  This value may not be NULL. </param>
        /// <param name="index"> Zero-based index of the element in the constant table. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns a unique identifier to the constant. </returns>
        /// <unmanaged>D3DXHANDLE GetConstantElement([None] D3DXHANDLE hConstant,[None] UINT Index)</unmanaged>
        public byte GetConstantElement(string hConstant, int index) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 9 * 4, (void*)hConstant_, index);
                Marshal.FreeHGlobal(hConstant_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the constants to the default values declared in the shader.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetDefaults()</unmanaged>
        public SlimDX2.Result SetDefaults() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the constant table with the data in the buffer.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to a constant. See {{D3DXHANDLE}}. </param>
        /// <param name="pData"> A pointer to a buffer containing the constant data. </param>
        /// <param name="bytes"> Size of the buffer, in bytes. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetValue([None] D3DXHANDLE hConstant,[None] LPCVOID pData,[None] UINT Bytes)</unmanaged>
        public SlimDX2.Result SetValue(string hConstant, IntPtr pData, int bytes) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, (void*)hConstant_, (void*)pData, bytes);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a BOOL value.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the constant. See {{D3DXHANDLE}}. </param>
        /// <param name="b"> BOOL value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetBool([None] D3DXHANDLE hConstant,[None] BOOL b)</unmanaged>
        public SlimDX2.Result SetBool(string hConstant, bool b) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, (void*)hConstant_, (b?1:0));
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of BOOL values.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the array of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="pb"> Array of BOOL values. </param>
        /// <param name="count"> Number of BOOL values in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetBoolArray([None] D3DXHANDLE hConstant,[None] const BOOL* pb,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetBoolArray(string hConstant, ref bool pb, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pb_ = &pb)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, (void*)hConstant_, (pb?1:0), count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an integer value.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the constant. See {{D3DXHANDLE}}. </param>
        /// <param name="n"> Integer value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetInt([None] D3DXHANDLE hConstant,[None] INT n)</unmanaged>
        public SlimDX2.Result SetInt(string hConstant, int n) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, (void*)hConstant_, n);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of integers.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the array of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="pn"> Array of integers. </param>
        /// <param name="count"> Number of integers in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetIntArray([None] D3DXHANDLE hConstant,[None] const INT* pn,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetIntArray(string hConstant, ref int pn, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pn_ = &pn)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, (void*)hConstant_, pn_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a floating-point number.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the constant. See {{D3DXHANDLE}}. </param>
        /// <param name="f"> Floating-point number. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetFloat([None] D3DXHANDLE hConstant,[None] FLOAT f)</unmanaged>
        public SlimDX2.Result SetFloat(string hConstant, float f) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, (void*)hConstant_, f);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of floating-point numbers.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the array of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="pf"> Array of floating-point numbers. </param>
        /// <param name="count"> Number of floating-point values in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetFloatArray([None] D3DXHANDLE hConstant,[None] const FLOAT* pf,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetFloatArray(string hConstant, ref float pf, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pf_ = &pf)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, (void*)hConstant_, pf_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a 4D vector.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the vector constant. See {{D3DXHANDLE}}. </param>
        /// <param name="pVector"> Pointer to a 4D vector. See <see cref="SlimMath.Vector4"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetVector([None] D3DXHANDLE hConstant,[None] const D3DXVECTOR4* pVector)</unmanaged>
        public SlimDX2.Result SetVector(string hConstant, ref SlimMath.Vector4 pVector) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pVector_ = &pVector)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, (void*)hConstant_, pVector_);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of 4D vectors.	
        /// </summary>	
        /// <param name="hConstant"> Unique identifier to the array of vector constants. See {{D3DXHANDLE}}. </param>
        /// <param name="pVector"> Array of 4D vectors. See <see cref="SlimMath.Vector4"/>. </param>
        /// <param name="count"> Number of vectors in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetVectorArray([None] D3DXHANDLE hConstant,[None] const D3DXVECTOR4* pVector,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetVectorArray(string hConstant, ref SlimMath.Vector4 pVector, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pVector_ = &pVector)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, (void*)hConstant_, pVector_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a non-transposed matrix.	
        /// </summary>	
        /// <remarks>	
        ///  A non-transposed matrix contains row-major data; that is, each vector is contained in a row. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to the matrix of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="pMatrix"> Pointer to a non-transposed matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrix([None] D3DXHANDLE hConstant,[None] const D3DXMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result SetMatrix(string hConstant, ref SlimMath.Matrix pMatrix) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, (void*)hConstant_, pMatrix_);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of non-transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A non-transposed matrix contains row-major data; that is, each vector is contained in a row. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to the array of constant matrices. See {{D3DXHANDLE}}. </param>
        /// <param name="pMatrix"> Array of non-transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrixArray([None] D3DXHANDLE hConstant,[None] const D3DXMATRIX* pMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixArray(string hConstant, ref SlimMath.Matrix pMatrix, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, (void*)hConstant_, pMatrix_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of pointers to non-transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A non-transposed matrix contains row-major data; that is, each vector is contained in a row. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to an array of constant matrices. See {{D3DXHANDLE}}. </param>
        /// <param name="ppMatrix"> Array of pointers to non-transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrixPointerArray([None] D3DXHANDLE hConstant,[None] const D3DXMATRIX** ppMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixPointerArray(string hConstant, ref SlimMath.Matrix ppMatrix, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* ppMatrix_ = &ppMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 22 * 4, (void*)hConstant_, ppMatrix_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a transposed matrix.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to the matrix of constants. See {{D3DXHANDLE}}. </param>
        /// <param name="pMatrix"> Pointer to a transposed matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrixTranspose([None] D3DXHANDLE hConstant,[None] const D3DXMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result SetMatrixTranspose(string hConstant, ref SlimMath.Matrix pMatrix) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, (void*)hConstant_, pMatrix_);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to the array of matrix constants. See {{D3DXHANDLE}}. </param>
        /// <param name="pMatrix"> Array of transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrixTransposeArray([None] D3DXHANDLE hConstant,[None] const D3DXMATRIX* pMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixTransposeArray(string hConstant, ref SlimMath.Matrix pMatrix, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, (void*)hConstant_, pMatrix_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of pointers to transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. 	
        /// </remarks>	
        /// <param name="hConstant"> Unique identifier to the array of matrix constants. See {{D3DXHANDLE}}. </param>
        /// <param name="ppMatrix"> Array of pointers to transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrixTransposePointerArray([None] D3DXHANDLE hConstant,[None] const D3DXMATRIX** ppMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixTransposePointerArray(string hConstant, ref SlimMath.Matrix ppMatrix, int count) {
            unsafe {
                IntPtr hConstant_ = Marshal.StringToHGlobalAnsi(hConstant);
                SlimDX2.Result __result__;
                fixed (void* ppMatrix_ = &ppMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4, (void*)hConstant_, ppMatrix_, count);
                Marshal.FreeHGlobal(hConstant_ );
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXInclude</unmanaged>
    public partial class Include : SlimDX2.CppObject {
        public Include(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// A user-implemented method for opening and reading the contents of a shader #include file.	
        /// </summary>	
        /// <param name="includeType"> The location of the #include file. See <see cref="SlimDX2.Direct3D9.IncludeType"/>. </param>
        /// <param name="pFileName"> Name of the #include file. </param>
        /// <param name="pParentData"> Pointer to the container that includes the #include file. </param>
        /// <param name="ppData"> Pointer to the returned buffer that contains the include directives. This pointer remains valid until <see cref="SlimDX2.Direct3D9.Include.Close"/> is called. </param>
        /// <param name="pBytes"> Number of bytes returned in ppData. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when reading the #include file, the API that caused the callback to be called will fail. This is one of the following:  The HLSL shader will fail one of the D3DXCompileShader*** functions. The assembly shader will fail one of the D3DXAssembleShader*** functions. The effect will fail one of the D3DXCreateEffect*** or D3DXCreateEffectCompiler*** functions.  </returns>
        /// <unmanaged>HRESULT Open([None] D3DXINCLUDE_TYPE IncludeType,[None] const char* pFileName,[None] LPCVOID pParentData,[None] LPCVOID* ppData,[None] UINT* pBytes)</unmanaged>
        public SlimDX2.Result Open(SlimDX2.Direct3D9.IncludeType includeType, string pFileName, IntPtr pParentData, IntPtr ppData, ref int pBytes) {
            unsafe {
                IntPtr pFileName_ = Marshal.StringToHGlobalAnsi(pFileName);
                SlimDX2.Result __result__;
                fixed (void* pBytes_ = &pBytes)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 0 * 4, unchecked((int)includeType), (void*)pFileName_, (void*)pParentData, (void*)ppData, pBytes_);
                Marshal.FreeHGlobal(pFileName_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A user-implemented method for closing a shader #include file.	
        /// </summary>	
        /// <remarks>	
        ///   If <see cref="SlimDX2.Direct3D9.Include.Open"/> was successful, ID3DXInclude::Close is guaranteed to be called before the API using this interface returns. 	
        /// </remarks>	
        /// <param name="pData"> Pointer to the returned buffer that contains the include directives. This is the pointer that was returned by the corresponding <see cref="SlimDX2.Direct3D9.Include.Open"/> call. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when reading the #include file, the API that caused the callback to be called will fail. This is one of the following:  The HLSL shader will fail one of the D3DXCompileShader*** functions. The assembly shader will fail one of the D3DXAssembleShader*** functions. The effect will fail one of the D3DXCreateEffect*** or D3DXCreateEffectCompiler*** functions.  </returns>
        /// <unmanaged>HRESULT Close([None] LPCVOID pData)</unmanaged>
        public SlimDX2.Result Close(IntPtr pData) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 1 * 4, (void*)pData);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXEffectPool</unmanaged>
    [Guid("9537ab04-3250-412e-8213-fcd2f8677933")]
    public partial class EffectPool : SlimDX2.ComObject {
        public EffectPool(IntPtr basePtr) : base(basePtr) {
        }
        
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXBaseEffect</unmanaged>
    [Guid("017c18ac-103f-4417-8c51-6bf6ef1e56be")]
    public partial class BaseEffect : SlimDX2.ComObject {
        public BaseEffect(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the effect description.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDesc([Out] D3DXEFFECT_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D9.EffectDescription Description {
                get { SlimDX2.Direct3D9.EffectDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the effect description.	
        /// </summary>	
        /// <param name="pDesc"> Returns a description of the effect. See <see cref="SlimDX2.Direct3D9.EffectDescription"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3DXEFFECT_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D9.EffectDescription pDesc) {
            unsafe {
                SlimDX2.Direct3D9.EffectDescription.__Native pDesc_ = new SlimDX2.Direct3D9.EffectDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &pDesc_);
                pDesc = new SlimDX2.Direct3D9.EffectDescription();
                pDesc.__MarshalFrom(ref pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a parameter or annotation description.	
        /// </summary>	
        /// <param name="hParameter"> Parameter or annotation handle. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pDesc"> Returns a description of the specified parameter or annotation. See <see cref="SlimDX2.Direct3D9.ParameterDescription"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetParameterDesc([None] D3DXHANDLE hParameter,[Out] D3DXPARAMETER_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetParameterDescription(string hParameter, out SlimDX2.Direct3D9.ParameterDescription pDesc) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Direct3D9.ParameterDescription.__Native pDesc_ = new SlimDX2.Direct3D9.ParameterDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)hParameter_, &pDesc_);
                Marshal.FreeHGlobal(hParameter_ );
                pDesc = new SlimDX2.Direct3D9.ParameterDescription();
                pDesc.__MarshalFrom(ref pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a technique description.	
        /// </summary>	
        /// <param name="hTechnique"> Technique handle. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pDesc"> Returns a description of the technique. See <see cref="SlimDX2.Direct3D9.TechniqueDescription"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetTechniqueDesc([None] D3DXHANDLE hTechnique,[Out] D3DXTECHNIQUE_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetTechniqueDescription(string hTechnique, out SlimDX2.Direct3D9.TechniqueDescription pDesc) {
            unsafe {
                IntPtr hTechnique_ = Marshal.StringToHGlobalAnsi(hTechnique);
                SlimDX2.Direct3D9.TechniqueDescription.__Native pDesc_ = new SlimDX2.Direct3D9.TechniqueDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)hTechnique_, &pDesc_);
                Marshal.FreeHGlobal(hTechnique_ );
                pDesc = new SlimDX2.Direct3D9.TechniqueDescription();
                pDesc.__MarshalFrom(ref pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a pass description.	
        /// </summary>	
        /// <remarks>	
        ///  Note If an effect is created with {{D3DXFX_NOT_CLONEABLE}}, this method will return NULL pointers (in <see cref="SlimDX2.Direct3D9.PassDescription"/>) to the shader functions. 	
        /// </remarks>	
        /// <param name="hPass"> Pass handle. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pDesc"> Returns a description of the specified pass. See <see cref="SlimDX2.Direct3D9.PassDescription"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetPassDesc([None] D3DXHANDLE hPass,[Out] D3DXPASS_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetPassDescription(string hPass, out SlimDX2.Direct3D9.PassDescription pDesc) {
            unsafe {
                IntPtr hPass_ = Marshal.StringToHGlobalAnsi(hPass);
                SlimDX2.Direct3D9.PassDescription.__Native pDesc_ = new SlimDX2.Direct3D9.PassDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)hPass_, &pDesc_);
                Marshal.FreeHGlobal(hPass_ );
                pDesc = new SlimDX2.Direct3D9.PassDescription();
                pDesc.__MarshalFrom(ref pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a function description.	
        /// </summary>	
        /// <param name="hShader"> Function handle. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pDesc"> Returns a description of the function. See <see cref="SlimDX2.Direct3D9.FunctionDescription"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetFunctionDesc([None] D3DXHANDLE hShader,[Out] D3DXFUNCTION_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetFunctionDescription(string hShader, out SlimDX2.Direct3D9.FunctionDescription pDesc) {
            unsafe {
                IntPtr hShader_ = Marshal.StringToHGlobalAnsi(hShader);
                SlimDX2.Direct3D9.FunctionDescription.__Native pDesc_ = new SlimDX2.Direct3D9.FunctionDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)hShader_, &pDesc_);
                Marshal.FreeHGlobal(hShader_ );
                pDesc = new SlimDX2.Direct3D9.FunctionDescription();
                pDesc.__MarshalFrom(ref pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a top-level parameter or a structure member parameter.	
        /// </summary>	
        /// <param name="hParameter"> Handle of the parameter, or NULL for top-level parameters. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="index"> Parameter index. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified parameter, or NULL if the index was invalid. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE GetParameter([None] D3DXHANDLE hParameter,[None] UINT Index)</unmanaged>
        public byte GetParameter(string hParameter, int index) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 8 * 4, (void*)hParameter_, index);
                Marshal.FreeHGlobal(hParameter_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a top-level parameter or a structure member parameter by looking up its name.	
        /// </summary>	
        /// <param name="hParameter"> Handle of the parameter, or NULL for top-level parameters. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pName"> String containing the parameter name. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified parameter, or NULL if the index was invalid. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE GetParameterByName([None] D3DXHANDLE hParameter,[Out] const char* pName)</unmanaged>
        public byte GetParameterByName(string hParameter, IntPtr pName) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 9 * 4, (void*)hParameter_, (void*)pName);
                Marshal.FreeHGlobal(hParameter_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a top-level parameter or a structure member parameter by looking up its semantic with a case-insensitive search.	
        /// </summary>	
        /// <param name="hParameter"> Handle of the parameter, or NULL for top-level parameters. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pSemantic"> String containing the semantic name. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the first parameter that matches the specified semantic, or NULL if the semantic was not found. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE GetParameterBySemantic([None] D3DXHANDLE hParameter,[Out] const char* pSemantic)</unmanaged>
        public byte GetParameterBySemantic(string hParameter, IntPtr pSemantic) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 10 * 4, (void*)hParameter_, (void*)pSemantic);
                Marshal.FreeHGlobal(hParameter_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the handle of an array element parameter.	
        /// </summary>	
        /// <remarks>	
        ///  This method is used to get an element of a parameter that is an array. 	
        /// </remarks>	
        /// <param name="hParameter"> Handle of the array. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="index"> Array element index. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified parameter, or NULL if either hParameter or ElementIndex is invalid.  See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE GetParameterElement([None] D3DXHANDLE hParameter,[None] UINT Index)</unmanaged>
        public byte GetParameterElement(string hParameter, int index) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 11 * 4, (void*)hParameter_, index);
                Marshal.FreeHGlobal(hParameter_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a technique.	
        /// </summary>	
        /// <param name="index"> Technique index. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified technique, or NULL if the index was invalid. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE GetTechnique([None] UINT Index)</unmanaged>
        public byte GetTechnique(int index) {
            unsafe {
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 12 * 4, index);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a technique by looking up its name.	
        /// </summary>	
        /// <param name="pName"> String containing the technique name. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the first technique that has the specified name, or NULL if the name was not found. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE GetTechniqueByName([None] const char* pName)</unmanaged>
        public byte GetTechniqueByName(string pName) {
            unsafe {
                IntPtr pName_ = Marshal.StringToHGlobalAnsi(pName);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 13 * 4, (void*)pName_);
                Marshal.FreeHGlobal(pName_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a pass.	
        /// </summary>	
        /// <param name="hTechnique"> Handle of the parent technique. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="index"> Index for the pass. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified pass inside the specified technique, or NULL if the index was invalid. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE GetPass([None] D3DXHANDLE hTechnique,[None] UINT Index)</unmanaged>
        public byte GetPass(string hTechnique, int index) {
            unsafe {
                IntPtr hTechnique_ = Marshal.StringToHGlobalAnsi(hTechnique);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 14 * 4, (void*)hTechnique_, index);
                Marshal.FreeHGlobal(hTechnique_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a pass by looking up its name.	
        /// </summary>	
        /// <param name="hTechnique"> Handle of the parent technique. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pName"> String containing the pass name. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the first pass inside the specified technique that has the specified name, or NULL if the name was not found. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE GetPassByName([None] D3DXHANDLE hTechnique,[Out] const char* pName)</unmanaged>
        public byte GetPassByName(string hTechnique, IntPtr pName) {
            unsafe {
                IntPtr hTechnique_ = Marshal.StringToHGlobalAnsi(hTechnique);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 15 * 4, (void*)hTechnique_, (void*)pName);
                Marshal.FreeHGlobal(hTechnique_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a function.	
        /// </summary>	
        /// <param name="index"> Function index. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified function, or NULL if the index was invalid. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE GetFunction([None] UINT Index)</unmanaged>
        public byte GetFunction(int index) {
            unsafe {
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 16 * 4, index);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of a function by looking up its name.	
        /// </summary>	
        /// <param name="pName"> String containing the function name.  </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified function, or NULL if the name was not found. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE GetFunctionByName([None] const char* pName)</unmanaged>
        public byte GetFunctionByName(string pName) {
            unsafe {
                IntPtr pName_ = Marshal.StringToHGlobalAnsi(pName);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 17 * 4, (void*)pName_);
                Marshal.FreeHGlobal(pName_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of an annotation. 	
        /// </summary>	
        /// <remarks>	
        ///  Annotations are user-specific data that can be attached to any technique, pass, or parameter. See {{Handles (Direct3D 9)}}.  	
        /// </remarks>	
        /// <param name="hObject"> Handle of a technique, pass, or top-level parameter. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="index"> Annotation index. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified annotation, or NULL if the index was invalid. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE GetAnnotation([None] D3DXHANDLE hObject,[None] UINT Index)</unmanaged>
        public byte GetAnnotation(string hObject, int index) {
            unsafe {
                IntPtr hObject_ = Marshal.StringToHGlobalAnsi(hObject);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 18 * 4, (void*)hObject_, index);
                Marshal.FreeHGlobal(hObject_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the handle of an annotation by looking up its name.	
        /// </summary>	
        /// <param name="hObject"> Handle of a technique, pass, or top-level parameter. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pName"> String containing the annotation name. </param>
        /// <returns>  {{D3DXHANDLE}}  Returns the handle of the specified annotation, or NULL if the name was not found. See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE GetAnnotationByName([None] D3DXHANDLE hObject,[Out] const char* pName)</unmanaged>
        public byte GetAnnotationByName(string hObject, IntPtr pName) {
            unsafe {
                IntPtr hObject_ = Marshal.StringToHGlobalAnsi(hObject);
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 19 * 4, (void*)hObject_, (void*)pName);
                Marshal.FreeHGlobal(hObject_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set the value of an arbitrary parameter or annotation, including simple types, structs, arrays, strings, shaders and textures. 	
        /// </summary>	
        /// <remarks>	
        ///  This method can be used in place of nearly all the effect set API calls. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pData"> Pointer to a buffer containing data. </param>
        /// <param name="bytes"> [in] Number of bytes in the buffer. Pass in D3DX_DEFAULT if you know your buffer is large enough to contain the entire parameter, and you want to skip size validation. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetValue([None] D3DXHANDLE hParameter,[None] LPCVOID pData,[None] UINT Bytes)</unmanaged>
        public SlimDX2.Result SetValue(string hParameter, IntPtr pData, int bytes) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, (void*)hParameter_, (void*)pData, bytes);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the value of an arbitrary parameter or annotation, including simple types, structs, arrays, strings, shaders and textures. This method can be used in place of nearly all the Getxxx calls in <see cref="SlimDX2.Direct3D9.BaseEffect"/>.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pData"> Returns a buffer containing the value. </param>
        /// <param name="bytes"> [in] Number of bytes in the buffer. Pass in D3DX_DEFAULT if you know your buffer is large enough to contain the entire parameter, and you want to skip size validation. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetValue([None] D3DXHANDLE hParameter,[None] void* pData,[None] UINT Bytes)</unmanaged>
        public SlimDX2.Result GetValue(string hParameter, IntPtr pData, int bytes) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, (void*)hParameter_, (void*)pData, bytes);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a BOOL value.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="b"> Boolean value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetBool([None] D3DXHANDLE hParameter,[None] BOOL b)</unmanaged>
        public SlimDX2.Result SetBool(string hParameter, bool b) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 22 * 4, (void*)hParameter_, (b?1:0));
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a BOOL value.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pb"> Returns a Boolean value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetBool([None] D3DXHANDLE hParameter,[Out] BOOL* pb)</unmanaged>
        public SlimDX2.Result GetBool(string hParameter, out bool pb) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* pb_ = &pb)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, (void*)hParameter_, pb_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of Boolean values.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pb"> Array of Boolean values. </param>
        /// <param name="count"> Number of Boolean values in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetBoolArray([None] D3DXHANDLE hParameter,[None] const BOOL* pb,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetBoolArray(string hParameter, ref bool pb, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* pb_ = &pb)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, (void*)hParameter_, (pb?1:0), count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an array of BOOL values.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pb"> Returns an array of Boolean values. </param>
        /// <param name="count"> Number of Boolean values in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetBoolArray([None] D3DXHANDLE hParameter,[Out] BOOL* pb,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetBoolArray(string hParameter, out bool pb, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* pb_ = &pb)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4, (void*)hParameter_, pb_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an integer.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="n"> Integer value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetInt([None] D3DXHANDLE hParameter,[None] INT n)</unmanaged>
        public SlimDX2.Result SetInt(string hParameter, int n) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 26 * 4, (void*)hParameter_, n);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an integer.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pn"> Returns an integer. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetInt([None] D3DXHANDLE hParameter,[Out] INT* pn)</unmanaged>
        public SlimDX2.Result GetInt(string hParameter, out int pn) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* pn_ = &pn)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 27 * 4, (void*)hParameter_, pn_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of integers.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pn"> Array of integers. </param>
        /// <param name="count"> Number of integers in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetIntArray([None] D3DXHANDLE hParameter,[None] const INT* pn,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetIntArray(string hParameter, ref int pn, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* pn_ = &pn)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 28 * 4, (void*)hParameter_, pn_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an array of integers.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pn"> Returns an array of integers. </param>
        /// <param name="count"> Number of integers in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetIntArray([None] D3DXHANDLE hParameter,[Out] INT* pn,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetIntArray(string hParameter, out int pn, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* pn_ = &pn)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 29 * 4, (void*)hParameter_, pn_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a floating point value.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="f"> Floating point value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetFloat([None] D3DXHANDLE hParameter,[None] FLOAT f)</unmanaged>
        public SlimDX2.Result SetFloat(string hParameter, float f) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 30 * 4, (void*)hParameter_, f);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a floating point value.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pf"> Returns a floating point value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetFloat([None] D3DXHANDLE hParameter,[Out] FLOAT* pf)</unmanaged>
        public SlimDX2.Result GetFloat(string hParameter, out float pf) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* pf_ = &pf)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 31 * 4, (void*)hParameter_, pf_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of floating point values.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pf"> Array of floating point values. </param>
        /// <param name="count"> Number of floating point values in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetFloatArray([None] D3DXHANDLE hParameter,[None] const FLOAT* pf,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetFloatArray(string hParameter, ref float pf, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* pf_ = &pf)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 32 * 4, (void*)hParameter_, pf_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an array of floating point values.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pf"> Returns an array of floating point values. </param>
        /// <param name="count"> Number of floating point values in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetFloatArray([None] D3DXHANDLE hParameter,[Out] FLOAT* pf,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetFloatArray(string hParameter, out float pf, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* pf_ = &pf)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 33 * 4, (void*)hParameter_, pf_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a vector.	
        /// </summary>	
        /// <remarks>	
        ///  If the destination vector is smaller than the source vector, the additional components of the source vector will be ignored. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pVector"> Pointer to a 4D vector. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetVector([None] D3DXHANDLE hParameter,[None] const D3DXVECTOR4* pVector)</unmanaged>
        public SlimDX2.Result SetVector(string hParameter, ref SlimMath.Vector4 pVector) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* pVector_ = &pVector)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 34 * 4, (void*)hParameter_, pVector_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a vector.	
        /// </summary>	
        /// <remarks>	
        ///  If the destination vector is larger than the source vector, only the initial components of the destination vector will be filled, and the remaining components will be set to zero. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pVector"> Returns a 4D vector. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetVector([None] D3DXHANDLE hParameter,[Out] D3DXVECTOR4* pVector)</unmanaged>
        public SlimDX2.Result GetVector(string hParameter, out SlimMath.Vector4 pVector) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                pVector = new SlimMath.Vector4();
                SlimDX2.Result __result__;
                fixed (void* pVector_ = &pVector)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 35 * 4, (void*)hParameter_, pVector_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of vectors.	
        /// </summary>	
        /// <remarks>	
        ///  If the destination vectors are smaller than the source vectors, the additional components of the source vectors will be ignored. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pVector"> Array of 4D floating point vectors. </param>
        /// <param name="count"> Number of vectors in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetVectorArray([None] D3DXHANDLE hParameter,[None] const D3DXVECTOR4* pVector,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetVectorArray(string hParameter, ref SlimMath.Vector4 pVector, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* pVector_ = &pVector)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 36 * 4, (void*)hParameter_, pVector_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an array of vectors.	
        /// </summary>	
        /// <remarks>	
        ///  If the destination vectors are larger than the source vectors, only the initial components of each destination vector will be filled, and the remaining destination vector components will be set to zero. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pVector"> Returns an array of 4D floating point vectors. </param>
        /// <param name="count"> Number of vectors in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetVectorArray([None] D3DXHANDLE hParameter,[Out] D3DXVECTOR4* pVector,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetVectorArray(string hParameter, out SlimMath.Vector4 pVector, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                pVector = new SlimMath.Vector4();
                SlimDX2.Result __result__;
                fixed (void* pVector_ = &pVector)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 37 * 4, (void*)hParameter_, pVector_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a non-transposed matrix.	
        /// </summary>	
        /// <remarks>	
        ///  A non-transposed matrix contains row-major data. In other words, each vector is contained in a row. If the destination matrix is smaller than the source matrix, the additional components of the source matrix will be ignored. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pMatrix"> Pointer to a nontransposed matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrix([None] D3DXHANDLE hParameter,[None] const D3DXMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result SetMatrix(string hParameter, ref SlimMath.Matrix pMatrix) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 38 * 4, (void*)hParameter_, pMatrix_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a nontransposed matrix.	
        /// </summary>	
        /// <remarks>	
        ///  A nontransposed matrix contains row-major data; that is, each vector is contained in a row. If the destination matrix is larger than the source matrix, only the upper-left components of the destination matrix will be filled, and the remaining components will be set to zero. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pMatrix"> Returns a nontransposed matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetMatrix([None] D3DXHANDLE hParameter,[Out] D3DXMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result GetMatrix(string hParameter, out SlimMath.Matrix pMatrix) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                pMatrix = new SlimMath.Matrix();
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 39 * 4, (void*)hParameter_, pMatrix_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of nontransposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A nontransposed matrix contains row-major data; that is, each vector is contained in a row. If the destination matrices are smaller than the source matrices, the additional components of the source matrices will be ignored. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pMatrix"> Array of nontransposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrixArray([None] D3DXHANDLE hParameter,[None] const D3DXMATRIX* pMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixArray(string hParameter, ref SlimMath.Matrix pMatrix, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 40 * 4, (void*)hParameter_, pMatrix_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an array of nontransposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A nontransposed matrix contains row-major data; that is, each vector is contained in a row. If the destination matrices are larger than the source matrices, only the upper-left components of each destination matrix will be filled, and the remaining destination matrix components will be set to zero. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pMatrix"> Returns an array of nontransposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetMatrixArray([None] D3DXHANDLE hParameter,[Out] D3DXMATRIX* pMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetMatrixArray(string hParameter, out SlimMath.Matrix pMatrix, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                pMatrix = new SlimMath.Matrix();
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 41 * 4, (void*)hParameter_, pMatrix_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of pointers to nontransposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A nontransposed matrix contains row-major data; that is, each vector is contained in a row. If the destination matrices are smaller than the source matrices, the additional components of the source matrices will be ignored. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="ppMatrix"> Array of pointers to nontransposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrixPointerArray([None] D3DXHANDLE hParameter,[None] const D3DXMATRIX** ppMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixPointerArray(string hParameter, ref SlimMath.Matrix ppMatrix, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* ppMatrix_ = &ppMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 42 * 4, (void*)hParameter_, ppMatrix_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an array of pointers to nontransposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A nontransposed matrix contains row-major data; that is, each vector is contained in a row. If the destination matrices are larger than the source matrices, only the upper-left components of each destination matrix will be filled, and the remaining destination matrix components will be set to zero. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="ppMatrix"> Array of pointers to nontransposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetMatrixPointerArray([None] D3DXHANDLE hParameter,[Out] D3DXMATRIX** ppMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetMatrixPointerArray(string hParameter, out SlimMath.Matrix ppMatrix, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                ppMatrix = new SlimMath.Matrix();
                SlimDX2.Result __result__;
                fixed (void* ppMatrix_ = &ppMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 43 * 4, (void*)hParameter_, ppMatrix_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a transposed matrix.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. If the destination matrix is smaller than the source matrix, the additional components of the source matrix will be ignored. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pMatrix"> Pointer to a transposed matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrixTranspose([None] D3DXHANDLE hParameter,[None] const D3DXMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result SetMatrixTranspose(string hParameter, ref SlimMath.Matrix pMatrix) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 44 * 4, (void*)hParameter_, pMatrix_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a transposed matrix.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. If the destination matrix is larger than the source matrix, only the upper-left elements of the destination matrix will be filled, and the remaining destination matrix components will be set to zero. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pMatrix"> Returns a transposed matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetMatrixTranspose([None] D3DXHANDLE hParameter,[Out] D3DXMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result GetMatrixTranspose(string hParameter, out SlimMath.Matrix pMatrix) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                pMatrix = new SlimMath.Matrix();
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 45 * 4, (void*)hParameter_, pMatrix_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. If the destination matrices are smaller than the source matrices, the additional components of the source matrices will be ignored. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pMatrix"> Array of transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrixTransposeArray([None] D3DXHANDLE hParameter,[None] const D3DXMATRIX* pMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixTransposeArray(string hParameter, ref SlimMath.Matrix pMatrix, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 46 * 4, (void*)hParameter_, pMatrix_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an array of transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. If the destination matrices are larger than the source matrices, only the upper-left components of each destination matrix will be filled, and the remaining destination matrix components will be set to zero. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pMatrix"> Returns an array of transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetMatrixTransposeArray([None] D3DXHANDLE hParameter,[Out] D3DXMATRIX* pMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetMatrixTransposeArray(string hParameter, out SlimMath.Matrix pMatrix, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                pMatrix = new SlimMath.Matrix();
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 47 * 4, (void*)hParameter_, pMatrix_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an array of pointers to transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. If the destination matrices are smaller than the source matrices, the additional components of the source matrices will be ignored. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="ppMatrix"> Array of pointers to transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetMatrixTransposePointerArray([None] D3DXHANDLE hParameter,[None] const D3DXMATRIX** ppMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixTransposePointerArray(string hParameter, ref SlimMath.Matrix ppMatrix, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* ppMatrix_ = &ppMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 48 * 4, (void*)hParameter_, ppMatrix_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an array of pointers to transposed matrices.	
        /// </summary>	
        /// <remarks>	
        ///  A transposed matrix contains column-major data; that is, each vector is contained in a column. If the destination matrices are larger than the source matrices, only the upper-left components of each destination matrix will be filled, and the remaining destination matrix components will be set to zero. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="ppMatrix"> Array of pointers to transposed matrices. See <see cref="SlimMath.Matrix"/>. </param>
        /// <param name="count"> Number of matrices in the array. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetMatrixTransposePointerArray([None] D3DXHANDLE hParameter,[Out] D3DXMATRIX** ppMatrix,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetMatrixTransposePointerArray(string hParameter, out SlimMath.Matrix ppMatrix, int count) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                ppMatrix = new SlimMath.Matrix();
                SlimDX2.Result __result__;
                fixed (void* ppMatrix_ = &ppMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 49 * 4, (void*)hParameter_, ppMatrix_, count);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a string.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pString"> String to set. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetString([None] D3DXHANDLE hParameter,[None] const char* pString)</unmanaged>
        public SlimDX2.Result SetString(string hParameter, string pString) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                IntPtr pString_ = Marshal.StringToHGlobalAnsi(pString);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 50 * 4, (void*)hParameter_, (void*)pString_);
                Marshal.FreeHGlobal(hParameter_ );
                Marshal.FreeHGlobal(pString_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a string.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="ppString"> Returns a string identified by hParameter. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetString([None] D3DXHANDLE hParameter,[Out] const char** ppString)</unmanaged>
        public SlimDX2.Result GetString(string hParameter, IntPtr ppString) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 51 * 4, (void*)hParameter_, (void*)ppString);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a texture.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pTexture"> Texture object. See <see cref="SlimDX2.Direct3D9.BaseTexture"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetTexture([None] D3DXHANDLE hParameter,[None] LPDIRECT3DBASETEXTURE9 pTexture)</unmanaged>
        public SlimDX2.Result SetTexture(string hParameter, SlimDX2.Direct3D9.BaseTexture pTexture) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 52 * 4, (void*)hParameter_, (void*)((pTexture == null)?IntPtr.Zero:pTexture.NativePointer));
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a texture.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="ppTexture"> Returns a texture object. See <see cref="SlimDX2.Direct3D9.BaseTexture"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetTexture([None] D3DXHANDLE hParameter,[Out] LPDIRECT3DBASETEXTURE9* ppTexture)</unmanaged>
        public SlimDX2.Result GetTexture(string hParameter, out SlimDX2.Direct3D9.BaseTexture ppTexture) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                IntPtr ppTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 53 * 4, (void*)hParameter_, &ppTexture_);
                Marshal.FreeHGlobal(hParameter_ );
                ppTexture = (ppTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.BaseTexture(ppTexture_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a pixel shader.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="ppPShader"> Returns a pixel shader object. See <see cref="SlimDX2.Direct3D9.PixelShader"/> object. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetPixelShader([None] D3DXHANDLE hParameter,[Out] LPDIRECT3DPIXELSHADER9* ppPShader)</unmanaged>
        public SlimDX2.Result GetPixelShader(string hParameter, out SlimDX2.Direct3D9.PixelShader ppPShader) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                IntPtr ppPShader_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 54 * 4, (void*)hParameter_, &ppPShader_);
                Marshal.FreeHGlobal(hParameter_ );
                ppPShader = (ppPShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PixelShader(ppPShader_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a vertex shader.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="ppVShader"> Returns a vertex shader object. See <see cref="SlimDX2.Direct3D9.VertexShader"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetVertexShader([None] D3DXHANDLE hParameter,[Out] LPDIRECT3DVERTEXSHADER9* ppVShader)</unmanaged>
        public SlimDX2.Result GetVertexShader(string hParameter, out SlimDX2.Direct3D9.VertexShader ppVShader) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                IntPtr ppVShader_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 55 * 4, (void*)hParameter_, &ppVShader_);
                Marshal.FreeHGlobal(hParameter_ );
                ppVShader = (ppVShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VertexShader(ppVShader_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set the range of an array to pass to the device.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="uStart"> Start index. </param>
        /// <param name="uEnd"> Stop index. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetArrayRange([None] D3DXHANDLE hParameter,[None] UINT uStart,[None] UINT uEnd)</unmanaged>
        public SlimDX2.Result SetArrayRange(string hParameter, int uStart, int uEnd) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 56 * 4, (void*)hParameter_, uStart, uEnd);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXEffectStateManager</unmanaged>
    [Guid("79aab587-6dbc-4fa7-82de-37fa1781c5ce")]
    public partial class EffectStateManager : SlimDX2.ComObject {
        public EffectStateManager(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set material state.	
        /// </summary>	
        /// <unmanaged>HRESULT SetMaterial([None] const D3DMATERIAL9* pMaterial)</unmanaged>
        public SlimDX2.Direct3D9.Material9 Material {
                set { SetMaterial(ref value); }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set the number of subdivision segments for N-patches.	
        /// </summary>	
        /// <unmanaged>HRESULT SetNPatchMode([None] FLOAT NumSegments)</unmanaged>
        public float NPatchMode {
                set { SetNPatchMode(value); }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a FVF code.	
        /// </summary>	
        /// <unmanaged>HRESULT SetFVF([None] int FVF)</unmanaged>
        public int FVF {
                set { SetFVF(value); }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a vertex shader.	
        /// </summary>	
        /// <unmanaged>HRESULT SetVertexShader([None] LPDIRECT3DVERTEXSHADER9 pShader)</unmanaged>
        public SlimDX2.Direct3D9.VertexShader VertexShader {
                set { SetVertexShader(value); }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a pixel shader.	
        /// </summary>	
        /// <unmanaged>HRESULT SetPixelShader([None] LPDIRECT3DPIXELSHADER9 pShader)</unmanaged>
        public SlimDX2.Direct3D9.PixelShader PixelShader {
                set { SetPixelShader(value); }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a transform.	
        /// </summary>	
        /// <param name="state"> The type of transform to apply the matrix to. See <see cref="SlimDX2.Direct3D9.Transformstatetype"/>. </param>
        /// <param name="pMatrix"> A transformation matrix. See <see cref="SlimMath.Matrix"/>. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetTransform"/>) will fail.  </returns>
        /// <unmanaged>HRESULT SetTransform([None] D3DTRANSFORMSTATETYPE State,[None] const D3DMATRIX* pMatrix)</unmanaged>
        public SlimDX2.Result SetTransform(SlimDX2.Direct3D9.Transformstatetype state, ref SlimMath.Matrix pMatrix) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, unchecked((int)state), pMatrix_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set material state.	
        /// </summary>	
        /// <param name="pMaterial"> A pointer to the material state. See <see cref="SlimDX2.Direct3D9.Material9"/>. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetMaterial"/>) will fail.  </returns>
        /// <unmanaged>HRESULT SetMaterial([None] const D3DMATERIAL9* pMaterial)</unmanaged>
        internal SlimDX2.Result SetMaterial(ref SlimDX2.Direct3D9.Material9 pMaterial) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pMaterial_ = &pMaterial)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, pMaterial_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a light.	
        /// </summary>	
        /// <param name="index"> The zero-based index of the light. This is the same index  in <see cref="SlimDX2.Direct3D9.Device.SetLight"/>. </param>
        /// <param name="pLight"> The light object. See <see cref="SlimDX2.Direct3D9.Light9"/>. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetLight"/>) will fail.  </returns>
        /// <unmanaged>HRESULT SetLight([None] int Index,[None] const D3DLIGHT9* pLight)</unmanaged>
        public SlimDX2.Result SetLight(int index, ref SlimDX2.Direct3D9.Light9 pLight) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pLight_ = &pLight)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, index, pLight_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to enable/disable a light.	
        /// </summary>	
        /// <param name="index"> The zero-based index of the light. This is the same index in <see cref="SlimDX2.Direct3D9.Device.SetLight"/>. </param>
        /// <param name="enable"> True to enable the light, false otherwise. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.LightEnable"/>) will fail.  </returns>
        /// <unmanaged>HRESULT LightEnable([None] int Index,[None] BOOL Enable)</unmanaged>
        public SlimDX2.Result LightEnable(int index, bool enable) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4, index, (enable?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set render state.	
        /// </summary>	
        /// <param name="state"> The render state to set. <see cref="SlimDX2.Direct3D9.Renderstatetype"/>  </param>
        /// <param name="value"> The render state value. See {{Effect States (Direct3D 9)}}. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/>) will fail.  </returns>
        /// <unmanaged>HRESULT SetRenderState([None] D3DRENDERSTATETYPE State,[None] int Value)</unmanaged>
        public SlimDX2.Result SetRenderState(SlimDX2.Direct3D9.Renderstatetype state, int value) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, unchecked((int)state), value);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a texture.	
        /// </summary>	
        /// <param name="stage"> The stage to which the texture is assigned. This is the index value in <see cref="SlimDX2.Direct3D9.Device.SetTexture"/> or <see cref="SlimDX2.Direct3D9.Device.SetTextureStageState"/>.  </param>
        /// <param name="pTexture"> A pointer to the texture object. This can be any of the Direct3D texture types (cube, volume, etc.). See <see cref="SlimDX2.Direct3D9.BaseTexture"/>. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetTexture"/>) will fail.  </returns>
        /// <unmanaged>HRESULT SetTexture([None] int Stage,[None] LPDIRECT3DBASETEXTURE9 pTexture)</unmanaged>
        public SlimDX2.Result SetTexture(int stage, SlimDX2.Direct3D9.BaseTexture pTexture) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, stage, (void*)((pTexture == null)?IntPtr.Zero:pTexture.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set the texture stage state.	
        /// </summary>	
        /// <param name="stage"> The stage that the texture is assigned to. This is the index value in <see cref="SlimDX2.Direct3D9.Device.SetTexture"/> or <see cref="SlimDX2.Direct3D9.Device.SetTextureStageState"/>.  </param>
        /// <param name="type"> Defines the type of operation that a texture stage will perform. See  <see cref="SlimDX2.Direct3D9.Texturestagestatetype"/>.  </param>
        /// <param name="value"> Can be either an operation (<see cref="SlimDX2.Direct3D9.Textureop"/>) or an argument value ({{D3DTA}}), depending on what is chosen for Type. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetTextureStageState"/>) will fail.  </returns>
        /// <unmanaged>HRESULT SetTextureStageState([None] int Stage,[None] D3DTEXTURESTAGESTATETYPE Type,[None] int Value)</unmanaged>
        public SlimDX2.Result SetTextureStageState(int stage, SlimDX2.Direct3D9.Texturestagestatetype type, int value) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, stage, unchecked((int)type), value);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a sampler.	
        /// </summary>	
        /// <param name="sampler"> The zero-based sampler number.  </param>
        /// <param name="type"> Identifies sampler state, which can specify the filtering, addressing, or the border color. See <see cref="SlimDX2.Direct3D9.Samplerstatetype"/>. </param>
        /// <param name="value"> A value from one of the sampler state types in Type.  </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetSamplerState"/>) will fail.  </returns>
        /// <unmanaged>HRESULT SetSamplerState([None] int Sampler,[None] D3DSAMPLERSTATETYPE Type,[None] int Value)</unmanaged>
        public SlimDX2.Result SetSamplerState(int sampler, SlimDX2.Direct3D9.Samplerstatetype type, int value) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, sampler, unchecked((int)type), value);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set the number of subdivision segments for N-patches.	
        /// </summary>	
        /// <param name="numSegments"> Break the surface into this number of subdivisions. This is the same as the number used by <see cref="SlimDX2.Direct3D9.Device.SetNPatchMode"/>. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetNPatchMode"/>) will fail.  </returns>
        /// <unmanaged>HRESULT SetNPatchMode([None] FLOAT NumSegments)</unmanaged>
        internal SlimDX2.Result SetNPatchMode(float numSegments) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, numSegments);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a FVF code.	
        /// </summary>	
        /// <param name="fvf"> The FVF constant, that determines how to interpret vertex data. See {{D3DFVF}}. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetFVF"/>) will fail.  </returns>
        /// <unmanaged>HRESULT SetFVF([None] int FVF)</unmanaged>
        internal SlimDX2.Result SetFVF(int fvf) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, fvf);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a vertex shader.	
        /// </summary>	
        /// <param name="pShader"> A pointer to a vertex shader object. See <see cref="SlimDX2.Direct3D9.VertexShader"/>.  </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetVertexShader"/>) will fail.  </returns>
        /// <unmanaged>HRESULT SetVertexShader([None] LPDIRECT3DVERTEXSHADER9 pShader)</unmanaged>
        internal SlimDX2.Result SetVertexShader(SlimDX2.Direct3D9.VertexShader pShader) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, (void*)((pShader == null)?IntPtr.Zero:pShader.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set an array of vertex shader floating-point constants.	
        /// </summary>	
        /// <param name="registerIndex"> The zero-based index of the first constant register. </param>
        /// <param name="pConstantData"> An array of floating-point constants. </param>
        /// <param name="registerCount"> The number of registers in pConstantData. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetVertexShaderConstantF"/>) will fail.  </returns>
        /// <unmanaged>HRESULT SetVertexShaderConstantF([None] UINT RegisterIndex,[None] const FLOAT* pConstantData,[None] UINT RegisterCount)</unmanaged>
        public SlimDX2.Result SetVertexShaderConstantF(int registerIndex, ref float pConstantData, int registerCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, registerIndex, pConstantData_, registerCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set an array of vertex shader integer constants.	
        /// </summary>	
        /// <param name="registerIndex"> The zero-based index of the first constant register. </param>
        /// <param name="pConstantData"> An array of integer constants. </param>
        /// <param name="registerCount"> The number of registers in pConstantData. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetVertexShaderConstantI"/>) will fail.  </returns>
        /// <unmanaged>HRESULT SetVertexShaderConstantI([None] UINT RegisterIndex,[None] const INT* pConstantData,[None] UINT RegisterCount)</unmanaged>
        public SlimDX2.Result SetVertexShaderConstantI(int registerIndex, ref int pConstantData, int registerCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, registerIndex, pConstantData_, registerCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set an array of vertex shader Boolean constants.	
        /// </summary>	
        /// <param name="registerIndex"> The zero-based index of the first constant register. </param>
        /// <param name="pConstantData"> An array of Boolean constants. </param>
        /// <param name="registerCount"> The number of registers in pConstantData. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetVertexShaderConstantB"/>) will fail.  </returns>
        /// <unmanaged>HRESULT SetVertexShaderConstantB([None] UINT RegisterIndex,[None] const BOOL* pConstantData,[None] UINT RegisterCount)</unmanaged>
        public SlimDX2.Result SetVertexShaderConstantB(int registerIndex, ref bool pConstantData, int registerCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, registerIndex, (pConstantData?1:0), registerCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set a pixel shader.	
        /// </summary>	
        /// <param name="pShader"> A pointer to a pixel shader object. See <see cref="SlimDX2.Direct3D9.PixelShader"/>.  </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetPixelShader"/>) will fail.  </returns>
        /// <unmanaged>HRESULT SetPixelShader([None] LPDIRECT3DPIXELSHADER9 pShader)</unmanaged>
        internal SlimDX2.Result SetPixelShader(SlimDX2.Direct3D9.PixelShader pShader) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, (void*)((pShader == null)?IntPtr.Zero:pShader.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set an array of vertex shader floating-point constants.	
        /// </summary>	
        /// <param name="registerIndex"> The zero-based index of the first constant register. </param>
        /// <param name="pConstantData"> An array of floating-point constants. </param>
        /// <param name="registerCount"> The number of registers in pConstantData. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetPixelShaderConstantF"/>) will fail.  </returns>
        /// <unmanaged>HRESULT SetPixelShaderConstantF([None] UINT RegisterIndex,[None] const FLOAT* pConstantData,[None] UINT RegisterCount)</unmanaged>
        public SlimDX2.Result SetPixelShaderConstantF(int registerIndex, ref float pConstantData, int registerCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, registerIndex, pConstantData_, registerCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set an array of vertex shader integer constants.	
        /// </summary>	
        /// <param name="registerIndex"> The zero-based index of the first constant register. </param>
        /// <param name="pConstantData"> An array of integer constants. </param>
        /// <param name="registerCount"> The number of registers in pConstantData. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetPixelShaderConstantI"/>) will fail.  </returns>
        /// <unmanaged>HRESULT SetPixelShaderConstantI([None] UINT RegisterIndex,[None] const INT* pConstantData,[None] UINT RegisterCount)</unmanaged>
        public SlimDX2.Result SetPixelShaderConstantI(int registerIndex, ref int pConstantData, int registerCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, registerIndex, pConstantData_, registerCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback function that must be implemented by a user to set an array of vertex shader Boolean constants.	
        /// </summary>	
        /// <param name="registerIndex"> The zero-based index of the first constant register. </param>
        /// <param name="pConstantData"> An array of Boolean constants. </param>
        /// <param name="registerCount"> The number of registers in pConstantData. </param>
        /// <returns>  <see cref="int"/>  The user-implemented method should return S_OK. If the callback fails when setting the device state, either of the following will occur:  The effect will fail during <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>. The dynamic effect state call (such as <see cref="SlimDX2.Direct3D9.Device.SetPixelShaderConstantB"/>) will fail.  </returns>
        /// <unmanaged>HRESULT SetPixelShaderConstantB([None] UINT RegisterIndex,[None] const BOOL* pConstantData,[None] UINT RegisterCount)</unmanaged>
        public SlimDX2.Result SetPixelShaderConstantB(int registerIndex, ref bool pConstantData, int registerCount) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pConstantData_ = &pConstantData)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, registerIndex, (pConstantData?1:0), registerCount);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXEffect</unmanaged>
    [Guid("f6ceb4b3-4e4c-40dd-b883-8d8de5ea0cd5")]
    public partial class Effect : SlimDX2.Direct3D9.BaseEffect {
        public Effect(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets a pointer to the pool of shared parameters.	
        /// </summary>	
        /// <remarks>	
        ///  Pools contain shared parameters between effects. See {{Cloning and Sharing (Direct3D 9)}}. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetPool([Out] LPD3DXEFFECTPOOL* ppPool)</unmanaged>
        public SlimDX2.Direct3D9.EffectPool Pool {
                get { SlimDX2.Direct3D9.EffectPool __output__; GetPool(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Sets the active technique.	
        /// </summary>	
        /// <unmanaged>HRESULT SetTechnique([None] D3DXHANDLE hTechnique)</unmanaged>
        public string Technique {
                set { SetTechnique(value); }
        }
        
        /// <summary>	
        /// Gets the current technique.	
        /// </summary>	
        /// <unmanaged>D3DXHANDLE GetCurrentTechnique()</unmanaged>
        public byte CurrentTechnique {
                get { return GetCurrentTechnique(); }
        }
        
        /// <summary>	
        /// Retrieves the device associated with the effect.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count for the <see cref="SlimDX2.Direct3D9.Device"/> interface. Be sure to call IUnknown::Release when you are done using the IDirect3DDevice9 interface or you will have a memory leak. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        public SlimDX2.Direct3D9.Device Device {
                get { SlimDX2.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the effect state manager.	
        /// </summary>	
        /// <remarks>	
        ///  The <see cref="SlimDX2.Direct3D9.EffectStateManager"/> is a user-implemented interface that furnishes callbacks into an application for setting device state from an effect. 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetStateManager([Out] LPD3DXEFFECTSTATEMANAGER* ppManager)</unmanaged>
        public SlimDX2.Direct3D9.EffectStateManager StateManager {
                get { SlimDX2.Direct3D9.EffectStateManager __output__; GetStateManager(out __output__); return __output__; }
                set { SetStateManager(value); }
        }
        
        /// <summary>	
        /// Gets a pointer to the pool of shared parameters.	
        /// </summary>	
        /// <remarks>	
        ///  Pools contain shared parameters between effects. See {{Cloning and Sharing (Direct3D 9)}}. 	
        /// </remarks>	
        /// <param name="ppPool"> Pointer to a <see cref="SlimDX2.Direct3D9.EffectPool"/> object.  </param>
        /// <returns>  <see cref="int"/>  This method always returns the value S_OK. </returns>
        /// <unmanaged>HRESULT GetPool([Out] LPD3DXEFFECTPOOL* ppPool)</unmanaged>
        internal SlimDX2.Result GetPool(out SlimDX2.Direct3D9.EffectPool ppPool) {
            unsafe {
                IntPtr ppPool_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 57 * 4, &ppPool_);
                ppPool = (ppPool_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.EffectPool(ppPool_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the active technique.	
        /// </summary>	
        /// <param name="hTechnique"> Unique handle to the technique.  See {{Handles (Direct3D 9)}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetTechnique([None] D3DXHANDLE hTechnique)</unmanaged>
        internal SlimDX2.Result SetTechnique(string hTechnique) {
            unsafe {
                IntPtr hTechnique_ = Marshal.StringToHGlobalAnsi(hTechnique);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 58 * 4, (void*)hTechnique_);
                Marshal.FreeHGlobal(hTechnique_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the current technique.	
        /// </summary>	
        /// <returns>  {{D3DXHANDLE}}  A unique identifier to the current technique.  See {{Handles (Direct3D 9)}}. </returns>
        /// <unmanaged>D3DXHANDLE GetCurrentTechnique()</unmanaged>
        internal byte GetCurrentTechnique() {
            unsafe {
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 59 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Validate a technique.	
        /// </summary>	
        /// <param name="hTechnique"> Unique identifier. See {{Handles (Direct3D 9)}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ValidateTechnique([None] D3DXHANDLE hTechnique)</unmanaged>
        public SlimDX2.Result ValidateTechnique(string hTechnique) {
            unsafe {
                IntPtr hTechnique_ = Marshal.StringToHGlobalAnsi(hTechnique);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 60 * 4, (void*)hTechnique_);
                Marshal.FreeHGlobal(hTechnique_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Searches for the next valid technique, starting at the technique after the specified technique.	
        /// </summary>	
        /// <param name="hTechnique"> Unique identifier to a technique. See {{Handles (Direct3D 9)}}. Specify NULL for this parameter to find the first valid technique. </param>
        /// <param name="pTechnique"> Pointer to an identifier for the next technique. NULL is returned if this is the last technique.  See {{Handles (Direct3D 9)}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT FindNextValidTechnique([None] D3DXHANDLE hTechnique,[None] D3DXHANDLE* pTechnique)</unmanaged>
        public SlimDX2.Result FindNextValidTechnique(string hTechnique, string pTechnique) {
            unsafe {
                IntPtr hTechnique_ = Marshal.StringToHGlobalAnsi(hTechnique);
                IntPtr pTechnique_ = Marshal.StringToHGlobalAnsi(pTechnique);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 61 * 4, (void*)hTechnique_, (void*)pTechnique_);
                Marshal.FreeHGlobal(hTechnique_ );
                Marshal.FreeHGlobal(pTechnique_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Determines if a parameter is used by the technique.	
        /// </summary>	
        /// <param name="hParameter"> Unique identifier for the parameter.  See {{Handles (Direct3D 9)}}. </param>
        /// <param name="hTechnique"> Unique identifier for the technique.  See {{Handles (Direct3D 9)}}. </param>
        /// <returns>  {{BOOL}}  Returns TRUE if the parameter is being used and returns FALSE if the parameter is not being used. </returns>
        /// <unmanaged>BOOL IsParameterUsed([None] D3DXHANDLE hParameter,[None] D3DXHANDLE hTechnique)</unmanaged>
        public bool IsParameterUsed(string hParameter, string hTechnique) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                IntPtr hTechnique_ = Marshal.StringToHGlobalAnsi(hTechnique);
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 62 * 4, (void*)hParameter_, (void*)hTechnique_));
                Marshal.FreeHGlobal(hParameter_ );
                Marshal.FreeHGlobal(hTechnique_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Starts an active technique.	
        /// </summary>	
        /// <remarks>	
        ///  An application sets one active technique in the effect system by calling ID3DXEffect::Begin. The effect system responds by capturing all the pipeline state that can be changed by the technique in a state block. An application signals the end of a technique by calling <see cref="SlimDX2.Direct3D9.Effect.End"/>, which uses the state block to restore the original state. The effect system, therefore, takes care of saving state when a technique becomes active and restoring state when a technique ends. If you choose to disable this save and restore functionality, see {{D3DXFX_DONOTSAVESAMPLERSTATE}}. Within the ID3DXEffect::Begin and <see cref="SlimDX2.Direct3D9.Effect.End"/> pair, an application uses <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/> to set the active pass, <see cref="SlimDX2.Direct3D9.Effect.CommitChanges"/> if any state changes occurred after the pass was activated, and <see cref="SlimDX2.Direct3D9.Effect.EndPass"/> to end the active pass. 	
        /// </remarks>	
        /// <param name="pPasses"> Pointer to a value returned that indicates the number of passes needed to render the current technique.  </param>
        /// <param name="flags"> DWORD that determines if state modified by an effect is saved and restored. The default value 0 specifies that ID3DXEffect::Begin and <see cref="SlimDX2.Direct3D9.Effect.End"/> will save and restore all state modified by the effect (including pixel and vertex shader constants). Valid flags can be seen at {{Effect State Save and Restore Flags}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT Begin([None] UINT* pPasses,[None] int Flags)</unmanaged>
        public SlimDX2.Result Begin(ref int pPasses, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pPasses_ = &pPasses)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 63 * 4, pPasses_, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Begins a pass, within the active technique.	
        /// </summary>	
        /// <remarks>	
        ///  An application sets one active pass (within one active technique) in the effect system by calling ID3DXEffect::BeginPass. An application signals the end of the active pass by calling <see cref="SlimDX2.Direct3D9.Effect.EndPass"/>. ID3DXEffect::BeginPass and ID3DXEffect::EndPass must occur in a matching pair, within a matching pair of <see cref="SlimDX2.Direct3D9.Effect.Begin"/> and <see cref="SlimDX2.Direct3D9.Effect.End"/> calls. If the application changes any effect state using any of the {{Effect::Setx}} methods inside of a ID3DXEffect::BeginPass/<see cref="SlimDX2.Direct3D9.Effect.EndPass"/> matching pair, the application must call <see cref="SlimDX2.Direct3D9.Effect.CommitChanges"/> to set the update the device with the state changes. If no state changes occur within a ID3DXEffect::BeginPass and ID3DXEffect::EndPass matching pair, it is not necessary to call ID3DXEffect::CommitChanges. 	
        /// </remarks>	
        /// <param name="pass"> A zero-based integer index into the technique. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT BeginPass([None] UINT Pass)</unmanaged>
        public SlimDX2.Result BeginPass(int pass) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 64 * 4, pass);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Propagate state changes that occur inside of an active pass to the device before rendering.	
        /// </summary>	
        /// <remarks>	
        ///  If the application changes any effect state using any of the {{ID3DXEffect::Setx}} methods inside of an <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>/<see cref="SlimDX2.Direct3D9.Effect.EndPass"/> matching pair, the application must call ID3DXEffect::CommitChanges before any DrawxPrimitive call to propagate state changes to the device before rendering. If no state changes occur within a ID3DXEffect::BeginPass and ID3DXEffect::EndPass matching pair, it is not necessary to call ID3DXEffect::CommitChanges. This is slightly different for any shared parameters in a cloned effect. When a technique is active on a cloned effect (that is, when <see cref="SlimDX2.Direct3D9.Effect.Begin"/> has been called but and <see cref="SlimDX2.Direct3D9.Effect.End"/> has not been called), ID3DXEffect::CommitChanges updates parameters that are not shared as expected. To update a shared parameter (only for a cloned effect whose technique is active), call ID3DXEffect::End to deactivate the technique and ID3DXEffect::Begin to reactivate the technique before calling ID3DXEffect::CommitChanges. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT CommitChanges()</unmanaged>
        public SlimDX2.Result CommitChanges() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 65 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// End an active pass.	
        /// </summary>	
        /// <remarks>	
        ///  An application signals the end of rendering an active pass by calling ID3DXEffect::EndPass. Each ID3DXEffect::EndPass must be part of a matching pair of <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/> and ID3DXEffect::EndPass calls. Each matching pair of <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/> and ID3DXEffect::EndPass calls must be located within a matching pair of <see cref="SlimDX2.Direct3D9.Effect.Begin"/> and <see cref="SlimDX2.Direct3D9.Effect.End"/> calls. If the application changes any effect state using any of the {{Effect::Setx}} methods inside of a <see cref="SlimDX2.Direct3D9.Effect.BeginPass"/>/ID3DXEffect::EndPass matching pair, the application must call <see cref="SlimDX2.Direct3D9.Effect.CommitChanges"/> before any DrawxPrimitive call to propagate state changes to the device before rendering. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  This method always returns the value S_OK. </returns>
        /// <unmanaged>HRESULT EndPass()</unmanaged>
        public SlimDX2.Result EndPass() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 66 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Ends an active technique.	
        /// </summary>	
        /// <remarks>	
        ///  All rendering in an effect is done within a matching pair of <see cref="SlimDX2.Direct3D9.Effect.Begin"/> and ID3DXEffect::End calls. After all passes are rendered, ID3DXEffect::End must be called to end the active technique. The effect system responds by using the state block created when ID3DXEffect::Begin was called, to automatically restore the pipeline state before ID3DXEffect::Begin. By default, the effect system takes care of saving state prior to a technique, and restoring state after a technique. If you choose to disable this save and restore functionality, see {{D3DXFX_DONOTSAVESAMPLERSTATE}}. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  This method always returns the value S_OK. </returns>
        /// <unmanaged>HRESULT End()</unmanaged>
        public SlimDX2.Result End() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 67 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the device associated with the effect.	
        /// </summary>	
        /// <remarks>	
        ///  Calling this method will increase the internal reference count for the <see cref="SlimDX2.Direct3D9.Device"/> interface. Be sure to call IUnknown::Release when you are done using the IDirect3DDevice9 interface or you will have a memory leak. 	
        /// </remarks>	
        /// <param name="ppDevice"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the effect.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetDevice([Out] LPDIRECT3DDEVICE9* ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D9.Device ppDevice) {
            unsafe {
                IntPtr ppDevice_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 68 * 4, &ppDevice_);
                ppDevice = (ppDevice_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Device(ppDevice_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost, or before resetting a device.	
        /// </summary>	
        /// <remarks>	
        ///  This method should be called whenever the device is lost or before the user calls <see cref="SlimDX2.Direct3D9.Device.Reset"/>. Even if the device was not actually lost, ID3DXEffect::OnLostDevice is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling IDirect3DDevice9::Reset and then <see cref="SlimDX2.Direct3D9.Effect.OnResetDevice"/>. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT OnLostDevice()</unmanaged>
        public SlimDX2.Result OnLostDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 69 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Use this method to re-acquire resources and save initial state.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXEffect::OnResetDevice should be called each time the device is reset (using <see cref="SlimDX2.Direct3D9.Device.Reset"/>), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT OnResetDevice()</unmanaged>
        public SlimDX2.Result OnResetDevice() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 70 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set the effect state manager.	
        /// </summary>	
        /// <remarks>	
        ///  The <see cref="SlimDX2.Direct3D9.EffectStateManager"/> is a user-implemented interface that furnishes callbacks into an application for setting device state from an effect. 	
        /// </remarks>	
        /// <param name="pManager"> A pointer to the state manager. See <see cref="SlimDX2.Direct3D9.EffectStateManager"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT SetStateManager([None] LPD3DXEFFECTSTATEMANAGER pManager)</unmanaged>
        internal SlimDX2.Result SetStateManager(SlimDX2.Direct3D9.EffectStateManager pManager) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 71 * 4, (void*)((pManager == null)?IntPtr.Zero:pManager.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the effect state manager.	
        /// </summary>	
        /// <remarks>	
        ///  The <see cref="SlimDX2.Direct3D9.EffectStateManager"/> is a user-implemented interface that furnishes callbacks into an application for setting device state from an effect. 	
        /// </remarks>	
        /// <param name="ppManager"> Returns a pointer to the state manager. See <see cref="SlimDX2.Direct3D9.EffectStateManager"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT GetStateManager([Out] LPD3DXEFFECTSTATEMANAGER* ppManager)</unmanaged>
        internal SlimDX2.Result GetStateManager(out SlimDX2.Direct3D9.EffectStateManager ppManager) {
            unsafe {
                IntPtr ppManager_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 72 * 4, &ppManager_);
                ppManager = (ppManager_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.EffectStateManager(ppManager_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Start capturing state changes in a parameter block.	
        /// </summary>	
        /// <remarks>	
        ///  Capture effect parameter state changes until EndParameterBlock is called. Effect parameters include any state changes outside of a pass. Delete parameter blocks if they are no longer needed by calling DeleteParameterBlock. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT BeginParameterBlock()</unmanaged>
        public SlimDX2.Result BeginParameterBlock() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 73 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Stop capturing effect parameter state changes.	
        /// </summary>	
        /// <remarks>	
        ///  All effect parameters that change state (after calling BeginParameterBlock and before calling EndParameterBlock) will be saved in an effect parameter state block. Use ApplyParameterBlock to apply this block of state changes to the effect system. Once you are finished with a state block use DeleteParameterBlock to free the memory. 	
        /// </remarks>	
        /// <returns>  {{D3DXHANDLE}}  Returns a handle to the parameter state block. </returns>
        /// <unmanaged>D3DXHANDLE EndParameterBlock()</unmanaged>
        public byte EndParameterBlock() {
            unsafe {
                byte __result__;
                __result__= (byte)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 74 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Apply the values in a state block to the current effect system state.	
        /// </summary>	
        /// <remarks>	
        ///  Capture effect parameter state changes in a parameter block by calling BeginParameterBlock; stop capturing state changes by calling EndParameterBlock. These state changes include any effect parameter changes that occur inside of a technique (including those outside of a pass). Once you are done with the parameter block, call DeleteParameterBlock to recover memory. 	
        /// </remarks>	
        /// <param name="hParameterBlock"> A handle to the parameter block. This is the handle returned by <see cref="SlimDX2.Direct3D9.Effect.EndParameterBlock"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT ApplyParameterBlock([None] D3DXHANDLE hParameterBlock)</unmanaged>
        public SlimDX2.Result ApplyParameterBlock(string hParameterBlock) {
            unsafe {
                IntPtr hParameterBlock_ = Marshal.StringToHGlobalAnsi(hParameterBlock);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 75 * 4, (void*)hParameterBlock_);
                Marshal.FreeHGlobal(hParameterBlock_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Delete a parameter block.	
        /// </summary>	
        /// <remarks>	
        ///  Parameter blocks are blocks of effect states. Use a parameter block to record state changes so that they can be applied later on with a single API call. When no longer needed, delete the parameter block to reduce memory usage. 	
        /// </remarks>	
        /// <param name="hParameterBlock"> A handle to the parameter block. This is the handle returned by <see cref="SlimDX2.Direct3D9.Effect.EndParameterBlock"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT DeleteParameterBlock([None] D3DXHANDLE hParameterBlock)</unmanaged>
        public SlimDX2.Result DeleteParameterBlock(string hParameterBlock) {
            unsafe {
                IntPtr hParameterBlock_ = Marshal.StringToHGlobalAnsi(hParameterBlock);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 76 * 4, (void*)hParameterBlock_);
                Marshal.FreeHGlobal(hParameterBlock_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a copy of an effect.	
        /// </summary>	
        /// <remarks>	
        ///  Note This function will not clone an effect if the user specifies {{D3DXFX_NOT_CLONEABLE}} during effect creation. To update shared and non-shared parameters in an active technique of a cloned effect, see <see cref="SlimDX2.Direct3D9.Effect.CommitChanges"/>. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the effect.  </param>
        /// <param name="ppEffect"> Pointer to an <see cref="SlimDX2.Direct3D9.Effect"/> interface, containing the cloned effect.  </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT CloneEffect([None] LPDIRECT3DDEVICE9 pDevice,[None] LPD3DXEFFECT* ppEffect)</unmanaged>
        public SlimDX2.Result CloneEffect(SlimDX2.Direct3D9.Device pDevice, out SlimDX2.Direct3D9.Effect ppEffect) {
            unsafe {
                IntPtr ppEffect_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 77 * 4, (void*)((pDevice == null)?IntPtr.Zero:pDevice.NativePointer), &ppEffect_);
                ppEffect = (ppEffect_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Effect(ppEffect_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set a contiguous range of shader constants with a memory copy.	
        /// </summary>	
        /// <remarks>	
        ///  SetRawValue is a very fast way to set effect constants since it performs a memory copy without performing validation or any data conversion (like converting a row-major matrix to a column-major matrix). Use SetRawValue to set a series of contiguous effect constants. For instance, you could set an array of twenty matrices with 20 calls to <see cref="SlimDX2.Direct3D9.BaseEffect.SetMatrix"/> or by using a single SetRawValue. All values are expected to be either matrix4x4s or float4s and all matrices are expected to be in column-major order. Int or float values are cast into a float4; therefore, it is highly recommended that you use SetRawValue with only float4 or matrix4x4 data. 	
        /// </remarks>	
        /// <param name="hParameter"> Handle to the value to set, or the name of the value passed in as a string. Passing in a handle is more efficient. See {{Handles (Direct3D 9)}}.  </param>
        /// <param name="pData"> Pointer to a buffer containing the data to be set. SetRawValue checks for valid memory, but does not do any checking for valid data. </param>
        /// <param name="byteOffset"> Number of bytes between the beginning of the effect data and the beginning of the effect constants you are going to set. </param>
        /// <param name="bytes"> The size of the buffer to be set, in bytes. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following:E_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetRawValue([None] D3DXHANDLE hParameter,[None] LPCVOID pData,[None] UINT ByteOffset,[None] UINT Bytes)</unmanaged>
        public SlimDX2.Result SetRawValue(string hParameter, IntPtr pData, int byteOffset, int bytes) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 78 * 4, (void*)hParameter_, (void*)pData, byteOffset, bytes);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXEffectCompiler</unmanaged>
    [Guid("51b8a949-1a31-47e6-bea0-4b30db53f1e0")]
    public partial class EffectCompiler : SlimDX2.Direct3D9.BaseEffect {
        public EffectCompiler(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Toggles the literal status of a parameter. A literal parameter has a value that doesn't change during the lifetime of an effect.	
        /// </summary>	
        /// <remarks>	
        ///  This methods only changes whether the parameter is a literal or not. To change the value of a parameter, use a method like <see cref="SlimDX2.Direct3D9.BaseEffect.SetBool"/> or <see cref="SlimDX2.Direct3D9.BaseEffect.SetValue"/>. This function must be called before the effect is compiled.  Here is an example of how one might use this function: 	
        /// <code> LPD3DXEFFECTCOMPILER pEffectCompiler; char errors[1000]; HRESULT hr; hr = D3DXCreateEffectCompilerFromFile("shader.fx", NULL, NULL, 0, &amp;pEffectCompiler,  &amp;errors); //In the fx file, literalInt is declared as an int. //By calling this function, the compiler will treat //it as a literal (i.e. #define) hr = pEffectCompiler-&gt;SetLiteral("literalInt", TRUE); //create ten different variations of the same effect LPD3DXBUFFER pEffects[10]; LPD3DXBUFFER pErrors; for(int i = 0; i &lt; 10; ++i) { hr = pEffectCompiler-&gt;SetInt("literalInt", i); hr = pEffectCompiler-&gt;CompileEffect(0, &amp;pEffects[i], &amp;pErrors); } </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier to a parameter. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="literal"> Set to True to make the parameter a literal, and False if the parameter can change value during the shader lifetime. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetLiteral([None] D3DXHANDLE hParameter,[None] BOOL Literal)</unmanaged>
        public SlimDX2.Result SetLiteral(string hParameter, bool literal) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 57 * 4, (void*)hParameter_, (literal?1:0));
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a literal status of a parameter. A literal parameter has a value that doesn't change during the lifetime of an effect.	
        /// </summary>	
        /// <remarks>	
        ///  This methods only changes whether the parameter is a literal or not. To change the value of a parameter, use a method like <see cref="SlimDX2.Direct3D9.BaseEffect.SetBool"/> or <see cref="SlimDX2.Direct3D9.BaseEffect.SetValue"/>. 	
        /// </remarks>	
        /// <param name="hParameter"> Unique identifier to a parameter. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pLiteral"> Returns True if the parameter is a literal, and False otherwise. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetLiteral([None] D3DXHANDLE hParameter,[Out] BOOL* pLiteral)</unmanaged>
        public SlimDX2.Result GetLiteral(string hParameter, out bool pLiteral) {
            unsafe {
                IntPtr hParameter_ = Marshal.StringToHGlobalAnsi(hParameter);
                SlimDX2.Result __result__;
                fixed (void* pLiteral_ = &pLiteral)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 58 * 4, (void*)hParameter_, pLiteral_);
                Marshal.FreeHGlobal(hParameter_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Compile an effect.	
        /// </summary>	
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="ppEffect"> Buffer containing the compiled effect. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.Buffer"/>. </param>
        /// <param name="ppErrorMsgs"> Buffer containing at least the first compile error message that occurred. This includes effect compiler errors and high-level language compile errors. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.Buffer"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the arguments are invalid, the method will return D3DERR_INVALIDCALL. If the method fails, the return value will be E_FAIL. </returns>
        /// <unmanaged>HRESULT CompileEffect([None] int Flags,[None] LPD3DXBUFFER* ppEffect,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
        public SlimDX2.Result CompileEffect(int flags, out SlimDX2.Direct3D9.Buffer ppEffect, out SlimDX2.Direct3D9.Buffer ppErrorMsgs) {
            unsafe {
                IntPtr ppEffect_ = IntPtr.Zero;
                IntPtr ppErrorMsgs_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 59 * 4, flags, &ppEffect_, &ppErrorMsgs_);
                ppEffect = (ppEffect_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppEffect_);	
                ppErrorMsgs = (ppErrorMsgs_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorMsgs_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Compiles a shader from an effect that contains one or more functions.	
        /// </summary>	
        /// <remarks>	
        ///  Targets can be specified for vertex shaders, pixel shaders, and texture fill functions.  Vertex shader targetsvs_1_1, vs_2_0, vs_2_sw, vs_3_0 Pixel shader targetsps_1_1, ps_1_2, ps_1_3, ps_1_4, ps_2_0, ps_2_sw, ps_3_0 Texture fill targetstx_0, tx_1    This method compiles a shader from a function that is written in a C-like language. For more information, see {{HLSL}}. 	
        /// </remarks>	
        /// <param name="hFunction"> Unique identifier to the function to be compiled. This value must not be NULL. See {{Handles (Direct3D 9)}}. </param>
        /// <param name="pTarget"> Pointer to a shader profile which determines the shader instruction set. See {{D3DXGetVertexShaderProfile}} or {{D3DXGetPixelShaderProfile}} for a list of the profiles available. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="ppShader"> Buffer containing the compiled shader. The compiler shader is an array of DWORDs. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.Buffer"/>. </param>
        /// <param name="ppErrorMsgs"> Buffer containing at least the first compile error message that occurred. This includes effect compiler errors and high-level language compile errors. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.Buffer"/>. </param>
        /// <param name="ppConstantTable"> Returns an <see cref="SlimDX2.Direct3D9.ConstantTable"/> interface, which can be used to access shader constants. This value can be NULL. If you compile your application as large address aware (that is, you use the /LARGEADDRESSAWARE linker option to handle addresses larger than 2 GB), you cannot use this parameter and must set it to NULL. Instead, you must use the <see cref="SlimDX2.Direct3D9.D3DX9.GetShaderConstantTableEx"/> function to retrieve the shader-constant table that is embedded inside the shader. In this D3DXGetShaderConstantTableEx call, you must pass the D3DXCONSTTABLE_LARGEADDRESSAWARE flag to the Flags parameter to specify to access up to 4 GB of virtual address space. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the arguments are invalid, the method will return D3DERR_INVALIDCALL. If the method fails, the return value will be E_FAIL. </returns>
        /// <unmanaged>HRESULT CompileShader([None] D3DXHANDLE hFunction,[None] const char* pTarget,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
        public SlimDX2.Result CompileShader(string hFunction, string pTarget, int flags, out SlimDX2.Direct3D9.Buffer ppShader, out SlimDX2.Direct3D9.Buffer ppErrorMsgs, out SlimDX2.Direct3D9.ConstantTable ppConstantTable) {
            unsafe {
                IntPtr hFunction_ = Marshal.StringToHGlobalAnsi(hFunction);
                IntPtr pTarget_ = Marshal.StringToHGlobalAnsi(pTarget);
                IntPtr ppShader_ = IntPtr.Zero;
                IntPtr ppErrorMsgs_ = IntPtr.Zero;
                IntPtr ppConstantTable_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 60 * 4, (void*)hFunction_, (void*)pTarget_, flags, &ppShader_, &ppErrorMsgs_, &ppConstantTable_);
                Marshal.FreeHGlobal(hFunction_ );
                Marshal.FreeHGlobal(pTarget_ );
                ppShader = (ppShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppShader_);	
                ppErrorMsgs = (ppErrorMsgs_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorMsgs_);	
                ppConstantTable = (ppConstantTable_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ConstantTable(ppConstantTable_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXAllocateHierarchy</unmanaged>
    public partial class AllocateHierarchy : SlimDX2.CppObject {
        public AllocateHierarchy(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Requests allocation of a frame object.	
        /// </summary>	
        /// <param name="name"> Name of the frame to be created. </param>
        /// <param name="ppNewFrame"> Returns the created frame object. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from D3DERR or D3DXERR,  as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT CreateFrame([None] const char* Name,[None] LPD3DXFRAME* ppNewFrame)</unmanaged>
        public SlimDX2.Result CreateFrame(string name, ref SlimDX2.Direct3D9.Frame ppNewFrame) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D9.Frame.__Native ppNewFrame_ = new SlimDX2.Direct3D9.Frame.__Native();
                ppNewFrame.__MarshalTo(ref ppNewFrame_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 0 * 4, (void*)name_, &ppNewFrame_);
                Marshal.FreeHGlobal(name_ );
                ppNewFrame.__MarshalFrom(ref ppNewFrame_);
                ppNewFrame_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Requests allocation of a mesh container object.	
        /// </summary>	
        /// <param name="name"> Name of the mesh. </param>
        /// <param name="pMeshData"> Pointer to the mesh data structure. See <see cref="SlimDX2.Direct3D9.Meshdata"/>. </param>
        /// <param name="pMaterials"> Array of materials used in the mesh. </param>
        /// <param name="pEffectInstances"> Array of effect instances used in the mesh. See <see cref="SlimDX2.Direct3D9.Effectinstance"/>. </param>
        /// <param name="numMaterials"> Number of materials in the materials array. </param>
        /// <param name="pAdjacency"> Adjacency array for the mesh. </param>
        /// <param name="pSkinInfo"> Pointer to the skin mesh object if skin data is found. See <see cref="SlimDX2.Direct3D9.SkinInfo"/>. </param>
        /// <param name="ppNewMeshContainer"> Returns the created mesh container. See <see cref="SlimDX2.Direct3D9.Meshcontainer"/>. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message  from D3DERR or D3DXERR, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT CreateMeshContainer([None] const char* Name,[None] const D3DXMESHDATA* pMeshData,[None] const D3DXMATERIAL* pMaterials,[None] const D3DXEFFECTINSTANCE* pEffectInstances,[None] int NumMaterials,[None] const int* pAdjacency,[None] LPD3DXSKININFO pSkinInfo,[None] LPD3DXMESHCONTAINER* ppNewMeshContainer)</unmanaged>
        public SlimDX2.Result CreateMeshContainer(string name, ref SlimDX2.Direct3D9.Meshdata pMeshData, ref SlimDX2.Direct3D9.Material pMaterials, ref SlimDX2.Direct3D9.Effectinstance pEffectInstances, int numMaterials, ref int pAdjacency, SlimDX2.Direct3D9.SkinInfo pSkinInfo, ref SlimDX2.Direct3D9.Meshcontainer ppNewMeshContainer) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D9.Material.__Native pMaterials_ = new SlimDX2.Direct3D9.Material.__Native();
                pMaterials.__MarshalTo(ref pMaterials_);
                SlimDX2.Direct3D9.Effectinstance.__Native pEffectInstances_ = new SlimDX2.Direct3D9.Effectinstance.__Native();
                pEffectInstances.__MarshalTo(ref pEffectInstances_);
                SlimDX2.Direct3D9.Meshcontainer.__Native ppNewMeshContainer_ = new SlimDX2.Direct3D9.Meshcontainer.__Native();
                ppNewMeshContainer.__MarshalTo(ref ppNewMeshContainer_);
                SlimDX2.Result __result__;
                fixed (void* pMeshData_ = &pMeshData)
                    fixed (void* pAdjacency_ = &pAdjacency)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 1 * 4, (void*)name_, pMeshData_, &pMaterials_, &pEffectInstances_, numMaterials, pAdjacency_, (void*)((pSkinInfo == null)?IntPtr.Zero:pSkinInfo.NativePointer), &ppNewMeshContainer_);
                Marshal.FreeHGlobal(name_ );
                pMaterials.__MarshalFrom(ref pMaterials_);
                pMaterials_.__MarshalFree();
                pEffectInstances.__MarshalFrom(ref pEffectInstances_);
                pEffectInstances_.__MarshalFree();
                ppNewMeshContainer.__MarshalFrom(ref ppNewMeshContainer_);
                ppNewMeshContainer_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Requests deallocation of a frame object.	
        /// </summary>	
        /// <param name="pFrameToFree"> Pointer to the frame to be deallocated. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message  from D3DERR or D3DXERR, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT DestroyFrame([None] LPD3DXFRAME pFrameToFree)</unmanaged>
        public SlimDX2.Result DestroyFrame(ref SlimDX2.Direct3D9.Frame pFrameToFree) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pFrameToFree_ = new SlimDX2.Direct3D9.Frame.__Native();
                pFrameToFree.__MarshalTo(ref pFrameToFree_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 2 * 4, &pFrameToFree_);
                pFrameToFree.__MarshalFrom(ref pFrameToFree_);
                pFrameToFree_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Requests deallocation of a mesh container object.	
        /// </summary>	
        /// <param name="pMeshContainerToFree"> Pointer to the mesh container object to be deallocated. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message  from D3DERR or D3DXERR, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT DestroyMeshContainer([None] LPD3DXMESHCONTAINER pMeshContainerToFree)</unmanaged>
        public SlimDX2.Result DestroyMeshContainer(ref SlimDX2.Direct3D9.Meshcontainer pMeshContainerToFree) {
            unsafe {
                SlimDX2.Direct3D9.Meshcontainer.__Native pMeshContainerToFree_ = new SlimDX2.Direct3D9.Meshcontainer.__Native();
                pMeshContainerToFree.__MarshalTo(ref pMeshContainerToFree_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, &pMeshContainerToFree_);
                pMeshContainerToFree.__MarshalFrom(ref pMeshContainerToFree_);
                pMeshContainerToFree_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXLoadUserData</unmanaged>
    public partial class LoadUserData : SlimDX2.CppObject {
        public LoadUserData(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Load top level data from a .x file.	
        /// </summary>	
        /// <param name="pXofChildData"> Pointer to a .x file data structure. This is defined in Dxfile.h. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from D3DERR or D3DXERR, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT LoadTopLevelData([None] LPD3DXFILEDATA pXofChildData)</unmanaged>
        public SlimDX2.Result LoadTopLevelData(SlimDX2.Direct3D9.FileData pXofChildData) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 0 * 4, (void*)((pXofChildData == null)?IntPtr.Zero:pXofChildData.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Load frame child data from a .x file.	
        /// </summary>	
        /// <param name="pFrame"> Pointer to a mesh container. See <see cref="SlimDX2.Direct3D9.Frame"/>. </param>
        /// <param name="pXofChildData"> Pointer to a .x file data structure. This is defined in Dxfile.h. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from D3DERR or D3DXERR, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error.  </returns>
        /// <unmanaged>HRESULT LoadFrameChildData([None] LPD3DXFRAME pFrame,[None] LPD3DXFILEDATA pXofChildData)</unmanaged>
        public SlimDX2.Result LoadFrameChildData(ref SlimDX2.Direct3D9.Frame pFrame, SlimDX2.Direct3D9.FileData pXofChildData) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pFrame_ = new SlimDX2.Direct3D9.Frame.__Native();
                pFrame.__MarshalTo(ref pFrame_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 1 * 4, &pFrame_, (void*)((pXofChildData == null)?IntPtr.Zero:pXofChildData.NativePointer));
                pFrame.__MarshalFrom(ref pFrame_);
                pFrame_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Load mesh child data from a .x file.	
        /// </summary>	
        /// <param name="pMeshContainer"> Pointer to a mesh container. See <see cref="SlimDX2.Direct3D9.Meshcontainer"/>. </param>
        /// <param name="pXofChildData"> Pointer to a .x file data structure. This is defined in Dxfile.h. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from D3DERR or D3DXERR, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT LoadMeshChildData([None] LPD3DXMESHCONTAINER pMeshContainer,[None] LPD3DXFILEDATA pXofChildData)</unmanaged>
        public SlimDX2.Result LoadMeshChildData(ref SlimDX2.Direct3D9.Meshcontainer pMeshContainer, SlimDX2.Direct3D9.FileData pXofChildData) {
            unsafe {
                SlimDX2.Direct3D9.Meshcontainer.__Native pMeshContainer_ = new SlimDX2.Direct3D9.Meshcontainer.__Native();
                pMeshContainer.__MarshalTo(ref pMeshContainer_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 2 * 4, &pMeshContainer_, (void*)((pXofChildData == null)?IntPtr.Zero:pXofChildData.NativePointer));
                pMeshContainer.__MarshalFrom(ref pMeshContainer_);
                pMeshContainer_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXSaveUserData</unmanaged>
    public partial class SaveUserData : SlimDX2.CppObject {
        public SaveUserData(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Add child data to the frame.	
        /// </summary>	
        /// <remarks>	
        ///   <see cref="SlimDX2.Direct3D9.SaveUserData.RegisterTemplates"/> and <see cref="SlimDX2.Direct3D9.SaveUserData.SaveTemplates"/> provide a mechanism for adding a template to a .x file for saving user data. 	
        /// </remarks>	
        /// <param name="pFrame"> Pointer to a mesh container. See <see cref="SlimDX2.Direct3D9.Frame"/>. </param>
        /// <param name="pXofSave"> Pointer to a .x file save object. Use the pointer to call <see cref="SlimDX2.Direct3D9.FileSaveObject.AddDataObject"/> to add a child data object. Do not save the data with <see cref="SlimDX2.Direct3D9.FileSaveObject.Save"/>. </param>
        /// <param name="pXofFrameData"> Pointer to a .x file data node. Use the pointer to call <see cref="SlimDX2.Direct3D9.FileSaveData.AddDataObject"/> to add a child data object. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT AddFrameChildData([None] const D3DXFRAME* pFrame,[None] LPD3DXFILESAVEOBJECT pXofSave,[None] LPD3DXFILESAVEDATA pXofFrameData)</unmanaged>
        public SlimDX2.Result AddFrameChildData(ref SlimDX2.Direct3D9.Frame pFrame, SlimDX2.Direct3D9.FileSaveObject pXofSave, SlimDX2.Direct3D9.FileSaveData pXofFrameData) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pFrame_ = new SlimDX2.Direct3D9.Frame.__Native();
                pFrame.__MarshalTo(ref pFrame_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 0 * 4, &pFrame_, (void*)((pXofSave == null)?IntPtr.Zero:pXofSave.NativePointer), (void*)((pXofFrameData == null)?IntPtr.Zero:pXofFrameData.NativePointer));
                pFrame.__MarshalFrom(ref pFrame_);
                pFrame_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Add child data to the mesh.	
        /// </summary>	
        /// <param name="pMeshContainer"> Pointer to a mesh container. See <see cref="SlimDX2.Direct3D9.Meshcontainer"/>. </param>
        /// <param name="pXofSave"> Pointer to a .x file save object. Use the pointer to call <see cref="SlimDX2.Direct3D9.FileSaveObject.AddDataObject"/> to add a child data object. Do not save the data with <see cref="SlimDX2.Direct3D9.FileSaveObject.Save"/>. </param>
        /// <param name="pXofMeshData"> Pointer to a .x file data node. Use the pointer to call <see cref="SlimDX2.Direct3D9.FileSaveData.AddDataObject"/> to add a child data object. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT AddMeshChildData([None] const D3DXMESHCONTAINER* pMeshContainer,[None] LPD3DXFILESAVEOBJECT pXofSave,[None] LPD3DXFILESAVEDATA pXofMeshData)</unmanaged>
        public SlimDX2.Result AddMeshChildData(ref SlimDX2.Direct3D9.Meshcontainer pMeshContainer, SlimDX2.Direct3D9.FileSaveObject pXofSave, SlimDX2.Direct3D9.FileSaveData pXofMeshData) {
            unsafe {
                SlimDX2.Direct3D9.Meshcontainer.__Native pMeshContainer_ = new SlimDX2.Direct3D9.Meshcontainer.__Native();
                pMeshContainer.__MarshalTo(ref pMeshContainer_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 1 * 4, &pMeshContainer_, (void*)((pXofSave == null)?IntPtr.Zero:pXofSave.NativePointer), (void*)((pXofMeshData == null)?IntPtr.Zero:pXofMeshData.NativePointer));
                pMeshContainer.__MarshalFrom(ref pMeshContainer_);
                pMeshContainer_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Add a top level object before the frame hierarchy.	
        /// </summary>	
        /// <param name="pXofSave"> Pointer to a .x file save object. Use this pointer to call {{IDirectXFileSaveObject::CreateDataObject}} to create the data object to be saved. Then call {{IDirectXFileSaveObject::SaveData}} to save the data. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT AddTopLevelDataObjectsPre([None] LPD3DXFILESAVEOBJECT pXofSave)</unmanaged>
        public SlimDX2.Result AddTopLevelDataObjectsPre(SlimDX2.Direct3D9.FileSaveObject pXofSave) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 2 * 4, (void*)((pXofSave == null)?IntPtr.Zero:pXofSave.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Add a top level object after the frame hierarchy.	
        /// </summary>	
        /// <param name="pXofSave"> Pointer to a .x file save object. Use this pointer to call {{IDirectXFileSaveObject::CreateDataObject}} to create the data object to be saved. Then call {{IDirectXFileSaveObject::SaveData}} to save the data. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT AddTopLevelDataObjectsPost([None] LPD3DXFILESAVEOBJECT pXofSave)</unmanaged>
        public SlimDX2.Result AddTopLevelDataObjectsPost(SlimDX2.Direct3D9.FileSaveObject pXofSave) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4, (void*)((pXofSave == null)?IntPtr.Zero:pXofSave.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback for the user to register a .x file template.	
        /// </summary>	
        /// <remarks>	
        ///  ID3DXSaveUserData::RegisterTemplates and <see cref="SlimDX2.Direct3D9.SaveUserData.SaveTemplates"/> provide a mechanism for adding a template to a .x file for saving user data. 	
        /// </remarks>	
        /// <param name="pXFileApi"> Use this pointer to register user-defined .x file templates. See <see cref="SlimDX2.Direct3D9.File"/>. Do not use this parameter to add data objects. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT RegisterTemplates([None] LPD3DXFILE pXFileApi)</unmanaged>
        public SlimDX2.Result RegisterTemplates(SlimDX2.Direct3D9.File pXFileApi) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)((pXFileApi == null)?IntPtr.Zero:pXFileApi.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// A callback for the user to save a .x file template.	
        /// </summary>	
        /// <remarks>	
        ///   <see cref="SlimDX2.Direct3D9.SaveUserData.RegisterTemplates"/> and ID3DXSaveUserData::SaveTemplates provide a mechanism for adding a template to a .x file for saving user data. 	
        /// </remarks>	
        /// <param name="pXofSave"> Pointer to a .x file save object. Do not use this parameter to add data objects. See <see cref="SlimDX2.Direct3D9.FileSaveObject"/>. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}, as this will cause {{D3DXLoadMeshHierarchyFromX}} to fail also, and return the error. </returns>
        /// <unmanaged>HRESULT SaveTemplates([None] LPD3DXFILESAVEOBJECT pXofSave)</unmanaged>
        public SlimDX2.Result SaveTemplates(SlimDX2.Direct3D9.FileSaveObject pXofSave) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)((pXofSave == null)?IntPtr.Zero:pXofSave.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXAnimationSet</unmanaged>
    [Guid("698cfb3f-9289-4d95-9a57-33a94b5a65f9")]
    public partial class AnimationSet : SlimDX2.ComObject {
        public AnimationSet(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the animation set name.	
        /// </summary>	
        /// <unmanaged>const char* GetName()</unmanaged>
        public IntPtr Name {
                get { return GetName(); }
        }
        
        /// <summary>	
        /// Gets the period of the animation set.	
        /// </summary>	
        /// <remarks>	
        ///  The period is the range of time that the animation key frames are valid. For looping animations, this is the period of the loop. The time units that the key frames are specified in (for example, seconds) is determined by the application.  	
        /// </remarks>	
        /// <unmanaged>DOUBLE GetPeriod()</unmanaged>
        public double Period {
                get { return GetPeriod(); }
        }
        
        /// <summary>	
        /// Gets the number of animations in the animation set.	
        /// </summary>	
        /// <unmanaged>UINT GetNumAnimations()</unmanaged>
        public int NumAnimations {
                get { return GetNumAnimations(); }
        }
        
        /// <summary>	
        /// Gets the animation set name.	
        /// </summary>	
        /// <returns>  {{LPCSTR}}  Name of the animation set. </returns>
        /// <unmanaged>const char* GetName()</unmanaged>
        internal IntPtr GetName() {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the period of the animation set.	
        /// </summary>	
        /// <remarks>	
        ///  The period is the range of time that the animation key frames are valid. For looping animations, this is the period of the loop. The time units that the key frames are specified in (for example, seconds) is determined by the application.  	
        /// </remarks>	
        /// <returns>  {{DOUBLE}}  Period of the animation set. </returns>
        /// <unmanaged>DOUBLE GetPeriod()</unmanaged>
        internal double GetPeriod() {
            unsafe {
                double __result__;
                __result__= (double)SlimDX2.Direct3D9.LocalInterop.CalliSystemDouble(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns time position in the local timeframe of an animation set.	
        /// </summary>	
        /// <remarks>	
        ///  The time position returned by this method can be used as the PeriodicPosition parameter of <see cref="SlimDX2.Direct3D9.AnimationSet.GetSRT"/>. 	
        /// </remarks>	
        /// <param name="position"> Local time of the animation set. </param>
        /// <returns>  {{DOUBLE}}  Time position as measured in the timeframe of the animation set. This value will be bounded by the period of the animation set. </returns>
        /// <unmanaged>DOUBLE GetPeriodicPosition([None] DOUBLE Position)</unmanaged>
        public double GetPeriodicPosition(double position) {
            unsafe {
                double __result__;
                __result__= (double)SlimDX2.Direct3D9.LocalInterop.CalliSystemDouble(_nativePointer, 5 * 4, position);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of animations in the animation set.	
        /// </summary>	
        /// <returns>  {{UINT}}  Number of animations in the animation set. </returns>
        /// <unmanaged>UINT GetNumAnimations()</unmanaged>
        internal int GetNumAnimations() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the name of an animation, given its index.	
        /// </summary>	
        /// <param name="index"> Index of the animation. </param>
        /// <param name="ppName"> Address of a pointer to a string that receives the animation name. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}. </returns>
        /// <unmanaged>HRESULT GetAnimationNameByIndex([None] UINT Index,[Out] const char** ppName)</unmanaged>
        public SlimDX2.Result GetAnimationNameByIndex(int index, IntPtr ppName) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, index, (void*)ppName);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the index of an animation, given its name.	
        /// </summary>	
        /// <param name="pName"> Name of the animation. </param>
        /// <param name="pIndex"> Pointer to the animation index. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}. </returns>
        /// <unmanaged>HRESULT GetAnimationIndexByName([Out] const char* pName,[Out] UINT* pIndex)</unmanaged>
        public SlimDX2.Result GetAnimationIndexByName(IntPtr pName, out int pIndex) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pIndex_ = &pIndex)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, (void*)pName, pIndex_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the scale, rotation, and translation values of the animation set.	
        /// </summary>	
        /// <param name="periodicPosition"> Position of the animation set. The position can be obtained by calling <see cref="SlimDX2.Direct3D9.AnimationSet.GetPeriodicPosition"/>. </param>
        /// <param name="animation"> Animation index. </param>
        /// <param name="pScale"> Pointer to the <see cref="SlimMath.Vector3"/> vector that describes the scale of the animation set. </param>
        /// <param name="pRotation"> Pointer to the <see cref="SlimMath.Quaternion"/> quaternion that describes the rotation of the animation set. </param>
        /// <param name="pTranslation"> Pointer to the <see cref="SlimMath.Vector3"/> vector that describes the translation of the animation set. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}. </returns>
        /// <unmanaged>HRESULT GetSRT([None] DOUBLE PeriodicPosition,[None] UINT Animation,[Out] D3DXVECTOR3* pScale,[Out] D3DXQUATERNION* pRotation,[Out] D3DXVECTOR3* pTranslation)</unmanaged>
        public SlimDX2.Result GetSRT(double periodicPosition, int animation, out SlimMath.Vector3 pScale, out SlimMath.Quaternion pRotation, out SlimMath.Vector3 pTranslation) {
            unsafe {
                pScale = new SlimMath.Vector3();
                pRotation = new SlimMath.Quaternion();
                pTranslation = new SlimMath.Vector3();
                SlimDX2.Result __result__;
                fixed (void* pScale_ = &pScale)
                    fixed (void* pRotation_ = &pRotation)
                        fixed (void* pTranslation_ = &pTranslation)
                            __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, periodicPosition, animation, pScale_, pRotation_, pTranslation_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets information about a specific callback in the animation set.	
        /// </summary>	
        /// <param name="position"> Position from which to find callbacks. </param>
        /// <param name="flags"> Callback search flags. This parameter can be set to a combination of one or more flags from <see cref="SlimDX2.Direct3D9.CallbackSearchFlags"/>. </param>
        /// <param name="pCallbackPosition"> Pointer to the position of the callback. </param>
        /// <param name="ppCallbackData"> Address of the callback data pointer. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message from {{D3DERR}} or {{D3DXERR}}. </returns>
        /// <unmanaged>HRESULT GetCallback([None] DOUBLE Position,[None] int Flags,[Out] DOUBLE* pCallbackPosition,[None] void** ppCallbackData)</unmanaged>
        public SlimDX2.Result GetCallback(double position, int flags, out double pCallbackPosition, IntPtr ppCallbackData) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pCallbackPosition_ = &pCallbackPosition)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4, position, flags, pCallbackPosition_, (void*)ppCallbackData);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXKeyframedAnimationSet</unmanaged>
    [Guid("fa4e8e3a-9786-407d-8b4c-5995893764af")]
    public partial class KeyframedAnimationSet : SlimDX2.Direct3D9.AnimationSet {
        public KeyframedAnimationSet(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the type of the animation set playback loop.	
        /// </summary>	
        /// <unmanaged>D3DXPLAYBACK_TYPE GetPlaybackType()</unmanaged>
        public SlimDX2.Direct3D9.PlaybackType PlaybackType {
                get { return GetPlaybackType(); }
        }
        
        /// <summary>	
        /// Gets the number of animation key frame ticks that occur per second.	
        /// </summary>	
        /// <unmanaged>DOUBLE GetSourceTicksPerSecond()</unmanaged>
        public double SourceTicksPerSecond {
                get { return GetSourceTicksPerSecond(); }
        }
        
        /// <summary>	
        /// Gets the number of callback keys in the animation set.	
        /// </summary>	
        /// <unmanaged>UINT GetNumCallbackKeys()</unmanaged>
        public int NumCallbackKeys {
                get { return GetNumCallbackKeys(); }
        }
        
        /// <summary>	
        /// Gets the type of the animation set playback loop.	
        /// </summary>	
        /// <returns>  <see cref="SlimDX2.Direct3D9.PlaybackType"/>  Type of the animation set playback loop. See <see cref="SlimDX2.Direct3D9.PlaybackType"/>. </returns>
        /// <unmanaged>D3DXPLAYBACK_TYPE GetPlaybackType()</unmanaged>
        internal SlimDX2.Direct3D9.PlaybackType GetPlaybackType() {
            unsafe {
                SlimDX2.Direct3D9.PlaybackType __result__;
                __result__= (SlimDX2.Direct3D9.PlaybackType)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of animation key frame ticks that occur per second.	
        /// </summary>	
        /// <returns>  {{DOUBLE}}  Number of animation key frame ticks that occur per second. </returns>
        /// <unmanaged>DOUBLE GetSourceTicksPerSecond()</unmanaged>
        internal double GetSourceTicksPerSecond() {
            unsafe {
                double __result__;
                __result__= (double)SlimDX2.Direct3D9.LocalInterop.CalliSystemDouble(_nativePointer, 12 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of scale keys in the specified key frame animation.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <returns>  {{UINT}}  Number of scale keys in the specified key frame animation. </returns>
        /// <unmanaged>UINT GetNumScaleKeys([None] UINT Animation)</unmanaged>
        public int GetNumScaleKeys(int animation) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, animation);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Fills an array with scale key data used for key frame animation.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="pScaleKeys"> Pointer to a user-allocated array of <see cref="SlimDX2.Direct3D9.KeyVector3"/> vectors that the method is to fill with animation scale data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetScaleKeys([None] UINT Animation,[None] LPD3DXKEY_VECTOR3 pScaleKeys)</unmanaged>
        public SlimDX2.Result GetScaleKeys(int animation, ref SlimDX2.Direct3D9.KeyVector3 pScaleKeys) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pScaleKeys_ = &pScaleKeys)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4, animation, pScaleKeys_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get scale information for a specific key frame in the animation set.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="key"> Key frame. </param>
        /// <param name="pScaleKey"> Pointer to the scale data. See  <see cref="SlimDX2.Direct3D9.KeyVector3"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetScaleKey([None] UINT Animation,[None] UINT Key,[None] LPD3DXKEY_VECTOR3 pScaleKey)</unmanaged>
        public SlimDX2.Result GetScaleKey(int animation, int key, ref SlimDX2.Direct3D9.KeyVector3 pScaleKey) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pScaleKey_ = &pScaleKey)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, animation, key, pScaleKey_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set scale information for a specific key frame in the animation set.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="key"> Key frame. </param>
        /// <param name="pScaleKey"> Pointer to the scale data. See <see cref="SlimDX2.Direct3D9.KeyVector3"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetScaleKey([None] UINT Animation,[None] UINT Key,[None] LPD3DXKEY_VECTOR3 pScaleKey)</unmanaged>
        public SlimDX2.Result SetScaleKey(int animation, int key, ref SlimDX2.Direct3D9.KeyVector3 pScaleKey) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pScaleKey_ = &pScaleKey)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, animation, key, pScaleKey_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of rotation keys in the specified key frame animation.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <returns>  {{UINT}}  Number of rotation keys in the specified key frame animation. </returns>
        /// <unmanaged>UINT GetNumRotationKeys([None] UINT Animation)</unmanaged>
        public int GetNumRotationKeys(int animation) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, animation);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Fills an array with rotational key data used for key frame animation.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="pRotationKeys"> Pointer to a user-allocated array of <see cref="SlimDX2.Direct3D9.KeyQuaternion"/> quaternions that the method is to fill with animation rotation data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetRotationKeys([None] UINT Animation,[None] LPD3DXKEY_QUATERNION pRotationKeys)</unmanaged>
        public SlimDX2.Result GetRotationKeys(int animation, ref SlimDX2.Direct3D9.KeyQuaternion pRotationKeys) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pRotationKeys_ = &pRotationKeys)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, animation, pRotationKeys_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get rotation information for a specific key frame in the animation set.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="key"> Key frame. </param>
        /// <param name="pRotationKey"> Pointer to the rotation data. See  <see cref="SlimDX2.Direct3D9.KeyQuaternion"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetRotationKey([None] UINT Animation,[None] UINT Key,[None] LPD3DXKEY_QUATERNION pRotationKey)</unmanaged>
        public SlimDX2.Result GetRotationKey(int animation, int key, ref SlimDX2.Direct3D9.KeyQuaternion pRotationKey) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pRotationKey_ = &pRotationKey)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, animation, key, pRotationKey_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set rotation information for a specific key frame in the animation set.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="key"> Key frame. </param>
        /// <param name="pRotationKey"> Pointer to the rotation data. See <see cref="SlimDX2.Direct3D9.KeyVector3"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetRotationKey([None] UINT Animation,[None] UINT Key,[None] LPD3DXKEY_QUATERNION pRotationKey)</unmanaged>
        public SlimDX2.Result SetRotationKey(int animation, int key, ref SlimDX2.Direct3D9.KeyQuaternion pRotationKey) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pRotationKey_ = &pRotationKey)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, animation, key, pRotationKey_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of translation keys in the specified key frame animation.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <returns>  {{UINT}}  Number of translation keys in the specified key frame animation. </returns>
        /// <unmanaged>UINT GetNumTranslationKeys([None] UINT Animation)</unmanaged>
        public int GetNumTranslationKeys(int animation) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, animation);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Fills an array with translational key data used for key frame animation.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="pTranslationKeys"> Pointer to a user-allocated array of <see cref="SlimDX2.Direct3D9.KeyVector3"/> vectors that the method is to fill with animation translation data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetTranslationKeys([None] UINT Animation,[None] LPD3DXKEY_VECTOR3 pTranslationKeys)</unmanaged>
        public SlimDX2.Result GetTranslationKeys(int animation, ref SlimDX2.Direct3D9.KeyVector3 pTranslationKeys) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pTranslationKeys_ = &pTranslationKeys)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 22 * 4, animation, pTranslationKeys_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get translation information for a specific key frame in the animation set.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="key"> Key Frame. </param>
        /// <param name="pTranslationKey"> Pointer to the rotation information. See <see cref="SlimDX2.Direct3D9.KeyVector3"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetTranslationKey([None] UINT Animation,[None] UINT Key,[None] LPD3DXKEY_VECTOR3 pTranslationKey)</unmanaged>
        public SlimDX2.Result GetTranslationKey(int animation, int key, ref SlimDX2.Direct3D9.KeyVector3 pTranslationKey) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pTranslationKey_ = &pTranslationKey)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, animation, key, pTranslationKey_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set translation information for a specific key frame in the animation set.	
        /// </summary>	
        /// <param name="animation"> Animation index. </param>
        /// <param name="key"> Key Frame. </param>
        /// <param name="pTranslationKey"> Pointer to the translation data. See <see cref="SlimDX2.Direct3D9.KeyVector3"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetTranslationKey([None] UINT Animation,[None] UINT Key,[None] LPD3DXKEY_VECTOR3 pTranslationKey)</unmanaged>
        public SlimDX2.Result SetTranslationKey(int animation, int key, ref SlimDX2.Direct3D9.KeyVector3 pTranslationKey) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pTranslationKey_ = &pTranslationKey)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, animation, key, pTranslationKey_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of callback keys in the animation set.	
        /// </summary>	
        /// <returns>  {{UINT}}  Number of callback keys in the animation set. </returns>
        /// <unmanaged>UINT GetNumCallbackKeys()</unmanaged>
        internal int GetNumCallbackKeys() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Fills an array with callback key data used for key frame animation.	
        /// </summary>	
        /// <param name="pCallbackKeys"> Pointer to a user-allocated array of <see cref="SlimDX2.Direct3D9.KeyCallback"/> structures that the method is to fill with callback data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetCallbackKeys([None] LPD3DXKEY_CALLBACK pCallbackKeys)</unmanaged>
        public SlimDX2.Result GetCallbackKeys(ref SlimDX2.Direct3D9.KeyCallback pCallbackKeys) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pCallbackKeys_ = &pCallbackKeys)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 26 * 4, pCallbackKeys_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets information about a specific callback in the animation set.	
        /// </summary>	
        /// <param name="key"> Animation index. </param>
        /// <param name="pCallbackKey"> Pointer to the {{callback function}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetCallbackKey([None] UINT Key,[None] LPD3DXKEY_CALLBACK pCallbackKey)</unmanaged>
        public SlimDX2.Result GetCallbackKey(int key, ref SlimDX2.Direct3D9.KeyCallback pCallbackKey) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pCallbackKey_ = &pCallbackKey)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 27 * 4, key, pCallbackKey_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets information about a specific callback in the animation set.	
        /// </summary>	
        /// <param name="key"> Animation index. </param>
        /// <param name="pCallbackKey"> Pointer to the {{callback function}}. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetCallbackKey([None] UINT Key,[None] LPD3DXKEY_CALLBACK pCallbackKey)</unmanaged>
        public SlimDX2.Result SetCallbackKey(int key, ref SlimDX2.Direct3D9.KeyCallback pCallbackKey) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pCallbackKey_ = &pCallbackKey)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 28 * 4, key, pCallbackKey_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Removes the scale data at the specified key frame.	
        /// </summary>	
        /// <remarks>	
        ///  This method is slow and should not be used after an animation has begun to play. 	
        /// </remarks>	
        /// <param name="animation"> Animation identifier. </param>
        /// <param name="key"> Key frame. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT UnregisterScaleKey([None] UINT Animation,[None] UINT Key)</unmanaged>
        public SlimDX2.Result UnregisterScaleKey(int animation, int key) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 29 * 4, animation, key);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Removes the rotation data at the specified key frame.	
        /// </summary>	
        /// <remarks>	
        ///  This method is slow and should not be used after an animation has begun to play. 	
        /// </remarks>	
        /// <param name="animation"> Animation identifier. </param>
        /// <param name="key"> Key frame. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT UnregisterRotationKey([None] UINT Animation,[None] UINT Key)</unmanaged>
        public SlimDX2.Result UnregisterRotationKey(int animation, int key) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 30 * 4, animation, key);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Removes the translation data at the specified key frame.	
        /// </summary>	
        /// <remarks>	
        ///  This method is slow and should not be used after an animation has begun to play. 	
        /// </remarks>	
        /// <param name="animation"> Animation identifier. </param>
        /// <param name="key"> Key frame. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT UnregisterTranslationKey([None] UINT Animation,[None] UINT Key)</unmanaged>
        public SlimDX2.Result UnregisterTranslationKey(int animation, int key) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 31 * 4, animation, key);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Register the scale, rotate, and translate (SRT) key frame data for an animation.	
        /// </summary>	
        /// <param name="pName"> Pointer to the animation name. </param>
        /// <param name="numScaleKeys"> Number of scale keys. </param>
        /// <param name="numRotationKeys"> Number of rotation keys. </param>
        /// <param name="numTranslationKeys"> Number of translation keys. </param>
        /// <param name="pScaleKeys"> Address of a pointer to a user-allocated array of <see cref="SlimDX2.Direct3D9.KeyVector3"/> vectors that the method fills with scale data. </param>
        /// <param name="pRotationKeys"> Address of a pointer to a user-allocated array of <see cref="SlimDX2.Direct3D9.KeyQuaternion"/> quaternions that the method fills with rotation data. </param>
        /// <param name="pTranslationKeys"> Address of a pointer to a user-allocated array of <see cref="SlimDX2.Direct3D9.KeyVector3"/> vectors that the method fills with translation data. </param>
        /// <param name="pAnimationIndex"> Returns the animation index. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT RegisterAnimationSRTKeys([None] const char* pName,[None] UINT NumScaleKeys,[None] UINT NumRotationKeys,[None] UINT NumTranslationKeys,[None] const D3DXKEY_VECTOR3* pScaleKeys,[None] const D3DXKEY_QUATERNION* pRotationKeys,[None] const D3DXKEY_VECTOR3* pTranslationKeys,[None] int* pAnimationIndex)</unmanaged>
        public SlimDX2.Result RegisterAnimationSRTKeys(string pName, int numScaleKeys, int numRotationKeys, int numTranslationKeys, ref SlimDX2.Direct3D9.KeyVector3 pScaleKeys, ref SlimDX2.Direct3D9.KeyQuaternion pRotationKeys, ref SlimDX2.Direct3D9.KeyVector3 pTranslationKeys, ref int pAnimationIndex) {
            unsafe {
                IntPtr pName_ = Marshal.StringToHGlobalAnsi(pName);
                SlimDX2.Result __result__;
                fixed (void* pScaleKeys_ = &pScaleKeys)
                    fixed (void* pRotationKeys_ = &pRotationKeys)
                        fixed (void* pTranslationKeys_ = &pTranslationKeys)
                            fixed (void* pAnimationIndex_ = &pAnimationIndex)
                                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 32 * 4, (void*)pName_, numScaleKeys, numRotationKeys, numTranslationKeys, pScaleKeys_, pRotationKeys_, pTranslationKeys_, pAnimationIndex_);
                Marshal.FreeHGlobal(pName_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Transforms animations in an animation set into a compressed format and returns a pointer to the buffer that stores the compressed data.	
        /// </summary>	
        /// <param name="flags"> One of the <see cref="SlimDX2.Direct3D9.CompressionFlags"/> values that define the compression mode used for storing compressed animation set data. D3DXCOMPRESS_DEFAULT is the only value currently supported. </param>
        /// <param name="lossiness"> Desired compression loss ratio, in the range from 0 to 1. </param>
        /// <param name="pHierarchy"> Pointer to a <see cref="SlimDX2.Direct3D9.Frame"/> transformation frame hierarchy. Can be NULL. </param>
        /// <param name="ppCompressedData"> Address of a pointer to the <see cref="SlimDX2.Direct3D9.Buffer"/> compressed animation set. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT Compress([None] int Flags,[None] FLOAT Lossiness,[None] LPD3DXFRAME pHierarchy,[None] LPD3DXBUFFER* ppCompressedData)</unmanaged>
        public SlimDX2.Result Compress(int flags, float lossiness, ref SlimDX2.Direct3D9.Frame pHierarchy, out SlimDX2.Direct3D9.Buffer ppCompressedData) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pHierarchy_ = new SlimDX2.Direct3D9.Frame.__Native();
                pHierarchy.__MarshalTo(ref pHierarchy_);
                IntPtr ppCompressedData_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 33 * 4, flags, lossiness, &pHierarchy_, &ppCompressedData_);
                pHierarchy.__MarshalFrom(ref pHierarchy_);
                pHierarchy_.__MarshalFree();
                ppCompressedData = (ppCompressedData_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppCompressedData_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Remove the animation data from the animation set.	
        /// </summary>	
        /// <param name="index"> The animation index. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT UnregisterAnimation([None] UINT Index)</unmanaged>
        public SlimDX2.Result UnregisterAnimation(int index) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 34 * 4, index);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXCompressedAnimationSet</unmanaged>
    [Guid("6cc2480d-3808-4739-9f88-de49facd8d4c")]
    public partial class CompressedAnimationSet : SlimDX2.Direct3D9.AnimationSet {
        public CompressedAnimationSet(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the type of the animation set playback loop.	
        /// </summary>	
        /// <unmanaged>D3DXPLAYBACK_TYPE GetPlaybackType()</unmanaged>
        public SlimDX2.Direct3D9.PlaybackType PlaybackType {
                get { return GetPlaybackType(); }
        }
        
        /// <summary>	
        /// Gets the number of animation key frame ticks that occur per second.	
        /// </summary>	
        /// <unmanaged>DOUBLE GetSourceTicksPerSecond()</unmanaged>
        public double SourceTicksPerSecond {
                get { return GetSourceTicksPerSecond(); }
        }
        
        /// <summary>	
        /// Gets the data buffer that stores compressed key frame animation data.	
        /// </summary>	
        /// <unmanaged>HRESULT GetCompressedData([Out] LPD3DXBUFFER* ppCompressedData)</unmanaged>
        public SlimDX2.Direct3D9.Buffer CompressedData {
                get { SlimDX2.Direct3D9.Buffer __output__; GetCompressedData(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the number of callback keys in the animation set.	
        /// </summary>	
        /// <unmanaged>UINT GetNumCallbackKeys()</unmanaged>
        public int NumCallbackKeys {
                get { return GetNumCallbackKeys(); }
        }
        
        /// <summary>	
        /// Gets the type of the animation set playback loop.	
        /// </summary>	
        /// <returns>  <see cref="SlimDX2.Direct3D9.PlaybackType"/>  Type of the animation set playback loop. See <see cref="SlimDX2.Direct3D9.PlaybackType"/>. </returns>
        /// <unmanaged>D3DXPLAYBACK_TYPE GetPlaybackType()</unmanaged>
        internal SlimDX2.Direct3D9.PlaybackType GetPlaybackType() {
            unsafe {
                SlimDX2.Direct3D9.PlaybackType __result__;
                __result__= (SlimDX2.Direct3D9.PlaybackType)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of animation key frame ticks that occur per second.	
        /// </summary>	
        /// <returns>  {{DOUBLE}}  Number of animation key frame ticks that occur per second. </returns>
        /// <unmanaged>DOUBLE GetSourceTicksPerSecond()</unmanaged>
        internal double GetSourceTicksPerSecond() {
            unsafe {
                double __result__;
                __result__= (double)SlimDX2.Direct3D9.LocalInterop.CalliSystemDouble(_nativePointer, 12 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the data buffer that stores compressed key frame animation data.	
        /// </summary>	
        /// <param name="ppCompressedData"> Address of a pointer to the <see cref="SlimDX2.Direct3D9.Buffer"/> data buffer that receives compressed key frame animation data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetCompressedData([Out] LPD3DXBUFFER* ppCompressedData)</unmanaged>
        internal SlimDX2.Result GetCompressedData(out SlimDX2.Direct3D9.Buffer ppCompressedData) {
            unsafe {
                IntPtr ppCompressedData_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, &ppCompressedData_);
                ppCompressedData = (ppCompressedData_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppCompressedData_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of callback keys in the animation set.	
        /// </summary>	
        /// <returns>  {{UINT}}  Number of callback keys in the animation set. </returns>
        /// <unmanaged>UINT GetNumCallbackKeys()</unmanaged>
        internal int GetNumCallbackKeys() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Fills an array with callback key data used for key frame animation.	
        /// </summary>	
        /// <param name="pCallbackKeys"> Pointer to a user-allocated array of <see cref="SlimDX2.Direct3D9.KeyCallback"/> structures that the method is to fill with callback data. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetCallbackKeys([None] LPD3DXKEY_CALLBACK pCallbackKeys)</unmanaged>
        public SlimDX2.Result GetCallbackKeys(ref SlimDX2.Direct3D9.KeyCallback pCallbackKeys) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pCallbackKeys_ = &pCallbackKeys)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 15 * 4, pCallbackKeys_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXAnimationCallbackHandler</unmanaged>
    public partial class AnimationCallbackHandler : SlimDX2.CppObject {
        public AnimationCallbackHandler(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// The application implements this method. This method is called when a callback occurs for an animation set in one of the tracks during a  call to <see cref="SlimDX2.Direct3D9.AnimationController.AdvanceTime"/>.	
        /// </summary>	
        /// <param name="track"> Identifier of the track on which the callback occurs. </param>
        /// <param name="pCallbackData"> Pointer to user-owned callback data. </param>
        /// <returns>  <see cref="int"/>  The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return D3D_OK. Otherwise, program the method to return an appropriate error message  from {{D3DERR}} or {{D3DXERR}}. </returns>
        /// <unmanaged>HRESULT HandleCallback([None] UINT Track,[None] void* pCallbackData)</unmanaged>
        public SlimDX2.Result HandleCallback(int track, IntPtr pCallbackData) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 0 * 4, track, (void*)pCallbackData);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>ID3DXAnimationController</unmanaged>
    [Guid("ac8948ec-f86d-43e2-96de-31fc35f96d9e")]
    public partial class AnimationController : SlimDX2.ComObject {
        public AnimationController(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the maximum number of animation outputs the animation controller can support.	
        /// </summary>	
        /// <unmanaged>UINT GetMaxNumAnimationOutputs()</unmanaged>
        public int MaxNumAnimationOutputs {
                get { return GetMaxNumAnimationOutputs(); }
        }
        
        /// <summary>	
        /// Gets the maximum number of animation sets the animation controller can support.	
        /// </summary>	
        /// <unmanaged>UINT GetMaxNumAnimationSets()</unmanaged>
        public int MaxNumAnimationSets {
                get { return GetMaxNumAnimationSets(); }
        }
        
        /// <summary>	
        /// Gets the maximum number of tracks in the animation controller.	
        /// </summary>	
        /// <remarks>	
        ///  The maximum number of tracks the controller can manage. 	
        /// </remarks>	
        /// <unmanaged>UINT GetMaxNumTracks()</unmanaged>
        public int MaxNumTracks {
                get { return GetMaxNumTracks(); }
        }
        
        /// <summary>	
        /// Gets the maximum number of events the animation controller can support.	
        /// </summary>	
        /// <unmanaged>UINT GetMaxNumEvents()</unmanaged>
        public int MaxNumEvents {
                get { return GetMaxNumEvents(); }
        }
        
        /// <summary>	
        /// Returns the number of animation sets currently registered in the animation controller.	
        /// </summary>	
        /// <remarks>	
        ///  The controller contains any number of animations sets and tracks. Animation sets can be registered with  {{RegisterAnimationOutput}}.  An animation controller created by a call  to {{D3DXLoadMeshHierarchyFromX}} will automatically register loaded animation sets. 	
        /// </remarks>	
        /// <unmanaged>UINT GetNumAnimationSets()</unmanaged>
        public int NumAnimationSets {
                get { return GetNumAnimationSets(); }
        }
        
        /// <summary>	
        /// Gets the global animation time.	
        /// </summary>	
        /// <remarks>	
        ///  Animations are designed using a local animation time and mixed into global time with {{AdvanceTime}}. 	
        /// </remarks>	
        /// <unmanaged>DOUBLE GetTime()</unmanaged>
        public double Time {
                get { return GetTime(); }
        }
        
        /// <summary>	
        /// Gets the current priority blending weight used by the animation controller.	
        /// </summary>	
        /// <remarks>	
        ///  The priority blending weight is used to blend high and low priority tracks together. 	
        /// </remarks>	
        /// <unmanaged>FLOAT GetPriorityBlend()</unmanaged>
        public float PriorityBlend {
                get { return GetPriorityBlend(); }
                set { SetPriorityBlend(value); }
        }
        
        /// <summary>	
        /// Returns an event handle to a priority blend event that is currently running.	
        /// </summary>	
        /// <unmanaged>D3DXEVENTHANDLE GetCurrentPriorityBlend()</unmanaged>
        public int CurrentPriorityBlend {
                get { return GetCurrentPriorityBlend(); }
        }
        
        /// <summary>	
        /// Get the maximum number of animation outputs the animation controller can support.	
        /// </summary>	
        /// <returns>  {{UINT}}  The maximum number of animation outputs the controller can manage. </returns>
        /// <unmanaged>UINT GetMaxNumAnimationOutputs()</unmanaged>
        internal int GetMaxNumAnimationOutputs() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the maximum number of animation sets the animation controller can support.	
        /// </summary>	
        /// <returns>  {{UINT}}  The maximum number of animation sets the controller can manage. </returns>
        /// <unmanaged>UINT GetMaxNumAnimationSets()</unmanaged>
        internal int GetMaxNumAnimationSets() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the maximum number of tracks in the animation controller.	
        /// </summary>	
        /// <remarks>	
        ///  The maximum number of tracks the controller can manage. 	
        /// </remarks>	
        /// <returns>  {{UINT}}  Number of tracks. </returns>
        /// <unmanaged>UINT GetMaxNumTracks()</unmanaged>
        internal int GetMaxNumTracks() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 5 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the maximum number of events the animation controller can support.	
        /// </summary>	
        /// <returns>  {{UINT}}  The maximum number of events the controller can manage. </returns>
        /// <unmanaged>UINT GetMaxNumEvents()</unmanaged>
        internal int GetMaxNumEvents() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 6 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds an animation output to the animation controller and registers pointers for scale, rotate, and translate (SRT) transformations.	
        /// </summary>	
        /// <remarks>	
        ///  If the animation output is already registered, pMatrix will be filled with the input transformation data. Animation sets created with {{D3DXLoadMeshHierarchyFromX}} automatically register all loaded animation sets. 	
        /// </remarks>	
        /// <param name="pName"> Name of the animation output. </param>
        /// <param name="pMatrix"> Pointer to a <see cref="SlimMath.Matrix"/> structure containing SRT transformation data. Can be NULL. </param>
        /// <param name="pScale"> Pointer to a <see cref="SlimMath.Vector3"/> vector that describes the scale of the animation set. Can be NULL. </param>
        /// <param name="pRotation"> Pointer to a <see cref="SlimMath.Quaternion"/> quaternion that describes the rotation of the animation set. Can be NULL. </param>
        /// <param name="pTranslation"> Pointer to a <see cref="SlimMath.Vector3"/> vector that describes the translation of the animation set. Can be NULL. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT RegisterAnimationOutput([None] const char* pName,[None] D3DXMATRIX* pMatrix,[None] D3DXVECTOR3* pScale,[None] D3DXQUATERNION* pRotation,[None] D3DXVECTOR3* pTranslation)</unmanaged>
        public SlimDX2.Result RegisterAnimationOutput(string pName, ref SlimMath.Matrix pMatrix, ref SlimMath.Vector3 pScale, ref SlimMath.Quaternion pRotation, ref SlimMath.Vector3 pTranslation) {
            unsafe {
                IntPtr pName_ = Marshal.StringToHGlobalAnsi(pName);
                SlimDX2.Result __result__;
                fixed (void* pMatrix_ = &pMatrix)
                    fixed (void* pScale_ = &pScale)
                        fixed (void* pRotation_ = &pRotation)
                            fixed (void* pTranslation_ = &pTranslation)
                                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)pName_, pMatrix_, pScale_, pRotation_, pTranslation_);
                Marshal.FreeHGlobal(pName_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Adds an animation set to the animation controller.	
        /// </summary>	
        /// <param name="pAnimSet"> Pointer to the <see cref="SlimDX2.Direct3D9.AnimationSet"/> animation set to add. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT RegisterAnimationSet([None] LPD3DXANIMATIONSET pAnimSet)</unmanaged>
        public SlimDX2.Result RegisterAnimationSet(SlimDX2.Direct3D9.AnimationSet pAnimSet) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 8 * 4, (void*)((pAnimSet == null)?IntPtr.Zero:pAnimSet.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Removes an animation set from the animation controller.	
        /// </summary>	
        /// <param name="pAnimSet"> Pointer to the <see cref="SlimDX2.Direct3D9.AnimationSet"/> animation set to remove. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, D3DERR_NOTFOUND. </returns>
        /// <unmanaged>HRESULT UnregisterAnimationSet([None] LPD3DXANIMATIONSET pAnimSet)</unmanaged>
        public SlimDX2.Result UnregisterAnimationSet(SlimDX2.Direct3D9.AnimationSet pAnimSet) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 9 * 4, (void*)((pAnimSet == null)?IntPtr.Zero:pAnimSet.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns the number of animation sets currently registered in the animation controller.	
        /// </summary>	
        /// <remarks>	
        ///  The controller contains any number of animations sets and tracks. Animation sets can be registered with  {{RegisterAnimationOutput}}.  An animation controller created by a call  to {{D3DXLoadMeshHierarchyFromX}} will automatically register loaded animation sets. 	
        /// </remarks>	
        /// <returns>  {{UINT}}  Number of animation sets. </returns>
        /// <unmanaged>UINT GetNumAnimationSets()</unmanaged>
        internal int GetNumAnimationSets() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 10 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an animation set.	
        /// </summary>	
        /// <remarks>	
        ///  The animation controller contains an array of animation sets. This method returns one of them at the given index. 	
        /// </remarks>	
        /// <param name="index"> Index of the animation set. </param>
        /// <param name="ppAnimationSet"> Pointer to the <see cref="SlimDX2.Direct3D9.AnimationSet"/> animation set. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetAnimationSet([None] UINT Index,[Out] LPD3DXANIMATIONSET* ppAnimationSet)</unmanaged>
        public SlimDX2.Result GetAnimationSet(int index, out SlimDX2.Direct3D9.AnimationSet ppAnimationSet) {
            unsafe {
                IntPtr ppAnimationSet_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 11 * 4, index, &ppAnimationSet_);
                ppAnimationSet = (ppAnimationSet_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.AnimationSet(ppAnimationSet_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an animation set, given its name.	
        /// </summary>	
        /// <remarks>	
        ///  The animation controller contains an array of animation sets. This method returns an animation set that has the given name. 	
        /// </remarks>	
        /// <param name="szName"> String containing the name of the animation set. </param>
        /// <param name="ppAnimationSet"> Pointer to the <see cref="SlimDX2.Direct3D9.AnimationSet"/> animation set. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetAnimationSetByName([Out] const char* szName,[Out] LPD3DXANIMATIONSET* ppAnimationSet)</unmanaged>
        public SlimDX2.Result GetAnimationSetByName(IntPtr szName, out SlimDX2.Direct3D9.AnimationSet ppAnimationSet) {
            unsafe {
                IntPtr ppAnimationSet_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 12 * 4, (void*)szName, &ppAnimationSet_);
                ppAnimationSet = (ppAnimationSet_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.AnimationSet(ppAnimationSet_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Animates the mesh and advances the global animation time by a specified amount.	
        /// </summary>	
        /// <param name="timeDelta"> Amount, in seconds, by which to advance the global animation time. TimeDelta value must be non-negative or zero. </param>
        /// <param name="pCallbackHandler"> Pointer to a user-defined animation callback handler interface, <see cref="SlimDX2.Direct3D9.AnimationCallbackHandler"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT AdvanceTime([None] DOUBLE TimeDelta,[None] LPD3DXANIMATIONCALLBACKHANDLER pCallbackHandler)</unmanaged>
        public SlimDX2.Result AdvanceTime(double timeDelta, SlimDX2.Direct3D9.AnimationCallbackHandler pCallbackHandler) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 13 * 4, timeDelta, (void*)((pCallbackHandler == null)?IntPtr.Zero:pCallbackHandler.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Resets the global animation time to zero. Any pending events will retain their original schedules, but in the new timeframe.	
        /// </summary>	
        /// <remarks>	
        ///  This method is typically used when the global animation time value is nearing the maximum precision of DOUBLE storage, or 264 - 1. 	
        /// </remarks>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT ResetTime()</unmanaged>
        public SlimDX2.Result ResetTime() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 14 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the global animation time.	
        /// </summary>	
        /// <remarks>	
        ///  Animations are designed using a local animation time and mixed into global time with {{AdvanceTime}}. 	
        /// </remarks>	
        /// <returns>  {{DOUBLE}}  Returns the global animation time. </returns>
        /// <unmanaged>DOUBLE GetTime()</unmanaged>
        internal double GetTime() {
            unsafe {
                double __result__;
                __result__= (double)SlimDX2.Direct3D9.LocalInterop.CalliSystemDouble(_nativePointer, 15 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Applies the animation set to the specified track.	
        /// </summary>	
        /// <remarks>	
        ///  This method sets the animation set to the specified track for mixing.  The animation set for each track is blended according to the  track weight and speed when {{AdvanceTime}} is called. 	
        /// </remarks>	
        /// <param name="track"> Identifier of the track to which the animation set is applied. </param>
        /// <param name="pAnimSet"> Pointer to the <see cref="SlimDX2.Direct3D9.AnimationSet"/> animation set to be added to the track. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT SetTrackAnimationSet([None] UINT Track,[None] LPD3DXANIMATIONSET pAnimSet)</unmanaged>
        public SlimDX2.Result SetTrackAnimationSet(int track, SlimDX2.Direct3D9.AnimationSet pAnimSet) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 16 * 4, track, (void*)((pAnimSet == null)?IntPtr.Zero:pAnimSet.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the animation set for the given track.	
        /// </summary>	
        /// <param name="track"> Track identifier. </param>
        /// <param name="ppAnimSet"> Pointer to the <see cref="SlimDX2.Direct3D9.AnimationSet"/> animation set for the given track. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT GetTrackAnimationSet([None] UINT Track,[Out] LPD3DXANIMATIONSET* ppAnimSet)</unmanaged>
        public SlimDX2.Result GetTrackAnimationSet(int track, out SlimDX2.Direct3D9.AnimationSet ppAnimSet) {
            unsafe {
                IntPtr ppAnimSet_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 17 * 4, track, &ppAnimSet_);
                ppAnimSet = (ppAnimSet_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.AnimationSet(ppAnimSet_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the priority blending weight for the specified animation track.	
        /// </summary>	
        /// <remarks>	
        ///  	
        /// </remarks>	
        /// <param name="track"> Track identifier. </param>
        /// <param name="priority"> Track priority. This parameter should be set to one of the constants from <see cref="SlimDX2.Direct3D9.PriorityType"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetTrackPriority([None] UINT Track,[None] D3DXPRIORITY_TYPE Priority)</unmanaged>
        public SlimDX2.Result SetTrackPriority(int track, SlimDX2.Direct3D9.PriorityType priority) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 18 * 4, track, unchecked((int)priority));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the track speed. The track speed is similar to a multiplier that is used to speed up or slow down the playback of the track.	
        /// </summary>	
        /// <param name="track"> Identifier of the track to set the speed on. </param>
        /// <param name="speed"> New speed. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT SetTrackSpeed([None] UINT Track,[None] FLOAT Speed)</unmanaged>
        public SlimDX2.Result SetTrackSpeed(int track, float speed) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 19 * 4, track, speed);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the track weight. The weight is used to determine how to blend multiple tracks together.	
        /// </summary>	
        /// <param name="track"> Identifier of the track to set the weight on. </param>
        /// <param name="weight"> Weight value. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT SetTrackWeight([None] UINT Track,[None] FLOAT Weight)</unmanaged>
        public SlimDX2.Result SetTrackWeight(int track, float weight) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 20 * 4, track, weight);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the track to the specified local animation time.	
        /// </summary>	
        /// <param name="track"> Track identifier. </param>
        /// <param name="position"> Local animation time value to assign to the track. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT SetTrackPosition([None] UINT Track,[None] DOUBLE Position)</unmanaged>
        public SlimDX2.Result SetTrackPosition(int track, double position) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 21 * 4, track, position);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Enables or disables a track in the animation controller.	
        /// </summary>	
        /// <remarks>	
        ///  To mix a track with other tracks, the Enable flag must be set to TRUE. Conversely, setting the flag to FALSE will prevent the track from being  mixed with other tracks. 	
        /// </remarks>	
        /// <param name="track"> Identifier of the track to be mixed. </param>
        /// <param name="enable"> Enable value. Set to TRUE to enable this track in the controller, or to FALSE to prevent it from being mixed. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT SetTrackEnable([None] UINT Track,[None] BOOL Enable)</unmanaged>
        public SlimDX2.Result SetTrackEnable(int track, bool enable) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 22 * 4, track, (enable?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the track description.	
        /// </summary>	
        /// <param name="track"> Identifier of the track to modify. </param>
        /// <param name="pDesc"> Description of the track. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT SetTrackDesc([None] UINT Track,[None] LPD3DXTRACK_DESC pDesc)</unmanaged>
        public SlimDX2.Result SetTrackDescription(int track, ref SlimDX2.Direct3D9.TrackDescription pDesc) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pDesc_ = &pDesc)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 23 * 4, track, pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the track description.	
        /// </summary>	
        /// <param name="track"> Track identifier. </param>
        /// <param name="pDesc"> Pointer to the track description. See <see cref="SlimDX2.Direct3D9.TrackDescription"/>. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT GetTrackDesc([None] UINT Track,[None] LPD3DXTRACK_DESC pDesc)</unmanaged>
        public SlimDX2.Result GetTrackDescription(int track, ref SlimDX2.Direct3D9.TrackDescription pDesc) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pDesc_ = &pDesc)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 24 * 4, track, pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the priority blending weight used by the animation controller.	
        /// </summary>	
        /// <remarks>	
        ///  The blend weight is used to blend high and low priority tracks together. 	
        /// </remarks>	
        /// <param name="blendWeight"> Priority blending weight used by the animation controller. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following values: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT SetPriorityBlend([None] FLOAT BlendWeight)</unmanaged>
        internal SlimDX2.Result SetPriorityBlend(float blendWeight) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 25 * 4, blendWeight);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the current priority blending weight used by the animation controller.	
        /// </summary>	
        /// <remarks>	
        ///  The priority blending weight is used to blend high and low priority tracks together. 	
        /// </remarks>	
        /// <returns>  {{FLOAT}}  Returns the current priority blending weight. </returns>
        /// <unmanaged>FLOAT GetPriorityBlend()</unmanaged>
        internal float GetPriorityBlend() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct3D9.LocalInterop.Callifloat(_nativePointer, 26 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an event key that changes the rate of play of an animation track.	
        /// </summary>	
        /// <param name="track"> Identifier of the track to modify. </param>
        /// <param name="newSpeed"> New speed of the animation track. </param>
        /// <param name="startTime"> Global time key. Specifies the global time when the change will take place. </param>
        /// <param name="duration"> Transition time, which specifies how long the smooth transition will take to complete. </param>
        /// <param name="transition"> Specifies the transition type used for transitioning between speeds. See <see cref="SlimDX2.Direct3D9.TransitionType"/>. </param>
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the priority blend event. NULL is returned if one or more of the input parameters is invalid, or no free event is available. </returns>
        /// <unmanaged>D3DXEVENTHANDLE KeyTrackSpeed([None] UINT Track,[None] FLOAT NewSpeed,[None] DOUBLE StartTime,[None] DOUBLE Duration,[None] D3DXTRANSITION_TYPE Transition)</unmanaged>
        public int KeyTrackSpeed(int track, float newSpeed, double startTime, double duration, SlimDX2.Direct3D9.TransitionType transition) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 27 * 4, track, newSpeed, startTime, duration, unchecked((int)transition));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an event key that changes the weight of an animation track. The weight is used as a multiplier when combining multiple tracks together.	
        /// </summary>	
        /// <remarks>	
        ///  The weight is used like a multiplier to determine how much of this track to blend together with other tracks. 	
        /// </remarks>	
        /// <param name="track"> Identifier of the track to modify. </param>
        /// <param name="newWeight"> New weight of the track. </param>
        /// <param name="startTime"> Global time key. Specifies the global time when the change will take place. </param>
        /// <param name="duration"> Transition time, which specifies how long the smooth transition will take to complete. </param>
        /// <param name="transition"> Specifies the transition type used for transitioning between weights. See <see cref="SlimDX2.Direct3D9.TransitionType"/>. </param>
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the priority blend event. NULL is returned if one or more of the input parameters is invalid, or no free event is available. </returns>
        /// <unmanaged>D3DXEVENTHANDLE KeyTrackWeight([None] UINT Track,[None] FLOAT NewWeight,[None] DOUBLE StartTime,[None] DOUBLE Duration,[None] D3DXTRANSITION_TYPE Transition)</unmanaged>
        public int KeyTrackWeight(int track, float newWeight, double startTime, double duration, SlimDX2.Direct3D9.TransitionType transition) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 28 * 4, track, newWeight, startTime, duration, unchecked((int)transition));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an event key that changes the local time of an animation track.	
        /// </summary>	
        /// <param name="track"> Identifier of the track to modify. </param>
        /// <param name="newPosition"> New local time of the animation track. </param>
        /// <param name="startTime"> Global time key. Specifies the global time when the change will take place. </param>
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the priority blend event. NULL is returned if Track is invalid, or if no free event is available. </returns>
        /// <unmanaged>D3DXEVENTHANDLE KeyTrackPosition([None] UINT Track,[None] DOUBLE NewPosition,[None] DOUBLE StartTime)</unmanaged>
        public int KeyTrackPosition(int track, double newPosition, double startTime) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 29 * 4, track, newPosition, startTime);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets an event key that enables or disables an animation track.	
        /// </summary>	
        /// <param name="track"> Identifier of the animation track to modify. </param>
        /// <param name="newEnable"> Enable flag. Set this to TRUE to enable the animation track, or to FALSE to disable the track. </param>
        /// <param name="startTime"> Global time key. Specifies the global time when the change will take place. </param>
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the priority blend event. NULL is returned if Track is invalid. </returns>
        /// <unmanaged>D3DXEVENTHANDLE KeyTrackEnable([None] UINT Track,[None] BOOL NewEnable,[None] DOUBLE StartTime)</unmanaged>
        public int KeyTrackEnable(int track, bool newEnable, double startTime) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 30 * 4, track, (newEnable?1:0), startTime);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets blending event keys for the specified animation track.	
        /// </summary>	
        /// <remarks>	
        ///  The animation controller blends in three phases: low priority tracks are blended first, high priority tracks are blended second, and  then the results of both are blended. 	
        /// </remarks>	
        /// <param name="newBlendWeight"> Number between 0 and 1 that is used to blend tracks together. </param>
        /// <param name="startTime"> Global time to start the blend. </param>
        /// <param name="duration"> Global time duration of the blend. </param>
        /// <param name="transition"> Specifies the transition type used for the duration of the blend. See <see cref="SlimDX2.Direct3D9.TransitionType"/>. </param>
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the priority blend event. NULL is returned if one or more of the input parameters is invalid, or no free event is available. </returns>
        /// <unmanaged>D3DXEVENTHANDLE KeyPriorityBlend([None] FLOAT NewBlendWeight,[None] DOUBLE StartTime,[None] DOUBLE Duration,[None] D3DXTRANSITION_TYPE Transition)</unmanaged>
        public int KeyPriorityBlend(float newBlendWeight, double startTime, double duration, SlimDX2.Direct3D9.TransitionType transition) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 31 * 4, newBlendWeight, startTime, duration, unchecked((int)transition));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Removes a specified event from an animation track, preventing the execution of the event.	
        /// </summary>	
        /// <param name="hEvent"> Event handle to the event to be removed from the animation track. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT UnkeyEvent([None] D3DXEVENTHANDLE hEvent)</unmanaged>
        public SlimDX2.Result UnkeyEvent(int hEvent) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 32 * 4, hEvent);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Removes all events from a specified animation track.	
        /// </summary>	
        /// <remarks>	
        ///  This method prevents the execution of all events previously scheduled on the track, and discards all data associated with those events. 	
        /// </remarks>	
        /// <param name="track"> Identifier of the track on which all events should be removed. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT UnkeyAllTrackEvents([None] UINT Track)</unmanaged>
        public SlimDX2.Result UnkeyAllTrackEvents(int track) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 33 * 4, track);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Removes all scheduled priority blend events from the animation controller.	
        /// </summary>	
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT UnkeyAllPriorityBlends()</unmanaged>
        public SlimDX2.Result UnkeyAllPriorityBlends() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 34 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns an event handle to the event currently running on the specified animation track.	
        /// </summary>	
        /// <param name="track"> Track identifier. </param>
        /// <param name="eventType"> Type of event to query. </param>
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the event currently running on the specified track. NULL is returned if no event is running on the specified track. </returns>
        /// <unmanaged>D3DXEVENTHANDLE GetCurrentTrackEvent([None] UINT Track,[None] D3DXEVENT_TYPE EventType)</unmanaged>
        public int GetCurrentTrackEvent(int track, SlimDX2.Direct3D9.EventType eventType) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 35 * 4, track, unchecked((int)eventType));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns an event handle to a priority blend event that is currently running.	
        /// </summary>	
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the currently running priority blend event. NULL is returned if no priority blend event is currently running. </returns>
        /// <unmanaged>D3DXEVENTHANDLE GetCurrentPriorityBlend()</unmanaged>
        internal int GetCurrentPriorityBlend() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 36 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns an event handle to the next event scheduled to occur after a specified event on an animation track.	
        /// </summary>	
        /// <remarks>	
        ///  This method can be used iteratively to locate a desired event by repeatedly passing in NULL for hEvent. Note Do not iterate further after the method has returned NULL. 	
        /// </remarks>	
        /// <param name="track"> Track identifier. </param>
        /// <param name="hEvent"> Event handle to a specified event after which to search for a following event. If set to NULL, then the method will return the next scheduled event. </param>
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the next event scheduled to run on the specified track. NULL is returned if no new event is scheduled. </returns>
        /// <unmanaged>D3DXEVENTHANDLE GetUpcomingTrackEvent([None] UINT Track,[None] D3DXEVENTHANDLE hEvent)</unmanaged>
        public int GetUpcomingTrackEvent(int track, int hEvent) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 37 * 4, track, hEvent);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns an event handle to the next priority blend event scheduled to occur after a specified event.	
        /// </summary>	
        /// <remarks>	
        ///  This method can be used iteratively to locate a desired priority blend event by repeatedly passing in NULL for hEvent. Note Do not iterate further after the method has returned NULL. 	
        /// </remarks>	
        /// <param name="hEvent"> Event handle to a specified event after which to search for a following priority blend event. If set to NULL, then the method will  return the next scheduled priority blend event. </param>
        /// <returns>  {{D3DXEVENTHANDLE}}  Event handle to the next scheduled priority blend event. NULL is returned if no new priority blend event is scheduled. </returns>
        /// <unmanaged>D3DXEVENTHANDLE GetUpcomingPriorityBlend([None] D3DXEVENTHANDLE hEvent)</unmanaged>
        public int GetUpcomingPriorityBlend(int hEvent) {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 38 * 4, hEvent);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Checks whether a specified event handle is valid and the animation event has not yet completed.	
        /// </summary>	
        /// <remarks>	
        ///  The method will indicate that an event handle is valid even if the event is running but has not yet completed. 	
        /// </remarks>	
        /// <param name="hEvent"> Event handle to an animation event. </param>
        /// <returns>  <see cref="int"/>  Returns S_OK if the event handle is valid and the event has not yet completed. Returns E_FAIL if the event handle is invalid and/or the event has completed. </returns>
        /// <unmanaged>HRESULT ValidateEvent([None] D3DXEVENTHANDLE hEvent)</unmanaged>
        public SlimDX2.Result ValidateEvent(int hEvent) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 39 * 4, hEvent);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a description of a specified animation event.	
        /// </summary>	
        /// <param name="hEvent"> Event handle to an animation event to describe. </param>
        /// <param name="pDesc"> Pointer to a <see cref="SlimDX2.Direct3D9.EventDescription"/> structure that contains a description of the animation event. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT GetEventDesc([None] D3DXEVENTHANDLE hEvent,[None] LPD3DXEVENT_DESC pDesc)</unmanaged>
        public SlimDX2.Result GetEventDescription(int hEvent, ref SlimDX2.Direct3D9.EventDescription pDesc) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* pDesc_ = &pDesc)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 40 * 4, hEvent, pDesc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Clones, or copies, an animation controller.	
        /// </summary>	
        /// <param name="maxNumAnimationOutputs"> Maximum number of animation outputs the controller can support. </param>
        /// <param name="maxNumAnimationSets"> Maximum number of animation sets the controller can support. </param>
        /// <param name="maxNumTracks"> Maximum number of tracks the controller can support. </param>
        /// <param name="maxNumEvents"> Maximum number of events the controller can support. </param>
        /// <param name="ppAnimController"> Address of a pointer to the cloned <see cref="SlimDX2.Direct3D9.AnimationController"/> animation controller. </param>
        /// <returns>  <see cref="int"/>  If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following  values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT CloneAnimationController([None] UINT MaxNumAnimationOutputs,[None] UINT MaxNumAnimationSets,[None] UINT MaxNumTracks,[None] UINT MaxNumEvents,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
        public SlimDX2.Result CloneAnimationController(int maxNumAnimationOutputs, int maxNumAnimationSets, int maxNumTracks, int maxNumEvents, out SlimDX2.Direct3D9.AnimationController ppAnimController) {
            unsafe {
                IntPtr ppAnimController_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D9.LocalInterop.Calliint(_nativePointer, 41 * 4, maxNumAnimationOutputs, maxNumAnimationSets, maxNumTracks, maxNumEvents, &ppAnimController_);
                ppAnimController = (ppAnimController_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.AnimationController(ppAnimController_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
}
