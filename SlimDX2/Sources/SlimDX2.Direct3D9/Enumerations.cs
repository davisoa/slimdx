// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Enums for SlimDX2.Direct3D9 namespace.
//     This code was generated by a tool.
//     Date : 11/09/2010 17:36:56
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace SlimDX2.Direct3D9 {

    
    /// <summary>	
    /// Defines the light type.	
    /// </summary>	
    /// <remarks>	
    ///  Directional lights are slightly faster than point light sources, but point lights look a little better. Spotlights offer interesting visual effects but are computationally time-consuming. 	
    /// </remarks>	
    /// <unmanaged>D3DLIGHTTYPE</unmanaged>
    public enum Lighttype : int {	
        
        /// <summary>	
        ///  Light is a point source. The light has a position in space and radiates light in all directions.  	
        /// </summary>	
        /// <unmanaged>D3DLIGHT_POINT</unmanaged>
        Point = unchecked((int)1),			
        
        /// <summary>	
        ///  Light is a spotlight source. This light is like a point light, except that the illumination is limited to a cone. This light type has a direction and several other parameters that determine the shape of the cone it produces. For information about these parameters, see the <see cref="SlimDX2.Direct3D9.Light9"/> structure.  	
        /// </summary>	
        /// <unmanaged>D3DLIGHT_SPOT</unmanaged>
        Spot = unchecked((int)2),			
        
        /// <summary>	
        ///  Light is a directional light source. This is equivalent to using a point light source at an infinite distance.  	
        /// </summary>	
        /// <unmanaged>D3DLIGHT_DIRECTIONAL</unmanaged>
        Directional = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Defines constants that describe the supported shading modes.	
    /// </summary>	
    /// <remarks>	
    ///  The first vertex of a triangle for flat shading mode is defined in the following manner.   For a triangle list, the first vertex of the triangle  i is  i * 3. For a triangle strip, the first vertex of the triangle    i  is vertex  i. For a triangle fan, the first vertex of the triangle  i is vertex  i + 1.  The members of this enumerated type define the vales for the D3DRS_SHADEMODE render state. 	
    /// </remarks>	
    /// <unmanaged>D3DSHADEMODE</unmanaged>
    public enum Shademode : int {	
        
        /// <summary>	
        ///  Flat shading mode. The color and specular component of the first vertex in the triangle are used to determine the color and specular component of the face. These colors remain constant across the triangle; that is, they are not interpolated. The specular alpha is interpolated. See Remarks.  	
        /// </summary>	
        /// <unmanaged>D3DSHADE_FLAT</unmanaged>
        Flat = unchecked((int)1),			
        
        /// <summary>	
        ///  Gouraud shading mode. The color and specular components of the face are determined by a linear interpolation between all three of the triangle's vertices.  	
        /// </summary>	
        /// <unmanaged>D3DSHADE_GOURAUD</unmanaged>
        Gouraud = unchecked((int)2),			
        
        /// <summary>	
        ///  Not supported.  	
        /// </summary>	
        /// <unmanaged>D3DSHADE_PHONG</unmanaged>
        Phong = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Defines constants describing the fill mode.	
    /// </summary>	
    /// <remarks>	
    ///  The values in this enumerated type are used by the D3DRS_FILLMODE render state. 	
    /// </remarks>	
    /// <unmanaged>D3DFILLMODE</unmanaged>
    public enum Fillmode : int {	
        
        /// <summary>	
        ///  Fill points. 	
        /// </summary>	
        /// <unmanaged>D3DFILL_POINT</unmanaged>
        Point = unchecked((int)1),			
        
        /// <summary>	
        ///  Fill wireframes. 	
        /// </summary>	
        /// <unmanaged>D3DFILL_WIREFRAME</unmanaged>
        Wireframe = unchecked((int)2),			
        
        /// <summary>	
        ///  Fill solids.  	
        /// </summary>	
        /// <unmanaged>D3DFILL_SOLID</unmanaged>
        Solid = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Defines the supported blend mode.	
    /// </summary>	
    /// <remarks>	
    ///  In the preceding member descriptions, the RGBA values of the source and destination are indicated by the s and d subscripts. The values in this enumerated type are used by the following render states:  D3DRS_DESTBLEND D3DRS_SRCBLEND D3DRS_DESTBLENDALPHA D3DRS_SRCBLENDALPHA  See <see cref="SlimDX2.Direct3D9.Renderstatetype"/>  Render Target Blending Direct3D 9Ex has improved text rendering capabilities. Rendering clear-type fonts would normally require two passes. To eliminate the second pass, a pixel shader can be used to output two colors, which we can call PSOutColor[0] and PSOutColor[1]. The first color would contain the standard 3 color components (RGB). The second color would contain 3 alpha components (one for each component of the first color). These new blending modes are only used for text rendering on the first render target. 	
    /// </remarks>	
    /// <unmanaged>D3DBLEND</unmanaged>
    public enum Blend : int {	
        
        /// <summary>	
        ///  Blend factor is (0, 0, 0, 0).  	
        /// </summary>	
        /// <unmanaged>D3DBLEND_ZERO</unmanaged>
        Zero = unchecked((int)1),			
        
        /// <summary>	
        ///  Blend factor is (1, 1, 1, 1).  	
        /// </summary>	
        /// <unmanaged>D3DBLEND_ONE</unmanaged>
        One = unchecked((int)2),			
        
        /// <summary>	
        ///  Blend factor is (Rs, Gs, Bs, As).  	
        /// </summary>	
        /// <unmanaged>D3DBLEND_SRCCOLOR</unmanaged>
        Srccolor = unchecked((int)3),			
        
        /// <summary>	
        ///  Blend factor is (1 - Rs, 1 - Gs, 1 - Bs, 1 - As).  	
        /// </summary>	
        /// <unmanaged>D3DBLEND_INVSRCCOLOR</unmanaged>
        Invsrccolor = unchecked((int)4),			
        
        /// <summary>	
        ///  Blend factor is (As, As, As, As).  	
        /// </summary>	
        /// <unmanaged>D3DBLEND_SRCALPHA</unmanaged>
        Srcalpha = unchecked((int)5),			
        
        /// <summary>	
        ///  Blend factor is ( 1 - As, 1 - As, 1 - As, 1 - As).  	
        /// </summary>	
        /// <unmanaged>D3DBLEND_INVSRCALPHA</unmanaged>
        Invsrcalpha = unchecked((int)6),			
        
        /// <summary>	
        ///  Blend factor is (Ad Ad Ad Ad).  	
        /// </summary>	
        /// <unmanaged>D3DBLEND_DESTALPHA</unmanaged>
        Destalpha = unchecked((int)7),			
        
        /// <summary>	
        ///  Blend factor is (1 - Ad 1 - Ad 1 - Ad 1 - Ad).  	
        /// </summary>	
        /// <unmanaged>D3DBLEND_INVDESTALPHA</unmanaged>
        Invdestalpha = unchecked((int)8),			
        
        /// <summary>	
        ///  Blend factor is (Rd, Gd, Bd, Ad).  	
        /// </summary>	
        /// <unmanaged>D3DBLEND_DESTCOLOR</unmanaged>
        Destcolor = unchecked((int)9),			
        
        /// <summary>	
        ///  Blend factor is (1 - Rd, 1 - Gd, 1 - Bd, 1 - Ad).  	
        /// </summary>	
        /// <unmanaged>D3DBLEND_INVDESTCOLOR</unmanaged>
        Invdestcolor = unchecked((int)10),			
        
        /// <summary>	
        ///  Blend factor is (f, f, f, 1); where f = min(As, 1 - Ad).  	
        /// </summary>	
        /// <unmanaged>D3DBLEND_SRCALPHASAT</unmanaged>
        Srcalphasat = unchecked((int)11),			
        
        /// <summary>	
        ///  Obsolete. Starting with DirectX 6, you can achieve the same effect by setting the source and destination blend factors to D3DBLEND_SRCALPHA and D3DBLEND_INVSRCALPHA in separate calls.  	
        /// </summary>	
        /// <unmanaged>D3DBLEND_BOTHSRCALPHA</unmanaged>
        Bothsrcalpha = unchecked((int)12),			
        
        /// <summary>	
        ///  Source blend factor is (1 - As, 1 - As, 1 - As, 1 - As), and destination blend factor is (As, As, As, As); the destination blend selection is overridden. This blend mode is supported only for the D3DRS_SRCBLEND render state.  	
        /// </summary>	
        /// <unmanaged>D3DBLEND_BOTHINVSRCALPHA</unmanaged>
        Bothinvsrcalpha = unchecked((int)13),			
        
        /// <summary>	
        ///  Constant color blending factor used by the frame-buffer blender. This blend mode is supported only if D3DPBLENDCAPS_BLENDFACTOR is set in the SrcBlendCaps or DestBlendCaps members of <see cref="SlimDX2.Direct3D9.Caps9"/>. 	
        /// </summary>	
        /// <unmanaged>D3DBLEND_BLENDFACTOR</unmanaged>
        Blendfactor = unchecked((int)14),			
        
        /// <summary>	
        ///  Inverted constant color-blending factor used by the frame-buffer blender. This blend mode is supported only if the D3DPBLENDCAPS_BLENDFACTOR bit is set in the SrcBlendCaps or DestBlendCaps members of <see cref="SlimDX2.Direct3D9.Caps9"/>. 	
        /// </summary>	
        /// <unmanaged>D3DBLEND_INVBLENDFACTOR</unmanaged>
        Invblendfactor = unchecked((int)15),			
        
        /// <summary>	
        ///  Blend factor is (PSOutColor[1]r, PSOutColor[1]g, PSOutColor[1]b, not used). See {{Render Target Blending}}.    Differences between Direct3D 9 and Direct3D 9Ex: This flag is available in Direct3D 9Ex only.     	
        /// </summary>	
        /// <unmanaged>D3DBLEND_SRCCOLOR2</unmanaged>
        Srccolor2 = unchecked((int)16),			
        
        /// <summary>	
        ///  Blend factor is (1 - PSOutColor[1]r, 1 - PSOutColor[1]g, 1 - PSOutColor[1]b, not used)). See {{Render Target Blending}}.    Differences between Direct3D 9 and Direct3D 9Ex: This flag is available in Direct3D 9Ex only.     	
        /// </summary>	
        /// <unmanaged>D3DBLEND_INVSRCCOLOR2</unmanaged>
        Invsrccolor2 = unchecked((int)17),			
    }
    
    /// <summary>	
    /// Defines the supported blend operations. See Remarks for definitions of terms.	
    /// </summary>	
    /// <remarks>	
    ///  Source, Destination, and Result are defined as:   TermTypeDescription SourceInputColor of the source pixel before the operation. DestinationInputColor of the pixel in the destination buffer before the operation. ResultOutputReturned value that is the blended color resulting from the operation.    This enumerated type defines values used by the following render states:  D3DRS_BLENDOP D3DRS_BLENDOPALPHA  	
    /// </remarks>	
    /// <unmanaged>D3DBLENDOP</unmanaged>
    public enum Blendop : int {	
        
        /// <summary>	
        ///  The result is the destination added to the source.  Result = Source + Destination 	
        /// </summary>	
        /// <unmanaged>D3DBLENDOP_ADD</unmanaged>
        Add = unchecked((int)1),			
        
        /// <summary>	
        ///  The result is the destination subtracted from to the source.  Result = Source - Destination 	
        /// </summary>	
        /// <unmanaged>D3DBLENDOP_SUBTRACT</unmanaged>
        Subtract = unchecked((int)2),			
        
        /// <summary>	
        ///  The result is the source subtracted from the destination.  Result = Destination - Source 	
        /// </summary>	
        /// <unmanaged>D3DBLENDOP_REVSUBTRACT</unmanaged>
        Revsubtract = unchecked((int)3),			
        
        /// <summary>	
        ///  The result is the minimum of the source and destination.  Result = MIN(Source, Destination) 	
        /// </summary>	
        /// <unmanaged>D3DBLENDOP_MIN</unmanaged>
        Minimum = unchecked((int)4),			
        
        /// <summary>	
        ///  The result is the maximum of the source and destination.  Result = MAX(Source, Destination) 	
        /// </summary>	
        /// <unmanaged>D3DBLENDOP_MAX</unmanaged>
        Maximum = unchecked((int)5),			
    }
    
    /// <summary>	
    /// Defines constants that describe the supported texture-addressing modes.	
    /// </summary>	
    /// <unmanaged>D3DTEXTUREADDRESS</unmanaged>
    public enum Textureaddress : int {	
        
        /// <summary>	
        ///  Tile the texture at every integer junction. For example, for u values between 0 and 3, the texture is repeated three times; no mirroring is performed.  	
        /// </summary>	
        /// <unmanaged>D3DTADDRESS_WRAP</unmanaged>
        AddressWrap = unchecked((int)1),			
        
        /// <summary>	
        ///  Similar to D3DTADDRESS_WRAP, except that the texture is flipped at every integer junction. For u values between 0 and 1, for example, the texture is addressed normally; between 1 and 2, the texture is flipped (mirrored); between 2 and 3, the texture is normal again; and so on.  	
        /// </summary>	
        /// <unmanaged>D3DTADDRESS_MIRROR</unmanaged>
        AddressMirror = unchecked((int)2),			
        
        /// <summary>	
        ///  Texture coordinates outside the range [0.0, 1.0] are set to the texture color at 0.0 or 1.0, respectively.  	
        /// </summary>	
        /// <unmanaged>D3DTADDRESS_CLAMP</unmanaged>
        AddressClamp = unchecked((int)3),			
        
        /// <summary>	
        ///  Texture coordinates outside the range [0.0, 1.0] are set to the border color.  	
        /// </summary>	
        /// <unmanaged>D3DTADDRESS_BORDER</unmanaged>
        AddressBorder = unchecked((int)4),			
        
        /// <summary>	
        ///  Similar to D3DTADDRESS_MIRROR and D3DTADDRESS_CLAMP. Takes the absolute value of the texture coordinate (thus, mirroring around 0), and then clamps to the maximum value. The most common usage is for volume textures, where support for the full D3DTADDRESS_MIRRORONCE texture-addressing mode is not necessary, but the data is symmetric around the one axis.  	
        /// </summary>	
        /// <unmanaged>D3DTADDRESS_MIRRORONCE</unmanaged>
        AddressMirroronce = unchecked((int)5),			
    }
    
    /// <summary>	
    /// Defines the supported culling modes.	
    /// </summary>	
    /// <remarks>	
    ///  The values in this enumerated type are used by the D3DRS_CULLMODE render state. The culling modes define how back faces are culled when rendering a geometry. 	
    /// </remarks>	
    /// <unmanaged>D3DCULL</unmanaged>
    public enum Cull : int {	
        
        /// <summary>	
        ///  Do not cull back faces.  	
        /// </summary>	
        /// <unmanaged>D3DCULL_NONE</unmanaged>
        None = unchecked((int)1),			
        
        /// <summary>	
        ///  Cull back faces with clockwise vertices.  	
        /// </summary>	
        /// <unmanaged>D3DCULL_CW</unmanaged>
        Cw = unchecked((int)2),			
        
        /// <summary>	
        ///  Cull back faces with counterclockwise vertices.  	
        /// </summary>	
        /// <unmanaged>D3DCULL_CCW</unmanaged>
        Ccw = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Defines the supported compare functions.	
    /// </summary>	
    /// <remarks>	
    ///  The values in this enumerated type define the supported compare functions for the D3DRS_ZFUNC, D3DRS_ALPHAFUNC, and D3DRS_STENCILFUNC render states. 	
    /// </remarks>	
    /// <unmanaged>D3DCMPFUNC</unmanaged>
    public enum Cmpfunc : int {	
        
        /// <summary>	
        ///  Always fail the test.  	
        /// </summary>	
        /// <unmanaged>D3DCMP_NEVER</unmanaged>
        Never = unchecked((int)1),			
        
        /// <summary>	
        ///  Accept the new pixel if its value is less than the value of the current pixel.  	
        /// </summary>	
        /// <unmanaged>D3DCMP_LESS</unmanaged>
        Less = unchecked((int)2),			
        
        /// <summary>	
        ///  Accept the new pixel if its value equals the value of the current pixel.  	
        /// </summary>	
        /// <unmanaged>D3DCMP_EQUAL</unmanaged>
        Equal = unchecked((int)3),			
        
        /// <summary>	
        ///  Accept the new pixel if its value is less than or equal to the value of the current pixel.  	
        /// </summary>	
        /// <unmanaged>D3DCMP_LESSEQUAL</unmanaged>
        Lessequal = unchecked((int)4),			
        
        /// <summary>	
        ///  Accept the new pixel if its value is greater than the value of the current pixel.  	
        /// </summary>	
        /// <unmanaged>D3DCMP_GREATER</unmanaged>
        Greater = unchecked((int)5),			
        
        /// <summary>	
        ///  Accept the new pixel if its value does not equal the value of the current pixel.  	
        /// </summary>	
        /// <unmanaged>D3DCMP_NOTEQUAL</unmanaged>
        Notequal = unchecked((int)6),			
        
        /// <summary>	
        ///  Accept the new pixel if its value is greater than or equal to the value of the current pixel.  	
        /// </summary>	
        /// <unmanaged>D3DCMP_GREATEREQUAL</unmanaged>
        Greaterequal = unchecked((int)7),			
        
        /// <summary>	
        ///  Always pass the test.  	
        /// </summary>	
        /// <unmanaged>D3DCMP_ALWAYS</unmanaged>
        Always = unchecked((int)8),			
    }
    
    /// <summary>	
    /// Defines stencil-buffer operations.	
    /// </summary>	
    /// <remarks>	
    ///  Stencil-buffer entries are integer values ranging from 0 through 2n - 1, where n is the bit depth of the stencil buffer. 	
    /// </remarks>	
    /// <unmanaged>D3DSTENCILOP</unmanaged>
    public enum StencilOperation : int {	
        
        /// <summary>	
        ///  Do not update the entry in the stencil buffer. This is the default value. 	
        /// </summary>	
        /// <unmanaged>D3DSTENCILOP_KEEP</unmanaged>
        Keep = unchecked((int)1),			
        
        /// <summary>	
        ///  Set the stencil-buffer entry to 0. 	
        /// </summary>	
        /// <unmanaged>D3DSTENCILOP_ZERO</unmanaged>
        Zero = unchecked((int)2),			
        
        /// <summary>	
        ///  Replace the stencil-buffer entry with a reference value. 	
        /// </summary>	
        /// <unmanaged>D3DSTENCILOP_REPLACE</unmanaged>
        Replace = unchecked((int)3),			
        
        /// <summary>	
        ///  Increment the stencil-buffer entry, clamping to the maximum value. 	
        /// </summary>	
        /// <unmanaged>D3DSTENCILOP_INCRSAT</unmanaged>
        Incrsat = unchecked((int)4),			
        
        /// <summary>	
        ///  Decrement the stencil-buffer entry, clamping to zero. 	
        /// </summary>	
        /// <unmanaged>D3DSTENCILOP_DECRSAT</unmanaged>
        Decrsat = unchecked((int)5),			
        
        /// <summary>	
        ///  Invert the bits in the stencil-buffer entry. 	
        /// </summary>	
        /// <unmanaged>D3DSTENCILOP_INVERT</unmanaged>
        Invert = unchecked((int)6),			
        
        /// <summary>	
        ///  Increment the stencil-buffer entry, wrapping to zero if the new value exceeds the maximum value. 	
        /// </summary>	
        /// <unmanaged>D3DSTENCILOP_INCR</unmanaged>
        Increment = unchecked((int)7),			
        
        /// <summary>	
        ///  Decrement the stencil-buffer entry, wrapping to the maximum value if the new value is less than zero. 	
        /// </summary>	
        /// <unmanaged>D3DSTENCILOP_DECR</unmanaged>
        Decrement = unchecked((int)8),			
    }
    
    /// <summary>	
    /// Defines constants that describe the fog mode.	
    /// </summary>	
    /// <remarks>	
    ///  The values in this enumerated type are used by the D3DRS_FOGTABLEMODE and D3DRS_FOGVERTEXMODE render states. Fog can be considered a measure of visibility: the lower the fog value produced by a fog equation, the less visible an object is. 	
    /// </remarks>	
    /// <unmanaged>D3DFOGMODE</unmanaged>
    public enum Fogmode : int {	
        
        /// <summary>	
        ///  No fog effect.  	
        /// </summary>	
        /// <unmanaged>D3DFOG_NONE</unmanaged>
        None = unchecked((int)0),			
        
        /// <summary>	
        ///  Fog effect intensifies exponentially, according to the following formula. 	
        ///   	
        /// </summary>	
        /// <unmanaged>D3DFOG_EXP</unmanaged>
        Exp = unchecked((int)1),			
        
        /// <summary>	
        ///  Fog effect intensifies exponentially with the square of the distance, according to the following formula. 	
        ///   	
        /// </summary>	
        /// <unmanaged>D3DFOG_EXP2</unmanaged>
        Exp2 = unchecked((int)2),			
        
        /// <summary>	
        ///  Fog effect intensifies linearly between the start and end points, according to the following formula.   This is the only fog mode currently supported. 	
        /// </summary>	
        /// <unmanaged>D3DFOG_LINEAR</unmanaged>
        Linear = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Defines constants that describe depth-buffer formats.	
    /// </summary>	
    /// <remarks>	
    ///  Members of this enumerated type are used with the D3DRS_ZENABLE render state. 	
    /// </remarks>	
    /// <unmanaged>D3DZBUFFERTYPE</unmanaged>
    public enum Zbuffertype : int {	
        
        /// <summary>	
        ///  Disable depth buffering.  	
        /// </summary>	
        /// <unmanaged>D3DZB_FALSE</unmanaged>
        False = unchecked((int)0),			
        
        /// <summary>	
        ///  Enable z-buffering.  	
        /// </summary>	
        /// <unmanaged>D3DZB_TRUE</unmanaged>
        True = unchecked((int)1),			
        
        /// <summary>	
        ///  Enable w-buffering.  	
        /// </summary>	
        /// <unmanaged>D3DZB_USEW</unmanaged>
        Usew = unchecked((int)2),			
    }
    
    /// <summary>	
    /// Defines the primitives supported by Direct3D.	
    /// </summary>	
    /// <remarks>	
    ///  Using {{Triangle Strips}} or {{Triangle Fans (Direct3D 9)}} is often more efficient than using triangle lists because fewer vertices are duplicated. 	
    /// </remarks>	
    /// <unmanaged>D3DPRIMITIVETYPE</unmanaged>
    public enum Primitivetype : int {	
        
        /// <summary>	
        ///  Renders the vertices as a collection of isolated points. This value is unsupported for indexed primitives. 	
        /// </summary>	
        /// <unmanaged>D3DPT_POINTLIST</unmanaged>
        TPointlist = unchecked((int)1),			
        
        /// <summary>	
        ///  Renders the vertices as a list of isolated straight line segments. 	
        /// </summary>	
        /// <unmanaged>D3DPT_LINELIST</unmanaged>
        TLinelist = unchecked((int)2),			
        
        /// <summary>	
        ///  Renders the vertices as a single polyline. 	
        /// </summary>	
        /// <unmanaged>D3DPT_LINESTRIP</unmanaged>
        TLinestrip = unchecked((int)3),			
        
        /// <summary>	
        ///  Renders the specified vertices as a sequence of isolated triangles. Each group of three vertices defines a separate triangle.  Back-face culling is affected by the current winding-order render state. 	
        /// </summary>	
        /// <unmanaged>D3DPT_TRIANGLELIST</unmanaged>
        TTrianglelist = unchecked((int)4),			
        
        /// <summary>	
        ///  Renders the vertices as a triangle strip. The backface-culling flag is automatically flipped on even-numbered triangles.  	
        /// </summary>	
        /// <unmanaged>D3DPT_TRIANGLESTRIP</unmanaged>
        TTrianglestrip = unchecked((int)5),			
        
        /// <summary>	
        ///  Renders the vertices as a triangle fan.  	
        /// </summary>	
        /// <unmanaged>D3DPT_TRIANGLEFAN</unmanaged>
        TTrianglefan = unchecked((int)6),			
    }
    
    /// <summary>	
    /// Defines constants that describe transformation state values.	
    /// </summary>	
    /// <remarks>	
    ///  The transform states in the range 256 through 511 are reserved to store up to 256 world matrices that can be indexed using the D3DTS_WORLDMATRIX and D3DTS_WORLD macros.  Macros  {{D3DTS_WORLD}} Equivalent to D3DTS_WORLDMATRIX(0).  {{D3DTS_WORLDMATRIX}} (index)Identifies the transform matrix to set for the world matrix at index. Multiple world matrices are used only for vertex blending. Otherwise only D3DTS_WORLD is used.    	
    /// </remarks>	
    /// <unmanaged>D3DTRANSFORMSTATETYPE</unmanaged>
    public enum Transformstatetype : int {	
        
        /// <summary>	
        ///  Identifies the transformation matrix being set as the view transformation matrix. The default value is NULL (the identity matrix).  	
        /// </summary>	
        /// <unmanaged>D3DTS_VIEW</unmanaged>
        SView = unchecked((int)2),			
        
        /// <summary>	
        ///  Identifies the transformation matrix being set as the projection transformation matrix. The default value is NULL (the identity matrix).  	
        /// </summary>	
        /// <unmanaged>D3DTS_PROJECTION</unmanaged>
        SProjection = unchecked((int)3),			
        
        /// <summary>	
        ///  Identifies the transformation matrix being set for the specified texture stage.  	
        /// </summary>	
        /// <unmanaged>D3DTS_TEXTURE0</unmanaged>
        STexture0 = unchecked((int)16),			
        
        /// <summary>	
        ///  Identifies the transformation matrix being set for the specified texture stage.  	
        /// </summary>	
        /// <unmanaged>D3DTS_TEXTURE1</unmanaged>
        STexture1 = unchecked((int)17),			
        
        /// <summary>	
        ///  Identifies the transformation matrix being set for the specified texture stage.  	
        /// </summary>	
        /// <unmanaged>D3DTS_TEXTURE2</unmanaged>
        STexture2 = unchecked((int)18),			
        
        /// <summary>	
        ///  Identifies the transformation matrix being set for the specified texture stage.  	
        /// </summary>	
        /// <unmanaged>D3DTS_TEXTURE3</unmanaged>
        STexture3 = unchecked((int)19),			
        
        /// <summary>	
        ///  Identifies the transformation matrix being set for the specified texture stage.  	
        /// </summary>	
        /// <unmanaged>D3DTS_TEXTURE4</unmanaged>
        STexture4 = unchecked((int)20),			
        
        /// <summary>	
        ///  Identifies the transformation matrix being set for the specified texture stage.  	
        /// </summary>	
        /// <unmanaged>D3DTS_TEXTURE5</unmanaged>
        STexture5 = unchecked((int)21),			
        
        /// <summary>	
        ///  Identifies the transformation matrix being set for the specified texture stage.  	
        /// </summary>	
        /// <unmanaged>D3DTS_TEXTURE6</unmanaged>
        STexture6 = unchecked((int)22),			
        
        /// <summary>	
        ///  Identifies the transformation matrix being set for the specified texture stage.  	
        /// </summary>	
        /// <unmanaged>D3DTS_TEXTURE7</unmanaged>
        STexture7 = unchecked((int)23),			
    }
    
    /// <summary>	
    /// Render states define set-up states for all kinds of vertex and pixel processing. Some render states set up vertex processing, and some set up pixel processing (see {{Render States (Direct3D 9)}}). Render states can be saved and restored using stateblocks (see {{State Blocks Save and Restore State (Direct3D 9)}}).	
    /// </summary>	
    /// <remarks>	
    ///   Render States ps_1_1 to ps_1_34 texture samplers    Direct3D defines the D3DRENDERSTATE_WRAPBIAS constant as a convenience for applications to enable or disable texture wrapping, based on the zero-based integer of a texture coordinate set (rather than explicitly using one of the D3DRS_WRAP n state values). Add the D3DRENDERSTATE_WRAPBIAS value to the zero-based index of a texture coordinate set to calculate the D3DRS_WRAP n value that corresponds to that index, as shown in the following example. 	
    /// <code> // Enable U/V wrapping for textures that use the texture 	
    /// // coordinate set at the index within the dwIndex variable HRESULT hr = pd3dDevice-&gt;SetRenderState(	
    /// dwIndex + D3DRENDERSTATE_WRAPBIAS,  	
    /// D3DWRAPCOORD_0 | D3DWRAPCOORD_1); // If dwIndex is 3, the value that results from 	
    /// // the addition equals D3DRS_WRAP3 (131) </code>	
    /// 	
    ///  	
    /// </remarks>	
    /// <unmanaged>D3DRENDERSTATETYPE</unmanaged>
    public enum Renderstatetype : int {	
        
        /// <summary>	
        ///  Depth-buffering state as one member of the <see cref="SlimDX2.Direct3D9.Zbuffertype"/> enumerated type. Set this state to D3DZB_TRUE to enable z-buffering, D3DZB_USEW to enable w-buffering, or D3DZB_FALSE to disable depth buffering.  The default value for this render state is D3DZB_TRUE if a depth stencil was created along with the swap chain by setting the  EnableAutoDepthStencil member of the <see cref="SlimDX2.Direct3D9.PresentParameters"/> structure to TRUE, and D3DZB_FALSE otherwise. 	
        /// </summary>	
        /// <unmanaged>D3DRS_ZENABLE</unmanaged>
        SZenable = unchecked((int)7),			
        
        /// <summary>	
        ///  One or more members of the <see cref="SlimDX2.Direct3D9.Fillmode"/> enumerated type. The default value is D3DFILL_SOLID.  	
        /// </summary>	
        /// <unmanaged>D3DRS_FILLMODE</unmanaged>
        SFillmode = unchecked((int)8),			
        
        /// <summary>	
        ///  One or more members of the <see cref="SlimDX2.Direct3D9.Shademode"/> enumerated type. The default value is D3DSHADE_GOURAUD.  	
        /// </summary>	
        /// <unmanaged>D3DRS_SHADEMODE</unmanaged>
        SShademode = unchecked((int)9),			
        
        /// <summary>	
        ///  TRUE to enable the application to write to the depth buffer. The default value is TRUE. This member enables an application to prevent the system from updating the depth buffer with new depth values. If FALSE, depth comparisons are still made according to the render state D3DRS_ZFUNC, assuming that depth buffering is taking place, but depth values are not written to the buffer.  	
        /// </summary>	
        /// <unmanaged>D3DRS_ZWRITEENABLE</unmanaged>
        SZwriteenable = unchecked((int)14),			
        
        /// <summary>	
        ///  TRUE to enable per pixel alpha testing. If the test passes, the pixel is processed by the frame buffer. Otherwise, all frame-buffer processing is skipped for the pixel.  The test is done by comparing the incoming alpha value with the reference alpha value, using the comparison function provided by the D3DRS_ALPHAFUNC render state. The reference alpha value is determined by the value set for D3DRS_ALPHAREF. For more information, see {{Alpha Testing State (Direct3D 9)}}.  The default value of this parameter is FALSE. 	
        /// </summary>	
        /// <unmanaged>D3DRS_ALPHATESTENABLE</unmanaged>
        SAlphatestenable = unchecked((int)15),			
        
        /// <summary>	
        ///  The default value is TRUE, which enables drawing of the last pixel in a line. To prevent drawing of the last pixel, set this value to FALSE. For more information, see {{Outline and Fill State (Direct3D 9)}}. 	
        /// </summary>	
        /// <unmanaged>D3DRS_LASTPIXEL</unmanaged>
        SLastpixel = unchecked((int)16),			
        
        /// <summary>	
        ///  One member of the <see cref="SlimDX2.Direct3D9.Blend"/> enumerated type. The default value is D3DBLEND_ONE.  	
        /// </summary>	
        /// <unmanaged>D3DRS_SRCBLEND</unmanaged>
        SSrcblend = unchecked((int)19),			
        
        /// <summary>	
        ///  One member of the <see cref="SlimDX2.Direct3D9.Blend"/> enumerated type. The default value is D3DBLEND_ZERO.  	
        /// </summary>	
        /// <unmanaged>D3DRS_DESTBLEND</unmanaged>
        SDestblend = unchecked((int)20),			
        
        /// <summary>	
        ///  Specifies how back-facing triangles are culled, if at all. This can be set to one member of the <see cref="SlimDX2.Direct3D9.Cull"/> enumerated type. The default value is D3DCULL_CCW.  	
        /// </summary>	
        /// <unmanaged>D3DRS_CULLMODE</unmanaged>
        SCullmode = unchecked((int)22),			
        
        /// <summary>	
        ///  One member of the <see cref="SlimDX2.Direct3D9.Cmpfunc"/> enumerated type. The default value is D3DCMP_LESSEQUAL. This member enables an application to accept or reject a pixel, based on its distance from the camera.  The depth value of the pixel is compared with the depth-buffer value. If the depth value of the pixel passes the comparison function, the pixel is written. The depth value is written to the depth buffer only if the render state is TRUE. Software rasterizers and many hardware accelerators work faster if the depth test fails, because there is no need to filter and modulate the texture if the pixel is not going to be rendered. 	
        /// </summary>	
        /// <unmanaged>D3DRS_ZFUNC</unmanaged>
        SZfunc = unchecked((int)23),			
        
        /// <summary>	
        ///  Value that specifies a reference alpha value against which pixels are tested when alpha testing is enabled. This is an 8-bit value placed in the low 8 bits of the DWORD render-state value. Values can range from 0x00000000 through 0x000000FF. The default value is 0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_ALPHAREF</unmanaged>
        SAlpharef = unchecked((int)24),			
        
        /// <summary>	
        ///  One member of the <see cref="SlimDX2.Direct3D9.Cmpfunc"/> enumerated type. The default value is D3DCMP_ALWAYS. This member enables an application to accept or reject a pixel, based on its alpha value.  	
        /// </summary>	
        /// <unmanaged>D3DRS_ALPHAFUNC</unmanaged>
        SAlphafunc = unchecked((int)25),			
        
        /// <summary>	
        ///  TRUE to enable dithering. The default value is FALSE.  	
        /// </summary>	
        /// <unmanaged>D3DRS_DITHERENABLE</unmanaged>
        SDitherenable = unchecked((int)26),			
        
        /// <summary>	
        ///  TRUE to enable alpha-blended transparency. The default value is FALSE.  The type of alpha blending is determined by the D3DRS_SRCBLEND and D3DRS_DESTBLEND render states. 	
        /// </summary>	
        /// <unmanaged>D3DRS_ALPHABLENDENABLE</unmanaged>
        SAlphablendenable = unchecked((int)27),			
        
        /// <summary>	
        ///  TRUE to enable fog blending. The default value is FALSE. For more information about using fog blending, see {{Fog}}.  	
        /// </summary>	
        /// <unmanaged>D3DRS_FOGENABLE</unmanaged>
        SFogenable = unchecked((int)28),			
        
        /// <summary>	
        ///  TRUE to enable specular highlights. The default value is FALSE.  Specular highlights are calculated as though every vertex in the object being lit is at the object's origin. This gives the expected results as long as the object is modeled around the origin and the distance from the light to the object is relatively large. In other cases, the results as undefined. When this member is set to TRUE, the specular color is added to the base color after the texture cascade but before alpha blending. 	
        /// </summary>	
        /// <unmanaged>D3DRS_SPECULARENABLE</unmanaged>
        SSpecularenable = unchecked((int)29),			
        
        /// <summary>	
        ///  Value whose type is <see cref="int"/>. The default value is 0. For more information about fog color, see {{Fog Color (Direct3D 9)}}.  	
        /// </summary>	
        /// <unmanaged>D3DRS_FOGCOLOR</unmanaged>
        SFogcolor = unchecked((int)34),			
        
        /// <summary>	
        ///  The fog formula to be used for pixel fog. Set to one of the members of the <see cref="SlimDX2.Direct3D9.Fogmode"/> enumerated type. The default value is D3DFOG_NONE. For more information about pixel fog, see {{Pixel Fog (Direct3D 9)}}.  	
        /// </summary>	
        /// <unmanaged>D3DRS_FOGTABLEMODE</unmanaged>
        SFogtablemode = unchecked((int)35),			
        
        /// <summary>	
        ///  Depth at which pixel or vertex fog effects begin for linear fog mode. The default value is 0.0f. Depth is specified in world space for vertex fog and either device space [0.0, 1.0] or world space for pixel fog. For pixel fog, these values are in device space when the system uses z for fog calculations and world-world space when the system is using eye-relative fog (w-fog). For more information, see {{Fog Parameters (Direct3D 9)}} and {{Eye-Relative vs. Z-based Depth}}.  Values for this render state are floating-point values. Because the <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/> method accepts  DWORD values, your application must cast a variable that contains the value, as shown in the following code example. 	
        /// <code> pDevice9-&gt;SetRenderState(D3DRS_FOGSTART,  *((DWORD*) (&amp;fFogStart))); </code>	
        /// 	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DRS_FOGSTART</unmanaged>
        SFogstart = unchecked((int)36),			
        
        /// <summary>	
        ///  Depth at which pixel or vertex fog effects end for linear fog mode. The default value is 1.0f. Depth is specified in world space for vertex fog and either device space [0.0, 1.0] or world space for pixel fog. For pixel fog, these values are in device space when the system uses z for fog calculations and in world space when the system is using eye-relative fog (w-fog). For more information, see {{Fog Parameters (Direct3D 9)}} and {{Eye-Relative vs. Z-based Depth}}.  Values for this render state are floating-point values. Because the <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/> method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. 	
        /// <code> m_pDevice9-&gt;SetRenderState(D3DRS_FOGEND, *((DWORD*) (&amp;fFogEnd))); </code>	
        /// 	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DRS_FOGEND</unmanaged>
        SFogend = unchecked((int)37),			
        
        /// <summary>	
        ///  Fog density for pixel or vertex fog used in the exponential fog modes (D3DFOG_EXP and D3DFOG_EXP2). Valid density values range from 0.0 through 1.0. The default value is 1.0. For more information, see {{Fog Parameters (Direct3D 9)}}.  Values for this render state are floating-point values. Because the <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/> method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example. 	
        /// <code> m_pDevice9-&gt;SetRenderState(D3DRS_FOGDENSITY, *((DWORD*) (&amp;fFogDensity))); </code>	
        /// 	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DRS_FOGDENSITY</unmanaged>
        SFogdensity = unchecked((int)38),			
        
        /// <summary>	
        ///  TRUE to enable range-based vertex fog. The default value is FALSE, in which case the system uses depth-based fog. In range-based fog, the distance of an object from the viewer is used to compute fog effects, not the depth of the object (that is, the z-coordinate) in the scene. In range-based fog, all fog methods work as usual, except that they use range instead of depth in the computations.  Range is the correct factor to use for fog computations, but depth is commonly used instead because range is time-consuming to compute and depth is generally already available. Using depth to calculate fog has the undesirable effect of having the fogginess of peripheral objects change as the viewer's eye moves - in this case, the depth changes and the range remains constant. Because no hardware currently supports per-pixel range-based fog, range correction is offered only for vertex fog. For more information, see {{Vertex Fog (Direct3D 9)}}. 	
        /// </summary>	
        /// <unmanaged>D3DRS_RANGEFOGENABLE</unmanaged>
        SRangefogenable = unchecked((int)48),			
        
        /// <summary>	
        ///  TRUE to enable stenciling, or FALSE to disable stenciling. The default value is FALSE. For more information, see {{Stencil Buffer Techniques (Direct3D 9)}}. 	
        /// </summary>	
        /// <unmanaged>D3DRS_STENCILENABLE</unmanaged>
        SStencilenable = unchecked((int)52),			
        
        /// <summary>	
        ///  Stencil operation to perform if the stencil test fails. Values are from the <see cref="SlimDX2.Direct3D9.StencilOperation"/> enumerated type. The default value is D3DSTENCILOP_KEEP. 	
        /// </summary>	
        /// <unmanaged>D3DRS_STENCILFAIL</unmanaged>
        SStencilfail = unchecked((int)53),			
        
        /// <summary>	
        ///  Stencil operation to perform if the stencil test passes and the depth test (z-test) fails. Values are from the <see cref="SlimDX2.Direct3D9.StencilOperation"/> enumerated type. The default value is D3DSTENCILOP_KEEP. 	
        /// </summary>	
        /// <unmanaged>D3DRS_STENCILZFAIL</unmanaged>
        SStencilzfail = unchecked((int)54),			
        
        /// <summary>	
        ///  Stencil operation to perform if both the stencil and the depth (z) tests pass. Values are from the <see cref="SlimDX2.Direct3D9.StencilOperation"/> enumerated type. The default value is D3DSTENCILOP_KEEP. 	
        /// </summary>	
        /// <unmanaged>D3DRS_STENCILPASS</unmanaged>
        SStencilpass = unchecked((int)55),			
        
        /// <summary>	
        ///  Comparison function for the stencil test. Values are from the <see cref="SlimDX2.Direct3D9.Cmpfunc"/> enumerated type. The default value is D3DCMP_ALWAYS.  The comparison function is used to compare the reference value to a stencil buffer entry. This comparison applies only to the bits in the reference value and stencil buffer entry that are set in the stencil mask (set by the D3DRS_STENCILMASK render state). If TRUE, the stencil test passes. 	
        /// </summary>	
        /// <unmanaged>D3DRS_STENCILFUNC</unmanaged>
        SStencilfunc = unchecked((int)56),			
        
        /// <summary>	
        ///  An int reference value for the stencil test. The default value is 0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_STENCILREF</unmanaged>
        SStencilref = unchecked((int)57),			
        
        /// <summary>	
        ///  Mask applied to the reference value and each stencil buffer entry to determine the significant bits for the stencil test. The default mask is 0xFFFFFFFF.  	
        /// </summary>	
        /// <unmanaged>D3DRS_STENCILMASK</unmanaged>
        SStencilmask = unchecked((int)58),			
        
        /// <summary>	
        ///  Write mask applied to values written into the stencil buffer. The default mask is 0xFFFFFFFF.  	
        /// </summary>	
        /// <unmanaged>D3DRS_STENCILWRITEMASK</unmanaged>
        SStencilwritemask = unchecked((int)59),			
        
        /// <summary>	
        ///  Color used for multiple-texture blending with the D3DTA_TFACTOR texture-blending argument or the D3DTOP_BLENDFACTORALPHA texture-blending operation. The associated value is a <see cref="int"/> variable. The default value is opaque white (0xFFFFFFFF). 	
        /// </summary>	
        /// <unmanaged>D3DRS_TEXTUREFACTOR</unmanaged>
        STexturefactor = unchecked((int)60),			
        
        /// <summary>	
        ///  Texture-wrapping behavior for multiple sets of texture coordinates. Valid values for this render state can be any combination of the D3DWRAPCOORD_0 (or D3DWRAP_U), D3DWRAPCOORD_1 (or D3DWRAP_V), D3DWRAPCOORD_2 (or D3DWRAP_W), and D3DWRAPCOORD_3 flags. These cause the system to wrap in the direction of the first, second, third, and fourth dimensions, sometimes referred to as the s, t, r, and q directions, for a given texture. The default value for this render state is 0 (wrapping disabled in all directions).  	
        /// </summary>	
        /// <unmanaged>D3DRS_WRAP0</unmanaged>
        SWrap0 = unchecked((int)128),			
        
        /// <summary>	
        ///  See D3DRS_WRAP0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_WRAP1</unmanaged>
        SWrap1 = unchecked((int)129),			
        
        /// <summary>	
        ///  See D3DRS_WRAP0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_WRAP2</unmanaged>
        SWrap2 = unchecked((int)130),			
        
        /// <summary>	
        ///  See D3DRS_WRAP0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_WRAP3</unmanaged>
        SWrap3 = unchecked((int)131),			
        
        /// <summary>	
        ///  See D3DRS_WRAP0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_WRAP4</unmanaged>
        SWrap4 = unchecked((int)132),			
        
        /// <summary>	
        ///  See D3DRS_WRAP0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_WRAP5</unmanaged>
        SWrap5 = unchecked((int)133),			
        
        /// <summary>	
        ///  See D3DRS_WRAP0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_WRAP6</unmanaged>
        SWrap6 = unchecked((int)134),			
        
        /// <summary>	
        ///  See D3DRS_WRAP0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_WRAP7</unmanaged>
        SWrap7 = unchecked((int)135),			
        
        /// <summary>	
        ///  TRUE to enable primitive clipping by Direct3D, or FALSE to disable it. The default value is TRUE.  	
        /// </summary>	
        /// <unmanaged>D3DRS_CLIPPING</unmanaged>
        SClipping = unchecked((int)136),			
        
        /// <summary>	
        ///  TRUE to enable Direct3D lighting, or FALSE to disable it. The default value is TRUE. Only vertices that include a vertex normal are properly lit; vertices that do not contain a normal employ a dot product of 0 in all lighting calculations.  	
        /// </summary>	
        /// <unmanaged>D3DRS_LIGHTING</unmanaged>
        SLighting = unchecked((int)137),			
        
        /// <summary>	
        ///  Ambient light color. This value is of type <see cref="int"/>. The default value is 0.  	
        /// </summary>	
        /// <unmanaged>D3DRS_AMBIENT</unmanaged>
        SAmbient = unchecked((int)139),			
        
        /// <summary>	
        ///  Fog formula to be used for vertex fog. Set to one member of the <see cref="SlimDX2.Direct3D9.Fogmode"/> enumerated type. The default value is D3DFOG_NONE.  	
        /// </summary>	
        /// <unmanaged>D3DRS_FOGVERTEXMODE</unmanaged>
        SFogvertexmode = unchecked((int)140),			
        
        /// <summary>	
        ///  TRUE to enable per-vertex color or FALSE to disable it. The default value is TRUE. Enabling per-vertex color allows the system to include the color defined for individual vertices in its lighting calculations.  For more information, see the following render states:  D3DRS_DIFFUSEMATERIALSOURCE D3DRS_SPECULARMATERIALSOURCE D3DRS_AMBIENTMATERIALSOURCE D3DRS_EMISSIVEMATERIALSOURCE  	
        /// </summary>	
        /// <unmanaged>D3DRS_COLORVERTEX</unmanaged>
        SColorvertex = unchecked((int)141),			
        
        /// <summary>	
        ///  TRUE to enable camera-relative specular highlights, or FALSE to use orthogonal specular highlights. The default value is TRUE. Applications that use orthogonal projection should specify false.  	
        /// </summary>	
        /// <unmanaged>D3DRS_LOCALVIEWER</unmanaged>
        SLocalviewer = unchecked((int)142),			
        
        /// <summary>	
        ///  TRUE to enable automatic normalization of vertex normals, or FALSE to disable it. The default value is FALSE. Enabling this feature causes the system to normalize the vertex normals for vertices after transforming them to camera space, which can be computationally time-consuming.  	
        /// </summary>	
        /// <unmanaged>D3DRS_NORMALIZENORMALS</unmanaged>
        SNormalizenormals = unchecked((int)143),			
        
        /// <summary>	
        ///  Diffuse color source for lighting calculations. Valid values are members of the <see cref="SlimDX2.Direct3D9.Materialcolorsource"/> enumerated type. The default value is D3DMCS_COLOR1. The value for this render state is used only if the D3DRS_COLORVERTEX render state is set to TRUE.  	
        /// </summary>	
        /// <unmanaged>D3DRS_DIFFUSEMATERIALSOURCE</unmanaged>
        SDiffusematerialsource = unchecked((int)145),			
        
        /// <summary>	
        ///  Specular color source for lighting calculations. Valid values are members of the <see cref="SlimDX2.Direct3D9.Materialcolorsource"/> enumerated type. The default value is D3DMCS_COLOR2.  	
        /// </summary>	
        /// <unmanaged>D3DRS_SPECULARMATERIALSOURCE</unmanaged>
        SSpecularmaterialsource = unchecked((int)146),			
        
        /// <summary>	
        ///  Ambient color source for lighting calculations. Valid values are members of the <see cref="SlimDX2.Direct3D9.Materialcolorsource"/> enumerated type. The default value is D3DMCS_MATERIAL.  	
        /// </summary>	
        /// <unmanaged>D3DRS_AMBIENTMATERIALSOURCE</unmanaged>
        SAmbientmaterialsource = unchecked((int)147),			
        
        /// <summary>	
        ///  Emissive color source for lighting calculations. Valid values are members of the <see cref="SlimDX2.Direct3D9.Materialcolorsource"/> enumerated type. The default value is D3DMCS_MATERIAL.  	
        /// </summary>	
        /// <unmanaged>D3DRS_EMISSIVEMATERIALSOURCE</unmanaged>
        SEmissivematerialsource = unchecked((int)148),			
        
        /// <summary>	
        ///  Number of matrices to use to perform geometry blending, if any. Valid values are members of the <see cref="SlimDX2.Direct3D9.Vertexblendflags"/> enumerated type. The default value is D3DVBF_DISABLE. 	
        /// </summary>	
        /// <unmanaged>D3DRS_VERTEXBLEND</unmanaged>
        SVertexblend = unchecked((int)151),			
        
        /// <summary>	
        ///  Enables or disables user-defined clipping planes. Valid values are any DWORD in which the status of each bit (set or not set) toggles the activation state of a corresponding user-defined clipping plane. The least significant bit (bit 0) controls the first clipping plane at index 0, and subsequent bits control the activation of clipping planes at higher indexes. If a bit is set, the system applies the appropriate clipping plane during scene rendering. The default value is 0.  The {{D3DCLIPPLANEn}} macros are defined to provide a convenient way to enable clipping planes. 	
        /// </summary>	
        /// <unmanaged>D3DRS_CLIPPLANEENABLE</unmanaged>
        SClipplaneenable = unchecked((int)152),			
        
        /// <summary>	
        ///  A float value that specifies the size to use for point size computation in cases where point size is not specified for each vertex. This value is not used when the vertex contains point size. This value is in screen space units if D3DRS_POINTSCALEENABLE is FALSE; otherwise this value is in world space units. The default value is the value a driver returns. If a driver returns 0 or 1, the default value is 64, which allows software point size emulation. Because the <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/> method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example.  	
        /// <code> m_pDevice9-&gt;SetRenderState(D3DRS_POINTSIZE, *((DWORD*)&amp;pointSize)); </code>	
        /// 	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DRS_POINTSIZE</unmanaged>
        SPointsize = unchecked((int)154),			
        
        /// <summary>	
        ///  A float value that specifies the minimum size of point primitives. Point primitives are clamped to this size during rendering. Setting this to values smaller than 1.0 results in points dropping out when the point does not cover a pixel center and antialiasing is disabled or being rendered with reduced intensity when antialiasing is enabled. The default value is 1.0f. The range for this value is greater than or equal to 0.0f. Because the <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/> method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example.  	
        /// <code> m_pDevice9-&gt;SetRenderState(D3DRS_POINTSIZE_MIN, *((DWORD*)&amp;pointSizeMin)); </code>	
        /// 	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DRS_POINTSIZE_MIN</unmanaged>
        SPointsizeMinimum = unchecked((int)155),			
        
        /// <summary>	
        ///   bool value. When TRUE, texture coordinates of point primitives are set so that full textures are mapped on each point. When FALSE, the vertex texture coordinates are used for the entire point. The default value is FALSE. You can achieve DirectX 7 style single-pixel points by setting D3DRS_POINTSCALEENABLE to FALSE and D3DRS_POINTSIZE to 1.0, which are the default values.  	
        /// </summary>	
        /// <unmanaged>D3DRS_POINTSPRITEENABLE</unmanaged>
        SPointspriteenable = unchecked((int)156),			
        
        /// <summary>	
        ///   bool value that controls computation of size for point primitives. When TRUE, the point size is interpreted as a camera space value and is scaled by the distance function and the frustum to viewport y-axis scaling to compute the final screen-space point size. When FALSE, the point size is interpreted as screen space and used directly. The default value is FALSE.  	
        /// </summary>	
        /// <unmanaged>D3DRS_POINTSCALEENABLE</unmanaged>
        SPointscaleenable = unchecked((int)157),			
        
        /// <summary>	
        ///  A float value that controls for distance-based size attenuation for point primitives. Active only when D3DRS_POINTSCALEENABLE is TRUE. The default value is 1.0f. The range for this value is greater than or equal to 0.0f. Because the <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/> method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example.  	
        /// <code> m_pDevice9-&gt;SetRenderState(D3DRS_POINTSCALE_A, *((DWORD*)&amp;pointScaleA)); </code>	
        /// 	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DRS_POINTSCALE_A</unmanaged>
        SPointscaleA = unchecked((int)158),			
        
        /// <summary>	
        ///  A float value that controls for distance-based size attenuation for point primitives. Active only when D3DRS_POINTSCALEENABLE is TRUE. The default value is 0.0f. The range for this value is greater than or equal to 0.0f. Because the <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/> method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example.  	
        /// <code> m_pDevice9-&gt;SetRenderState(D3DRS_POINTSCALE_B, *((DWORD*)&amp;pointScaleB)); </code>	
        /// 	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DRS_POINTSCALE_B</unmanaged>
        SPointscaleB = unchecked((int)159),			
        
        /// <summary>	
        ///  A float value that controls for distance-based size attenuation for point primitives. Active only when D3DRS_POINTSCALEENABLE is TRUE. The default value is 0.0f. The range for this value is greater than or equal to 0.0f. Because the <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/> method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example.  	
        /// <code> m_pDevice9-&gt;SetRenderState(D3DRS_POINTSCALE_C, *((DWORD*)&amp;pointScaleC)); </code>	
        /// 	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DRS_POINTSCALE_C</unmanaged>
        SPointscaleC = unchecked((int)160),			
        
        /// <summary>	
        ///   bool value that determines how individual samples are computed when using a multisample render-target buffer. When set to TRUE, the multiple samples are computed so that full-scene antialiasing is performed by sampling at different sample positions for each multiple sample. When set to FALSE, the multiple samples are all written with the same sample value, sampled at the pixel center, which allows non-antialiased rendering to a multisample buffer. This render state has no effect when rendering to a single sample buffer. The default value is TRUE.   	
        /// </summary>	
        /// <unmanaged>D3DRS_MULTISAMPLEANTIALIAS</unmanaged>
        SMultisampleantialias = unchecked((int)161),			
        
        /// <summary>	
        ///  Each bit in this mask, starting at the least significant bit (LSB), controls modification of one of the samples in a multisample render target. Thus, for an 8-sample render target, the low byte contains the eight write enables for each of the eight samples. This render state has no effect when rendering to a single sample buffer. The default value is 0xFFFFFFFF.  This render state enables use of a multisample buffer as an accumulation buffer, doing multipass rendering of geometry where each pass updates a subset of samples. If there are n multisamples and k enabled samples, the resulting intensity of the rendered image should be k/n. Each component RGB of every pixel is factored by k/n. 	
        /// </summary>	
        /// <unmanaged>D3DRS_MULTISAMPLEMASK</unmanaged>
        SMultisamplemask = unchecked((int)162),			
        
        /// <summary>	
        ///  Sets whether patch edges will use float style tessellation. Possible values are defined by the <see cref="SlimDX2.Direct3D9.Patchedgestyle"/> enumerated type. The default value is D3DPATCHEDGE_DISCRETE. 	
        /// </summary>	
        /// <unmanaged>D3DRS_PATCHEDGESTYLE</unmanaged>
        SPatchedgestyle = unchecked((int)163),			
        
        /// <summary>	
        ///  Set only for debugging the monitor. Possible values are defined by the <see cref="SlimDX2.Direct3D9.Debugmonitortokens"/> enumerated type. Note that if D3DRS_DEBUGMONITORTOKEN is set, the call is treated as passing a token to the debug monitor. For example, if - after passing D3DDMT_ENABLE or D3DDMT_DISABLE to D3DRS_DEBUGMONITORTOKEN - other token values are passed in, the state (enabled or disabled) of the debug monitor will still persist.  This state is only useful for debug builds. The debug monitor defaults to D3DDMT_ENABLE. 	
        /// </summary>	
        /// <unmanaged>D3DRS_DEBUGMONITORTOKEN</unmanaged>
        SDebugmonitortoken = unchecked((int)165),			
        
        /// <summary>	
        ///  A float value that specifies the maximum size to which point sprites will be clamped. The value must be less than or equal to the  MaxPointSize member of <see cref="SlimDX2.Direct3D9.Caps9"/> and greater than or equal to D3DRS_POINTSIZE_MIN. The default value is 64.0. Because the <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/> method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example.  	
        /// <code> m_pDevice9-&gt;SetRenderState(D3DRS_PONTSIZE_MAX, *((DWORD*)&amp;pointSizeMax)); </code>	
        /// 	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DRS_POINTSIZE_MAX</unmanaged>
        SPointsizeMaximum = unchecked((int)166),			
        
        /// <summary>	
        ///   bool value that enables or disables indexed vertex blending. The default value is FALSE. When set to TRUE, indexed vertex blending is enabled. When set to FALSE, indexed vertex blending is disabled. If this render state is enabled, the user must pass matrix indices as a packed DWORDwith every vertex. When the render state is disabled and vertex blending is enabled through the D3DRS_VERTEXBLEND state, it is equivalent to having matrix indices 0, 1, 2, 3 in every vertex.  	
        /// </summary>	
        /// <unmanaged>D3DRS_INDEXEDVERTEXBLENDENABLE</unmanaged>
        SIndexedvertexblendenable = unchecked((int)167),			
        
        /// <summary>	
        ///  UINT value that enables a per-channel write for the render-target color buffer. A set bit results in the color channel being updated during 3D rendering. A clear bit results in the color channel being unaffected. This functionality is available if the D3DPMISCCAPS_COLORWRITEENABLE capabilities bit is set in the PrimitiveMiscCaps member of the <see cref="SlimDX2.Direct3D9.Caps9"/> structure for the device. This render state does not affect the clear operation. The default value is 0x0000000F.  Valid values for this render state can be any combination of the D3DCOLORWRITEENABLE_ALPHA, D3DCOLORWRITEENABLE_BLUE, D3DCOLORWRITEENABLE_GREEN, or D3DCOLORWRITEENABLE_RED flags. 	
        /// </summary>	
        /// <unmanaged>D3DRS_COLORWRITEENABLE</unmanaged>
        SColorwriteenable = unchecked((int)168),			
        
        /// <summary>	
        ///  A float value that controls the tween factor. The default value is 0.0f. Because the <see cref="SlimDX2.Direct3D9.Device.SetRenderState"/> method accepts DWORD values, your application must cast a variable that contains the value, as shown in the following code example.  	
        /// <code> m_pDevice9-&gt;SetRenderState(D3DRS_TWEENFACTOR, *((DWORD*)&amp;TweenFactor)); </code>	
        /// 	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DRS_TWEENFACTOR</unmanaged>
        STweenfactor = unchecked((int)170),			
        
        /// <summary>	
        ///  Value used to select the arithmetic operation applied when the alpha blending render state, D3DRS_ALPHABLENDENABLE, is set to TRUE. Valid values are defined by the <see cref="SlimDX2.Direct3D9.Blendop"/> enumerated type. The default value is D3DBLENDOP_ADD.  If the D3DPMISCCAPS_BLENDOP device capability is not supported, then D3DBLENDOP_ADD is performed. 	
        /// </summary>	
        /// <unmanaged>D3DRS_BLENDOP</unmanaged>
        SBlendop = unchecked((int)171),			
        
        /// <summary>	
        ///  N-patch position interpolation degree. The values can be D3DDEGREE_CUBIC (default) or D3DDEGREE_LINEAR. For more information, see <see cref="SlimDX2.Direct3D9.Degreetype"/>. 	
        /// </summary>	
        /// <unmanaged>D3DRS_POSITIONDEGREE</unmanaged>
        SPositiondegree = unchecked((int)172),			
        
        /// <summary>	
        ///  N-patch normal interpolation degree. The values can be D3DDEGREE_LINEAR (default) or D3DDEGREE_QUADRATIC. For more information, see <see cref="SlimDX2.Direct3D9.Degreetype"/>. 	
        /// </summary>	
        /// <unmanaged>D3DRS_NORMALDEGREE</unmanaged>
        SNormaldegree = unchecked((int)173),			
        
        /// <summary>	
        ///  TRUE to enable scissor testing and FALSE to disable it. The default value is FALSE. 	
        /// </summary>	
        /// <unmanaged>D3DRS_SCISSORTESTENABLE</unmanaged>
        SScissortestenable = unchecked((int)174),			
        
        /// <summary>	
        ///  Used to determine how much bias can be applied to co-planar primitives to reduce z-fighting. The default value is 0. bias = (max * D3DRS_SLOPESCALEDEPTHBIAS) + D3DRS_DEPTHBIAS. where max is the maximum depth slope of the triangle being rendered. 	
        /// </summary>	
        /// <unmanaged>D3DRS_SLOPESCALEDEPTHBIAS</unmanaged>
        SSlopescaledepthbias = unchecked((int)175),			
        
        /// <summary>	
        ///  TRUE to enable line antialiasing, FALSE to disable line antialiasing. The default value is FALSE. When rendering to a multisample render target, D3DRS_ANTIALIASEDLINEENABLE is ignored and all lines are rendered aliased. Use <see cref="SlimDX2.Direct3D9.Line"/> for antialiased line rendering in a multisample render target. 	
        /// </summary>	
        /// <unmanaged>D3DRS_ANTIALIASEDLINEENABLE</unmanaged>
        SAntialiasedlineenable = unchecked((int)176),			
        
        /// <summary>	
        ///  Minimum tessellation level. The default value is 1.0f. See {{Tessellation (Direct3D 9)}}. 	
        /// </summary>	
        /// <unmanaged>D3DRS_MINTESSELLATIONLEVEL</unmanaged>
        SMintessellationlevel = unchecked((int)178),			
        
        /// <summary>	
        ///  Maximum tessellation level. The default value is 1.0f. See {{Tessellation (Direct3D 9)}}. 	
        /// </summary>	
        /// <unmanaged>D3DRS_MAXTESSELLATIONLEVEL</unmanaged>
        SMaxtessellationlevel = unchecked((int)179),			
        
        /// <summary>	
        ///  Amount to adaptively tessellate, in the x direction. Default value is 0.0f. See {{Adaptive Tessellation}}. 	
        /// </summary>	
        /// <unmanaged>D3DRS_ADAPTIVETESS_X</unmanaged>
        SAdaptivetessX = unchecked((int)180),			
        
        /// <summary>	
        ///  Amount to adaptively tessellate, in the y direction. Default value is 0.0f. See {{Adaptive_Tessellation}}. 	
        /// </summary>	
        /// <unmanaged>D3DRS_ADAPTIVETESS_Y</unmanaged>
        SAdaptivetessY = unchecked((int)181),			
        
        /// <summary>	
        ///  Amount to adaptively tessellate, in the z direction. Default value is 1.0f. See {{Adaptive_Tessellation}}. 	
        /// </summary>	
        /// <unmanaged>D3DRS_ADAPTIVETESS_Z</unmanaged>
        SAdaptivetessZ = unchecked((int)182),			
        
        /// <summary>	
        ///  Amount to adaptively tessellate, in the w direction. Default value is 0.0f. See {{Adaptive_Tessellation}}. 	
        /// </summary>	
        /// <unmanaged>D3DRS_ADAPTIVETESS_W</unmanaged>
        SAdaptivetessW = unchecked((int)183),			
        
        /// <summary>	
        ///  TRUE to enable adaptive tessellation, FALSE to disable it. The default value is FALSE.  See {{Adaptive_Tessellation}}. 	
        /// </summary>	
        /// <unmanaged>D3DRS_ENABLEADAPTIVETESSELLATION</unmanaged>
        SEnableadaptivetessellation = unchecked((int)184),			
        
        /// <summary>	
        ///  TRUE enables two-sided stenciling, FALSE disables it. The default value is FALSE. The application should set D3DRS_CULLMODE to D3DCULL_NONE to enable two-sided stencil mode. If the triangle winding order is clockwise, the D3DRS_STENCIL* operations will be used. If the winding order is counterclockwise, the D3DRS_CCW_STENCIL* operations will be used. To see if two-sided stencil is supported, check the StencilCaps member of <see cref="SlimDX2.Direct3D9.Caps9"/> for D3DSTENCILCAPS_TWOSIDED. See also {{D3DSTENCILCAPS}}. 	
        /// </summary>	
        /// <unmanaged>D3DRS_TWOSIDEDSTENCILMODE</unmanaged>
        STwosidedstencilmode = unchecked((int)185),			
        
        /// <summary>	
        ///  Stencil operation to perform if CCW stencil test fails. Values are from the <see cref="SlimDX2.Direct3D9.StencilOperation"/> enumerated type. The default value is D3DSTENCILOP_KEEP. 	
        /// </summary>	
        /// <unmanaged>D3DRS_CCW_STENCILFAIL</unmanaged>
        SCcwStencilfail = unchecked((int)186),			
        
        /// <summary>	
        ///  Stencil operation to perform if CCW stencil test passes and z-test fails. Values are from the <see cref="SlimDX2.Direct3D9.StencilOperation"/> enumerated type. The default value is D3DSTENCILOP_KEEP. 	
        /// </summary>	
        /// <unmanaged>D3DRS_CCW_STENCILZFAIL</unmanaged>
        SCcwStencilzfail = unchecked((int)187),			
        
        /// <summary>	
        ///  Stencil operation to perform if both CCW stencil and z-tests pass. Values are from the <see cref="SlimDX2.Direct3D9.StencilOperation"/> enumerated type. The default value is D3DSTENCILOP_KEEP. 	
        /// </summary>	
        /// <unmanaged>D3DRS_CCW_STENCILPASS</unmanaged>
        SCcwStencilpass = unchecked((int)188),			
        
        /// <summary>	
        ///  The comparison function. CCW stencil test passes if ((ref &amp; mask) stencil function (stencil &amp; mask)) is true. Values are from the <see cref="SlimDX2.Direct3D9.Cmpfunc"/> enumerated type. The default value is D3DCMP_ALWAYS. 	
        /// </summary>	
        /// <unmanaged>D3DRS_CCW_STENCILFUNC</unmanaged>
        SCcwStencilfunc = unchecked((int)189),			
        
        /// <summary>	
        ///  Additional ColorWriteEnable values for the devices. See D3DRS_COLORWRITEENABLE. This functionality is available if the D3DPMISCCAPS_INDEPENDENTWRITEMASKS capabilities bit is set in the 	PrimitiveMiscCaps member of the <see cref="SlimDX2.Direct3D9.Caps9"/> structure for the device. The default value is 0x0000000f. 	
        /// </summary>	
        /// <unmanaged>D3DRS_COLORWRITEENABLE1</unmanaged>
        SColorwriteenable1 = unchecked((int)190),			
        
        /// <summary>	
        ///  Additional ColorWriteEnable values for the devices. See D3DRS_COLORWRITEENABLE. This functionality is available if the D3DPMISCCAPS_INDEPENDENTWRITEMASKS capabilities bit is set in the 	PrimitiveMiscCaps member of the <see cref="SlimDX2.Direct3D9.Caps9"/> structure for the device. The default value is 0x0000000f. 	
        /// </summary>	
        /// <unmanaged>D3DRS_COLORWRITEENABLE2</unmanaged>
        SColorwriteenable2 = unchecked((int)191),			
        
        /// <summary>	
        ///  Additional ColorWriteEnable values for the devices. See D3DRS_COLORWRITEENABLE. This functionality is available if the D3DPMISCCAPS_INDEPENDENTWRITEMASKS capabilities bit is set in the 	PrimitiveMiscCaps member of the <see cref="SlimDX2.Direct3D9.Caps9"/> structure for the device. The default value is 0x0000000f. 	
        /// </summary>	
        /// <unmanaged>D3DRS_COLORWRITEENABLE3</unmanaged>
        SColorwriteenable3 = unchecked((int)192),			
        
        /// <summary>	
        ///   <see cref="int"/> used for a constant blend-factor during alpha blending. This functionality is available if the D3DPBLENDCAPS_BLENDFACTOR capabilities bit is set in the SrcBlendCaps member of <see cref="SlimDX2.Direct3D9.Caps9"/> or the DestBlendCaps member of D3DCAPS9. See <see cref="SlimDX2.Direct3D9.Renderstatetype"/>. The default value is 0xffffffff. 	
        /// </summary>	
        /// <unmanaged>D3DRS_BLENDFACTOR</unmanaged>
        SBlendfactor = unchecked((int)193),			
        
        /// <summary>	
        ///  Enable render-target writes to be gamma corrected to sRGB. The format must expose D3DUSAGE_SRGBWRITE. The default value is 0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_SRGBWRITEENABLE</unmanaged>
        SSrgbwriteenable = unchecked((int)194),			
        
        /// <summary>	
        ///  A floating-point value that is used for comparison of depth values. See {{Depth Bias (Direct3D 9)}}. The default value is 0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_DEPTHBIAS</unmanaged>
        SDepthbias = unchecked((int)195),			
        
        /// <summary>	
        ///  See D3DRS_WRAP0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_WRAP8</unmanaged>
        SWrap8 = unchecked((int)198),			
        
        /// <summary>	
        ///  See D3DRS_WRAP0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_WRAP9</unmanaged>
        SWrap9 = unchecked((int)199),			
        
        /// <summary>	
        ///  See D3DRS_WRAP0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_WRAP10</unmanaged>
        SWrap10 = unchecked((int)200),			
        
        /// <summary>	
        ///  See D3DRS_WRAP0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_WRAP11</unmanaged>
        SWrap11 = unchecked((int)201),			
        
        /// <summary>	
        ///  See D3DRS_WRAP0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_WRAP12</unmanaged>
        SWrap12 = unchecked((int)202),			
        
        /// <summary>	
        ///  See D3DRS_WRAP0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_WRAP13</unmanaged>
        SWrap13 = unchecked((int)203),			
        
        /// <summary>	
        ///  See D3DRS_WRAP0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_WRAP14</unmanaged>
        SWrap14 = unchecked((int)204),			
        
        /// <summary>	
        ///  See D3DRS_WRAP0. 	
        /// </summary>	
        /// <unmanaged>D3DRS_WRAP15</unmanaged>
        SWrap15 = unchecked((int)205),			
        
        /// <summary>	
        ///  TRUE enables the separate blend mode for the alpha channel.  The default value is FALSE.   When set to false, the render-target blending factors and operations applied to alpha are forced to be the same as those defined for color. This mode is effectively hardwired to false on implementations that don't set the cap D3DPMISCCAPS_SEPARATEALPHABLEND. See {{D3DPMISCCAPS}}. The type of separate alpha blending is determined by the D3DRS_SRCBLENDALPHA and D3DRS_DESTBLENDALPHA render states. 	
        /// </summary>	
        /// <unmanaged>D3DRS_SEPARATEALPHABLENDENABLE</unmanaged>
        SSeparatealphablendenable = unchecked((int)206),			
        
        /// <summary>	
        ///  One member of the <see cref="SlimDX2.Direct3D9.Blend"/> enumerated type.  This value is ignored unless D3DRS_SEPARATEALPHABLENDENABLE is true.  The default value is D3DBLEND_ONE. 	
        /// </summary>	
        /// <unmanaged>D3DRS_SRCBLENDALPHA</unmanaged>
        SSrcblendalpha = unchecked((int)207),			
        
        /// <summary>	
        ///  One member of the <see cref="SlimDX2.Direct3D9.Blend"/> enumerated type.  This value is ignored unless D3DRS_SEPARATEALPHABLENDENABLE is true.  The default value is D3DBLEND_ZERO. 	
        /// </summary>	
        /// <unmanaged>D3DRS_DESTBLENDALPHA</unmanaged>
        SDestblendalpha = unchecked((int)208),			
        
        /// <summary>	
        ///  Value used to select the arithmetic operation applied to separate alpha blending when the render state, D3DRS_SEPARATEALPHABLENDENABLE, is set to TRUE.   Valid values are defined by the <see cref="SlimDX2.Direct3D9.Blendop"/> enumerated type. The default value is D3DBLENDOP_ADD. If the D3DPMISCCAPS_BLENDOP device capability is not supported, then D3DBLENDOP_ADD is performed. See {{D3DPMISCCAPS}}. 	
        /// </summary>	
        /// <unmanaged>D3DRS_BLENDOPALPHA</unmanaged>
        SBlendopalpha = unchecked((int)209),			
    }
    
    /// <summary>	
    /// Defines the location at which a color or color component must be accessed for lighting calculations.	
    /// </summary>	
    /// <remarks>	
    ///  These flags are used to set the value of the following render states in the <see cref="SlimDX2.Direct3D9.Renderstatetype"/> enumerated type.   D3DRS_AMBIENTMATERIALSOURCE D3DRS_DIFFUSEMATERIALSOURCE D3DRS_EMISSIVEMATERIALSOURCE D3DRS_SPECULARMATERIALSOURCE  	
    /// </remarks>	
    /// <unmanaged>D3DMATERIALCOLORSOURCE</unmanaged>
    public enum Materialcolorsource : int {	
        
        /// <summary>	
        ///  Use the color from the current material.  	
        /// </summary>	
        /// <unmanaged>D3DMCS_MATERIAL</unmanaged>
        CsMaterial = unchecked((int)0),			
        
        /// <summary>	
        ///  Use the diffuse vertex color.  	
        /// </summary>	
        /// <unmanaged>D3DMCS_COLOR1</unmanaged>
        CsColor1 = unchecked((int)1),			
        
        /// <summary>	
        ///  Use the specular vertex color.  	
        /// </summary>	
        /// <unmanaged>D3DMCS_COLOR2</unmanaged>
        CsColor2 = unchecked((int)2),			
    }
    
    /// <summary>	
    /// Texture stage states define multi-blender texture operations. Some sampler states set up vertex processing, and some set up pixel processing. Texture stage states can be saved and restored using stateblocks (see {{State Blocks Save and Restore State (Direct3D 9)}}).	
    /// </summary>	
    /// <remarks>	
    ///  Members of this enumerated type are used with the <see cref="SlimDX2.Direct3D9.Device.GetTextureStageState"/> and <see cref="SlimDX2.Direct3D9.Device.SetTextureStageState"/> methods to retrieve and set texture state values. The valid range of values for the D3DTSS_BUMPENVMAT00, D3DTSS_BUMPENVMAT01, D3DTSS_BUMPENVMAT10, and D3DTSS_BUMPENVMAT11 bump-mapping matrix coefficients is greater than or equal to -8.0 and less than 8.0. This range, expressed in mathematical notation is (-8.0,8.0). 	
    /// </remarks>	
    /// <unmanaged>D3DTEXTURESTAGESTATETYPE</unmanaged>
    public enum Texturestagestatetype : int {	
        
        /// <summary>	
        ///  Texture-stage state is a texture color blending operation identified by one member of the <see cref="SlimDX2.Direct3D9.Textureop"/> enumerated type. The default value for the first texture stage (stage 0) is D3DTOP_MODULATE; for all other stages the default is D3DTOP_DISABLE.  	
        /// </summary>	
        /// <unmanaged>D3DTSS_COLOROP</unmanaged>
        SsColorop = unchecked((int)1),			
        
        /// <summary>	
        ///  Texture-stage state is the first color argument for the stage, identified by one of the {{D3DTA}}. The default argument is D3DTA_TEXTURE.  Specify D3DTA_TEMP to select a temporary register color for read or write. D3DTA_TEMP is supported if the D3DPMISCCAPS_TSSARGTEMP device capability is present. The default value for the register is (0.0, 0.0, 0.0, 0.0). 	
        /// </summary>	
        /// <unmanaged>D3DTSS_COLORARG1</unmanaged>
        SsColorarg1 = unchecked((int)2),			
        
        /// <summary>	
        ///  Texture-stage state is the second color argument for the stage, identified by {{D3DTA}}. The default argument is D3DTA_CURRENT. Specify D3DTA_TEMP to select a temporary register color for read or write. D3DTA_TEMP is supported if the D3DPMISCCAPS_TSSARGTEMP device capability is present. The default value for the register is (0.0, 0.0, 0.0, 0.0) 	
        /// </summary>	
        /// <unmanaged>D3DTSS_COLORARG2</unmanaged>
        SsColorarg2 = unchecked((int)3),			
        
        /// <summary>	
        ///  Texture-stage state is a texture alpha blending operation identified by one member of the <see cref="SlimDX2.Direct3D9.Textureop"/> enumerated type. The default value for the first texture stage (stage 0) is D3DTOP_SELECTARG1, and for all other stages the default is D3DTOP_DISABLE.  	
        /// </summary>	
        /// <unmanaged>D3DTSS_ALPHAOP</unmanaged>
        SsAlphaop = unchecked((int)4),			
        
        /// <summary>	
        ///  Texture-stage state is the first alpha argument for the stage, identified by by {{D3DTA}}. The default argument is D3DTA_TEXTURE. If no texture is set for this stage, the default argument is D3DTA_DIFFUSE. Specify D3DTA_TEMP to select a temporary register color for read or write. D3DTA_TEMP is supported if the D3DPMISCCAPS_TSSARGTEMP device capability is present. The default value for the register is (0.0, 0.0, 0.0, 0.0). 	
        /// </summary>	
        /// <unmanaged>D3DTSS_ALPHAARG1</unmanaged>
        SsAlphaarg1 = unchecked((int)5),			
        
        /// <summary>	
        ///  Texture-stage state is the second alpha argument for the stage, identified by by {{D3DTA}}. The default argument is D3DTA_CURRENT. Specify D3DTA_TEMP to select a temporary register color for read or write. D3DTA_TEMP is supported if the D3DPMISCCAPS_TSSARGTEMP device capability is present. The default value for the register is (0.0, 0.0, 0.0, 0.0).  	
        /// </summary>	
        /// <unmanaged>D3DTSS_ALPHAARG2</unmanaged>
        SsAlphaarg2 = unchecked((int)6),			
        
        /// <summary>	
        ///  Texture-stage state is a floating-point value for the [0][0] coefficient in a bump-mapping matrix. The default value is 0.0.  	
        /// </summary>	
        /// <unmanaged>D3DTSS_BUMPENVMAT00</unmanaged>
        SsBumpenvmat00 = unchecked((int)7),			
        
        /// <summary>	
        ///  Texture-stage state is a floating-point value for the [0][1] coefficient in a bump-mapping matrix. The default value is 0.0.  	
        /// </summary>	
        /// <unmanaged>D3DTSS_BUMPENVMAT01</unmanaged>
        SsBumpenvmat01 = unchecked((int)8),			
        
        /// <summary>	
        ///  Texture-stage state is a floating-point value for the [1][0] coefficient in a bump-mapping matrix. The default value is 0.0.  	
        /// </summary>	
        /// <unmanaged>D3DTSS_BUMPENVMAT10</unmanaged>
        SsBumpenvmat10 = unchecked((int)9),			
        
        /// <summary>	
        ///  Texture-stage state is a floating-point value for the [1][1] coefficient in a bump-mapping matrix. The default value is 0.0.  	
        /// </summary>	
        /// <unmanaged>D3DTSS_BUMPENVMAT11</unmanaged>
        SsBumpenvmat11 = unchecked((int)10),			
        
        /// <summary>	
        ///  Index of the texture coordinate set to use with this texture stage. You can specify up to eight sets of texture coordinates per vertex. If a vertex does not include a set of texture coordinates at the specified index, the system defaults to the u and v coordinates (0,0). When rendering using vertex shaders, each stage's texture coordinate index must be set to its default value. The default index for each stage is equal to the stage index. Set this state to the zero-based index of the coordinate set for each vertex that this texture stage uses. Additionally, applications can include, as logical OR with the index being set, one of the constants to request that Direct3D automatically generate the input texture coordinates for a texture transformation. For a list of all the constants, see {{D3DTSS_TCI}}. With the exception of D3DTSS_TCI_PASSTHRU, which resolves to zero, if any of the following values is included with the index being set, the system uses the index strictly to determine texture wrapping mode. These flags are most useful when performing environment mapping. 	
        /// </summary>	
        /// <unmanaged>D3DTSS_TEXCOORDINDEX</unmanaged>
        SsTexcoordindex = unchecked((int)11),			
        
        /// <summary>	
        ///  Floating-point scale value for bump-map luminance. The default value is 0.0.  	
        /// </summary>	
        /// <unmanaged>D3DTSS_BUMPENVLSCALE</unmanaged>
        SsBumpenvlscale = unchecked((int)22),			
        
        /// <summary>	
        ///  Floating-point offset value for bump-map luminance. The default value is 0.0.  	
        /// </summary>	
        /// <unmanaged>D3DTSS_BUMPENVLOFFSET</unmanaged>
        SsBumpenvloffset = unchecked((int)23),			
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Texturetransformflags"/> enumerated type that controls the transformation of texture coordinates for this texture stage. The default value is D3DTTFF_DISABLE.  	
        /// </summary>	
        /// <unmanaged>D3DTSS_TEXTURETRANSFORMFLAGS</unmanaged>
        SsTexturetransformflags = unchecked((int)24),			
        
        /// <summary>	
        ///  Settings for the third color operand for triadic operations (multiply, add, and linearly interpolate), identified by {{D3DTA}}. This setting is supported if the D3DTEXOPCAPS_MULTIPLYADD or D3DTEXOPCAPS_LERP device capabilities are present. The default argument is D3DTA_CURRENT. Specify D3DTA_TEMP to select a temporary register color for read or write. D3DTA_TEMP is supported if the D3DPMISCCAPS_TSSARGTEMP device capability is present. The default value for the register is (0.0, 0.0, 0.0, 0.0).  	
        /// </summary>	
        /// <unmanaged>D3DTSS_COLORARG0</unmanaged>
        SsColorarg0 = unchecked((int)26),			
        
        /// <summary>	
        ///  Settings for the alpha channel selector operand for triadic operations (multiply, add, and linearly interpolate), identified by {{D3DTA}}. This setting is supported if the D3DTEXOPCAPS_MULTIPLYADD or D3DTEXOPCAPS_LERP device capabilities are present. The default argument is D3DTA_CURRENT. Specify D3DTA_TEMP to select a temporary register color for read or write. D3DTA_TEMP is supported if the D3DPMISCCAPS_TSSARGTEMP device capability is present. The default argument is (0.0, 0.0, 0.0, 0.0).  	
        /// </summary>	
        /// <unmanaged>D3DTSS_ALPHAARG0</unmanaged>
        SsAlphaarg0 = unchecked((int)27),			
        
        /// <summary>	
        ///  Setting to select destination register for the result of this stage, identified by {{D3DTA}}. This value can be set to D3DTA_CURRENT (the default value) or to D3DTA_TEMP, which is a single temporary register that can be read into subsequent stages as an input argument. The final color passed to the fog blender and frame buffer is taken from D3DTA_CURRENT, so the last active texture stage state must be set to write to current. This setting is supported if the D3DPMISCCAPS_TSSARGTEMP device capability is present.  	
        /// </summary>	
        /// <unmanaged>D3DTSS_RESULTARG</unmanaged>
        SsResultarg = unchecked((int)28),			
        
        /// <summary>	
        ///  Per-stage constant color. To see if a device supports a per-stage constant color, see the D3DPMISCCAPS_PERSTAGECONSTANT constant in {{D3DPMISCCAPS}}. D3DTSS_CONSTANT is used by D3DTA_CONSTANT. See {{D3DTA}}.   	
        /// </summary>	
        /// <unmanaged>D3DTSS_CONSTANT</unmanaged>
        SsConstant = unchecked((int)32),			
    }
    
    /// <summary>	
    /// Sampler states define texture sampling operations such as texture addressing and texture filtering. Some sampler states set-up vertex processing, and some set-up pixel processing. Sampler states can be saved and restored using stateblocks (see {{State Blocks Save and Restore State (Direct3D 9)}}).	
    /// </summary>	
    /// <unmanaged>D3DSAMPLERSTATETYPE</unmanaged>
    public enum Samplerstatetype : int {	
        
        /// <summary>	
        ///  Texture-address mode for the u coordinate. The default is D3DTADDRESS_WRAP. For more information, see <see cref="SlimDX2.Direct3D9.Textureaddress"/>. 	
        /// </summary>	
        /// <unmanaged>D3DSAMP_ADDRESSU</unmanaged>
        Addressu = unchecked((int)1),			
        
        /// <summary>	
        ///  Texture-address mode for the v coordinate. The default is D3DTADDRESS_WRAP. For more information, see <see cref="SlimDX2.Direct3D9.Textureaddress"/>. 	
        /// </summary>	
        /// <unmanaged>D3DSAMP_ADDRESSV</unmanaged>
        Addressv = unchecked((int)2),			
        
        /// <summary>	
        ///  Texture-address mode for the w coordinate. The default is D3DTADDRESS_WRAP. For more information, see <see cref="SlimDX2.Direct3D9.Textureaddress"/>. 	
        /// </summary>	
        /// <unmanaged>D3DSAMP_ADDRESSW</unmanaged>
        Addressw = unchecked((int)3),			
        
        /// <summary>	
        ///  Border color or type <see cref="int"/>. The default color is 0x00000000. 	
        /// </summary>	
        /// <unmanaged>D3DSAMP_BORDERCOLOR</unmanaged>
        Bordercolor = unchecked((int)4),			
        
        /// <summary>	
        ///  Magnification filter of type <see cref="SlimDX2.Direct3D9.Texturefiltertype"/>. The default value is D3DTEXF_POINT. 	
        /// </summary>	
        /// <unmanaged>D3DSAMP_MAGFILTER</unmanaged>
        Magfilter = unchecked((int)5),			
        
        /// <summary>	
        ///  Minification filter of type <see cref="SlimDX2.Direct3D9.Texturefiltertype"/>. The default value is D3DTEXF_POINT. 	
        /// </summary>	
        /// <unmanaged>D3DSAMP_MINFILTER</unmanaged>
        Minfilter = unchecked((int)6),			
        
        /// <summary>	
        ///  Mipmap filter to use during minification. See <see cref="SlimDX2.Direct3D9.Texturefiltertype"/>. The default value is D3DTEXF_NONE. 	
        /// </summary>	
        /// <unmanaged>D3DSAMP_MIPFILTER</unmanaged>
        Mipfilter = unchecked((int)7),			
        
        /// <summary>	
        ///  Mipmap level-of-detail bias. The default value is zero. 	
        /// </summary>	
        /// <unmanaged>D3DSAMP_MIPMAPLODBIAS</unmanaged>
        Mipmaplodbias = unchecked((int)8),			
        
        /// <summary>	
        ///  level-of-detail index of largest map to use. Values range from 0 to (n - 1) where 0 is the largest. The default value is zero. 	
        /// </summary>	
        /// <unmanaged>D3DSAMP_MAXMIPLEVEL</unmanaged>
        Maxmiplevel = unchecked((int)9),			
        
        /// <summary>	
        ///  DWORD maximum anisotropy. Values range from 1 to the value that is specified in the MaxAnisotropy member of the <see cref="SlimDX2.Direct3D9.Caps9"/> structure. The default value is 1. 	
        /// </summary>	
        /// <unmanaged>D3DSAMP_MAXANISOTROPY</unmanaged>
        Maxanisotropy = unchecked((int)10),			
        
        /// <summary>	
        ///  Gamma correction value. The default value is 0, which means gamma is 1.0 and no correction is required. Otherwise, this value means that the sampler should assume gamma of 2.2 on the content and convert it to linear (gamma 1.0) before presenting it to the pixel shader. 	
        /// </summary>	
        /// <unmanaged>D3DSAMP_SRGBTEXTURE</unmanaged>
        Srgbtexture = unchecked((int)11),			
        
        /// <summary>	
        ///  When a multielement texture is assigned to the sampler, this indicates which element index to use.  The default value is 0. 	
        /// </summary>	
        /// <unmanaged>D3DSAMP_ELEMENTINDEX</unmanaged>
        Elementindex = unchecked((int)12),			
        
        /// <summary>	
        ///  Vertex offset in the presampled displacement map. This is a constant used by the tessellator, its default value is 0. 	
        /// </summary>	
        /// <unmanaged>D3DSAMP_DMAPOFFSET</unmanaged>
        Dmapoffset = unchecked((int)13),			
    }
    
    /// <summary>	
    /// Defines per-stage texture-blending operations.	
    /// </summary>	
    /// <remarks>	
    ///   The members of this type are used when setting color or alpha operations by using the D3DTSS_COLOROP or D3DTSS_ALPHAOP values with the <see cref="SlimDX2.Direct3D9.Device.SetTextureStageState"/> method.   In the above formulas, SRGBA is the RGBA color produced by a texture operation, and 	Arg1, Arg2, and Arg3 represent the complete RGBA color of the texture arguments. Individual components of an argument are shown with subscripts. For example, the alpha component for argument 1 would be shown as Arg1A.  	
    /// </remarks>	
    /// <unmanaged>D3DTEXTUREOP</unmanaged>
    public enum Textureop : int {	
        
        /// <summary>	
        ///  Disables output from this texture stage and all stages with a higher index. To disable texture mapping, set this as the color operation for the first texture stage (stage 0). Alpha operations cannot be disabled when color operations are enabled. Setting the alpha operation to D3DTOP_DISABLE when color blending is enabled causes undefined behavior.  	
        /// </summary>	
        /// <unmanaged>D3DTOP_DISABLE</unmanaged>
        OperationDisable = unchecked((int)1),			
        
        /// <summary>	
        ///  Use this texture stage's first color or alpha argument, unmodified, as the output. This operation affects the color argument when used with the D3DTSS_COLOROP texture-stage state, and the alpha argument when used with D3DTSS_ALPHAOP.     	
        /// </summary>	
        /// <unmanaged>D3DTOP_SELECTARG1</unmanaged>
        OperationSelectarg1 = unchecked((int)2),			
        
        /// <summary>	
        ///  Use this texture stage's second color or alpha argument, unmodified, as the output. This operation affects the color argument when used with the D3DTSS_COLOROP texture stage state, and the alpha argument when used with D3DTSS_ALPHAOP.     	
        /// </summary>	
        /// <unmanaged>D3DTOP_SELECTARG2</unmanaged>
        OperationSelectarg2 = unchecked((int)3),			
        
        /// <summary>	
        ///  Multiply the components of the arguments.     	
        /// </summary>	
        /// <unmanaged>D3DTOP_MODULATE</unmanaged>
        OperationModulate = unchecked((int)4),			
        
        /// <summary>	
        ///  Multiply the components of the arguments, and shift the products to the left 1 bit (effectively multiplying them by 2) for brightening.     	
        /// </summary>	
        /// <unmanaged>D3DTOP_MODULATE2X</unmanaged>
        OperationModulate2x = unchecked((int)5),			
        
        /// <summary>	
        ///  Multiply the components of the arguments, and shift the products to the left 2 bits (effectively multiplying them by 4) for brightening.     	
        /// </summary>	
        /// <unmanaged>D3DTOP_MODULATE4X</unmanaged>
        OperationModulate4x = unchecked((int)6),			
        
        /// <summary>	
        ///  Add the components of the arguments.     	
        /// </summary>	
        /// <unmanaged>D3DTOP_ADD</unmanaged>
        OperationAdd = unchecked((int)7),			
        
        /// <summary>	
        ///  Add the components of the arguments with a  - 0.5 bias, making the effective range of values from  - 0.5 through 0.5.     	
        /// </summary>	
        /// <unmanaged>D3DTOP_ADDSIGNED</unmanaged>
        OperationAddsigned = unchecked((int)8),			
        
        /// <summary>	
        ///  Add the components of the arguments with a  - 0.5 bias, and shift the products to the left 1 bit.     	
        /// </summary>	
        /// <unmanaged>D3DTOP_ADDSIGNED2X</unmanaged>
        OperationAddsigned2x = unchecked((int)9),			
        
        /// <summary>	
        ///  Subtract the components of the second argument from those of the first argument.     	
        /// </summary>	
        /// <unmanaged>D3DTOP_SUBTRACT</unmanaged>
        OperationSubtract = unchecked((int)10),			
        
        /// <summary>	
        ///  Add the first and second arguments; then subtract their product from the sum.     	
        /// </summary>	
        /// <unmanaged>D3DTOP_ADDSMOOTH</unmanaged>
        OperationAddsmooth = unchecked((int)11),			
        
        /// <summary>	
        ///  Linearly blend this texture stage, using the interpolated alpha from each vertex.     	
        /// </summary>	
        /// <unmanaged>D3DTOP_BLENDDIFFUSEALPHA</unmanaged>
        OperationBlenddiffusealpha = unchecked((int)12),			
        
        /// <summary>	
        ///  Linearly blend this texture stage, using the alpha from this stage's texture.     	
        /// </summary>	
        /// <unmanaged>D3DTOP_BLENDTEXTUREALPHA</unmanaged>
        OperationBlendtexturealpha = unchecked((int)13),			
        
        /// <summary>	
        ///  Linearly blend this texture stage, using a scalar alpha set with the D3DRS_TEXTUREFACTOR render state.     	
        /// </summary>	
        /// <unmanaged>D3DTOP_BLENDFACTORALPHA</unmanaged>
        OperationBlendfactoralpha = unchecked((int)14),			
        
        /// <summary>	
        ///  Linearly blend a texture stage that uses a premultiplied alpha.     	
        /// </summary>	
        /// <unmanaged>D3DTOP_BLENDTEXTUREALPHAPM</unmanaged>
        OperationBlendtexturealphapm = unchecked((int)15),			
        
        /// <summary>	
        ///  Linearly blend this texture stage, using the alpha taken from the previous texture stage.     	
        /// </summary>	
        /// <unmanaged>D3DTOP_BLENDCURRENTALPHA</unmanaged>
        OperationBlendcurrentalpha = unchecked((int)16),			
        
        /// <summary>	
        ///  D3DTOP_PREMODULATE is set in stage n. The output of stage n is arg1. Additionally, if there is a texture in stage n + 1, any D3DTA_CURRENT in stage n + 1 is premultiplied by texture in stage n + 1. 	
        /// </summary>	
        /// <unmanaged>D3DTOP_PREMODULATE</unmanaged>
        OperationPremodulate = unchecked((int)17),			
        
        /// <summary>	
        ///  Modulate the color of the second argument, using the alpha of the first argument; then add the result to argument one. This operation is supported only for color operations (D3DTSS_COLOROP).     	
        /// </summary>	
        /// <unmanaged>D3DTOP_MODULATEALPHA_ADDCOLOR</unmanaged>
        OperationModulatealphaAddcolor = unchecked((int)18),			
        
        /// <summary>	
        ///  Modulate the arguments; then add the alpha of the first argument. This operation is supported only for color operations (D3DTSS_COLOROP).     	
        /// </summary>	
        /// <unmanaged>D3DTOP_MODULATECOLOR_ADDALPHA</unmanaged>
        OperationModulatecolorAddalpha = unchecked((int)19),			
        
        /// <summary>	
        ///  Similar to D3DTOP_MODULATEALPHA_ADDCOLOR, but use the inverse of the alpha of the first argument. This operation is supported only for color operations (D3DTSS_COLOROP).     	
        /// </summary>	
        /// <unmanaged>D3DTOP_MODULATEINVALPHA_ADDCOLOR</unmanaged>
        OperationModulateinvalphaAddcolor = unchecked((int)20),			
        
        /// <summary>	
        ///  Similar to D3DTOP_MODULATECOLOR_ADDALPHA, but use the inverse of the color of the first argument. This operation is supported only for color operations (D3DTSS_COLOROP).     	
        /// </summary>	
        /// <unmanaged>D3DTOP_MODULATEINVCOLOR_ADDALPHA</unmanaged>
        OperationModulateinvcolorAddalpha = unchecked((int)21),			
        
        /// <summary>	
        ///  Perform per-pixel bump mapping, using the environment map in the next texture stage, without luminance. This operation is supported only for color operations (D3DTSS_COLOROP).  	
        /// </summary>	
        /// <unmanaged>D3DTOP_BUMPENVMAP</unmanaged>
        OperationBumpenvmap = unchecked((int)22),			
        
        /// <summary>	
        ///  Perform per-pixel bump mapping, using the environment map in the next texture stage, with luminance. This operation is supported only for color operations (D3DTSS_COLOROP).  	
        /// </summary>	
        /// <unmanaged>D3DTOP_BUMPENVMAPLUMINANCE</unmanaged>
        OperationBumpenvmapluminance = unchecked((int)23),			
        
        /// <summary>	
        ///   Modulate the components of each argument as signed components, add their products; then replicate the sum to all color channels, including alpha. This operation is supported for color and alpha operations.      In DirectX 6 and DirectX 7, multitexture operations the above inputs are all shifted down by half (y = x - 0.5) before use to simulate signed data, and the scalar result is automatically clamped to positive values and replicated to all three output channels. Also, note that as a color operation this does not updated the alpha it just updates the RGB components.   However, in DirectX 8.1 shaders you can specify that the output be routed to the .rgb or the .a components or both (the default). You can also specify a separate scalar operation on the alpha channel.   	
        /// </summary>	
        /// <unmanaged>D3DTOP_DOTPRODUCT3</unmanaged>
        OperationDotproduct3 = unchecked((int)24),			
        
        /// <summary>	
        ///  Performs a multiply-accumulate operation. It takes the last two arguments, multiplies them together, and adds them to the remaining input/source argument, and places that into the result.  SRGBA = Arg1 + Arg2 *  Arg3   	
        /// </summary>	
        /// <unmanaged>D3DTOP_MULTIPLYADD</unmanaged>
        OperationMultiplyadd = unchecked((int)25),			
        
        /// <summary>	
        ///  Linearly interpolates between the second and third source arguments by a proportion specified in the first source argument. SRGBA = (Arg1) *  Arg2 + (1- Arg1) *  Arg3. 	
        /// </summary>	
        /// <unmanaged>D3DTOP_LERP</unmanaged>
        OperationLerp = unchecked((int)26),			
    }
    
    /// <summary>	
    /// Defines texture filtering modes for a texture stage.	
    /// </summary>	
    /// <remarks>	
    ///  D3DTEXTUREFILTERTYPE is used by <see cref="SlimDX2.Direct3D9.Device.SetSamplerState"/> along with <see cref="SlimDX2.Direct3D9.Samplerstatetype"/> to define texture filtering modes for a texture stage.  To check if a format supports texture filter types other than D3DTEXF_POINT (which is always supported), call <see cref="SlimDX2.Direct3D9.Direct3D9.CheckDeviceFormat"/> with D3DUSAGE_QUERY_FILTER. Set a texture stage's magnification filter by calling <see cref="SlimDX2.Direct3D9.Device.SetSamplerState"/> with the D3DSAMP_MAGFILTER value as the second parameter and one member of this enumeration as the third parameter. Set a texture stage's minification filter by calling <see cref="SlimDX2.Direct3D9.Device.SetSamplerState"/> with the D3DSAMP_MINFILTER value as the second parameter and one member of this enumeration as the third parameter. Set the texture filter to use between-mipmap levels by calling <see cref="SlimDX2.Direct3D9.Device.SetSamplerState"/> with the D3DSAMP_MIPFILTER value as the second parameter and one member of this enumeration as the third parameter. Not all valid filtering modes for a device will apply to volume maps. In general, D3DTEXF_POINT and D3DTEXF_LINEAR magnification filters will be supported for volume maps. If D3DPTEXTURECAPS_MIPVOLUMEMAP is set, then the D3DTEXF_POINT mipmap filter and D3DTEXF_POINT and D3DTEXF_LINEAR minification filters will be supported for volume maps. The device may or may not support the D3DTEXF_LINEAR mipmap filter for volume maps. Devices that support anisotropic filtering for 2D maps do not necessarily support anisotropic filtering for volume maps. However, applications that enable anisotropic filtering will receive the best available filtering (probably linear) if anisotropic filtering is not supported. 	
    /// </remarks>	
    /// <unmanaged>D3DTEXTUREFILTERTYPE</unmanaged>
    public enum Texturefiltertype : int {	
        
        /// <summary>	
        ///  When used with <see cref="SlimDX2.Direct3D9.Samplerstatetype.Mipfilter"/>, disables mipmapping. 	
        /// </summary>	
        /// <unmanaged>D3DTEXF_NONE</unmanaged>
        FNone = unchecked((int)0),			
        
        /// <summary>	
        ///  When used with {{D3DSAMP_ MAGFILTER}} or <see cref="SlimDX2.Direct3D9.Samplerstatetype.Minfilter"/>,  specifies that point filtering is to be used as the texture magnification or minification filter respectively. When used  with D3DSAMP_MIPFILTER, enables mipmapping and specifies that the rasterizer chooses the color from the  texel of the nearest mip level. 	
        /// </summary>	
        /// <unmanaged>D3DTEXF_POINT</unmanaged>
        FPoint = unchecked((int)1),			
        
        /// <summary>	
        ///  When used with {{D3DSAMP_ MAGFILTER}} or <see cref="SlimDX2.Direct3D9.Samplerstatetype.Minfilter"/>,  specifies that linear filtering is to be used as the texture magnification or minification filter respectively. When used  with D3DSAMP_MIPFILTER, enables mipmapping and trilinear filtering; it specifies that the rasterizer  interpolates between the two nearest mip levels. 	
        /// </summary>	
        /// <unmanaged>D3DTEXF_LINEAR</unmanaged>
        FLinear = unchecked((int)2),			
        
        /// <summary>	
        ///  When used with {{D3DSAMP_ MAGFILTER}} or <see cref="SlimDX2.Direct3D9.Samplerstatetype.Minfilter"/>,  specifies that anisotropic texture filtering used as a texture magnification or minification filter respectively.  Compensates for distortion caused by the difference in angle between the texture polygon and the plane of the screen.  Use with D3DSAMP_MIPFILTER is undefined. 	
        /// </summary>	
        /// <unmanaged>D3DTEXF_ANISOTROPIC</unmanaged>
        FAnisotropic = unchecked((int)3),			
        
        /// <summary>	
        ///  A 4-sample tent filter used as a texture magnification or minification filter.  Use with <see cref="SlimDX2.Direct3D9.Samplerstatetype.Mipfilter"/> is undefined. 	
        /// </summary>	
        /// <unmanaged>D3DTEXF_PYRAMIDALQUAD</unmanaged>
        FPyramidalquad = unchecked((int)6),			
        
        /// <summary>	
        ///  A 4-sample Gaussian filter used as a texture magnification or minification filter.  Use with <see cref="SlimDX2.Direct3D9.Samplerstatetype.Mipfilter"/> is undefined. 	
        /// </summary>	
        /// <unmanaged>D3DTEXF_GAUSSIANQUAD</unmanaged>
        FGaussianquad = unchecked((int)7),			
        
        /// <summary>	
        ///  Convolution filter for monochrome textures.  See <see cref="SlimDX2.Direct3D9.Format.MtA1"/>.    Differences between Direct3D 9 and Direct3D 9Ex: This flag is available in Direct3D 9Ex only.      Use with <see cref="SlimDX2.Direct3D9.Samplerstatetype.Mipfilter"/> is undefined.  	
        /// </summary>	
        /// <unmanaged>D3DTEXF_CONVOLUTIONMONO</unmanaged>
        FConvolutionmono = unchecked((int)8),			
    }
    
    /// <summary>	
    /// Identifies the intended use of vertex data.	
    /// </summary>	
    /// <remarks>	
    ///  Vertex data is declared with an array of <see cref="SlimDX2.Direct3D9.Vertexelement9"/> structures. Each element in the array contains a usage type. For more information about vertex declarations, see {{Vertex Declaration (Direct3D 9)}}. 	
    /// </remarks>	
    /// <unmanaged>D3DDECLUSAGE</unmanaged>
    public enum Declusage : int {	
        
        /// <summary>	
        ///  Position data ranging from (-1,-1) to (1,1). Use D3DDECLUSAGE_POSITION with a usage index of 0 to specify untransformed position for fixed function vertex processing and the n-patch tessellator. Use D3DDECLUSAGE_POSITION with a usage index of 1 to specify untransformed position in the fixed function vertex shader for vertex tweening.  	
        /// </summary>	
        /// <unmanaged>D3DDECLUSAGE_POSITION</unmanaged>
        Position = unchecked((int)0),			
        
        /// <summary>	
        ///  Blending weight data. Use D3DDECLUSAGE_BLENDWEIGHT with a usage index of 0 to specify the blend weights used in indexed and nonindexed vertex blending. 	
        /// </summary>	
        /// <unmanaged>D3DDECLUSAGE_BLENDWEIGHT</unmanaged>
        Blendweight,
        
        /// <summary>	
        ///  Blending indices data. Use D3DDECLUSAGE_BLENDINDICES with a usage index of 0 to specify matrix indices for indexed paletted skinning. 	
        /// </summary>	
        /// <unmanaged>D3DDECLUSAGE_BLENDINDICES</unmanaged>
        Blendindices,
        
        /// <summary>	
        ///  Vertex normal data. Use D3DDECLUSAGE_NORMAL with a usage index of 0 to specify vertex normals for fixed function vertex processing and the n-patch tessellator. Use D3DDECLUSAGE_NORMAL with a usage index of 1 to specify vertex normals for fixed function vertex processing for vertex tweening. 	
        /// </summary>	
        /// <unmanaged>D3DDECLUSAGE_NORMAL</unmanaged>
        Normal,
        
        /// <summary>	
        ///  Point size data. Use D3DDECLUSAGE_PSIZE with a usage index of 0 to specify the point-size attribute used by the setup engine of the rasterizer to expand a point into a quad for the point-sprite functionality. 	
        /// </summary>	
        /// <unmanaged>D3DDECLUSAGE_PSIZE</unmanaged>
        Psize,
        
        /// <summary>	
        ///  Texture coordinate data. Use D3DDECLUSAGE_TEXCOORD, n to specify texture coordinates in fixed function vertex processing and in pixel shaders prior to ps_3_0. These can be used to pass user defined data.  	
        /// </summary>	
        /// <unmanaged>D3DDECLUSAGE_TEXCOORD</unmanaged>
        Texcoord,
        
        /// <summary>	
        ///  Vertex tangent data. 	
        /// </summary>	
        /// <unmanaged>D3DDECLUSAGE_TANGENT</unmanaged>
        Tangent,
        
        /// <summary>	
        ///  Vertex binormal data.  	
        /// </summary>	
        /// <unmanaged>D3DDECLUSAGE_BINORMAL</unmanaged>
        Binormal,
        
        /// <summary>	
        ///  Single positive floating point value. Use D3DDECLUSAGE_TESSFACTOR with a usage index of 0 to specify a tessellation factor used in the tessellation unit to control the rate of tessellation. For more information about the data type, see D3DDECLTYPE_FLOAT1. 	
        /// </summary>	
        /// <unmanaged>D3DDECLUSAGE_TESSFACTOR</unmanaged>
        Tessfactor,
        
        /// <summary>	
        ///  Vertex data contains transformed position data ranging from (0,0) to (viewport width, viewport height). Use D3DDECLUSAGE_POSITIONT with a usage index of 0 to specify transformed position. When a declaration containing this is set, the pipeline does not perform vertex processing. 	
        /// </summary>	
        /// <unmanaged>D3DDECLUSAGE_POSITIONT</unmanaged>
        Positiont,
        
        /// <summary>	
        ///  Vertex data contains diffuse or specular color. Use D3DDECLUSAGE_COLOR with a usage index of 0 to specify the diffuse color in the fixed function vertex shader and pixel shaders prior to ps_3_0. Use D3DDECLUSAGE_COLOR with a usage index of 1 to specify the specular color in the fixed function vertex shader and pixel shaders prior to ps_3_0. 	
        /// </summary>	
        /// <unmanaged>D3DDECLUSAGE_COLOR</unmanaged>
        Color,
        
        /// <summary>	
        ///  Vertex data contains fog data. Use D3DDECLUSAGE_FOG with a usage index of 0 to specify a fog blend value used after pixel shading finishes. This applies to pixel shaders prior to version ps_3_0.  	
        /// </summary>	
        /// <unmanaged>D3DDECLUSAGE_FOG</unmanaged>
        Fog,
        
        /// <summary>	
        ///  Vertex data contains depth data. 	
        /// </summary>	
        /// <unmanaged>D3DDECLUSAGE_DEPTH</unmanaged>
        Depth,
        
        /// <summary>	
        ///  Vertex data contains sampler data. Use D3DDECLUSAGE_SAMPLE with a usage index of 0 to specify the displacement value to look up. It can be used only with D3DDECLUSAGE_LOOKUPPRESAMPLED or D3DDECLUSAGE_LOOKUP.   	
        /// </summary>	
        /// <unmanaged>D3DDECLUSAGE_SAMPLE</unmanaged>
        Sample,
    }
    
    /// <summary>	
    /// Defines the vertex declaration method which is a predefined operation performed by the tessellator (or any procedural geometry routine on the vertex data during tessellation).	
    /// </summary>	
    /// <remarks>	
    ///  The tessellator looks at the method to determine what data to calculate from the vertex data during tessellation. Mesh data should use the default value. Patches can use any of the other implemented types.  Vertex data is declared with an array of <see cref="SlimDX2.Direct3D9.Vertexelement9"/> structures. Each element in the array contains a vertex declaration method. In addition to using D3DDECLMETHOD_DEFAULT, a normal mesh can use D3DDECLMETHOD_LOOKUP and D3DDECLMETHOD_LOOKUPPRESAMPLED methods when N-patches are enabled.  	
    /// </remarks>	
    /// <unmanaged>D3DDECLMETHOD</unmanaged>
    public enum Declmethod : int {	
        
        /// <summary>	
        ///  Default value. The tessellator copies the vertex data (spline data for patches) as is, with no additional calculations. When the tessellator is used, this element is interpolated. Otherwise vertex data is copied into the input register. The input and output type can be any value, but are always the same type. 	
        /// </summary>	
        /// <unmanaged>D3DDECLMETHOD_DEFAULT</unmanaged>
        Default = unchecked((int)0),			
        
        /// <summary>	
        ///  Computes the tangent at a point on the rectangle or triangle patch in the U direction. The input type can be one of the following:	
        ///   D3DDECLTYPE_D3DCOLOR D3DDECLTYPE_FLOAT3 D3DDECLTYPE_FLOAT4 D3DDECLTYPE_SHORT4 D3DDECLTYPE_UBYTE4   The output type is always D3DDECLTYPE_FLOAT3. 	
        /// </summary>	
        /// <unmanaged>D3DDECLMETHOD_PARTIALU</unmanaged>
        Partialu,
        
        /// <summary>	
        ///  Computes the tangent at a point on the rectangle or triangle patch in the V direction. The input type can be one of the following:	
        ///   D3DDECLTYPE_D3DCOLOR D3DDECLTYPE_FLOAT3 D3DDECLTYPE_FLOAT4 D3DDECLTYPE_SHORT4 D3DDECLTYPE_UBYTE4   The output type is always D3DDECLTYPE_FLOAT3.  	
        /// </summary>	
        /// <unmanaged>D3DDECLMETHOD_PARTIALV</unmanaged>
        Partialv,
        
        /// <summary>	
        ///  Computes the normal at a point on the rectangle or triangle patch by taking the cross product of two tangents. The input type can be one of the following:	
        ///   D3DDECLTYPE_D3DCOLOR D3DDECLTYPE_FLOAT3 D3DDECLTYPE_FLOAT4 D3DDECLTYPE_SHORT4 D3DDECLTYPE_UBYTE4   The output type is always D3DDECLTYPE_FLOAT3. 	
        /// </summary>	
        /// <unmanaged>D3DDECLMETHOD_CROSSUV</unmanaged>
        Crossuv,
        
        /// <summary>	
        ///  Copy out the U, V values at a point on the rectangle or triangle patch. This results in a 2D float. The input type must be set to D3DDECLTYPE_UNUSED. The output data type is always D3DDECLTYPE_FLOAT2. The input stream and offset are also unused (but must be set to 0). 	
        /// </summary>	
        /// <unmanaged>D3DDECLMETHOD_UV</unmanaged>
        Uv,
        
        /// <summary>	
        ///  Look up a displacement map. The input type can be one of the following:	
        ///   D3DDECLTYPE_FLOAT2 D3DDECLTYPE_FLOAT3 D3DDECLTYPE_FLOAT4   Only the .x and .y components are used for the texture map lookup. The output type is always D3DDECLTYPE_FLOAT1. The device must support displacement mapping. For more information about displacement mapping, see {{Displacement Mapping (Direct3D 9)}}. This constant is supported only by the programmable pipeline on N-patch data, if N-patches are enabled.  	
        /// </summary>	
        /// <unmanaged>D3DDECLMETHOD_LOOKUP</unmanaged>
        Lookup,
        
        /// <summary>	
        ///  Look up a presampled displacement map. The input type must be set to D3DDECLTYPE_UNUSED; the stream index and the stream offset must be set to 0. The output type for this operation is always D3DDECLTYPE_FLOAT1. The device must support displacement mapping. For more information about displacement mapping, see {{Displacement Mapping (Direct3D 9)}}. This constant is supported only by the programmable pipeline on N-patch data, if N-patches are enabled. This method can be used only with D3DDECLUSAGE_SAMPLE. 	
        /// </summary>	
        /// <unmanaged>D3DDECLMETHOD_LOOKUPPRESAMPLED</unmanaged>
        Lookuppresampled,
    }
    
    /// <summary>	
    /// Defines a vertex declaration data type.	
    /// </summary>	
    /// <remarks>	
    ///  Vertex data is declared with an array of <see cref="SlimDX2.Direct3D9.Vertexelement9"/> structures. Each element in the array contains a vertex declaration data type. Use the {{DirectX Caps Viewer Tool}} tool to see which types are supported on your device. 	
    /// </remarks>	
    /// <unmanaged>D3DDECLTYPE</unmanaged>
    public enum Decltype : int {	
        
        /// <summary>	
        ///  One-component float expanded to (float, 0, 0, 1). 	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_FLOAT1</unmanaged>
        Float1 = unchecked((int)0),			
        
        /// <summary>	
        ///  Two-component float expanded to (float, float, 0, 1). 	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_FLOAT2</unmanaged>
        Float2 = unchecked((int)1),			
        
        /// <summary>	
        ///  Three-component float expanded to (float, float, float, 1). 	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_FLOAT3</unmanaged>
        Float3 = unchecked((int)2),			
        
        /// <summary>	
        ///  Four-component float expanded to (float, float, float, float). 	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_FLOAT4</unmanaged>
        Float4 = unchecked((int)3),			
        
        /// <summary>	
        ///  Four-component, packed, unsigned bytes mapped to 0 to 1 range. Input is a <see cref="int"/> and is expanded to RGBA order. 	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_D3DCOLOR</unmanaged>
        D3DCOLOR = unchecked((int)4),			
        
        /// <summary>	
        ///  Four-component, unsigned byte. 	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_UBYTE4</unmanaged>
        Ubyte4 = unchecked((int)5),			
        
        /// <summary>	
        ///  Two-component, signed short expanded to (value, value, 0, 1). 	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_SHORT2</unmanaged>
        Short2 = unchecked((int)6),			
        
        /// <summary>	
        ///  Four-component, signed short expanded to (value, value, value, value). 	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_SHORT4</unmanaged>
        Short4 = unchecked((int)7),			
        
        /// <summary>	
        ///  Four-component byte with each byte normalized by dividing with 255.0f. 	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_UBYTE4N</unmanaged>
        Ubyte4n = unchecked((int)8),			
        
        /// <summary>	
        ///  Normalized, two-component, signed short, expanded to (first short/32767.0, second short/32767.0, 0, 1).  	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_SHORT2N</unmanaged>
        Short2n = unchecked((int)9),			
        
        /// <summary>	
        ///  Normalized, four-component, signed short, expanded to (first short/32767.0, second short/32767.0, third short/32767.0, fourth short/32767.0).  	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_SHORT4N</unmanaged>
        Short4n = unchecked((int)10),			
        
        /// <summary>	
        ///  Normalized, two-component, unsigned short, expanded to (first short/65535.0, short short/65535.0, 0, 1).  	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_USHORT2N</unmanaged>
        Ushort2n = unchecked((int)11),			
        
        /// <summary>	
        ///  Normalized, four-component, unsigned short, expanded to (first short/65535.0, second short/65535.0, third short/65535.0, fourth short/65535.0).  	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_USHORT4N</unmanaged>
        Ushort4n = unchecked((int)12),			
        
        /// <summary>	
        ///  Three-component, unsigned, 10 10 10 format expanded to (value, value, value, 1). 	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_UDEC3</unmanaged>
        Udec3 = unchecked((int)13),			
        
        /// <summary>	
        ///  Three-component, signed, 10 10 10 format normalized and expanded to (v[0]/511.0, v[1]/511.0, v[2]/511.0, 1).  	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_DEC3N</unmanaged>
        Dec3n = unchecked((int)14),			
        
        /// <summary>	
        ///  Two-component, 16-bit, floating point expanded to (value, value, 0, 1). 	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_FLOAT16_2</unmanaged>
        Float162 = unchecked((int)15),			
        
        /// <summary>	
        ///  Four-component, 16-bit, floating point expanded to (value, value, value, value).  	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_FLOAT16_4</unmanaged>
        Float164 = unchecked((int)16),			
        
        /// <summary>	
        ///  Type field in the declaration is unused. This is designed for use with D3DDECLMETHOD_UV  and D3DDECLMETHOD_LOOKUPPRESAMPLED. 	
        /// </summary>	
        /// <unmanaged>D3DDECLTYPE_UNUSED</unmanaged>
        Unused = unchecked((int)17),			
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DSHADER_INSTRUCTION_OPCODE_TYPE</unmanaged>
    public enum ShaderInstructionOpcodeType : int {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_NOP</unmanaged>
        IoNop = unchecked((int)0),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_MOV</unmanaged>
        IoMov,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_ADD</unmanaged>
        IoAdd,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_SUB</unmanaged>
        IoSub,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_MAD</unmanaged>
        IoMad,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_MUL</unmanaged>
        IoMul,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_RCP</unmanaged>
        IoRcp,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_RSQ</unmanaged>
        IoRsq,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_DP3</unmanaged>
        IoDp3,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_DP4</unmanaged>
        IoDp4,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_MIN</unmanaged>
        IoMinimum,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_MAX</unmanaged>
        IoMaximum,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_SLT</unmanaged>
        IoSlt,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_SGE</unmanaged>
        IoSge,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_EXP</unmanaged>
        IoExp,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_LOG</unmanaged>
        IoLog,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_LIT</unmanaged>
        IoLit,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_DST</unmanaged>
        IoDst,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_LRP</unmanaged>
        IoLrp,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_FRC</unmanaged>
        IoFrc,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_M4x4</unmanaged>
        IoM4x4,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_M4x3</unmanaged>
        IoM4x3,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_M3x4</unmanaged>
        IoM3x4,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_M3x3</unmanaged>
        IoM3x3,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_M3x2</unmanaged>
        IoM3x2,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_CALL</unmanaged>
        IoCall,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_CALLNZ</unmanaged>
        IoCallnz,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_LOOP</unmanaged>
        IoLoop,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_RET</unmanaged>
        IoRet,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_ENDLOOP</unmanaged>
        IoEndloop,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_LABEL</unmanaged>
        IoLabel,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_DCL</unmanaged>
        IoDcl,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_POW</unmanaged>
        IoPow,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_CRS</unmanaged>
        IoCrs,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_SGN</unmanaged>
        IoSgn,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_ABS</unmanaged>
        IoAbs,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_NRM</unmanaged>
        IoNrm,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_SINCOS</unmanaged>
        IoSincos,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_REP</unmanaged>
        IoRep,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_ENDREP</unmanaged>
        IoEndrep,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_IF</unmanaged>
        IoIf,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_IFC</unmanaged>
        IoIfc,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_ELSE</unmanaged>
        IoElse,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_ENDIF</unmanaged>
        IoEndif,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_BREAK</unmanaged>
        IoBreak,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_BREAKC</unmanaged>
        IoBreakc,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_MOVA</unmanaged>
        IoMova,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_DEFB</unmanaged>
        IoDefb,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_DEFI</unmanaged>
        IoDefi,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXCOORD</unmanaged>
        IoTexcoord = unchecked((int)64),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXKILL</unmanaged>
        IoTexkill,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEX</unmanaged>
        IoTex,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXBEM</unmanaged>
        IoTexbem,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXBEML</unmanaged>
        IoTexbeml,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXREG2AR</unmanaged>
        IoTexreg2ar,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXREG2GB</unmanaged>
        IoTexreg2gb,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXM3x2PAD</unmanaged>
        IoTEXM3x2PAD,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXM3x2TEX</unmanaged>
        IoTEXM3x2TEX,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXM3x3PAD</unmanaged>
        IoTEXM3x3PAD,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXM3x3TEX</unmanaged>
        IoTEXM3x3TEX,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_RESERVED0</unmanaged>
        IoReserved0,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXM3x3SPEC</unmanaged>
        IoTEXM3x3SPEC,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXM3x3VSPEC</unmanaged>
        IoTEXM3x3VSPEC,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_EXPP</unmanaged>
        IoExpp,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_LOGP</unmanaged>
        IoLogp,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_CND</unmanaged>
        IoCnd,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_DEF</unmanaged>
        IoDef,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXREG2RGB</unmanaged>
        IoTexreg2rgb,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXDP3TEX</unmanaged>
        IoTexdp3tex,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXM3x2DEPTH</unmanaged>
        IoTEXM3x2DEPTH,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXDP3</unmanaged>
        IoTexdp3,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXM3x3</unmanaged>
        IoTEXM3x3,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXDEPTH</unmanaged>
        IoTexdepth,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_CMP</unmanaged>
        IoCmp,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_BEM</unmanaged>
        IoBem,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_DP2ADD</unmanaged>
        IoDp2add,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_DSX</unmanaged>
        IoDsx,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_DSY</unmanaged>
        IoDsy,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXLDD</unmanaged>
        IoTexldd,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_SETP</unmanaged>
        IoSetp,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_TEXLDL</unmanaged>
        IoTexldl,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_BREAKP</unmanaged>
        IoBreakp,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_PHASE</unmanaged>
        IoPhase = unchecked((int)65533),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_COMMENT</unmanaged>
        IoComment = unchecked((int)65534),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSIO_END</unmanaged>
        IoEnd = unchecked((int)65535),			
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DSHADER_COMPARISON</unmanaged>
    public enum ShaderComparison : int {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPC_RESERVED0</unmanaged>
        PcReserved0 = unchecked((int)0),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPC_GT</unmanaged>
        PcGt = unchecked((int)1),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPC_EQ</unmanaged>
        PcEq = unchecked((int)2),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPC_GE</unmanaged>
        PcGe = unchecked((int)3),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPC_LT</unmanaged>
        PcLt = unchecked((int)4),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPC_NE</unmanaged>
        PcNe = unchecked((int)5),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPC_LE</unmanaged>
        PcLe = unchecked((int)6),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPC_RESERVED1</unmanaged>
        PcReserved1 = unchecked((int)7),			
    }
    
    /// <summary>	
    /// Defines the sampler texture types for vertex shaders.	
    /// </summary>	
    /// <unmanaged>D3DSAMPLER_TEXTURE_TYPE</unmanaged>
    public enum SamplerTextureType : int {	
        
        /// <summary>	
        ///  Uninitialized value. The value of this element is D3DSP_TEXTURETYPE_SHIFT. 	
        /// </summary>	
        /// <unmanaged>D3DSTT_UNKNOWN</unmanaged>
        TtUnknown = unchecked((int)0),			
        
        /// <summary>	
        ///  Declaring a 2D texture. The value of this element is D3DSP_TEXTURETYPE_SHIFT * 4. 	
        /// </summary>	
        /// <unmanaged>D3DSTT_2D</unmanaged>
        Tt2d = unchecked((int)268435456),			
        
        /// <summary>	
        ///  Declaring a cube texture. The value of this element is D3DSP_TEXTURETYPE_SHIFT * 8. 	
        /// </summary>	
        /// <unmanaged>D3DSTT_CUBE</unmanaged>
        TtCube = unchecked((int)402653184),			
        
        /// <summary>	
        ///  Declaring a volume texture. The value of this element is D3DSP_TEXTURETYPE_SHIFT * 16. 	
        /// </summary>	
        /// <unmanaged>D3DSTT_VOLUME</unmanaged>
        TtVolume = unchecked((int)536870912),			
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DSHADER_PARAM_REGISTER_TYPE</unmanaged>
    public enum ShaderParamRegisterType : int {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_TEMP</unmanaged>
        PrTemp = unchecked((int)0),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_INPUT</unmanaged>
        PrInput = unchecked((int)1),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_CONST</unmanaged>
        PrConst = unchecked((int)2),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_ADDR</unmanaged>
        PrAddr = unchecked((int)3),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_TEXTURE</unmanaged>
        PrTexture = unchecked((int)3),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_RASTOUT</unmanaged>
        PrRastout = unchecked((int)4),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_ATTROUT</unmanaged>
        PrAttrout = unchecked((int)5),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_TEXCRDOUT</unmanaged>
        PrTexcrdout = unchecked((int)6),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_OUTPUT</unmanaged>
        PrOutput = unchecked((int)6),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_CONSTINT</unmanaged>
        PrConstint = unchecked((int)7),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_COLOROUT</unmanaged>
        PrColorout = unchecked((int)8),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_DEPTHOUT</unmanaged>
        PrDepthout = unchecked((int)9),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_SAMPLER</unmanaged>
        PrSampler = unchecked((int)10),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_CONST2</unmanaged>
        PrConst2 = unchecked((int)11),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_CONST3</unmanaged>
        PrConst3 = unchecked((int)12),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_CONST4</unmanaged>
        PrConst4 = unchecked((int)13),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_CONSTBOOL</unmanaged>
        PrConstbool = unchecked((int)14),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_LOOP</unmanaged>
        PrLoop = unchecked((int)15),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_TEMPFLOAT16</unmanaged>
        PrTempfloat16 = unchecked((int)16),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_MISCTYPE</unmanaged>
        PrMisctype = unchecked((int)17),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_LABEL</unmanaged>
        PrLabel = unchecked((int)18),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPR_PREDICATE</unmanaged>
        PrPredicate = unchecked((int)19),			
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DSHADER_MISCTYPE_OFFSETS</unmanaged>
    public enum ShaderMisctypeOffsets : int {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSMO_POSITION</unmanaged>
        MoPosition = unchecked((int)0),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSMO_FACE</unmanaged>
        MoFace = unchecked((int)1),			
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DVS_RASTOUT_OFFSETS</unmanaged>
    public enum VsRastoutOffsets : int {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSRO_POSITION</unmanaged>
        SroPosition = unchecked((int)0),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSRO_FOG</unmanaged>
        SroFog,
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSRO_POINT_SIZE</unmanaged>
        SroPointSize,
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DVS_ADDRESSMODE_TYPE</unmanaged>
    public enum VsAddressmodeType : int {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DVS_ADDRMODE_ABSOLUTE</unmanaged>
        ModeAbsolute = unchecked((int)0),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DVS_ADDRMODE_RELATIVE</unmanaged>
        ModeRelative = unchecked((int)8192),			
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DSHADER_ADDRESSMODE_TYPE</unmanaged>
    public enum ShaderAddressmodeType : int {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSHADER_ADDRMODE_ABSOLUTE</unmanaged>
        ModeAbsolute = unchecked((int)0),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSHADER_ADDRMODE_RELATIVE</unmanaged>
        ModeRelative = unchecked((int)8192),			
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DSHADER_PARAM_SRCMOD_TYPE</unmanaged>
    public enum ShaderParamSrcmodType : int {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPSM_NONE</unmanaged>
        PsmNone = unchecked((int)0),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPSM_NEG</unmanaged>
        PsmNeg = unchecked((int)16777216),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPSM_BIAS</unmanaged>
        PsmBias = unchecked((int)33554432),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPSM_BIASNEG</unmanaged>
        PsmBiasneg = unchecked((int)50331648),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPSM_SIGN</unmanaged>
        PsmSign = unchecked((int)67108864),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPSM_SIGNNEG</unmanaged>
        PsmSignneg = unchecked((int)83886080),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPSM_COMP</unmanaged>
        PsmComp = unchecked((int)100663296),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPSM_X2</unmanaged>
        PsmX2 = unchecked((int)117440512),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPSM_X2NEG</unmanaged>
        PsmX2NEG = unchecked((int)134217728),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPSM_DZ</unmanaged>
        PsmDz = unchecked((int)150994944),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPSM_DW</unmanaged>
        PsmDw = unchecked((int)167772160),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPSM_ABS</unmanaged>
        PsmAbs = unchecked((int)184549376),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPSM_ABSNEG</unmanaged>
        PsmAbsneg = unchecked((int)201326592),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSPSM_NOT</unmanaged>
        PsmNot = unchecked((int)218103808),			
    }
    
    /// <summary>	
    /// Defines the basis type of a high-order patch surface.	
    /// </summary>	
    /// <remarks>	
    ///  The members of D3DBASISTYPE specify the formulation to be used in evaluating the high-order patch surface primitive during tessellation. 	
    /// </remarks>	
    /// <unmanaged>D3DBASISTYPE</unmanaged>
    public enum Basistype : int {	
        
        /// <summary>	
        ///  Input vertices are treated as a series of B?zier patches. The number of vertices specified must be divisible by 4. Portions of the mesh beyond this criterion will not be rendered. Full continuity is assumed between sub-patches in the interior of the surface rendered by each call. Only the vertices at the corners of each sub-patch are guaranteed to lie on the resulting surface.  	
        /// </summary>	
        /// <unmanaged>D3DBASIS_BEZIER</unmanaged>
        Bezier = unchecked((int)0),			
        
        /// <summary>	
        ///  Input vertices are treated as control points of a B-spline surface. The number of apertures rendered is two fewer than the number of apertures in that direction. In general, the generated surface does not contain the control vertices specified.  	
        /// </summary>	
        /// <unmanaged>D3DBASIS_BSPLINE</unmanaged>
        Bspline = unchecked((int)1),			
        
        /// <summary>	
        ///  An interpolating basis defines the surface so that the surface goes through all the input vertices specified. In DirectX 8, this was D3DBASIS_INTERPOLATE. 	
        /// </summary>	
        /// <unmanaged>D3DBASIS_CATMULL_ROM</unmanaged>
        CatmullRom = unchecked((int)2),			
    }
    
    /// <summary>	
    /// Defines the degree of the variables in the equation that describes a curve.	
    /// </summary>	
    /// <remarks>	
    ///  The values in this enumeration are used to describe the curves used by rectangle and triangle patches. For more information, see D3DRS_CULLMODE. 	
    /// </remarks>	
    /// <unmanaged>D3DDEGREETYPE</unmanaged>
    public enum Degreetype : int {	
        
        /// <summary>	
        ///  Curve is described by variables of first order. 	
        /// </summary>	
        /// <unmanaged>D3DDEGREE_LINEAR</unmanaged>
        Linear = unchecked((int)1),			
        
        /// <summary>	
        ///  Curve is described by variables of second order. 	
        /// </summary>	
        /// <unmanaged>D3DDEGREE_QUADRATIC</unmanaged>
        Quadratic = unchecked((int)2),			
        
        /// <summary>	
        ///  Curve is described by variables of third order. 	
        /// </summary>	
        /// <unmanaged>D3DDEGREE_CUBIC</unmanaged>
        Cubic = unchecked((int)3),			
        
        /// <summary>	
        ///  Curve is described by variables of fourth order. 	
        /// </summary>	
        /// <unmanaged>D3DDEGREE_QUINTIC</unmanaged>
        Quintic = unchecked((int)5),			
    }
    
    /// <summary>	
    /// Defines whether the current tessellation mode is discrete or continuous.	
    /// </summary>	
    /// <remarks>	
    ///  Note that continuous tessellation produces a completely different tessellation pattern from the discrete one for the same tessellation values (this is more apparent in wireframe mode). Thus, 4.0 continuous is not the same as 4 discrete. 	
    /// </remarks>	
    /// <unmanaged>D3DPATCHEDGESTYLE</unmanaged>
    public enum Patchedgestyle : int {	
        
        /// <summary>	
        ///  Discrete edge style. In discrete mode, you can specify float tessellation but it will be truncated to integers.  	
        /// </summary>	
        /// <unmanaged>D3DPATCHEDGE_DISCRETE</unmanaged>
        Discrete = unchecked((int)0),			
        
        /// <summary>	
        ///  Continuous edge style. In continuous mode, tessellation is specified as float values that can be smoothly varied to reduce "popping" artifacts.  	
        /// </summary>	
        /// <unmanaged>D3DPATCHEDGE_CONTINUOUS</unmanaged>
        Continuous = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Predefined sets of pipeline state used by state blocks (see {{State Blocks Save and Restore State (Direct3D 9)}}).	
    /// </summary>	
    /// <remarks>	
    ///  As the following diagram shows, vertex and pixel state are both subsets of device state.     Diagram of device state, with vertex state and pixel state as subsets   There are only a few states that are considered both vertex and pixel state. These states are:  Render state: D3DRS_FOGDENSITY Render state: D3DRS_FOGSTART Render state: D3DRS_FOGEND Texture state: D3DTSS_TEXCOORDINDEX Texture state: D3DTSS_TEXTURETRANSFORMFLAGS  	
    /// </remarks>	
    /// <unmanaged>D3DSTATEBLOCKTYPE</unmanaged>
    public enum Stateblocktype : int {	
        
        /// <summary>	
        ///  Capture the current {{device state}}. 	
        /// </summary>	
        /// <unmanaged>D3DSBT_ALL</unmanaged>
        BtAll = unchecked((int)1),			
        
        /// <summary>	
        ///  Capture the current {{pixel state}}. 	
        /// </summary>	
        /// <unmanaged>D3DSBT_PIXELSTATE</unmanaged>
        BtPixelstate = unchecked((int)2),			
        
        /// <summary>	
        ///  Capture the current {{vertex state}}. 	
        /// </summary>	
        /// <unmanaged>D3DSBT_VERTEXSTATE</unmanaged>
        BtVertexstate = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Defines flags used to control the number or matrices that the system applies when performing multimatrix vertex blending.	
    /// </summary>	
    /// <remarks>	
    ///  Members of this type are used with the D3DRS_VERTEXBLEND render state. Geometry blending (multimatrix vertex blending) requires that your application use a vertex format that has blending (beta) weights for each vertex. 	
    /// </remarks>	
    /// <unmanaged>D3DVERTEXBLENDFLAGS</unmanaged>
    [Flags]
    public enum Vertexblendflags : int {	
        
        /// <summary>	
        ///  Disable vertex blending; apply only the world matrix set by the {{D3DTS_WORLDMATRIX}} macro, where the index value for the transformation state is 0.  	
        /// </summary>	
        /// <unmanaged>D3DVBF_DISABLE</unmanaged>
        BfDisable = unchecked((int)0),			
        
        /// <summary>	
        ///  Enable vertex blending between the two matrices set by the {{D3DTS_WORLDMATRIX}} macro, where the index value for the transformation states are 0 and 1.  	
        /// </summary>	
        /// <unmanaged>D3DVBF_1WEIGHTS</unmanaged>
        Bf1weights = unchecked((int)1),			
        
        /// <summary>	
        ///  Enable vertex blending between the three matrices set by the {{D3DTS_WORLDMATRIX}} macro, where the index value for the transformation states are 0, 1, and 2.  	
        /// </summary>	
        /// <unmanaged>D3DVBF_2WEIGHTS</unmanaged>
        Bf2weights = unchecked((int)2),			
        
        /// <summary>	
        ///  Enable vertex blending between the four matrices set by the {{D3DTS_WORLDMATRIX}} macro, where the index value for the transformation states are 0, 1, 2, and 3.  	
        /// </summary>	
        /// <unmanaged>D3DVBF_3WEIGHTS</unmanaged>
        Bf3weights = unchecked((int)3),			
        
        /// <summary>	
        ///  Vertex blending is done by using the value assigned to D3DRS_TWEENFACTOR.  	
        /// </summary>	
        /// <unmanaged>D3DVBF_TWEENING</unmanaged>
        BfTweening = unchecked((int)255),			
        
        /// <summary>	
        ///  Use a single matrix with a weight of 1.0.  	
        /// </summary>	
        /// <unmanaged>D3DVBF_0WEIGHTS</unmanaged>
        Bf0weights = unchecked((int)256),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Defines texture coordinate transformation values.	
    /// </summary>	
    /// <remarks>	
    ///  Texture coordinates can be transformed using a 4 x 4 matrix before the results are passed to the rasterizer. The texture coordinate transforms are set by calling <see cref="SlimDX2.Direct3D9.Device.SetTextureStageState"/>, and by passing in the D3DTSS_TEXTURETRANSFORMFLAGS texture stage state and one of the values from D3DTEXTURETRANSFORMFLAGS. For more information about texture transforms, see {{Texture Coordinate Transformations (Direct3D 9)}}. 	
    /// </remarks>	
    /// <unmanaged>D3DTEXTURETRANSFORMFLAGS</unmanaged>
    [Flags]
    public enum Texturetransformflags : int {	
        
        /// <summary>	
        ///  Texture coordinates are passed directly to the rasterizer.  	
        /// </summary>	
        /// <unmanaged>D3DTTFF_DISABLE</unmanaged>
        TffDisable = unchecked((int)0),			
        
        /// <summary>	
        ///  The rasterizer should expect 1D texture coordinates. This value is used by fixed function vertex processing; it should be set to 0 when using a programmable vertex shader. 	
        /// </summary>	
        /// <unmanaged>D3DTTFF_COUNT1</unmanaged>
        TffCount1 = unchecked((int)1),			
        
        /// <summary>	
        ///  The rasterizer should expect 2D texture coordinates. This value is used by fixed function vertex processing; it should be set to 0 when using a programmable vertex shader. 	
        /// </summary>	
        /// <unmanaged>D3DTTFF_COUNT2</unmanaged>
        TffCount2 = unchecked((int)2),			
        
        /// <summary>	
        ///  The rasterizer should expect 3D texture coordinates. This value is used by fixed function vertex processing; it should be set to 0 when using a programmable vertex shader. 	
        /// </summary>	
        /// <unmanaged>D3DTTFF_COUNT3</unmanaged>
        TffCount3 = unchecked((int)3),			
        
        /// <summary>	
        ///  The rasterizer should expect 4D texture coordinates. This value is used by fixed function vertex processing; it should be set to 0 when using a programmable vertex shader. 	
        /// </summary>	
        /// <unmanaged>D3DTTFF_COUNT4</unmanaged>
        TffCount4 = unchecked((int)4),			
        
        /// <summary>	
        ///  This flag is honored by the fixed function pixel pipeline, as well as the programmable pixel pipeline in versions ps_1_1 to ps_1_3. When texture projection is enabled for a texture stage, all four floating point values must be written to the corresponding texture register. Each texture coordinate is divided by the last element before being passed to the rasterizer. For example, if this flag is specified with the D3DTTFF_COUNT3 flag, the first and second texture coordinates are divided by the third coordinate before being passed to the rasterizer.  	
        /// </summary>	
        /// <unmanaged>D3DTTFF_PROJECTED</unmanaged>
        TffProjected = unchecked((int)256),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Defines device types.	
    /// </summary>	
    /// <remarks>	
    ///  All methods of the <see cref="SlimDX2.Direct3D9.Direct3D9"/> interface that take a D3DDEVTYPE device type will fail if D3DDEVTYPE_NULLREF is specified. To use these methods, substitute D3DDEVTYPE_REF in the method call. A D3DDEVTYPE_REF device should be created in D3DPOOL_SCRATCH memory, unless vertex and index buffers are required. To support vertex and index buffers, create the device in D3DPOOL_SYSTEMMEM memory. If D3dref9.dll is installed, Direct3D will use the reference rasterizer to create a D3DDEVTYPE_REF device type, even if D3DDEVTYPE_NULLREF is specified. If D3dref9.dll is not available and D3DDEVTYPE_NULLREF is specified, Direct3D will neither render nor present the scene. 	
    /// </remarks>	
    /// <unmanaged>D3DDEVTYPE</unmanaged>
    public enum Devtype : int {	
        
        /// <summary>	
        ///  Hardware rasterization. Shading is done with software, hardware, or mixed transform and lighting. 	
        /// </summary>	
        /// <unmanaged>D3DDEVTYPE_HAL</unmanaged>
        Hal = unchecked((int)1),			
        
        /// <summary>	
        ///  Initialize Direct3D on a computer that has neither hardware nor reference rasterization available, and enable resources for 3D content creation. See Remarks. 	
        /// </summary>	
        /// <unmanaged>D3DDEVTYPE_REF</unmanaged>
        Ref = unchecked((int)2),			
        
        /// <summary>	
        ///  Direct3D features are implemented in software; however, the reference rasterizer does make use of special CPU instructions whenever it can. 	
        /// </summary>	
        /// <unmanaged>D3DDEVTYPE_SW</unmanaged>
        Sw = unchecked((int)3),			
        
        /// <summary>	
        ///  A pluggable software device that has been registered with <see cref="SlimDX2.Direct3D9.Direct3D9.RegisterSoftwareDevice"/>. 	
        /// </summary>	
        /// <unmanaged>D3DDEVTYPE_NULLREF</unmanaged>
        Nullref = unchecked((int)4),			
    }
    
    /// <summary>	
    /// Defines the levels of full-scene multisampling that the device can apply.	
    /// </summary>	
    /// <remarks>	
    ///  In addition to enabling full-scene multisampling at <see cref="SlimDX2.Direct3D9.Device.Reset"/> time, there will be render states that turn various aspects on and off at fine-grained levels. Multisampling is valid only on a swap chain that is being created or reset with the D3DSWAPEFFECT_DISCARD swap effect. The multisample antialiasing value can be set with the parameters (or sub-parameters) in the following methods.  MethodParametersSub-parameters  <see cref="SlimDX2.Direct3D9.Direct3D9.CheckDeviceMultiSampleType"/> MultiSampleType and pQualityLevels  <see cref="SlimDX2.Direct3D9.Direct3D9.CreateDevice"/> pPresentationParametersMultiSampleType and pQualityLevels  <see cref="SlimDX2.Direct3D9.Device.CreateAdditionalSwapChain"/> pPresentationParametersMultiSampleType and pQualityLevels  <see cref="SlimDX2.Direct3D9.Device.CreateDepthStencilSurface"/> MultiSampleType and pQualityLevels  <see cref="SlimDX2.Direct3D9.Device.CreateRenderTarget"/> MultiSampleType and pQualityLevels  <see cref="SlimDX2.Direct3D9.Device.Reset"/> pPresentationParametersMultiSampleType and pQualityLevels    It is not good practice to switch from one multisample type to another to raise the quality of the antialiasing. D3DMULTISAMPLE_NONE enables swap effects other than discarding, locking, and so on. Whether the display device supports maskable multisampling (more than one sample for a multiple-sample render-target format plus antialias support) or just non-maskable multisampling (only antialias support), the driver for the device provides the number of quality levels for the D3DMULTISAMPLE_NONMASKABLE multiple-sample type. Applications that just use multisampling for antialiasing purposes only need to query for the number of non-maskable multiple-sample quality levels that the driver supports. The quality levels supported by the device can be obtained with the pQualityLevels parameter of <see cref="SlimDX2.Direct3D9.Direct3D9.CheckDeviceMultiSampleType"/>. Quality levels used by the application are set with the MultiSampleQuality parameter of <see cref="SlimDX2.Direct3D9.Device.CreateDepthStencilSurface"/> and <see cref="SlimDX2.Direct3D9.Device.CreateRenderTarget"/>. See D3DRS_MULTISAMPLEMASK for discussion of maskable multisampling. 	
    /// </remarks>	
    /// <unmanaged>D3DMULTISAMPLE_TYPE</unmanaged>
    public enum MultisampleType : int {	
        
        /// <summary>	
        ///  No level of full-scene multisampling is available.  	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_NONE</unmanaged>
        None = unchecked((int)0),			
        
        /// <summary>	
        ///  Enables the multisample quality value. See Remarks.  	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_NONMASKABLE</unmanaged>
        NonMaskable = unchecked((int)1),			
        
        /// <summary>	
        ///  Level of full-scene multisampling available.  	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_2_SAMPLES</unmanaged>
        TwoSamples = unchecked((int)2),			
        
        /// <summary>	
        ///  Level of full-scene multisampling available.  	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_3_SAMPLES</unmanaged>
        ThreeSamples = unchecked((int)3),			
        
        /// <summary>	
        ///  Level of full-scene multisampling available.  	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_4_SAMPLES</unmanaged>
        FourSamples = unchecked((int)4),			
        
        /// <summary>	
        ///  Level of full-scene multisampling available.  	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_5_SAMPLES</unmanaged>
        FiveSamples = unchecked((int)5),			
        
        /// <summary>	
        ///  Level of full-scene multisampling available.  	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_6_SAMPLES</unmanaged>
        SixSamples = unchecked((int)6),			
        
        /// <summary>	
        ///  Level of full-scene multisampling available.  	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_7_SAMPLES</unmanaged>
        SevenSamples = unchecked((int)7),			
        
        /// <summary>	
        ///  Level of full-scene multisampling available.  	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_8_SAMPLES</unmanaged>
        EightSamples = unchecked((int)8),			
        
        /// <summary>	
        ///  Level of full-scene multisampling available.  	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_9_SAMPLES</unmanaged>
        NineSamples = unchecked((int)9),			
        
        /// <summary>	
        ///  Level of full-scene multisampling available.  	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_10_SAMPLES</unmanaged>
        TenSamples = unchecked((int)10),			
        
        /// <summary>	
        ///  Level of full-scene multisampling available.  	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_11_SAMPLES</unmanaged>
        ElevenSamples = unchecked((int)11),			
        
        /// <summary>	
        ///  Level of full-scene multisampling available.  	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_12_SAMPLES</unmanaged>
        TwelveSamples = unchecked((int)12),			
        
        /// <summary>	
        ///  Level of full-scene multisampling available.  	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_13_SAMPLES</unmanaged>
        ThirteenSamples = unchecked((int)13),			
        
        /// <summary>	
        ///  Level of full-scene multisampling available.  	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_14_SAMPLES</unmanaged>
        FourteenSamples = unchecked((int)14),			
        
        /// <summary>	
        ///  Level of full-scene multisampling available.  	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_15_SAMPLES</unmanaged>
        FifteenSamples = unchecked((int)15),			
        
        /// <summary>	
        ///  Level of full-scene multisampling available.  	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_16_SAMPLES</unmanaged>
        SixteenSamples = unchecked((int)16),			
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DFORMAT</unmanaged>
    public enum Format : int {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_UNKNOWN</unmanaged>
        MtUnknown = unchecked((int)0),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_R8G8B8</unmanaged>
        MtR8G8B8 = unchecked((int)20),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_A8R8G8B8</unmanaged>
        MtA8R8G8B8 = unchecked((int)21),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_X8R8G8B8</unmanaged>
        MtX8R8G8B8 = unchecked((int)22),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_R5G6B5</unmanaged>
        MtR5G6B5 = unchecked((int)23),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_X1R5G5B5</unmanaged>
        MtX1R5G5B5 = unchecked((int)24),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_A1R5G5B5</unmanaged>
        MtA1R5G5B5 = unchecked((int)25),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_A4R4G4B4</unmanaged>
        MtA4R4G4B4 = unchecked((int)26),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_R3G3B2</unmanaged>
        MtR3G3B2 = unchecked((int)27),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_A8</unmanaged>
        MtA8 = unchecked((int)28),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_A8R3G3B2</unmanaged>
        MtA8R3G3B2 = unchecked((int)29),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_X4R4G4B4</unmanaged>
        MtX4R4G4B4 = unchecked((int)30),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_A2B10G10R10</unmanaged>
        MtA2B10G10R10 = unchecked((int)31),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_A8B8G8R8</unmanaged>
        MtA8B8G8R8 = unchecked((int)32),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_X8B8G8R8</unmanaged>
        MtX8B8G8R8 = unchecked((int)33),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_G16R16</unmanaged>
        MtG16R16 = unchecked((int)34),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_A2R10G10B10</unmanaged>
        MtA2R10G10B10 = unchecked((int)35),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_A16B16G16R16</unmanaged>
        MtA16B16G16R16 = unchecked((int)36),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_A8P8</unmanaged>
        MtA8P8 = unchecked((int)40),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_P8</unmanaged>
        MtP8 = unchecked((int)41),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_L8</unmanaged>
        MtL8 = unchecked((int)50),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_A8L8</unmanaged>
        MtA8L8 = unchecked((int)51),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_A4L4</unmanaged>
        MtA4L4 = unchecked((int)52),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_V8U8</unmanaged>
        MtV8U8 = unchecked((int)60),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_L6V5U5</unmanaged>
        MtL6V5U5 = unchecked((int)61),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_X8L8V8U8</unmanaged>
        MtX8L8V8U8 = unchecked((int)62),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_Q8W8V8U8</unmanaged>
        MtQ8W8V8U8 = unchecked((int)63),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_V16U16</unmanaged>
        MtV16U16 = unchecked((int)64),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_A2W10V10U10</unmanaged>
        MtA2W10V10U10 = unchecked((int)67),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_UYVY</unmanaged>
        MtUyvy = unchecked((int)((int)(byte)('U')|((int)(byte)('Y')<<8)|((int)(byte)('V')<<16)|((int)(byte)('Y')<<24))),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_R8G8_B8G8</unmanaged>
        MtR8G8B8G8 = unchecked((int)((int)(byte)('R')|((int)(byte)('G')<<8)|((int)(byte)('B')<<16)|((int)(byte)('G')<<24))),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_YUY2</unmanaged>
        MtYuy2 = unchecked((int)((int)(byte)('Y')|((int)(byte)('U')<<8)|((int)(byte)('Y')<<16)|((int)(byte)('2')<<24))),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_G8R8_G8B8</unmanaged>
        MtG8R8G8B8 = unchecked((int)((int)(byte)('G')|((int)(byte)('R')<<8)|((int)(byte)('G')<<16)|((int)(byte)('B')<<24))),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_DXT1</unmanaged>
        MtDxt1 = unchecked((int)((int)(byte)('D')|((int)(byte)('X')<<8)|((int)(byte)('T')<<16)|((int)(byte)('1')<<24))),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_DXT2</unmanaged>
        MtDxt2 = unchecked((int)((int)(byte)('D')|((int)(byte)('X')<<8)|((int)(byte)('T')<<16)|((int)(byte)('2')<<24))),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_DXT3</unmanaged>
        MtDxt3 = unchecked((int)((int)(byte)('D')|((int)(byte)('X')<<8)|((int)(byte)('T')<<16)|((int)(byte)('3')<<24))),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_DXT4</unmanaged>
        MtDxt4 = unchecked((int)((int)(byte)('D')|((int)(byte)('X')<<8)|((int)(byte)('T')<<16)|((int)(byte)('4')<<24))),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_DXT5</unmanaged>
        MtDxt5 = unchecked((int)((int)(byte)('D')|((int)(byte)('X')<<8)|((int)(byte)('T')<<16)|((int)(byte)('5')<<24))),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_D16_LOCKABLE</unmanaged>
        MtD16Lockable = unchecked((int)70),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_D32</unmanaged>
        MtD32 = unchecked((int)71),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_D15S1</unmanaged>
        MtD15S1 = unchecked((int)73),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_D24S8</unmanaged>
        MtD24S8 = unchecked((int)75),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_D24X8</unmanaged>
        MtD24X8 = unchecked((int)77),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_D24X4S4</unmanaged>
        MtD24X4S4 = unchecked((int)79),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_D16</unmanaged>
        MtD16 = unchecked((int)80),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_D32F_LOCKABLE</unmanaged>
        MtD32FLockable = unchecked((int)82),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_D24FS8</unmanaged>
        MtD24FS8 = unchecked((int)83),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_D32_LOCKABLE</unmanaged>
        MtD32Lockable = unchecked((int)84),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_S8_LOCKABLE</unmanaged>
        MtS8Lockable = unchecked((int)85),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_L16</unmanaged>
        MtL16 = unchecked((int)81),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_VERTEXDATA</unmanaged>
        MtVertexdata = unchecked((int)100),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_INDEX16</unmanaged>
        MtIndex16 = unchecked((int)101),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_INDEX32</unmanaged>
        MtIndex32 = unchecked((int)102),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_Q16W16V16U16</unmanaged>
        MtQ16W16V16U16 = unchecked((int)110),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_MULTI2_ARGB8</unmanaged>
        MtMulti2Argb8 = unchecked((int)((int)(byte)('M')|((int)(byte)('E')<<8)|((int)(byte)('T')<<16)|((int)(byte)('1')<<24))),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_R16F</unmanaged>
        MtR16F = unchecked((int)111),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_G16R16F</unmanaged>
        MtG16R16F = unchecked((int)112),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_A16B16G16R16F</unmanaged>
        MtA16B16G16R16F = unchecked((int)113),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_R32F</unmanaged>
        MtR32F = unchecked((int)114),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_G32R32F</unmanaged>
        MtG32R32F = unchecked((int)115),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_A32B32G32R32F</unmanaged>
        MtA32B32G32R32F = unchecked((int)116),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_CxV8U8</unmanaged>
        MtCxV8U8 = unchecked((int)117),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_A1</unmanaged>
        MtA1 = unchecked((int)118),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_A2B10G10R10_XR_BIAS</unmanaged>
        MtA2B10G10R10XrBias = unchecked((int)119),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFMT_BINARYBUFFER</unmanaged>
        MtBinarybuffer = unchecked((int)199),			
    }
    
    /// <summary>	
    /// Defines swap effects.	
    /// </summary>	
    /// <remarks>	
    ///  The state of the back buffer after a call to Present is well-defined by each of these swap effects, and whether the Direct3D device was created with a full-screen swap chain or a windowed swap chain has no effect on this state. In particular, the D3DSWAPEFFECT_FLIP swap effect operates the same whether windowed or full-screen, and the Direct3D runtime guarantees this by creating extra buffers. As a result, it is recommended that applications use D3DSWAPEFFECT_DISCARD whenever possible to avoid any such penalties. This is because this swap effect will always be the most efficient in terms of memory consumption and performance. Applications that use D3DSWAPEFFECT_FLIP or D3DSWAPEFFECT_DISCARD should not expect full-screen destination alpha to work. This means that the D3DRS_DESTBLEND render state will not work as expected because full-screen swap chains with these swap effects do not have an explicit pixel format from the driver's point of view. The driver infers that they should take on the display format, which does not have an alpha channel. To work around this, take the following steps:   Use D3DSWAPEFFECT_COPY. Check the D3DCAPS3_ALPHA_FULLSCREEN_FLIP_OR_DISCARD flag in the Caps3 member of the <see cref="SlimDX2.Direct3D9.Caps9"/> structure. This flag indicates whether the driver can do alpha blending when D3DSWAPEFFECT_FLIP or D3DSWAPEFFECT_DISCARD is used. Applications using flip mode swap effect (D3DSWAPEFFECT_FLIPEX) should call {{PresentEx}} after a window resize or region change to ensure that the display content is updated.  An invisible window cannot receive user-mode events; furthermore, an invisible-fullscreen window will interfere with the presentation of another applications' windowed-mode window. Therefore, each application needs to ensure that a device window is visible when a swapchain is presented in fullscreen mode. 	
    /// </remarks>	
    /// <unmanaged>D3DSWAPEFFECT</unmanaged>
    public enum Swapeffect : int {	
        
        /// <summary>	
        ///  When a swap chain is created with a swap effect of D3DSWAPEFFECT_FLIP or  D3DSWAPEFFECT_COPY, the runtime will guarantee that an <see cref="SlimDX2.Direct3D9.Device.Present"/> operation will not affect the content of any of the back buffers. Unfortunately, meeting this guarantee can involve substantial video memory or processing overheads, especially when implementing flip semantics for a windowed swap chain or copy semantics for a full-screen swap chain. An application may use the D3DSWAPEFFECT_DISCARD swap effect to avoid these overheads and to enable the display driver to select the most efficient presentation technique for the swap chain. This is also the only swap effect that may be used when specifying a value other than D3DMULTISAMPLE_NONE for the MultiSampleType member of <see cref="SlimDX2.Direct3D9.PresentParameters"/>. Like a swap chain that uses D3DSWAPEFFECT_FLIP, a swap chain that uses D3DSWAPEFFECT_DISCARD might include more than one back buffer, any of which may be accessed using <see cref="SlimDX2.Direct3D9.Device.GetBackBuffer"/> or <see cref="SlimDX2.Direct3D9.SwapChain.GetBackBuffer"/>. The swap chain is best envisaged as a queue in which 0 always indexes the back buffer that will be displayed by the next Present operation and from which buffers are discarded when they have been displayed. An application that uses this swap effect cannot make any assumptions about the contents of a discarded back buffer and should therefore update an entire back buffer before invoking a Present operation that would display it. Although this is not enforced, the debug version of the runtime will overwrite the contents of discarded back buffers with random data to enable developers to verify that their applications are updating the entire back buffer surfaces correctly. 	
        /// </summary>	
        /// <unmanaged>D3DSWAPEFFECT_DISCARD</unmanaged>
        Discard = unchecked((int)1),			
        
        /// <summary>	
        ///  The swap chain might include multiple back buffers and is best envisaged as a circular queue that includes the front buffer. Within this queue, the back buffers are always numbered sequentially from 0 to (n - 1), where n is the number of back buffers, so that 0 denotes the least recently presented buffer. When Present is invoked, the queue is "rotated" so that the front buffer becomes back buffer (n - 1), while the back buffer 0 becomes the new front buffer. 	
        /// </summary>	
        /// <unmanaged>D3DSWAPEFFECT_FLIP</unmanaged>
        Flip = unchecked((int)2),			
        
        /// <summary>	
        ///  This swap effect may be specified only for a swap chain comprising a single back buffer. Whether the swap chain is windowed or full-screen, the runtime will guarantee the semantics implied by a copy-based Present operation, namely that the operation leaves the content of the back buffer unchanged, instead of replacing it with the content of the front buffer as a flip-based Present operation would.  For a full-screen swap chain, the runtime uses a combination of flip operations and copy operations, supported if necessary by hidden back buffers, to accomplish the Present operation. Accordingly, the presentation is synchronized with the display adapter's vertical retrace and its rate is constrained by the chosen presentation interval. A swap chain specified with the D3DPRESENT_INTERVAL_IMMEDIATE flag is the only exception. (Refer to the description of the PresentationIntervals member of the <see cref="SlimDX2.Direct3D9.PresentParameters"/> structure.) In this case, a Present operation copies the back buffer content directly to the front buffer without waiting for the vertical retrace. 	
        /// </summary>	
        /// <unmanaged>D3DSWAPEFFECT_COPY</unmanaged>
        Copy = unchecked((int)3),			
        
        /// <summary>	
        ///  Use a dedicated area of video memory that can be overlayed on the primary surface. No copy is performed when the overlay is displayed.  The overlay operation is performed in hardware, without modifying the data in the primary surface.   Differences between Direct3D 9 and Direct3D 9Ex: D3DSWAPEFFECT_OVERLAY is only available in Direct3D9Ex running on Windows 7 (or more current operating system).     	
        /// </summary>	
        /// <unmanaged>D3DSWAPEFFECT_OVERLAY</unmanaged>
        Overlay = unchecked((int)4),			
        
        /// <summary>	
        ///  Designates when an application is adopting flip mode, during which time an application's frame is passed instead of copied to the Desktop Window Manager(DWM) for composition when the application is presenting in windowed mode. Flip mode allows an application to more efficiently use memory bandwidth as well as enabling an application to take advantage of full-screen-present statistics. Flip mode does not affect full-screen behavior. A sample application that uses {{D3DPRESENT_FORCEIMMEDIATE}} and D3DSWAPEFFECT_FLIPEX is the {{D3D9ExFlipEx sample on the MSDN Code Gallery}}.   Differences between Direct3D 9 and Direct3D 9Ex: D3DSWAPEFFECT_FLIPEX is only available in Direct3D9Ex running on Windows 7 (or more current operating system).     	
        /// </summary>	
        /// <unmanaged>D3DSWAPEFFECT_FLIPEX</unmanaged>
        Flipex = unchecked((int)5),			
    }
    
    /// <summary>	
    /// Defines the memory class that holds the buffers for a resource.	
    /// </summary>	
    /// <remarks>	
    ///  All pool types are valid with all resources including: vertex buffers, index buffers, textures, and surfaces. The following tables indicate restrictions on pool types for render targets, depth stencils, and dynamic and mipmap usages. An x indicates a compatible combination; lack of an x indicates incompatibility.  PoolD3DUSAGE_RENDERTARGETD3DUSAGE_DEPTHSTENCIL D3DPOOL_DEFAULTxx D3DPOOL_MANAGED D3DPOOL_SCRATCH D3DPOOL_SYSTEMMEM     PoolD3DUSAGE_DYNAMICD3DUSAGE_AUTOGENMIPMAP D3DPOOL_DEFAULTxx D3DPOOL_MANAGEDx D3DPOOL_SCRATCH D3DPOOL_SYSTEMMEMx    For more information about usage types, see {{D3DUSAGE}}. Pools cannot be mixed for different objects contained within one resource (mip levels in a mipmap) and, when a pool is chosen, it cannot be changed. Applications should use D3DPOOL_MANAGED for most static resources because this saves the application from having to deal with lost devices. (Managed resources are restored by the runtime.) This is especially beneficial for unified memory architecture (UMA) systems. Other dynamic resources are not a good match for D3DPOOL_MANAGED. In fact, index buffers and vertex buffers cannot be created using D3DPOOL_MANAGED together with D3DUSAGE_DYNAMIC. For dynamic textures, it is sometimes desirable to use a pair of video memory and system memory textures, allocating the video memory using D3DPOOL_DEFAULT and the system memory using D3DPOOL_SYSTEMMEM. You can lock and modify the bits of the system memory texture using a locking method. Then you can update the video memory texture using <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/>. 	
    /// </remarks>	
    /// <unmanaged>D3DPOOL</unmanaged>
    public enum Pool : int {	
        
        /// <summary>	
        ///  Resources are placed in the memory pool most appropriate for the set of usages requested for the given resource. This is usually video memory, including both local video memory and AGP memory. The D3DPOOL_DEFAULT pool is separate from D3DPOOL_MANAGED and D3DPOOL_SYSTEMMEM, and it specifies that the resource is placed in the preferred memory for device access. Note that D3DPOOL_DEFAULT never indicates that either D3DPOOL_MANAGED or D3DPOOL_SYSTEMMEM should be chosen as the memory pool type for this resource. Textures placed in the D3DPOOL_DEFAULT pool cannot be locked unless they are dynamic textures or they are private, FOURCC, driver formats. To access unlockable textures, you must use functions such as <see cref="SlimDX2.Direct3D9.Device.UpdateSurface"/>, <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/>, <see cref="SlimDX2.Direct3D9.Device.GetFrontBufferData"/>, and <see cref="SlimDX2.Direct3D9.Device.GetRenderTargetData"/>. D3DPOOL_MANAGED is probably a better choice than D3DPOOL_DEFAULT for most applications. Note that some textures created in driver-proprietary pixel formats, unknown to the Direct3D runtime, can be locked. Also note that - unlike textures - swap chain back buffers, render targets, vertex buffers, and index buffers can be locked. When a device is lost, resources created using D3DPOOL_DEFAULT must be released before calling <see cref="SlimDX2.Direct3D9.Device.Reset"/>. For more information, see {{Lost Devices (Direct3D 9)}}.  When creating resources with D3DPOOL_DEFAULT, if video card memory is already committed, managed resources will be evicted to free enough memory to satisfy the request. 	
        /// </summary>	
        /// <unmanaged>D3DPOOL_DEFAULT</unmanaged>
        Default = unchecked((int)0),			
        
        /// <summary>	
        ///  Resources are copied automatically to device-accessible memory as needed. Managed resources are backed by system memory and do not need to be recreated when a device is lost. See {{Managing Resources (Direct3D 9)}} for more information. Managed resources can be locked. Only the system-memory copy is directly modified. Direct3D copies your changes to driver-accessible memory as needed.    Differences between Direct3D 9 and Direct3D 9Ex: D3DPOOL_MANAGED is valid with <see cref="SlimDX2.Direct3D9.Device"/>; however, it is not valid with <see cref="SlimDX2.Direct3D9.Device9Ex"/>.     	
        /// </summary>	
        /// <unmanaged>D3DPOOL_MANAGED</unmanaged>
        Managed = unchecked((int)1),			
        
        /// <summary>	
        ///  Resources are placed in memory that is not typically accessible by the Direct3D device. This memory allocation consumes system RAM but does not reduce pageable RAM. These resources do not need to be recreated when a device is lost. Resources in this pool can be locked and can be used as the source for a <see cref="SlimDX2.Direct3D9.Device.UpdateSurface"/> or <see cref="SlimDX2.Direct3D9.Device.UpdateTexture"/> operation to a memory resource created with D3DPOOL_DEFAULT.  	
        /// </summary>	
        /// <unmanaged>D3DPOOL_SYSTEMMEM</unmanaged>
        Systemmem = unchecked((int)2),			
        
        /// <summary>	
        ///  Resources are placed in system RAM and do not need to be recreated when a device is lost.  These resources are not bound by device size or format restrictions.  Because of this, these resources cannot be accessed by the Direct3D device nor set as textures or render targets. However, these resources can always be created, locked, and copied. 	
        /// </summary>	
        /// <unmanaged>D3DPOOL_SCRATCH</unmanaged>
        Scratch = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Defines constants that describe the type of back buffer.	
    /// </summary>	
    /// <remarks>	
    ///  Direct3D 9 does not support stereo view, so Direct3D does not use the D3DBACKBUFFER_TYPE_LEFT and D3DBACKBUFFER_TYPE_RIGHT values of this enumerated type. 	
    /// </remarks>	
    /// <unmanaged>D3DBACKBUFFER_TYPE</unmanaged>
    public enum BackbufferType : int {	
        
        /// <summary>	
        ///  Specifies a nonstereo swap chain.  	
        /// </summary>	
        /// <unmanaged>D3DBACKBUFFER_TYPE_MONO</unmanaged>
        Mono = unchecked((int)0),			
        
        /// <summary>	
        ///  Specifies the left side of a stereo pair in a swap chain.  	
        /// </summary>	
        /// <unmanaged>D3DBACKBUFFER_TYPE_LEFT</unmanaged>
        Left = unchecked((int)1),			
        
        /// <summary>	
        ///  Specifies the right side of a stereo pair in a swap chain.  	
        /// </summary>	
        /// <unmanaged>D3DBACKBUFFER_TYPE_RIGHT</unmanaged>
        Right = unchecked((int)2),			
    }
    
    /// <summary>	
    /// </summary>	
    /// <unmanaged>D3DRESOURCETYPE</unmanaged>
    public enum Resourcetype : int {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DRTYPE_SURFACE</unmanaged>
        TypeSurface = unchecked((int)1),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DRTYPE_VOLUME</unmanaged>
        TypeVolume = unchecked((int)2),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DRTYPE_TEXTURE</unmanaged>
        TypeTexture = unchecked((int)3),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DRTYPE_VOLUMETEXTURE</unmanaged>
        TypeVolumetexture = unchecked((int)4),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DRTYPE_CUBETEXTURE</unmanaged>
        TypeCubetexture = unchecked((int)5),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DRTYPE_VERTEXBUFFER</unmanaged>
        TypeVertexbuffer = unchecked((int)6),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DRTYPE_INDEXBUFFER</unmanaged>
        TypeIndexbuffer = unchecked((int)7),			
    }
    
    /// <summary>	
    /// Defines the faces of a cubemap.	
    /// </summary>	
    /// <unmanaged>D3DCUBEMAP_FACES</unmanaged>
    public enum CubemapFaces : int {	
        
        /// <summary>	
        ///  Positive x-face of the cubemap.  	
        /// </summary>	
        /// <unmanaged>D3DCUBEMAP_FACE_POSITIVE_X</unmanaged>
        PositiveX = unchecked((int)0),			
        
        /// <summary>	
        ///  Negative x-face of the cubemap.  	
        /// </summary>	
        /// <unmanaged>D3DCUBEMAP_FACE_NEGATIVE_X</unmanaged>
        NegativeX = unchecked((int)1),			
        
        /// <summary>	
        ///  Positive y-face of the cubemap.  	
        /// </summary>	
        /// <unmanaged>D3DCUBEMAP_FACE_POSITIVE_Y</unmanaged>
        PositiveY = unchecked((int)2),			
        
        /// <summary>	
        ///  Negative y-face of the cubemap.  	
        /// </summary>	
        /// <unmanaged>D3DCUBEMAP_FACE_NEGATIVE_Y</unmanaged>
        NegativeY = unchecked((int)3),			
        
        /// <summary>	
        ///  Positive z-face of the cubemap.  	
        /// </summary>	
        /// <unmanaged>D3DCUBEMAP_FACE_POSITIVE_Z</unmanaged>
        PositiveZ = unchecked((int)4),			
        
        /// <summary>	
        ///  Negative z-face of the cubemap.  	
        /// </summary>	
        /// <unmanaged>D3DCUBEMAP_FACE_NEGATIVE_Z</unmanaged>
        NegativeZ = unchecked((int)5),			
    }
    
    /// <summary>	
    /// Defines the debug monitor tokens.	
    /// </summary>	
    /// <remarks>	
    ///  The values in this enumerated type are used by the D3DRS_DEBUGMONITORTOKEN render state and are only relevant for debug builds. 	
    /// </remarks>	
    /// <unmanaged>D3DDEBUGMONITORTOKENS</unmanaged>
    public enum Debugmonitortokens : int {	
        
        /// <summary>	
        ///  Enable the debug monitor.  	
        /// </summary>	
        /// <unmanaged>D3DDMT_ENABLE</unmanaged>
        MtEnable = unchecked((int)0),			
        
        /// <summary>	
        ///  Disable the debug monitor.  	
        /// </summary>	
        /// <unmanaged>D3DDMT_DISABLE</unmanaged>
        MtDisable = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Identifies the query type. For information about queries, see {{Queries (Direct3D 9)}} 	
    /// </summary>	
    /// <unmanaged>D3DQUERYTYPE</unmanaged>
    public enum Querytype : int {	
        
        /// <summary>	
        ///  Query for driver hints about data layout for vertex caching. 	
        /// </summary>	
        /// <unmanaged>D3DQUERYTYPE_VCACHE</unmanaged>
        Vcache = unchecked((int)4),			
        
        /// <summary>	
        ///  Query the resource manager. For this query, the device behavior flags must include {{D3DCREATE_DISABLE_DRIVER_MANAGEMENT}}. 	
        /// </summary>	
        /// <unmanaged>D3DQUERYTYPE_RESOURCEMANAGER</unmanaged>
        Resourcemanager = unchecked((int)5),			
        
        /// <summary>	
        ///  Query vertex statistics. 	
        /// </summary>	
        /// <unmanaged>D3DQUERYTYPE_VERTEXSTATS</unmanaged>
        Vertexstats = unchecked((int)6),			
        
        /// <summary>	
        ///  Query for any and all asynchronous events that have been issued from API calls.  	
        /// </summary>	
        /// <unmanaged>D3DQUERYTYPE_EVENT</unmanaged>
        Event = unchecked((int)8),			
        
        /// <summary>	
        ///  An occlusion query returns the number of pixels that pass z-testing. These pixels are for primitives drawn between the issue of {{D3DISSUE_BEGIN}} and {{D3DISSUE_END}}. This enables an application to check the occlusion result against 0. Zero is fully occluded, which means the pixels are not visible from the current camera position. 	
        /// </summary>	
        /// <unmanaged>D3DQUERYTYPE_OCCLUSION</unmanaged>
        Occlusion = unchecked((int)9),			
        
        /// <summary>	
        ///  Returns a 64-bit timestamp. 	
        /// </summary>	
        /// <unmanaged>D3DQUERYTYPE_TIMESTAMP</unmanaged>
        Timestamp = unchecked((int)10),			
        
        /// <summary>	
        ///  Use this query to notify an application if the counter frequency has changed from the D3DQUERYTYPE_TIMESTAMP. 	
        /// </summary>	
        /// <unmanaged>D3DQUERYTYPE_TIMESTAMPDISJOINT</unmanaged>
        Timestampdisjoint = unchecked((int)11),			
        
        /// <summary>	
        ///  This query result is TRUE if the values from D3DQUERYTYPE_TIMESTAMP queries cannot be guaranteed to be continuous throughout the duration of the D3DQUERYTYPE_TIMESTAMPDISJOINT query. Otherwise, the query result is FALSE. 	
        /// </summary>	
        /// <unmanaged>D3DQUERYTYPE_TIMESTAMPFREQ</unmanaged>
        Timestampfreq = unchecked((int)12),			
        
        /// <summary>	
        ///  Percent of time processing pipeline data. 	
        /// </summary>	
        /// <unmanaged>D3DQUERYTYPE_PIPELINETIMINGS</unmanaged>
        Pipelinetimings = unchecked((int)13),			
        
        /// <summary>	
        ///  Percent of time processing data in the driver. 	
        /// </summary>	
        /// <unmanaged>D3DQUERYTYPE_INTERFACETIMINGS</unmanaged>
        Interfacetimings = unchecked((int)14),			
        
        /// <summary>	
        ///  Percent of time processing vertex shader data. 	
        /// </summary>	
        /// <unmanaged>D3DQUERYTYPE_VERTEXTIMINGS</unmanaged>
        Vertextimings = unchecked((int)15),			
        
        /// <summary>	
        ///  Percent of time processing pixel shader data. 	
        /// </summary>	
        /// <unmanaged>D3DQUERYTYPE_PIXELTIMINGS</unmanaged>
        Pixeltimings = unchecked((int)16),			
        
        /// <summary>	
        ///  Throughput measurement comparisons for help in understanding the performance of an application. 	
        /// </summary>	
        /// <unmanaged>D3DQUERYTYPE_BANDWIDTHTIMINGS</unmanaged>
        Bandwidthtimings = unchecked((int)17),			
        
        /// <summary>	
        ///  Measure the cache hit-rate performance for textures and indexed vertices. 	
        /// </summary>	
        /// <unmanaged>D3DQUERYTYPE_CACHEUTILIZATION</unmanaged>
        Cacheutilization = unchecked((int)18),			
        
        /// <summary>	
        ///  Efficiency of memory allocation contained in a  <see cref="SlimDX2.Direct3D9.Memorypressure"/> structure.   Differences between Direct3D 9 and Direct3D 9Ex: D3DQUERYTYPE_MEMORYPRESSURE is only available in Direct3D9Ex running on Windows 7 (or more current operating system).     	
        /// </summary>	
        /// <unmanaged>D3DQUERYTYPE_MEMORYPRESSURE</unmanaged>
        Memorypressure = unchecked((int)19),			
    }
    
    /// <summary>	
    /// Specifies how to combine the glyph data from the source and destination surfaces in a call to {{ComposeRects}}.	
    /// </summary>	
    /// <unmanaged>D3DCOMPOSERECTSOP</unmanaged>
    public enum Composerectsop : int {	
        
        /// <summary>	
        ///  Copy the source to the destination. 	
        /// </summary>	
        /// <unmanaged>D3DCOMPOSERECTS_COPY</unmanaged>
        Copy = unchecked((int)1),			
        
        /// <summary>	
        ///  Bitwise OR the source and the destination. 	
        /// </summary>	
        /// <unmanaged>D3DCOMPOSERECTS_OR</unmanaged>
        Or = unchecked((int)2),			
        
        /// <summary>	
        ///  Bitwise AND the source and the destination. 	
        /// </summary>	
        /// <unmanaged>D3DCOMPOSERECTS_AND</unmanaged>
        And = unchecked((int)3),			
        
        /// <summary>	
        ///  Copy the negated source to the destination (Dst &amp; ~Src). 	
        /// </summary>	
        /// <unmanaged>D3DCOMPOSERECTS_NEG</unmanaged>
        Neg = unchecked((int)4),			
    }
    
    /// <summary>	
    /// Flags indicating the method the rasterizer uses to create an image on a surface.	
    /// </summary>	
    /// <remarks>	
    ///  This enumeration is used as a member in <see cref="SlimDX2.Direct3D9.Displaymodefilter"/> and <see cref="SlimDX2.Direct3D9.Displaymodeex"/>. 	
    /// </remarks>	
    /// <unmanaged>D3DSCANLINEORDERING</unmanaged>
    public enum Scanlineordering : int {	
        
        /// <summary>	
        ///  The image is created from the first scanline to the last without skipping any. 	
        /// </summary>	
        /// <unmanaged>D3DSCANLINEORDERING_UNKNOWN</unmanaged>
        Unknown = unchecked((int)0),			
        
        /// <summary>	
        ///  The image is created using the interlaced method in which odd-numbered lines are drawn on odd-numbered passes and even lines are drawn on even-numbered passes. 	
        /// </summary>	
        /// <unmanaged>D3DSCANLINEORDERING_PROGRESSIVE</unmanaged>
        Progressive = unchecked((int)1),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSCANLINEORDERING_INTERLACED</unmanaged>
        Interlaced = unchecked((int)2),			
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DDISPLAYROTATION</unmanaged>
    public enum Displayrotation : int {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DDISPLAYROTATION_IDENTITY</unmanaged>
        RotationIDENTITY = unchecked((int)1),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DDISPLAYROTATION_90</unmanaged>
        Rotation90 = unchecked((int)2),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DDISPLAYROTATION_180</unmanaged>
        Rotation180 = unchecked((int)3),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DDISPLAYROTATION_270</unmanaged>
        Rotation270 = unchecked((int)4),			
    }
    
    /// <summary>	
    /// Specifies the type of I/O bus used by the graphics adapter.	
    /// </summary>	
    /// <remarks>	
    ///  As many as three flags can be set. Flags in the range 0x00 through 0x04 (D3DBUSTYPE_Xxx) provide the basic bus type. Flags in the range 0x10000 through 0x50000 (D3DBUSIMPL_MODIFIER_Xxx) modify the basic description. The driver sets one bus-type flag, and can set zero or one modifier flag. If the driver sets a modifier flag, it also sets the D3DBUSIMPL_MODIFIER_NON_STANDARD flag. Flags are combined with a bitwise OR.  	
    /// </remarks>	
    /// <unmanaged>D3DBUSTYPE</unmanaged>
    public enum Bustype : int {	
        
        /// <summary>	
        ///  Indicates a type of bus other than the types listed here.	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DBUSTYPE_OTHER</unmanaged>
        TypeOther = unchecked((int)0),			
        
        /// <summary>	
        ///  PCI bus.	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DBUSTYPE_PCI</unmanaged>
        TypePci = unchecked((int)1),			
        
        /// <summary>	
        ///  PCI-X bus.	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DBUSTYPE_PCIX</unmanaged>
        TypePcix = unchecked((int)2),			
        
        /// <summary>	
        ///  PCI Express bus.	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DBUSTYPE_PCIEXPRESS</unmanaged>
        TypePciexpress = unchecked((int)3),			
        
        /// <summary>	
        ///  Accelerated Graphics Port (AGP) bus.	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DBUSTYPE_AGP</unmanaged>
        TypeAgp = unchecked((int)4),			
        
        /// <summary>	
        ///  The implementation for the graphics adapter is in a motherboard chip set's north bridge. This flag implies that data never goes over an expansion bus (such as PCI or AGP) when it is transferred from main memory to the graphics adapter. 	
        /// </summary>	
        /// <unmanaged>D3DBUSIMPL_MODIFIER_INSIDE_OF_CHIPSET</unmanaged>
        ImplModifierInsideOfChipset = unchecked((int)65536),			
        
        /// <summary>	
        ///  Indicates that the graphics adapter is connected to a motherboard chip set's north bridge by tracks on the motherboard and all of the graphics adapter's chips are soldered to the motherboard. This flag implies that data never goes over an expansion bus (such as PCI or AGP) when it is transferred from main memory to the graphics adapter. 	
        /// </summary>	
        /// <unmanaged>D3DBUSIMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP</unmanaged>
        ImplModifierTracksOnMotherBoardToChip = unchecked((int)131072),			
        
        /// <summary>	
        ///  The graphics adapter is connected to a motherboard chip set's north bridge by tracks on the motherboard, and all of the graphics adapter's chips are connected through sockets to the motherboard.	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DBUSIMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET</unmanaged>
        ImplModifierTracksOnMotherBoardToSocket = unchecked((int)196608),			
        
        /// <summary>	
        ///  The graphics adapter is connected to the motherboard through a daughterboard connector.	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DBUSIMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR</unmanaged>
        ImplModifierDaughterBoardConnector = unchecked((int)262144),			
        
        /// <summary>	
        ///  The graphics adapter is connected to the motherboard through a daughterboard connector, and the graphics adapter is inside an enclosure that is not user accessible.	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DBUSIMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE</unmanaged>
        ImplModifierDaughterBoardConnectorInsideOfNuae = unchecked((int)327680),			
        
        /// <summary>	
        ///  One of the D3DBUSIMPL_MODIFIER_MODIFIER_Xxx flags is set.	
        ///  	
        /// </summary>	
        /// <unmanaged>D3DBUSIMPL_MODIFIER_NON_STANDARD</unmanaged>
        ImplModifierNonStandard = unchecked((int)2147483648),			
    }
    
    /// <summary>	
    /// Errors are represented by negative values and cannot be combined. The following is a list of values that can be returned by methods included with the D3DX utility library. See the individual method descriptions for lists of the values that each can return. These lists are not necessarily comprehensive.	
    /// </summary>	
    /// <remarks>	
    ///  The facility code _FACDD is used to generate error codes, as in the following macros.  	
    /// <code> #define _FACDD                  0x876	
    /// #define MAKE_DDHRESULT( code )  MAKE_HRESULT( 1, _FACDD, code )	
    /// enum _D3DXERR { D3DXERR_CANNOTMODIFYINDEXBUFFER = MAKE_DDHRESULT(2900), D3DXERR_INVALIDMESH             = MAKE_DDHRESULT(2901), ... }; </code>	
    /// 	
    ///  	
    /// </remarks>	
    /// <unmanaged>_D3DXERR</unmanaged>
    public enum D3DXERR : int {	
        
        /// <summary>	
        ///  The index buffer cannot be modified. 	
        /// </summary>	
        /// <unmanaged>D3DXERR_CANNOTMODIFYINDEXBUFFER</unmanaged>
        D3DXERRCannotmodifyindexbuffer = unchecked((int)-2005529772),			
        
        /// <summary>	
        ///  The mesh is invalid. 	
        /// </summary>	
        /// <unmanaged>D3DXERR_INVALIDMESH</unmanaged>
        D3DXERRInvalidmesh = unchecked((int)-2005529771),			
        
        /// <summary>	
        ///  Attribute sort (D3DXMESHOPT_ATTRSORT) is not supported as an optimization technique. 	
        /// </summary>	
        /// <unmanaged>D3DXERR_CANNOTATTRSORT</unmanaged>
        D3DXERRCannotattrsort = unchecked((int)-2005529770),			
        
        /// <summary>	
        ///  Skinning is not supported. 	
        /// </summary>	
        /// <unmanaged>D3DXERR_SKINNINGNOTSUPPORTED</unmanaged>
        D3DXERRSkinningnotsupported = unchecked((int)-2005529769),			
        
        /// <summary>	
        ///  Too many influences specified. 	
        /// </summary>	
        /// <unmanaged>D3DXERR_TOOMANYINFLUENCES</unmanaged>
        D3DXERRToomanyinfluences = unchecked((int)-2005529768),			
        
        /// <summary>	
        ///  The data is invalid. 	
        /// </summary>	
        /// <unmanaged>D3DXERR_INVALIDDATA</unmanaged>
        D3DXERRInvaliddata = unchecked((int)-2005529767),			
        
        /// <summary>	
        ///  The mesh has no data.  	
        /// </summary>	
        /// <unmanaged>D3DXERR_LOADEDMESHASNODATA</unmanaged>
        D3DXERRLoadedmeshasnodata = unchecked((int)-2005529766),			
        
        /// <summary>	
        ///  A fragment with that name already exists. 	
        /// </summary>	
        /// <unmanaged>D3DXERR_DUPLICATENAMEDFRAGMENT</unmanaged>
        D3DXERRDuplicatenamedfragment = unchecked((int)-2005529765),			
        
        /// <summary>	
        ///  The last item cannot be deleted. 	
        /// </summary>	
        /// <unmanaged>D3DXERR_CANNOTREMOVELASTITEM</unmanaged>
        D3DXERRCannotremovelastitem = unchecked((int)-2005529764),			
    }
    
    /// <summary>	
    /// Mesh patch types.	
    /// </summary>	
    /// <remarks>	
    ///  Triangle patches have three sides and are described in <see cref="SlimDX2.Direct3D9.TripatchInformation"/>. Rectangle patches are four-sided and are described in <see cref="SlimDX2.Direct3D9.RectpatchInformation"/>.  	
    /// </remarks>	
    /// <unmanaged>D3DXPATCHMESHTYPE</unmanaged>
    public enum Patchmeshtype : int {	
        
        /// <summary>	
        ///  Rectangle patch mesh type. 	
        /// </summary>	
        /// <unmanaged>D3DXPATCHMESH_RECT</unmanaged>
        Rect = unchecked((int)1),			
        
        /// <summary>	
        ///  Triangle patch mesh type. 	
        /// </summary>	
        /// <unmanaged>D3DXPATCHMESH_TRI</unmanaged>
        Tri = unchecked((int)2),			
        
        /// <summary>	
        ///  N-patch mesh type. 	
        /// </summary>	
        /// <unmanaged>D3DXPATCHMESH_NPATCH</unmanaged>
        Npatch = unchecked((int)3),			
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>_D3DXMESH</unmanaged>
    public enum D3DXMESH : int {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_32BIT</unmanaged>
        D3DXMESH32bit = unchecked((int)1),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_DONOTCLIP</unmanaged>
        D3DXMESHDonotclip = unchecked((int)2),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_POINTS</unmanaged>
        D3DXMESHPoints = unchecked((int)4),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_RTPATCHES</unmanaged>
        D3DXMESHRtpatches = unchecked((int)8),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_NPATCHES</unmanaged>
        D3DXMESHNpatches = unchecked((int)16384),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_VB_SYSTEMMEM</unmanaged>
        D3DXMESHVbSystemmem = unchecked((int)16),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_VB_MANAGED</unmanaged>
        D3DXMESHVbManaged = unchecked((int)32),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_VB_WRITEONLY</unmanaged>
        D3DXMESHVbWriteonly = unchecked((int)64),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_VB_DYNAMIC</unmanaged>
        D3DXMESHVbDynamic = unchecked((int)128),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_VB_SOFTWAREPROCESSING</unmanaged>
        D3DXMESHVbSoftwareprocessing = unchecked((int)32768),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_IB_SYSTEMMEM</unmanaged>
        D3DXMESHIbSystemmem = unchecked((int)256),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_IB_MANAGED</unmanaged>
        D3DXMESHIbManaged = unchecked((int)512),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_IB_WRITEONLY</unmanaged>
        D3DXMESHIbWriteonly = unchecked((int)1024),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_IB_DYNAMIC</unmanaged>
        D3DXMESHIbDynamic = unchecked((int)2048),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_IB_SOFTWAREPROCESSING</unmanaged>
        D3DXMESHIbSoftwareprocessing = unchecked((int)65536),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_VB_SHARE</unmanaged>
        D3DXMESHVbShare = unchecked((int)4096),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_USEHWONLY</unmanaged>
        D3DXMESHUsehwonly = unchecked((int)8192),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_SYSTEMMEM</unmanaged>
        D3DXMESHSystemmem = unchecked((int)272),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_MANAGED</unmanaged>
        D3DXMESHManaged = unchecked((int)544),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_WRITEONLY</unmanaged>
        D3DXMESHWriteonly = unchecked((int)1088),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_DYNAMIC</unmanaged>
        D3DXMESHDynamic = unchecked((int)2176),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXMESH_SOFTWAREPROCESSING</unmanaged>
        D3DXMESHSoftwareprocessing = unchecked((int)98304),			
    }
    
    /// <summary>	
    /// Not used. Use <see cref="SlimDX2.Direct3D9.Patchmeshtype"/> instead to specify mesh patch types.	
    /// </summary>	
    /// <unmanaged>_D3DXPATCHMESH</unmanaged>
    public enum D3DXPATCHMESH : int {	
        
        /// <summary>	
        ///  Not used. 	
        /// </summary>	
        /// <unmanaged>D3DXPATCHMESH_DEFAULT</unmanaged>
        D3DXPATCHMESHDefault = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Specifies simplification options for a mesh.	
    /// </summary>	
    /// <unmanaged>_D3DXMESHSIMP</unmanaged>
    public enum D3DXMESHSIMP : int {	
        
        /// <summary>	
        ///  The mesh will be simplified by the number of vertices specified in the MinValue parameter. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHSIMP_VERTEX</unmanaged>
        D3DXMESHSIMPVertex = unchecked((int)1),			
        
        /// <summary>	
        ///  The mesh will be simplified by the number of faces specified in the MinValue parameter. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHSIMP_FACE</unmanaged>
        D3DXMESHSIMPFace = unchecked((int)2),			
    }
    
    /// <summary>	
    /// Defines operations to perform on vertices in preparation for mesh cleaning.	
    /// </summary>	
    /// <unmanaged>D3DXCLEANTYPE</unmanaged>
    public enum Cleantype : int {	
        
        /// <summary>	
        ///  Merge triangles that share the same vertex indices but have face normals pointing in opposite directions (back-facing triangles). Unless the triangles are not split by adding a replicated vertex, mesh adjacency data from the two triangles may conflict. 	
        /// </summary>	
        /// <unmanaged>D3DXCLEAN_BACKFACING</unmanaged>
        Backfacing = unchecked((int)1),			
        
        /// <summary>	
        ///  If a vertex is the apex of two triangle fans (a bowtie) and mesh operations will affect one of the fans, then split the shared vertex into two new vertices. Bowties can cause problems for operations such as mesh simplification that remove vertices, because removing one vertex affects two distinct sets of triangles. 	
        /// </summary>	
        /// <unmanaged>D3DXCLEAN_BOWTIES</unmanaged>
        Bowties = unchecked((int)2),			
        
        /// <summary>	
        ///  Use this flag to prevent infinite loops during skinning setup mesh operations. 	
        /// </summary>	
        /// <unmanaged>D3DXCLEAN_SKINNING</unmanaged>
        Skinning = unchecked((int)1),			
        
        /// <summary>	
        ///  Use this flag to prevent infinite loops during mesh optimization operations. 	
        /// </summary>	
        /// <unmanaged>D3DXCLEAN_OPTIMIZATION</unmanaged>
        Optimization = unchecked((int)1),			
        
        /// <summary>	
        ///  Use this flag to prevent infinite loops during mesh simplification operations. 	
        /// </summary>	
        /// <unmanaged>D3DXCLEAN_SIMPLIFICATION</unmanaged>
        Simplification = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Defines settings used for mesh tangent frame computations.	
    /// </summary>	
    /// <unmanaged>D3DXTANGENT</unmanaged>
    public enum Tangent : int {	
        
        /// <summary>	
        ///  Texture coordinate values in the u direction are between 0 and 1. In this case a texture coordinate set will be chosen that minimizes the perimeter of the triangle. See {{Texture Wrapping (Direct3D 9)}}. 	
        /// </summary>	
        /// <unmanaged>D3DXTANGENT_WRAP_U</unmanaged>
        WrapU = unchecked((int)1),			
        
        /// <summary>	
        ///  Texture coordinate values in the v direction are between 0 and 1. In this case a texture coordinate set will be chosen that minimizes the perimeter of the triangle. See {{Texture Wrapping (Direct3D 9)}}. 	
        /// </summary>	
        /// <unmanaged>D3DXTANGENT_WRAP_V</unmanaged>
        WrapV = unchecked((int)2),			
        
        /// <summary>	
        ///  Texture coordinate values in both u and v directions are between 0 and 1. In this case a texture coordinate set will be chosen that minimizes the perimeter of the triangle. See {{Texture Wrapping (Direct3D 9)}}. 	
        /// </summary>	
        /// <unmanaged>D3DXTANGENT_WRAP_UV</unmanaged>
        WrapUv = unchecked((int)3),			
        
        /// <summary>	
        ///  Do not normalize partial derivatives with respect to texture coordinates. If not normalized, the scale of the partial derivatives is proportional to the scale of the 3D model divided by the scale of the triangle in (u, v) space. This scale value provides a measure of how much the texture is stretched in a given direction. The resulting vector length is a weighted sum of the lengths of the partial derivatives. 	
        /// </summary>	
        /// <unmanaged>D3DXTANGENT_DONT_NORMALIZE_PARTIALS</unmanaged>
        DontNormalizePartials = unchecked((int)4),			
        
        /// <summary>	
        ///  Do not transform texture coordinates to orthogonal Cartesian coordinates. Mutually exclusive with D3DXTANGENT_ORTHOGONALIZE_FROM_U and D3DXTANGENT_ORTHOGONALIZE_FROM_V. 	
        /// </summary>	
        /// <unmanaged>D3DXTANGENT_DONT_ORTHOGONALIZE</unmanaged>
        DontOrthogonalize = unchecked((int)8),			
        
        /// <summary>	
        ///  Compute the partial derivative with respect to texture coordinate v independently for each vertex, and then compute the partial derivative with respect to u as the cross product of the partial derivative with respect to v and the normal vector. Mutually exclusive with D3DXTANGENT_DONT_ORTHOGONALIZE and D3DXTANGENT_ORTHOGONALIZE_FROM_U. 	
        /// </summary>	
        /// <unmanaged>D3DXTANGENT_ORTHOGONALIZE_FROM_V</unmanaged>
        OrthogonalizeFromV = unchecked((int)16),			
        
        /// <summary>	
        ///  Compute the partial derivative with respect to texture coordinate u independently for each vertex, and then compute the partial derivative with respect to v as  the cross product of the normal vector and the partial derivative with respect to u. Mutually exclusive with D3DXTANGENT_DONT_ORTHOGONALIZE and D3DXTANGENT_ORTHOGONALIZE_FROM_V. 	
        /// </summary>	
        /// <unmanaged>D3DXTANGENT_ORTHOGONALIZE_FROM_U</unmanaged>
        OrthogonalizeFromU = unchecked((int)32),			
        
        /// <summary>	
        ///  Weight the direction of the computed per-vertex normal or partial derivative vector according to the areas of triangles attached to that vertex. Mutually exclusive with D3DXTANGENT_WEIGHT_EQUAL. 	
        /// </summary>	
        /// <unmanaged>D3DXTANGENT_WEIGHT_BY_AREA</unmanaged>
        WeightByArea = unchecked((int)64),			
        
        /// <summary>	
        ///  Compute a unit-length normal vector for each triangle of the input mesh. Mutually exclusive with D3DXTANGENT_WEIGHT_BY_AREA. 	
        /// </summary>	
        /// <unmanaged>D3DXTANGENT_WEIGHT_EQUAL</unmanaged>
        WeightEqual = unchecked((int)128),			
        
        /// <summary>	
        ///  Vertices are ordered in a clockwise direction around each triangle. The computed normal vector direction is therefore inverted 180 degrees from the direction computed using counterclockwise vertex ordering. 	
        /// </summary>	
        /// <unmanaged>D3DXTANGENT_WIND_CW</unmanaged>
        WindCw = unchecked((int)256),			
        
        /// <summary>	
        ///  Compute the per-vertex normal vector for each triangle of the input mesh, and ignore any normal vectors already in the input mesh. 	
        /// </summary>	
        /// <unmanaged>D3DXTANGENT_CALCULATE_NORMALS</unmanaged>
        CalculateNormals = unchecked((int)512),			
        
        /// <summary>	
        ///  The results are stored in the original input mesh, and the output mesh is not used. 	
        /// </summary>	
        /// <unmanaged>D3DXTANGENT_GENERATE_IN_PLACE</unmanaged>
        GenerateInPlace = unchecked((int)1024),			
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DXIMT</unmanaged>
    public enum Imt : int {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXIMT_WRAP_U</unmanaged>
        WrapU = unchecked((int)1),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXIMT_WRAP_V</unmanaged>
        WrapV = unchecked((int)2),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DXIMT_WRAP_UV</unmanaged>
        WrapUv = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Defines options for performing geodesic distance calculations, when fitting a texture to a curved surface. Use this flag to choose between high quality versus fast  calculations when computing a texture atlas.	
    /// </summary>	
    /// <unmanaged>D3DXUVATLAS</unmanaged>
    public enum Uvatlas : int {	
        
        /// <summary>	
        ///  Meshes with more than 25k faces will have the fast geodasic distance method applied to them while meshes with fewer than 25k faces will have the higher quality geodesic distance method applied to them instead. 	
        /// </summary>	
        /// <unmanaged>D3DXUVATLAS_DEFAULT</unmanaged>
        Default = unchecked((int)0),			
        
        /// <summary>	
        ///  Uses approximations to improve charting speed at the cost of added stretch or more charts being output for the mesh. 	
        /// </summary>	
        /// <unmanaged>D3DXUVATLAS_GEODESIC_FAST</unmanaged>
        GeodesicFast = unchecked((int)1),			
        
        /// <summary>	
        ///  Provides better quality charts, but requires more time and memory than fast. 	
        /// </summary>	
        /// <unmanaged>D3DXUVATLAS_GEODESIC_QUALITY</unmanaged>
        GeodesicQuality = unchecked((int)2),			
    }
    
    /// <summary>	
    /// Effect data types. The data is contained in the pValue member of <see cref="SlimDX2.Direct3D9.Effectdefault"/>.	
    /// </summary>	
    /// <unmanaged>D3DXEFFECTDEFAULTTYPE</unmanaged>
    public enum Effectdefaulttype : int {	
        
        /// <summary>	
        ///  The data type is a NULL-terminated ASCII text string. 	
        /// </summary>	
        /// <unmanaged>D3DXEDT_STRING</unmanaged>
        DtString = unchecked((int)1),			
        
        /// <summary>	
        ///  The data type is an array of type float. The number of float types in the array is specified by NumBytes in <see cref="SlimDX2.Direct3D9.Effectdefault"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXEDT_FLOATS</unmanaged>
        DtFloats = unchecked((int)2),			
        
        /// <summary>	
        ///  The data type is a DWORD. 	
        /// </summary>	
        /// <unmanaged>D3DXEDT_DWORD</unmanaged>
        DtDword = unchecked((int)3),			
        
        /// <summary>	
        ///  Forces this enumeration to compile to 32 bits in size. Without this value, some compilers would allow this enumeration to compile to a size other than 32 bits. This value is not used. 	
        /// </summary>	
        /// <unmanaged>D3DXEDT_FORCEDWORD</unmanaged>
        DtForcedword = unchecked((int)2147483647),			
    }
    
    /// <summary>	
    /// Options for welding together vertices.	
    /// </summary>	
    /// <unmanaged>_D3DXWELDEPSILONSFLAGS</unmanaged>
    [Flags]
    public enum D3DXWELDEPSILONSFLAGS : int {	
        
        /// <summary>	
        ///  Weld together all vertices that are at the same location. Using this flag avoids an epsilon comparison between vertex components. 	
        /// </summary>	
        /// <unmanaged>D3DXWELDEPSILONS_WELDALL</unmanaged>
        D3DXWELDEPSILONSWeldall = unchecked((int)1),			
        
        /// <summary>	
        ///  If a given vertex component is within epsilon, modify partially matched vertices so that both components are identical. If all components are equal, remove one of the vertices. 	
        /// </summary>	
        /// <unmanaged>D3DXWELDEPSILONS_WELDPARTIALMATCHES</unmanaged>
        D3DXWELDEPSILONSWeldpartialmatches = unchecked((int)2),			
        
        /// <summary>	
        ///  Instructs the weld to allow only modifications to vertices and not removal. This flag is valid only if D3DXWELDEPSILONS_WELDPARTIALMATCHES is set. It is useful to modify vertices to be equal, but not to allow vertices to be removed. 	
        /// </summary>	
        /// <unmanaged>D3DXWELDEPSILONS_DONOTREMOVEVERTICES</unmanaged>
        D3DXWELDEPSILONSDonotremovevertices = unchecked((int)4),			
        
        /// <summary>	
        ///  Instructs the weld not to split vertices that are in separate attribute groups. When the <see cref="SlimDX2.Direct3D9.Mesh.Optimize"/> method is called with the D3DXMESHOPT_ATTRSORT flag, then the D3DXMESHOPT_DONOTSPLIT flag will also be set. Setting this flag can slow down software vertex processing. 	
        /// </summary>	
        /// <unmanaged>D3DXWELDEPSILONS_DONOTSPLIT</unmanaged>
        D3DXWELDEPSILONSDonotsplit = unchecked((int)8),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Specifies the type of mesh optimization to be performed.	
    /// </summary>	
    /// <remarks>	
    ///  The D3DXMESHOPT_STRIPREORDER and D3DXMESHOPT_VERTEXCACHE optimization flags are mutually exclusive. The D3DXMESHOPT_SHAREVB flag has been removed from this enumeration. Use D3DXMESH_VB_SHARE instead, in {{D3DXMESH}}. 	
    /// </remarks>	
    /// <unmanaged>_D3DXMESHOPT</unmanaged>
    public enum D3DXMESHOPT : int {	
        
        /// <summary>	
        ///  Reorders faces to remove unused vertices and faces. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHOPT_COMPACT</unmanaged>
        D3DXMESHOPTCompact = unchecked((int)16777216),			
        
        /// <summary>	
        ///  Reorders faces to optimize for fewer attribute bundle state changes and enhanced <see cref="SlimDX2.Direct3D9.BaseMesh.DrawSubset"/> performance. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHOPT_ATTRSORT</unmanaged>
        D3DXMESHOPTAttrsort = unchecked((int)33554432),			
        
        /// <summary>	
        ///  Reorders faces to increase the cache hit rate of vertex caches. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHOPT_VERTEXCACHE</unmanaged>
        D3DXMESHOPTVertexcache = unchecked((int)67108864),			
        
        /// <summary>	
        ///  Reorders faces to maximize length of adjacent triangles. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHOPT_STRIPREORDER</unmanaged>
        D3DXMESHOPTStripreorder = unchecked((int)134217728),			
        
        /// <summary>	
        ///  Optimize the faces only; do not optimize the vertices. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHOPT_IGNOREVERTS</unmanaged>
        D3DXMESHOPTIgnoreverts = unchecked((int)268435456),			
        
        /// <summary>	
        ///  While attribute sorting, do not split vertices that are shared between attribute groups. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHOPT_DONOTSPLIT</unmanaged>
        D3DXMESHOPTDonotsplit = unchecked((int)536870912),			
        
        /// <summary>	
        ///  Affects the vertex cache size. Using this flag specifies a default vertex cache size that works well on legacy hardware. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHOPT_DEVICEINDEPENDENT</unmanaged>
        D3DXMESHOPTDeviceindependent = unchecked((int)4194304),			
    }
    
    /// <summary>	
    /// Spherical harmonic (SH) compression setting.	
    /// </summary>	
    /// <unmanaged>D3DXSHCOMPRESSQUALITYTYPE</unmanaged>
    public enum Shcompressqualitytype : int {	
        
        /// <summary>	
        ///  The data compression is low quality, but is fast to compress. 	
        /// </summary>	
        /// <unmanaged>D3DXSHCQUAL_FASTLOWQUALITY</unmanaged>
        QualFastlowquality = unchecked((int)1),			
        
        /// <summary>	
        ///  The data compression is high quality, but is slow to compress. 	
        /// </summary>	
        /// <unmanaged>D3DXSHCQUAL_SLOWHIGHQUALITY</unmanaged>
        QualSlowhighquality = unchecked((int)2),			
    }
    
    /// <summary>	
    /// Describes the resolution of the shadow z-buffer that will be used in Precomputed Radiance Transfer (PRT) direct lighting simulation on the GPU. A higher quality z-buffer can also be specified to reduce noise in the results of the direct lighting simulation, although the simulation will be slower.	
    /// </summary>	
    /// <remarks>	
    ///  Only one of the resolution values may be specified, and may be combined with the high-quality value. 	
    /// </remarks>	
    /// <unmanaged>D3DXSHGPUSIMOPT</unmanaged>
    public enum Shgpusimopt : int {	
        
        /// <summary>	
        ///  Low resolution simulation. A 256 x 256 pixel texture is used in the simulation to encode the shadow z-buffer. 	
        /// </summary>	
        /// <unmanaged>D3DXSHGPUSIMOPT_SHADOWRES256</unmanaged>
        Shadowres256 = unchecked((int)1),			
        
        /// <summary>	
        ///  Medium resolution simulation. A 512 x 512 pixel texture is used in the simulation to encode the shadow z-buffer. This is the default value. 	
        /// </summary>	
        /// <unmanaged>D3DXSHGPUSIMOPT_SHADOWRES512</unmanaged>
        Shadowres512 = unchecked((int)0),			
        
        /// <summary>	
        ///  High resolution simulation. A 1024 x 1024 pixel texture is used in the simulation to encode the shadow z-buffer. 	
        /// </summary>	
        /// <unmanaged>D3DXSHGPUSIMOPT_SHADOWRES1024</unmanaged>
        Shadowres1024 = unchecked((int)2),			
        
        /// <summary>	
        ///  Highest resolution simulation. A 2048 x 2048 pixel texture is used in the simulation to encode the shadow z-buffer. 	
        /// </summary>	
        /// <unmanaged>D3DXSHGPUSIMOPT_SHADOWRES2048</unmanaged>
        Shadowres2048 = unchecked((int)3),			
        
        /// <summary>	
        ///  The simulation is of high precision, regardless of the selected resolution. Setting this value will reduce noise in the results of the direct lighting simulation, although the simulation will be slower. May be combined with one of the resolution values. 	
        /// </summary>	
        /// <unmanaged>D3DXSHGPUSIMOPT_HIGHQUALITY</unmanaged>
        Highquality = unchecked((int)4),			
    }
    
    /// <summary>	
    /// Data type of the register.	
    /// </summary>	
    /// <unmanaged>D3DXREGISTER_SET</unmanaged>
    public enum RegisterSet : int {	
        
        /// <summary>	
        ///  Boolean value. 	
        /// </summary>	
        /// <unmanaged>D3DXRS_BOOL</unmanaged>
        SBool,
        
        /// <summary>	
        ///  4D integer number. 	
        /// </summary>	
        /// <unmanaged>D3DXRS_INT4</unmanaged>
        SInt4,
        
        /// <summary>	
        ///  4D floating-point number. 	
        /// </summary>	
        /// <unmanaged>D3DXRS_FLOAT4</unmanaged>
        SFloat4,
        
        /// <summary>	
        ///  The register contains 4D sampler data. 	
        /// </summary>	
        /// <unmanaged>D3DXRS_SAMPLER</unmanaged>
        SSampler,
    }
    
    /// <summary>	
    /// The type of object.	
    /// </summary>	
    /// <unmanaged>D3DXPARAMETER_CLASS</unmanaged>
    public enum ParameterClass : int {	
        
        /// <summary>	
        ///  Constant is a scalar. 	
        /// </summary>	
        /// <unmanaged>D3DXPC_SCALAR</unmanaged>
        CScalar,
        
        /// <summary>	
        ///  Constant is a vector. 	
        /// </summary>	
        /// <unmanaged>D3DXPC_VECTOR</unmanaged>
        CVector,
        
        /// <summary>	
        ///  Constant is a row major matrix. 	
        /// </summary>	
        /// <unmanaged>D3DXPC_MATRIX_ROWS</unmanaged>
        CMatrixRows,
        
        /// <summary>	
        ///  Constant is a column major matrix. 	
        /// </summary>	
        /// <unmanaged>D3DXPC_MATRIX_COLUMNS</unmanaged>
        CMatrixColumns,
        
        /// <summary>	
        ///  Constant is either a texture, shader, or a string. 	
        /// </summary>	
        /// <unmanaged>D3DXPC_OBJECT</unmanaged>
        CObject,
        
        /// <summary>	
        ///  Constant is a structure. 	
        /// </summary>	
        /// <unmanaged>D3DXPC_STRUCT</unmanaged>
        CStruct,
    }
    
    /// <summary>	
    /// Describes the data contained by the enumeration.	
    /// </summary>	
    /// <unmanaged>D3DXPARAMETER_TYPE</unmanaged>
    public enum ParameterType : int {	
        
        /// <summary>	
        ///  Parameter is a void pointer. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_VOID</unmanaged>
        TVoid,
        
        /// <summary>	
        ///  Parameter is a Boolean. Any non-zero value passed into <see cref="SlimDX2.Direct3D9.ConstantTable.SetBool"/>, <see cref="SlimDX2.Direct3D9.ConstantTable.SetBoolArray"/>, <see cref="SlimDX2.Direct3D9.ConstantTable.SetValue"/>, <see cref="SlimDX2.Direct3D9.ConstantTable.SetVector"/>, or <see cref="SlimDX2.Direct3D9.ConstantTable.SetVectorArray"/> will be mapped to 1 (TRUE) before being written into the constant table; otherwise, the value will be set to 0 in the constant table. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_BOOL</unmanaged>
        TBool,
        
        /// <summary>	
        ///  Parameter is an integer. Any floating-point values passed into <see cref="SlimDX2.Direct3D9.ConstantTable.SetValue"/>, <see cref="SlimDX2.Direct3D9.ConstantTable.SetVector"/>, or <see cref="SlimDX2.Direct3D9.ConstantTable.SetVectorArray"/> will be rounded off (to zero decimal places) before being written into the constant table. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_INT</unmanaged>
        TInt,
        
        /// <summary>	
        ///  Parameter is a floating-point number. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_FLOAT</unmanaged>
        TFloat,
        
        /// <summary>	
        ///  Parameter is a string. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_STRING</unmanaged>
        TString,
        
        /// <summary>	
        ///  Parameter is a texture. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_TEXTURE</unmanaged>
        TTexture,
        
        /// <summary>	
        ///  Parameter is a 1D texture. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_TEXTURE1D</unmanaged>
        TTexture1D,
        
        /// <summary>	
        ///  Parameter is a 2D texture. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_TEXTURE2D</unmanaged>
        TTexture2D,
        
        /// <summary>	
        ///  Parameter is a 3D texture. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_TEXTURE3D</unmanaged>
        TTexture3D,
        
        /// <summary>	
        ///  Parameter is a cube texture. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_TEXTURECUBE</unmanaged>
        TTexturecube,
        
        /// <summary>	
        ///  Parameter is a sampler. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_SAMPLER</unmanaged>
        TSampler,
        
        /// <summary>	
        ///  Parameter is a 1D sampler. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_SAMPLER1D</unmanaged>
        TSampler1d,
        
        /// <summary>	
        ///  Parameter is a 2D sampler. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_SAMPLER2D</unmanaged>
        TSampler2d,
        
        /// <summary>	
        ///  Parameter is a 3D sampler. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_SAMPLER3D</unmanaged>
        TSampler3d,
        
        /// <summary>	
        ///  Parameter is a cube sampler. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_SAMPLERCUBE</unmanaged>
        TSamplercube,
        
        /// <summary>	
        ///  Parameter is a pixel shader. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_PIXELSHADER</unmanaged>
        TPixelshader,
        
        /// <summary>	
        ///  Parameter is a vertex shader. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_VERTEXSHADER</unmanaged>
        TVertexshader,
        
        /// <summary>	
        ///  Parameter is a pixel shader fragment. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_PIXELFRAGMENT</unmanaged>
        TPixelfragment,
        
        /// <summary>	
        ///  Parameter is a vertex shader fragment. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_VERTEXFRAGMENT</unmanaged>
        TVertexfragment,
        
        /// <summary>	
        ///  Parameter is not supported. 	
        /// </summary>	
        /// <unmanaged>D3DXPT_UNSUPPORTED</unmanaged>
        TUnsupported,
    }
    
    /// <summary>	
    /// Describes the location for the include file.	
    /// </summary>	
    /// <unmanaged>D3DXINCLUDE_TYPE</unmanaged>
    public enum IncludeType : int {	
        
        /// <summary>	
        ///  Look in the local project for the include file. 	
        /// </summary>	
        /// <unmanaged>D3DXINC_LOCAL</unmanaged>
        Local,
        
        /// <summary>	
        ///  Look in the system path for the include file. 	
        /// </summary>	
        /// <unmanaged>D3DXINC_SYSTEM</unmanaged>
        System,
    }
    
    /// <summary>	
    /// Describes the supported image file formats. See Remarks for descriptions of these formats.	
    /// </summary>	
    /// <remarks>	
    ///  Functions that begin with D3DXLoadxxx support all of the formats listed. Functions that begin with D3DXSavexxx support all but the Truevision (.tga) and portable pixmap (.ppm) formats. The following table lists the available input and output formats.   File ExtensionDescription .bmpWindows bitmap format. Contains a header that describes the resolution of the device on which the rectangle of pixels was created, the dimensions of the rectangle, the size of the array of bits, a logical palette, and an array of bits that defines the relationship between pixels in the bitmapped image and entries in the logical palette. .ddsDirectDraw Surface file format. Stores textures, volume textures, and cubic environment maps, with or without mipmap levels, and with or without pixel compression. See {{DDS}}. .dibWindows DIB. Contains an array of bits combined with structures that specify width and height of the bitmapped image, color format of the device where the image was created, and resolution of the device used to create that image. .hdrHDR format. Encodes each pixel as an RGBE 32-bit color, with 8 bits of mantissa for red, green, and blue, and a shared 8-bit exponent. Each channel is separately compressed with run-length encoding (RLE). .jpgJPEG standard. Specifies variable compression of 24-bit RGB color and 8-bit gray-scale Tagged Image File Format (TIFF) image document files. .pfmPortable float map format. A raw floating point image format, without any compression. The file header specifies image width, height, monochrome or color, and machine word order. Pixel data is stored as 32-bit floating point values, with 3 values per pixel for color, and one value per pixel for monochrome. .pngPNG format. A non-proprietary bitmap format using lossless compression. .ppmPortable Pixmap format. A binary or ASCII file format for color images that includes image height and width and the maximum color component value. .tgaTarga or Truevision Graphics Adapter format. Supports depths of 8, 15, 16, 24, and 32 bits, including 8-bit gray scale, and contains optional color palette data, image (x, y) origin and size data, and pixel data.    See {{Types of Bitmaps}} for more information on some of these formats. 	
    /// </remarks>	
    /// <unmanaged>D3DXIMAGE_FILEFORMAT</unmanaged>
    public enum ImageFileformat : int {	
        
        /// <summary>	
        ///  Windows bitmap (BMP) file format. 	
        /// </summary>	
        /// <unmanaged>D3DXIFF_BMP</unmanaged>
        FfBmp = unchecked((int)0),			
        
        /// <summary>	
        ///  Joint Photographics Experts Group (JPEG) compressed file format. 	
        /// </summary>	
        /// <unmanaged>D3DXIFF_JPG</unmanaged>
        FfJpg = unchecked((int)1),			
        
        /// <summary>	
        ///  Truevision (Targa, or TGA) image file format. 	
        /// </summary>	
        /// <unmanaged>D3DXIFF_TGA</unmanaged>
        FfTga = unchecked((int)2),			
        
        /// <summary>	
        ///  Portable Network Graphics (PNG) file format. 	
        /// </summary>	
        /// <unmanaged>D3DXIFF_PNG</unmanaged>
        FfPng = unchecked((int)3),			
        
        /// <summary>	
        ///  DirectDraw surface (DDS) file format. 	
        /// </summary>	
        /// <unmanaged>D3DXIFF_DDS</unmanaged>
        FfDds = unchecked((int)4),			
        
        /// <summary>	
        ///  Portable pixmap (PPM) file format. 	
        /// </summary>	
        /// <unmanaged>D3DXIFF_PPM</unmanaged>
        FfPpm = unchecked((int)5),			
        
        /// <summary>	
        ///  Windows device-independent bitmap (DIB) file format. 	
        /// </summary>	
        /// <unmanaged>D3DXIFF_DIB</unmanaged>
        FfDib = unchecked((int)6),			
        
        /// <summary>	
        ///  High dynamic range (HDR) file format. 	
        /// </summary>	
        /// <unmanaged>D3DXIFF_HDR</unmanaged>
        FfHdr = unchecked((int)7),			
        
        /// <summary>	
        ///  Portable float map file format. 	
        /// </summary>	
        /// <unmanaged>D3DXIFF_PFM</unmanaged>
        FfPfm = unchecked((int)8),			
    }
    
    /// <summary>	
    /// Defines the type of mesh data present in <see cref="SlimDX2.Direct3D9.Meshdata"/>.	
    /// </summary>	
    /// <unmanaged>D3DXMESHDATATYPE</unmanaged>
    public enum Meshdatatype : int {	
        
        /// <summary>	
        ///  The data type is a mesh. See <see cref="SlimDX2.Direct3D9.Mesh"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHTYPE_MESH</unmanaged>
        TypeMesh = unchecked((int)1),			
        
        /// <summary>	
        ///  The data type is a patch mesh. See <see cref="SlimDX2.Direct3D9.PatchMesh"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHTYPE_PMESH</unmanaged>
        TypePmesh = unchecked((int)2),			
        
        /// <summary>	
        ///  Forces this enumeration to compile to 32 bits in size. Without this value, some compilers would allow this enumeration to compile to a size other than 32 bits. This value is not used. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHTYPE_PATCHMESH</unmanaged>
        TypePatchmesh = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Flags used to obtain callback information.	
    /// </summary>	
    /// <unmanaged>D3DXCALLBACK_SEARCH_FLAGS</unmanaged>
    [Flags]
    public enum CallbackSearchFlags : int {	
        
        /// <summary>	
        ///  Exclude callbacks located at the initial position from the search. 	
        /// </summary>	
        /// <unmanaged>D3DXCALLBACK_SEARCH_EXCLUDING_INITIAL_POSITION</unmanaged>
        ExcludingInitialPosition = unchecked((int)1),			
        
        /// <summary>	
        ///  Reverse the callback search direction. 	
        /// </summary>	
        /// <unmanaged>D3DXCALLBACK_SEARCH_BEHIND_INITIAL_POSITION</unmanaged>
        BehindInitialPosition = unchecked((int)2),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Defines the type of animation set looping modes used for playback.	
    /// </summary>	
    /// <unmanaged>D3DXPLAYBACK_TYPE</unmanaged>
    public enum PlaybackType : int {	
        
        /// <summary>	
        ///  The animation repeats endlessly. 	
        /// </summary>	
        /// <unmanaged>D3DXPLAY_LOOP</unmanaged>
        Loop = unchecked((int)0),			
        
        /// <summary>	
        ///  The animation plays once, and then it stops on the last frame. 	
        /// </summary>	
        /// <unmanaged>D3DXPLAY_ONCE</unmanaged>
        Once = unchecked((int)1),			
        
        /// <summary>	
        ///  The animation alternates endlessly between playing forward and playing backward. 	
        /// </summary>	
        /// <unmanaged>D3DXPLAY_PINGPONG</unmanaged>
        Pingpong = unchecked((int)2),			
    }
    
    /// <summary>	
    /// Defines the compression mode used for storing compressed animation set data.	
    /// </summary>	
    /// <unmanaged>D3DXCOMPRESSION_FLAGS</unmanaged>
    [Flags]
    public enum CompressionFlags : int {	
        
        /// <summary>	
        ///  Implements fast compression. 	
        /// </summary>	
        /// <unmanaged>D3DXCOMPRESS_DEFAULT</unmanaged>
        Default = unchecked((int)0),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Defines the priority type to which an animation track is assigned.	
    /// </summary>	
    /// <remarks>	
    ///  Tracks with the same priority are blended together, and the two resulting values are then blended using the priority blend factor. 	
    /// </remarks>	
    /// <unmanaged>D3DXPRIORITY_TYPE</unmanaged>
    public enum PriorityType : int {	
        
        /// <summary>	
        ///  Track should be blended with all the low-priority tracks before the low-priority blend is mixed with the high-priority blend. 	
        /// </summary>	
        /// <unmanaged>D3DXPRIORITY_LOW</unmanaged>
        Low = unchecked((int)0),			
        
        /// <summary>	
        ///  Track should be blended with all the high-priority tracks before the high-priority blend is mixed with the low-priority blend. 	
        /// </summary>	
        /// <unmanaged>D3DXPRIORITY_HIGH</unmanaged>
        High = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Describes the type of events that can be keyed by the animation controller.	
    /// </summary>	
    /// <unmanaged>D3DXEVENT_TYPE</unmanaged>
    public enum EventType : int {	
        
        /// <summary>	
        ///  Track speed. 	
        /// </summary>	
        /// <unmanaged>D3DXEVENT_TRACKSPEED</unmanaged>
        Trackspeed = unchecked((int)0),			
        
        /// <summary>	
        ///  Track weight. 	
        /// </summary>	
        /// <unmanaged>D3DXEVENT_TRACKWEIGHT</unmanaged>
        Trackweight = unchecked((int)1),			
        
        /// <summary>	
        ///  Track position. 	
        /// </summary>	
        /// <unmanaged>D3DXEVENT_TRACKPOSITION</unmanaged>
        Trackposition = unchecked((int)2),			
        
        /// <summary>	
        ///  Enable flag. 	
        /// </summary>	
        /// <unmanaged>D3DXEVENT_TRACKENABLE</unmanaged>
        Trackenable = unchecked((int)3),			
        
        /// <summary>	
        ///  Priority blend value. 	
        /// </summary>	
        /// <unmanaged>D3DXEVENT_PRIORITYBLEND</unmanaged>
        Priorityblend = unchecked((int)4),			
    }
    
    /// <summary>	
    /// Defines the transition style between values of a mesh animation.	
    /// </summary>	
    /// <remarks>	
    ///  The calculation for the ramp from ease in to ease out is calculated as follows:  Q(t) = 2(x - y)t3 + 3(y - x)t2 + x  where the ramp is a function Q(t) with the following properties:  Q(t) is a cubic spline. Q(t) interpolates between x and y as t ranges from 0 to 1. Q(t) is horizontal when t = 0 and t = 1.  Mathematically, this translates into:  Q(t) = At3 + Bt2 + Ct + D (and therefore, Q'(t) = 3At2 + 2Bt + C) 2a) Q(0) = x 2b) Q(1) = y 3a) Q'(0) = 0 3b) Q'(1) = 0  Solving for A, B, C, D:   D = x   (from 2a) C = 0  (from 3a) 3A + 2B = 0 (from 3b) A + B = y - x (from 2b and D = x)  Therefore:  A = 2(x - y), B = 3(y - x), C = 0, D = x  	
    /// </remarks>	
    /// <unmanaged>D3DXTRANSITION_TYPE</unmanaged>
    public enum TransitionType : int {	
        
        /// <summary>	
        ///  Linear transition between values. 	
        /// </summary>	
        /// <unmanaged>D3DXTRANSITION_LINEAR</unmanaged>
        Linear = unchecked((int)0),			
        
        /// <summary>	
        ///  Ease-in, ease-out spline transition between values. 	
        /// </summary>	
        /// <unmanaged>D3DXTRANSITION_EASEINEASEOUT</unmanaged>
        Easeineaseout = unchecked((int)1),			
    }
}
