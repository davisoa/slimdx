// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Functions for SlimDX2.Direct3D9 namespace.
//     This code was generated by a tool.
//     Date : 11/09/2010 17:36:57
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace SlimDX2.Direct3D9 {


	/// <summary>
    /// D3D9 Functions.
    /// </summary>
    static partial class D3D9 {   
        
        /// <summary>Constant D3D_SDK_VERSION.</summary>
        public const int D3DSdkVersion = 32;
        
        /// <summary>	
        /// Create an IDirect3D9 object and return an interface to it.	
        /// </summary>	
        /// <remarks>	
        ///  The Direct3D object is the first Direct3D COM object that your graphical application needs to create and the last object that your application needs to release. Functions for enumerating and retrieving capabilities of a device are accessible through the Direct3D object. This enables applications to select devices without creating them. Create an IDirect3D9 object as shown here: 	
        /// <code> LPDIRECT3D9 g_pD3D = NULL; if( NULL == (g_pD3D = Direct3DCreate9(D3D_SDK_VERSION))) return E_FAIL; </code>	
        /// 	
        ///  The IDirect3D9 interface supports enumeration of active display adapters and allows the creation of <see cref="SlimDX2.Direct3D9.Device"/> objects. If the user dynamically adds adapters (either by adding devices to the desktop, or by hot-docking a laptop), those devices will not be included in the enumeration. Creating a new IDirect3D9 interface will expose the new devices. D3D_SDK_VERSION is passed to this function to ensure that the header files against which an application is compiled match the version of the runtime DLL's that are installed on the machine. D3D_SDK_VERSION is only changed in the runtime when a header change (or other code change) would require an application to be rebuilt. If this function fails, it indicates that the header file version does not match the runtime DLL version. For an example, see {{Creating a Device (Direct3D 9)}}. 	
        /// </remarks>	
        /// <param name="sDKVersion"> The value of this parameter should be D3D_SDK_VERSION. See Remarks. </param>
        /// <returns> <see cref="SlimDX2.Direct3D9.Direct3D9"/> If successful, this function returns a pointer to an <see cref="SlimDX2.Direct3D9.Direct3D9"/> interface; otherwise, a NULL pointer is returned. </returns>
        /// <unmanaged>IDirect3D9* Direct3DCreate9([None] UINT SDKVersion)</unmanaged>
		public static SlimDX2.Direct3D9.Direct3D9 Direct3DCreate9(int sDKVersion) {
            unsafe {
                SlimDX2.Direct3D9.Direct3D9 __result__;
                __result__= (SlimDX2.Direct3D9.Direct3D9)Direct3DCreate9_( sDKVersion);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>IDirect3D9* Direct3DCreate9([None] UINT SDKVersion)</unmanaged>
		[DllImport("d3d9.dll", EntryPoint = "Direct3DCreate9", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Direct3D9.Direct3D9 Direct3DCreate9_(int sDKVersion);		
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct3D9.Direct3D9Ex"/> object and returns an interface to it.	
        /// </summary>	
        /// <remarks>	
        ///   The <see cref="SlimDX2.Direct3D9.Direct3D9Ex"/> object is the first object that the application creates and the last object thta the application releases. Functions for enumerating and retrieving capabilities of a device are accessible through the IDirect3D9Ex object. This enables applications to select devices without creating them.   The <see cref="SlimDX2.Direct3D9.Direct3D9Ex"/> interface supports enumeration of active display adapters and allows the creation of IDirect3D9Ex objects. If the user dynamically adds adapters (either by adding devices to the desktop, or by hot-docking a laptop), these devices are not included in the enumeration. Creating a new IDirect3D9Ex interface will expose the new devices.   Pass the D3D_SDK_VERSION flag to this function to ensure that header files used in the compiled application match the version of the installed runtime DLLs. D3D_SDK_VERSION is changed in the runtime only when a header or another code change would require rebuilding the application. If this function fails, it indicates that the versions of the header file and the runtime DLL do not match.  Note Direct3DCreate9Ex is supported only in Windows Vista, Windows Server 2008, and Windows 7.   Earlier versions of the D3D9.dll library do not include Direct3D9Ex and Direct3DCreate9Ex.  	
        /// </remarks>	
        /// <param name="sDKVersion"> The value of this parameter should be D3D_SDK_VERSION. See Remarks. </param>
        /// <param name="arg1">  Address of a pointer to an <see cref="SlimDX2.Direct3D9.Direct3D9Ex"/> interface, representing the created IDirect3D9Ex object. If the function fails, NULL is inserted here.  </param>
        /// <returns> <see cref="int"/>   D3DERR_NOTAVAILABLE if Direct3DEx features are not supported (no WDDM driver is installed) or if the SDKVersion does not match the version of the DLL.   D3DERR_OUTOFMEMORY if out-of-memory conditions are detected when creating the enumerator object.  S_OK if the creation of the enumerator object is successful.  </returns>
        /// <unmanaged>HRESULT Direct3DCreate9Ex([None] UINT SDKVersion,[None] IDirect3D9Ex** arg1)</unmanaged>
		public static SlimDX2.Result Direct3DCreate9Ex(int sDKVersion, out SlimDX2.Direct3D9.Direct3D9Ex arg1) {
            unsafe {
                IntPtr arg1_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)Direct3DCreate9Ex_( sDKVersion, out arg1_);
                arg1 = (arg1_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Direct3D9Ex(arg1_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT Direct3DCreate9Ex([None] UINT SDKVersion,[None] IDirect3D9Ex** arg1)</unmanaged>
		[DllImport("d3d9.dll", EntryPoint = "Direct3DCreate9Ex", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result Direct3DCreate9Ex_(int sDKVersion, out IntPtr arg1);		
    }

	/// <summary>
    /// D3DX9 Functions.
    /// </summary>
    static partial class D3DX9 {   
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="col">No documentation.</param>
        /// <param name="wszName">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>int D3DPERF_BeginEvent([None] D3DCOLOR col,[None] const wchar* wszName)</unmanaged>
		public static int PerfBeginEvent(int col, string wszName) {
            unsafe {
                int __result__;
                __result__= (int)D3DPERF_BeginEvent_( col,  wszName);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>int D3DPERF_BeginEvent([None] D3DCOLOR col,[None] const wchar* wszName)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_BeginEvent", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DPERF_BeginEvent_(int col, [MarshalAs(UnmanagedType.LPWStr),In] string wszName);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int D3DPERF_EndEvent()</unmanaged>
		public static int PerfEndEvent() {
            unsafe {
                int __result__;
                __result__= (int)D3DPERF_EndEvent_();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>int D3DPERF_EndEvent()</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_EndEvent", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DPERF_EndEvent_();		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="col">No documentation.</param>
        /// <param name="wszName">No documentation.</param>
        /// <unmanaged>void D3DPERF_SetMarker([None] D3DCOLOR col,[None] const wchar* wszName)</unmanaged>
		public static void PerfSetMarker(int col, string wszName) {
            unsafe {
                D3DPERF_SetMarker_( col,  wszName);
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>void D3DPERF_SetMarker([None] D3DCOLOR col,[None] const wchar* wszName)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_SetMarker", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static void D3DPERF_SetMarker_(int col, [MarshalAs(UnmanagedType.LPWStr),In] string wszName);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="col">No documentation.</param>
        /// <param name="wszName">No documentation.</param>
        /// <unmanaged>void D3DPERF_SetRegion([None] D3DCOLOR col,[None] const wchar* wszName)</unmanaged>
		public static void PerfSetRegion(int col, string wszName) {
            unsafe {
                D3DPERF_SetRegion_( col,  wszName);
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>void D3DPERF_SetRegion([None] D3DCOLOR col,[None] const wchar* wszName)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_SetRegion", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static void D3DPERF_SetRegion_(int col, [MarshalAs(UnmanagedType.LPWStr),In] string wszName);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>BOOL D3DPERF_QueryRepeatFrame()</unmanaged>
		public static bool PerfQueryRepeatFrame() {
            unsafe {
                bool __result__;
                __result__= (bool)D3DPERF_QueryRepeatFrame_();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>BOOL D3DPERF_QueryRepeatFrame()</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_QueryRepeatFrame", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static bool D3DPERF_QueryRepeatFrame_();		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwOptions">No documentation.</param>
        /// <unmanaged>void D3DPERF_SetOptions([None] int dwOptions)</unmanaged>
		public static void PerfSetOptions(int dwOptions) {
            unsafe {
                D3DPERF_SetOptions_( dwOptions);
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>void D3DPERF_SetOptions([None] int dwOptions)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_SetOptions", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static void D3DPERF_SetOptions_(int dwOptions);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int D3DPERF_GetStatus()</unmanaged>
		public static int PerfGetStatus() {
            unsafe {
                int __result__;
                __result__= (int)D3DPERF_GetStatus_();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>int D3DPERF_GetStatus()</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_GetStatus", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DPERF_GetStatus_();		
        
        /// <summary>	
        /// Verify that the version of D3DX you compiled with is the version that you are running.	
        /// </summary>	
        /// <remarks>	
        ///  Use this function during the initialization of your application like this: 	
        /// <code> HRESULT CD3DXMyApplication::Initialize(HINSTANCE hInstance,  LPCSTR szWindowName, LPCSTR szClassName, UINT uWidth, UINT uHeight)	
        /// { HRESULT hr; if (!D3DXCheckVersion(D3D_SDK_VERSION, D3DX_SDK_VERSION)) return E_FAIL; ...	
        /// } </code>	
        /// 	
        ///  Use <see cref="SlimDX2.Direct3D9.D3D9.Direct3DCreate9"/> to verify that the correct runtime is installed. 	
        /// </remarks>	
        /// <param name="d3DSdkVersion"> Use D3D_SDK_VERSION. See remarks. </param>
        /// <param name="d3DXSdkVersion"> Use D3DX_SDK_VERSION. See remarks. </param>
        /// <returns> {{BOOL}} Returns TRUE if the version of D3DX you compiled against is the version you are running with; otherwise, FALSE is returned. </returns>
        /// <unmanaged>BOOL D3DXCheckVersion([None] UINT D3DSdkVersion,[None] UINT D3DXSdkVersion)</unmanaged>
		public static bool CheckVersion(int d3DSdkVersion, int d3DXSdkVersion) {
            unsafe {
                bool __result__;
                __result__= (bool)D3DXCheckVersion_( d3DSdkVersion,  d3DXSdkVersion);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>BOOL D3DXCheckVersion([None] UINT D3DSdkVersion,[None] UINT D3DXSdkVersion)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCheckVersion", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static bool D3DXCheckVersion_(int d3DSdkVersion, int d3DXSdkVersion);		
        
        /// <summary>	
        /// Turns on or off all D3DX debug output.	
        /// </summary>	
        /// <param name="mute"> If TRUE, debugger output is halted; if FALSE, debug output is enabled. </param>
        /// <returns> {{BOOL}} Returns the previous value of Mute. </returns>
        /// <unmanaged>BOOL D3DXDebugMute([None] BOOL Mute)</unmanaged>
		public static bool DebugMute(bool mute) {
            unsafe {
                bool __result__;
                __result__= (bool)D3DXDebugMute_( mute);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>BOOL D3DXDebugMute([None] BOOL Mute)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXDebugMute", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static bool D3DXDebugMute_(bool mute);		
        
        /// <summary>	
        /// Returns the driver level.	
        /// </summary>	
        /// <remarks>	
        ///  This method returns the driver version, which is one of the following:  700 - Direct3D 7 level driver 800 - Direct3D 8 level driver 900 - Direct3D 9 level driver  	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface representing the device. </param>
        /// <returns> {{UINT}} The driver level. See remarks. </returns>
        /// <unmanaged>UINT D3DXGetDriverLevel([None] LPDIRECT3DDEVICE9 pDevice)</unmanaged>
		public static int GetDriverLevel(SlimDX2.Direct3D9.Device pDevice) {
            unsafe {
                int __result__;
                __result__= (int)D3DXGetDriverLevel_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>UINT D3DXGetDriverLevel([None] LPDIRECT3DDEVICE9 pDevice)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetDriverLevel", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DXGetDriverLevel_(IntPtr pDevice);		
        
        /// <summary>	
        /// Creates a sprite object which is associated with a particular device. Sprite objects are used to draw 2D images to the screen.	
        /// </summary>	
        /// <remarks>	
        ///  This interface can be used to draw two dimensional images in screen space of the associated device. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device to be associated with the sprite. </param>
        /// <param name="ppSprite"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Sprite"/> interface. This interface allows the user to access sprite functions.  </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK.If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateSprite([None] LPDIRECT3DDEVICE9 pDevice,[None] LPD3DXSPRITE* ppSprite)</unmanaged>
		public static SlimDX2.Result CreateSprite(SlimDX2.Direct3D9.Device pDevice, out SlimDX2.Direct3D9.Sprite ppSprite) {
            unsafe {
                IntPtr ppSprite_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateSprite_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer, out ppSprite_);
                ppSprite = (ppSprite_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Sprite(ppSprite_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateSprite([None] LPDIRECT3DDEVICE9 pDevice,[None] LPD3DXSPRITE* ppSprite)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSprite", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateSprite_(IntPtr pDevice, out IntPtr ppSprite);		
        
        /// <summary>	
        /// Creates a font object for a device and font.	
        /// </summary>	
        /// <remarks>	
        ///  The creation of an ID3DXFont object requires that the device supports 32-bit color. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateFontW. Otherwise, the function call resolves to D3DXCreateFontA because ANSI strings are being used. If you want more information about font parameters, see {{The Logical Font}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device to be associated with the font object. </param>
        /// <param name="height"> The height of the characters in logical units. </param>
        /// <param name="width"> The width of the characters in logical units. </param>
        /// <param name="weight"> Typeface weight. One example is bold. </param>
        /// <param name="mipLevels"> The number of mipmap levels. </param>
        /// <param name="italic"> True for italic font, false otherwise. </param>
        /// <param name="charSet"> The character set of the font. </param>
        /// <param name="outputPrecision"> Specifies how Windows should attempt to match the desired font sizes and characteristics with actual fonts. Use OUT_TT_ONLY_PRECIS for instance, to ensure that you always get a TrueType font. </param>
        /// <param name="quality"> Specifies how Windows should match the desired font with a real font. It applies to raster fonts only and should not affect TrueType fonts. </param>
        /// <param name="pitchAndFamily"> Pitch and family index. </param>
        /// <param name="pFaceName"> String containing the typeface name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.  </param>
        /// <param name="ppFont"> Returns a pointer to an <see cref="SlimDX2.Direct3D9.Font"/> interface, representing the created font object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateFontA([None] LPDIRECT3DDEVICE9 pDevice,[None] INT Height,[None] UINT Width,[None] UINT Weight,[None] UINT MipLevels,[None] BOOL Italic,[None] int CharSet,[None] int OutputPrecision,[None] int Quality,[None] int PitchAndFamily,[None] const char* pFaceName,[None] LPD3DXFONT* ppFont)</unmanaged>
		public static SlimDX2.Result CreateFontA(SlimDX2.Direct3D9.Device pDevice, int height, int width, int weight, int mipLevels, bool italic, int charSet, int outputPrecision, int quality, int pitchAndFamily, string pFaceName, out SlimDX2.Direct3D9.Font ppFont) {
            unsafe {
                IntPtr ppFont_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateFontA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  height,  width,  weight,  mipLevels,  italic,  charSet,  outputPrecision,  quality,  pitchAndFamily,  pFaceName, out ppFont_);
                ppFont = (ppFont_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Font(ppFont_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateFontA([None] LPDIRECT3DDEVICE9 pDevice,[None] INT Height,[None] UINT Width,[None] UINT Weight,[None] UINT MipLevels,[None] BOOL Italic,[None] int CharSet,[None] int OutputPrecision,[None] int Quality,[None] int PitchAndFamily,[None] const char* pFaceName,[None] LPD3DXFONT* ppFont)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateFontA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateFontA_(IntPtr pDevice, int height, int width, int weight, int mipLevels, bool italic, int charSet, int outputPrecision, int quality, int pitchAndFamily, [MarshalAs(UnmanagedType.LPStr),In] string pFaceName, out IntPtr ppFont);		
        
        /// <summary>	
        /// Creates a font object for a device and font.	
        /// </summary>	
        /// <remarks>	
        ///  The creation of an ID3DXFont object requires that the device supports 32-bit color. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateFontW. Otherwise, the function call resolves to D3DXCreateFontA because ANSI strings are being used. If you want more information about font parameters, see {{The Logical Font}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device to be associated with the font object. </param>
        /// <param name="height"> The height of the characters in logical units. </param>
        /// <param name="width"> The width of the characters in logical units. </param>
        /// <param name="weight"> Typeface weight. One example is bold. </param>
        /// <param name="mipLevels"> The number of mipmap levels. </param>
        /// <param name="italic"> True for italic font, false otherwise. </param>
        /// <param name="charSet"> The character set of the font. </param>
        /// <param name="outputPrecision"> Specifies how Windows should attempt to match the desired font sizes and characteristics with actual fonts. Use OUT_TT_ONLY_PRECIS for instance, to ensure that you always get a TrueType font. </param>
        /// <param name="quality"> Specifies how Windows should match the desired font with a real font. It applies to raster fonts only and should not affect TrueType fonts. </param>
        /// <param name="pitchAndFamily"> Pitch and family index. </param>
        /// <param name="pFaceName"> String containing the typeface name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.  </param>
        /// <param name="ppFont"> Returns a pointer to an <see cref="SlimDX2.Direct3D9.Font"/> interface, representing the created font object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateFontW([None] LPDIRECT3DDEVICE9 pDevice,[None] INT Height,[None] UINT Width,[None] UINT Weight,[None] UINT MipLevels,[None] BOOL Italic,[None] int CharSet,[None] int OutputPrecision,[None] int Quality,[None] int PitchAndFamily,[None] const wchar* pFaceName,[None] LPD3DXFONT* ppFont)</unmanaged>
		public static SlimDX2.Result CreateFontW(SlimDX2.Direct3D9.Device pDevice, int height, int width, int weight, int mipLevels, bool italic, int charSet, int outputPrecision, int quality, int pitchAndFamily, string pFaceName, out SlimDX2.Direct3D9.Font ppFont) {
            unsafe {
                IntPtr ppFont_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateFontW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  height,  width,  weight,  mipLevels,  italic,  charSet,  outputPrecision,  quality,  pitchAndFamily,  pFaceName, out ppFont_);
                ppFont = (ppFont_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Font(ppFont_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateFontW([None] LPDIRECT3DDEVICE9 pDevice,[None] INT Height,[None] UINT Width,[None] UINT Weight,[None] UINT MipLevels,[None] BOOL Italic,[None] int CharSet,[None] int OutputPrecision,[None] int Quality,[None] int PitchAndFamily,[None] const wchar* pFaceName,[None] LPD3DXFONT* ppFont)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateFontW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateFontW_(IntPtr pDevice, int height, int width, int weight, int mipLevels, bool italic, int charSet, int outputPrecision, int quality, int pitchAndFamily, [MarshalAs(UnmanagedType.LPWStr),In] string pFaceName, out IntPtr ppFont);		
        
        /// <summary>	
        /// Creates a font object indirectly for both a device and a font.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateFontIndirectW. Otherwise, the function call resolves to D3DXCreateFontIndirectA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device to be associated with the font object. </param>
        /// <param name="pDesc"> Pointer to a <see cref="SlimDX2.Direct3D9.FontDesca"/> structure, describing the attributes of the font object to create. If the compiler settings require Unicode, the data type D3DXFONT_DESC resolves to D3DXFONT_DESCW; otherwise, the data type resolves to D3DXFONT_DESCA. See Remarks. </param>
        /// <param name="ppFont"> Returns a pointer to an <see cref="SlimDX2.Direct3D9.Font"/> interface, representing the created font object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateFontIndirectA([None] LPDIRECT3DDEVICE9 pDevice,[None] const D3DXFONT_DESCA* pDesc,[None] LPD3DXFONT* ppFont)</unmanaged>
		public static SlimDX2.Result CreateFontIndirectA(SlimDX2.Direct3D9.Device pDevice, ref SlimDX2.Direct3D9.FontDesca pDesc, out SlimDX2.Direct3D9.Font ppFont) {
            unsafe {
                SlimDX2.Direct3D9.FontDesca.__Native pDesc_ = new SlimDX2.Direct3D9.FontDesca.__Native();
                pDesc.__MarshalTo(ref pDesc_);
                IntPtr ppFont_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateFontIndirectA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer, ref  pDesc_, out ppFont_);
                ppFont = (ppFont_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Font(ppFont_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateFontIndirectA([None] LPDIRECT3DDEVICE9 pDevice,[None] const D3DXFONT_DESCA* pDesc,[None] LPD3DXFONT* ppFont)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateFontIndirectA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateFontIndirectA_(IntPtr pDevice, ref SlimDX2.Direct3D9.FontDesca.__Native pDesc, out IntPtr ppFont);		
        
        /// <summary>	
        /// Creates a font object indirectly for both a device and a font.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateFontIndirectW. Otherwise, the function call resolves to D3DXCreateFontIndirectA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device to be associated with the font object. </param>
        /// <param name="pDesc"> Pointer to a <see cref="SlimDX2.Direct3D9.FontDesca"/> structure, describing the attributes of the font object to create. If the compiler settings require Unicode, the data type D3DXFONT_DESC resolves to D3DXFONT_DESCW; otherwise, the data type resolves to D3DXFONT_DESCA. See Remarks. </param>
        /// <param name="ppFont"> Returns a pointer to an <see cref="SlimDX2.Direct3D9.Font"/> interface, representing the created font object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateFontIndirectW([None] LPDIRECT3DDEVICE9 pDevice,[None] const D3DXFONT_DESCW* pDesc,[None] LPD3DXFONT* ppFont)</unmanaged>
		public static SlimDX2.Result CreateFontIndirectW(SlimDX2.Direct3D9.Device pDevice, ref SlimDX2.Direct3D9.FontDescw pDesc, out SlimDX2.Direct3D9.Font ppFont) {
            unsafe {
                SlimDX2.Direct3D9.FontDescw.__Native pDesc_ = new SlimDX2.Direct3D9.FontDescw.__Native();
                pDesc.__MarshalTo(ref pDesc_);
                IntPtr ppFont_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateFontIndirectW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer, ref  pDesc_, out ppFont_);
                ppFont = (ppFont_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Font(ppFont_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateFontIndirectW([None] LPDIRECT3DDEVICE9 pDevice,[None] const D3DXFONT_DESCW* pDesc,[None] LPD3DXFONT* ppFont)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateFontIndirectW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateFontIndirectW_(IntPtr pDevice, ref SlimDX2.Direct3D9.FontDescw.__Native pDesc, out IntPtr ppFont);		
        
        /// <summary>	
        /// Creates a render surface.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device to be associated with the render surface. </param>
        /// <param name="width"> Width of the render surface, in pixels. </param>
        /// <param name="height"> Height of the render surface, in pixels. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the pixel format of the render surface. </param>
        /// <param name="depthStencil"> If TRUE, the render surface supports a depth-stencil surface. Otherwise, this member is set to FALSE. This function will create a new depth buffer. </param>
        /// <param name="depthStencilFormat"> If  DepthStencil is set to TRUE, this parameter is a member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the depth-stencil format of the render surface. </param>
        /// <param name="ppRenderToSurface"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.RenderToSurface"/> interface, representing the created render surface. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateRenderToSurface([None] LPDIRECT3DDEVICE9 pDevice,[None] UINT Width,[None] UINT Height,[None] D3DFORMAT Format,[None] BOOL DepthStencil,[None] D3DFORMAT DepthStencilFormat,[None] LPD3DXRENDERTOSURFACE* ppRenderToSurface)</unmanaged>
		public static SlimDX2.Result CreateRenderToSurface(SlimDX2.Direct3D9.Device pDevice, int width, int height, SlimDX2.Direct3D9.Format format, bool depthStencil, SlimDX2.Direct3D9.Format depthStencilFormat, out SlimDX2.Direct3D9.RenderToSurface ppRenderToSurface) {
            unsafe {
                IntPtr ppRenderToSurface_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateRenderToSurface_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  width,  height,  format,  depthStencil,  depthStencilFormat, out ppRenderToSurface_);
                ppRenderToSurface = (ppRenderToSurface_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.RenderToSurface(ppRenderToSurface_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateRenderToSurface([None] LPDIRECT3DDEVICE9 pDevice,[None] UINT Width,[None] UINT Height,[None] D3DFORMAT Format,[None] BOOL DepthStencil,[None] D3DFORMAT DepthStencilFormat,[None] LPD3DXRENDERTOSURFACE* ppRenderToSurface)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateRenderToSurface", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateRenderToSurface_(IntPtr pDevice, int width, int height, SlimDX2.Direct3D9.Format format, bool depthStencil, SlimDX2.Direct3D9.Format depthStencilFormat, out IntPtr ppRenderToSurface);		
        
        /// <summary>	
        /// Creates a render environment map.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, which is the device to associate with the render surface. </param>
        /// <param name="size"> Size of the render surface. </param>
        /// <param name="mipLevels"> The number of mipmap levels. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type that describes the pixel format of the environment map. </param>
        /// <param name="depthStencil"> If TRUE, the render surface supports a depth-stencil surface. Otherwise, this member is set to FALSE. </param>
        /// <param name="depthStencilFormat"> If DepthStencil is set to TRUE, this parameter is a member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type that describes the depth-stencil format of the environment map. </param>
        /// <param name="ppRenderToEnvMap"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.RenderToEnvMap"/> interface that represents the created render environment map. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateRenderToEnvMap([None] LPDIRECT3DDEVICE9 pDevice,[None] UINT Size,[None] UINT MipLevels,[None] D3DFORMAT Format,[None] BOOL DepthStencil,[None] D3DFORMAT DepthStencilFormat,[None] LPD3DXRenderToEnvMap* ppRenderToEnvMap)</unmanaged>
		public static SlimDX2.Result CreateRenderToEnvMap(SlimDX2.Direct3D9.Device pDevice, int size, int mipLevels, SlimDX2.Direct3D9.Format format, bool depthStencil, SlimDX2.Direct3D9.Format depthStencilFormat, out SlimDX2.Direct3D9.RenderToEnvMap ppRenderToEnvMap) {
            unsafe {
                IntPtr ppRenderToEnvMap_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateRenderToEnvMap_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  size,  mipLevels,  format,  depthStencil,  depthStencilFormat, out ppRenderToEnvMap_);
                ppRenderToEnvMap = (ppRenderToEnvMap_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.RenderToEnvMap(ppRenderToEnvMap_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateRenderToEnvMap([None] LPDIRECT3DDEVICE9 pDevice,[None] UINT Size,[None] UINT MipLevels,[None] D3DFORMAT Format,[None] BOOL DepthStencil,[None] D3DFORMAT DepthStencilFormat,[None] LPD3DXRenderToEnvMap* ppRenderToEnvMap)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateRenderToEnvMap", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateRenderToEnvMap_(IntPtr pDevice, int size, int mipLevels, SlimDX2.Direct3D9.Format format, bool depthStencil, SlimDX2.Direct3D9.Format depthStencilFormat, out IntPtr ppRenderToEnvMap);		
        
        /// <summary>	
        /// Uses a left-handed coordinate system to create a line.	
        /// </summary>	
        /// <remarks>	
        ///  This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} Flexible Vertex Format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the created box mesh. </param>
        /// <param name="ppLine"> Pointer to an <see cref="SlimDX2.Direct3D9.Line"/> interface. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateLine([None] LPDIRECT3DDEVICE9 pDevice,[None] LPD3DXLINE* ppLine)</unmanaged>
		public static SlimDX2.Result CreateLine(SlimDX2.Direct3D9.Device pDevice, out SlimDX2.Direct3D9.Line ppLine) {
            unsafe {
                IntPtr ppLine_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateLine_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer, out ppLine_);
                ppLine = (ppLine_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Line(ppLine_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateLine([None] LPDIRECT3DDEVICE9 pDevice,[None] LPD3DXLINE* ppLine)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateLine", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateLine_(IntPtr pDevice, out IntPtr ppLine);		
        
        /// <summary>	
        /// Creates an instance of an <see cref="SlimDX2.Direct3D9.File"/> object.	
        /// </summary>	
        /// <remarks>	
        ///  After using this function, use {{RegisterTemplates}} or {{RegisterEnumTemplates}} to register  templates, {{CreateEnumObject}} to create an enumerator object, or {{CreateSaveObject}} to create a save object. 	
        /// </remarks>	
        /// <param name="lplpDirectXFile"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.File"/> interface, representing the created .x file object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following: E_POINTER, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXFileCreate([None] ID3DXFile** lplpDirectXFile)</unmanaged>
		public static SlimDX2.Result FileCreate(out SlimDX2.Direct3D9.File lplpDirectXFile) {
            unsafe {
                IntPtr lplpDirectXFile_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFileCreate_(out lplpDirectXFile_);
                lplpDirectXFile = (lplpDirectXFile_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.File(lplpDirectXFile_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFileCreate([None] ID3DXFile** lplpDirectXFile)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFileCreate", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFileCreate_(out IntPtr lplpDirectXFile);		
        
        /// <summary>	
        /// Creates a mesh object using a declarator.	
        /// </summary>	
        /// <param name="numFaces"> Number of faces for the mesh. The valid range for this number is greater than 0, and one less than the maximum DWORD (typically 65534), because the last index is reserved. </param>
        /// <param name="numVertices"> Number of vertices for the mesh. This parameter must be greater than 0. </param>
        /// <param name="options"> Combination of one or more flags from the  {{D3DXMESH}} enumeration, specifying options for the mesh.  </param>
        /// <param name="pDeclaration"> Array of <see cref="SlimDX2.Direct3D9.Vertexelement9"/> elements, describing the vertex format for the returned mesh. This parameter must map directly to a flexible vertex format (FVF). </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device object to be associated with the mesh. </param>
        /// <param name="ppMesh"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the created mesh object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateMesh([None] int NumFaces,[None] int NumVertices,[None] int Options,[None] const D3DVERTEXELEMENT9* pDeclaration,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result CreateMesh(int numFaces, int numVertices, int options, ref SlimDX2.Direct3D9.Vertexelement9 pDeclaration, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.Mesh ppMesh) {
            unsafe {
                IntPtr ppMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateMesh_( numFaces,  numVertices,  options, ref  pDeclaration, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out ppMesh_);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateMesh([None] int NumFaces,[None] int NumVertices,[None] int Options,[None] const D3DVERTEXELEMENT9* pDeclaration,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateMesh_(int numFaces, int numVertices, int options, ref SlimDX2.Direct3D9.Vertexelement9 pDeclaration, IntPtr pD3DDevice, out IntPtr ppMesh);		
        
        /// <summary>	
        /// Creates a mesh object using a flexible vertex format (FVF) code.	
        /// </summary>	
        /// <param name="numFaces"> Number of faces for the mesh. The valid range for this number is greater than 0, and one less than the max DWORD value, typically 232 - 1, because the last index is reserved. </param>
        /// <param name="numVertices"> Number of vertices for the mesh. This parameter must be greater than 0. </param>
        /// <param name="options"> Combination of one or more flags from the  {{D3DXMESH}} enumeration, specifying creation options for the mesh.  </param>
        /// <param name="fvf"> Combination of {{D3DFVF}} that describes the vertex format for the returned mesh. This function does not support D3DFVF_XYZRHW. </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device object to be associated with the mesh. </param>
        /// <param name="ppMesh"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the created mesh object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateMeshFVF([None] int NumFaces,[None] int NumVertices,[None] int Options,[None] int FVF,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result CreateMeshFVF(int numFaces, int numVertices, int options, int fvf, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.Mesh ppMesh) {
            unsafe {
                IntPtr ppMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateMeshFVF_( numFaces,  numVertices,  options,  fvf, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out ppMesh_);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateMeshFVF([None] int NumFaces,[None] int NumVertices,[None] int Options,[None] int FVF,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateMeshFVF", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateMeshFVF_(int numFaces, int numVertices, int options, int fvf, IntPtr pD3DDevice, out IntPtr ppMesh);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="pMesh">No documentation.</param>
        /// <param name="pAdjacency">No documentation.</param>
        /// <param name="pVertexAttributeWeights">No documentation.</param>
        /// <param name="pVertexWeights">No documentation.</param>
        /// <param name="ppSMesh">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXCreateSPMesh([None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,[None] const FLOAT* pVertexWeights,[None] LPD3DXSPMESH* ppSMesh)</unmanaged>
		public static SlimDX2.Result CreateSPMesh(SlimDX2.Direct3D9.Mesh pMesh, ref int pAdjacency, ref SlimDX2.Direct3D9.Attributeweights pVertexAttributeWeights, ref float pVertexWeights, out SlimDX2.Direct3D9.SPMesh ppSMesh) {
            unsafe {
                SlimDX2.Direct3D9.Attributeweights.__Native pVertexAttributeWeights_ = new SlimDX2.Direct3D9.Attributeweights.__Native();
                pVertexAttributeWeights.__MarshalTo(ref pVertexAttributeWeights_);
                IntPtr ppSMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateSPMesh_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  pAdjacency, ref  pVertexAttributeWeights_, ref  pVertexWeights, out ppSMesh_);
                ppSMesh = (ppSMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.SPMesh(ppSMesh_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateSPMesh([None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,[None] const FLOAT* pVertexWeights,[None] LPD3DXSPMESH* ppSMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSPMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateSPMesh_(IntPtr pMesh, ref int pAdjacency, ref SlimDX2.Direct3D9.Attributeweights.__Native pVertexAttributeWeights, ref float pVertexWeights, out IntPtr ppSMesh);		
        
        /// <summary>	
        /// Cleans a mesh, preparing it for simplification.	
        /// </summary>	
        /// <remarks>	
        ///  This function cleans a mesh using the cleaning method and options specified in the CleanType parameter. See the <see cref="SlimDX2.Direct3D9.Cleantype"/> enumeration for a description of the available options. 	
        /// </remarks>	
        /// <param name="cleanType"> Vertex operations to perform in preparation for mesh cleaning. See <see cref="SlimDX2.Direct3D9.Cleantype"/>. </param>
        /// <param name="pMeshIn"> Pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the mesh to be cleaned. </param>
        /// <param name="pAdjacencyIn"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh to be cleaned. </param>
        /// <param name="ppMeshOut"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the returned cleaned mesh. The same mesh is returned that was passed in if no cleaning was necessary. </param>
        /// <param name="pAdjacencyOut"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the output mesh. </param>
        /// <param name="ppErrorsAndWarnings"> Returns a buffer containing a string of errors and warnings, which explain the problems found in the mesh. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCleanMesh([None] D3DXCLEANTYPE CleanType,[None] LPD3DXMESH pMeshIn,[None] const int* pAdjacencyIn,[None] LPD3DXMESH* ppMeshOut,[None] int* pAdjacencyOut,[None] LPD3DXBUFFER* ppErrorsAndWarnings)</unmanaged>
		public static SlimDX2.Result CleanMesh(SlimDX2.Direct3D9.Cleantype cleanType, SlimDX2.Direct3D9.Mesh pMeshIn, ref int pAdjacencyIn, out SlimDX2.Direct3D9.Mesh ppMeshOut, ref int pAdjacencyOut, out SlimDX2.Direct3D9.Buffer ppErrorsAndWarnings) {
            unsafe {
                IntPtr ppMeshOut_ = IntPtr.Zero;
                IntPtr ppErrorsAndWarnings_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCleanMesh_( cleanType, (pMeshIn == null)?IntPtr.Zero:pMeshIn.NativePointer, ref  pAdjacencyIn, out ppMeshOut_, ref  pAdjacencyOut, out ppErrorsAndWarnings_);
                ppMeshOut = (ppMeshOut_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMeshOut_);
                ppErrorsAndWarnings = (ppErrorsAndWarnings_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorsAndWarnings_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCleanMesh([None] D3DXCLEANTYPE CleanType,[None] LPD3DXMESH pMeshIn,[None] const int* pAdjacencyIn,[None] LPD3DXMESH* ppMeshOut,[None] int* pAdjacencyOut,[None] LPD3DXBUFFER* ppErrorsAndWarnings)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCleanMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCleanMesh_(SlimDX2.Direct3D9.Cleantype cleanType, IntPtr pMeshIn, ref int pAdjacencyIn, out IntPtr ppMeshOut, ref int pAdjacencyOut, out IntPtr ppErrorsAndWarnings);		
        
        /// <summary>	
        /// Validates a mesh.	
        /// </summary>	
        /// <remarks>	
        ///  This method validates the mesh by checking for invalid indices. Error information is available from the debugger output. 	
        /// </remarks>	
        /// <param name="pMeshIn"> Pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the mesh to be tested. </param>
        /// <param name="pAdjacency"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh to be tested. </param>
        /// <param name="ppErrorsAndWarnings"> Returns a buffer containing a string of errors and warnings, which explain the problems found in the mesh. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DXERR_INVALIDMESH, D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXValidMesh([None] LPD3DXMESH pMeshIn,[None] const int* pAdjacency,[None] LPD3DXBUFFER* ppErrorsAndWarnings)</unmanaged>
		public static SlimDX2.Result ValidMesh(SlimDX2.Direct3D9.Mesh pMeshIn, ref int pAdjacency, out SlimDX2.Direct3D9.Buffer ppErrorsAndWarnings) {
            unsafe {
                IntPtr ppErrorsAndWarnings_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXValidMesh_((pMeshIn == null)?IntPtr.Zero:pMeshIn.NativePointer, ref  pAdjacency, out ppErrorsAndWarnings_);
                ppErrorsAndWarnings = (ppErrorsAndWarnings_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorsAndWarnings_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXValidMesh([None] LPD3DXMESH pMeshIn,[None] const int* pAdjacency,[None] LPD3DXBUFFER* ppErrorsAndWarnings)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXValidMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXValidMesh_(IntPtr pMeshIn, ref int pAdjacency, out IntPtr ppErrorsAndWarnings);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="pMesh">No documentation.</param>
        /// <param name="pAdjacency">No documentation.</param>
        /// <param name="pVertexAttributeWeights">No documentation.</param>
        /// <param name="pVertexWeights">No documentation.</param>
        /// <param name="minValue">No documentation.</param>
        /// <param name="options">No documentation.</param>
        /// <param name="ppPMesh">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXGeneratePMesh([None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,[None] const FLOAT* pVertexWeights,[None] int MinValue,[None] int Options,[None] LPD3DXPMESH* ppPMesh)</unmanaged>
		public static SlimDX2.Result GeneratePMesh(SlimDX2.Direct3D9.Mesh pMesh, ref int pAdjacency, ref SlimDX2.Direct3D9.Attributeweights pVertexAttributeWeights, ref float pVertexWeights, int minValue, int options, out SlimDX2.Direct3D9.PMesh ppPMesh) {
            unsafe {
                SlimDX2.Direct3D9.Attributeweights.__Native pVertexAttributeWeights_ = new SlimDX2.Direct3D9.Attributeweights.__Native();
                pVertexAttributeWeights.__MarshalTo(ref pVertexAttributeWeights_);
                IntPtr ppPMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGeneratePMesh_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  pAdjacency, ref  pVertexAttributeWeights_, ref  pVertexWeights,  minValue,  options, out ppPMesh_);
                ppPMesh = (ppPMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PMesh(ppPMesh_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGeneratePMesh([None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,[None] const FLOAT* pVertexWeights,[None] int MinValue,[None] int Options,[None] LPD3DXPMESH* ppPMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGeneratePMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGeneratePMesh_(IntPtr pMesh, ref int pAdjacency, ref SlimDX2.Direct3D9.Attributeweights.__Native pVertexAttributeWeights, ref float pVertexWeights, int minValue, int options, out IntPtr ppPMesh);		
        
        /// <summary>	
        /// Generates a simplified mesh using the provided weights that come as close as possible to the given MinValue.	
        /// </summary>	
        /// <remarks>	
        ///  This function generates a mesh that has MinValue vertices or faces. If the simplification process cannot reduce the mesh to MinValue, the call still succeeds because MinValue is a desired minimum, not an absolute minimum. If pVertexAttributeWeights is set to NULL, the following values are assigned to the default <see cref="SlimDX2.Direct3D9.Attributeweights"/> structure. 	
        /// <code> D3DXATTRIBUTEWEIGHTS AttributeWeights; AttributeWeights.Position  = 1.0;	
        /// AttributeWeights.Boundary =  1.0;	
        /// AttributeWeights.Normal   =  1.0;	
        /// AttributeWeights.Diffuse  =  0.0;	
        /// AttributeWeights.Specular =  0.0;	
        /// AttributeWeights.Tex[8]   =  {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}; </code>	
        /// 	
        ///  This default structure is what most applications should use because it considers only geometric and normal adjustment. Only in special cases will the other member fields need to be modified.  	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the source mesh. </param>
        /// <param name="pAdjacency"> Pointer to an array of three  DWORDs per face that specify the three neighbors for each face in the mesh to be simplified. </param>
        /// <param name="pVertexAttributeWeights"> Pointer to a <see cref="SlimDX2.Direct3D9.Attributeweights"/> structure, containing the weight for each vertex component. If this parameter is set to NULL, a default structure is used. See Remarks. </param>
        /// <param name="pVertexWeights"> Pointer to an array of vertex weights. If this parameter is set to NULL, all vertex weights are set to 1.0. </param>
        /// <param name="minValue"> Number of vertices or faces, depending on the flag set in the  Options parameter, by which to simplify the source mesh. </param>
        /// <param name="options"> Specifies simplification options for the mesh. One of the flags in {{D3DXMESHSIMP}} can be set. </param>
        /// <param name="ppMesh"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the returned simplification mesh. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXSimplifyMesh([None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,[None] const FLOAT* pVertexWeights,[None] int MinValue,[None] int Options,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result SimplifyMesh(SlimDX2.Direct3D9.Mesh pMesh, ref int pAdjacency, ref SlimDX2.Direct3D9.Attributeweights pVertexAttributeWeights, ref float pVertexWeights, int minValue, int options, out SlimDX2.Direct3D9.Mesh ppMesh) {
            unsafe {
                SlimDX2.Direct3D9.Attributeweights.__Native pVertexAttributeWeights_ = new SlimDX2.Direct3D9.Attributeweights.__Native();
                pVertexAttributeWeights.__MarshalTo(ref pVertexAttributeWeights_);
                IntPtr ppMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSimplifyMesh_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  pAdjacency, ref  pVertexAttributeWeights_, ref  pVertexWeights,  minValue,  options, out ppMesh_);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSimplifyMesh([None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,[None] const FLOAT* pVertexWeights,[None] int MinValue,[None] int Options,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSimplifyMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSimplifyMesh_(IntPtr pMesh, ref int pAdjacency, ref SlimDX2.Direct3D9.Attributeweights.__Native pVertexAttributeWeights, ref float pVertexWeights, int minValue, int options, out IntPtr ppMesh);		
        
        /// <summary>	
        /// Computes a bounding sphere for the mesh.	
        /// </summary>	
        /// <param name="pFirstPosition"> Pointer to first position. </param>
        /// <param name="numVertices"> Number of vertices. </param>
        /// <param name="dwStride"> Number of bytes between position vectors.  Use {{GetNumBytesPerVertex}}, <see cref="SlimDX2.Direct3D9.D3DX9.GetFVFVertexSize"/>, or <see cref="SlimDX2.Direct3D9.D3DX9.GetDeclVertexSize"/> to get the vertex stride. </param>
        /// <param name="pCenter">  <see cref="SlimMath.Vector3"/> structure, defining the coordinate center of the returned bounding sphere. </param>
        /// <param name="pRadius"> Radius of the returned bounding sphere. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXComputeBoundingSphere([None] const D3DXVECTOR3* pFirstPosition,[None] int NumVertices,[None] int dwStride,[None] D3DXVECTOR3* pCenter,[None] FLOAT* pRadius)</unmanaged>
		public static SlimDX2.Result ComputeBoundingSphere(ref SlimMath.Vector3 pFirstPosition, int numVertices, int dwStride, ref SlimMath.Vector3 pCenter, ref float pRadius) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeBoundingSphere_(ref  pFirstPosition,  numVertices,  dwStride, ref  pCenter, ref  pRadius);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeBoundingSphere([None] const D3DXVECTOR3* pFirstPosition,[None] int NumVertices,[None] int dwStride,[None] D3DXVECTOR3* pCenter,[None] FLOAT* pRadius)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeBoundingSphere", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeBoundingSphere_(ref SlimMath.Vector3 pFirstPosition, int numVertices, int dwStride, ref SlimMath.Vector3 pCenter, ref float pRadius);		
        
        /// <summary>	
        /// Computes a coordinate-axis oriented bounding box.	
        /// </summary>	
        /// <remarks>	
        ///  	
        /// </remarks>	
        /// <param name="pFirstPosition"> Pointer to the first position. </param>
        /// <param name="numVertices"> Number of vertices. </param>
        /// <param name="dwStride"> Count or number of bytes between vertices. </param>
        /// <param name="pMin"> Pointer to a <see cref="SlimMath.Vector3"/> structure, describing the returned lower-left corner of the bounding box. See Remarks. </param>
        /// <param name="pMax"> Pointer to a  <see cref="SlimMath.Vector3"/> structure, describing the returned upper-right corner of the bounding box. See Remarks. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXComputeBoundingBox([None] const D3DXVECTOR3* pFirstPosition,[None] int NumVertices,[None] int dwStride,[None] D3DXVECTOR3* pMin,[None] D3DXVECTOR3* pMax)</unmanaged>
		public static SlimDX2.Result ComputeBoundingBox(ref SlimMath.Vector3 pFirstPosition, int numVertices, int dwStride, ref SlimMath.Vector3 pMin, ref SlimMath.Vector3 pMax) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeBoundingBox_(ref  pFirstPosition,  numVertices,  dwStride, ref  pMin, ref  pMax);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeBoundingBox([None] const D3DXVECTOR3* pFirstPosition,[None] int NumVertices,[None] int dwStride,[None] D3DXVECTOR3* pMin,[None] D3DXVECTOR3* pMax)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeBoundingBox", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeBoundingBox_(ref SlimMath.Vector3 pFirstPosition, int numVertices, int dwStride, ref SlimMath.Vector3 pMin, ref SlimMath.Vector3 pMax);		
        
        /// <summary>	
        /// Computes unit normals for each vertex in a mesh. Provided to support legacy applications. Use <see cref="SlimDX2.Direct3D9.D3DX9.ComputeTangentFrameEx"/> for better results.	
        /// </summary>	
        /// <remarks>	
        ///  The input mesh must have the {{D3DFVF_NORMAL}} flag specified in its flexible vertex format (FVF). A normal for a vertex is generated by averaging the normals of all faces that share that vertex. If adjacency is provided, replicated vertices are ignored and "smoothed" over. If adjacency is not provided, replicated vertices will have normals averaged in from only the faces explicitly referencing them. This function simply calls <see cref="SlimDX2.Direct3D9.D3DX9.ComputeTangentFrameEx"/> with the following input parameters: 	
        /// <code> D3DXComputeTangentFrameEx( pMesh, D3DX_DEFAULT, 0, D3DX_DEFAULT, 0, D3DX_DEFAULT, 0, D3DDECLUSAGE_NORMAL, 0, D3DXTANGENT_GENERATE_IN_PLACE | D3DXTANGENT_CALCULATE_NORMALS, pAdjacency, -1.01f, -0.01f, -1.01f, NULL, NULL); </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.BaseMesh"/> interface, representing the normalized mesh object. </param>
        /// <param name="pAdjacency"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the created progressive mesh. This parameter is optional and should be set to NULL if it is unused. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXComputeNormals([None] LPD3DXBASEMESH pMesh,[None] const int* pAdjacency)</unmanaged>
		public static SlimDX2.Result ComputeNormals(SlimDX2.Direct3D9.BaseMesh pMesh, ref int pAdjacency) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeNormals_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  pAdjacency);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeNormals([None] LPD3DXBASEMESH pMesh,[None] const int* pAdjacency)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeNormals", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeNormals_(IntPtr pMesh, ref int pAdjacency);		
        
        /// <summary>	
        /// Creates a buffer object.	
        /// </summary>	
        /// <param name="numBytes"> Size of the buffer to create, in bytes. </param>
        /// <param name="ppBuffer"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface, representing the created buffer object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateBuffer([None] int NumBytes,[None] LPD3DXBUFFER* ppBuffer)</unmanaged>
		public static SlimDX2.Result CreateBuffer(int numBytes, out SlimDX2.Direct3D9.Buffer ppBuffer) {
            unsafe {
                IntPtr ppBuffer_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateBuffer_( numBytes, out ppBuffer_);
                ppBuffer = (ppBuffer_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppBuffer_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateBuffer([None] int NumBytes,[None] LPD3DXBUFFER* ppBuffer)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateBuffer", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateBuffer_(int numBytes, out IntPtr ppBuffer);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="pFilename">No documentation.</param>
        /// <param name="options">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="ppAdjacency">No documentation.</param>
        /// <param name="ppMaterials">No documentation.</param>
        /// <param name="ppEffectInstances">No documentation.</param>
        /// <param name="pNumMaterials">No documentation.</param>
        /// <param name="ppMesh">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXA([None] const char* pFilename,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result LoadMeshFromXA(string pFilename, int options, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.Buffer ppAdjacency, out SlimDX2.Direct3D9.Buffer ppMaterials, out SlimDX2.Direct3D9.Buffer ppEffectInstances, ref int pNumMaterials, out SlimDX2.Direct3D9.Mesh ppMesh) {
            unsafe {
                IntPtr ppAdjacency_ = IntPtr.Zero;
                IntPtr ppMaterials_ = IntPtr.Zero;
                IntPtr ppEffectInstances_ = IntPtr.Zero;
                IntPtr ppMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadMeshFromXA_( pFilename,  options, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out ppAdjacency_, out ppMaterials_, out ppEffectInstances_, ref  pNumMaterials, out ppMesh_);
                ppAdjacency = (ppAdjacency_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAdjacency_);
                ppMaterials = (ppMaterials_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppMaterials_);
                ppEffectInstances = (ppEffectInstances_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppEffectInstances_);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXA([None] const char* pFilename,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshFromXA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadMeshFromXA_([MarshalAs(UnmanagedType.LPStr),In] string pFilename, int options, IntPtr pD3DDevice, out IntPtr ppAdjacency, out IntPtr ppMaterials, out IntPtr ppEffectInstances, ref int pNumMaterials, out IntPtr ppMesh);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="pFilename">No documentation.</param>
        /// <param name="options">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="ppAdjacency">No documentation.</param>
        /// <param name="ppMaterials">No documentation.</param>
        /// <param name="ppEffectInstances">No documentation.</param>
        /// <param name="pNumMaterials">No documentation.</param>
        /// <param name="ppMesh">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXW([None] const wchar* pFilename,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result LoadMeshFromXW(string pFilename, int options, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.Buffer ppAdjacency, out SlimDX2.Direct3D9.Buffer ppMaterials, out SlimDX2.Direct3D9.Buffer ppEffectInstances, ref int pNumMaterials, out SlimDX2.Direct3D9.Mesh ppMesh) {
            unsafe {
                IntPtr ppAdjacency_ = IntPtr.Zero;
                IntPtr ppMaterials_ = IntPtr.Zero;
                IntPtr ppEffectInstances_ = IntPtr.Zero;
                IntPtr ppMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadMeshFromXW_( pFilename,  options, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out ppAdjacency_, out ppMaterials_, out ppEffectInstances_, ref  pNumMaterials, out ppMesh_);
                ppAdjacency = (ppAdjacency_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAdjacency_);
                ppMaterials = (ppMaterials_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppMaterials_);
                ppEffectInstances = (ppEffectInstances_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppEffectInstances_);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXW([None] const wchar* pFilename,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshFromXW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadMeshFromXW_([MarshalAs(UnmanagedType.LPWStr),In] string pFilename, int options, IntPtr pD3DDevice, out IntPtr ppAdjacency, out IntPtr ppMaterials, out IntPtr ppEffectInstances, ref int pNumMaterials, out IntPtr ppMesh);		
        
        /// <summary>	
        /// Loads a mesh from memory.	
        /// </summary>	
        /// <remarks>	
        ///  All the meshes in the file will be collapsed into one output mesh. If the file contains a frame hierarchy, all the transformations will be applied to the mesh. For mesh files that do not contain effect instance information, default effect instances will be generated from the material information in the .x file. A default effect instance will have default values that correspond to the members of the <see cref="SlimDX2.Direct3D9.Material9"/> structure. The default texture name is also filled in, but is handled differently. The name will be Texture0@Name, which corresponds to an effect variable by the name of "Texture0" with an annotation called "Name." This will contain the string file name for the texture. 	
        /// </remarks>	
        /// <param name="memory"> Pointer to the memory buffer which contains the mesh data. </param>
        /// <param name="sizeOfMemory"> Size of the file in memory, in bytes. </param>
        /// <param name="options"> Combination of one or more flags from the {{D3DXMESH}} enumeration, specifying creation options for the mesh. </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device object associated with the mesh. </param>
        /// <param name="ppAdjacency"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. </param>
        /// <param name="ppMaterials"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface. When this method returns, this parameter is filled with an array of <see cref="SlimDX2.Direct3D9.Material"/> structures, containing information saved in the DirectX file. </param>
        /// <param name="ppEffectInstances"> Pointer to a buffer containing an array of effect instances, one per attribute group in the returned mesh. An effect instance is a particular instance of state information used to initialize an effect. See <see cref="SlimDX2.Direct3D9.Effectinstance"/>. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.Buffer"/>. </param>
        /// <param name="pNumMaterials"> Pointer to the number of <see cref="SlimDX2.Direct3D9.Material"/> structures in the ppMaterials array, when the method returns. </param>
        /// <param name="ppMesh"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the loaded mesh. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXInMemory([None] LPCVOID Memory,[None] int SizeOfMemory,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result LoadMeshFromXInMemory(IntPtr memory, int sizeOfMemory, int options, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.Buffer ppAdjacency, out SlimDX2.Direct3D9.Buffer ppMaterials, out SlimDX2.Direct3D9.Buffer ppEffectInstances, ref int pNumMaterials, out SlimDX2.Direct3D9.Mesh ppMesh) {
            unsafe {
                IntPtr ppAdjacency_ = IntPtr.Zero;
                IntPtr ppMaterials_ = IntPtr.Zero;
                IntPtr ppEffectInstances_ = IntPtr.Zero;
                IntPtr ppMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadMeshFromXInMemory_( memory,  sizeOfMemory,  options, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out ppAdjacency_, out ppMaterials_, out ppEffectInstances_, ref  pNumMaterials, out ppMesh_);
                ppAdjacency = (ppAdjacency_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAdjacency_);
                ppMaterials = (ppMaterials_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppMaterials_);
                ppEffectInstances = (ppEffectInstances_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppEffectInstances_);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXInMemory([None] LPCVOID Memory,[None] int SizeOfMemory,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshFromXInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadMeshFromXInMemory_(IntPtr memory, int sizeOfMemory, int options, IntPtr pD3DDevice, out IntPtr ppAdjacency, out IntPtr ppMaterials, out IntPtr ppEffectInstances, ref int pNumMaterials, out IntPtr ppMesh);		
        
        /// <summary>	
        /// Loads a mesh from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  See {{FindResource}} to find out more about the Module, Name and Type parameters. All the meshes in the file will be collapsed into one output mesh. If the file contains a frame hierarchy, all the transformations will be applied to the mesh. For mesh files that do not contain effect instance information, default effect instances will be generated from the material information in the .x file. A default effect instance will have default values that correspond to the members of the <see cref="SlimDX2.Direct3D9.Material9"/> structure. The default texture name is also filled in, but is handled differently. The name will be Texture0@Name, which corresponds to an effect variable by the name of "Texture0" with an annotation called "Name." This will contain the string file name for the texture. 	
        /// </remarks>	
        /// <param name="module"> Handle to the module where the resource is located, or NULL for the module associated with the image the operating system used to create the current process. See remarks. </param>
        /// <param name="name"> Pointer to a string that specifies the resource to create the mesh from. See remarks. </param>
        /// <param name="type"> Pointer to a string that specifies the resource type. See remarks. </param>
        /// <param name="options"> Combination of one or more flags from the {{D3DXMESH}} enumeration that specify creation options for the mesh. </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device object associated with the mesh. </param>
        /// <param name="ppAdjacency"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. </param>
        /// <param name="ppMaterials"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface. When this method returns, this parameter is filled with an array of <see cref="SlimDX2.Direct3D9.Material"/> structures, containing information saved in the DirectX file. </param>
        /// <param name="ppEffectInstances"> Pointer to a buffer containing an array of effect instances, one per attribute group in the returned mesh. An effect instance is a particular instance of state information used to initialize an effect. See <see cref="SlimDX2.Direct3D9.Effectinstance"/>. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.Buffer"/>. </param>
        /// <param name="pNumMaterials"> Pointer to the number of <see cref="SlimDX2.Direct3D9.Material"/> structures in the ppMaterials array, when the method returns. </param>
        /// <param name="ppMesh"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the loaded mesh. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXResource([None] HMODULE Module,[None] const char* Name,[None] const char* Type,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result LoadMeshFromXResource(IntPtr module, string name, string type, int options, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.Buffer ppAdjacency, out SlimDX2.Direct3D9.Buffer ppMaterials, out SlimDX2.Direct3D9.Buffer ppEffectInstances, ref int pNumMaterials, out SlimDX2.Direct3D9.Mesh ppMesh) {
            unsafe {
                IntPtr ppAdjacency_ = IntPtr.Zero;
                IntPtr ppMaterials_ = IntPtr.Zero;
                IntPtr ppEffectInstances_ = IntPtr.Zero;
                IntPtr ppMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadMeshFromXResource_( module,  name,  type,  options, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out ppAdjacency_, out ppMaterials_, out ppEffectInstances_, ref  pNumMaterials, out ppMesh_);
                ppAdjacency = (ppAdjacency_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAdjacency_);
                ppMaterials = (ppMaterials_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppMaterials_);
                ppEffectInstances = (ppEffectInstances_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppEffectInstances_);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXResource([None] HMODULE Module,[None] const char* Name,[None] const char* Type,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshFromXResource", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadMeshFromXResource_(IntPtr module, [MarshalAs(UnmanagedType.LPStr),In] string name, [MarshalAs(UnmanagedType.LPStr),In] string type, int options, IntPtr pD3DDevice, out IntPtr ppAdjacency, out IntPtr ppMaterials, out IntPtr ppEffectInstances, ref int pNumMaterials, out IntPtr ppMesh);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="pFilename">No documentation.</param>
        /// <param name="pMesh">No documentation.</param>
        /// <param name="pAdjacency">No documentation.</param>
        /// <param name="pMaterials">No documentation.</param>
        /// <param name="pEffectInstances">No documentation.</param>
        /// <param name="numMaterials">No documentation.</param>
        /// <param name="format">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXSaveMeshToXA([None] const char* pFilename,[None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXMATERIAL* pMaterials,[None] const D3DXEFFECTINSTANCE* pEffectInstances,[None] int NumMaterials,[None] int Format)</unmanaged>
		public static SlimDX2.Result SaveMeshToXA(string pFilename, SlimDX2.Direct3D9.Mesh pMesh, ref int pAdjacency, ref SlimDX2.Direct3D9.Material pMaterials, ref SlimDX2.Direct3D9.Effectinstance pEffectInstances, int numMaterials, int format) {
            unsafe {
                SlimDX2.Direct3D9.Material.__Native pMaterials_ = new SlimDX2.Direct3D9.Material.__Native();
                pMaterials.__MarshalTo(ref pMaterials_);
                SlimDX2.Direct3D9.Effectinstance.__Native pEffectInstances_ = new SlimDX2.Direct3D9.Effectinstance.__Native();
                pEffectInstances.__MarshalTo(ref pEffectInstances_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveMeshToXA_( pFilename, (pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  pAdjacency, ref  pMaterials_, ref  pEffectInstances_,  numMaterials,  format);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveMeshToXA([None] const char* pFilename,[None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXMATERIAL* pMaterials,[None] const D3DXEFFECTINSTANCE* pEffectInstances,[None] int NumMaterials,[None] int Format)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveMeshToXA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveMeshToXA_([MarshalAs(UnmanagedType.LPStr),In] string pFilename, IntPtr pMesh, ref int pAdjacency, ref SlimDX2.Direct3D9.Material.__Native pMaterials, ref SlimDX2.Direct3D9.Effectinstance.__Native pEffectInstances, int numMaterials, int format);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="pFilename">No documentation.</param>
        /// <param name="pMesh">No documentation.</param>
        /// <param name="pAdjacency">No documentation.</param>
        /// <param name="pMaterials">No documentation.</param>
        /// <param name="pEffectInstances">No documentation.</param>
        /// <param name="numMaterials">No documentation.</param>
        /// <param name="format">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXSaveMeshToXW([None] const wchar* pFilename,[None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXMATERIAL* pMaterials,[None] const D3DXEFFECTINSTANCE* pEffectInstances,[None] int NumMaterials,[None] int Format)</unmanaged>
		public static SlimDX2.Result SaveMeshToXW(string pFilename, SlimDX2.Direct3D9.Mesh pMesh, ref int pAdjacency, ref SlimDX2.Direct3D9.Material pMaterials, ref SlimDX2.Direct3D9.Effectinstance pEffectInstances, int numMaterials, int format) {
            unsafe {
                SlimDX2.Direct3D9.Material.__Native pMaterials_ = new SlimDX2.Direct3D9.Material.__Native();
                pMaterials.__MarshalTo(ref pMaterials_);
                SlimDX2.Direct3D9.Effectinstance.__Native pEffectInstances_ = new SlimDX2.Direct3D9.Effectinstance.__Native();
                pEffectInstances.__MarshalTo(ref pEffectInstances_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveMeshToXW_( pFilename, (pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  pAdjacency, ref  pMaterials_, ref  pEffectInstances_,  numMaterials,  format);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveMeshToXW([None] const wchar* pFilename,[None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXMATERIAL* pMaterials,[None] const D3DXEFFECTINSTANCE* pEffectInstances,[None] int NumMaterials,[None] int Format)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveMeshToXW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveMeshToXW_([MarshalAs(UnmanagedType.LPWStr),In] string pFilename, IntPtr pMesh, ref int pAdjacency, ref SlimDX2.Direct3D9.Material.__Native pMaterials, ref SlimDX2.Direct3D9.Effectinstance.__Native pEffectInstances, int numMaterials, int format);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="pStream">No documentation.</param>
        /// <param name="options">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="ppMaterials">No documentation.</param>
        /// <param name="ppEffectInstances">No documentation.</param>
        /// <param name="pNumMaterials">No documentation.</param>
        /// <param name="ppPMesh">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXCreatePMeshFromStream([None] void* pStream,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXPMESH* ppPMesh)</unmanaged>
		public static SlimDX2.Result CreatePMeshFromStream(IntPtr pStream, int options, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.Buffer ppMaterials, out SlimDX2.Direct3D9.Buffer ppEffectInstances, ref int pNumMaterials, out SlimDX2.Direct3D9.PMesh ppPMesh) {
            unsafe {
                IntPtr ppMaterials_ = IntPtr.Zero;
                IntPtr ppEffectInstances_ = IntPtr.Zero;
                IntPtr ppPMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreatePMeshFromStream_( pStream,  options, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out ppMaterials_, out ppEffectInstances_, ref  pNumMaterials, out ppPMesh_);
                ppMaterials = (ppMaterials_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppMaterials_);
                ppEffectInstances = (ppEffectInstances_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppEffectInstances_);
                ppPMesh = (ppPMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PMesh(ppPMesh_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreatePMeshFromStream([None] void* pStream,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXPMESH* ppPMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreatePMeshFromStream", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreatePMeshFromStream_(IntPtr pStream, int options, IntPtr pD3DDevice, out IntPtr ppMaterials, out IntPtr ppEffectInstances, ref int pNumMaterials, out IntPtr ppPMesh);		
        
        /// <summary>	
        /// Creates an empty skin mesh object using a declarator.	
        /// </summary>	
        /// <remarks>	
        ///  Use {{SetBoneInfluence}} to populate the empty skin mesh object returned by this method. 	
        /// </remarks>	
        /// <param name="numVertices"> Number of vertices for the skin mesh. </param>
        /// <param name="pDeclaration"> Array of <see cref="SlimDX2.Direct3D9.Vertexelement9"/> elements, describing the vertex format for the returned mesh. </param>
        /// <param name="numBones"> Number of bones for the skin mesh. </param>
        /// <param name="ppSkinInfo"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.SkinInfo"/> interface, representing the created skin mesh object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be: E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateSkinInfo([None] int NumVertices,[None] const D3DVERTEXELEMENT9* pDeclaration,[None] int NumBones,[None] LPD3DXSKININFO* ppSkinInfo)</unmanaged>
		public static SlimDX2.Result CreateSkinInfo(int numVertices, ref SlimDX2.Direct3D9.Vertexelement9 pDeclaration, int numBones, out SlimDX2.Direct3D9.SkinInfo ppSkinInfo) {
            unsafe {
                IntPtr ppSkinInfo_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateSkinInfo_( numVertices, ref  pDeclaration,  numBones, out ppSkinInfo_);
                ppSkinInfo = (ppSkinInfo_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.SkinInfo(ppSkinInfo_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateSkinInfo([None] int NumVertices,[None] const D3DVERTEXELEMENT9* pDeclaration,[None] int NumBones,[None] LPD3DXSKININFO* ppSkinInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSkinInfo", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateSkinInfo_(int numVertices, ref SlimDX2.Direct3D9.Vertexelement9 pDeclaration, int numBones, out IntPtr ppSkinInfo);		
        
        /// <summary>	
        /// Creates an empty skin mesh object using a flexible vertex format (FVF) code.	
        /// </summary>	
        /// <remarks>	
        ///  Use {{SetBoneInfluence}} to populate the empty skin mesh object returned by this method. 	
        /// </remarks>	
        /// <param name="numVertices"> Number of vertices for the skin mesh. </param>
        /// <param name="fvf"> Combination of {{D3DFVF}} that describes the vertex format for the returned skin mesh. </param>
        /// <param name="numBones"> Number of bones for the skin mesh. </param>
        /// <param name="ppSkinInfo"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.SkinInfo"/> interface, representing the created skin information object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateSkinInfoFVF([None] int NumVertices,[None] int FVF,[None] int NumBones,[None] LPD3DXSKININFO* ppSkinInfo)</unmanaged>
		public static SlimDX2.Result CreateSkinInfoFVF(int numVertices, int fvf, int numBones, out SlimDX2.Direct3D9.SkinInfo ppSkinInfo) {
            unsafe {
                IntPtr ppSkinInfo_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateSkinInfoFVF_( numVertices,  fvf,  numBones, out ppSkinInfo_);
                ppSkinInfo = (ppSkinInfo_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.SkinInfo(ppSkinInfo_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateSkinInfoFVF([None] int NumVertices,[None] int FVF,[None] int NumBones,[None] LPD3DXSKININFO* ppSkinInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSkinInfoFVF", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateSkinInfoFVF_(int numVertices, int fvf, int numBones, out IntPtr ppSkinInfo);		
        
        /// <summary>	
        /// Loads a mesh from an <see cref="SlimDX2.Direct3D9.FileData"/> object.	
        /// </summary>	
        /// <remarks>	
        ///  For mesh files that do not contain effect instance information, default effect instances will be generated from the material information in the .x file. A default effect instance will have default values that correspond to the members of the <see cref="SlimDX2.Direct3D9.Material9"/> structure. The default texture name is also filled in, but is handled differently. The name will be Texture0@Name, which corresponds to an effect variable by the name of "Texture0" with an annotation called "Name." This will contain the string file name for the texture. 	
        /// </remarks>	
        /// <param name="pxofMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.FileData"/> interface, representing the file data object to load. </param>
        /// <param name="options"> Combination of one or more flags from the {{D3DXMESH}} enumeration, specifying creation options for the mesh. </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device object associated with the mesh. </param>
        /// <param name="ppAdjacency"> Pointer to a buffer that contains adjacency data.  The adjacency data contains an array of three DWORDs per face that specify the three neighbors for each face in the mesh. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.Buffer"/>. </param>
        /// <param name="ppMaterials"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface. When the method returns, this parameter is filled with an array of <see cref="SlimDX2.Direct3D9.Material"/> structures. </param>
        /// <param name="ppEffectInstances"> Pointer to a buffer containing an array of effect instances, one per attribute group in the returned mesh. An effect instance is a particular instance of state information used to initialize an effect. See <see cref="SlimDX2.Direct3D9.Effectinstance"/>. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.Buffer"/>. </param>
        /// <param name="pNumMaterials"> Pointer to the number of <see cref="SlimDX2.Direct3D9.Material"/> structures in the  ppMaterials array, when the method returns. </param>
        /// <param name="ppMesh"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the loaded mesh. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXof([None] LPD3DXFILEDATA pxofMesh,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result LoadMeshFromXof(SlimDX2.Direct3D9.FileData pxofMesh, int options, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.Buffer ppAdjacency, out SlimDX2.Direct3D9.Buffer ppMaterials, out SlimDX2.Direct3D9.Buffer ppEffectInstances, ref int pNumMaterials, out SlimDX2.Direct3D9.Mesh ppMesh) {
            unsafe {
                IntPtr ppAdjacency_ = IntPtr.Zero;
                IntPtr ppMaterials_ = IntPtr.Zero;
                IntPtr ppEffectInstances_ = IntPtr.Zero;
                IntPtr ppMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadMeshFromXof_((pxofMesh == null)?IntPtr.Zero:pxofMesh.NativePointer,  options, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out ppAdjacency_, out ppMaterials_, out ppEffectInstances_, ref  pNumMaterials, out ppMesh_);
                ppAdjacency = (ppAdjacency_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAdjacency_);
                ppMaterials = (ppMaterials_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppMaterials_);
                ppEffectInstances = (ppEffectInstances_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppEffectInstances_);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXof([None] LPD3DXFILEDATA pxofMesh,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshFromXof", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadMeshFromXof_(IntPtr pxofMesh, int options, IntPtr pD3DDevice, out IntPtr ppAdjacency, out IntPtr ppMaterials, out IntPtr ppEffectInstances, ref int pNumMaterials, out IntPtr ppMesh);		
        
        /// <summary>	
        /// Loads a skin mesh from a DirectX .x file data object.	
        /// </summary>	
        /// <remarks>	
        ///  This method takes a pointer to an internal object in the .x file, enabling you to load the frame hierarchy. For mesh files that do not contain effect instance information, default effect instances will be generated from the material information in the .x file. A default effect instance will have default values that correspond to the members of the <see cref="SlimDX2.Direct3D9.Material9"/> structure. The default texture name is also filled in, but is handled differently. The name will be Texture0@Name, which corresponds to an effect variable by the name of "Texture0" with an annotation called "Name." This will contain the string file name for the texture. 	
        /// </remarks>	
        /// <param name="pxofMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.FileData"/> interface, representing the file data object to load. </param>
        /// <param name="options"> Combination of one or more flags, from the {{D3DXMESH}} enumeration, specifying creation options for the mesh. </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device object associated with the mesh. </param>
        /// <param name="ppAdjacency"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface. When this method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh. </param>
        /// <param name="ppMaterials"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface. When the method returns, this parameter is filled with an array of <see cref="SlimDX2.Direct3D9.Material"/> structures. </param>
        /// <param name="ppEffectInstances"> Pointer to a buffer containing an array of effect instances, one per attribute group in the returned mesh. An effect instance is a particular instance of state information used to initialize an effect. See <see cref="SlimDX2.Direct3D9.Effectinstance"/>. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.Buffer"/>. </param>
        /// <param name="pMatOut"> Pointer to the number of <see cref="SlimDX2.Direct3D9.Material"/> structures in the  ppMaterials array, when the method returns. </param>
        /// <param name="ppSkinInfo"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.SkinInfo"/> interface, which represents the skinning information. 									  </param>
        /// <param name="ppMesh"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, which represents the loaded mesh. 									  </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY </returns>
        /// <unmanaged>HRESULT D3DXLoadSkinMeshFromXof([None] LPD3DXFILEDATA pxofMesh,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pMatOut,[None] LPD3DXSKININFO* ppSkinInfo,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result LoadSkinMeshFromXof(SlimDX2.Direct3D9.FileData pxofMesh, int options, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.Buffer ppAdjacency, out SlimDX2.Direct3D9.Buffer ppMaterials, out SlimDX2.Direct3D9.Buffer ppEffectInstances, ref int pMatOut, out SlimDX2.Direct3D9.SkinInfo ppSkinInfo, out SlimDX2.Direct3D9.Mesh ppMesh) {
            unsafe {
                IntPtr ppAdjacency_ = IntPtr.Zero;
                IntPtr ppMaterials_ = IntPtr.Zero;
                IntPtr ppEffectInstances_ = IntPtr.Zero;
                IntPtr ppSkinInfo_ = IntPtr.Zero;
                IntPtr ppMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadSkinMeshFromXof_((pxofMesh == null)?IntPtr.Zero:pxofMesh.NativePointer,  options, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out ppAdjacency_, out ppMaterials_, out ppEffectInstances_, ref  pMatOut, out ppSkinInfo_, out ppMesh_);
                ppAdjacency = (ppAdjacency_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAdjacency_);
                ppMaterials = (ppMaterials_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppMaterials_);
                ppEffectInstances = (ppEffectInstances_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppEffectInstances_);
                ppSkinInfo = (ppSkinInfo_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.SkinInfo(ppSkinInfo_);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadSkinMeshFromXof([None] LPD3DXFILEDATA pxofMesh,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pMatOut,[None] LPD3DXSKININFO* ppSkinInfo,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSkinMeshFromXof", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadSkinMeshFromXof_(IntPtr pxofMesh, int options, IntPtr pD3DDevice, out IntPtr ppAdjacency, out IntPtr ppMaterials, out IntPtr ppEffectInstances, ref int pMatOut, out IntPtr ppSkinInfo, out IntPtr ppMesh);		
        
        /// <summary>	
        /// Creates a skin mesh from another mesh.	
        /// </summary>	
        /// <param name="pMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.BaseMesh"/> object, the mesh from which to create the skin mesh. </param>
        /// <param name="numBones"> The length of the array attached to the BoneId. See <see cref="SlimDX2.Direct3D9.Bonecombination"/>. </param>
        /// <param name="pBoneCombinationTable"> Pointer to an array of bone combinations. See <see cref="SlimDX2.Direct3D9.Bonecombination"/>. </param>
        /// <param name="ppSkinInfo"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.SkinInfo"/> interface representing the created skin mesh object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateSkinInfoFromBlendedMesh([None] LPD3DXBASEMESH pMesh,[None] int NumBones,[None] const D3DXBONECOMBINATION* pBoneCombinationTable,[None] LPD3DXSKININFO* ppSkinInfo)</unmanaged>
		public static SlimDX2.Result CreateSkinInfoFromBlendedMesh(SlimDX2.Direct3D9.BaseMesh pMesh, int numBones, ref SlimDX2.Direct3D9.Bonecombination pBoneCombinationTable, out SlimDX2.Direct3D9.SkinInfo ppSkinInfo) {
            unsafe {
                IntPtr ppSkinInfo_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateSkinInfoFromBlendedMesh_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  numBones, ref  pBoneCombinationTable, out ppSkinInfo_);
                ppSkinInfo = (ppSkinInfo_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.SkinInfo(ppSkinInfo_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateSkinInfoFromBlendedMesh([None] LPD3DXBASEMESH pMesh,[None] int NumBones,[None] const D3DXBONECOMBINATION* pBoneCombinationTable,[None] LPD3DXSKININFO* ppSkinInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSkinInfoFromBlendedMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateSkinInfoFromBlendedMesh_(IntPtr pMesh, int numBones, ref SlimDX2.Direct3D9.Bonecombination pBoneCombinationTable, out IntPtr ppSkinInfo);		
        
        /// <summary>	
        /// Tessellates the given mesh using the N-patch tessellation scheme.	
        /// </summary>	
        /// <remarks>	
        ///  This function tessellates by using the N-patch algorithm. 	
        /// </remarks>	
        /// <param name="pMeshIn"> Pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the mesh to tessellate. </param>
        /// <param name="pAdjacencyIn"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the source mesh. This parameter may be NULL. </param>
        /// <param name="numSegs"> Number of segments per edge to tessellate. </param>
        /// <param name="quadraticInterpNormals"> Set to TRUE to use quadratic interpolation for normals; set to FALSE for linear interpolation. </param>
        /// <param name="ppMeshOut"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the returned tessellated mesh. </param>
        /// <param name="ppAdjacencyOut"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface. If the value of this parameter is not set to NULL&gt;, this buffer will contain an array of three DWORDs per face that specify the three neighbors for each face in the output mesh. This parameter may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXTessellateNPatches([None] LPD3DXMESH pMeshIn,[None] const int* pAdjacencyIn,[None] FLOAT NumSegs,[None] BOOL QuadraticInterpNormals,[None] LPD3DXMESH* ppMeshOut,[None] LPD3DXBUFFER* ppAdjacencyOut)</unmanaged>
		public static SlimDX2.Result TessellateNPatches(SlimDX2.Direct3D9.Mesh pMeshIn, ref int pAdjacencyIn, float numSegs, bool quadraticInterpNormals, out SlimDX2.Direct3D9.Mesh ppMeshOut, out SlimDX2.Direct3D9.Buffer ppAdjacencyOut) {
            unsafe {
                IntPtr ppMeshOut_ = IntPtr.Zero;
                IntPtr ppAdjacencyOut_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXTessellateNPatches_((pMeshIn == null)?IntPtr.Zero:pMeshIn.NativePointer, ref  pAdjacencyIn,  numSegs,  quadraticInterpNormals, out ppMeshOut_, out ppAdjacencyOut_);
                ppMeshOut = (ppMeshOut_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMeshOut_);
                ppAdjacencyOut = (ppAdjacencyOut_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAdjacencyOut_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXTessellateNPatches([None] LPD3DXMESH pMeshIn,[None] const int* pAdjacencyIn,[None] FLOAT NumSegs,[None] BOOL QuadraticInterpNormals,[None] LPD3DXMESH* ppMeshOut,[None] LPD3DXBUFFER* ppAdjacencyOut)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXTessellateNPatches", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXTessellateNPatches_(IntPtr pMeshIn, ref int pAdjacencyIn, float numSegs, bool quadraticInterpNormals, out IntPtr ppMeshOut, out IntPtr ppAdjacencyOut);		
        
        /// <summary>	
        /// Generates an output vertex declaration from the input declaration. The output declaration is intended for use by the mesh tessellation functions.	
        /// </summary>	
        /// <param name="pOutput"> Pointer to the output vertex declaration. See <see cref="SlimDX2.Direct3D9.Vertexelement9"/>. </param>
        /// <param name="pInput"> Pointer to the input vertex declaration. See <see cref="SlimDX2.Direct3D9.Vertexelement9"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXGenerateOutputDecl([None] D3DVERTEXELEMENT9* pOutput,[None] const D3DVERTEXELEMENT9* pInput)</unmanaged>
		public static SlimDX2.Result GenerateOutputDecl(ref SlimDX2.Direct3D9.Vertexelement9 pOutput, ref SlimDX2.Direct3D9.Vertexelement9 pInput) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGenerateOutputDecl_(ref  pOutput, ref  pInput);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGenerateOutputDecl([None] D3DVERTEXELEMENT9* pOutput,[None] const D3DVERTEXELEMENT9* pInput)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGenerateOutputDecl", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGenerateOutputDecl_(ref SlimDX2.Direct3D9.Vertexelement9 pOutput, ref SlimDX2.Direct3D9.Vertexelement9 pInput);		
        
        /// <summary>	
        /// Loads a patch mesh from an <see cref="SlimDX2.Direct3D9.FileData"/> object.	
        /// </summary>	
        /// <remarks>	
        ///  For mesh files that do not contain effect instance information, default effect instances will be generated from the material information in the .x file. A default effect instance will have default values that correspond to the members of the <see cref="SlimDX2.Direct3D9.Material9"/> structure. The default texture name is also filled in, but is handled differently. The name will be Texture0@Name, which corresponds to an effect variable by the name of "Texture0" with an annotation called "Name." This will contain the string file name for the texture. 	
        /// </remarks>	
        /// <param name="pXofObjMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.FileData"/> interface, representing the file data object to load. </param>
        /// <param name="options"> Combination of one or more {{D3DXMESH}} flags, specifying creation options for the mesh. </param>
        /// <param name="pD3DDevice"> Pointer to the device that the mesh is created from. </param>
        /// <param name="ppMaterials"> Array of materials contained in the mesh. Each material is indexed by an <see cref="SlimDX2.Direct3D9.Buffer"/> interface. </param>
        /// <param name="ppEffectInstances"> Pointer to a buffer containing an array of effect instances, one per attribute group in the returned mesh. An effect instance is a particular instance of state information used to initialize an effect. See <see cref="SlimDX2.Direct3D9.Effectinstance"/>. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.Buffer"/>. </param>
        /// <param name="pNumMaterials"> Pointer that contains the number of materials in the mesh. </param>
        /// <param name="ppMesh"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.PatchMesh"/> interface, representing the loaded mesh. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXLoadPatchMeshFromXof([None] LPD3DXFILEDATA pXofObjMesh,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXPATCHMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result LoadPatchMeshFromXof(SlimDX2.Direct3D9.FileData pXofObjMesh, int options, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.Buffer ppMaterials, out SlimDX2.Direct3D9.Buffer ppEffectInstances, ref int pNumMaterials, out SlimDX2.Direct3D9.PatchMesh ppMesh) {
            unsafe {
                IntPtr ppMaterials_ = IntPtr.Zero;
                IntPtr ppEffectInstances_ = IntPtr.Zero;
                IntPtr ppMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadPatchMeshFromXof_((pXofObjMesh == null)?IntPtr.Zero:pXofObjMesh.NativePointer,  options, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out ppMaterials_, out ppEffectInstances_, ref  pNumMaterials, out ppMesh_);
                ppMaterials = (ppMaterials_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppMaterials_);
                ppEffectInstances = (ppEffectInstances_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppEffectInstances_);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PatchMesh(ppMesh_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadPatchMeshFromXof([None] LPD3DXFILEDATA pXofObjMesh,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXPATCHMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadPatchMeshFromXof", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadPatchMeshFromXof_(IntPtr pXofObjMesh, int options, IntPtr pD3DDevice, out IntPtr ppMaterials, out IntPtr ppEffectInstances, ref int pNumMaterials, out IntPtr ppMesh);		
        
        /// <summary>	
        /// Gets the size of the rectangle patch.	
        /// </summary>	
        /// <param name="pfNumSegs"> Number of segments per edge to tessellate. </param>
        /// <param name="pdwTriangles"> Pointer to a DWORD that contains the number of triangles in the patch. </param>
        /// <param name="pdwVertices"> Pointer to a DWORD that contains the number of vertices in the patch. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXRectPatchSize([None] const FLOAT* pfNumSegs,[None] int* pdwTriangles,[None] int* pdwVertices)</unmanaged>
		public static SlimDX2.Result RectPatchSize(ref float pfNumSegs, ref int pdwTriangles, ref int pdwVertices) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXRectPatchSize_(ref  pfNumSegs, ref  pdwTriangles, ref  pdwVertices);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXRectPatchSize([None] const FLOAT* pfNumSegs,[None] int* pdwTriangles,[None] int* pdwVertices)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXRectPatchSize", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXRectPatchSize_(ref float pfNumSegs, ref int pdwTriangles, ref int pdwVertices);		
        
        /// <summary>	
        /// Gets the size of the triangle patch.	
        /// </summary>	
        /// <param name="pfNumSegs"> Number of segments per edge to tessellate. </param>
        /// <param name="pdwTriangles"> Pointer to a DWORD that contains the number of triangles in the patch. </param>
        /// <param name="pdwVertices"> Pointer to a DWORD that contains the number of vertices in the triangle patch. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXTriPatchSize([None] const FLOAT* pfNumSegs,[None] int* pdwTriangles,[None] int* pdwVertices)</unmanaged>
		public static SlimDX2.Result TriPatchSize(ref float pfNumSegs, ref int pdwTriangles, ref int pdwVertices) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXTriPatchSize_(ref  pfNumSegs, ref  pdwTriangles, ref  pdwVertices);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXTriPatchSize([None] const FLOAT* pfNumSegs,[None] int* pdwTriangles,[None] int* pdwVertices)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXTriPatchSize", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXTriPatchSize_(ref float pfNumSegs, ref int pdwTriangles, ref int pdwVertices);		
        
        /// <summary>	
        /// Tessellates a rectangular higher-order surface patch into a triangle mesh.	
        /// </summary>	
        /// <remarks>	
        ///  Use <see cref="SlimDX2.Direct3D9.D3DX9.RectPatchSize"/> to get the number of output vertices and indices that the tessellation function needs. 	
        /// </remarks>	
        /// <param name="pVB"> Vertex buffer containing the patch data. </param>
        /// <param name="pNumSegs"> Pointer to an array of four floating-point values that identify the number of segments into which each edge of the rectangle patch should be divided when tessellated. See <see cref="SlimDX2.Direct3D9.RectpatchInformation"/>. </param>
        /// <param name="pdwInDecl"> Vertex declaration structure that defines the vertex data. See <see cref="SlimDX2.Direct3D9.Vertexelement9"/>. </param>
        /// <param name="pRectPatchInfo"> Describes a rectangular patch. See <see cref="SlimDX2.Direct3D9.RectpatchInformation"/>. </param>
        /// <param name="pMesh"> Pointer to the created mesh. See <see cref="SlimDX2.Direct3D9.Mesh"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXTessellateRectPatch([None] LPDIRECT3DVERTEXBUFFER9 pVB,[None] const FLOAT* pNumSegs,[None] const D3DVERTEXELEMENT9* pdwInDecl,[None] const D3DRECTPATCH_INFO* pRectPatchInfo,[None] LPD3DXMESH pMesh)</unmanaged>
		public static SlimDX2.Result TessellateRectPatch(SlimDX2.Direct3D9.VertexBuffer pVB, ref float pNumSegs, ref SlimDX2.Direct3D9.Vertexelement9 pdwInDecl, ref SlimDX2.Direct3D9.RectpatchInformation pRectPatchInfo, SlimDX2.Direct3D9.Mesh pMesh) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXTessellateRectPatch_((pVB == null)?IntPtr.Zero:pVB.NativePointer, ref  pNumSegs, ref  pdwInDecl, ref  pRectPatchInfo, (pMesh == null)?IntPtr.Zero:pMesh.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXTessellateRectPatch([None] LPDIRECT3DVERTEXBUFFER9 pVB,[None] const FLOAT* pNumSegs,[None] const D3DVERTEXELEMENT9* pdwInDecl,[None] const D3DRECTPATCH_INFO* pRectPatchInfo,[None] LPD3DXMESH pMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXTessellateRectPatch", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXTessellateRectPatch_(IntPtr pVB, ref float pNumSegs, ref SlimDX2.Direct3D9.Vertexelement9 pdwInDecl, ref SlimDX2.Direct3D9.RectpatchInformation pRectPatchInfo, IntPtr pMesh);		
        
        /// <summary>	
        /// Tessellates a triangular higher-order surface patch into a triangle mesh.	
        /// </summary>	
        /// <remarks>	
        ///  Use <see cref="SlimDX2.Direct3D9.D3DX9.TriPatchSize"/> to get the number of output vertices and indices that the tessellation function needs. 	
        /// </remarks>	
        /// <param name="pVB"> Vertex buffer containing the patch data. </param>
        /// <param name="pNumSegs"> Pointer to an array of three floating-point values that identify the number of segments into which each edge of the triangle patch should be divided when tessellated. See <see cref="SlimDX2.Direct3D9.TripatchInformation"/>. </param>
        /// <param name="pInDecl"> Vertex declaration structure that defines the vertex data. See <see cref="SlimDX2.Direct3D9.Vertexelement9"/>. </param>
        /// <param name="pTriPatchInfo"> Describes a triangle patch. See <see cref="SlimDX2.Direct3D9.TripatchInformation"/>. </param>
        /// <param name="pMesh"> Pointer to the created mesh. See <see cref="SlimDX2.Direct3D9.Mesh"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXTessellateTriPatch([None] LPDIRECT3DVERTEXBUFFER9 pVB,[None] const FLOAT* pNumSegs,[None] const D3DVERTEXELEMENT9* pInDecl,[None] const D3DTRIPATCH_INFO* pTriPatchInfo,[None] LPD3DXMESH pMesh)</unmanaged>
		public static SlimDX2.Result TessellateTriPatch(SlimDX2.Direct3D9.VertexBuffer pVB, ref float pNumSegs, ref SlimDX2.Direct3D9.Vertexelement9 pInDecl, ref SlimDX2.Direct3D9.TripatchInformation pTriPatchInfo, SlimDX2.Direct3D9.Mesh pMesh) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXTessellateTriPatch_((pVB == null)?IntPtr.Zero:pVB.NativePointer, ref  pNumSegs, ref  pInDecl, ref  pTriPatchInfo, (pMesh == null)?IntPtr.Zero:pMesh.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXTessellateTriPatch([None] LPDIRECT3DVERTEXBUFFER9 pVB,[None] const FLOAT* pNumSegs,[None] const D3DVERTEXELEMENT9* pInDecl,[None] const D3DTRIPATCH_INFO* pTriPatchInfo,[None] LPD3DXMESH pMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXTessellateTriPatch", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXTessellateTriPatch_(IntPtr pVB, ref float pNumSegs, ref SlimDX2.Direct3D9.Vertexelement9 pInDecl, ref SlimDX2.Direct3D9.TripatchInformation pTriPatchInfo, IntPtr pMesh);		
        
        /// <summary>	
        /// Creates an N-patch mesh from a triangle mesh.	
        /// </summary>	
        /// <param name="pMeshSysMem"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface that represents the triangle mesh object. </param>
        /// <param name="pPatchMesh"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.PatchMesh"/> interface that represents the created patch mesh object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateNPatchMesh([None] LPD3DXMESH pMeshSysMem,[None] LPD3DXPATCHMESH* pPatchMesh)</unmanaged>
		public static SlimDX2.Result CreateNPatchMesh(SlimDX2.Direct3D9.Mesh pMeshSysMem, out SlimDX2.Direct3D9.PatchMesh pPatchMesh) {
            unsafe {
                IntPtr pPatchMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateNPatchMesh_((pMeshSysMem == null)?IntPtr.Zero:pMeshSysMem.NativePointer, out pPatchMesh_);
                pPatchMesh = (pPatchMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PatchMesh(pPatchMesh_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateNPatchMesh([None] LPD3DXMESH pMeshSysMem,[None] LPD3DXPATCHMESH* pPatchMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateNPatchMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateNPatchMesh_(IntPtr pMeshSysMem, out IntPtr pPatchMesh);		
        
        /// <summary>	
        /// Creates a mesh from a control-patch mesh.	
        /// </summary>	
        /// <remarks>	
        ///  This method takes an input patch mesh and converts it to a tessellated mesh. Patch meshes use 16-bit index buffers. Therefore, indices to {{LockIndexBuffer}} are 16 bits. 	
        /// </remarks>	
        /// <param name="pInfo"> Patch information structure. For more information, see <see cref="SlimDX2.Direct3D9.Patchinfo"/>. </param>
        /// <param name="dwNumPatches"> Number of patches. </param>
        /// <param name="dwNumVertices"> Number of control vertices in the patch. </param>
        /// <param name="dwOptions"> Unused. Reserved for later use. </param>
        /// <param name="pDecl"> Array of <see cref="SlimDX2.Direct3D9.Vertexelement9"/> elements, describing the vertex format for the returned mesh. </param>
        /// <param name="pD3DDevice"> Pointer the device that creates the patch mesh. See <see cref="SlimDX2.Direct3D9.Device"/>. </param>
        /// <param name="pPatchMesh"> Pointer to the <see cref="SlimDX2.Direct3D9.PatchMesh"/> object that is created. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreatePatchMesh([None] const D3DXPATCHINFO* pInfo,[None] int dwNumPatches,[None] int dwNumVertices,[None] int dwOptions,[None] const D3DVERTEXELEMENT9* pDecl,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXPATCHMESH* pPatchMesh)</unmanaged>
		public static SlimDX2.Result CreatePatchMesh(ref SlimDX2.Direct3D9.Patchinfo pInfo, int dwNumPatches, int dwNumVertices, int dwOptions, ref SlimDX2.Direct3D9.Vertexelement9 pDecl, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.PatchMesh pPatchMesh) {
            unsafe {
                IntPtr pPatchMesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreatePatchMesh_(ref  pInfo,  dwNumPatches,  dwNumVertices,  dwOptions, ref  pDecl, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out pPatchMesh_);
                pPatchMesh = (pPatchMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PatchMesh(pPatchMesh_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreatePatchMesh([None] const D3DXPATCHINFO* pInfo,[None] int dwNumPatches,[None] int dwNumVertices,[None] int dwOptions,[None] const D3DVERTEXELEMENT9* pDecl,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXPATCHMESH* pPatchMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreatePatchMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreatePatchMesh_(ref SlimDX2.Direct3D9.Patchinfo pInfo, int dwNumPatches, int dwNumVertices, int dwOptions, ref SlimDX2.Direct3D9.Vertexelement9 pDecl, IntPtr pD3DDevice, out IntPtr pPatchMesh);		
        
        /// <summary>	
        /// Validates a patch mesh, returning the number of degenerate vertices and patches.	
        /// </summary>	
        /// <remarks>	
        ///  This method validates the mesh by checking for invalid indices. Error information is available from the debugger output. 	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.PatchMesh"/> interface, representing the patch mesh to be tested. </param>
        /// <param name="dwcDegenerateVertices"> Returns the number of degenerate vertices in the patch mesh. </param>
        /// <param name="dwcDegeneratePatches"> Returns the number of degenerate patches in the patch mesh. </param>
        /// <param name="ppErrorsAndWarnings"> Returns a pointer to a buffer containing a string of errors and warnings that explain the problems found in the patch mesh. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXValidPatchMesh([None] LPD3DXPATCHMESH pMesh,[None] int* dwcDegenerateVertices,[None] int* dwcDegeneratePatches,[None] LPD3DXBUFFER* ppErrorsAndWarnings)</unmanaged>
		public static SlimDX2.Result ValidPatchMesh(SlimDX2.Direct3D9.PatchMesh pMesh, ref int dwcDegenerateVertices, ref int dwcDegeneratePatches, out SlimDX2.Direct3D9.Buffer ppErrorsAndWarnings) {
            unsafe {
                IntPtr ppErrorsAndWarnings_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXValidPatchMesh_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  dwcDegenerateVertices, ref  dwcDegeneratePatches, out ppErrorsAndWarnings_);
                ppErrorsAndWarnings = (ppErrorsAndWarnings_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorsAndWarnings_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXValidPatchMesh([None] LPD3DXPATCHMESH pMesh,[None] int* dwcDegenerateVertices,[None] int* dwcDegeneratePatches,[None] LPD3DXBUFFER* ppErrorsAndWarnings)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXValidPatchMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXValidPatchMesh_(IntPtr pMesh, ref int dwcDegenerateVertices, ref int dwcDegeneratePatches, out IntPtr ppErrorsAndWarnings);		
        
        /// <summary>	
        /// Returns the size of a vertex for a flexible vertex format (FVF).	
        /// </summary>	
        /// <param name="fvf"> FVF to be queried. A combination of {{D3DFVF}}. </param>
        /// <returns> {{UINT}} The FVF vertex size, in bytes. </returns>
        /// <unmanaged>UINT D3DXGetFVFVertexSize([None] int FVF)</unmanaged>
		public static int GetFVFVertexSize(int fvf) {
            unsafe {
                int __result__;
                __result__= (int)D3DXGetFVFVertexSize_( fvf);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>UINT D3DXGetFVFVertexSize([None] int FVF)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetFVFVertexSize", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DXGetFVFVertexSize_(int fvf);		
        
        /// <summary>	
        /// Returns the size of a vertex from the vertex declaration.	
        /// </summary>	
        /// <param name="pDecl"> A pointer to the vertex declaration. See <see cref="SlimDX2.Direct3D9.Vertexelement9"/>. </param>
        /// <param name="stream"> The zero-based stream index. </param>
        /// <returns> {{UINT}} The vertex declaration size, in bytes. </returns>
        /// <unmanaged>UINT D3DXGetDeclVertexSize([None] const D3DVERTEXELEMENT9* pDecl,[None] int Stream)</unmanaged>
		public static int GetDeclVertexSize(ref SlimDX2.Direct3D9.Vertexelement9 pDecl, int stream) {
            unsafe {
                int __result__;
                __result__= (int)D3DXGetDeclVertexSize_(ref  pDecl,  stream);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>UINT D3DXGetDeclVertexSize([None] const D3DVERTEXELEMENT9* pDecl,[None] int Stream)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetDeclVertexSize", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DXGetDeclVertexSize_(ref SlimDX2.Direct3D9.Vertexelement9 pDecl, int stream);		
        
        /// <summary>	
        /// Returns the number of elements in the vertex declaration.	
        /// </summary>	
        /// <param name="pDecl"> A pointer to the vertex declaration. See <see cref="SlimDX2.Direct3D9.Vertexelement9"/>. </param>
        /// <returns> {{UINT}} The number of elements in the vertex declaration. </returns>
        /// <unmanaged>UINT D3DXGetDeclLength([None] const D3DVERTEXELEMENT9* pDecl)</unmanaged>
		public static int GetDeclLength(ref SlimDX2.Direct3D9.Vertexelement9 pDecl) {
            unsafe {
                int __result__;
                __result__= (int)D3DXGetDeclLength_(ref  pDecl);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>UINT D3DXGetDeclLength([None] const D3DVERTEXELEMENT9* pDecl)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetDeclLength", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DXGetDeclLength_(ref SlimDX2.Direct3D9.Vertexelement9 pDecl);		
        
        /// <summary>	
        /// Returns a declarator from a flexible vertex format (FVF) code.	
        /// </summary>	
        /// <param name="fvf"> Combination of {{D3DFVF}} that describes the FVF from which to generate the returned declarator array. </param>
        /// <param name="pDeclarator"> An array of <see cref="SlimDX2.Direct3D9.Vertexelement9"/> elements describing the vertex format of the mesh vertices. The upper limit of this declarator array is {{MAX_FVF_DECL_SIZE}}. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DXERR_INVALIDMESH. </returns>
        /// <unmanaged>HRESULT D3DXDeclaratorFromFVF([None] int FVF,[None] D3DVERTEXELEMENT9 pDeclarator[65])</unmanaged>
		public static SlimDX2.Result DeclaratorFromFVF(int fvf, SlimDX2.Direct3D9.Vertexelement9[] pDeclarator) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXDeclaratorFromFVF_( fvf,  pDeclarator);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXDeclaratorFromFVF([None] int FVF,[None] D3DVERTEXELEMENT9 pDeclarator[65])</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXDeclaratorFromFVF", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXDeclaratorFromFVF_(int fvf, SlimDX2.Direct3D9.Vertexelement9[] pDeclarator);		
        
        /// <summary>	
        /// Returns a flexible vertex format (FVF) code from a declarator.	
        /// </summary>	
        /// <remarks>	
        ///  This function will fail for any declarator that does not map directly to an FVF. 	
        /// </remarks>	
        /// <param name="pDeclarator"> Array of <see cref="SlimDX2.Direct3D9.Vertexelement9"/> elements, describing the FVF code. </param>
        /// <param name="pFVF"> Pointer to a  DWORD value, representing the returned combination of {{D3DFVF}} that describes the vertex format returned from the declarator. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXFVFFromDeclarator([None] const D3DVERTEXELEMENT9* pDeclarator,[None] int* pFVF)</unmanaged>
		public static SlimDX2.Result FVFFromDeclarator(ref SlimDX2.Direct3D9.Vertexelement9 pDeclarator, ref int pFVF) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFVFFromDeclarator_(ref  pDeclarator, ref  pFVF);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFVFFromDeclarator([None] const D3DVERTEXELEMENT9* pDeclarator,[None] int* pFVF)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFVFFromDeclarator", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFVFFromDeclarator_(ref SlimDX2.Direct3D9.Vertexelement9 pDeclarator, ref int pFVF);		
        
        /// <summary>	
        /// Welds together replicated vertices that have equal attributes. This method uses specified epsilon values for equality comparisons.	
        /// </summary>	
        /// <remarks>	
        ///  This function uses supplied adjacency information to determine the points that are replicated. Vertices are merged based on an epsilon comparison. Vertices with equal position must already have been calculated and represented by point-representative data. This function combines logically-welded vertices that have similar components, such as normals or texture coordinates within pEpsilons. The following example code calls this function with welding enabled. Vertices are compared using epsilon values for normal vector and vertex position. A pointer is returned to a face remapping array (pFaceRemap). 	
        /// <code> TCHAR            strMediaPath[512];       // X-file path 	
        /// LPD3DXBUFFER     pAdjacencyBuffer = NULL; // adjacency data buffer	
        /// LPD3DXBUFFER     pD3DXMtrlBuffer  = NULL; // material buffer	
        /// LPD3DXMESH       pMesh            = NULL; // mesh object	
        /// DWORD            m_dwNumMaterials;        // number of materials	
        /// D3DXWELDEPSILONS Epsilons;                // structure with epsilon values	
        /// DWORD            *pFaceRemap[65536];      // face remapping array	
        /// DWORD            i;                       // internal variable // Load the mesh from the specified file hr = D3DXLoadMeshFromX ( strMediaPath, D3DXMESH_MANAGED, m_pd3dDevice, &amp;pAdjacencyBuffer, &amp;pD3DXMtrlBuffer, NULL, &amp;m_dwNumMaterials, &amp;pMesh ) ) if( FAILED( hr ) )  goto End;              // Go to error handling // Set epsilon values Epsilons.Normal = 0.001; Epsilons.Position = 0.1; // Weld the vertices for( i=0; i &lt; 65536; i++ ) {  pFaceRemap[i] = 0;  } hr = D3DXWeldVertices ( pMesh, D3DXWELDEPSILONS_WELDPARTIALMATCHES, &amp;Epsilons, (DWORD*)pAdjacencyBuffer-&gt;GetBufferPointer(), (DWORD*)pAdjacencyBuffer-&gt;GetBufferPointer(), (DWORD*)pFaceRemap, NULL ) if( FAILED( hr ) )  goto End;              // Go to error handling </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> object, the mesh from which to weld vertices. </param>
        /// <param name="flags"> Combination of one or more flags from {{D3DXWELDEPSILONSFLAGS}}. </param>
        /// <param name="pEpsilons"> Pointer to a {{D3DXWeldEpsilons}} structure, specifying the epsilon values to be used for this method. Use NULL to initialize all structure members to a default value of 1.0e-6f. </param>
        /// <param name="pAdjacencyIn"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the source mesh. If the edge has no adjacent faces, the value is 0xffffffff. If this parameter is set to NULL, <see cref="SlimDX2.Direct3D9.BaseMesh.GenerateAdjacency"/> will be called to create logical adjacency information. </param>
        /// <param name="pAdjacencyOut"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the optimized mesh. If the edge has no adjacent faces, the value is 0xffffffff. </param>
        /// <param name="pFaceRemap"> An array of DWORDs, one per face, that identifies the original mesh face that corresponds to each face in the welded mesh. </param>
        /// <param name="ppVertexRemap"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface, which contains a DWORD for each vertex that specifies how the new vertices map to the old vertices. This remap is useful if you need to alter external data based on the new vertex mapping. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXWeldVertices([None] LPD3DXMESH pMesh,[None] int Flags,[None] const D3DXWELDEPSILONS* pEpsilons,[None] const int* pAdjacencyIn,[None] int* pAdjacencyOut,[None] int* pFaceRemap,[None] LPD3DXBUFFER* ppVertexRemap)</unmanaged>
		public static SlimDX2.Result WeldVertices(SlimDX2.Direct3D9.Mesh pMesh, int flags, ref SlimDX2.Direct3D9.Weldepsilons pEpsilons, ref int pAdjacencyIn, ref int pAdjacencyOut, ref int pFaceRemap, out SlimDX2.Direct3D9.Buffer ppVertexRemap) {
            unsafe {
                SlimDX2.Direct3D9.Weldepsilons.__Native pEpsilons_ = new SlimDX2.Direct3D9.Weldepsilons.__Native();
                pEpsilons.__MarshalTo(ref pEpsilons_);
                IntPtr ppVertexRemap_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXWeldVertices_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  flags, ref  pEpsilons_, ref  pAdjacencyIn, ref  pAdjacencyOut, ref  pFaceRemap, out ppVertexRemap_);
                ppVertexRemap = (ppVertexRemap_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppVertexRemap_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXWeldVertices([None] LPD3DXMESH pMesh,[None] int Flags,[None] const D3DXWELDEPSILONS* pEpsilons,[None] const int* pAdjacencyIn,[None] int* pAdjacencyOut,[None] int* pFaceRemap,[None] LPD3DXBUFFER* ppVertexRemap)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXWeldVertices", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXWeldVertices_(IntPtr pMesh, int flags, ref SlimDX2.Direct3D9.Weldepsilons.__Native pEpsilons, ref int pAdjacencyIn, ref int pAdjacencyOut, ref int pFaceRemap, out IntPtr ppVertexRemap);		
        
        /// <summary>	
        /// Determines if a ray intersects with a mesh.	
        /// </summary>	
        /// <remarks>	
        ///  The D3DXIntersect function provides a way to understand points in and around a triangle, independent of where the triangle is actually located. This function returns the resulting point by using the following equation: V1 + U(V2 - V1) + V(V3 - V1). Any point in the plane V1V2V3 can be represented by the barycentric coordinate (U,V). The parameter U controls how much V2 gets weighted into the result, and the parameter V controls how much V3 gets weighted into the result. Lastly, the value of [1 - (U + V)] controls how much V1 gets weighted into the result. Barycentric coordinates are a form of general coordinates. In this context, using barycentric coordinates represents a change in coordinate systems. What holds true for Cartesian coordinates holds true for barycentric coordinates. Barycentric coordinates define a point inside a triangle in terms of the triangle's vertices.  For a more in-depth description of barycentric coordinates, see {{Mathworld's Barycentric Coordinates Description}}. 	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.BaseMesh"/> interface, representing the mesh to be tested. </param>
        /// <param name="pRayPos"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the point where the ray begins. </param>
        /// <param name="pRayDir"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the direction of the ray. </param>
        /// <param name="pHit"> Pointer to a  BOOL. If the ray intersects a triangular face on the mesh, this value will be set to TRUE. Otherwise, this value is set to FALSE. </param>
        /// <param name="pFaceIndex"> Pointer to an index value of the face closest to the ray origin, if pHit is TRUE. </param>
        /// <param name="pU"> Pointer to a barycentric hit coordinate, U. </param>
        /// <param name="pV"> Pointer to a barycentric hit coordinate, V. </param>
        /// <param name="pDist"> Pointer to a ray intersection parameter distance. </param>
        /// <param name="ppAllHits"> Pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> object, containing an array of <see cref="SlimDX2.Direct3D9.Intersectinfo"/> structures. </param>
        /// <param name="pCountOfHits"> Pointer to a DWORD that contains the number of entries in the ppAllHits array. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be: E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXIntersect([None] LPD3DXBASEMESH pMesh,[None] const D3DXVECTOR3* pRayPos,[None] const D3DXVECTOR3* pRayDir,[None] BOOL* pHit,[None] int* pFaceIndex,[None] FLOAT* pU,[None] FLOAT* pV,[None] FLOAT* pDist,[None] LPD3DXBUFFER* ppAllHits,[None] int* pCountOfHits)</unmanaged>
		public static SlimDX2.Result Intersect(SlimDX2.Direct3D9.BaseMesh pMesh, ref SlimMath.Vector3 pRayPos, ref SlimMath.Vector3 pRayDir, ref bool pHit, ref int pFaceIndex, ref float pU, ref float pV, ref float pDist, out SlimDX2.Direct3D9.Buffer ppAllHits, ref int pCountOfHits) {
            unsafe {
                IntPtr ppAllHits_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXIntersect_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  pRayPos, ref  pRayDir, ref  pHit, ref  pFaceIndex, ref  pU, ref  pV, ref  pDist, out ppAllHits_, ref  pCountOfHits);
                ppAllHits = (ppAllHits_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAllHits_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXIntersect([None] LPD3DXBASEMESH pMesh,[None] const D3DXVECTOR3* pRayPos,[None] const D3DXVECTOR3* pRayDir,[None] BOOL* pHit,[None] int* pFaceIndex,[None] FLOAT* pU,[None] FLOAT* pV,[None] FLOAT* pDist,[None] LPD3DXBUFFER* ppAllHits,[None] int* pCountOfHits)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXIntersect", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXIntersect_(IntPtr pMesh, ref SlimMath.Vector3 pRayPos, ref SlimMath.Vector3 pRayDir, ref bool pHit, ref int pFaceIndex, ref float pU, ref float pV, ref float pDist, out IntPtr ppAllHits, ref int pCountOfHits);		
        
        /// <summary>	
        /// Intersects the specified ray with the given mesh subset. This provides similar functionality to <see cref="SlimDX2.Direct3D9.D3DX9.Intersect"/>.	
        /// </summary>	
        /// <remarks>	
        ///  The D3DXIntersectSubset function provides a way to understand points in and around a triangle, independent of where the triangle is actually located. This function returns the resulting point by using the following equation: V1 + U(V2 - V1) + V(V3 - V1). Any point in the plane V1V2V3 can be represented by the barycentric coordinate (U,V). The parameter U controls how much V2 gets weighted into the result and the parameter V controls how much V3 gets weighted into the result. Lastly, the value of [1 - (U + V)] controls how much V1 gets weighted into the result. Barycentric coordinates are a form of general coordinates. In this context, using barycentric coordinates represents a change in coordinate systems. What holds true for Cartesian coordinates holds true for barycentric coordinates. Barycentric coordinates define a point inside a triangle in terms of the triangle's vertices.  For a more in-depth description of barycentric coordinates, see {{Mathworld's Barycentric Coordinates Description}}. 	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.BaseMesh"/> interface, representing the mesh to be tested. The mesh must be attribute sorted. </param>
        /// <param name="attribId"> Attribute identifier of the subset to intersect with. </param>
        /// <param name="pRayPos"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the point where the ray begins. </param>
        /// <param name="pRayDir"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the direction of the ray. </param>
        /// <param name="pHit"> Pointer to a BOOL. If the ray intersects a triangular face on the mesh, this value will be set to TRUE. Otherwise, this value is set to FALSE. </param>
        /// <param name="pFaceIndex"> Pointer to an index value of the face closest to the ray origin, if pHit is TRUE. </param>
        /// <param name="pU"> Pointer to a barycentric hit coordinate, U. </param>
        /// <param name="pV"> Pointer to a barycentric hit coordinate, V. </param>
        /// <param name="pDist"> Pointer to a ray intersection parameter distance. </param>
        /// <param name="ppAllHits"> Array of <see cref="SlimDX2.Direct3D9.Intersectinfo"/> structures, representing all hits, not just closest hits. </param>
        /// <param name="pCountOfHits"> Number of elements in the array returned from ppAllHits. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following value: E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXIntersectSubset([None] LPD3DXBASEMESH pMesh,[None] int AttribId,[None] const D3DXVECTOR3* pRayPos,[None] const D3DXVECTOR3* pRayDir,[None] BOOL* pHit,[None] int* pFaceIndex,[None] FLOAT* pU,[None] FLOAT* pV,[None] FLOAT* pDist,[None] LPD3DXBUFFER* ppAllHits,[None] int* pCountOfHits)</unmanaged>
		public static SlimDX2.Result IntersectSubset(SlimDX2.Direct3D9.BaseMesh pMesh, int attribId, ref SlimMath.Vector3 pRayPos, ref SlimMath.Vector3 pRayDir, ref bool pHit, ref int pFaceIndex, ref float pU, ref float pV, ref float pDist, out SlimDX2.Direct3D9.Buffer ppAllHits, ref int pCountOfHits) {
            unsafe {
                IntPtr ppAllHits_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXIntersectSubset_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  attribId, ref  pRayPos, ref  pRayDir, ref  pHit, ref  pFaceIndex, ref  pU, ref  pV, ref  pDist, out ppAllHits_, ref  pCountOfHits);
                ppAllHits = (ppAllHits_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAllHits_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXIntersectSubset([None] LPD3DXBASEMESH pMesh,[None] int AttribId,[None] const D3DXVECTOR3* pRayPos,[None] const D3DXVECTOR3* pRayDir,[None] BOOL* pHit,[None] int* pFaceIndex,[None] FLOAT* pU,[None] FLOAT* pV,[None] FLOAT* pDist,[None] LPD3DXBUFFER* ppAllHits,[None] int* pCountOfHits)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXIntersectSubset", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXIntersectSubset_(IntPtr pMesh, int attribId, ref SlimMath.Vector3 pRayPos, ref SlimMath.Vector3 pRayDir, ref bool pHit, ref int pFaceIndex, ref float pU, ref float pV, ref float pDist, out IntPtr ppAllHits, ref int pCountOfHits);		
        
        /// <summary>	
        /// Splits a mesh into meshes smaller than the specified size.	
        /// </summary>	
        /// <remarks>	
        ///  A common use of this function is to split a mesh with 32-bit indices (more than 65535 vertices) into more than one mesh, each of which has 16-bit indices. The adjacency, vertex remap and face remap arrays are arrays are DWORDs where each array contains n DWORD pointers, followed by the DWORD data referenced by the pointers. For example, to obtain the face remap information for face 3 in mesh 2, the following code could be used, assuming the face remap data was returned in a variable named ppFaceRemapArrayOut. 	
        /// <code> const DWORD **face_remaps =  static_cast&lt;DWORD **&gt;(ppFaceRemapArrayOut-&gt;GetBufferPointer());	
        /// const DWORD remap = face_remaps[2][3]; </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="pMeshIn"> Pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface, representing the source mesh. </param>
        /// <param name="pAdjacencyIn"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh to be simplified. </param>
        /// <param name="maxSize">  Maximum number of vertices in the resulting mesh. </param>
        /// <param name="options"> Option flags for the new meshes. </param>
        /// <param name="pMeshesOut"> Number of meshes returned. </param>
        /// <param name="ppMeshArrayOut"> Buffer containing an array of <see cref="SlimDX2.Direct3D9.Mesh"/> interfaces for the new meshes. For a source mesh split into n meshes, ppMeshArrayOut is an array of n ID3DXMesh pointers. </param>
        /// <param name="ppAdjacencyArrayOut"> Buffer containing an array of adjacency arrays (DWORDs) for the new meshes. See <see cref="SlimDX2.Direct3D9.Buffer"/>. This parameter is optional. </param>
        /// <param name="ppFaceRemapArrayOut"> Buffer containing an array of face remap arrays (DWORDs) for the new meshes. See <see cref="SlimDX2.Direct3D9.Buffer"/>. This parameter is optional. </param>
        /// <param name="ppVertRemapArrayOut"> Buffer containing an array of vertex remap arrays for the new meshes. See <see cref="SlimDX2.Direct3D9.Buffer"/>. This parameter is optional. </param>
        /// <returns> void If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXSplitMesh([None] LPD3DXMESH pMeshIn,[None] const int* pAdjacencyIn,[None] const int MaxSize,[None] const int Options,[None] int* pMeshesOut,[None] LPD3DXBUFFER* ppMeshArrayOut,[None] LPD3DXBUFFER* ppAdjacencyArrayOut,[None] LPD3DXBUFFER* ppFaceRemapArrayOut,[None] LPD3DXBUFFER* ppVertRemapArrayOut)</unmanaged>
		public static SlimDX2.Result SplitMesh(SlimDX2.Direct3D9.Mesh pMeshIn, ref int pAdjacencyIn, int maxSize, int options, ref int pMeshesOut, out SlimDX2.Direct3D9.Buffer ppMeshArrayOut, out SlimDX2.Direct3D9.Buffer ppAdjacencyArrayOut, out SlimDX2.Direct3D9.Buffer ppFaceRemapArrayOut, out SlimDX2.Direct3D9.Buffer ppVertRemapArrayOut) {
            unsafe {
                IntPtr ppMeshArrayOut_ = IntPtr.Zero;
                IntPtr ppAdjacencyArrayOut_ = IntPtr.Zero;
                IntPtr ppFaceRemapArrayOut_ = IntPtr.Zero;
                IntPtr ppVertRemapArrayOut_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSplitMesh_((pMeshIn == null)?IntPtr.Zero:pMeshIn.NativePointer, ref  pAdjacencyIn,  maxSize,  options, ref  pMeshesOut, out ppMeshArrayOut_, out ppAdjacencyArrayOut_, out ppFaceRemapArrayOut_, out ppVertRemapArrayOut_);
                ppMeshArrayOut = (ppMeshArrayOut_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppMeshArrayOut_);
                ppAdjacencyArrayOut = (ppAdjacencyArrayOut_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAdjacencyArrayOut_);
                ppFaceRemapArrayOut = (ppFaceRemapArrayOut_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppFaceRemapArrayOut_);
                ppVertRemapArrayOut = (ppVertRemapArrayOut_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppVertRemapArrayOut_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSplitMesh([None] LPD3DXMESH pMeshIn,[None] const int* pAdjacencyIn,[None] const int MaxSize,[None] const int Options,[None] int* pMeshesOut,[None] LPD3DXBUFFER* ppMeshArrayOut,[None] LPD3DXBUFFER* ppAdjacencyArrayOut,[None] LPD3DXBUFFER* ppFaceRemapArrayOut,[None] LPD3DXBUFFER* ppVertRemapArrayOut)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSplitMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSplitMesh_(IntPtr pMeshIn, ref int pAdjacencyIn, int maxSize, int options, ref int pMeshesOut, out IntPtr ppMeshArrayOut, out IntPtr ppAdjacencyArrayOut, out IntPtr ppFaceRemapArrayOut, out IntPtr ppVertRemapArrayOut);		
        
        /// <summary>	
        /// Computes the intersection of a ray and a triangle.	
        /// </summary>	
        /// <remarks>	
        ///  The <see cref="SlimDX2.Direct3D9.D3DX9.Intersect"/> function provides a way to understand points in and around a triangle, independent of where the triangle is actually located. This function returns the resulting point by using the following equation: V1 + U(V2 - V1) + V(V3 - V1). Any point in the plane V1V2V3 can be represented by the barycentric coordinate (U,V). The parameter U controls how much V2 gets weighted into the result, and the parameter V controls how much V3 gets weighted into the result. Lastly, the value of [1 - (U + V)] controls how much V1 gets weighted into the result. Barycentric coordinates are a form of general coordinates. In this context, using barycentric coordinates represents a change in coordinate systems. What holds true for Cartesian coordinates holds true for barycentric coordinates. Barycentric coordinates define a point inside a triangle in terms of the triangle's vertices.  For a more in-depth description of barycentric coordinates, see {{Mathworld's Barycentric Coordinates Description}}. 	
        /// </remarks>	
        /// <param name="p0"> Pointer to a <see cref="SlimMath.Vector3"/> structure, describing the first triangle vertex position. </param>
        /// <param name="p1"> Pointer to a <see cref="SlimMath.Vector3"/> structure, describing the second triangle vertex position. </param>
        /// <param name="p2"> Pointer to a <see cref="SlimMath.Vector3"/> structure, describing the third triangle vertex position. </param>
        /// <param name="pRayPos"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the point where the ray begins. </param>
        /// <param name="pRayDir"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the direction of the ray. </param>
        /// <param name="pU"> Barycentric hit coordinates, U. </param>
        /// <param name="pV"> Barycentric hit coordinates, V. </param>
        /// <param name="pDist"> Ray-intersection parameter distance. </param>
        /// <returns> {{BOOL}} Returns TRUE if the ray intersects the area of the triangle. Otherwise, returns FALSE. </returns>
        /// <unmanaged>BOOL D3DXIntersectTri([None] const D3DXVECTOR3* p0,[None] const D3DXVECTOR3* p1,[None] const D3DXVECTOR3* p2,[None] const D3DXVECTOR3* pRayPos,[None] const D3DXVECTOR3* pRayDir,[None] FLOAT* pU,[None] FLOAT* pV,[None] FLOAT* pDist)</unmanaged>
		public static bool IntersectTri(ref SlimMath.Vector3 p0, ref SlimMath.Vector3 p1, ref SlimMath.Vector3 p2, ref SlimMath.Vector3 pRayPos, ref SlimMath.Vector3 pRayDir, ref float pU, ref float pV, ref float pDist) {
            unsafe {
                bool __result__;
                __result__= (bool)D3DXIntersectTri_(ref  p0, ref  p1, ref  p2, ref  pRayPos, ref  pRayDir, ref  pU, ref  pV, ref  pDist);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>BOOL D3DXIntersectTri([None] const D3DXVECTOR3* p0,[None] const D3DXVECTOR3* p1,[None] const D3DXVECTOR3* p2,[None] const D3DXVECTOR3* pRayPos,[None] const D3DXVECTOR3* pRayDir,[None] FLOAT* pU,[None] FLOAT* pV,[None] FLOAT* pDist)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXIntersectTri", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static bool D3DXIntersectTri_(ref SlimMath.Vector3 p0, ref SlimMath.Vector3 p1, ref SlimMath.Vector3 p2, ref SlimMath.Vector3 pRayPos, ref SlimMath.Vector3 pRayDir, ref float pU, ref float pV, ref float pDist);		
        
        /// <summary>	
        /// Determines if a ray intersects the volume of a sphere's bounding box.	
        /// </summary>	
        /// <remarks>	
        ///  D3DXSphereBoundProbe determines if the ray intersects the volume of the sphere's bounding box, not just the surface of the sphere. 	
        /// </remarks>	
        /// <param name="pCenter"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the center coordinate of the sphere. </param>
        /// <param name="radius"> Radius of the sphere. </param>
        /// <param name="pRayPosition"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the origin coordinate of the ray. </param>
        /// <param name="pRayDirection"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the direction of the ray. This vector should not be (0,0,0) but does not need to be normalized. </param>
        /// <returns> {{BOOL}} Returns TRUE if the ray intersects the volume of the sphere's bounding box. Otherwise, returns FALSE. </returns>
        /// <unmanaged>BOOL D3DXSphereBoundProbe([None] const D3DXVECTOR3* pCenter,[None] FLOAT Radius,[None] const D3DXVECTOR3* pRayPosition,[None] const D3DXVECTOR3* pRayDirection)</unmanaged>
		public static bool SphereBoundProbe(ref SlimMath.Vector3 pCenter, float radius, ref SlimMath.Vector3 pRayPosition, ref SlimMath.Vector3 pRayDirection) {
            unsafe {
                bool __result__;
                __result__= (bool)D3DXSphereBoundProbe_(ref  pCenter,  radius, ref  pRayPosition, ref  pRayDirection);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>BOOL D3DXSphereBoundProbe([None] const D3DXVECTOR3* pCenter,[None] FLOAT Radius,[None] const D3DXVECTOR3* pRayPosition,[None] const D3DXVECTOR3* pRayDirection)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSphereBoundProbe", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static bool D3DXSphereBoundProbe_(ref SlimMath.Vector3 pCenter, float radius, ref SlimMath.Vector3 pRayPosition, ref SlimMath.Vector3 pRayDirection);		
        
        /// <summary>	
        /// Determines whether a ray intersects the volume of a box's bounding box.	
        /// </summary>	
        /// <remarks>	
        ///  D3DXBoxBoundProbe determines if the ray intersects the volume of the box's bounding box, not just the surface of the box. The values passed to D3DXBoxBoundProbe are xmin, xmax, ymin, ymax, zmin, and zmax. Thus, the following defines the corners of the bounding box. 	
        /// <code> xmax, ymax, zmax	
        /// xmax, ymax, zmin	
        /// xmax, ymin, zmax	
        /// xmax, ymin, zmin	
        /// xmin, ymax, zmax	
        /// xmin, ymax, zmin	
        /// xmin, ymin, zmax	
        /// xmin, ymin, zmin </code>	
        /// 	
        ///  The depth of the bounding box in the z direction is zmax - zmin, in the y direction is ymax - ymin, and in the x direction is xmax - xmin. For example, with the following minimum and maximum vectors, min (-1, -1, -1) and max (1, 1, 1), the bounding box is defined in the following manner. 	
        /// <code> 1,  1,  1 1,  1, -1 1, -1,  1 1, -1, -1	
        /// -1,  1,  1	
        /// -1,  1, -1	
        /// -1, -1,  1	
        /// -1, -1, -l </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="pMin"> Pointer to a <see cref="SlimMath.Vector3"/>, describing the lower-left corner of the bounding box. See Remarks. </param>
        /// <param name="pMax"> Pointer to a  <see cref="SlimMath.Vector3"/> structure, describing the upper-right corner of the bounding box. See Remarks. </param>
        /// <param name="pRayPosition"> Pointer to a D3DXVECTOR3 structure, specifying the origin coordinate of the ray. </param>
        /// <param name="pRayDirection"> Pointer to a D3DXVECTOR3 structure, specifying the direction of the ray. This vector should not be (0,0,0) but does not need to be normalized. </param>
        /// <returns> {{BOOL}} Returns TRUE if the ray intersects the volume of the box's bounding box. Otherwise, returns FALSE. </returns>
        /// <unmanaged>BOOL D3DXBoxBoundProbe([None] const D3DXVECTOR3* pMin,[None] const D3DXVECTOR3* pMax,[None] const D3DXVECTOR3* pRayPosition,[None] const D3DXVECTOR3* pRayDirection)</unmanaged>
		public static bool BoxBoundProbe(ref SlimMath.Vector3 pMin, ref SlimMath.Vector3 pMax, ref SlimMath.Vector3 pRayPosition, ref SlimMath.Vector3 pRayDirection) {
            unsafe {
                bool __result__;
                __result__= (bool)D3DXBoxBoundProbe_(ref  pMin, ref  pMax, ref  pRayPosition, ref  pRayDirection);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>BOOL D3DXBoxBoundProbe([None] const D3DXVECTOR3* pMin,[None] const D3DXVECTOR3* pMax,[None] const D3DXVECTOR3* pRayPosition,[None] const D3DXVECTOR3* pRayDirection)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXBoxBoundProbe", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static bool D3DXBoxBoundProbe_(ref SlimMath.Vector3 pMin, ref SlimMath.Vector3 pMax, ref SlimMath.Vector3 pRayPosition, ref SlimMath.Vector3 pRayDirection);		
        
        /// <summary>	
        ///  Compute tangent, binormal, and normal vectors for a mesh.	
        /// </summary>	
        /// <remarks>	
        ///  This function simply calls <see cref="SlimDX2.Direct3D9.D3DX9.ComputeTangentFrameEx"/> with the following input parameters: 	
        /// <code> D3DXComputeTangentFrameEx(pMesh, D3DDECLUSAGE_TEXCOORD, 0,    D3DDECLUSAGE_BINORMAL, 0, D3DDECLUSAGE_TANGENT, 0,  D3DDECLUSAGE_NORMAL, 0,  dwOptions | D3DXTANGENT_GENERATE_IN_PLACE, NULL, 0.01f, 0.25f, 0.01f, NULL, NULL); </code>	
        /// 	
        ///  Singularities are handled as required by grouping edges and splitting vertices. If any vertices need to be split, the function will fail. The computed normal vector at each vertex is always normalized to have unit length. The most robust solution for computing orthogonal Cartesian coordinates is to not set flags D3DXTANGENT_ORTHOGONALIZE_FROM_U and D3DXTANGENT_ORTHOGONALIZE_FROM_V, so that orthogonal coordinates are computed from both UV texture coordinates. However, in this case, if either U or V is zero, then the function will compute orthogonal coordinates using D3DXTANGENT_ORTHOGONALIZE_FROM_V or D3DXTANGENT_ORTHOGONALIZE_FROM_U respectively. 	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an input <see cref="SlimDX2.Direct3D9.Mesh"/> mesh object. </param>
        /// <param name="dwOptions"> Combination of one or more <see cref="SlimDX2.Direct3D9.Tangent"/> flags.   Use NULL to specify the following options:  Weight the normal vector length by the angle, in radians, subtended by the two edges leaving the vertex. Compute orthogonal Cartesian coordinates from the UV texture coordinates. Textures are not wrapped in either U or V directions Partial derivatives with respect to texture coordinates are normalized. Vertices are ordered in a counterclockwise direction around each triangle. Use per-vertex normal vectors already present in the input mesh. The results will be stored in the original input mesh. The function will fail if new vertices need to be created.  </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXComputeTangentFrame([None] ID3DXMesh* pMesh,[None] int dwOptions)</unmanaged>
		public static SlimDX2.Result ComputeTangentFrame(SlimDX2.Direct3D9.Mesh pMesh, int dwOptions) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeTangentFrame_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  dwOptions);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeTangentFrame([None] ID3DXMesh* pMesh,[None] int dwOptions)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeTangentFrame", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeTangentFrame_(IntPtr pMesh, int dwOptions);		
        
        /// <summary>	
        /// Performs tangent frame computations on a mesh. Tangent, binormal, and optionally normal vectors are generated. Singularities are handled as required by grouping edges and splitting vertices.	
        /// </summary>	
        /// <remarks>	
        ///  A simplified version of this function is available as <see cref="SlimDX2.Direct3D9.D3DX9.ComputeTangentFrame"/>. The computed normal vector at each vertex is always normalized to have unit length. The most robust solution for computing orthogonal Cartesian coordinates is to not set flags D3DXTANGENT_ORTHOGONALIZE_FROM_U and D3DXTANGENT_ORTHOGONALIZE_FROM_V, so that orthogonal coordinates are computed from both texture coordinates u and v. However, in this case, if either u or v is zero, then the function will compute orthogonal coordinates using D3DXTANGENT_ORTHOGONALIZE_FROM_V or D3DXTANGENT_ORTHOGONALIZE_FROM_U, respectively. 	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an input <see cref="SlimDX2.Direct3D9.Mesh"/> mesh object. </param>
        /// <param name="dwTextureInSemantic"> Specifies the texture coordinate input semantic. If D3DX_DEFAULT, the function assumes that there are no texture coordinates, and the function will fail unless normal vector calculation is specified. </param>
        /// <param name="dwTextureInIndex"> If a mesh has multiple texture coordinates, specifies the texture coordinate to use for the tangent frame computations. If zero, the mesh has only a single texture coordinate. </param>
        /// <param name="dwUPartialOutSemantic"> Specifies the output semantic for the type, typically D3DDECLUSAGE_TANGENT, that describes where the partial derivative with respect to the U texture coordinate will be stored. If D3DX_DEFAULT, then this partial derivative will not be stored. </param>
        /// <param name="dwUPartialOutIndex"> Specifies the semantic index at which to store the partial derivative with respect to the U texture coordinate. </param>
        /// <param name="dwVPartialOutSemantic"> Specifies the <see cref="SlimDX2.Direct3D9.Declusage"/> type, typically D3DDECLUSAGE_BINORMAL, that describes where the partial derivative with respect to the V texture coordinate will be stored. If D3DX_DEFAULT, then this partial derivative will not be stored. </param>
        /// <param name="dwVPartialOutIndex"> Specifies the semantic index at which to store the partial derivative with respect to the V texture coordinate. </param>
        /// <param name="dwNormalOutSemantic"> Specifies the output normal semantic, typically D3DDECLUSAGE_NORMAL, that describes where the normal vector at each vertex will be stored. If D3DX_DEFAULT, then this normal vector will not be stored. </param>
        /// <param name="dwNormalOutIndex"> Specifies the semantic index at which to store the normal vector at each vertex. </param>
        /// <param name="dwOptions"> Combination of one or more <see cref="SlimDX2.Direct3D9.Tangent"/> flags that specify tangent frame computation options. If NULL, the following options will be specified:  Description <see cref="SlimDX2.Direct3D9.Tangent"/> Flag Value Weight the normal vector length by the angle, in radians, subtended by the two edges leaving the vertex.&amp; !( D3DXTANGENT_WEIGHT_BY_AREA | D3DXTANGENT_WEIGHT_EQUAL ) Compute orthogonal Cartesian coordinates from texture coordinates (u, v). See Remarks.&amp; !( D3DXTANGENT_ORTHOGONALIZE_FROM_U | D3DXTANGENT_ORTHOGONALIZE_FROM_V ) Textures are not wrapped in either u or v directions&amp; !( D3DXTANGENT_WRAP_UV ) Partial derivatives with respect to texture coordinates are normalized.&amp; !( D3DXTANGENT_DONT_NORMALIZE_PARTIALS ) Vertices are ordered in a counterclockwise direction around each triangle.&amp; !( D3DXTANGENT_WIND_CW ) Use per-vertex normal vectors already present in the input mesh.&amp; !( D3DXTANGENT_CALCULATE_NORMALS )    If D3DXTANGENT_GENERATE_IN_PLACE is not set, the input mesh is cloned. The original mesh must therefore have sufficient space to store the computed normal vector and partial derivative data. </param>
        /// <param name="pdwAdjacency"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh. The number of bytes in this array must be at least 3 * {{GetNumFaces}} * sizeof(DWORD). </param>
        /// <param name="fPartialEdgeThreshold"> Specifies the maximum cosine of the angle at which two partial derivatives are deemed to be incompatible with each other. If the dot product of the direction of the two partial derivatives in adjacent triangles is less than or equal to this threshold, then the vertices shared between these triangles will be split. </param>
        /// <param name="fSingularPointThreshold"> Specifies the maximum magnitude of a partial derivative at which a vertex will be deemed singular. As multiple triangles are incident on a point that have nearby tangent frames, but altogether cancel each other out (such as at the top of a sphere), the magnitude of the partial derivative will decrease. If the magnitude is less than or equal to this threshold, then the vertex will be split for every triangle that contains it. </param>
        /// <param name="fNormalEdgeThreshold"> Similar to fPartialEdgeThreshold, specifies the maximum cosine of the angle between two normals that is a threshold beyond which vertices shared between triangles will be split. If the dot product of the two normals is less than the threshold, the shared vertices will be split, forming a hard edge between neighboring triangles. If the dot product is more than the threshold, neighboring triangles will have their normals interpolated. </param>
        /// <param name="ppMeshOut"> Address of a pointer to an output <see cref="SlimDX2.Direct3D9.Mesh"/> mesh object that receives the computed tangent, binormal, and normal vector data. </param>
        /// <param name="ppVertexMapping"> Address of a pointer to an output <see cref="SlimDX2.Direct3D9.Buffer"/> buffer object that receives a mapping of new vertices computed by this method to the original vertices. The buffer is an array of DWORDs, with the array size defined as the number of vertices in ppMeshOut. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXComputeTangentFrameEx([None] ID3DXMesh* pMesh,[None] int dwTextureInSemantic,[None] int dwTextureInIndex,[None] int dwUPartialOutSemantic,[None] int dwUPartialOutIndex,[None] int dwVPartialOutSemantic,[None] int dwVPartialOutIndex,[None] int dwNormalOutSemantic,[None] int dwNormalOutIndex,[None] int dwOptions,[None] const int* pdwAdjacency,[None] FLOAT fPartialEdgeThreshold,[None] FLOAT fSingularPointThreshold,[None] FLOAT fNormalEdgeThreshold,[None] ID3DXMesh** ppMeshOut,[None] ID3DXBuffer** ppVertexMapping)</unmanaged>
		public static SlimDX2.Result ComputeTangentFrameEx(SlimDX2.Direct3D9.Mesh pMesh, int dwTextureInSemantic, int dwTextureInIndex, int dwUPartialOutSemantic, int dwUPartialOutIndex, int dwVPartialOutSemantic, int dwVPartialOutIndex, int dwNormalOutSemantic, int dwNormalOutIndex, int dwOptions, ref int pdwAdjacency, float fPartialEdgeThreshold, float fSingularPointThreshold, float fNormalEdgeThreshold, out SlimDX2.Direct3D9.Mesh ppMeshOut, out SlimDX2.Direct3D9.Buffer ppVertexMapping) {
            unsafe {
                IntPtr ppMeshOut_ = IntPtr.Zero;
                IntPtr ppVertexMapping_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeTangentFrameEx_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  dwTextureInSemantic,  dwTextureInIndex,  dwUPartialOutSemantic,  dwUPartialOutIndex,  dwVPartialOutSemantic,  dwVPartialOutIndex,  dwNormalOutSemantic,  dwNormalOutIndex,  dwOptions, ref  pdwAdjacency,  fPartialEdgeThreshold,  fSingularPointThreshold,  fNormalEdgeThreshold, out ppMeshOut_, out ppVertexMapping_);
                ppMeshOut = (ppMeshOut_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMeshOut_);
                ppVertexMapping = (ppVertexMapping_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppVertexMapping_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeTangentFrameEx([None] ID3DXMesh* pMesh,[None] int dwTextureInSemantic,[None] int dwTextureInIndex,[None] int dwUPartialOutSemantic,[None] int dwUPartialOutIndex,[None] int dwVPartialOutSemantic,[None] int dwVPartialOutIndex,[None] int dwNormalOutSemantic,[None] int dwNormalOutIndex,[None] int dwOptions,[None] const int* pdwAdjacency,[None] FLOAT fPartialEdgeThreshold,[None] FLOAT fSingularPointThreshold,[None] FLOAT fNormalEdgeThreshold,[None] ID3DXMesh** ppMeshOut,[None] ID3DXBuffer** ppVertexMapping)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeTangentFrameEx", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeTangentFrameEx_(IntPtr pMesh, int dwTextureInSemantic, int dwTextureInIndex, int dwUPartialOutSemantic, int dwUPartialOutIndex, int dwVPartialOutSemantic, int dwVPartialOutIndex, int dwNormalOutSemantic, int dwNormalOutIndex, int dwOptions, ref int pdwAdjacency, float fPartialEdgeThreshold, float fSingularPointThreshold, float fNormalEdgeThreshold, out IntPtr ppMeshOut, out IntPtr ppVertexMapping);		
        
        /// <summary>	
        /// Computes the tangent vectors for the texture coordinates given in the texture stage. Provided to support legacy applications. Use <see cref="SlimDX2.Direct3D9.D3DX9.ComputeTangentFrameEx"/> for better results.	
        /// </summary>	
        /// <remarks>	
        ///  If the mesh vertex declaration specifies tangent or binormal fields, D3DXComputeTangent will update any user-supplied tangent or binormal data. Alternatively, set TangentIndex to {{D3DX_DEFAULT}} to not update the user-supplied tangent data, or set BinormIndex to D3DX_DEFAULT to not update the user-supplied binormal data. TexStageIndex cannot be set to D3DX_DEFAULT. D3DXComputeTangent depends on the mesh vertex declaration containing either the binormal field (BinormIndex), the tangent field (TangentIndex), or both. If both are missing, this function will fail. This function simply calls <see cref="SlimDX2.Direct3D9.D3DX9.ComputeTangentFrameEx"/> with the following input parameters: 	
        /// <code> D3DXComputeTangentFrameEx( Mesh, D3DDECLUSAGE_TEXCOORD, TexStageIndex, ( BinormIndex == D3DX_DEFAULT ) ? D3DX_DEFAULT : D3DDECLUSAGE_BINORMAL, // provides backward function compatibility BinormIndex, ( TangentIndex == D3DX_DEFAULT ) ? D3DX_DEFAULT : D3DDECLUSAGE_TANGENT, TangentIndex, D3DX_DEFAULT, // do not store normals 0, ( Wrap ? D3DXTANGENT_WRAP_UV : 0 ) | D3DXTANGENT_GENERATE_IN_PLACE | D3DXTANGENT_ORTHOGONALIZE_FROM_U, pAdjacency, -1.01f, -0.01f, -1.01f, NULL, NULL); </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="mesh"> Pointer to an <see cref="SlimDX2.Direct3D9.Mesh"/> interface that represent the input mesh. </param>
        /// <param name="texStage"> Index that represents the texture stage. </param>
        /// <param name="tangentIndex"> Index that provides the usage index for the tangent data. The vertex declaration implies the usage; this index modifies the usage with the usage index. For more information about a vertex declaration, see {{Vertex Declaration (Direct3D 9)}}. </param>
        /// <param name="binormIndex"> Index that provides the usage index for the binormal data. The vertex declaration implies the usage; this index modifies the usage with the usage index. For more information about a vertex declaration, see {{Vertex Declaration (Direct3D 9)}}. </param>
        /// <param name="wrap"> Set this value to 0 for no wrapping, or to 1 for wrapping in the U and V directions. </param>
        /// <param name="pAdjacency"> Pointer to an array of three DWORDs per face to be filled with adjacent face indices. The number of bytes in this array must be at least ((3 * {{GetNumFaces}}) * sizeof(DWORD)). </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXComputeTangent([None] LPD3DXMESH Mesh,[None] int TexStage,[None] int TangentIndex,[None] int BinormIndex,[None] int Wrap,[None] const int* pAdjacency)</unmanaged>
		public static SlimDX2.Result ComputeTangent(SlimDX2.Direct3D9.Mesh mesh, int texStage, int tangentIndex, int binormIndex, int wrap, ref int pAdjacency) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeTangent_((mesh == null)?IntPtr.Zero:mesh.NativePointer,  texStage,  tangentIndex,  binormIndex,  wrap, ref  pAdjacency);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeTangent([None] LPD3DXMESH Mesh,[None] int TexStage,[None] int TangentIndex,[None] int BinormIndex,[None] int Wrap,[None] const int* pAdjacency)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeTangent", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeTangent_(IntPtr mesh, int texStage, int tangentIndex, int binormIndex, int wrap, ref int pAdjacency);		
        
        /// <summary>	
        /// Create a UV atlas for a mesh.	
        /// </summary>	
        /// <remarks>	
        ///  D3DXUVAtlasCreate can partition mesh geometry two ways:  Based on the number of charts Based on the maximum allowed stretch. If the maximum allowed stretch is 0, each triangle will likely be in its own chart.  	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an input mesh (see <see cref="SlimDX2.Direct3D9.Mesh"/>) which contains the object geometry for calculating the atlas. At a minimum, the mesh must contain position data and 2D texture coordinates. </param>
        /// <param name="uMaxChartNumber"> The maximum number of charts to partition the mesh into. See remarks about the partitioning modes. Use 0 to tell D3DX that the atlas should be parameterized based on stretch. </param>
        /// <param name="fMaxStretch"> The amount of stretching allowed. 0 means no stretching is allowed, 1 means any amount of stretching can be used. </param>
        /// <param name="uWidth"> Texture width. </param>
        /// <param name="uHeight"> Texture height. </param>
        /// <param name="fGutter"> The minimum distance, in texels, between two charts on the atlas. The gutter is always scaled by the width; so, if a gutter of 2.5 is used on a 512x512 texture, then the minimum distance between two charts is 2.5 / 512.0 texels. </param>
        /// <param name="dwTextureIndex"> Zero-based texture coordinate index that identifies which set of texture coordinates to use. </param>
        /// <param name="pdwAdjacency"> A pointer to an array of adjacency data. with 3 DWORDs per face, indicating which triangles are adjacent to each other (see <see cref="SlimDX2.Direct3D9.BaseMesh.GenerateAdjacency"/>). </param>
        /// <param name="pdwFalseEdgeAdjacency"> An array with 3 DWORDS per face. Each face indicates if an edge is false or not. A non-false edge is indicated by -1, a false edge is indicated by any other value. This enables the parameterization of a mesh of quads where the edges down the middle of each quad will not be cut. </param>
        /// <param name="pfIMTArray"> A pointer to an array of integrated metric tensors that describes how to stretch a triangle (see {{IntegratedMetricTensor}}). </param>
        /// <param name="pStatusCallback"> A pointer to a callback function (see <see cref="IntPtr"/>) that is useful for monitoring progress. </param>
        /// <param name="fCallbackFrequency"> Specify how often D3DX will call the callback; a reasonable default value is 0.0001f. </param>
        /// <param name="pUserContext"> Pointer to a user-defined value which is passed to the callback function; typically used by an application to pass a pointer to a data structure that provides context information for the callback function. </param>
        /// <param name="dwOptions"> Specify the quality of the charts generated. See <see cref="SlimDX2.Direct3D9.Uvatlas"/>. </param>
        /// <param name="ppMeshOut"> Pointer to the created mesh with the atlas (see <see cref="SlimDX2.Direct3D9.Mesh"/>). </param>
        /// <param name="ppFacePartitioning"> A pointer to an array of the final face-partitioning data. Each element contains one DWORD per face (see <see cref="SlimDX2.Direct3D9.Buffer"/>). </param>
        /// <param name="ppVertexRemapArray"> A pointer to an array of remapped vertices. Each array element identifies the original vertex that each final vertex came from (if the vertex was split during remapping). Each array element contains one DWORD per vertex. </param>
        /// <param name="pfMaxStretchOut"> A pointer to the maximum stretch value generated by the atlas algorithm. The range is between 0.0 and 1.0. </param>
        /// <param name="puNumChartsOut"> A pointer to the number of charts created by the atlas algorithm. If dwMaxChartNumber is too low, this parameter will return the minimum number of charts required to create an atlas. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK; otherwise, the value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXUVAtlasCreate([None] LPD3DXMESH pMesh,[None] UINT uMaxChartNumber,[None] FLOAT fMaxStretch,[None] UINT uWidth,[None] UINT uHeight,[None] FLOAT fGutter,[None] int dwTextureIndex,[None] const int* pdwAdjacency,[None] const int* pdwFalseEdgeAdjacency,[None] const FLOAT* pfIMTArray,[None] LPD3DXUVATLASCB pStatusCallback,[None] FLOAT fCallbackFrequency,[None] void* pUserContext,[None] int dwOptions,[None] LPD3DXMESH* ppMeshOut,[None] LPD3DXBUFFER* ppFacePartitioning,[None] LPD3DXBUFFER* ppVertexRemapArray,[None] FLOAT* pfMaxStretchOut,[None] UINT* puNumChartsOut)</unmanaged>
		public static SlimDX2.Result UVAtlasCreate(SlimDX2.Direct3D9.Mesh pMesh, int uMaxChartNumber, float fMaxStretch, int uWidth, int uHeight, float fGutter, int dwTextureIndex, ref int pdwAdjacency, ref int pdwFalseEdgeAdjacency, ref float pfIMTArray, IntPtr pStatusCallback, float fCallbackFrequency, IntPtr pUserContext, int dwOptions, out SlimDX2.Direct3D9.Mesh ppMeshOut, out SlimDX2.Direct3D9.Buffer ppFacePartitioning, out SlimDX2.Direct3D9.Buffer ppVertexRemapArray, ref float pfMaxStretchOut, ref int puNumChartsOut) {
            unsafe {
                IntPtr ppMeshOut_ = IntPtr.Zero;
                IntPtr ppFacePartitioning_ = IntPtr.Zero;
                IntPtr ppVertexRemapArray_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXUVAtlasCreate_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  uMaxChartNumber,  fMaxStretch,  uWidth,  uHeight,  fGutter,  dwTextureIndex, ref  pdwAdjacency, ref  pdwFalseEdgeAdjacency, ref  pfIMTArray,  pStatusCallback,  fCallbackFrequency,  pUserContext,  dwOptions, out ppMeshOut_, out ppFacePartitioning_, out ppVertexRemapArray_, ref  pfMaxStretchOut, ref  puNumChartsOut);
                ppMeshOut = (ppMeshOut_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMeshOut_);
                ppFacePartitioning = (ppFacePartitioning_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppFacePartitioning_);
                ppVertexRemapArray = (ppVertexRemapArray_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppVertexRemapArray_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXUVAtlasCreate([None] LPD3DXMESH pMesh,[None] UINT uMaxChartNumber,[None] FLOAT fMaxStretch,[None] UINT uWidth,[None] UINT uHeight,[None] FLOAT fGutter,[None] int dwTextureIndex,[None] const int* pdwAdjacency,[None] const int* pdwFalseEdgeAdjacency,[None] const FLOAT* pfIMTArray,[None] LPD3DXUVATLASCB pStatusCallback,[None] FLOAT fCallbackFrequency,[None] void* pUserContext,[None] int dwOptions,[None] LPD3DXMESH* ppMeshOut,[None] LPD3DXBUFFER* ppFacePartitioning,[None] LPD3DXBUFFER* ppVertexRemapArray,[None] FLOAT* pfMaxStretchOut,[None] UINT* puNumChartsOut)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXUVAtlasCreate", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXUVAtlasCreate_(IntPtr pMesh, int uMaxChartNumber, float fMaxStretch, int uWidth, int uHeight, float fGutter, int dwTextureIndex, ref int pdwAdjacency, ref int pdwFalseEdgeAdjacency, ref float pfIMTArray, IntPtr pStatusCallback, float fCallbackFrequency, IntPtr pUserContext, int dwOptions, out IntPtr ppMeshOut, out IntPtr ppFacePartitioning, out IntPtr ppVertexRemapArray, ref float pfMaxStretchOut, ref int puNumChartsOut);		
        
        /// <summary>	
        /// Create a UV atlas for a mesh.	
        /// </summary>	
        /// <remarks>	
        ///  D3DXUVAtlasPartition is similar to <see cref="SlimDX2.Direct3D9.D3DX9.UVAtlasCreate"/>, except that D3DXUVAtlasPartition does not performing the final packing step. 	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an input mesh (see <see cref="SlimDX2.Direct3D9.Mesh"/>) that contains the object geometry for calculating the atlas. At a minimum, the mesh must contain position data and 2D texture coordinates. </param>
        /// <param name="uMaxChartNumber"> The maximum number of charts to partition the mesh into. See remarks about the partitioning modes. Use 0 to tell D3DX that the atlas should be parameterized based on stretch. </param>
        /// <param name="fMaxStretch"> The amount of stretching allowed. 0 means no stretching is allowed, 1 means any amount of stretching can be used. </param>
        /// <param name="dwTextureIndex"> Zero-based texture coordinate index that identifies which set of texture coordinates to use. </param>
        /// <param name="pdwAdjacency"> A pointer to an array of adjacency data with 3 DWORDs per face, indicating which triangles are adjacent to each other (see <see cref="SlimDX2.Direct3D9.BaseMesh.GenerateAdjacency"/>). </param>
        /// <param name="pdwFalseEdgeAdjacency"> An array with 3 DWORDS per face. Each face indicates if an edge is false or not. A non-false edge is indicated by -1, a false edge is indicated by any other value. This enables the parameterization of a mesh of quads where the edges down the middle of each quad will not be cut. </param>
        /// <param name="pfIMTArray"> A pointer to an array of integrated metric tensors that describes how to stretch a triangle (see {{IntegratedMetricTensor}}). </param>
        /// <param name="pStatusCallback"> A pointer to a callback function (see <see cref="IntPtr"/>) that is useful for monitoring progress. </param>
        /// <param name="fCallbackFrequency"> Specify how often D3DX will call the callback; a reasonable default value is 0.0001f. </param>
        /// <param name="pUserContext"> Pointer to a user-defined value that is passed to the callback function; typically used by an application to pass a pointer to a data structure that provides context information for the callback function. </param>
        /// <param name="dwOptions"> Specify the quality of the charts generated by combining one or more <see cref="SlimDX2.Direct3D9.Uvatlas"/> flags. </param>
        /// <param name="ppMeshOut"> Pointer to the created mesh with the atlas (see <see cref="SlimDX2.Direct3D9.Mesh"/>). </param>
        /// <param name="ppFacePartitioning"> A pointer to an array of the final face-partitioning data. Each element contains one DWORD per face (see <see cref="SlimDX2.Direct3D9.Buffer"/>). </param>
        /// <param name="ppVertexRemapArray"> A pointer to an array of remapped vertices. Each array element identifies the original vertex each final vertex came from (if the vertex was split during remapping). Each array element contains one DWORD per vertex. </param>
        /// <param name="ppPartitionResultAdjacency"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface. This buffer will contain an array of three DWORDs per face that specify the three neighbors for each face in the output mesh. This parameter must not be NULL, because the subsequent call to D3DXUVAtlasPack() requires it. </param>
        /// <param name="pfMaxStretchOut"> A pointer to the maximum stretch value generated by the atlas algorithm. The range is between 0.0 and 1.0. </param>
        /// <param name="puNumChartsOut"> A pointer to the number of charts created by the atlas algorithm. If dwMaxChartNumber is too low, this parameter will return the minimum number of charts required to create an atlas. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK; otherwise, the value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXUVAtlasPartition([None] LPD3DXMESH pMesh,[None] UINT uMaxChartNumber,[None] FLOAT fMaxStretch,[None] int dwTextureIndex,[None] const int* pdwAdjacency,[None] const int* pdwFalseEdgeAdjacency,[None] const FLOAT* pfIMTArray,[None] LPD3DXUVATLASCB pStatusCallback,[None] FLOAT fCallbackFrequency,[None] void* pUserContext,[None] int dwOptions,[None] LPD3DXMESH* ppMeshOut,[None] LPD3DXBUFFER* ppFacePartitioning,[None] LPD3DXBUFFER* ppVertexRemapArray,[None] LPD3DXBUFFER* ppPartitionResultAdjacency,[None] FLOAT* pfMaxStretchOut,[None] UINT* puNumChartsOut)</unmanaged>
		public static SlimDX2.Result UVAtlasPartition(SlimDX2.Direct3D9.Mesh pMesh, int uMaxChartNumber, float fMaxStretch, int dwTextureIndex, ref int pdwAdjacency, ref int pdwFalseEdgeAdjacency, ref float pfIMTArray, IntPtr pStatusCallback, float fCallbackFrequency, IntPtr pUserContext, int dwOptions, out SlimDX2.Direct3D9.Mesh ppMeshOut, out SlimDX2.Direct3D9.Buffer ppFacePartitioning, out SlimDX2.Direct3D9.Buffer ppVertexRemapArray, out SlimDX2.Direct3D9.Buffer ppPartitionResultAdjacency, ref float pfMaxStretchOut, ref int puNumChartsOut) {
            unsafe {
                IntPtr ppMeshOut_ = IntPtr.Zero;
                IntPtr ppFacePartitioning_ = IntPtr.Zero;
                IntPtr ppVertexRemapArray_ = IntPtr.Zero;
                IntPtr ppPartitionResultAdjacency_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXUVAtlasPartition_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  uMaxChartNumber,  fMaxStretch,  dwTextureIndex, ref  pdwAdjacency, ref  pdwFalseEdgeAdjacency, ref  pfIMTArray,  pStatusCallback,  fCallbackFrequency,  pUserContext,  dwOptions, out ppMeshOut_, out ppFacePartitioning_, out ppVertexRemapArray_, out ppPartitionResultAdjacency_, ref  pfMaxStretchOut, ref  puNumChartsOut);
                ppMeshOut = (ppMeshOut_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMeshOut_);
                ppFacePartitioning = (ppFacePartitioning_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppFacePartitioning_);
                ppVertexRemapArray = (ppVertexRemapArray_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppVertexRemapArray_);
                ppPartitionResultAdjacency = (ppPartitionResultAdjacency_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppPartitionResultAdjacency_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXUVAtlasPartition([None] LPD3DXMESH pMesh,[None] UINT uMaxChartNumber,[None] FLOAT fMaxStretch,[None] int dwTextureIndex,[None] const int* pdwAdjacency,[None] const int* pdwFalseEdgeAdjacency,[None] const FLOAT* pfIMTArray,[None] LPD3DXUVATLASCB pStatusCallback,[None] FLOAT fCallbackFrequency,[None] void* pUserContext,[None] int dwOptions,[None] LPD3DXMESH* ppMeshOut,[None] LPD3DXBUFFER* ppFacePartitioning,[None] LPD3DXBUFFER* ppVertexRemapArray,[None] LPD3DXBUFFER* ppPartitionResultAdjacency,[None] FLOAT* pfMaxStretchOut,[None] UINT* puNumChartsOut)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXUVAtlasPartition", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXUVAtlasPartition_(IntPtr pMesh, int uMaxChartNumber, float fMaxStretch, int dwTextureIndex, ref int pdwAdjacency, ref int pdwFalseEdgeAdjacency, ref float pfIMTArray, IntPtr pStatusCallback, float fCallbackFrequency, IntPtr pUserContext, int dwOptions, out IntPtr ppMeshOut, out IntPtr ppFacePartitioning, out IntPtr ppVertexRemapArray, out IntPtr ppPartitionResultAdjacency, ref float pfMaxStretchOut, ref int puNumChartsOut);		
        
        /// <summary>	
        /// Pack mesh partitioning data into an atlas.	
        /// </summary>	
        /// <param name="pMesh"> Pointer to an input mesh (see <see cref="SlimDX2.Direct3D9.Mesh"/>) which contains the object geometry for calculating the atlas. At a minimum, the mesh must contain position data and 2D texture coordinates. </param>
        /// <param name="uWidth"> Texture width. </param>
        /// <param name="uHeight"> Texture height. </param>
        /// <param name="fGutter"> The minimum distance, in texels, between two charts on the atlas. The gutter is always scaled by the width; so, if a gutter of 2.5 is used on a 512x512 texture, then the minimum distance between two charts is 2.5 / 512.0 texels. </param>
        /// <param name="dwTextureIndex"> Zero-based texture coordinate index that identifies which set of texture coordinates to use. </param>
        /// <param name="pdwPartitionResultAdjacency"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh. It should be derived from the ppPartitionResultAdjacency returned from <see cref="SlimDX2.Direct3D9.D3DX9.UVAtlasPartition"/>. This value cannot be NULL, because Pack needs to know where charts were cut in the partition step in order to find the edges of each chart. </param>
        /// <param name="pStatusCallback"> A pointer to a callback function (see <see cref="IntPtr"/>) that is useful for monitoring progress. </param>
        /// <param name="fCallbackFrequency"> Specify how often D3DX will call the callback; a reasonable default value is 0.0001f. </param>
        /// <param name="pUserContext"> A void pointer to be passed back to the callback function. </param>
        /// <param name="dwOptions"> This options parameter is currently reserved. </param>
        /// <param name="pFacePartitioning"> A pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> containing the array of the final face-partitioning. Each element contains one DWORD per face. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK; otherwise, the value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXUVAtlasPack([None] ID3DXMesh* pMesh,[None] UINT uWidth,[None] UINT uHeight,[None] FLOAT fGutter,[None] int dwTextureIndex,[None] const int* pdwPartitionResultAdjacency,[None] LPD3DXUVATLASCB pStatusCallback,[None] FLOAT fCallbackFrequency,[None] void* pUserContext,[None] int dwOptions,[None] LPD3DXBUFFER pFacePartitioning)</unmanaged>
		public static SlimDX2.Result UVAtlasPack(SlimDX2.Direct3D9.Mesh pMesh, int uWidth, int uHeight, float fGutter, int dwTextureIndex, ref int pdwPartitionResultAdjacency, IntPtr pStatusCallback, float fCallbackFrequency, IntPtr pUserContext, int dwOptions, SlimDX2.Direct3D9.Buffer pFacePartitioning) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXUVAtlasPack_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  uWidth,  uHeight,  fGutter,  dwTextureIndex, ref  pdwPartitionResultAdjacency,  pStatusCallback,  fCallbackFrequency,  pUserContext,  dwOptions, (pFacePartitioning == null)?IntPtr.Zero:pFacePartitioning.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXUVAtlasPack([None] ID3DXMesh* pMesh,[None] UINT uWidth,[None] UINT uHeight,[None] FLOAT fGutter,[None] int dwTextureIndex,[None] const int* pdwPartitionResultAdjacency,[None] LPD3DXUVATLASCB pStatusCallback,[None] FLOAT fCallbackFrequency,[None] void* pUserContext,[None] int dwOptions,[None] LPD3DXBUFFER pFacePartitioning)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXUVAtlasPack", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXUVAtlasPack_(IntPtr pMesh, int uWidth, int uHeight, float fGutter, int dwTextureIndex, ref int pdwPartitionResultAdjacency, IntPtr pStatusCallback, float fCallbackFrequency, IntPtr pUserContext, int dwOptions, IntPtr pFacePartitioning);		
        
        /// <summary>	
        /// Calculate per-triangle IMT's from from per-vertex data. This function allows you to calculate the IMT based off of any value in a mesh (color, normal, etc).	
        /// </summary>	
        /// <param name="pMesh"> A pointer to an input mesh (see <see cref="SlimDX2.Direct3D9.Mesh"/>) which contains the object geometry for calculating the IMT. </param>
        /// <param name="pfVertexSignal"> A pointer to an array of per-vertex data from which IMT will be computed. The array size is  uSignalStride * v, where v is the number of vertices in the mesh. </param>
        /// <param name="uSignalDimension"> The number of floats per vertex. </param>
        /// <param name="uSignalStride"> The number of bytes per vertex in the array. This must be a multiple of sizeof(float) </param>
        /// <param name="dwOptions"> Texture wrap options. This is a combination of one or more {{D3DXIMT FLAGS}}. </param>
        /// <param name="pStatusCallback"> A pointer to a callback function to monitor IMT computation progress. </param>
        /// <param name="pUserContext"> A pointer to a user-defined variable which is passed to the status callback function. Typically used by an application to pass a pointer to a data structure that provides context information for the callback function. </param>
        /// <param name="ppIMTData"> A pointer to the buffer (see <see cref="SlimDX2.Direct3D9.Buffer"/>) containing the returned IMT array. This array can be provided as input to the D3DX {{UVAtlas Functions}} to prioritize texture-space allocation in the texture parameterization. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK; otherwise, the value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXComputeIMTFromPerVertexSignal([None] LPD3DXMESH pMesh,[None] const FLOAT* pfVertexSignal,[None] UINT uSignalDimension,[None] UINT uSignalStride,[None] int dwOptions,[None] LPD3DXUVATLASCB pStatusCallback,[None] void* pUserContext,[None] LPD3DXBUFFER* ppIMTData)</unmanaged>
		public static SlimDX2.Result ComputeIMTFromPerVertexSignal(SlimDX2.Direct3D9.Mesh pMesh, ref float pfVertexSignal, int uSignalDimension, int uSignalStride, int dwOptions, IntPtr pStatusCallback, IntPtr pUserContext, out SlimDX2.Direct3D9.Buffer ppIMTData) {
            unsafe {
                IntPtr ppIMTData_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeIMTFromPerVertexSignal_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  pfVertexSignal,  uSignalDimension,  uSignalStride,  dwOptions,  pStatusCallback,  pUserContext, out ppIMTData_);
                ppIMTData = (ppIMTData_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppIMTData_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeIMTFromPerVertexSignal([None] LPD3DXMESH pMesh,[None] const FLOAT* pfVertexSignal,[None] UINT uSignalDimension,[None] UINT uSignalStride,[None] int dwOptions,[None] LPD3DXUVATLASCB pStatusCallback,[None] void* pUserContext,[None] LPD3DXBUFFER* ppIMTData)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeIMTFromPerVertexSignal", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeIMTFromPerVertexSignal_(IntPtr pMesh, ref float pfVertexSignal, int uSignalDimension, int uSignalStride, int dwOptions, IntPtr pStatusCallback, IntPtr pUserContext, out IntPtr ppIMTData);		
        
        /// <summary>	
        /// Calculates per-triangle IMT's from a custom application-specified signal that varies over the surface of the mesh (generally at a higher frequency than vertex data). The signal is evaluated via a user-specified callback function.	
        /// </summary>	
        /// <remarks>	
        ///  This function requires that the input mesh contain a signal-to-mesh texture mapping (ie. texture coordinates). It allows the user to define a signal arbitrarily over the surface of the mesh. 	
        /// </remarks>	
        /// <param name="pMesh"> A pointer to an input mesh (see <see cref="SlimDX2.Direct3D9.Mesh"/>) which contains the object geometry for calculating the IMT. </param>
        /// <param name="dwTextureIndex"> Zero-based texture coordinate index that identifies which set of texture coordinates to use. </param>
        /// <param name="uSignalDimension"> The number of components in each data point in the signal. </param>
        /// <param name="fMaxUVDistance"> The maximum distance between vertices; the algorithm continues  subdividing until the distance between all vertices is less than or equal to fMaxUVDistance. </param>
        /// <param name="dwOptions"> Texture wrap options. This is a combination of one or more {{D3DXIMT FLAGS}}. </param>
        /// <param name="pSignalCallback"> A pointer to a user-provided evaluator function, which will be used to compute the signal value at arbitrary U,V coordinates. The function follows the prototype of <see cref="IntPtr"/>. </param>
        /// <param name="pUserData"> A pointer to a user-defined value which is passed to the signal callback function. Typically used by an application to pass a pointer to a data structure that provides context information for the callback function. </param>
        /// <param name="pStatusCallback"> A pointer to a callback function to monitor IMT computation progress. </param>
        /// <param name="pUserContext"> A pointer to a user-defined variable which is passed to the status callback function. Typically used by an application to pass a pointer to a data structure that provides context information for the callback function. </param>
        /// <param name="ppIMTData"> A pointer to the buffer (see <see cref="SlimDX2.Direct3D9.Buffer"/>) containing the returned IMT array. This array can be provided as input to the D3DX {{UVAtlas Functions}} to prioritize texture-space allocation in the texture parameterization. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK; otherwise, the value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXComputeIMTFromSignal([None] LPD3DXMESH pMesh,[None] int dwTextureIndex,[None] UINT uSignalDimension,[None] FLOAT fMaxUVDistance,[None] int dwOptions,[None] LPD3DXIMTSIGNALCALLBACK pSignalCallback,[None] VOID* pUserData,[None] LPD3DXUVATLASCB pStatusCallback,[None] void* pUserContext,[None] LPD3DXBUFFER* ppIMTData)</unmanaged>
		public static SlimDX2.Result ComputeIMTFromSignal(SlimDX2.Direct3D9.Mesh pMesh, int dwTextureIndex, int uSignalDimension, float fMaxUVDistance, int dwOptions, IntPtr pSignalCallback, IntPtr pUserData, IntPtr pStatusCallback, IntPtr pUserContext, out SlimDX2.Direct3D9.Buffer ppIMTData) {
            unsafe {
                IntPtr ppIMTData_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeIMTFromSignal_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  dwTextureIndex,  uSignalDimension,  fMaxUVDistance,  dwOptions,  pSignalCallback,  pUserData,  pStatusCallback,  pUserContext, out ppIMTData_);
                ppIMTData = (ppIMTData_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppIMTData_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeIMTFromSignal([None] LPD3DXMESH pMesh,[None] int dwTextureIndex,[None] UINT uSignalDimension,[None] FLOAT fMaxUVDistance,[None] int dwOptions,[None] LPD3DXIMTSIGNALCALLBACK pSignalCallback,[None] VOID* pUserData,[None] LPD3DXUVATLASCB pStatusCallback,[None] void* pUserContext,[None] LPD3DXBUFFER* ppIMTData)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeIMTFromSignal", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeIMTFromSignal_(IntPtr pMesh, int dwTextureIndex, int uSignalDimension, float fMaxUVDistance, int dwOptions, IntPtr pSignalCallback, IntPtr pUserData, IntPtr pStatusCallback, IntPtr pUserContext, out IntPtr ppIMTData);		
        
        /// <summary>	
        /// Calculates per-triangle IMT's from a texture mapped onto a mesh, to be used optionally as input to the D3DX {{UVAtlas Functions}}.	
        /// </summary>	
        /// <remarks>	
        ///  Given a texture that maps over the surface of the mesh, the algorithm computes the IMT for each face. This will cause triangles containing lower-frequency signal data to take up less space in the final texture atlas when parameterized with the UVAtlas functions. The texture is assumed to be interpolated over the mesh bilinearly. 	
        /// </remarks>	
        /// <param name="pMesh"> A pointer to an input mesh (see <see cref="SlimDX2.Direct3D9.Mesh"/>) which contains the object geometry for calculating the IMT. </param>
        /// <param name="pTexture"> A pointer to the texture (see <see cref="SlimDX2.Direct3D9.Texture"/>) that is mapped to the mesh. </param>
        /// <param name="dwTextureIndex"> Zero-based texture coordinate index that identifies which set of texture coordinates to use. </param>
        /// <param name="dwOptions"> Texture wrap options. This is a combination of one or more {{D3DXIMT FLAGS}}. </param>
        /// <param name="pStatusCallback"> A pointer to a callback function to monitor IMT computation progress. </param>
        /// <param name="pUserContext"> A pointer to a user-defined variable which is passed to the status callback function. Typically used by an application to pass a pointer to a data structure that provides context information for the callback function. </param>
        /// <param name="ppIMTData"> A pointer to the buffer (see <see cref="SlimDX2.Direct3D9.Buffer"/>) containing the returned IMT array. This array can be provided as input to the D3DX {{UVAtlas Functions}} to prioritize texture-space allocation in the texture parameterization. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK; otherwise, the value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXComputeIMTFromTexture([None] LPD3DXMESH pMesh,[None] LPDIRECT3DTEXTURE9 pTexture,[None] int dwTextureIndex,[None] int dwOptions,[None] LPD3DXUVATLASCB pStatusCallback,[None] void* pUserContext,[None] LPD3DXBUFFER* ppIMTData)</unmanaged>
		public static SlimDX2.Result ComputeIMTFromTexture(SlimDX2.Direct3D9.Mesh pMesh, SlimDX2.Direct3D9.Texture pTexture, int dwTextureIndex, int dwOptions, IntPtr pStatusCallback, IntPtr pUserContext, out SlimDX2.Direct3D9.Buffer ppIMTData) {
            unsafe {
                IntPtr ppIMTData_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeIMTFromTexture_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer, (pTexture == null)?IntPtr.Zero:pTexture.NativePointer,  dwTextureIndex,  dwOptions,  pStatusCallback,  pUserContext, out ppIMTData_);
                ppIMTData = (ppIMTData_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppIMTData_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeIMTFromTexture([None] LPD3DXMESH pMesh,[None] LPDIRECT3DTEXTURE9 pTexture,[None] int dwTextureIndex,[None] int dwOptions,[None] LPD3DXUVATLASCB pStatusCallback,[None] void* pUserContext,[None] LPD3DXBUFFER* ppIMTData)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeIMTFromTexture", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeIMTFromTexture_(IntPtr pMesh, IntPtr pTexture, int dwTextureIndex, int dwOptions, IntPtr pStatusCallback, IntPtr pUserContext, out IntPtr ppIMTData);		
        
        /// <summary>	
        /// Calculate per-triangle IMT's from per-texel data. This function is similar to <see cref="SlimDX2.Direct3D9.D3DX9.ComputeIMTFromTexture"/>, but it uses a float array to pass in the data, and it can calculate higher dimensional values than 4.	
        /// </summary>	
        /// <param name="pMesh"> A pointer to an input mesh (see <see cref="SlimDX2.Direct3D9.Mesh"/>) which contains the object geometry for calculating the IMT. </param>
        /// <param name="dwTextureIndex"> Zero-based texture coordinate index that identifies which set of texture coordinates to use. </param>
        /// <param name="pfTexelSignal"> A pointer to an array of input texels from which IMT will be computed. The array size is uWidth*uHeight*uComponents. </param>
        /// <param name="uWidth"> Texture width in pixels. </param>
        /// <param name="uHeight"> Texture height in pixels. </param>
        /// <param name="uSignalDimension"> The number of floats per-component in each element of the signal array. </param>
        /// <param name="uComponents"> The number of components in each texel. </param>
        /// <param name="dwOptions"> Texture wrap options. This is a combination of one or more {{D3DXIMT FLAGS}}. </param>
        /// <param name="pStatusCallback"> A pointer to a callback function to monitor IMT computation progress. </param>
        /// <param name="pUserContext"> A pointer to a user-defined variable which is passed to the status callback function. Typically used by an application to pass a pointer to a data structure that provides context information for the callback function. </param>
        /// <param name="ppIMTData"> A pointer to the buffer (see <see cref="SlimDX2.Direct3D9.Buffer"/>) containing the returned IMT array. This array can be provided as input to the D3DX {{UVAtlas Functions}} to prioritize texture-space allocation in the texture parameterization. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK; otherwise, the value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXComputeIMTFromPerTexelSignal([None] LPD3DXMESH pMesh,[None] int dwTextureIndex,[None] FLOAT* pfTexelSignal,[None] UINT uWidth,[None] UINT uHeight,[None] UINT uSignalDimension,[None] UINT uComponents,[None] int dwOptions,[None] LPD3DXUVATLASCB pStatusCallback,[None] void* pUserContext,[None] LPD3DXBUFFER* ppIMTData)</unmanaged>
		public static SlimDX2.Result ComputeIMTFromPerTexelSignal(SlimDX2.Direct3D9.Mesh pMesh, int dwTextureIndex, ref float pfTexelSignal, int uWidth, int uHeight, int uSignalDimension, int uComponents, int dwOptions, IntPtr pStatusCallback, IntPtr pUserContext, out SlimDX2.Direct3D9.Buffer ppIMTData) {
            unsafe {
                IntPtr ppIMTData_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeIMTFromPerTexelSignal_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  dwTextureIndex, ref  pfTexelSignal,  uWidth,  uHeight,  uSignalDimension,  uComponents,  dwOptions,  pStatusCallback,  pUserContext, out ppIMTData_);
                ppIMTData = (ppIMTData_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppIMTData_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeIMTFromPerTexelSignal([None] LPD3DXMESH pMesh,[None] int dwTextureIndex,[None] FLOAT* pfTexelSignal,[None] UINT uWidth,[None] UINT uHeight,[None] UINT uSignalDimension,[None] UINT uComponents,[None] int dwOptions,[None] LPD3DXUVATLASCB pStatusCallback,[None] void* pUserContext,[None] LPD3DXBUFFER* ppIMTData)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeIMTFromPerTexelSignal", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeIMTFromPerTexelSignal_(IntPtr pMesh, int dwTextureIndex, ref float pfTexelSignal, int uWidth, int uHeight, int uSignalDimension, int uComponents, int dwOptions, IntPtr pStatusCallback, IntPtr pUserContext, out IntPtr ppIMTData);		
        
        /// <summary>	
        /// Converts the specified mesh subset into a single triangle strip.	
        /// </summary>	
        /// <remarks>	
        ///  Before running this function, call {{Optimize}} or <see cref="SlimDX2.Direct3D9.D3DX9.OptimizeFaces"/>, with the D3DXMESHOPT_ATTRSORT flag set. 	
        /// </remarks>	
        /// <param name="meshIn"> Pointer to an <see cref="SlimDX2.Direct3D9.BaseMesh"/> interface, representing the mesh to convert to a strip. </param>
        /// <param name="attribId"> Attribute ID of the mesh subset to convert to strips. </param>
        /// <param name="iBOptions"> Combination of one or more flags from the {{D3DXMESH}} enumeration, specifying options for creating the index buffer. Cannot be D3DXMESH_32BIT. The index buffer will be created with 32-bit or 16-bit indices, depending on the format of the index buffer of the mesh specified by the MeshIn parameter. </param>
        /// <param name="ppIndexBuffer"> Pointer to an <see cref="SlimDX2.Direct3D9.IndexBuffer"/> interface, representing the index buffer containing the strip. </param>
        /// <param name="pNumIndices"> Number of indices in the buffer returned in the ppIndexBuffer parameter. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXConvertMeshSubsetToSingleStrip([None] LPD3DXBASEMESH MeshIn,[None] int AttribId,[None] int IBOptions,[None] LPDIRECT3DINDEXBUFFER9* ppIndexBuffer,[None] int* pNumIndices)</unmanaged>
		public static SlimDX2.Result ConvertMeshSubsetToSingleStrip(SlimDX2.Direct3D9.BaseMesh meshIn, int attribId, int iBOptions, out SlimDX2.Direct3D9.IndexBuffer ppIndexBuffer, ref int pNumIndices) {
            unsafe {
                IntPtr ppIndexBuffer_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXConvertMeshSubsetToSingleStrip_((meshIn == null)?IntPtr.Zero:meshIn.NativePointer,  attribId,  iBOptions, out ppIndexBuffer_, ref  pNumIndices);
                ppIndexBuffer = (ppIndexBuffer_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.IndexBuffer(ppIndexBuffer_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXConvertMeshSubsetToSingleStrip([None] LPD3DXBASEMESH MeshIn,[None] int AttribId,[None] int IBOptions,[None] LPDIRECT3DINDEXBUFFER9* ppIndexBuffer,[None] int* pNumIndices)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXConvertMeshSubsetToSingleStrip", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXConvertMeshSubsetToSingleStrip_(IntPtr meshIn, int attribId, int iBOptions, out IntPtr ppIndexBuffer, ref int pNumIndices);		
        
        /// <summary>	
        /// Convert the specified mesh subset into a series of strips.	
        /// </summary>	
        /// <remarks>	
        ///  Before running this function, call {{Optimize}} or <see cref="SlimDX2.Direct3D9.D3DX9.OptimizeFaces"/>, with the D3DXMESHOPT_ATTRSORT flag set. 	
        /// </remarks>	
        /// <param name="meshIn"> Pointer to an <see cref="SlimDX2.Direct3D9.BaseMesh"/> interface, representing the mesh to convert to a strip. </param>
        /// <param name="attribId"> Attribute ID of the mesh subset to convert to strips. </param>
        /// <param name="iBOptions"> Combination of one or more flags from the {{D3DXMESH}} enumeration, specifying options for creating the index buffer. Cannot be D3DXMESH_32BIT. The index buffer will be created with 32-bit or 16-bit indices depending on the format of the index buffer of the mesh specified by the MeshIn parameter. </param>
        /// <param name="ppIndexBuffer"> Pointer to an <see cref="SlimDX2.Direct3D9.IndexBuffer"/> interface, representing index buffer containing the strip. </param>
        /// <param name="pNumIndices"> Number of indices in the buffer returned in the ppIndexBuffer parameter. </param>
        /// <param name="ppStripLengths"> Buffer containing an array of one DWORD per strip, which specifies the number of triangles in the that strip. </param>
        /// <param name="pNumStrips"> Number of individual strips in the index buffer and corresponding strip length array. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXConvertMeshSubsetToStrips([None] LPD3DXBASEMESH MeshIn,[None] int AttribId,[None] int IBOptions,[None] LPDIRECT3DINDEXBUFFER9* ppIndexBuffer,[None] int* pNumIndices,[None] LPD3DXBUFFER* ppStripLengths,[None] int* pNumStrips)</unmanaged>
		public static SlimDX2.Result ConvertMeshSubsetToStrips(SlimDX2.Direct3D9.BaseMesh meshIn, int attribId, int iBOptions, out SlimDX2.Direct3D9.IndexBuffer ppIndexBuffer, ref int pNumIndices, out SlimDX2.Direct3D9.Buffer ppStripLengths, ref int pNumStrips) {
            unsafe {
                IntPtr ppIndexBuffer_ = IntPtr.Zero;
                IntPtr ppStripLengths_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXConvertMeshSubsetToStrips_((meshIn == null)?IntPtr.Zero:meshIn.NativePointer,  attribId,  iBOptions, out ppIndexBuffer_, ref  pNumIndices, out ppStripLengths_, ref  pNumStrips);
                ppIndexBuffer = (ppIndexBuffer_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.IndexBuffer(ppIndexBuffer_);
                ppStripLengths = (ppStripLengths_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppStripLengths_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXConvertMeshSubsetToStrips([None] LPD3DXBASEMESH MeshIn,[None] int AttribId,[None] int IBOptions,[None] LPDIRECT3DINDEXBUFFER9* ppIndexBuffer,[None] int* pNumIndices,[None] LPD3DXBUFFER* ppStripLengths,[None] int* pNumStrips)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXConvertMeshSubsetToStrips", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXConvertMeshSubsetToStrips_(IntPtr meshIn, int attribId, int iBOptions, out IntPtr ppIndexBuffer, ref int pNumIndices, out IntPtr ppStripLengths, ref int pNumStrips);		
        
        /// <summary>	
        /// Generates an optimized face remapping for a triangle list.	
        /// </summary>	
        /// <remarks>	
        ///  This function's optimization procedure is functionally equivalent to calling <see cref="SlimDX2.Direct3D9.Mesh.Optimize"/> with the D3DXMESHOPT_DEVICEINDEPENDENT flag, but this function makes more efficient use of vertex caches. 	
        /// </remarks>	
        /// <param name="pbIndices"> Pointer to triangle list indices to use for ordering vertices. </param>
        /// <param name="cFaces"> Number of faces in the triangle list. For 16-bit meshes, this is limited to 2^16 - 1 (65535) or fewer faces. </param>
        /// <param name="cVertices"> Number of vertices referenced by the triangle list. </param>
        /// <param name="b32BitIndices"> Flag indicating index type: TRUE if indices are 32-bit (more than 65535 indices), FALSE if indices are 16-bit (65535 or fewer indices). </param>
        /// <param name="pFaceRemap"> Pointer to the original mesh face that was split to generate the current face. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXOptimizeFaces([None] LPCVOID pbIndices,[None] UINT cFaces,[None] UINT cVertices,[None] BOOL b32BitIndices,[None] int* pFaceRemap)</unmanaged>
		public static SlimDX2.Result OptimizeFaces(IntPtr pbIndices, int cFaces, int cVertices, bool b32BitIndices, ref int pFaceRemap) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXOptimizeFaces_( pbIndices,  cFaces,  cVertices,  b32BitIndices, ref  pFaceRemap);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXOptimizeFaces([None] LPCVOID pbIndices,[None] UINT cFaces,[None] UINT cVertices,[None] BOOL b32BitIndices,[None] int* pFaceRemap)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXOptimizeFaces", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXOptimizeFaces_(IntPtr pbIndices, int cFaces, int cVertices, bool b32BitIndices, ref int pFaceRemap);		
        
        /// <summary>	
        /// Generates an optimized vertex remapping for a triangle list. This function is commonly used after applying the face remapping generated by <see cref="SlimDX2.Direct3D9.D3DX9.OptimizeFaces"/>.	
        /// </summary>	
        /// <remarks>	
        ///  By default, a mesh uses 16 bit indices when it is created unless the application specifies otherwise. To check whether an existing mesh uses 16-bit or 32-bit indices, call <see cref="SlimDX2.Direct3D9.BaseMesh.GetOptions"/> and check for the D3DXMESH_32BIT flag. 	
        /// </remarks>	
        /// <param name="pbIndices"> Pointer to triangle list indices to use for ordering vertices. </param>
        /// <param name="cFaces"> Number of faces in the triangle list. </param>
        /// <param name="cVertices"> Number of vertices referenced by the triangle list. </param>
        /// <param name="b32BitIndices"> Flag indicating index type: TRUE if indices are 32-bit (more than 65535 vertices), FALSE if indices are 16-bit (65535 or fewer vertices). </param>
        /// <param name="pVertexRemap"> Pointer to a destination buffer that will contain the new index for each vertex. The value stored in pVertexRemap for a given element is the source vertex location in the new vertex ordering. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXOptimizeVertices([None] LPCVOID pbIndices,[None] UINT cFaces,[None] UINT cVertices,[None] BOOL b32BitIndices,[None] int* pVertexRemap)</unmanaged>
		public static SlimDX2.Result OptimizeVertices(IntPtr pbIndices, int cFaces, int cVertices, bool b32BitIndices, ref int pVertexRemap) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXOptimizeVertices_( pbIndices,  cFaces,  cVertices,  b32BitIndices, ref  pVertexRemap);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXOptimizeVertices([None] LPCVOID pbIndices,[None] UINT cFaces,[None] UINT cVertices,[None] BOOL b32BitIndices,[None] int* pVertexRemap)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXOptimizeVertices", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXOptimizeVertices_(IntPtr pbIndices, int cFaces, int cVertices, bool b32BitIndices, ref int pVertexRemap);		
        
        /// <summary>	
        /// Creates a precomputed radiance transfer (PRT) buffer that can be compressed or filled by a simulator. This function should be used to create per-vertex or volume buffers.	
        /// </summary>	
        /// <remarks>	
        ///  When the buffer is created, all values are initialized to zero. 	
        /// </remarks>	
        /// <param name="numSamples"> Number of vertices (or texels) sampled. </param>
        /// <param name="numCoeffs"> Number of coefficients per sample location. When using spherical harmonic (SH) PRT, the number of coefficients should be Order2, where Order is the order of the SH evaluation. Order must be in the range of {{D3DXSH_MINORDER}} to D3DXSH_MAXORDER, inclusive. The degree of the evaluation is Order - 1. </param>
        /// <param name="numChannels"> Number of color channels to set in the mesh. Set to 1 to specify gray materials (R = G = B), or 3 to enable color bleeding effects. </param>
        /// <param name="ppBuffer"> Address of a pointer to the created <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of these: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreatePRTBuffer([None] UINT NumSamples,[None] UINT NumCoeffs,[None] UINT NumChannels,[None] LPD3DXPRTBUFFER* ppBuffer)</unmanaged>
		public static SlimDX2.Result CreatePRTBuffer(int numSamples, int numCoeffs, int numChannels, out SlimDX2.Direct3D9.PRTBuffer ppBuffer) {
            unsafe {
                IntPtr ppBuffer_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreatePRTBuffer_( numSamples,  numCoeffs,  numChannels, out ppBuffer_);
                ppBuffer = (ppBuffer_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PRTBuffer(ppBuffer_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreatePRTBuffer([None] UINT NumSamples,[None] UINT NumCoeffs,[None] UINT NumChannels,[None] LPD3DXPRTBUFFER* ppBuffer)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreatePRTBuffer", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreatePRTBuffer_(int numSamples, int numCoeffs, int numChannels, out IntPtr ppBuffer);		
        
        /// <summary>	
        /// Creates a precomputed radiance transfer (PRT) buffer that can be compressed or filled by a simulator. This function should be used to create per-pixel buffers.	
        /// </summary>	
        /// <remarks>	
        ///  When the buffer is created, all values are initialized to zero. 	
        /// </remarks>	
        /// <param name="width"> Width of the texture, in pixels. </param>
        /// <param name="height"> Height of the texture, in pixels. </param>
        /// <param name="numCoeffs"> Number of coefficients per sample location. When using spherical harmonic (SH) PRT, the number of coefficients should be Order2, where Order is the order of the SH evaluation. Order must be in the range of {{D3DXSH_MINORDER}} to D3DXSH_MAXORDER, inclusive. The degree of the evaluation is Order - 1. </param>
        /// <param name="numChannels"> Number of color channels to set in the mesh. Set to 1 to specify gray materials (R = G = B), or 3 to enable color bleeding effects. </param>
        /// <param name="ppBuffer"> Address of a pointer to the created <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreatePRTBufferTex([None] UINT Width,[None] UINT Height,[None] UINT NumCoeffs,[None] UINT NumChannels,[None] LPD3DXPRTBUFFER* ppBuffer)</unmanaged>
		public static SlimDX2.Result CreatePRTBufferTex(int width, int height, int numCoeffs, int numChannels, out SlimDX2.Direct3D9.PRTBuffer ppBuffer) {
            unsafe {
                IntPtr ppBuffer_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreatePRTBufferTex_( width,  height,  numCoeffs,  numChannels, out ppBuffer_);
                ppBuffer = (ppBuffer_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PRTBuffer(ppBuffer_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreatePRTBufferTex([None] UINT Width,[None] UINT Height,[None] UINT NumCoeffs,[None] UINT NumChannels,[None] LPD3DXPRTBUFFER* ppBuffer)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreatePRTBufferTex", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreatePRTBufferTex_(int width, int height, int numCoeffs, int numChannels, out IntPtr ppBuffer);		
        
        /// <summary>	
        /// Loads into memory a precomputed radiance transfer (PRT) buffer that was saved to disk.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXLoadPRTBufferFromFileW. Otherwise, the function call resolves to D3DXLoadPRTBufferFromFileA. 	
        /// </remarks>	
        /// <param name="pFilename"> Name of the file from which to load the buffer data. </param>
        /// <param name="ppBuffer"> Address of a pointer to the output <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXLoadPRTBufferFromFileA([None] const char* pFilename,[None] LPD3DXPRTBUFFER* ppBuffer)</unmanaged>
		public static SlimDX2.Result LoadPRTBufferFromFileA(string pFilename, out SlimDX2.Direct3D9.PRTBuffer ppBuffer) {
            unsafe {
                IntPtr ppBuffer_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadPRTBufferFromFileA_( pFilename, out ppBuffer_);
                ppBuffer = (ppBuffer_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PRTBuffer(ppBuffer_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadPRTBufferFromFileA([None] const char* pFilename,[None] LPD3DXPRTBUFFER* ppBuffer)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadPRTBufferFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadPRTBufferFromFileA_([MarshalAs(UnmanagedType.LPStr),In] string pFilename, out IntPtr ppBuffer);		
        
        /// <summary>	
        /// Loads into memory a precomputed radiance transfer (PRT) buffer that was saved to disk.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXLoadPRTBufferFromFileW. Otherwise, the function call resolves to D3DXLoadPRTBufferFromFileA. 	
        /// </remarks>	
        /// <param name="pFilename"> Name of the file from which to load the buffer data. </param>
        /// <param name="ppBuffer"> Address of a pointer to the output <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXLoadPRTBufferFromFileW([None] const wchar* pFilename,[None] LPD3DXPRTBUFFER* ppBuffer)</unmanaged>
		public static SlimDX2.Result LoadPRTBufferFromFileW(string pFilename, out SlimDX2.Direct3D9.PRTBuffer ppBuffer) {
            unsafe {
                IntPtr ppBuffer_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadPRTBufferFromFileW_( pFilename, out ppBuffer_);
                ppBuffer = (ppBuffer_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PRTBuffer(ppBuffer_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadPRTBufferFromFileW([None] const wchar* pFilename,[None] LPD3DXPRTBUFFER* ppBuffer)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadPRTBufferFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadPRTBufferFromFileW_([MarshalAs(UnmanagedType.LPWStr),In] string pFilename, out IntPtr ppBuffer);		
        
        /// <summary>	
        /// Saves a precomputed radiance transfer (PRT) buffer to disk.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXSavePRTBufferToFileW. Otherwise, the function call resolves to D3DXSavePRTBufferToFileA. 	
        /// </remarks>	
        /// <param name="pFileName"> Name of the file to which the buffer is to be saved. </param>
        /// <param name="pBuffer"> Address of a pointer to the input <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object. </param>
        /// <returns> <see cref="int"/> If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXSavePRTBufferToFileA([None] const char* pFileName,[None] LPD3DXPRTBUFFER pBuffer)</unmanaged>
		public static SlimDX2.Result SavePRTBufferToFileA(string pFileName, SlimDX2.Direct3D9.PRTBuffer pBuffer) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSavePRTBufferToFileA_( pFileName, (pBuffer == null)?IntPtr.Zero:pBuffer.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSavePRTBufferToFileA([None] const char* pFileName,[None] LPD3DXPRTBUFFER pBuffer)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSavePRTBufferToFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSavePRTBufferToFileA_([MarshalAs(UnmanagedType.LPStr),In] string pFileName, IntPtr pBuffer);		
        
        /// <summary>	
        /// Saves a precomputed radiance transfer (PRT) buffer to disk.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXSavePRTBufferToFileW. Otherwise, the function call resolves to D3DXSavePRTBufferToFileA. 	
        /// </remarks>	
        /// <param name="pFileName"> Name of the file to which the buffer is to be saved. </param>
        /// <param name="pBuffer"> Address of a pointer to the input <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object. </param>
        /// <returns> <see cref="int"/> If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXSavePRTBufferToFileW([None] const wchar* pFileName,[None] LPD3DXPRTBUFFER pBuffer)</unmanaged>
		public static SlimDX2.Result SavePRTBufferToFileW(string pFileName, SlimDX2.Direct3D9.PRTBuffer pBuffer) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSavePRTBufferToFileW_( pFileName, (pBuffer == null)?IntPtr.Zero:pBuffer.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSavePRTBufferToFileW([None] const wchar* pFileName,[None] LPD3DXPRTBUFFER pBuffer)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSavePRTBufferToFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSavePRTBufferToFileW_([MarshalAs(UnmanagedType.LPWStr),In] string pFileName, IntPtr pBuffer);		
        
        /// <summary>	
        /// Loads into memory a compressed precomputed radiance transfer (PRT) buffer that was saved to disk.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXLoadPRTCompBufferFromFileW. Otherwise, the function call resolves to D3DXLoadPRTCompBufferFromFileA. 	
        /// </remarks>	
        /// <param name="pFilename"> Name of the file from which to load the compressed buffer data. </param>
        /// <param name="ppBuffer"> Address of a pointer to the output <see cref="SlimDX2.Direct3D9.PRTCompBuffer"/> object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXLoadPRTCompBufferFromFileA([None] const char* pFilename,[None] LPD3DXPRTCOMPBUFFER* ppBuffer)</unmanaged>
		public static SlimDX2.Result LoadPRTCompBufferFromFileA(string pFilename, out SlimDX2.Direct3D9.PRTCompBuffer ppBuffer) {
            unsafe {
                IntPtr ppBuffer_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadPRTCompBufferFromFileA_( pFilename, out ppBuffer_);
                ppBuffer = (ppBuffer_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PRTCompBuffer(ppBuffer_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadPRTCompBufferFromFileA([None] const char* pFilename,[None] LPD3DXPRTCOMPBUFFER* ppBuffer)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadPRTCompBufferFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadPRTCompBufferFromFileA_([MarshalAs(UnmanagedType.LPStr),In] string pFilename, out IntPtr ppBuffer);		
        
        /// <summary>	
        /// Loads into memory a compressed precomputed radiance transfer (PRT) buffer that was saved to disk.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXLoadPRTCompBufferFromFileW. Otherwise, the function call resolves to D3DXLoadPRTCompBufferFromFileA. 	
        /// </remarks>	
        /// <param name="pFilename"> Name of the file from which to load the compressed buffer data. </param>
        /// <param name="ppBuffer"> Address of a pointer to the output <see cref="SlimDX2.Direct3D9.PRTCompBuffer"/> object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXLoadPRTCompBufferFromFileW([None] const wchar* pFilename,[None] LPD3DXPRTCOMPBUFFER* ppBuffer)</unmanaged>
		public static SlimDX2.Result LoadPRTCompBufferFromFileW(string pFilename, out SlimDX2.Direct3D9.PRTCompBuffer ppBuffer) {
            unsafe {
                IntPtr ppBuffer_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadPRTCompBufferFromFileW_( pFilename, out ppBuffer_);
                ppBuffer = (ppBuffer_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PRTCompBuffer(ppBuffer_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadPRTCompBufferFromFileW([None] const wchar* pFilename,[None] LPD3DXPRTCOMPBUFFER* ppBuffer)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadPRTCompBufferFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadPRTCompBufferFromFileW_([MarshalAs(UnmanagedType.LPWStr),In] string pFilename, out IntPtr ppBuffer);		
        
        /// <summary>	
        /// Saves a compressed precomputed radiance transfer (PRT) buffer to disk.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXSavePRTCompBufferToFileW. Otherwise, the function call resolves to D3DXSavePRTCompBufferToFileA. 	
        /// </remarks>	
        /// <param name="pFileName"> Name of the file to which the compressed buffer is to be saved. </param>
        /// <param name="pBuffer"> Address of a pointer to the input <see cref="SlimDX2.Direct3D9.PRTCompBuffer"/> object. </param>
        /// <returns> <see cref="int"/> If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXSavePRTCompBufferToFileA([None] const char* pFileName,[None] LPD3DXPRTCOMPBUFFER pBuffer)</unmanaged>
		public static SlimDX2.Result SavePRTCompBufferToFileA(string pFileName, SlimDX2.Direct3D9.PRTCompBuffer pBuffer) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSavePRTCompBufferToFileA_( pFileName, (pBuffer == null)?IntPtr.Zero:pBuffer.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSavePRTCompBufferToFileA([None] const char* pFileName,[None] LPD3DXPRTCOMPBUFFER pBuffer)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSavePRTCompBufferToFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSavePRTCompBufferToFileA_([MarshalAs(UnmanagedType.LPStr),In] string pFileName, IntPtr pBuffer);		
        
        /// <summary>	
        /// Saves a compressed precomputed radiance transfer (PRT) buffer to disk.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXSavePRTCompBufferToFileW. Otherwise, the function call resolves to D3DXSavePRTCompBufferToFileA. 	
        /// </remarks>	
        /// <param name="pFileName"> Name of the file to which the compressed buffer is to be saved. </param>
        /// <param name="pBuffer"> Address of a pointer to the input <see cref="SlimDX2.Direct3D9.PRTCompBuffer"/> object. </param>
        /// <returns> <see cref="int"/> If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXSavePRTCompBufferToFileW([None] const wchar* pFileName,[None] LPD3DXPRTCOMPBUFFER pBuffer)</unmanaged>
		public static SlimDX2.Result SavePRTCompBufferToFileW(string pFileName, SlimDX2.Direct3D9.PRTCompBuffer pBuffer) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSavePRTCompBufferToFileW_( pFileName, (pBuffer == null)?IntPtr.Zero:pBuffer.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSavePRTCompBufferToFileW([None] const wchar* pFileName,[None] LPD3DXPRTCOMPBUFFER pBuffer)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSavePRTCompBufferToFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSavePRTCompBufferToFileW_([MarshalAs(UnmanagedType.LPWStr),In] string pFileName, IntPtr pBuffer);		
        
        /// <summary>	
        /// Creates a compressed precomputed radiance transfer (PRT) buffer from an uncompressed <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object. This function should be used with per-vertex or volume buffers.	
        /// </summary>	
        /// <param name="quality"> Quality of spherical harmonic (SH) compression. See <see cref="SlimDX2.Direct3D9.Shcompressqualitytype"/>. </param>
        /// <param name="numClusters"> Number of clusters to use for compression. </param>
        /// <param name="numPCA"> Number of principal component analysis (PCA) basis vectors to use in each cluster. </param>
        /// <param name="pCB"> Optional pointer to the <see cref="IntPtr"/> callback function that is used to compute the percentage of PRT compression computations completed. The callback function must be implemented to return S_OK to keep running the compression routine. Any other value will halt compression. May be NULL. </param>
        /// <param name="lpUserContext"> Optional pointer to a user-defined value passed to the <see cref="IntPtr"/> callback function. Typically used by an application to pass a pointer to a data structure that provides context information for the callback function. May be NULL. </param>
        /// <param name="pBufferIn"> Address of a pointer to the uncompressed <see cref="SlimDX2.Direct3D9.PRTBuffer"/> object that will be compressed. </param>
        /// <param name="ppBufferOut"> Address of a pointer to the output <see cref="SlimDX2.Direct3D9.PRTCompBuffer"/> object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreatePRTCompBuffer([None] D3DXSHCOMPRESSQUALITYTYPE Quality,[None] UINT NumClusters,[None] UINT NumPCA,[None] LPD3DXSHPRTSIMCB pCB,[None] void* lpUserContext,[None] LPD3DXPRTBUFFER pBufferIn,[None] LPD3DXPRTCOMPBUFFER* ppBufferOut)</unmanaged>
		public static SlimDX2.Result CreatePRTCompBuffer(SlimDX2.Direct3D9.Shcompressqualitytype quality, int numClusters, int numPCA, IntPtr pCB, IntPtr lpUserContext, SlimDX2.Direct3D9.PRTBuffer pBufferIn, out SlimDX2.Direct3D9.PRTCompBuffer ppBufferOut) {
            unsafe {
                IntPtr ppBufferOut_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreatePRTCompBuffer_( quality,  numClusters,  numPCA,  pCB,  lpUserContext, (pBufferIn == null)?IntPtr.Zero:pBufferIn.NativePointer, out ppBufferOut_);
                ppBufferOut = (ppBufferOut_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PRTCompBuffer(ppBufferOut_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreatePRTCompBuffer([None] D3DXSHCOMPRESSQUALITYTYPE Quality,[None] UINT NumClusters,[None] UINT NumPCA,[None] LPD3DXSHPRTSIMCB pCB,[None] void* lpUserContext,[None] LPD3DXPRTBUFFER pBufferIn,[None] LPD3DXPRTCOMPBUFFER* ppBufferOut)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreatePRTCompBuffer", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreatePRTCompBuffer_(SlimDX2.Direct3D9.Shcompressqualitytype quality, int numClusters, int numPCA, IntPtr pCB, IntPtr lpUserContext, IntPtr pBufferIn, out IntPtr ppBufferOut);		
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct3D9.TextureGutterHelper"/> object from an input mesh and texture data.	
        /// </summary>	
        /// <remarks>	
        ///  Use <see cref="SlimDX2.Direct3D9.D3DX9.ConcatenateMeshes"/> to transform a scene to new coordinates. 	
        /// </remarks>	
        /// <param name="width"> Width of the texture, in pixels. </param>
        /// <param name="height"> Height of the texture, in pixels. </param>
        /// <param name="pMesh"> Pointer to an input <see cref="SlimDX2.Direct3D9.Mesh"/> mesh object. </param>
        /// <param name="gutterSize"> Number of texels by which to over-sample the texture and create the gutter region. Must be at least 1. </param>
        /// <param name="ppBuffer"> Pointer to an <see cref="SlimDX2.Direct3D9.TextureGutterHelper"/> object to be created. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of these: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureGutterHelper([None] UINT Width,[None] UINT Height,[None] LPD3DXMESH pMesh,[None] FLOAT GutterSize,[None] LPD3DXTEXTUREGUTTERHELPER* ppBuffer)</unmanaged>
		public static SlimDX2.Result CreateTextureGutterHelper(int width, int height, SlimDX2.Direct3D9.Mesh pMesh, float gutterSize, out SlimDX2.Direct3D9.TextureGutterHelper ppBuffer) {
            unsafe {
                IntPtr ppBuffer_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureGutterHelper_( width,  height, (pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  gutterSize, out ppBuffer_);
                ppBuffer = (ppBuffer_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.TextureGutterHelper(ppBuffer_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureGutterHelper([None] UINT Width,[None] UINT Height,[None] LPD3DXMESH pMesh,[None] FLOAT GutterSize,[None] LPD3DXTEXTUREGUTTERHELPER* ppBuffer)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureGutterHelper", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureGutterHelper_(int width, int height, IntPtr pMesh, float gutterSize, out IntPtr ppBuffer);		
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct3D9.PRTEngine"/> object that can efficiently generate precomputed radiance transfer (PRT) simulations of a 3D scene.	
        /// </summary>	
        /// <remarks>	
        ///  Use <see cref="SlimDX2.Direct3D9.D3DX9.ConcatenateMeshes"/> to combine multiple meshes into a single mesh interface. 	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an input <see cref="SlimDX2.Direct3D9.Mesh"/> mesh object that models the 3D scene. This mesh must have an attribute table in which vertices are in a unique attribute. </param>
        /// <param name="pAdjacency"> Optional pointer to an array of three DWORDs per face to be filled with adjacent face indices. The number of bytes in this array must be at least ((3 * {{GetNumFaces}}) * sizeof(DWORD)). May be NULL. </param>
        /// <param name="extractUVs"> If TRUE, textures will be used to store albedos or PRT vectors. </param>
        /// <param name="pBlockerMesh"> Pointer to an optional <see cref="SlimDX2.Direct3D9.Mesh"/> mesh object that blocks the 3D scene. May be NULL. </param>
        /// <param name="ppEngine"> Pointer to an output <see cref="SlimDX2.Direct3D9.PRTEngine"/> object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreatePRTEngine([None] LPD3DXMESH pMesh,[None] int* pAdjacency,[None] BOOL ExtractUVs,[None] LPD3DXMESH pBlockerMesh,[None] LPD3DXPRTENGINE* ppEngine)</unmanaged>
		public static SlimDX2.Result CreatePRTEngine(SlimDX2.Direct3D9.Mesh pMesh, ref int pAdjacency, bool extractUVs, SlimDX2.Direct3D9.Mesh pBlockerMesh, out SlimDX2.Direct3D9.PRTEngine ppEngine) {
            unsafe {
                IntPtr ppEngine_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreatePRTEngine_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  pAdjacency,  extractUVs, (pBlockerMesh == null)?IntPtr.Zero:pBlockerMesh.NativePointer, out ppEngine_);
                ppEngine = (ppEngine_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.PRTEngine(ppEngine_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreatePRTEngine([None] LPD3DXMESH pMesh,[None] int* pAdjacency,[None] BOOL ExtractUVs,[None] LPD3DXMESH pBlockerMesh,[None] LPD3DXPRTENGINE* ppEngine)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreatePRTEngine", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreatePRTEngine_(IntPtr pMesh, ref int pAdjacency, bool extractUVs, IntPtr pBlockerMesh, out IntPtr ppEngine);		
        
        /// <summary>	
        /// Concatenates a group of meshes into one common mesh. This method can optionally apply a matrix transformation to each input mesh and its texture coordinates.	
        /// </summary>	
        /// <remarks>	
        ///  If no {{vertex declaration}} is given as part of the Options mesh creation parameter, the method will generate a union of all of the vertex declarations of the submeshes, promoting channels and types if necessary. The method will create an attribute table from attribute tables of the input meshes. To ensure creation of an attribute table, call {{Optimize}} with Flags set to D3DXMESHOPT_COMPACT and D3DXMESHOPT_ATTRSORT (see {{D3DXMESHOPT}}). 	
        /// </remarks>	
        /// <param name="ppMeshes"> Array of input mesh pointers (see <see cref="SlimDX2.Direct3D9.Mesh"/>). The number of elements in the array is NumMeshes. </param>
        /// <param name="numMeshes"> Number of input meshes to concatenate. </param>
        /// <param name="options"> Mesh creation options; this is a combination of one or more {{D3DXMESH}} flags. The mesh creation options are equivalent to the options parameter required by <see cref="SlimDX2.Direct3D9.D3DX9.CreateMesh"/>. </param>
        /// <param name="pGeomXForms"> Optional array of geometry transforms. The number of elements in the array is NumMeshes; each element is a transformation matrix (see <see cref="SlimMath.Matrix"/>). May be NULL. </param>
        /// <param name="pTextureXForms"> Optional array of texture transforms. The number of elements in the array is NumMeshes; each element is a transformation matrix (see <see cref="SlimMath.Matrix"/>). This parameter may be NULL. </param>
        /// <param name="pDecl"> Optional pointer to a vertex declaration (see <see cref="SlimDX2.Direct3D9.Vertexelement9"/>). This parameter may be NULL. </param>
        /// <param name="pD3DDevice"> Pointer to a <see cref="SlimDX2.Direct3D9.Device"/> device that is used to create the new mesh. </param>
        /// <param name="ppMeshOut"> Address of a pointer to the mesh created (see <see cref="SlimDX2.Direct3D9.Mesh"/>). </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of these: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXConcatenateMeshes([None] LPD3DXMESH* ppMeshes,[None] UINT NumMeshes,[None] int Options,[None] const D3DXMATRIX* pGeomXForms,[None] const D3DXMATRIX* pTextureXForms,[None] const D3DVERTEXELEMENT9* pDecl,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXMESH* ppMeshOut)</unmanaged>
		public static SlimDX2.Result ConcatenateMeshes(out SlimDX2.Direct3D9.Mesh ppMeshes, int numMeshes, int options, ref SlimMath.Matrix pGeomXForms, ref SlimMath.Matrix pTextureXForms, ref SlimDX2.Direct3D9.Vertexelement9 pDecl, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.Mesh ppMeshOut) {
            unsafe {
                IntPtr ppMeshes_ = IntPtr.Zero;
                IntPtr ppMeshOut_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXConcatenateMeshes_(out ppMeshes_,  numMeshes,  options, ref  pGeomXForms, ref  pTextureXForms, ref  pDecl, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out ppMeshOut_);
                ppMeshes = (ppMeshes_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMeshes_);
                ppMeshOut = (ppMeshOut_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMeshOut_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXConcatenateMeshes([None] LPD3DXMESH* ppMeshes,[None] UINT NumMeshes,[None] int Options,[None] const D3DXMATRIX* pGeomXForms,[None] const D3DXMATRIX* pTextureXForms,[None] const D3DVERTEXELEMENT9* pDecl,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXMESH* ppMeshOut)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXConcatenateMeshes", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXConcatenateMeshes_(out IntPtr ppMeshes, int numMeshes, int options, ref SlimMath.Matrix pGeomXForms, ref SlimMath.Matrix pTextureXForms, ref SlimDX2.Direct3D9.Vertexelement9 pDecl, IntPtr pD3DDevice, out IntPtr ppMeshOut);		
        
        /// <summary>	
        /// Used with compressed results of the vertex version of the precomputed radiance transfer (PRT) simulator. Generates "superclusters," which are groups of clusters that can be drawn in the same draw call.  A greedy algorithm that minimizes overdraw is used to group the clusters.	
        /// </summary>	
        /// <param name="pClusterIDs"> Pointer to a NumVerts cluster IDs (extracted from a compressed buffer.) </param>
        /// <param name="pScene"> Pointer to a mesh that represents composite scene passed to the simulator. See <see cref="SlimDX2.Direct3D9.Mesh"/>. </param>
        /// <param name="maxNumClusters"> Maximum number of clusters allocated per super cluster. </param>
        /// <param name="numClusters"> Number of clusters computed in the simulator. </param>
        /// <param name="pSuperClusterIDs"> Pointer to an array of length NumClusters. Contains the index of the super cluster to which the corresponding cluster was assigned. </param>
        /// <param name="pNumSuperClusters"> Number of super clusters allocated. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXSHPRTCompSuperCluster([None] UINT* pClusterIDs,[None] LPD3DXMESH pScene,[None] UINT MaxNumClusters,[None] UINT NumClusters,[None] UINT* pSuperClusterIDs,[None] UINT* pNumSuperClusters)</unmanaged>
		public static SlimDX2.Result SHPRTCompSuperCluster(ref int pClusterIDs, SlimDX2.Direct3D9.Mesh pScene, int maxNumClusters, int numClusters, ref int pSuperClusterIDs, ref int pNumSuperClusters) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSHPRTCompSuperCluster_(ref  pClusterIDs, (pScene == null)?IntPtr.Zero:pScene.NativePointer,  maxNumClusters,  numClusters, ref  pSuperClusterIDs, ref  pNumSuperClusters);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSHPRTCompSuperCluster([None] UINT* pClusterIDs,[None] LPD3DXMESH pScene,[None] UINT MaxNumClusters,[None] UINT NumClusters,[None] UINT* pSuperClusterIDs,[None] UINT* pNumSuperClusters)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSHPRTCompSuperCluster", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSHPRTCompSuperCluster_(ref int pClusterIDs, IntPtr pScene, int maxNumClusters, int numClusters, ref int pSuperClusterIDs, ref int pNumSuperClusters);		
        
        /// <summary>	
        /// Used with compressed results of the vertex version of the precomputed radiance transfer (PRT) simulator. After <see cref="SlimDX2.Direct3D9.D3DX9.SHPRTCompSuperCluster"/> has been called, this function can be used to split the mesh into a group of faces/vertices per super cluster. Each super cluster contains all of the faces that contain any vertex classified in one of its clusters.  All of the vertices connected to this set of faces are also included with the returned array ppVertStatus indicating whether or not the vertex belongs to the super cluster.	
        /// </summary>	
        /// <param name="pClusterIDs"> NumVertices cluster IDs (extracted from a compressed buffer.) </param>
        /// <param name="numVertices"> Number of vertices in original mesh. </param>
        /// <param name="numClusters"> Number of clusters (input parameter to compression.) </param>
        /// <param name="pSuperClusterIDs"> Array of size NumCs that will contain super cluster IDs. </param>
        /// <param name="numSuperClusters"> Number of super clusters allocated in <see cref="SlimDX2.Direct3D9.D3DX9.SHPRTCompSuperCluster"/>. </param>
        /// <param name="pInputIB"> Raw index buffer for mesh. The format depends on InputIBIs32Bit. </param>
        /// <param name="inputIBIs32Bit"> If TRUE, the index buffer is set to 32 bit; otherwise, 16 bit. </param>
        /// <param name="numFaces"> Number of faces in the original mesh (pInputIB is 3 times this length.) </param>
        /// <param name="ppIBData"> Raw index buffer that will contain the resulting split faces.  Format determined by InputIBIs32Bit. Allocated by function. </param>
        /// <param name="pIBDataLength"> Length of ppIBData, assigned in function. </param>
        /// <param name="outputIBIs32Bit"> If TRUE, allocates an unsigned integer array; otherwise, allocates an unsigned short array. </param>
        /// <param name="ppFaceRemap"> Mapping of each face in ppIBData to original faces. Length is *pIBDataLength/3. </param>
        /// <param name="ppVertData"> New vertex data structure. Size of pVertDataLength. </param>
        /// <param name="pVertDataLength"> Number of new vertices in split mesh.  Assigned in function. </param>
        /// <param name="pSCClusterList"> Array of length NumCs which pSCData indexes into (pClusterIDs* fields) for each supercluster, contains clusters sorted by supercluster. </param>
        /// <param name="pSCData"> Structure per super cluster. Contains indices into ppIBData, pSCClusterList, and ppVertData. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXSHPRTCompSplitMeshSC([None] UINT* pClusterIDs,[None] UINT NumVertices,[None] UINT NumClusters,[None] UINT* pSuperClusterIDs,[None] UINT NumSuperClusters,[None] void* pInputIB,[None] BOOL InputIBIs32Bit,[None] UINT NumFaces,[None] LPD3DXBUFFER* ppIBData,[None] UINT* pIBDataLength,[None] BOOL OutputIBIs32Bit,[None] LPD3DXBUFFER* ppFaceRemap,[None] LPD3DXBUFFER* ppVertData,[None] UINT* pVertDataLength,[None] UINT* pSCClusterList,[None] D3DXSHPRTSPLITMESHCLUSTERDATA* pSCData)</unmanaged>
		public static SlimDX2.Result SHPRTCompSplitMeshSC(ref int pClusterIDs, int numVertices, int numClusters, ref int pSuperClusterIDs, int numSuperClusters, IntPtr pInputIB, bool inputIBIs32Bit, int numFaces, out SlimDX2.Direct3D9.Buffer ppIBData, ref int pIBDataLength, bool outputIBIs32Bit, out SlimDX2.Direct3D9.Buffer ppFaceRemap, out SlimDX2.Direct3D9.Buffer ppVertData, ref int pVertDataLength, ref int pSCClusterList, ref SlimDX2.Direct3D9.Shprtsplitmeshclusterdata pSCData) {
            unsafe {
                IntPtr ppIBData_ = IntPtr.Zero;
                IntPtr ppFaceRemap_ = IntPtr.Zero;
                IntPtr ppVertData_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSHPRTCompSplitMeshSC_(ref  pClusterIDs,  numVertices,  numClusters, ref  pSuperClusterIDs,  numSuperClusters,  pInputIB,  inputIBIs32Bit,  numFaces, out ppIBData_, ref  pIBDataLength,  outputIBIs32Bit, out ppFaceRemap_, out ppVertData_, ref  pVertDataLength, ref  pSCClusterList, ref  pSCData);
                ppIBData = (ppIBData_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppIBData_);
                ppFaceRemap = (ppFaceRemap_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppFaceRemap_);
                ppVertData = (ppVertData_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppVertData_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSHPRTCompSplitMeshSC([None] UINT* pClusterIDs,[None] UINT NumVertices,[None] UINT NumClusters,[None] UINT* pSuperClusterIDs,[None] UINT NumSuperClusters,[None] void* pInputIB,[None] BOOL InputIBIs32Bit,[None] UINT NumFaces,[None] LPD3DXBUFFER* ppIBData,[None] UINT* pIBDataLength,[None] BOOL OutputIBIs32Bit,[None] LPD3DXBUFFER* ppFaceRemap,[None] LPD3DXBUFFER* ppVertData,[None] UINT* pVertDataLength,[None] UINT* pSCClusterList,[None] D3DXSHPRTSPLITMESHCLUSTERDATA* pSCData)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSHPRTCompSplitMeshSC", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSHPRTCompSplitMeshSC_(ref int pClusterIDs, int numVertices, int numClusters, ref int pSuperClusterIDs, int numSuperClusters, IntPtr pInputIB, bool inputIBIs32Bit, int numFaces, out IntPtr ppIBData, ref int pIBDataLength, bool outputIBIs32Bit, out IntPtr ppFaceRemap, out IntPtr ppVertData, ref int pVertDataLength, ref int pSCClusterList, ref SlimDX2.Direct3D9.Shprtsplitmeshclusterdata pSCData);		
        
        /// <summary>	
        /// Assemble a shader.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXAssembleShaderFromFileW. Otherwise, the function call resolves to D3DXAssembleShaderFromFileA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="pDefines"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="ppShader"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="ppErrorMsgs"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXAssembleShaderFromFileA([None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result AssembleShaderFromFileA(string pSrcFile, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, int flags, out SlimDX2.Direct3D9.Buffer ppShader, out SlimDX2.Direct3D9.Buffer ppErrorMsgs) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppShader_ = IntPtr.Zero;
                IntPtr ppErrorMsgs_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXAssembleShaderFromFileA_( pSrcFile, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out ppShader_, out ppErrorMsgs_);
                ppShader = (ppShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppShader_);
                ppErrorMsgs = (ppErrorMsgs_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorMsgs_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXAssembleShaderFromFileA([None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXAssembleShaderFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXAssembleShaderFromFileA_([MarshalAs(UnmanagedType.LPStr),In] string pSrcFile, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, int flags, out IntPtr ppShader, out IntPtr ppErrorMsgs);		
        
        /// <summary>	
        /// Assemble a shader.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXAssembleShaderFromFileW. Otherwise, the function call resolves to D3DXAssembleShaderFromFileA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="pDefines"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="ppShader"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="ppErrorMsgs"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXAssembleShaderFromFileW([None] const wchar* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result AssembleShaderFromFileW(string pSrcFile, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, int flags, out SlimDX2.Direct3D9.Buffer ppShader, out SlimDX2.Direct3D9.Buffer ppErrorMsgs) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppShader_ = IntPtr.Zero;
                IntPtr ppErrorMsgs_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXAssembleShaderFromFileW_( pSrcFile, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out ppShader_, out ppErrorMsgs_);
                ppShader = (ppShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppShader_);
                ppErrorMsgs = (ppErrorMsgs_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorMsgs_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXAssembleShaderFromFileW([None] const wchar* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXAssembleShaderFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXAssembleShaderFromFileW_([MarshalAs(UnmanagedType.LPWStr),In] string pSrcFile, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, int flags, out IntPtr ppShader, out IntPtr ppErrorMsgs);		
        
        /// <summary>	
        /// Assemble a shader.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXAssembleShaderFromResourceW. Otherwise, the function call resolves to D3DXAssembleShaderFromResourceA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="pDefines"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="ppShader"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="ppErrorMsgs"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXAssembleShaderFromResourceA([None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result AssembleShaderFromResourceA(IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, int flags, out SlimDX2.Direct3D9.Buffer ppShader, out SlimDX2.Direct3D9.Buffer ppErrorMsgs) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppShader_ = IntPtr.Zero;
                IntPtr ppErrorMsgs_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXAssembleShaderFromResourceA_( hSrcModule,  pSrcResource, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out ppShader_, out ppErrorMsgs_);
                ppShader = (ppShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppShader_);
                ppErrorMsgs = (ppErrorMsgs_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorMsgs_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXAssembleShaderFromResourceA([None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXAssembleShaderFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXAssembleShaderFromResourceA_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string pSrcResource, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, int flags, out IntPtr ppShader, out IntPtr ppErrorMsgs);		
        
        /// <summary>	
        /// Assemble a shader.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXAssembleShaderFromResourceW. Otherwise, the function call resolves to D3DXAssembleShaderFromResourceA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="pDefines"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="ppShader"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="ppErrorMsgs"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXAssembleShaderFromResourceW([None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result AssembleShaderFromResourceW(IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, int flags, out SlimDX2.Direct3D9.Buffer ppShader, out SlimDX2.Direct3D9.Buffer ppErrorMsgs) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppShader_ = IntPtr.Zero;
                IntPtr ppErrorMsgs_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXAssembleShaderFromResourceW_( hSrcModule,  pSrcResource, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out ppShader_, out ppErrorMsgs_);
                ppShader = (ppShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppShader_);
                ppErrorMsgs = (ppErrorMsgs_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorMsgs_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXAssembleShaderFromResourceW([None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXAssembleShaderFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXAssembleShaderFromResourceW_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcResource, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, int flags, out IntPtr ppShader, out IntPtr ppErrorMsgs);		
        
        /// <summary>	
        /// Assemble a shader.	
        /// </summary>	
        /// <param name="pSrcData"> Pointer to a memory buffer that contains the shader data. </param>
        /// <param name="srcDataLen"> Length of the effect data, in bytes. </param>
        /// <param name="pDefines"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="ppShader"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information. </param>
        /// <param name="ppErrorMsgs"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXAssembleShader([None] const char* pSrcData,[None] UINT SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result AssembleShader(string pSrcData, int srcDataLen, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, int flags, out SlimDX2.Direct3D9.Buffer ppShader, out SlimDX2.Direct3D9.Buffer ppErrorMsgs) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppShader_ = IntPtr.Zero;
                IntPtr ppErrorMsgs_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXAssembleShader_( pSrcData,  srcDataLen, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out ppShader_, out ppErrorMsgs_);
                ppShader = (ppShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppShader_);
                ppErrorMsgs = (ppErrorMsgs_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorMsgs_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXAssembleShader([None] const char* pSrcData,[None] UINT SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXAssembleShader", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXAssembleShader_([MarshalAs(UnmanagedType.LPStr),In] string pSrcData, int srcDataLen, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, int flags, out IntPtr ppShader, out IntPtr ppErrorMsgs);		
        
        /// <summary>	
        /// Compile a shader file.	
        /// </summary>	
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. </param>
        /// <param name="pDefines"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="pFunctionName"> Pointer to the shader entry point function where execution begins. </param>
        /// <param name="pProfile"> Pointer to a shader profile which determines the shader instruction set. See {{D3DXGetVertexShaderProfile}} or {{D3DXGetPixelShaderProfile}} for a list of the profiles available. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="ppShader"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="ppErrorMsgs"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <param name="ppConstantTable"> Returns an <see cref="SlimDX2.Direct3D9.ConstantTable"/> interface, which can be used to access shader constants. This value can be NULL. If you compile your application as large address aware (that is, you use the /LARGEADDRESSAWARE linker option to handle addresses larger than 2 GB), you cannot use this parameter and must set it to NULL. Instead, you must use the <see cref="SlimDX2.Direct3D9.D3DX9.GetShaderConstantTableEx"/> function to retrieve the shader-constant table that is embedded inside the shader. In this D3DXGetShaderConstantTableEx call, you must pass the D3DXCONSTTABLE_LARGEADDRESSAWARE flag to the Flags parameter to specify to access up to 4 GB of virtual address space. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCompileShaderFromFileA([None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		public static SlimDX2.Result CompileShaderFromFileA(string pSrcFile, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, string pFunctionName, string pProfile, int flags, out SlimDX2.Direct3D9.Buffer ppShader, out SlimDX2.Direct3D9.Buffer ppErrorMsgs, out SlimDX2.Direct3D9.ConstantTable ppConstantTable) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppShader_ = IntPtr.Zero;
                IntPtr ppErrorMsgs_ = IntPtr.Zero;
                IntPtr ppConstantTable_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCompileShaderFromFileA_( pSrcFile, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  pFunctionName,  pProfile,  flags, out ppShader_, out ppErrorMsgs_, out ppConstantTable_);
                ppShader = (ppShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppShader_);
                ppErrorMsgs = (ppErrorMsgs_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorMsgs_);
                ppConstantTable = (ppConstantTable_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ConstantTable(ppConstantTable_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCompileShaderFromFileA([None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCompileShaderFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCompileShaderFromFileA_([MarshalAs(UnmanagedType.LPStr),In] string pSrcFile, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, [MarshalAs(UnmanagedType.LPStr),In] string pFunctionName, [MarshalAs(UnmanagedType.LPStr),In] string pProfile, int flags, out IntPtr ppShader, out IntPtr ppErrorMsgs, out IntPtr ppConstantTable);		
        
        /// <summary>	
        /// Compile a shader file.	
        /// </summary>	
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. </param>
        /// <param name="pDefines"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="pFunctionName"> Pointer to the shader entry point function where execution begins. </param>
        /// <param name="pProfile"> Pointer to a shader profile which determines the shader instruction set. See {{D3DXGetVertexShaderProfile}} or {{D3DXGetPixelShaderProfile}} for a list of the profiles available. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="ppShader"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="ppErrorMsgs"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <param name="ppConstantTable"> Returns an <see cref="SlimDX2.Direct3D9.ConstantTable"/> interface, which can be used to access shader constants. This value can be NULL. If you compile your application as large address aware (that is, you use the /LARGEADDRESSAWARE linker option to handle addresses larger than 2 GB), you cannot use this parameter and must set it to NULL. Instead, you must use the <see cref="SlimDX2.Direct3D9.D3DX9.GetShaderConstantTableEx"/> function to retrieve the shader-constant table that is embedded inside the shader. In this D3DXGetShaderConstantTableEx call, you must pass the D3DXCONSTTABLE_LARGEADDRESSAWARE flag to the Flags parameter to specify to access up to 4 GB of virtual address space. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCompileShaderFromFileW([None] const wchar* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		public static SlimDX2.Result CompileShaderFromFileW(string pSrcFile, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, string pFunctionName, string pProfile, int flags, out SlimDX2.Direct3D9.Buffer ppShader, out SlimDX2.Direct3D9.Buffer ppErrorMsgs, out SlimDX2.Direct3D9.ConstantTable ppConstantTable) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppShader_ = IntPtr.Zero;
                IntPtr ppErrorMsgs_ = IntPtr.Zero;
                IntPtr ppConstantTable_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCompileShaderFromFileW_( pSrcFile, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  pFunctionName,  pProfile,  flags, out ppShader_, out ppErrorMsgs_, out ppConstantTable_);
                ppShader = (ppShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppShader_);
                ppErrorMsgs = (ppErrorMsgs_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorMsgs_);
                ppConstantTable = (ppConstantTable_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ConstantTable(ppConstantTable_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCompileShaderFromFileW([None] const wchar* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCompileShaderFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCompileShaderFromFileW_([MarshalAs(UnmanagedType.LPWStr),In] string pSrcFile, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, [MarshalAs(UnmanagedType.LPWStr),In] string pFunctionName, [MarshalAs(UnmanagedType.LPWStr),In] string pProfile, int flags, out IntPtr ppShader, out IntPtr ppErrorMsgs, out IntPtr ppConstantTable);		
        
        /// <summary>	
        /// Compile a shader file.	
        /// </summary>	
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. </param>
        /// <param name="pDefines"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file, or will error when compiled from a resource or memory. </param>
        /// <param name="pFunctionName"> Pointer to the shader entry point function where execution begins. </param>
        /// <param name="pProfile"> Pointer to a shader profile which determines the shader instruction set. See {{D3DXGetVertexShaderProfile}} or {{D3DXGetPixelShaderProfile}} for a list of the profiles available. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="ppShader"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="ppErrorMsgs"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <param name="ppConstantTable"> Returns an <see cref="SlimDX2.Direct3D9.ConstantTable"/> interface, which can be used to access shader constants. This value can be NULL. If you compile your application as large address aware (that is, you use the /LARGEADDRESSAWARE linker option to handle addresses larger than 2 GB), you cannot use this parameter and must set it to NULL. Instead, you must use the <see cref="SlimDX2.Direct3D9.D3DX9.GetShaderConstantTableEx"/> function to retrieve the shader-constant table that is embedded inside the shader. In this D3DXGetShaderConstantTableEx call, you must pass the D3DXCONSTTABLE_LARGEADDRESSAWARE flag to the Flags parameter to specify to access up to 4 GB of virtual address space. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCompileShaderFromResourceA([None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		public static SlimDX2.Result CompileShaderFromResourceA(IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, string pFunctionName, string pProfile, int flags, out SlimDX2.Direct3D9.Buffer ppShader, out SlimDX2.Direct3D9.Buffer ppErrorMsgs, out SlimDX2.Direct3D9.ConstantTable ppConstantTable) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppShader_ = IntPtr.Zero;
                IntPtr ppErrorMsgs_ = IntPtr.Zero;
                IntPtr ppConstantTable_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCompileShaderFromResourceA_( hSrcModule,  pSrcResource, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  pFunctionName,  pProfile,  flags, out ppShader_, out ppErrorMsgs_, out ppConstantTable_);
                ppShader = (ppShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppShader_);
                ppErrorMsgs = (ppErrorMsgs_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorMsgs_);
                ppConstantTable = (ppConstantTable_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ConstantTable(ppConstantTable_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCompileShaderFromResourceA([None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCompileShaderFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCompileShaderFromResourceA_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string pSrcResource, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, [MarshalAs(UnmanagedType.LPStr),In] string pFunctionName, [MarshalAs(UnmanagedType.LPStr),In] string pProfile, int flags, out IntPtr ppShader, out IntPtr ppErrorMsgs, out IntPtr ppConstantTable);		
        
        /// <summary>	
        /// Compile a shader file.	
        /// </summary>	
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. </param>
        /// <param name="pDefines"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file, or will error when compiled from a resource or memory. </param>
        /// <param name="pFunctionName"> Pointer to the shader entry point function where execution begins. </param>
        /// <param name="pProfile"> Pointer to a shader profile which determines the shader instruction set. See {{D3DXGetVertexShaderProfile}} or {{D3DXGetPixelShaderProfile}} for a list of the profiles available. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="ppShader"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="ppErrorMsgs"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <param name="ppConstantTable"> Returns an <see cref="SlimDX2.Direct3D9.ConstantTable"/> interface, which can be used to access shader constants. This value can be NULL. If you compile your application as large address aware (that is, you use the /LARGEADDRESSAWARE linker option to handle addresses larger than 2 GB), you cannot use this parameter and must set it to NULL. Instead, you must use the <see cref="SlimDX2.Direct3D9.D3DX9.GetShaderConstantTableEx"/> function to retrieve the shader-constant table that is embedded inside the shader. In this D3DXGetShaderConstantTableEx call, you must pass the D3DXCONSTTABLE_LARGEADDRESSAWARE flag to the Flags parameter to specify to access up to 4 GB of virtual address space. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCompileShaderFromResourceW([None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		public static SlimDX2.Result CompileShaderFromResourceW(IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, string pFunctionName, string pProfile, int flags, out SlimDX2.Direct3D9.Buffer ppShader, out SlimDX2.Direct3D9.Buffer ppErrorMsgs, out SlimDX2.Direct3D9.ConstantTable ppConstantTable) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppShader_ = IntPtr.Zero;
                IntPtr ppErrorMsgs_ = IntPtr.Zero;
                IntPtr ppConstantTable_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCompileShaderFromResourceW_( hSrcModule,  pSrcResource, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  pFunctionName,  pProfile,  flags, out ppShader_, out ppErrorMsgs_, out ppConstantTable_);
                ppShader = (ppShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppShader_);
                ppErrorMsgs = (ppErrorMsgs_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorMsgs_);
                ppConstantTable = (ppConstantTable_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ConstantTable(ppConstantTable_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCompileShaderFromResourceW([None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCompileShaderFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCompileShaderFromResourceW_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcResource, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, [MarshalAs(UnmanagedType.LPWStr),In] string pFunctionName, [MarshalAs(UnmanagedType.LPWStr),In] string pProfile, int flags, out IntPtr ppShader, out IntPtr ppErrorMsgs, out IntPtr ppConstantTable);		
        
        /// <summary>	
        /// Compile a shader file.	
        /// </summary>	
        /// <param name="pSrcData"> Pointer to a string that contains the shader. </param>
        /// <param name="srcDataLen"> Length of the data in bytes. </param>
        /// <param name="pDefines"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="pFunctionName"> Pointer to a string that contains the name of the shader entry point function where execution begins. </param>
        /// <param name="pProfile"> Pointer to a shader profile which determines the shader instruction set. See {{D3DXGetVertexShaderProfile}} or {{D3DXGetPixelShaderProfile}} for a list of the profiles available. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="ppShader"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="ppErrorMsgs"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode.  This value may be NULL. </param>
        /// <param name="ppConstantTable"> Returns an <see cref="SlimDX2.Direct3D9.ConstantTable"/> interface, which can be used to access shader constants. This value can be NULL. If you compile your application as large address aware (that is, you use the /LARGEADDRESSAWARE linker option to handle addresses larger than 2 GB), you cannot use this parameter and must set it to NULL. Instead, you must use the <see cref="SlimDX2.Direct3D9.D3DX9.GetShaderConstantTableEx"/> function to retrieve the shader-constant table that is embedded inside the shader. In this D3DXGetShaderConstantTableEx call, you must pass the D3DXCONSTTABLE_LARGEADDRESSAWARE flag to the Flags parameter to specify to access up to 4 GB of virtual address space. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCompileShader([None] const char* pSrcData,[None] UINT SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		public static SlimDX2.Result CompileShader(string pSrcData, int srcDataLen, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, string pFunctionName, string pProfile, int flags, out SlimDX2.Direct3D9.Buffer ppShader, out SlimDX2.Direct3D9.Buffer ppErrorMsgs, out SlimDX2.Direct3D9.ConstantTable ppConstantTable) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppShader_ = IntPtr.Zero;
                IntPtr ppErrorMsgs_ = IntPtr.Zero;
                IntPtr ppConstantTable_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCompileShader_( pSrcData,  srcDataLen, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  pFunctionName,  pProfile,  flags, out ppShader_, out ppErrorMsgs_, out ppConstantTable_);
                ppShader = (ppShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppShader_);
                ppErrorMsgs = (ppErrorMsgs_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorMsgs_);
                ppConstantTable = (ppConstantTable_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ConstantTable(ppConstantTable_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCompileShader([None] const char* pSrcData,[None] UINT SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCompileShader", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCompileShader_([MarshalAs(UnmanagedType.LPStr),In] string pSrcData, int srcDataLen, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, [MarshalAs(UnmanagedType.LPStr),In] string pFunctionName, [MarshalAs(UnmanagedType.LPStr),In] string pProfile, int flags, out IntPtr ppShader, out IntPtr ppErrorMsgs, out IntPtr ppConstantTable);		
        
        /// <summary>	
        /// Disassemble a shader.	
        /// </summary>	
        /// <param name="pShader"> Pointer to a memory buffer that contains the shader data. </param>
        /// <param name="enableColorCode"> Enable color code to make it easier to read the disassembly. </param>
        /// <param name="pComments"> An optional NULL-terminated comment string. This value may be NULL. </param>
        /// <param name="ppDisassembly"> Returns a buffer containing the disassembled shader. See <see cref="SlimDX2.Direct3D9.Buffer"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXDisassembleShader([None] const int* pShader,[None] BOOL EnableColorCode,[None] const char* pComments,[None] LPD3DXBUFFER* ppDisassembly)</unmanaged>
		public static SlimDX2.Result DisassembleShader(ref int pShader, bool enableColorCode, string pComments, out SlimDX2.Direct3D9.Buffer ppDisassembly) {
            unsafe {
                IntPtr ppDisassembly_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXDisassembleShader_(ref  pShader,  enableColorCode,  pComments, out ppDisassembly_);
                ppDisassembly = (ppDisassembly_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppDisassembly_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXDisassembleShader([None] const int* pShader,[None] BOOL EnableColorCode,[None] const char* pComments,[None] LPD3DXBUFFER* ppDisassembly)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXDisassembleShader", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXDisassembleShader_(ref int pShader, bool enableColorCode, [MarshalAs(UnmanagedType.LPStr),In] string pComments, out IntPtr ppDisassembly);		
        
        /// <summary>	
        /// Searches through a shader for a particular comment. The comment is identified by a four-character code (FOURCC) in the first DWORD of the comment.	
        /// </summary>	
        /// <param name="pFunction"> Pointer to the shader function DWORD stream. </param>
        /// <param name="fourCC"> FOURCC code that identifies the comment block. See {{FourCC Formats}}. </param>
        /// <param name="ppData"> Returns a pointer to the comment data (not including the comment token and FOURCC code). This value can be NULL. </param>
        /// <param name="pSizeInBytes"> Returns the size of the comment data in bytes. This value can be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the comment is not found, and no other error has occurred, S_FALSE is returned. </returns>
        /// <unmanaged>HRESULT D3DXFindShaderComment([None] const int* pFunction,[None] int FourCC,[None] LPCVOID* ppData,[None] UINT* pSizeInBytes)</unmanaged>
		public static SlimDX2.Result FindShaderComment(ref int pFunction, int fourCC, IntPtr ppData, ref int pSizeInBytes) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFindShaderComment_(ref  pFunction,  fourCC,  ppData, ref  pSizeInBytes);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFindShaderComment([None] const int* pFunction,[None] int FourCC,[None] LPCVOID* ppData,[None] UINT* pSizeInBytes)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFindShaderComment", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFindShaderComment_(ref int pFunction, int fourCC, IntPtr ppData, ref int pSizeInBytes);		
        
        /// <summary>	
        /// Returns the size of the shader byte code, in bytes.	
        /// </summary>	
        /// <param name="pFunction"> Pointer to the function DWORD stream. </param>
        /// <returns> {{UINT}} Returns the size of the shader byte code, in bytes. </returns>
        /// <unmanaged>UINT D3DXGetShaderSize([None] const int* pFunction)</unmanaged>
		public static int GetShaderSize(ref int pFunction) {
            unsafe {
                int __result__;
                __result__= (int)D3DXGetShaderSize_(ref  pFunction);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>UINT D3DXGetShaderSize([None] const int* pFunction)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderSize", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DXGetShaderSize_(ref int pFunction);		
        
        /// <summary>	
        /// Returns the shader version of the compiled shader.	
        /// </summary>	
        /// <param name="pFunction"> Pointer to the function DWORD stream. </param>
        /// <returns> <see cref="int"/> Returns the shader version of the given shader, or zero if the shader  function is NULL. </returns>
        /// <unmanaged>int D3DXGetShaderVersion([None] const int* pFunction)</unmanaged>
		public static int GetShaderVersion(ref int pFunction) {
            unsafe {
                int __result__;
                __result__= (int)D3DXGetShaderVersion_(ref  pFunction);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>int D3DXGetShaderVersion([None] const int* pFunction)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderVersion", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DXGetShaderVersion_(ref int pFunction);		
        
        /// <summary>	
        /// Gets the semantics for the shader inputs. Use this method to determine the input vertex format.	
        /// </summary>	
        /// <remarks>	
        ///  Use D3DXGetShaderInputSemantics to return a list of input semantics required by the shader. This is the way to find out what the input vertex format is for a high-level shader language (HLSL) shader. If the shader has additional inputs that your vertex declaration is missing, you could create an extra vertex stream that has a stride of 0 that has the missing components with default values. For instance, this technique could be used to provide default vertex color for models that do not specify it. 	
        /// </remarks>	
        /// <param name="pFunction"> Pointer to the shader function DWORD stream. </param>
        /// <param name="pSemantics"> Pointer to an array of <see cref="SlimDX2.Direct3D9.Semantic"/> structures.  The function will fill this array with the semantics for each input element referenced by the shader. This array is assumed to contain at least MAXD3DDECLLENGTH elements. However, calling D3DXGetShaderInputSemantics with pSemantics = NULL will return the number of elements  needed for pCount. </param>
        /// <param name="pCount"> Returns the number of elements in pSemantics. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXGetShaderInputSemantics([None] const int* pFunction,[None] D3DXSEMANTIC* pSemantics,[None] UINT* pCount)</unmanaged>
		public static SlimDX2.Result GetShaderInputSemantics(ref int pFunction, ref SlimDX2.Direct3D9.Semantic pSemantics, ref int pCount) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetShaderInputSemantics_(ref  pFunction, ref  pSemantics, ref  pCount);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetShaderInputSemantics([None] const int* pFunction,[None] D3DXSEMANTIC* pSemantics,[None] UINT* pCount)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderInputSemantics", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetShaderInputSemantics_(ref int pFunction, ref SlimDX2.Direct3D9.Semantic pSemantics, ref int pCount);		
        
        /// <summary>	
        /// Get the semantics for all shader output elements.	
        /// </summary>	
        /// <param name="pFunction"> Pointer to the shader function DWORD stream. </param>
        /// <param name="pSemantics"> Pointer to an array of <see cref="SlimDX2.Direct3D9.Semantic"/> structures.  The function will fill this array with the semantics for each output element referenced by the shader.  This array is assumed to contain at least MAXD3DDECLLENGTH elements. However, calling D3DXGetShaderOutputSemantics with pSemantics = NULL will return the number of elements  needed for pCount. </param>
        /// <param name="pCount"> Returns the number of elements in pSemantics. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXGetShaderOutputSemantics([None] const int* pFunction,[None] D3DXSEMANTIC* pSemantics,[None] UINT* pCount)</unmanaged>
		public static SlimDX2.Result GetShaderOutputSemantics(ref int pFunction, ref SlimDX2.Direct3D9.Semantic pSemantics, ref int pCount) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetShaderOutputSemantics_(ref  pFunction, ref  pSemantics, ref  pCount);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetShaderOutputSemantics([None] const int* pFunction,[None] D3DXSEMANTIC* pSemantics,[None] UINT* pCount)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderOutputSemantics", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetShaderOutputSemantics_(ref int pFunction, ref SlimDX2.Direct3D9.Semantic pSemantics, ref int pCount);		
        
        /// <summary>	
        /// Get the sampler names referenced in a shader.	
        /// </summary>	
        /// <param name="pFunction"> Pointer to the shader function DWORD stream. </param>
        /// <param name="pSamplers"> Pointer to an array of LPCSTRs. The function will fill this array with pointers to the sampler names contained within pFunction. The maximum array size is the maximum number of sampler registers (16 for vs_3_0 and ps_3_0). To find the number of samplers used, check pCount after calling D3DXGetShaderSamplers with pSamplers = NULL. </param>
        /// <param name="pCount"> Returns the number of samplers referenced by the shader. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXGetShaderSamplers([None] const int* pFunction,[None] const char** pSamplers,[None] UINT* pCount)</unmanaged>
		public static SlimDX2.Result GetShaderSamplers(ref int pFunction, string pSamplers, ref int pCount) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetShaderSamplers_(ref  pFunction,  pSamplers, ref  pCount);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetShaderSamplers([None] const int* pFunction,[None] const char** pSamplers,[None] UINT* pCount)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderSamplers", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetShaderSamplers_(ref int pFunction, [MarshalAs(UnmanagedType.LPStr),In] string pSamplers, ref int pCount);		
        
        /// <summary>	
        /// Gets the shader-constant table embedded inside a shader.	
        /// </summary>	
        /// <remarks>	
        ///  A constant table is generated by <see cref="SlimDX2.Direct3D9.D3DX9.CompileShader"/> and embedded in the shader body. If you need additional virtual address space, see <see cref="SlimDX2.Direct3D9.D3DX9.GetShaderConstantTableEx"/>. 	
        /// </remarks>	
        /// <param name="pFunction"> Pointer to the function DWORD stream. </param>
        /// <param name="ppConstantTable"> Returns the constant table interface (see <see cref="SlimDX2.Direct3D9.ConstantTable"/>) that manages the constant table. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXGetShaderConstantTable([None] const int* pFunction,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		public static SlimDX2.Result GetShaderConstantTable(ref int pFunction, out SlimDX2.Direct3D9.ConstantTable ppConstantTable) {
            unsafe {
                IntPtr ppConstantTable_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetShaderConstantTable_(ref  pFunction, out ppConstantTable_);
                ppConstantTable = (ppConstantTable_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ConstantTable(ppConstantTable_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetShaderConstantTable([None] const int* pFunction,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderConstantTable", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetShaderConstantTable_(ref int pFunction, out IntPtr ppConstantTable);		
        
        /// <summary>	
        /// Gets the shader-constant table embedded inside a shader.	
        /// </summary>	
        /// <remarks>	
        ///  A constant table is generated by <see cref="SlimDX2.Direct3D9.D3DX9.CompileShader"/> and embedded in the shader body. 	
        /// </remarks>	
        /// <param name="pFunction"> Pointer to the function DWORD stream. </param>
        /// <param name="flags"> Use the D3DXCONSTTABLE_LARGEADDRESSAWARE flag to access up to 4 GB of virtual address space (instead of the default of 2 GB). If you do not need the additional virtual address space, use <see cref="SlimDX2.Direct3D9.D3DX9.GetShaderConstantTable"/>. </param>
        /// <param name="ppConstantTable"> Returns the constant table interface (see <see cref="SlimDX2.Direct3D9.ConstantTable"/>) that manages the constant table. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXGetShaderConstantTableEx([None] const int* pFunction,[None] int Flags,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		public static SlimDX2.Result GetShaderConstantTableEx(ref int pFunction, int flags, out SlimDX2.Direct3D9.ConstantTable ppConstantTable) {
            unsafe {
                IntPtr ppConstantTable_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetShaderConstantTableEx_(ref  pFunction,  flags, out ppConstantTable_);
                ppConstantTable = (ppConstantTable_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ConstantTable(ppConstantTable_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetShaderConstantTableEx([None] const int* pFunction,[None] int Flags,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderConstantTableEx", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetShaderConstantTableEx_(ref int pFunction, int flags, out IntPtr ppConstantTable);		
        
        /// <summary>	
        /// Creates a texture shader object from the compiled shader.	
        /// </summary>	
        /// <param name="pFunction"> Pointer to the function DWORD stream. </param>
        /// <param name="ppTextureShader"> Returns an <see cref="SlimDX2.Direct3D9.TextureShader"/> object which can be used to procedurally fill the contents of a texture using the <see cref="SlimDX2.Direct3D9.D3DX9.FillTextureTX"/> functions. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureShader([None] const int* pFunction,[None] LPD3DXTEXTURESHADER* ppTextureShader)</unmanaged>
		public static SlimDX2.Result CreateTextureShader(ref int pFunction, out SlimDX2.Direct3D9.TextureShader ppTextureShader) {
            unsafe {
                IntPtr ppTextureShader_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureShader_(ref  pFunction, out ppTextureShader_);
                ppTextureShader = (ppTextureShader_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.TextureShader(ppTextureShader_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureShader([None] const int* pFunction,[None] LPD3DXTEXTURESHADER* ppTextureShader)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureShader", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureShader_(ref int pFunction, out IntPtr ppTextureShader);		
        
        /// <summary>	
        /// Preprocesses a shader file without performing compilation. This resolves all #defines and #includes, providing a self-contained shader for subsequent compilation.	
        /// </summary>	
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename of the shader. </param>
        /// <param name="pDefines"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="ppShaderText"> Returns a buffer containing a single large string that represents the resulting formatted token stream. </param>
        /// <param name="ppErrorMsgs"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode.  This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromFileA([None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result PreprocessShaderFromFileA(string pSrcFile, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, out SlimDX2.Direct3D9.Buffer ppShaderText, out SlimDX2.Direct3D9.Buffer ppErrorMsgs) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppShaderText_ = IntPtr.Zero;
                IntPtr ppErrorMsgs_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXPreprocessShaderFromFileA_( pSrcFile, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer, out ppShaderText_, out ppErrorMsgs_);
                ppShaderText = (ppShaderText_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppShaderText_);
                ppErrorMsgs = (ppErrorMsgs_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorMsgs_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromFileA([None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXPreprocessShaderFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXPreprocessShaderFromFileA_([MarshalAs(UnmanagedType.LPStr),In] string pSrcFile, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, out IntPtr ppShaderText, out IntPtr ppErrorMsgs);		
        
        /// <summary>	
        /// Preprocesses a shader file without performing compilation. This resolves all #defines and #includes, providing a self-contained shader for subsequent compilation.	
        /// </summary>	
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename of the shader. </param>
        /// <param name="pDefines"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="ppShaderText"> Returns a buffer containing a single large string that represents the resulting formatted token stream. </param>
        /// <param name="ppErrorMsgs"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode.  This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromFileW([None] const wchar* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result PreprocessShaderFromFileW(string pSrcFile, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, out SlimDX2.Direct3D9.Buffer ppShaderText, out SlimDX2.Direct3D9.Buffer ppErrorMsgs) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppShaderText_ = IntPtr.Zero;
                IntPtr ppErrorMsgs_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXPreprocessShaderFromFileW_( pSrcFile, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer, out ppShaderText_, out ppErrorMsgs_);
                ppShaderText = (ppShaderText_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppShaderText_);
                ppErrorMsgs = (ppErrorMsgs_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorMsgs_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromFileW([None] const wchar* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXPreprocessShaderFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXPreprocessShaderFromFileW_([MarshalAs(UnmanagedType.LPWStr),In] string pSrcFile, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, out IntPtr ppShaderText, out IntPtr ppErrorMsgs);		
        
        /// <summary>	
        /// Preprocesses a shader resource without performing compilation. This resolves all #defines and #includes, providing a self-contained shader for subsequent compilation. 	
        /// </summary>	
        /// <param name="hSrcModule"> Handle to the module that holds the shader resource. If this value is NULL, the current module will be used. </param>
        /// <param name="pSrcResource"> String that represents the name of the resource in the module. </param>
        /// <param name="pDefines"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="ppShaderText"> Returns a buffer containing a single large string that represents the resulting formatted token stream. </param>
        /// <param name="ppErrorMsgs"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode.  This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromResourceA([None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result PreprocessShaderFromResourceA(IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, out SlimDX2.Direct3D9.Buffer ppShaderText, out SlimDX2.Direct3D9.Buffer ppErrorMsgs) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppShaderText_ = IntPtr.Zero;
                IntPtr ppErrorMsgs_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXPreprocessShaderFromResourceA_( hSrcModule,  pSrcResource, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer, out ppShaderText_, out ppErrorMsgs_);
                ppShaderText = (ppShaderText_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppShaderText_);
                ppErrorMsgs = (ppErrorMsgs_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorMsgs_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromResourceA([None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXPreprocessShaderFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXPreprocessShaderFromResourceA_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string pSrcResource, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, out IntPtr ppShaderText, out IntPtr ppErrorMsgs);		
        
        /// <summary>	
        /// Preprocesses a shader resource without performing compilation. This resolves all #defines and #includes, providing a self-contained shader for subsequent compilation. 	
        /// </summary>	
        /// <param name="hSrcModule"> Handle to the module that holds the shader resource. If this value is NULL, the current module will be used. </param>
        /// <param name="pSrcResource"> String that represents the name of the resource in the module. </param>
        /// <param name="pDefines"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="ppShaderText"> Returns a buffer containing a single large string that represents the resulting formatted token stream. </param>
        /// <param name="ppErrorMsgs"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode.  This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromResourceW([None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result PreprocessShaderFromResourceW(IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, out SlimDX2.Direct3D9.Buffer ppShaderText, out SlimDX2.Direct3D9.Buffer ppErrorMsgs) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppShaderText_ = IntPtr.Zero;
                IntPtr ppErrorMsgs_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXPreprocessShaderFromResourceW_( hSrcModule,  pSrcResource, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer, out ppShaderText_, out ppErrorMsgs_);
                ppShaderText = (ppShaderText_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppShaderText_);
                ppErrorMsgs = (ppErrorMsgs_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorMsgs_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromResourceW([None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXPreprocessShaderFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXPreprocessShaderFromResourceW_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcResource, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, out IntPtr ppShaderText, out IntPtr ppErrorMsgs);		
        
        /// <summary>	
        /// Preprocesses a shader without performing compilation. This resolves all #defines and #includes, providing a self-contained shader for subsequent compilation. 	
        /// </summary>	
        /// <param name="pSrcData"> Pointer to a string that contains the shader. </param>
        /// <param name="srcDataSize"> Length of the data in bytes. </param>
        /// <param name="pDefines"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="ppShaderText"> Returns a buffer containing a single large string that represents the resulting formatted token stream. </param>
        /// <param name="ppErrorMsgs"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode.  This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXPreprocessShader([None] const char* pSrcData,[None] UINT SrcDataSize,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result PreprocessShader(string pSrcData, int srcDataSize, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, out SlimDX2.Direct3D9.Buffer ppShaderText, out SlimDX2.Direct3D9.Buffer ppErrorMsgs) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppShaderText_ = IntPtr.Zero;
                IntPtr ppErrorMsgs_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXPreprocessShader_( pSrcData,  srcDataSize, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer, out ppShaderText_, out ppErrorMsgs_);
                ppShaderText = (ppShaderText_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppShaderText_);
                ppErrorMsgs = (ppErrorMsgs_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppErrorMsgs_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXPreprocessShader([None] const char* pSrcData,[None] UINT SrcDataSize,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXPreprocessShader", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXPreprocessShader_([MarshalAs(UnmanagedType.LPStr),In] string pSrcData, int srcDataSize, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, out IntPtr ppShaderText, out IntPtr ppErrorMsgs);		
        
        /// <summary>	
        /// Create an effect pool. A pool is used to share parameters between effects.	
        /// </summary>	
        /// <remarks>	
        ///  For effects within a pool, shared parameters with the same name share values.  	
        /// </remarks>	
        /// <param name="ppPool"> Returns a pointer to the created pool. </param>
        /// <returns> <see cref="int"/> If the method succeeds, the return value is S_OK. If the arguments are invalid, the method will return D3DERR_INVALIDCALL. If the method fails, the return value will be E_FAIL. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectPool([None] LPD3DXEFFECTPOOL* ppPool)</unmanaged>
		public static SlimDX2.Result CreateEffectPool(out SlimDX2.Direct3D9.EffectPool ppPool) {
            unsafe {
                IntPtr ppPool_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectPool_(out ppPool_);
                ppPool = (ppPool_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.EffectPool(ppPool_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectPool([None] LPD3DXEFFECTPOOL* ppPool)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectPool", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectPool_(out IntPtr ppPool);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description.	
        /// </summary>	
        /// <remarks>	
        ///  If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectFromFileW. Otherwise, the function call resolves to D3DXCreateEffectFromFileA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device that will create the effect. See <see cref="SlimDX2.Direct3D9.Device"/>. </param>
        /// <param name="pSrcFile"> Pointer to the filename. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="pDefines"> Optional NULL-terminated array of preprocessor macro definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> If pSrcFile contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, pSrcFile contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to a <see cref="SlimDX2.Direct3D9.EffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="ppEffect"> Returns a pointer to a buffer containing the compiled effect. See <see cref="SlimDX2.Direct3D9.Effect"/>. </param>
        /// <param name="ppCompilationErrors"> Returns a pointer to a buffer containing a listing of compile errors. See <see cref="SlimDX2.Direct3D9.Buffer"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result CreateEffectFromFileA(SlimDX2.Direct3D9.Device pDevice, string pSrcFile, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, int flags, SlimDX2.Direct3D9.EffectPool pPool, out SlimDX2.Direct3D9.Effect ppEffect, out SlimDX2.Direct3D9.Buffer ppCompilationErrors) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppEffect_ = IntPtr.Zero;
                IntPtr ppCompilationErrors_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectFromFileA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcFile, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out ppEffect_, out ppCompilationErrors_);
                ppEffect = (ppEffect_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Effect(ppEffect_);
                ppCompilationErrors = (ppCompilationErrors_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppCompilationErrors_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectFromFileA_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPStr),In] string pSrcFile, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, int flags, IntPtr pPool, out IntPtr ppEffect, out IntPtr ppCompilationErrors);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description.	
        /// </summary>	
        /// <remarks>	
        ///  If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectFromFileW. Otherwise, the function call resolves to D3DXCreateEffectFromFileA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device that will create the effect. See <see cref="SlimDX2.Direct3D9.Device"/>. </param>
        /// <param name="pSrcFile"> Pointer to the filename. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="pDefines"> Optional NULL-terminated array of preprocessor macro definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> If pSrcFile contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, pSrcFile contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to a <see cref="SlimDX2.Direct3D9.EffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="ppEffect"> Returns a pointer to a buffer containing the compiled effect. See <see cref="SlimDX2.Direct3D9.Effect"/>. </param>
        /// <param name="ppCompilationErrors"> Returns a pointer to a buffer containing a listing of compile errors. See <see cref="SlimDX2.Direct3D9.Buffer"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result CreateEffectFromFileW(SlimDX2.Direct3D9.Device pDevice, string pSrcFile, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, int flags, SlimDX2.Direct3D9.EffectPool pPool, out SlimDX2.Direct3D9.Effect ppEffect, out SlimDX2.Direct3D9.Buffer ppCompilationErrors) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppEffect_ = IntPtr.Zero;
                IntPtr ppCompilationErrors_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectFromFileW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcFile, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out ppEffect_, out ppCompilationErrors_);
                ppEffect = (ppEffect_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Effect(ppEffect_);
                ppCompilationErrors = (ppCompilationErrors_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppCompilationErrors_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectFromFileW_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcFile, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, int flags, IntPtr pPool, out IntPtr ppEffect, out IntPtr ppCompilationErrors);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description.	
        /// </summary>	
        /// <remarks>	
        ///  If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectFromResourceW. Otherwise, the function call resolves to D3DXCreateEffectFromResourceA because ANSI strings are being used. D3DXCreateEffectFromResource loads data from a resource of type RT_RCDATA. See MSDN for more information about Windows resources. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device. </param>
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="pSrcResource"> Pointer to the resource. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="pDefines"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> If hSrcModule contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, hSrcModule contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to a <see cref="SlimDX2.Direct3D9.EffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="ppEffect"> Returns a buffer containing the compiled effect. </param>
        /// <param name="ppCompilationErrors"> Returns a buffer containing a listing of compile errors. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceA([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result CreateEffectFromResourceA(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, int flags, SlimDX2.Direct3D9.EffectPool pPool, out SlimDX2.Direct3D9.Effect ppEffect, out SlimDX2.Direct3D9.Buffer ppCompilationErrors) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppEffect_ = IntPtr.Zero;
                IntPtr ppCompilationErrors_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectFromResourceA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  pSrcResource, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out ppEffect_, out ppCompilationErrors_);
                ppEffect = (ppEffect_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Effect(ppEffect_);
                ppCompilationErrors = (ppCompilationErrors_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppCompilationErrors_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceA([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectFromResourceA_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string pSrcResource, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, int flags, IntPtr pPool, out IntPtr ppEffect, out IntPtr ppCompilationErrors);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description.	
        /// </summary>	
        /// <remarks>	
        ///  If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectFromResourceW. Otherwise, the function call resolves to D3DXCreateEffectFromResourceA because ANSI strings are being used. D3DXCreateEffectFromResource loads data from a resource of type RT_RCDATA. See MSDN for more information about Windows resources. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device. </param>
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="pSrcResource"> Pointer to the resource. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="pDefines"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> If hSrcModule contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, hSrcModule contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to a <see cref="SlimDX2.Direct3D9.EffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="ppEffect"> Returns a buffer containing the compiled effect. </param>
        /// <param name="ppCompilationErrors"> Returns a buffer containing a listing of compile errors. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceW([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result CreateEffectFromResourceW(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, int flags, SlimDX2.Direct3D9.EffectPool pPool, out SlimDX2.Direct3D9.Effect ppEffect, out SlimDX2.Direct3D9.Buffer ppCompilationErrors) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppEffect_ = IntPtr.Zero;
                IntPtr ppCompilationErrors_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectFromResourceW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  pSrcResource, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out ppEffect_, out ppCompilationErrors_);
                ppEffect = (ppEffect_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Effect(ppEffect_);
                ppCompilationErrors = (ppCompilationErrors_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppCompilationErrors_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceW([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectFromResourceW_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcResource, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, int flags, IntPtr pPool, out IntPtr ppEffect, out IntPtr ppCompilationErrors);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to the device that will create the effect. See <see cref="SlimDX2.Direct3D9.Device"/>. </param>
        /// <param name="pSrcData"> Pointer to a buffer containing an effect description. </param>
        /// <param name="srcDataLen"> Length of the effect data, in bytes. </param>
        /// <param name="pDefines"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> If pSrcData contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, pSrcData contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to a <see cref="SlimDX2.Direct3D9.EffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="ppEffect"> Returns a pointer to an <see cref="SlimDX2.Direct3D9.Effect"/> interface. </param>
        /// <param name="ppCompilationErrors"> Returns a buffer containing a listing of compile errors. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffect([None] LPDIRECT3DDEVICE9 pDevice,[None] LPCVOID pSrcData,[None] UINT SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result CreateEffect(SlimDX2.Direct3D9.Device pDevice, IntPtr pSrcData, int srcDataLen, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, int flags, SlimDX2.Direct3D9.EffectPool pPool, out SlimDX2.Direct3D9.Effect ppEffect, out SlimDX2.Direct3D9.Buffer ppCompilationErrors) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppEffect_ = IntPtr.Zero;
                IntPtr ppCompilationErrors_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffect_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcData,  srcDataLen, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out ppEffect_, out ppCompilationErrors_);
                ppEffect = (ppEffect_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Effect(ppEffect_);
                ppCompilationErrors = (ppCompilationErrors_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppCompilationErrors_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffect([None] LPDIRECT3DDEVICE9 pDevice,[None] LPCVOID pSrcData,[None] UINT SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffect", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffect_(IntPtr pDevice, IntPtr pSrcData, int srcDataLen, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, int flags, IntPtr pPool, out IntPtr ppEffect, out IntPtr ppCompilationErrors);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description. This function is an extended version of {{D3DXCreateEffectFromFile}} that allows an application to control which parameters are ignored by the effects system.	
        /// </summary>	
        /// <remarks>	
        ///  This function is an extended version of {{D3DXCreateEffectFromFile}} that allows an application to specify which effect constants will be managed by the application. A constant that is managed by the application is ignored by the effects system. That is, the application is responsible for initializing the constant as well as saving and restoring its state whenever appropriate. This function checks each constant in pSkipConstants to see that:  It is bound to a constant register. It is only used in HLSL shader code.   If a constant is named in the string that is not present in the effect, it is ignored. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectFromFileW. Otherwise, the function call resolves to D3DXCreateEffectFromFileA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device that will create the effect. See <see cref="SlimDX2.Direct3D9.Device"/>. </param>
        /// <param name="pSrcFile"> Pointer to the filename. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="pDefines"> Optional NULL-terminated array of preprocessor macro definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="pSkipConstants"> A string of effect parameters that will be ignored by the effect system. The string must be NULL terminated, and needs to contain the name of each application-managed constant  separated by a semicolon. </param>
        /// <param name="flags"> If pSrcFile contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, pSrcFile contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to a <see cref="SlimDX2.Direct3D9.EffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="ppEffect"> Returns a pointer to a buffer containing the compiled effect. See <see cref="SlimDX2.Direct3D9.Effect"/>. </param>
        /// <param name="ppCompilationErrors"> Returns a pointer to a buffer containing a listing of compile errors. See <see cref="SlimDX2.Direct3D9.Buffer"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileExA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result CreateEffectFromFileExA(SlimDX2.Direct3D9.Device pDevice, string pSrcFile, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, string pSkipConstants, int flags, SlimDX2.Direct3D9.EffectPool pPool, out SlimDX2.Direct3D9.Effect ppEffect, out SlimDX2.Direct3D9.Buffer ppCompilationErrors) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppEffect_ = IntPtr.Zero;
                IntPtr ppCompilationErrors_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectFromFileExA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcFile, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  pSkipConstants,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out ppEffect_, out ppCompilationErrors_);
                ppEffect = (ppEffect_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Effect(ppEffect_);
                ppCompilationErrors = (ppCompilationErrors_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppCompilationErrors_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileExA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromFileExA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectFromFileExA_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPStr),In] string pSrcFile, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, [MarshalAs(UnmanagedType.LPStr),In] string pSkipConstants, int flags, IntPtr pPool, out IntPtr ppEffect, out IntPtr ppCompilationErrors);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description. This function is an extended version of {{D3DXCreateEffectFromFile}} that allows an application to control which parameters are ignored by the effects system.	
        /// </summary>	
        /// <remarks>	
        ///  This function is an extended version of {{D3DXCreateEffectFromFile}} that allows an application to specify which effect constants will be managed by the application. A constant that is managed by the application is ignored by the effects system. That is, the application is responsible for initializing the constant as well as saving and restoring its state whenever appropriate. This function checks each constant in pSkipConstants to see that:  It is bound to a constant register. It is only used in HLSL shader code.   If a constant is named in the string that is not present in the effect, it is ignored. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectFromFileW. Otherwise, the function call resolves to D3DXCreateEffectFromFileA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device that will create the effect. See <see cref="SlimDX2.Direct3D9.Device"/>. </param>
        /// <param name="pSrcFile"> Pointer to the filename. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="pDefines"> Optional NULL-terminated array of preprocessor macro definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="pSkipConstants"> A string of effect parameters that will be ignored by the effect system. The string must be NULL terminated, and needs to contain the name of each application-managed constant  separated by a semicolon. </param>
        /// <param name="flags"> If pSrcFile contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, pSrcFile contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to a <see cref="SlimDX2.Direct3D9.EffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="ppEffect"> Returns a pointer to a buffer containing the compiled effect. See <see cref="SlimDX2.Direct3D9.Effect"/>. </param>
        /// <param name="ppCompilationErrors"> Returns a pointer to a buffer containing a listing of compile errors. See <see cref="SlimDX2.Direct3D9.Buffer"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileExW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result CreateEffectFromFileExW(SlimDX2.Direct3D9.Device pDevice, string pSrcFile, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, string pSkipConstants, int flags, SlimDX2.Direct3D9.EffectPool pPool, out SlimDX2.Direct3D9.Effect ppEffect, out SlimDX2.Direct3D9.Buffer ppCompilationErrors) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppEffect_ = IntPtr.Zero;
                IntPtr ppCompilationErrors_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectFromFileExW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcFile, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  pSkipConstants,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out ppEffect_, out ppCompilationErrors_);
                ppEffect = (ppEffect_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Effect(ppEffect_);
                ppCompilationErrors = (ppCompilationErrors_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppCompilationErrors_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileExW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromFileExW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectFromFileExW_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcFile, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, [MarshalAs(UnmanagedType.LPWStr),In] string pSkipConstants, int flags, IntPtr pPool, out IntPtr ppEffect, out IntPtr ppCompilationErrors);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description. This is an extended version of {{D3DXCreateEffectFromResource}} that allows an application to control which parameters are ignored by the effects system.	
        /// </summary>	
        /// <remarks>	
        ///  This function is an extended version of {{D3DXCreateEffectFromResource}} that allows an application to specify which effect constants will be managed by the application. A constant that is managed by the application is ignored by the effects system. That is, the application is responsible for initializing the constant as well as saving and restoring its state whenever appropriate. This function checks each constant in pSkipConstants to see that:  It is bound to a constant register. It is only used in HLSL shader code.   If a constant is named in the string that is not present in the effect, it is ignored. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectFromResourceW. Otherwise, the function call resolves to D3DXCreateEffectFromResourceA because ANSI strings are being used. D3DXCreateEffectFromResource loads data from a resource of type RT_RCDATA. See MSDN for more information about Windows resources. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device. </param>
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="pSrcResource"> Pointer to the resource. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="pDefines"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="pSkipConstants"> A string of effect parameters that will be ignored by the effect system. The string must be NULL terminated, and needs to contain the name of each application-managed constant  separated by a semicolon. </param>
        /// <param name="flags"> If pSrcResource contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, pSrcResource contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to an <see cref="SlimDX2.Direct3D9.EffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="ppEffect"> Returns a buffer containing the compiled effect. </param>
        /// <param name="ppCompilationErrors"> Returns a buffer containing a listing of compile errors. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceExA([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result CreateEffectFromResourceExA(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, string pSkipConstants, int flags, SlimDX2.Direct3D9.EffectPool pPool, out SlimDX2.Direct3D9.Effect ppEffect, out SlimDX2.Direct3D9.Buffer ppCompilationErrors) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppEffect_ = IntPtr.Zero;
                IntPtr ppCompilationErrors_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectFromResourceExA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  pSrcResource, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  pSkipConstants,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out ppEffect_, out ppCompilationErrors_);
                ppEffect = (ppEffect_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Effect(ppEffect_);
                ppCompilationErrors = (ppCompilationErrors_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppCompilationErrors_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceExA([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromResourceExA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectFromResourceExA_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string pSrcResource, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, [MarshalAs(UnmanagedType.LPStr),In] string pSkipConstants, int flags, IntPtr pPool, out IntPtr ppEffect, out IntPtr ppCompilationErrors);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description. This is an extended version of {{D3DXCreateEffectFromResource}} that allows an application to control which parameters are ignored by the effects system.	
        /// </summary>	
        /// <remarks>	
        ///  This function is an extended version of {{D3DXCreateEffectFromResource}} that allows an application to specify which effect constants will be managed by the application. A constant that is managed by the application is ignored by the effects system. That is, the application is responsible for initializing the constant as well as saving and restoring its state whenever appropriate. This function checks each constant in pSkipConstants to see that:  It is bound to a constant register. It is only used in HLSL shader code.   If a constant is named in the string that is not present in the effect, it is ignored. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectFromResourceW. Otherwise, the function call resolves to D3DXCreateEffectFromResourceA because ANSI strings are being used. D3DXCreateEffectFromResource loads data from a resource of type RT_RCDATA. See MSDN for more information about Windows resources. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device. </param>
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="pSrcResource"> Pointer to the resource. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="pDefines"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="pSkipConstants"> A string of effect parameters that will be ignored by the effect system. The string must be NULL terminated, and needs to contain the name of each application-managed constant  separated by a semicolon. </param>
        /// <param name="flags"> If pSrcResource contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, pSrcResource contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to an <see cref="SlimDX2.Direct3D9.EffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="ppEffect"> Returns a buffer containing the compiled effect. </param>
        /// <param name="ppCompilationErrors"> Returns a buffer containing a listing of compile errors. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceExW([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result CreateEffectFromResourceExW(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, string pSkipConstants, int flags, SlimDX2.Direct3D9.EffectPool pPool, out SlimDX2.Direct3D9.Effect ppEffect, out SlimDX2.Direct3D9.Buffer ppCompilationErrors) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppEffect_ = IntPtr.Zero;
                IntPtr ppCompilationErrors_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectFromResourceExW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  pSrcResource, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  pSkipConstants,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out ppEffect_, out ppCompilationErrors_);
                ppEffect = (ppEffect_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Effect(ppEffect_);
                ppCompilationErrors = (ppCompilationErrors_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppCompilationErrors_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceExW([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromResourceExW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectFromResourceExW_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcResource, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, [MarshalAs(UnmanagedType.LPWStr),In] string pSkipConstants, int flags, IntPtr pPool, out IntPtr ppEffect, out IntPtr ppCompilationErrors);		
        
        /// <summary>	
        /// Creates an effect from an ASCII or binary effect description. This function is an extended version of <see cref="SlimDX2.Direct3D9.D3DX9.CreateEffect"/> that allows an application to control which parameters are ignored by the effects system.	
        /// </summary>	
        /// <remarks>	
        ///  This function is an extended version of <see cref="SlimDX2.Direct3D9.D3DX9.CreateEffect"/> that allows an application to specify which effect constants will be managed by the application. A constant that is managed by the application is ignored by the effects system. That is, the application is responsible for initializing the constant as well as saving and restoring its state whenever appropriate. This function checks each constant in pSkipConstants to see that:  It is bound to a constant register. It is only used in HLSL shader code.   If a constant is named in the string that is not present in the effect, it is ignored. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device that will create the effect. See <see cref="SlimDX2.Direct3D9.Device"/>. </param>
        /// <param name="pSrcData"> Pointer to a buffer containing an effect description. </param>
        /// <param name="srcDataLen"> Length of the effect data, in bytes. </param>
        /// <param name="pDefines"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="pSkipConstants"> A string of effect parameters that will be ignored by the effect system. The string must be NULL terminated, and needs to contain the name of each application-managed constant  separated by a semicolon. </param>
        /// <param name="flags"> If pSrcData contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, pSrcData contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to an <see cref="SlimDX2.Direct3D9.EffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="ppEffect"> Returns a pointer to an <see cref="SlimDX2.Direct3D9.Effect"/> interface. </param>
        /// <param name="ppCompilationErrors"> Returns a buffer containing a list of compile errors. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectEx([None] LPDIRECT3DDEVICE9 pDevice,[None] LPCVOID pSrcData,[None] UINT SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result CreateEffectEx(SlimDX2.Direct3D9.Device pDevice, IntPtr pSrcData, int srcDataLen, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, string pSkipConstants, int flags, SlimDX2.Direct3D9.EffectPool pPool, out SlimDX2.Direct3D9.Effect ppEffect, out SlimDX2.Direct3D9.Buffer ppCompilationErrors) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppEffect_ = IntPtr.Zero;
                IntPtr ppCompilationErrors_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectEx_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcData,  srcDataLen, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  pSkipConstants,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out ppEffect_, out ppCompilationErrors_);
                ppEffect = (ppEffect_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Effect(ppEffect_);
                ppCompilationErrors = (ppCompilationErrors_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppCompilationErrors_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectEx([None] LPDIRECT3DDEVICE9 pDevice,[None] LPCVOID pSrcData,[None] UINT SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectEx", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectEx_(IntPtr pDevice, IntPtr pSrcData, int srcDataLen, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, [MarshalAs(UnmanagedType.LPStr),In] string pSkipConstants, int flags, IntPtr pPool, out IntPtr ppEffect, out IntPtr ppCompilationErrors);		
        
        /// <summary>	
        /// Creates an effect compiler from an ASCII effect description.	
        /// </summary>	
        /// <remarks>	
        ///  If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectCompilerFromFileW. Otherwise, the function call resolves to D3DXCreateEffectCompilerFromFileA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="pSrcFile"> Pointer to the filename. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="pDefines"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> Compile options identified by various flags (see {{D3DXSHADER Flags}}). The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="ppCompiler"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.EffectCompiler"/> interface, containing the effect compiler.  </param>
        /// <param name="ppParseErrors"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface, containing any error messages that occurred during compilation. This parameter can be set to NULL to ignore error messages.  </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromFileA([None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		public static SlimDX2.Result CreateEffectCompilerFromFileA(string pSrcFile, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, int flags, out SlimDX2.Direct3D9.EffectCompiler ppCompiler, out SlimDX2.Direct3D9.Buffer ppParseErrors) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppCompiler_ = IntPtr.Zero;
                IntPtr ppParseErrors_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectCompilerFromFileA_( pSrcFile, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out ppCompiler_, out ppParseErrors_);
                ppCompiler = (ppCompiler_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.EffectCompiler(ppCompiler_);
                ppParseErrors = (ppParseErrors_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppParseErrors_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromFileA([None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectCompilerFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectCompilerFromFileA_([MarshalAs(UnmanagedType.LPStr),In] string pSrcFile, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, int flags, out IntPtr ppCompiler, out IntPtr ppParseErrors);		
        
        /// <summary>	
        /// Creates an effect compiler from an ASCII effect description.	
        /// </summary>	
        /// <remarks>	
        ///  If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectCompilerFromFileW. Otherwise, the function call resolves to D3DXCreateEffectCompilerFromFileA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="pSrcFile"> Pointer to the filename. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="pDefines"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> Compile options identified by various flags (see {{D3DXSHADER Flags}}). The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="ppCompiler"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.EffectCompiler"/> interface, containing the effect compiler.  </param>
        /// <param name="ppParseErrors"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface, containing any error messages that occurred during compilation. This parameter can be set to NULL to ignore error messages.  </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromFileW([None] const wchar* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		public static SlimDX2.Result CreateEffectCompilerFromFileW(string pSrcFile, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, int flags, out SlimDX2.Direct3D9.EffectCompiler ppCompiler, out SlimDX2.Direct3D9.Buffer ppParseErrors) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppCompiler_ = IntPtr.Zero;
                IntPtr ppParseErrors_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectCompilerFromFileW_( pSrcFile, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out ppCompiler_, out ppParseErrors_);
                ppCompiler = (ppCompiler_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.EffectCompiler(ppCompiler_);
                ppParseErrors = (ppParseErrors_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppParseErrors_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromFileW([None] const wchar* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectCompilerFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectCompilerFromFileW_([MarshalAs(UnmanagedType.LPWStr),In] string pSrcFile, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, int flags, out IntPtr ppCompiler, out IntPtr ppParseErrors);		
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct3D9.EffectCompiler"/> from an ASCII effect description.	
        /// </summary>	
        /// <remarks>	
        ///  If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectCompilerFromResourceW. Otherwise, the function call resolves to D3DXCreateEffectCompilerFromResourceA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="pSrcResource"> Pointer to the resource. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="pDefines"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> Compile options identified by various flags (see {{D3DXSHADER Flags}}). The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="ppCompiler"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.EffectCompiler"/> interface, containing the effect compiler.  </param>
        /// <param name="ppParseErrors"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface, containing any error messages that occurred during compilation. This parameter can be set to NULL to ignore error messages.  </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromResourceA([None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		public static SlimDX2.Result CreateEffectCompilerFromResourceA(IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, int flags, out SlimDX2.Direct3D9.EffectCompiler ppCompiler, out SlimDX2.Direct3D9.Buffer ppParseErrors) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppCompiler_ = IntPtr.Zero;
                IntPtr ppParseErrors_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectCompilerFromResourceA_( hSrcModule,  pSrcResource, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out ppCompiler_, out ppParseErrors_);
                ppCompiler = (ppCompiler_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.EffectCompiler(ppCompiler_);
                ppParseErrors = (ppParseErrors_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppParseErrors_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromResourceA([None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectCompilerFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectCompilerFromResourceA_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string pSrcResource, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, int flags, out IntPtr ppCompiler, out IntPtr ppParseErrors);		
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct3D9.EffectCompiler"/> from an ASCII effect description.	
        /// </summary>	
        /// <remarks>	
        ///  If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectCompilerFromResourceW. Otherwise, the function call resolves to D3DXCreateEffectCompilerFromResourceA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="pSrcResource"> Pointer to the resource. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="pDefines"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> Compile options identified by various flags (see {{D3DXSHADER Flags}}). The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="ppCompiler"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.EffectCompiler"/> interface, containing the effect compiler.  </param>
        /// <param name="ppParseErrors"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface, containing any error messages that occurred during compilation. This parameter can be set to NULL to ignore error messages.  </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromResourceW([None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		public static SlimDX2.Result CreateEffectCompilerFromResourceW(IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, int flags, out SlimDX2.Direct3D9.EffectCompiler ppCompiler, out SlimDX2.Direct3D9.Buffer ppParseErrors) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppCompiler_ = IntPtr.Zero;
                IntPtr ppParseErrors_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectCompilerFromResourceW_( hSrcModule,  pSrcResource, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out ppCompiler_, out ppParseErrors_);
                ppCompiler = (ppCompiler_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.EffectCompiler(ppCompiler_);
                ppParseErrors = (ppParseErrors_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppParseErrors_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromResourceW([None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectCompilerFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectCompilerFromResourceW_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcResource, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, int flags, out IntPtr ppCompiler, out IntPtr ppParseErrors);		
        
        /// <summary>	
        /// Creates an effect compiler from an ASCII effect description.	
        /// </summary>	
        /// <param name="pSrcData"> Pointer to a buffer containing an effect description. </param>
        /// <param name="srcDataLen"> Length, in bytes, of the effect data. </param>
        /// <param name="pDefines"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.Include"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> Compile options identified by various flags (see {{D3DXSHADER Flags}}). The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="ppCompiler"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.EffectCompiler"/> interface containing the effect compiler.  </param>
        /// <param name="ppParseErrors"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface containing any error messages that occurred during compilation. This parameter can be set to NULL to ignore error messages.  </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectCompiler([None] const char* pSrcData,[None] UINT SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		public static SlimDX2.Result CreateEffectCompiler(string pSrcData, int srcDataLen, ref SlimDX2.Direct3D9.Macro pDefines, SlimDX2.Direct3D9.Include pInclude, int flags, out SlimDX2.Direct3D9.EffectCompiler ppCompiler, out SlimDX2.Direct3D9.Buffer ppParseErrors) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native pDefines_ = new SlimDX2.Direct3D9.Macro.__Native();
                pDefines.__MarshalTo(ref pDefines_);
                IntPtr ppCompiler_ = IntPtr.Zero;
                IntPtr ppParseErrors_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectCompiler_( pSrcData,  srcDataLen, ref  pDefines_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out ppCompiler_, out ppParseErrors_);
                ppCompiler = (ppCompiler_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.EffectCompiler(ppCompiler_);
                ppParseErrors = (ppParseErrors_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppParseErrors_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectCompiler([None] const char* pSrcData,[None] UINT SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectCompiler", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectCompiler_([MarshalAs(UnmanagedType.LPStr),In] string pSrcData, int srcDataLen, ref SlimDX2.Direct3D9.Macro.__Native pDefines, IntPtr pInclude, int flags, out IntPtr ppCompiler, out IntPtr ppParseErrors);		
        
        /// <summary>	
        /// Disassemble an effect.	
        /// </summary>	
        /// <param name="pEffect"> Pointer to an <see cref="SlimDX2.Direct3D9.Effect"/> interface that contains the effect. </param>
        /// <param name="enableColorCode"> Enable color coding to make the disassembly easier to read. </param>
        /// <param name="ppDisassembly"> Returns a buffer containing the disassembled shader. See <see cref="SlimDX2.Direct3D9.Buffer"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXDisassembleEffect([None] LPD3DXEFFECT pEffect,[None] BOOL EnableColorCode,[None] LPD3DXBUFFER* ppDisassembly)</unmanaged>
		public static SlimDX2.Result DisassembleEffect(SlimDX2.Direct3D9.Effect pEffect, bool enableColorCode, out SlimDX2.Direct3D9.Buffer ppDisassembly) {
            unsafe {
                IntPtr ppDisassembly_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXDisassembleEffect_((pEffect == null)?IntPtr.Zero:pEffect.NativePointer,  enableColorCode, out ppDisassembly_);
                ppDisassembly = (ppDisassembly_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppDisassembly_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXDisassembleEffect([None] LPD3DXEFFECT pEffect,[None] BOOL EnableColorCode,[None] LPD3DXBUFFER* ppDisassembly)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXDisassembleEffect", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXDisassembleEffect_(IntPtr pEffect, bool enableColorCode, out IntPtr ppDisassembly);		
        
        /// <summary>	
        /// Retrieves information about a given image file.	
        /// </summary>	
        /// <remarks>	
        ///  This function supports both Unicode and ANSI strings. 	
        /// </remarks>	
        /// <param name="pSrcFile"> File name of image to retrieve information about. If UNICODE or _UNICODE are defined, this parameter type is LPCWSTR, otherwise, the type is LPCSTR. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with the description of the data in the source file. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromFileA([None] const char* pSrcFile,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result GetImageInfoFromFileA(string pSrcFile, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetImageInfoFromFileA_( pSrcFile, ref  pSrcInfo);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromFileA([None] const char* pSrcFile,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetImageInfoFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetImageInfoFromFileA_([MarshalAs(UnmanagedType.LPStr),In] string pSrcFile, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo);		
        
        /// <summary>	
        /// Retrieves information about a given image file.	
        /// </summary>	
        /// <remarks>	
        ///  This function supports both Unicode and ANSI strings. 	
        /// </remarks>	
        /// <param name="pSrcFile"> File name of image to retrieve information about. If UNICODE or _UNICODE are defined, this parameter type is LPCWSTR, otherwise, the type is LPCSTR. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with the description of the data in the source file. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromFileW([None] const wchar* pSrcFile,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result GetImageInfoFromFileW(string pSrcFile, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetImageInfoFromFileW_( pSrcFile, ref  pSrcInfo);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromFileW([None] const wchar* pSrcFile,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetImageInfoFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetImageInfoFromFileW_([MarshalAs(UnmanagedType.LPWStr),In] string pSrcFile, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo);		
        
        /// <summary>	
        /// Retrieves information about a given image in a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXGetImageInfoFromResourceW. Otherwise, the function call resolves to D3DXGetImageInfoFromResourceA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="hSrcModule"> Module where the resource is loaded. Set this parameter to NULL to specify the module associated with the image that the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with the description of the data in the source file. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromResourceA([None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result GetImageInfoFromResourceA(IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetImageInfoFromResourceA_( hSrcModule,  pSrcResource, ref  pSrcInfo);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromResourceA([None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetImageInfoFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetImageInfoFromResourceA_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string pSrcResource, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo);		
        
        /// <summary>	
        /// Retrieves information about a given image in a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXGetImageInfoFromResourceW. Otherwise, the function call resolves to D3DXGetImageInfoFromResourceA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="hSrcModule"> Module where the resource is loaded. Set this parameter to NULL to specify the module associated with the image that the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with the description of the data in the source file. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromResourceW([None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result GetImageInfoFromResourceW(IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetImageInfoFromResourceW_( hSrcModule,  pSrcResource, ref  pSrcInfo);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromResourceW([None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetImageInfoFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetImageInfoFromResourceW_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcResource, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo);		
        
        /// <summary>	
        /// Retrieves information about a given image file in memory.	
        /// </summary>	
        /// <param name="pSrcData"> VOID pointer to the source file in memory. </param>
        /// <param name="srcDataSize"> Size of file in memory, in bytes. . </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with the description of the data in the source file. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromFileInMemory([None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result GetImageInfoFromFileInMemory(IntPtr pSrcData, int srcDataSize, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetImageInfoFromFileInMemory_( pSrcData,  srcDataSize, ref  pSrcInfo);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromFileInMemory([None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetImageInfoFromFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetImageInfoFromFileInMemory_(IntPtr pSrcData, int srcDataSize, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo);		
        
        /// <summary>	
        /// Loads a surface from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXLoadSurfaceFromFileW. Otherwise, the function call resolves to D3DXLoadSurfaceFromFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats and supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Writing to a non-level-zero surface will not cause the dirty rectangle to be updated. If D3DXLoadSurfaceFromFile is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call {{AddDirtyRect}} on the surface. 	
        /// </remarks>	
        /// <param name="pDestSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface. Specifies the destination surface, which receives the image. </param>
        /// <param name="pDestPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="pDestRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the destination rectangle. Set this parameter to NULL to specify the entire surface. </param>
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="pSrcRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire image. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromFileA([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] const char* pSrcFile,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result LoadSurfaceFromFileA(SlimDX2.Direct3D9.Surface pDestSurface, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Rectangle pDestRect, string pSrcFile, ref SlimDX2.Rectangle pSrcRect, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadSurfaceFromFileA_((pDestSurface == null)?IntPtr.Zero:pDestSurface.NativePointer, ref  pDestPalette, ref  pDestRect,  pSrcFile, ref  pSrcRect,  filter,  colorKey, ref  pSrcInfo);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromFileA([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] const char* pSrcFile,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadSurfaceFromFileA_(IntPtr pDestSurface, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Rectangle pDestRect, [MarshalAs(UnmanagedType.LPStr),In] string pSrcFile, ref SlimDX2.Rectangle pSrcRect, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo);		
        
        /// <summary>	
        /// Loads a surface from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXLoadSurfaceFromFileW. Otherwise, the function call resolves to D3DXLoadSurfaceFromFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats and supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Writing to a non-level-zero surface will not cause the dirty rectangle to be updated. If D3DXLoadSurfaceFromFile is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call {{AddDirtyRect}} on the surface. 	
        /// </remarks>	
        /// <param name="pDestSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface. Specifies the destination surface, which receives the image. </param>
        /// <param name="pDestPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="pDestRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the destination rectangle. Set this parameter to NULL to specify the entire surface. </param>
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="pSrcRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire image. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromFileW([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] const wchar* pSrcFile,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result LoadSurfaceFromFileW(SlimDX2.Direct3D9.Surface pDestSurface, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Rectangle pDestRect, string pSrcFile, ref SlimDX2.Rectangle pSrcRect, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadSurfaceFromFileW_((pDestSurface == null)?IntPtr.Zero:pDestSurface.NativePointer, ref  pDestPalette, ref  pDestRect,  pSrcFile, ref  pSrcRect,  filter,  colorKey, ref  pSrcInfo);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromFileW([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] const wchar* pSrcFile,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadSurfaceFromFileW_(IntPtr pDestSurface, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Rectangle pDestRect, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcFile, ref SlimDX2.Rectangle pSrcRect, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo);		
        
        /// <summary>	
        /// Loads a surface from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXLoadSurfaceFromResourceW. Otherwise, the function call resolves to D3DXLoadSurfaceFromResourceA because ANSI strings are being used. The resource being loaded must be of type RT_BITMAP or RT_RCDATA. Resource type RT_RCDATA is used to load formats other than bitmaps (such as .tga, .jpg, and .dds). This function handles conversion to and from compressed texture formats. Writing to a non-level-zero surface will not cause the dirty rectangle to be updated. If {{D3DXLoadSurfaceFromFile}} is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call {{AddDirtyRect}} on the surface. 	
        /// </remarks>	
        /// <param name="pDestSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface. Specifies the destination surface, which receives the image. </param>
        /// <param name="pDestPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="pDestRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the destination rectangle. Set this parameter to NULL to specify the entire surface. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="pSrcRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire image. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromResourceA([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result LoadSurfaceFromResourceA(SlimDX2.Direct3D9.Surface pDestSurface, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Rectangle pDestRect, IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Rectangle pSrcRect, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadSurfaceFromResourceA_((pDestSurface == null)?IntPtr.Zero:pDestSurface.NativePointer, ref  pDestPalette, ref  pDestRect,  hSrcModule,  pSrcResource, ref  pSrcRect,  filter,  colorKey, ref  pSrcInfo);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromResourceA([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadSurfaceFromResourceA_(IntPtr pDestSurface, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Rectangle pDestRect, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string pSrcResource, ref SlimDX2.Rectangle pSrcRect, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo);		
        
        /// <summary>	
        /// Loads a surface from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXLoadSurfaceFromResourceW. Otherwise, the function call resolves to D3DXLoadSurfaceFromResourceA because ANSI strings are being used. The resource being loaded must be of type RT_BITMAP or RT_RCDATA. Resource type RT_RCDATA is used to load formats other than bitmaps (such as .tga, .jpg, and .dds). This function handles conversion to and from compressed texture formats. Writing to a non-level-zero surface will not cause the dirty rectangle to be updated. If {{D3DXLoadSurfaceFromFile}} is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call {{AddDirtyRect}} on the surface. 	
        /// </remarks>	
        /// <param name="pDestSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface. Specifies the destination surface, which receives the image. </param>
        /// <param name="pDestPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="pDestRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the destination rectangle. Set this parameter to NULL to specify the entire surface. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="pSrcRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire image. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromResourceW([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result LoadSurfaceFromResourceW(SlimDX2.Direct3D9.Surface pDestSurface, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Rectangle pDestRect, IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Rectangle pSrcRect, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadSurfaceFromResourceW_((pDestSurface == null)?IntPtr.Zero:pDestSurface.NativePointer, ref  pDestPalette, ref  pDestRect,  hSrcModule,  pSrcResource, ref  pSrcRect,  filter,  colorKey, ref  pSrcInfo);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromResourceW([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadSurfaceFromResourceW_(IntPtr pDestSurface, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Rectangle pDestRect, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcResource, ref SlimDX2.Rectangle pSrcRect, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo);		
        
        /// <summary>	
        /// Loads a surface from a file in memory.	
        /// </summary>	
        /// <remarks>	
        ///  This function handles conversion to and from compressed texture formats and supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Writing to a non-level-zero surface will not cause the dirty rectangle to be updated. If D3DXLoadSurfaceFromFileInMemory is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call {{AddDirtyRect}} on the surface. 	
        /// </remarks>	
        /// <param name="pDestSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface. Specifies the destination surface, which receives the image. </param>
        /// <param name="pDestPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="pDestRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the destination rectangle. Set this parameter to NULL to specify the entire surface. </param>
        /// <param name="pSrcData"> Pointer to the file in memory from which to load the surface. </param>
        /// <param name="srcDataSize"> Size of the file in memory, in bytes. </param>
        /// <param name="pSrcRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire image. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromFileInMemory([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result LoadSurfaceFromFileInMemory(SlimDX2.Direct3D9.Surface pDestSurface, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Rectangle pDestRect, IntPtr pSrcData, int srcDataSize, ref SlimDX2.Rectangle pSrcRect, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadSurfaceFromFileInMemory_((pDestSurface == null)?IntPtr.Zero:pDestSurface.NativePointer, ref  pDestPalette, ref  pDestRect,  pSrcData,  srcDataSize, ref  pSrcRect,  filter,  colorKey, ref  pSrcInfo);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromFileInMemory([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadSurfaceFromFileInMemory_(IntPtr pDestSurface, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Rectangle pDestRect, IntPtr pSrcData, int srcDataSize, ref SlimDX2.Rectangle pSrcRect, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo);		
        
        /// <summary>	
        /// Loads a surface from another surface with color conversion.	
        /// </summary>	
        /// <remarks>	
        ///  This function handles conversion to and from compressed texture formats. Writing to a non-level-zero surface will not cause the dirty rectangle to be updated. If D3DXLoadSurfaceFromSurface is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call {{AddDirtyRect}} on the surface. 	
        /// </remarks>	
        /// <param name="pDestSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface. Specifies the destination surface, which receives the image. </param>
        /// <param name="pDestPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="pDestRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the destination rectangle. Set this parameter to NULL to specify the entire surface. </param>
        /// <param name="pSrcSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the source surface. </param>
        /// <param name="pSrcPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the source palette of 256 colors or NULL. </param>
        /// <param name="pSrcRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire surface. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromSurface([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] LPDIRECT3DSURFACE9 pSrcSurface,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey)</unmanaged>
		public static SlimDX2.Result LoadSurfaceFromSurface(SlimDX2.Direct3D9.Surface pDestSurface, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Rectangle pDestRect, SlimDX2.Direct3D9.Surface pSrcSurface, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Rectangle pSrcRect, int filter, int colorKey) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadSurfaceFromSurface_((pDestSurface == null)?IntPtr.Zero:pDestSurface.NativePointer, ref  pDestPalette, ref  pDestRect, (pSrcSurface == null)?IntPtr.Zero:pSrcSurface.NativePointer, ref  pSrcPalette, ref  pSrcRect,  filter,  colorKey);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromSurface([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] LPDIRECT3DSURFACE9 pSrcSurface,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromSurface", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadSurfaceFromSurface_(IntPtr pDestSurface, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Rectangle pDestRect, IntPtr pSrcSurface, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Rectangle pSrcRect, int filter, int colorKey);		
        
        /// <summary>	
        /// Loads a surface from memory.	
        /// </summary>	
        /// <remarks>	
        ///  This function handles conversion to and from compressed texture formats. Writing to a non-level-zero surface will not cause the dirty rectangle to be updated. If D3DXLoadSurfaceFromMemory is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call {{AddDirtyRect}} on the surface. 	
        /// </remarks>	
        /// <param name="pDestSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface. Specifies the destination surface, which receives the image. </param>
        /// <param name="pDestPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="pDestRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the destination rectangle. Set this parameter to NULL to specify the entire surface. </param>
        /// <param name="pSrcMemory"> Pointer to the upper left corner of the source image in memory. </param>
        /// <param name="srcFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, the pixel format of the source image. </param>
        /// <param name="srcPitch"> Pitch of source image, in bytes. For DXT formats, this number should represent the width of one row of cells, in bytes. </param>
        /// <param name="pSrcPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the source palette of 256 colors or NULL. </param>
        /// <param name="pSrcRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the dimensions of the source image in memory. This value cannot be NULL. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromMemory([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] LPCVOID pSrcMemory,[None] D3DFORMAT SrcFormat,[None] UINT SrcPitch,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey)</unmanaged>
		public static SlimDX2.Result LoadSurfaceFromMemory(SlimDX2.Direct3D9.Surface pDestSurface, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Rectangle pDestRect, IntPtr pSrcMemory, SlimDX2.Direct3D9.Format srcFormat, int srcPitch, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Rectangle pSrcRect, int filter, int colorKey) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadSurfaceFromMemory_((pDestSurface == null)?IntPtr.Zero:pDestSurface.NativePointer, ref  pDestPalette, ref  pDestRect,  pSrcMemory,  srcFormat,  srcPitch, ref  pSrcPalette, ref  pSrcRect,  filter,  colorKey);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromMemory([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] LPCVOID pSrcMemory,[None] D3DFORMAT SrcFormat,[None] UINT SrcPitch,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadSurfaceFromMemory_(IntPtr pDestSurface, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Rectangle pDestRect, IntPtr pSrcMemory, SlimDX2.Direct3D9.Format srcFormat, int srcPitch, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Rectangle pSrcRect, int filter, int colorKey);		
        
        /// <summary>	
        /// Saves a surface to a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXSaveSurfaceToFileW. Otherwise, the function call resolves to D3DXSaveSurfaceToFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats. 	
        /// </remarks>	
        /// <param name="pDestFile"> Pointer to a string that specifies the file name of the destination image. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileformat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcSurface"> Pointer to <see cref="SlimDX2.Direct3D9.Surface"/> interface, containing the image to be saved. </param>
        /// <param name="pSrcPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <param name="pSrcRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire image. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXSaveSurfaceToFileA([None] const char* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DSURFACE9 pSrcSurface,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect)</unmanaged>
		public static SlimDX2.Result SaveSurfaceToFileA(string pDestFile, SlimDX2.Direct3D9.ImageFileformat destFormat, SlimDX2.Direct3D9.Surface pSrcSurface, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Rectangle pSrcRect) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveSurfaceToFileA_( pDestFile,  destFormat, (pSrcSurface == null)?IntPtr.Zero:pSrcSurface.NativePointer, ref  pSrcPalette, ref  pSrcRect);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveSurfaceToFileA([None] const char* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DSURFACE9 pSrcSurface,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveSurfaceToFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveSurfaceToFileA_([MarshalAs(UnmanagedType.LPStr),In] string pDestFile, SlimDX2.Direct3D9.ImageFileformat destFormat, IntPtr pSrcSurface, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Rectangle pSrcRect);		
        
        /// <summary>	
        /// Saves a surface to a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXSaveSurfaceToFileW. Otherwise, the function call resolves to D3DXSaveSurfaceToFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats. 	
        /// </remarks>	
        /// <param name="pDestFile"> Pointer to a string that specifies the file name of the destination image. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileformat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcSurface"> Pointer to <see cref="SlimDX2.Direct3D9.Surface"/> interface, containing the image to be saved. </param>
        /// <param name="pSrcPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <param name="pSrcRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire image. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXSaveSurfaceToFileW([None] const wchar* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DSURFACE9 pSrcSurface,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect)</unmanaged>
		public static SlimDX2.Result SaveSurfaceToFileW(string pDestFile, SlimDX2.Direct3D9.ImageFileformat destFormat, SlimDX2.Direct3D9.Surface pSrcSurface, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Rectangle pSrcRect) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveSurfaceToFileW_( pDestFile,  destFormat, (pSrcSurface == null)?IntPtr.Zero:pSrcSurface.NativePointer, ref  pSrcPalette, ref  pSrcRect);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveSurfaceToFileW([None] const wchar* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DSURFACE9 pSrcSurface,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveSurfaceToFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveSurfaceToFileW_([MarshalAs(UnmanagedType.LPWStr),In] string pDestFile, SlimDX2.Direct3D9.ImageFileformat destFormat, IntPtr pSrcSurface, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Rectangle pSrcRect);		
        
        /// <summary>	
        /// Saves a surface to an image file.	
        /// </summary>	
        /// <remarks>	
        ///  This function handles conversion to and from compressed texture formats. 	
        /// </remarks>	
        /// <param name="ppDestBuf"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> that will store the image. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileformat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcSurface"> Pointer to <see cref="SlimDX2.Direct3D9.Surface"/> interface containing the image to be saved. </param>
        /// <param name="pSrcPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <param name="pSrcRect"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire image. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXSaveSurfaceToFileInMemory([None] LPD3DXBUFFER* ppDestBuf,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DSURFACE9 pSrcSurface,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect)</unmanaged>
		public static SlimDX2.Result SaveSurfaceToFileInMemory(out SlimDX2.Direct3D9.Buffer ppDestBuf, SlimDX2.Direct3D9.ImageFileformat destFormat, SlimDX2.Direct3D9.Surface pSrcSurface, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Rectangle pSrcRect) {
            unsafe {
                IntPtr ppDestBuf_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveSurfaceToFileInMemory_(out ppDestBuf_,  destFormat, (pSrcSurface == null)?IntPtr.Zero:pSrcSurface.NativePointer, ref  pSrcPalette, ref  pSrcRect);
                ppDestBuf = (ppDestBuf_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppDestBuf_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveSurfaceToFileInMemory([None] LPD3DXBUFFER* ppDestBuf,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DSURFACE9 pSrcSurface,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveSurfaceToFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveSurfaceToFileInMemory_(out IntPtr ppDestBuf, SlimDX2.Direct3D9.ImageFileformat destFormat, IntPtr pSrcSurface, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Rectangle pSrcRect);		
        
        /// <summary>	
        /// Loads a volume from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXLoadVolumeFromFileW. Otherwise, the function call resolves to D3DXLoadVolumeFromFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats and supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If D3DXLoadVolumeFromFile is called and the texture was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <see cref="SlimDX2.Direct3D9.VolumeTexture.AddDirtyBox"/> on the volume texture. 	
        /// </remarks>	
        /// <param name="pDestVolume"> Pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface. Specifies the destination volume. </param>
        /// <param name="pDestPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="pDestBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the destination box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="pSrcBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromFileA([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] const char* pSrcFile,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result LoadVolumeFromFileA(SlimDX2.Direct3D9.Volume pDestVolume, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Direct3D9.Box pDestBox, string pSrcFile, ref SlimDX2.Direct3D9.Box pSrcBox, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadVolumeFromFileA_((pDestVolume == null)?IntPtr.Zero:pDestVolume.NativePointer, ref  pDestPalette, ref  pDestBox,  pSrcFile, ref  pSrcBox,  filter,  colorKey, ref  pSrcInfo);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromFileA([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] const char* pSrcFile,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadVolumeFromFileA_(IntPtr pDestVolume, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Direct3D9.Box pDestBox, [MarshalAs(UnmanagedType.LPStr),In] string pSrcFile, ref SlimDX2.Direct3D9.Box pSrcBox, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo);		
        
        /// <summary>	
        /// Loads a volume from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXLoadVolumeFromFileW. Otherwise, the function call resolves to D3DXLoadVolumeFromFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats and supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If D3DXLoadVolumeFromFile is called and the texture was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <see cref="SlimDX2.Direct3D9.VolumeTexture.AddDirtyBox"/> on the volume texture. 	
        /// </remarks>	
        /// <param name="pDestVolume"> Pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface. Specifies the destination volume. </param>
        /// <param name="pDestPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="pDestBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the destination box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="pSrcBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromFileW([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] const wchar* pSrcFile,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result LoadVolumeFromFileW(SlimDX2.Direct3D9.Volume pDestVolume, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Direct3D9.Box pDestBox, string pSrcFile, ref SlimDX2.Direct3D9.Box pSrcBox, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadVolumeFromFileW_((pDestVolume == null)?IntPtr.Zero:pDestVolume.NativePointer, ref  pDestPalette, ref  pDestBox,  pSrcFile, ref  pSrcBox,  filter,  colorKey, ref  pSrcInfo);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromFileW([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] const wchar* pSrcFile,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadVolumeFromFileW_(IntPtr pDestVolume, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Direct3D9.Box pDestBox, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcFile, ref SlimDX2.Direct3D9.Box pSrcBox, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo);		
        
        /// <summary>	
        /// Loads a volume from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The resource being loaded must be a bitmap resource(RT_BITMAP). This function handles conversion to and from compressed texture formats. Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If {{D3DXLoadVolumeFromFile}} is called and the texture was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <see cref="SlimDX2.Direct3D9.VolumeTexture.AddDirtyBox"/> on the volume texture. This function supports both Unicode and ANSI strings. 	
        /// </remarks>	
        /// <param name="pDestVolume"> Pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface. Specifies the destination volume. </param>
        /// <param name="pDestPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="pDestBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the destination box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the file name of the source image.  If UNICODE or _UNICODE are defined, this parameter type is LPCWSTR, otherwise, the type is LPCSTR. </param>
        /// <param name="pSrcBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromResourceA([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result LoadVolumeFromResourceA(SlimDX2.Direct3D9.Volume pDestVolume, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Direct3D9.Box pDestBox, IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Direct3D9.Box pSrcBox, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadVolumeFromResourceA_((pDestVolume == null)?IntPtr.Zero:pDestVolume.NativePointer, ref  pDestPalette, ref  pDestBox,  hSrcModule,  pSrcResource, ref  pSrcBox,  filter,  colorKey, ref  pSrcInfo);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromResourceA([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadVolumeFromResourceA_(IntPtr pDestVolume, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Direct3D9.Box pDestBox, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string pSrcResource, ref SlimDX2.Direct3D9.Box pSrcBox, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo);		
        
        /// <summary>	
        /// Loads a volume from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The resource being loaded must be a bitmap resource(RT_BITMAP). This function handles conversion to and from compressed texture formats. Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If {{D3DXLoadVolumeFromFile}} is called and the texture was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <see cref="SlimDX2.Direct3D9.VolumeTexture.AddDirtyBox"/> on the volume texture. This function supports both Unicode and ANSI strings. 	
        /// </remarks>	
        /// <param name="pDestVolume"> Pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface. Specifies the destination volume. </param>
        /// <param name="pDestPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="pDestBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the destination box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the file name of the source image.  If UNICODE or _UNICODE are defined, this parameter type is LPCWSTR, otherwise, the type is LPCSTR. </param>
        /// <param name="pSrcBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromResourceW([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result LoadVolumeFromResourceW(SlimDX2.Direct3D9.Volume pDestVolume, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Direct3D9.Box pDestBox, IntPtr hSrcModule, string pSrcResource, ref SlimDX2.Direct3D9.Box pSrcBox, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadVolumeFromResourceW_((pDestVolume == null)?IntPtr.Zero:pDestVolume.NativePointer, ref  pDestPalette, ref  pDestBox,  hSrcModule,  pSrcResource, ref  pSrcBox,  filter,  colorKey, ref  pSrcInfo);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromResourceW([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadVolumeFromResourceW_(IntPtr pDestVolume, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Direct3D9.Box pDestBox, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcResource, ref SlimDX2.Direct3D9.Box pSrcBox, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo);		
        
        /// <summary>	
        /// Loads a volume from a file in memory.	
        /// </summary>	
        /// <remarks>	
        ///  This function handles conversion to and from compressed texture formats and supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If D3DXLoadVolumeFromFileInMemory is called and the texture was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <see cref="SlimDX2.Direct3D9.VolumeTexture.AddDirtyBox"/> on the volume texture. 	
        /// </remarks>	
        /// <param name="pDestVolume"> Pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface. Specifies the destination volume. </param>
        /// <param name="pDestPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="pDestBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the destination box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="pSrcData"> Pointer to the file in memory from which to load the volume. </param>
        /// <param name="srcDataSize"> Size in bytes of the file in memory. </param>
        /// <param name="pSrcBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromFileInMemory([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result LoadVolumeFromFileInMemory(SlimDX2.Direct3D9.Volume pDestVolume, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Direct3D9.Box pDestBox, IntPtr pSrcData, int srcDataSize, ref SlimDX2.Direct3D9.Box pSrcBox, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadVolumeFromFileInMemory_((pDestVolume == null)?IntPtr.Zero:pDestVolume.NativePointer, ref  pDestPalette, ref  pDestBox,  pSrcData,  srcDataSize, ref  pSrcBox,  filter,  colorKey, ref  pSrcInfo);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromFileInMemory([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadVolumeFromFileInMemory_(IntPtr pDestVolume, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Direct3D9.Box pDestBox, IntPtr pSrcData, int srcDataSize, ref SlimDX2.Direct3D9.Box pSrcBox, int filter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo);		
        
        /// <summary>	
        /// Loads a volume from another volume.	
        /// </summary>	
        /// <remarks>	
        ///  Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If D3DXLoadVolumeFromVolume is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <see cref="SlimDX2.Direct3D9.VolumeTexture.AddDirtyBox"/> on the surface. 	
        /// </remarks>	
        /// <param name="pDestVolume"> Pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface. Specifies the destination volume, which receives the image. </param>
        /// <param name="pDestPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="pDestBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the destination box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="pSrcVolume"> A Pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface. Specifies the source volume. </param>
        /// <param name="pSrcPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the source palette of 256 colors or NULL. </param>
        /// <param name="pSrcBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromVolume([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] LPDIRECT3DVOLUME9 pSrcVolume,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey)</unmanaged>
		public static SlimDX2.Result LoadVolumeFromVolume(SlimDX2.Direct3D9.Volume pDestVolume, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Direct3D9.Box pDestBox, SlimDX2.Direct3D9.Volume pSrcVolume, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Direct3D9.Box pSrcBox, int filter, int colorKey) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadVolumeFromVolume_((pDestVolume == null)?IntPtr.Zero:pDestVolume.NativePointer, ref  pDestPalette, ref  pDestBox, (pSrcVolume == null)?IntPtr.Zero:pSrcVolume.NativePointer, ref  pSrcPalette, ref  pSrcBox,  filter,  colorKey);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromVolume([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] LPDIRECT3DVOLUME9 pSrcVolume,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromVolume", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadVolumeFromVolume_(IntPtr pDestVolume, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Direct3D9.Box pDestBox, IntPtr pSrcVolume, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Direct3D9.Box pSrcBox, int filter, int colorKey);		
        
        /// <summary>	
        /// Loads a volume from memory.	
        /// </summary>	
        /// <remarks>	
        ///  Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If D3DXLoadVolumeFromMemory is called and the texture was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <see cref="SlimDX2.Direct3D9.VolumeTexture.AddDirtyBox"/> on the volume texture. 	
        /// </remarks>	
        /// <param name="pDestVolume"> Pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface. Specifies the destination volume, which receives the image. </param>
        /// <param name="pDestPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="pDestBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the destination box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="pSrcMemory"> Pointer to the top-left corner of the source volume in memory. </param>
        /// <param name="srcFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, the pixel format of the source volume. </param>
        /// <param name="srcRowPitch"> Pitch of source image, in bytes. For DXT formats (compressed texture formats), this number should represent the size of one row of cells, in bytes. </param>
        /// <param name="srcSlicePitch"> Pitch of source image, in bytes. For DXT formats (compressed texture formats), this number should represent the size of one slice of cells, in bytes. </param>
        /// <param name="pSrcPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the source palette of 256 colors or NULL. </param>
        /// <param name="pSrcBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. NULL is not a valid value for this parameter. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromMemory([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] LPCVOID pSrcMemory,[None] D3DFORMAT SrcFormat,[None] UINT SrcRowPitch,[None] UINT SrcSlicePitch,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey)</unmanaged>
		public static SlimDX2.Result LoadVolumeFromMemory(SlimDX2.Direct3D9.Volume pDestVolume, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Direct3D9.Box pDestBox, IntPtr pSrcMemory, SlimDX2.Direct3D9.Format srcFormat, int srcRowPitch, int srcSlicePitch, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Direct3D9.Box pSrcBox, int filter, int colorKey) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadVolumeFromMemory_((pDestVolume == null)?IntPtr.Zero:pDestVolume.NativePointer, ref  pDestPalette, ref  pDestBox,  pSrcMemory,  srcFormat,  srcRowPitch,  srcSlicePitch, ref  pSrcPalette, ref  pSrcBox,  filter,  colorKey);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromMemory([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] LPCVOID pSrcMemory,[None] D3DFORMAT SrcFormat,[None] UINT SrcRowPitch,[None] UINT SrcSlicePitch,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadVolumeFromMemory_(IntPtr pDestVolume, ref SlimDX2.Windows.Paletteentry pDestPalette, ref SlimDX2.Direct3D9.Box pDestBox, IntPtr pSrcMemory, SlimDX2.Direct3D9.Format srcFormat, int srcRowPitch, int srcSlicePitch, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Direct3D9.Box pSrcBox, int filter, int colorKey);		
        
        /// <summary>	
        /// Saves a volume to a file on disk.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXSaveVolumeToFileW. Otherwise, the function call resolves to &gt;D3DXSaveVolumeToFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats. If the volume is nondynamic (because of a usage parameter set to 0 at the creation) and located in video memory (the memory pool set to D3DPOOL_DEFAULT), {{D3DXSaveTextureToFile}} will fail because D3DX cannot lock nondynamic volumes located in video memory. 	
        /// </remarks>	
        /// <param name="pDestFile"> Pointer to a string that specifies the file name of the destination image. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileformat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcVolume"> Pointer to <see cref="SlimDX2.Direct3D9.Volume"/> interface containing the image to be saved. </param>
        /// <param name="pSrcPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <param name="pSrcBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXSaveVolumeToFileA([None] const char* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DVOLUME9 pSrcVolume,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox)</unmanaged>
		public static SlimDX2.Result SaveVolumeToFileA(string pDestFile, SlimDX2.Direct3D9.ImageFileformat destFormat, SlimDX2.Direct3D9.Volume pSrcVolume, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Direct3D9.Box pSrcBox) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveVolumeToFileA_( pDestFile,  destFormat, (pSrcVolume == null)?IntPtr.Zero:pSrcVolume.NativePointer, ref  pSrcPalette, ref  pSrcBox);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveVolumeToFileA([None] const char* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DVOLUME9 pSrcVolume,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveVolumeToFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveVolumeToFileA_([MarshalAs(UnmanagedType.LPStr),In] string pDestFile, SlimDX2.Direct3D9.ImageFileformat destFormat, IntPtr pSrcVolume, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Direct3D9.Box pSrcBox);		
        
        /// <summary>	
        /// Saves a volume to a file on disk.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXSaveVolumeToFileW. Otherwise, the function call resolves to &gt;D3DXSaveVolumeToFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats. If the volume is nondynamic (because of a usage parameter set to 0 at the creation) and located in video memory (the memory pool set to D3DPOOL_DEFAULT), {{D3DXSaveTextureToFile}} will fail because D3DX cannot lock nondynamic volumes located in video memory. 	
        /// </remarks>	
        /// <param name="pDestFile"> Pointer to a string that specifies the file name of the destination image. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileformat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcVolume"> Pointer to <see cref="SlimDX2.Direct3D9.Volume"/> interface containing the image to be saved. </param>
        /// <param name="pSrcPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <param name="pSrcBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXSaveVolumeToFileW([None] const wchar* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DVOLUME9 pSrcVolume,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox)</unmanaged>
		public static SlimDX2.Result SaveVolumeToFileW(string pDestFile, SlimDX2.Direct3D9.ImageFileformat destFormat, SlimDX2.Direct3D9.Volume pSrcVolume, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Direct3D9.Box pSrcBox) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveVolumeToFileW_( pDestFile,  destFormat, (pSrcVolume == null)?IntPtr.Zero:pSrcVolume.NativePointer, ref  pSrcPalette, ref  pSrcBox);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveVolumeToFileW([None] const wchar* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DVOLUME9 pSrcVolume,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveVolumeToFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveVolumeToFileW_([MarshalAs(UnmanagedType.LPWStr),In] string pDestFile, SlimDX2.Direct3D9.ImageFileformat destFormat, IntPtr pSrcVolume, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Direct3D9.Box pSrcBox);		
        
        /// <summary>	
        /// Saves a volume to a buffer. The method creates an <see cref="SlimDX2.Direct3D9.Buffer"/> buffer to store the data, and returns that object.	
        /// </summary>	
        /// <param name="ppDestBuf"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> buffer that will store the image. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileformat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcVolume"> Pointer to <see cref="SlimDX2.Direct3D9.Volume"/> interface containing the image to be saved. </param>
        /// <param name="pSrcPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <param name="pSrcBox"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXSaveVolumeToFileInMemory([None] LPD3DXBUFFER* ppDestBuf,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DVOLUME9 pSrcVolume,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox)</unmanaged>
		public static SlimDX2.Result SaveVolumeToFileInMemory(out SlimDX2.Direct3D9.Buffer ppDestBuf, SlimDX2.Direct3D9.ImageFileformat destFormat, SlimDX2.Direct3D9.Volume pSrcVolume, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Direct3D9.Box pSrcBox) {
            unsafe {
                IntPtr ppDestBuf_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveVolumeToFileInMemory_(out ppDestBuf_,  destFormat, (pSrcVolume == null)?IntPtr.Zero:pSrcVolume.NativePointer, ref  pSrcPalette, ref  pSrcBox);
                ppDestBuf = (ppDestBuf_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppDestBuf_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveVolumeToFileInMemory([None] LPD3DXBUFFER* ppDestBuf,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DVOLUME9 pSrcVolume,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveVolumeToFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveVolumeToFileInMemory_(out IntPtr ppDestBuf, SlimDX2.Direct3D9.ImageFileformat destFormat, IntPtr pSrcVolume, ref SlimDX2.Windows.Paletteentry pSrcPalette, ref SlimDX2.Direct3D9.Box pSrcBox);		
        
        /// <summary>	
        /// Checks texture-creation parameters.	
        /// </summary>	
        /// <remarks>	
        ///  If parameters to this function are invalid, this function returns corrected parameters. This function uses the following heuristics when comparing the requested requirements against available formats:  Do not choose a format that has fewer channels. Avoid {{FOURCC}} And 24-bit formats unless explicitly requested. Try not to add new channels. Try not to change the number of bits per channel. Try to avoid converting between types of formats. For instance, avoid converting an ARGB format to a depth format.  	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="pWidth"> Pointer to the requested width in pixels, or NULL. Returns the corrected size. </param>
        /// <param name="pHeight"> Pointer to the requested height in pixels, or NULL. Returns the corrected size. </param>
        /// <param name="pNumMipLevels"> Pointer to number of requested mipmap levels, or NULL. Returns the corrected number of mipmap levels. </param>
        /// <param name="usage"> 0 or {{D3DUSAGE_RENDERTARGET}}. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If D3DUSAGE_RENDERTARGET is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. </param>
        /// <param name="pFormat"> Pointer to a member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type. Specifies the desired pixel format, or NULL. Returns the corrected format. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE. </returns>
        /// <unmanaged>HRESULT D3DXCheckTextureRequirements([None] LPDIRECT3DDEVICE9 pDevice,[None] UINT* pWidth,[None] UINT* pHeight,[None] UINT* pNumMipLevels,[None] int Usage,[None] D3DFORMAT* pFormat,[None] D3DPOOL Pool)</unmanaged>
		public static SlimDX2.Result CheckTextureRequirements(SlimDX2.Direct3D9.Device pDevice, ref int pWidth, ref int pHeight, ref int pNumMipLevels, int usage, ref SlimDX2.Direct3D9.Format pFormat, SlimDX2.Direct3D9.Pool pool) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCheckTextureRequirements_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer, ref  pWidth, ref  pHeight, ref  pNumMipLevels,  usage, ref  pFormat,  pool);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCheckTextureRequirements([None] LPDIRECT3DDEVICE9 pDevice,[None] UINT* pWidth,[None] UINT* pHeight,[None] UINT* pNumMipLevels,[None] int Usage,[None] D3DFORMAT* pFormat,[None] D3DPOOL Pool)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCheckTextureRequirements", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCheckTextureRequirements_(IntPtr pDevice, ref int pWidth, ref int pHeight, ref int pNumMipLevels, int usage, ref SlimDX2.Direct3D9.Format pFormat, SlimDX2.Direct3D9.Pool pool);		
        
        /// <summary>	
        /// Checks cube-texture-creation parameters.	
        /// </summary>	
        /// <remarks>	
        ///  If parameters to this function are invalid, this function returns corrected parameters. Cube textures differ from other surfaces in that they are collections of surfaces. To call {{SetRenderTarget}} with a cube texture, you must select an individual face using {{GetCubeMapSurface}} and pass the resulting surface to SetRenderTarget. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="pSize"> Pointer to the requested width and height in pixels, or NULL. Returns the corrected size. </param>
        /// <param name="pNumMipLevels"> Pointer to the number of requested mipmap levels, or NULL. Returns the corrected number of mipmap levels. </param>
        /// <param name="usage"> 0 or D3DUSAGE_RENDERTARGET. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If D3DUSAGE_RENDERTARGET is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. </param>
        /// <param name="pFormat"> Pointer to a member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type. Specifies the desired pixel format, or NULL. Returns the corrected format. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXCheckCubeTextureRequirements([None] LPDIRECT3DDEVICE9 pDevice,[None] UINT* pSize,[None] UINT* pNumMipLevels,[None] int Usage,[None] D3DFORMAT* pFormat,[None] D3DPOOL Pool)</unmanaged>
		public static SlimDX2.Result CheckCubeTextureRequirements(SlimDX2.Direct3D9.Device pDevice, ref int pSize, ref int pNumMipLevels, int usage, ref SlimDX2.Direct3D9.Format pFormat, SlimDX2.Direct3D9.Pool pool) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCheckCubeTextureRequirements_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer, ref  pSize, ref  pNumMipLevels,  usage, ref  pFormat,  pool);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCheckCubeTextureRequirements([None] LPDIRECT3DDEVICE9 pDevice,[None] UINT* pSize,[None] UINT* pNumMipLevels,[None] int Usage,[None] D3DFORMAT* pFormat,[None] D3DPOOL Pool)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCheckCubeTextureRequirements", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCheckCubeTextureRequirements_(IntPtr pDevice, ref int pSize, ref int pNumMipLevels, int usage, ref SlimDX2.Direct3D9.Format pFormat, SlimDX2.Direct3D9.Pool pool);		
        
        /// <summary>	
        /// Checks volume-texture-creation parameters.	
        /// </summary>	
        /// <remarks>	
        ///  If parameters to this function are invalid, this function returns corrected parameters. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the volume texture. </param>
        /// <param name="pWidth"> Pointer to the requested width in pixels, or NULL. Returns the corrected size. </param>
        /// <param name="pHeight"> Pointer to the requested height in pixels, or NULL. Returns the corrected size. </param>
        /// <param name="pDepth"> Pointer to the requested depth in pixels, or NULL. Returns the corrected size. </param>
        /// <param name="pNumMipLevels"> Pointer to the number of requested mipmap levels, or NULL. Returns the corrected number of mipmap levels. </param>
        /// <param name="usage"> Currently not used, set to 0. </param>
        /// <param name="pFormat"> Pointer to a member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type. Specifies the desired pixel format, or NULL. Returns the corrected format. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the volume texture should be placed. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXCheckVolumeTextureRequirements([None] LPDIRECT3DDEVICE9 pDevice,[None] UINT* pWidth,[None] UINT* pHeight,[None] UINT* pDepth,[None] UINT* pNumMipLevels,[None] int Usage,[None] D3DFORMAT* pFormat,[None] D3DPOOL Pool)</unmanaged>
		public static SlimDX2.Result CheckVolumeTextureRequirements(SlimDX2.Direct3D9.Device pDevice, ref int pWidth, ref int pHeight, ref int pDepth, ref int pNumMipLevels, int usage, ref SlimDX2.Direct3D9.Format pFormat, SlimDX2.Direct3D9.Pool pool) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCheckVolumeTextureRequirements_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer, ref  pWidth, ref  pHeight, ref  pDepth, ref  pNumMipLevels,  usage, ref  pFormat,  pool);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCheckVolumeTextureRequirements([None] LPDIRECT3DDEVICE9 pDevice,[None] UINT* pWidth,[None] UINT* pHeight,[None] UINT* pDepth,[None] UINT* pNumMipLevels,[None] int Usage,[None] D3DFORMAT* pFormat,[None] D3DPOOL Pool)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCheckVolumeTextureRequirements", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCheckVolumeTextureRequirements_(IntPtr pDevice, ref int pWidth, ref int pHeight, ref int pDepth, ref int pNumMipLevels, int usage, ref SlimDX2.Direct3D9.Format pFormat, SlimDX2.Direct3D9.Pool pool);		
        
        /// <summary>	
        /// Creates an empty texture, adjusting the calling parameters as needed.	
        /// </summary>	
        /// <remarks>	
        ///  Internally, D3DXCreateTexture uses <see cref="SlimDX2.Direct3D9.D3DX9.CheckTextureRequirements"/> to adjust the calling parameters. Therefore, calls to D3DXCreateTexture will often succeed where calls to {{CreateTexture}} would fail. If both Height and Width are set to {{D3DX_DEFAULT}}, a value of 256 is used for both parameters. If either Height or Width is set to D3DX_DEFAULT And the other parameter is set to a numeric value, the texture will be square with both the height and width equal to the numeric value. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="width"> Width in pixels. If this value is 0, a value of 1 is used. See Remarks. </param>
        /// <param name="height"> Height in pixels. If this value is 0, a value of 1 is used. See Remarks. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, {{D3DUSAGE_RENDERTARGET}}, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target by calling the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE_DYNAMIC is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture may be of a different format from that specified, if the device does not support the requested format. Applications should check the format of the returned texture to see if it matches the format requested. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="ppTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTexture([None] LPDIRECT3DDEVICE9 pDevice,[None] UINT Width,[None] UINT Height,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result CreateTexture(SlimDX2.Direct3D9.Device pDevice, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.Texture ppTexture) {
            unsafe {
                IntPtr ppTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTexture_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  width,  height,  mipLevels,  usage,  format,  pool, out ppTexture_);
                ppTexture = (ppTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(ppTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTexture([None] LPDIRECT3DDEVICE9 pDevice,[None] UINT Width,[None] UINT Height,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTexture", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTexture_(IntPtr pDevice, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out IntPtr ppTexture);		
        
        /// <summary>	
        /// Creates an empty cube texture, adjusting the calling parameters as needed.	
        /// </summary>	
        /// <remarks>	
        ///  Cube textures differ from other surfaces in that they are collections of surfaces.  Internally, D3DXCreateCubeTexture uses <see cref="SlimDX2.Direct3D9.D3DX9.CheckCubeTextureRequirements"/> to adjust the calling parameters. Therefore, calls to D3DXCreateCubeTexture will often succeed where calls to {{CreateCubeTexture}} would fail. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="size"> Width and height of the cube texture, in pixels. For example, if the cube texture is an 8-pixel by 8-pixel cube, the value for this parameter should be 8. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If D3DUSAGE_RENDERTARGET is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the cube texture. The returned cube texture might have a different format from that specified by  Format. Applications should check the format of the returned cube texture. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the cube texture should be placed. </param>
        /// <param name="ppCubeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTexture([None] LPDIRECT3DDEVICE9 pDevice,[None] UINT Size,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result CreateCubeTexture(SlimDX2.Direct3D9.Device pDevice, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.CubeTexture ppCubeTexture) {
            unsafe {
                IntPtr ppCubeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTexture_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  size,  mipLevels,  usage,  format,  pool, out ppCubeTexture_);
                ppCubeTexture = (ppCubeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(ppCubeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTexture([None] LPDIRECT3DDEVICE9 pDevice,[None] UINT Size,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTexture", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTexture_(IntPtr pDevice, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out IntPtr ppCubeTexture);		
        
        /// <summary>	
        /// Creates an empty volume texture, adjusting the calling parameters as needed.	
        /// </summary>	
        /// <remarks>	
        ///  Internally, D3DXCreateVolumeTexture uses <see cref="SlimDX2.Direct3D9.D3DX9.CheckVolumeTextureRequirements"/> to adjust the calling parameters. Therefore, calls to D3DXCreateVolumeTexture will often succeed where calls to {{CreateVolumeTexture}} would fail. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the volume texture. </param>
        /// <param name="width"> Width in pixels. This value must be nonzero. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="height"> Height in pixels. This value must be nonzero. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="depth"> Depth in pixels. This value must be nonzero. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0 or D3DUSAGE_DYNAMIC. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the volume texture. The returned volume texture might have a different format from that specified by Format. Applications should check the format of the returned volume texture. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the volume texture should be placed. </param>
        /// <param name="ppVolumeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the created volume texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, E_OUTOFMEMORY . </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTexture([None] LPDIRECT3DDEVICE9 pDevice,[None] UINT Width,[None] UINT Height,[None] UINT Depth,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result CreateVolumeTexture(SlimDX2.Direct3D9.Device pDevice, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.VolumeTexture ppVolumeTexture) {
            unsafe {
                IntPtr ppVolumeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTexture_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  width,  height,  depth,  mipLevels,  usage,  format,  pool, out ppVolumeTexture_);
                ppVolumeTexture = (ppVolumeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(ppVolumeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTexture([None] LPDIRECT3DDEVICE9 pDevice,[None] UINT Width,[None] UINT Height,[None] UINT Depth,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTexture", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTexture_(IntPtr pDevice, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out IntPtr ppVolumeTexture);		
        
        /// <summary>	
        /// Creates a texture from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromFileW. Otherwise, the function call resolves to D3DXCreateTextureFromFileA because ANSI strings are being used. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. The function is equivalent to D3DXCreateTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture). Mipmapped textures automatically have each level filled with the loaded texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, the images need to be loaded manually. Note that a resource created with this function will be placed in the memory class denoted by D3DPOOL_MANAGED. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. For the best performance when using D3DXCreateTextureFromFile:  Doing image scaling and format conversion at load time can be slow. Store images in the format and resolution they will be used. If the target hardware requires power of two dimensions, create and store images using power of two dimensions. Consider using DirectDraw surface (DDS) files. Because DDS files can be used to represent any Direct3D 9 texture format, they are very easy for D3DX to read. Also, they can store mipmaps, so any mipmap-generation algorithms can be used to author the images.  	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="ppTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result CreateTextureFromFileA(SlimDX2.Direct3D9.Device pDevice, string pSrcFile, out SlimDX2.Direct3D9.Texture ppTexture) {
            unsafe {
                IntPtr ppTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromFileA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcFile, out ppTexture_);
                ppTexture = (ppTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(ppTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromFileA_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPStr),In] string pSrcFile, out IntPtr ppTexture);		
        
        /// <summary>	
        /// Creates a texture from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromFileW. Otherwise, the function call resolves to D3DXCreateTextureFromFileA because ANSI strings are being used. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. The function is equivalent to D3DXCreateTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture). Mipmapped textures automatically have each level filled with the loaded texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, the images need to be loaded manually. Note that a resource created with this function will be placed in the memory class denoted by D3DPOOL_MANAGED. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. For the best performance when using D3DXCreateTextureFromFile:  Doing image scaling and format conversion at load time can be slow. Store images in the format and resolution they will be used. If the target hardware requires power of two dimensions, create and store images using power of two dimensions. Consider using DirectDraw surface (DDS) files. Because DDS files can be used to represent any Direct3D 9 texture format, they are very easy for D3DX to read. Also, they can store mipmaps, so any mipmap-generation algorithms can be used to author the images.  	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="ppTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar* pSrcFile,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result CreateTextureFromFileW(SlimDX2.Direct3D9.Device pDevice, string pSrcFile, out SlimDX2.Direct3D9.Texture ppTexture) {
            unsafe {
                IntPtr ppTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromFileW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcFile, out ppTexture_);
                ppTexture = (ppTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(ppTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar* pSrcFile,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromFileW_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcFile, out IntPtr ppTexture);		
        
        /// <summary>	
        /// Creates a cube texture from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateCubeTextureFromFileW. Otherwise, the function call resolves to D3DXCreateCubeTextureFromFileA because ANSI strings are being used. The function is equivalent to D3DXCreateCubeTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppCubeTexture). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. D3DXCreateCubeTextureFromFile uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="ppCubeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result CreateCubeTextureFromFileA(SlimDX2.Direct3D9.Device pDevice, string pSrcFile, out SlimDX2.Direct3D9.CubeTexture ppCubeTexture) {
            unsafe {
                IntPtr ppCubeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromFileA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcFile, out ppCubeTexture_);
                ppCubeTexture = (ppCubeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(ppCubeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromFileA_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPStr),In] string pSrcFile, out IntPtr ppCubeTexture);		
        
        /// <summary>	
        /// Creates a cube texture from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateCubeTextureFromFileW. Otherwise, the function call resolves to D3DXCreateCubeTextureFromFileA because ANSI strings are being used. The function is equivalent to D3DXCreateCubeTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppCubeTexture). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. D3DXCreateCubeTextureFromFile uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="ppCubeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar* pSrcFile,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result CreateCubeTextureFromFileW(SlimDX2.Direct3D9.Device pDevice, string pSrcFile, out SlimDX2.Direct3D9.CubeTexture ppCubeTexture) {
            unsafe {
                IntPtr ppCubeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromFileW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcFile, out ppCubeTexture_);
                ppCubeTexture = (ppCubeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(ppCubeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar* pSrcFile,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromFileW_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcFile, out IntPtr ppCubeTexture);		
        
        /// <summary>	
        /// Creates a volume texture from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateVolumeTextureFromFileW. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromFileA because ANSI strings are being used. The function is equivalent to D3DXCreateVolumeTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppVolumeTexture). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Mipmapped textures automatically have each level filled with the loaded texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, then the images need to be loaded manually. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the volume texture. </param>
        /// <param name="pSrcFile"> Pointer to a string that specifies the file name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="ppVolumeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result CreateVolumeTextureFromFileA(SlimDX2.Direct3D9.Device pDevice, string pSrcFile, out SlimDX2.Direct3D9.VolumeTexture ppVolumeTexture) {
            unsafe {
                IntPtr ppVolumeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromFileA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcFile, out ppVolumeTexture_);
                ppVolumeTexture = (ppVolumeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(ppVolumeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromFileA_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPStr),In] string pSrcFile, out IntPtr ppVolumeTexture);		
        
        /// <summary>	
        /// Creates a volume texture from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateVolumeTextureFromFileW. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromFileA because ANSI strings are being used. The function is equivalent to D3DXCreateVolumeTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppVolumeTexture). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Mipmapped textures automatically have each level filled with the loaded texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, then the images need to be loaded manually. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the volume texture. </param>
        /// <param name="pSrcFile"> Pointer to a string that specifies the file name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="ppVolumeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar* pSrcFile,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result CreateVolumeTextureFromFileW(SlimDX2.Direct3D9.Device pDevice, string pSrcFile, out SlimDX2.Direct3D9.VolumeTexture ppVolumeTexture) {
            unsafe {
                IntPtr ppVolumeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromFileW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcFile, out ppVolumeTexture_);
                ppVolumeTexture = (ppVolumeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(ppVolumeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar* pSrcFile,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromFileW_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcFile, out IntPtr ppVolumeTexture);		
        
        /// <summary>	
        /// Creates a texture from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromResourceW. Otherwise, the function call resolves to D3DXCreateTextureFromResourceA because ANSI strings are being used. The function is equivalent to D3DXCreateTextureFromResourceEx(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture). The resource being loaded must be of type RT_BITMAP or RT_RCDATA. Resource type RT_RCDATA is used to load formats other than bitmaps (such as .tga, .jpg, and .dds). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="ppTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceA([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result CreateTextureFromResourceA(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string pSrcResource, out SlimDX2.Direct3D9.Texture ppTexture) {
            unsafe {
                IntPtr ppTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromResourceA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  pSrcResource, out ppTexture_);
                ppTexture = (ppTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(ppTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceA([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromResourceA_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string pSrcResource, out IntPtr ppTexture);		
        
        /// <summary>	
        /// Creates a texture from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromResourceW. Otherwise, the function call resolves to D3DXCreateTextureFromResourceA because ANSI strings are being used. The function is equivalent to D3DXCreateTextureFromResourceEx(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture). The resource being loaded must be of type RT_BITMAP or RT_RCDATA. Resource type RT_RCDATA is used to load formats other than bitmaps (such as .tga, .jpg, and .dds). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="ppTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceW([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result CreateTextureFromResourceW(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string pSrcResource, out SlimDX2.Direct3D9.Texture ppTexture) {
            unsafe {
                IntPtr ppTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromResourceW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  pSrcResource, out ppTexture_);
                ppTexture = (ppTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(ppTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceW([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromResourceW_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcResource, out IntPtr ppTexture);		
        
        /// <summary>	
        /// Creates a cube texture from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting determines the function version. If Unicode is defined, the function call resolves to D3DXCreateCubeTextureFromResourceW. Otherwise, the function call resolves to D3DXCreateCubeTextureFromResourceA because ANSI strings are being used. The function is equivalent to D3DXCreateCubeTextureFromResourceEx(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppCubeTexture). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. D3DXCreateCubeTextureFromResource uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for the module associated with the image the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="ppCubeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceA([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result CreateCubeTextureFromResourceA(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string pSrcResource, out SlimDX2.Direct3D9.CubeTexture ppCubeTexture) {
            unsafe {
                IntPtr ppCubeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromResourceA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  pSrcResource, out ppCubeTexture_);
                ppCubeTexture = (ppCubeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(ppCubeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceA([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromResourceA_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string pSrcResource, out IntPtr ppCubeTexture);		
        
        /// <summary>	
        /// Creates a cube texture from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting determines the function version. If Unicode is defined, the function call resolves to D3DXCreateCubeTextureFromResourceW. Otherwise, the function call resolves to D3DXCreateCubeTextureFromResourceA because ANSI strings are being used. The function is equivalent to D3DXCreateCubeTextureFromResourceEx(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppCubeTexture). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. D3DXCreateCubeTextureFromResource uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for the module associated with the image the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="ppCubeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceW([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result CreateCubeTextureFromResourceW(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string pSrcResource, out SlimDX2.Direct3D9.CubeTexture ppCubeTexture) {
            unsafe {
                IntPtr ppCubeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromResourceW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  pSrcResource, out ppCubeTexture_);
                ppCubeTexture = (ppCubeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(ppCubeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceW([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromResourceW_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcResource, out IntPtr ppCubeTexture);		
        
        /// <summary>	
        /// Creates a volume texture from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateVolumeTextureFromResourceW. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromResourceA because ANSI strings are being used. The function is equivalent to D3DXCreateVolumeTextureFromResourceEx(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppVolumeTexture). The resource being loaded must be an application-defined resource (RT_RCDATA). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the volume texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for the module associated with the image the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="ppVolumeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceA([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result CreateVolumeTextureFromResourceA(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string pSrcResource, out SlimDX2.Direct3D9.VolumeTexture ppVolumeTexture) {
            unsafe {
                IntPtr ppVolumeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromResourceA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  pSrcResource, out ppVolumeTexture_);
                ppVolumeTexture = (ppVolumeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(ppVolumeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceA([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromResourceA_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string pSrcResource, out IntPtr ppVolumeTexture);		
        
        /// <summary>	
        /// Creates a volume texture from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateVolumeTextureFromResourceW. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromResourceA because ANSI strings are being used. The function is equivalent to D3DXCreateVolumeTextureFromResourceEx(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppVolumeTexture). The resource being loaded must be an application-defined resource (RT_RCDATA). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the volume texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for the module associated with the image the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="ppVolumeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceW([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result CreateVolumeTextureFromResourceW(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string pSrcResource, out SlimDX2.Direct3D9.VolumeTexture ppVolumeTexture) {
            unsafe {
                IntPtr ppVolumeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromResourceW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  pSrcResource, out ppVolumeTexture_);
                ppVolumeTexture = (ppVolumeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(ppVolumeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceW([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromResourceW_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcResource, out IntPtr ppVolumeTexture);		
        
        /// <summary>	
        /// Creates a texture from a file. This is a more advanced function than {{D3DXCreateTextureFromFile}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromFileExW. Otherwise, the function call resolves to D3DXCreateTextureFromFileExA because ANSI strings are being used. Use <see cref="SlimDX2.Direct3D9.D3DX9.CheckTextureRequirements"/> to determine if your device can support the texture given the current state. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Mipmapped textures automatically have each level filled with the loaded texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, then the images need to be loaded manually. For the best performance when using D3DXCreateTextureFromFileEx:  Doing image scaling and format conversion at load time can be slow. Store images in the format and resolution they will be used. If the target hardware requires power of 2 dimensions, then create and store images using power of 2 dimensions. For mipmap image creation at load time, filter using {{D3DX_FILTER_BOX}}. A box filter is much faster than other filter types such as D3DX_FILTER_TRIANGLE. Consider using DDS files. Since DDS files can be used to represent any Direct3D 9 texture format, they are very easy for D3DX to read. Also, they can store mipmaps, so any mipmap-generation algorithms can be used to author the images.  When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file and rounded up to a power of two. If the device supports non-power of 2 textures and {{D3DX_DEFAULT_NONPOW2}} is specified, the size will not be rounded. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file and rounded up to a power of two. If the device supports non-power of 2 textures and {{D3DX_DEFAULT_NONPOW2}} is sepcified, the size will not be rounded. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. If D3DX_FROM_FILE, the size will be taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="usage"> 0, {{D3DUSAGE_RENDERTARGET}}, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET    or D3DUSAGE_DYNAMIC is specified, Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. See {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If D3DFMT_UNKNOWN, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} constants controlling how the image is filtered. Specifying {{D3DX_DEFAULT}} for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} constants controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the color key. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled in with a description of the data in the source image file, or NULL. </param>
        /// <param name="pPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="ppTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileExA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] UINT Width,[None] UINT Height,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result CreateTextureFromFileExA(SlimDX2.Direct3D9.Device pDevice, string pSrcFile, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out SlimDX2.Direct3D9.Texture ppTexture) {
            unsafe {
                IntPtr ppTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromFileExA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcFile,  width,  height,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  pSrcInfo, ref  pPalette, out ppTexture_);
                ppTexture = (ppTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(ppTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileExA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] UINT Width,[None] UINT Height,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromFileExA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromFileExA_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPStr),In] string pSrcFile, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out IntPtr ppTexture);		
        
        /// <summary>	
        /// Creates a texture from a file. This is a more advanced function than {{D3DXCreateTextureFromFile}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromFileExW. Otherwise, the function call resolves to D3DXCreateTextureFromFileExA because ANSI strings are being used. Use <see cref="SlimDX2.Direct3D9.D3DX9.CheckTextureRequirements"/> to determine if your device can support the texture given the current state. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Mipmapped textures automatically have each level filled with the loaded texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, then the images need to be loaded manually. For the best performance when using D3DXCreateTextureFromFileEx:  Doing image scaling and format conversion at load time can be slow. Store images in the format and resolution they will be used. If the target hardware requires power of 2 dimensions, then create and store images using power of 2 dimensions. For mipmap image creation at load time, filter using {{D3DX_FILTER_BOX}}. A box filter is much faster than other filter types such as D3DX_FILTER_TRIANGLE. Consider using DDS files. Since DDS files can be used to represent any Direct3D 9 texture format, they are very easy for D3DX to read. Also, they can store mipmaps, so any mipmap-generation algorithms can be used to author the images.  When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file and rounded up to a power of two. If the device supports non-power of 2 textures and {{D3DX_DEFAULT_NONPOW2}} is specified, the size will not be rounded. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file and rounded up to a power of two. If the device supports non-power of 2 textures and {{D3DX_DEFAULT_NONPOW2}} is sepcified, the size will not be rounded. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. If D3DX_FROM_FILE, the size will be taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="usage"> 0, {{D3DUSAGE_RENDERTARGET}}, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET    or D3DUSAGE_DYNAMIC is specified, Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. See {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If D3DFMT_UNKNOWN, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} constants controlling how the image is filtered. Specifying {{D3DX_DEFAULT}} for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} constants controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the color key. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled in with a description of the data in the source image file, or NULL. </param>
        /// <param name="pPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="ppTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileExW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar* pSrcFile,[None] UINT Width,[None] UINT Height,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result CreateTextureFromFileExW(SlimDX2.Direct3D9.Device pDevice, string pSrcFile, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out SlimDX2.Direct3D9.Texture ppTexture) {
            unsafe {
                IntPtr ppTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromFileExW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcFile,  width,  height,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  pSrcInfo, ref  pPalette, out ppTexture_);
                ppTexture = (ppTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(ppTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileExW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar* pSrcFile,[None] UINT Width,[None] UINT Height,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromFileExW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromFileExW_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcFile, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out IntPtr ppTexture);		
        
        /// <summary>	
        /// Creates a cube texture from a file. This is a more advanced function than {{D3DXCreateCubeTextureFromFile}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateCubeTextureFromFileExW. Otherwise, the function call resolves to D3DXCreateCubeTextureFromFileExA because ANSI strings are being used. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Cube textures differ from other surfaces in that they are collections of surfaces. To call {{SetRenderTarget}} with a cube texture, you must select an individual face using {{GetCubeMapSurface}} and pass the resulting surface to SetRenderTarget. D3DXCreateCubeTextureFromFileEx uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="size"> Width and height of the cube texture, in pixels. For example, if the cube texture is an 8-pixel by 8-pixel cube, the value for this parameter should be 8. If this value is 0 or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0 or D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If D3DUSAGE_RENDERTARGET is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the cube texture. The returned cube texture might have a different format from that specified by Format. Applications should check the format of the returned cube texture. If <see cref="SlimDX2.Direct3D9.Format.MtUnknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the cube texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} constants, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} constants controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant, and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <param name="pPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="ppCubeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileExA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] UINT Size,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result CreateCubeTextureFromFileExA(SlimDX2.Direct3D9.Device pDevice, string pSrcFile, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out SlimDX2.Direct3D9.CubeTexture ppCubeTexture) {
            unsafe {
                IntPtr ppCubeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromFileExA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcFile,  size,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  pSrcInfo, ref  pPalette, out ppCubeTexture_);
                ppCubeTexture = (ppCubeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(ppCubeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileExA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] UINT Size,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromFileExA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromFileExA_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPStr),In] string pSrcFile, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out IntPtr ppCubeTexture);		
        
        /// <summary>	
        /// Creates a cube texture from a file. This is a more advanced function than {{D3DXCreateCubeTextureFromFile}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateCubeTextureFromFileExW. Otherwise, the function call resolves to D3DXCreateCubeTextureFromFileExA because ANSI strings are being used. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Cube textures differ from other surfaces in that they are collections of surfaces. To call {{SetRenderTarget}} with a cube texture, you must select an individual face using {{GetCubeMapSurface}} and pass the resulting surface to SetRenderTarget. D3DXCreateCubeTextureFromFileEx uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="size"> Width and height of the cube texture, in pixels. For example, if the cube texture is an 8-pixel by 8-pixel cube, the value for this parameter should be 8. If this value is 0 or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0 or D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If D3DUSAGE_RENDERTARGET is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the cube texture. The returned cube texture might have a different format from that specified by Format. Applications should check the format of the returned cube texture. If <see cref="SlimDX2.Direct3D9.Format.MtUnknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the cube texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} constants, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} constants controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant, and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <param name="pPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="ppCubeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileExW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar* pSrcFile,[None] UINT Size,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result CreateCubeTextureFromFileExW(SlimDX2.Direct3D9.Device pDevice, string pSrcFile, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out SlimDX2.Direct3D9.CubeTexture ppCubeTexture) {
            unsafe {
                IntPtr ppCubeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromFileExW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcFile,  size,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  pSrcInfo, ref  pPalette, out ppCubeTexture_);
                ppCubeTexture = (ppCubeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(ppCubeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileExW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar* pSrcFile,[None] UINT Size,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromFileExW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromFileExW_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcFile, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out IntPtr ppCubeTexture);		
        
        /// <summary>	
        /// Creates a volume texture from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateVolumeTextureFromFileExW. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromFileExA because ANSI strings are being used. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Mipmapped textures automatically have each level filled with the loaded volume texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, then the images need to be loaded manually. When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="depth"> Depth, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the  pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE_DYNAMIC is specified,  Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.MtUnknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled in with a description of the data in the source image file, or NULL. </param>
        /// <param name="pPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="ppVolumeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileExA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] UINT Width,[None] UINT Height,[None] UINT Depth,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result CreateVolumeTextureFromFileExA(SlimDX2.Direct3D9.Device pDevice, string pSrcFile, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out SlimDX2.Direct3D9.VolumeTexture ppVolumeTexture) {
            unsafe {
                IntPtr ppVolumeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromFileExA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcFile,  width,  height,  depth,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  pSrcInfo, ref  pPalette, out ppVolumeTexture_);
                ppVolumeTexture = (ppVolumeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(ppVolumeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileExA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] UINT Width,[None] UINT Height,[None] UINT Depth,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromFileExA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromFileExA_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPStr),In] string pSrcFile, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out IntPtr ppVolumeTexture);		
        
        /// <summary>	
        /// Creates a volume texture from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateVolumeTextureFromFileExW. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromFileExA because ANSI strings are being used. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Mipmapped textures automatically have each level filled with the loaded volume texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, then the images need to be loaded manually. When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="pSrcFile"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="depth"> Depth, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the  pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE_DYNAMIC is specified,  Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.MtUnknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled in with a description of the data in the source image file, or NULL. </param>
        /// <param name="pPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="ppVolumeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileExW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar* pSrcFile,[None] UINT Width,[None] UINT Height,[None] UINT Depth,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result CreateVolumeTextureFromFileExW(SlimDX2.Direct3D9.Device pDevice, string pSrcFile, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out SlimDX2.Direct3D9.VolumeTexture ppVolumeTexture) {
            unsafe {
                IntPtr ppVolumeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromFileExW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcFile,  width,  height,  depth,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  pSrcInfo, ref  pPalette, out ppVolumeTexture_);
                ppVolumeTexture = (ppVolumeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(ppVolumeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileExW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar* pSrcFile,[None] UINT Width,[None] UINT Height,[None] UINT Depth,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromFileExW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromFileExW_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcFile, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out IntPtr ppVolumeTexture);		
        
        /// <summary>	
        /// Creates a texture from a resource. This is a more advanced function than {{D3DXCreateTextureFromResource}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromResourceExW. Otherwise, the function call resolves to D3DXCreateTextureFromResourceExA because ANSI strings are being used. The resource being loaded must be of type RT_BITMAP or RT_RCDATA. Resource type RT_RCDATA is used to load formats other than bitmaps (such as .tga, .jpg, and .dds). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE is specified, Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Performance Optimizations (Direct3D 9)}}Using Dynamic Textures. </param>
        /// <param name="format"> A member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.MtUnknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <param name="pPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in or NULL. </param>
        /// <param name="ppTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceExA([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] UINT Width,[None] UINT Height,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result CreateTextureFromResourceExA(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string pSrcResource, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out SlimDX2.Direct3D9.Texture ppTexture) {
            unsafe {
                IntPtr ppTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromResourceExA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  pSrcResource,  width,  height,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  pSrcInfo, ref  pPalette, out ppTexture_);
                ppTexture = (ppTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(ppTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceExA([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] UINT Width,[None] UINT Height,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromResourceExA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromResourceExA_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string pSrcResource, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out IntPtr ppTexture);		
        
        /// <summary>	
        /// Creates a texture from a resource. This is a more advanced function than {{D3DXCreateTextureFromResource}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromResourceExW. Otherwise, the function call resolves to D3DXCreateTextureFromResourceExA because ANSI strings are being used. The resource being loaded must be of type RT_BITMAP or RT_RCDATA. Resource type RT_RCDATA is used to load formats other than bitmaps (such as .tga, .jpg, and .dds). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE is specified, Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Performance Optimizations (Direct3D 9)}}Using Dynamic Textures. </param>
        /// <param name="format"> A member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.MtUnknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <param name="pPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in or NULL. </param>
        /// <param name="ppTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceExW([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] UINT Width,[None] UINT Height,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result CreateTextureFromResourceExW(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string pSrcResource, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out SlimDX2.Direct3D9.Texture ppTexture) {
            unsafe {
                IntPtr ppTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromResourceExW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  pSrcResource,  width,  height,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  pSrcInfo, ref  pPalette, out ppTexture_);
                ppTexture = (ppTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(ppTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceExW([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] UINT Width,[None] UINT Height,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromResourceExW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromResourceExW_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcResource, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out IntPtr ppTexture);		
        
        /// <summary>	
        /// Creates a cube texture from a resource specified by a string. This is a more advanced function than {{D3DXCreateCubeTextureFromResource}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting determines the function version. If Unicode is defined, the function call resolves to D3DXCreateCubeTextureFromResourceExW. Otherwise, the function call resolves to D3DXCreateCubeTextureFromResourceExA because ANSI strings are being used. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Cube textures differ from other surfaces in that they are collections of surfaces. To call {{SetRenderTarget}} with a cube texture, you must select an individual face using {{GetCubeMapSurface}} and pass the resulting surface to  SetRenderTarget. D3DXCreateCubeTextureFromResourceEx uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for the module associated with the image the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="size"> Width and height of the cube texture, in pixels. For example, if the cube texture is an 8-pixel by 8-pixel cube, the value for this parameter should be 8. If this value is 0 or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0 or D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the  pNewRenderTarget parameter of the {{SetRenderTarget}} method. If D3DUSAGE_RENDERTARGET is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the cube texture. The returned cube texture might have a different format from that specified by Format. Applications should check the format of the returned cube texture. If <see cref="SlimDX2.Direct3D9.Format.MtUnknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the cube texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant, and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <param name="pPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in or NULL. </param>
        /// <param name="ppCubeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceExA([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] UINT Size,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result CreateCubeTextureFromResourceExA(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string pSrcResource, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out SlimDX2.Direct3D9.CubeTexture ppCubeTexture) {
            unsafe {
                IntPtr ppCubeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromResourceExA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  pSrcResource,  size,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  pSrcInfo, ref  pPalette, out ppCubeTexture_);
                ppCubeTexture = (ppCubeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(ppCubeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceExA([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] UINT Size,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromResourceExA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromResourceExA_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string pSrcResource, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out IntPtr ppCubeTexture);		
        
        /// <summary>	
        /// Creates a cube texture from a resource specified by a string. This is a more advanced function than {{D3DXCreateCubeTextureFromResource}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting determines the function version. If Unicode is defined, the function call resolves to D3DXCreateCubeTextureFromResourceExW. Otherwise, the function call resolves to D3DXCreateCubeTextureFromResourceExA because ANSI strings are being used. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Cube textures differ from other surfaces in that they are collections of surfaces. To call {{SetRenderTarget}} with a cube texture, you must select an individual face using {{GetCubeMapSurface}} and pass the resulting surface to  SetRenderTarget. D3DXCreateCubeTextureFromResourceEx uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for the module associated with the image the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="size"> Width and height of the cube texture, in pixels. For example, if the cube texture is an 8-pixel by 8-pixel cube, the value for this parameter should be 8. If this value is 0 or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0 or D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the  pNewRenderTarget parameter of the {{SetRenderTarget}} method. If D3DUSAGE_RENDERTARGET is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the cube texture. The returned cube texture might have a different format from that specified by Format. Applications should check the format of the returned cube texture. If <see cref="SlimDX2.Direct3D9.Format.MtUnknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the cube texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant, and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <param name="pPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in or NULL. </param>
        /// <param name="ppCubeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceExW([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] UINT Size,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result CreateCubeTextureFromResourceExW(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string pSrcResource, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out SlimDX2.Direct3D9.CubeTexture ppCubeTexture) {
            unsafe {
                IntPtr ppCubeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromResourceExW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  pSrcResource,  size,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  pSrcInfo, ref  pPalette, out ppCubeTexture_);
                ppCubeTexture = (ppCubeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(ppCubeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceExW([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] UINT Size,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromResourceExW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromResourceExW_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcResource, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out IntPtr ppCubeTexture);		
        
        /// <summary>	
        /// Creates a volume texture from a resource specified by a string. This is a more advanced function than {{D3DXCreateVolumeTextureFromResource}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateVolumeTextureFromResourceExW. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromResourceExA because ANSI strings are being used. The resource being loaded must be an application-defined resource (RT_RCDATA). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="depth"> Depth, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE_DYNAMIC is specified, Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.MtUnknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled in with a description of the data in the source image file, or NULL. </param>
        /// <param name="pPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="ppVolumeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceExA([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] UINT Width,[None] UINT Height,[None] UINT Depth,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result CreateVolumeTextureFromResourceExA(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string pSrcResource, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out SlimDX2.Direct3D9.VolumeTexture ppVolumeTexture) {
            unsafe {
                IntPtr ppVolumeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromResourceExA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  pSrcResource,  width,  height,  depth,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  pSrcInfo, ref  pPalette, out ppVolumeTexture_);
                ppVolumeTexture = (ppVolumeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(ppVolumeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceExA([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const char* pSrcResource,[None] UINT Width,[None] UINT Height,[None] UINT Depth,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromResourceExA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromResourceExA_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string pSrcResource, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out IntPtr ppVolumeTexture);		
        
        /// <summary>	
        /// Creates a volume texture from a resource specified by a string. This is a more advanced function than {{D3DXCreateVolumeTextureFromResource}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateVolumeTextureFromResourceExW. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromResourceExA because ANSI strings are being used. The resource being loaded must be an application-defined resource (RT_RCDATA). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="pSrcResource"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="depth"> Depth, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE_DYNAMIC is specified, Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.MtUnknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled in with a description of the data in the source image file, or NULL. </param>
        /// <param name="pPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="ppVolumeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceExW([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] UINT Width,[None] UINT Height,[None] UINT Depth,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result CreateVolumeTextureFromResourceExW(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string pSrcResource, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out SlimDX2.Direct3D9.VolumeTexture ppVolumeTexture) {
            unsafe {
                IntPtr ppVolumeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromResourceExW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  pSrcResource,  width,  height,  depth,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  pSrcInfo, ref  pPalette, out ppVolumeTexture_);
                ppVolumeTexture = (ppVolumeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(ppVolumeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceExW([None] LPDIRECT3DDEVICE9 pDevice,[None] HMODULE hSrcModule,[None] const wchar* pSrcResource,[None] UINT Width,[None] UINT Height,[None] UINT Depth,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromResourceExW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromResourceExW_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string pSrcResource, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out IntPtr ppVolumeTexture);		
        
        /// <summary>	
        /// Creates a texture from a file in memory.	
        /// </summary>	
        /// <remarks>	
        ///  The function is equivalent to D3DXCreateTextureFromFileInMemoryEx(pDevice, pSrcData, SrcDataSize, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface representing the device to be associated with the texture. </param>
        /// <param name="pSrcData"> Pointer to the file in memory from which to create the texture. </param>
        /// <param name="srcDataSize"> Size in bytes of the file in memory. </param>
        /// <param name="ppTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileInMemory([None] LPDIRECT3DDEVICE9 pDevice,[None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result CreateTextureFromFileInMemory(SlimDX2.Direct3D9.Device pDevice, IntPtr pSrcData, int srcDataSize, out SlimDX2.Direct3D9.Texture ppTexture) {
            unsafe {
                IntPtr ppTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromFileInMemory_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcData,  srcDataSize, out ppTexture_);
                ppTexture = (ppTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(ppTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileInMemory([None] LPDIRECT3DDEVICE9 pDevice,[None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromFileInMemory_(IntPtr pDevice, IntPtr pSrcData, int srcDataSize, out IntPtr ppTexture);		
        
        /// <summary>	
        /// Creates a cube texture from a file in memory.	
        /// </summary>	
        /// <remarks>	
        ///  This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. The function is equivalent to D3DXCreateCubeTextureFromFileInMemoryEx(pDevice, pSrcData, SrcDataSize, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppCubeTexture). Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. This method is designed to be used for loading image files stored as RT_RCDATA, which is an application-defined resource (raw data). Otherwise this method will fail. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. D3DXCreateCubeTextureFromFileInMemory uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="pSrcData"> Pointer to the file in memory from which to create the cubemap. See Remarks. </param>
        /// <param name="srcDataSize"> Size of the file in memory, in bytes. </param>
        /// <param name="ppCubeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileInMemory([None] LPDIRECT3DDEVICE9 pDevice,[None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result CreateCubeTextureFromFileInMemory(SlimDX2.Direct3D9.Device pDevice, IntPtr pSrcData, int srcDataSize, out SlimDX2.Direct3D9.CubeTexture ppCubeTexture) {
            unsafe {
                IntPtr ppCubeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromFileInMemory_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcData,  srcDataSize, out ppCubeTexture_);
                ppCubeTexture = (ppCubeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(ppCubeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileInMemory([None] LPDIRECT3DDEVICE9 pDevice,[None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromFileInMemory_(IntPtr pDevice, IntPtr pSrcData, int srcDataSize, out IntPtr ppCubeTexture);		
        
        /// <summary>	
        /// Creates a volume texture from a file in memory.	
        /// </summary>	
        /// <remarks>	
        ///  This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. The function is equivalent to D3DXCreateVolumeTextureFromFileInMemoryEx(pDevice, pSrcFile, SrcData, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppVolumeTexture). Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the volume texture. </param>
        /// <param name="pSrcData"> Pointer to the file in memory from which to create the volume texture. </param>
        /// <param name="srcDataSize"> Size of the file in memory, in bytes. </param>
        /// <param name="ppVolumeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileInMemory([None] LPDIRECT3DDEVICE9 pDevice,[None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result CreateVolumeTextureFromFileInMemory(SlimDX2.Direct3D9.Device pDevice, IntPtr pSrcData, int srcDataSize, out SlimDX2.Direct3D9.VolumeTexture ppVolumeTexture) {
            unsafe {
                IntPtr ppVolumeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromFileInMemory_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcData,  srcDataSize, out ppVolumeTexture_);
                ppVolumeTexture = (ppVolumeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(ppVolumeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileInMemory([None] LPDIRECT3DDEVICE9 pDevice,[None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromFileInMemory_(IntPtr pDevice, IntPtr pSrcData, int srcDataSize, out IntPtr ppVolumeTexture);		
        
        /// <summary>	
        /// Creates a texture from a file in memory. This is a more advanced function than <see cref="SlimDX2.Direct3D9.D3DX9.CreateTextureFromFileInMemory"/>.	
        /// </summary>	
        /// <remarks>	
        ///  This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. For details about  <see cref="SlimDX2.Windows.Paletteentry"/>, see the Platform SDK. Note that as of DirectX 8.0, the peFlags member of the PALETTEENTRY structure does not function as documented in the Platform SDK. The peFlags member is now the alpha channel for 8-bit palettized formats. When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="pSrcData"> Pointer to the file in memory from which to create the texture. </param>
        /// <param name="srcDataSize"> Size of the file in memory, in bytes. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the  pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE_DYNAMIC is specified, Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.MtUnknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> Combination of one or more flags controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. Each valid filter must contain one of the flags in {{D3DX_FILTER}}.  </param>
        /// <param name="mipFilter"> Combination of one or more flags controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. Each valid filter must contain one of the flags in {{D3DX_FILTER}}. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <param name="pPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. See Remarks. </param>
        /// <param name="ppTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileInMemoryEx([None] LPDIRECT3DDEVICE9 pDevice,[None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] UINT Width,[None] UINT Height,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result CreateTextureFromFileInMemoryEx(SlimDX2.Direct3D9.Device pDevice, IntPtr pSrcData, int srcDataSize, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out SlimDX2.Direct3D9.Texture ppTexture) {
            unsafe {
                IntPtr ppTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromFileInMemoryEx_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcData,  srcDataSize,  width,  height,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  pSrcInfo, ref  pPalette, out ppTexture_);
                ppTexture = (ppTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(ppTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileInMemoryEx([None] LPDIRECT3DDEVICE9 pDevice,[None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] UINT Width,[None] UINT Height,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromFileInMemoryEx", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromFileInMemoryEx_(IntPtr pDevice, IntPtr pSrcData, int srcDataSize, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out IntPtr ppTexture);		
        
        /// <summary>	
        /// Creates a cube texture from a file in memory. This is a more advanced function than <see cref="SlimDX2.Direct3D9.D3DX9.CreateCubeTextureFromFileInMemory"/>.	
        /// </summary>	
        /// <remarks>	
        ///  This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. Cube textures differ from other surfaces in that they are collections of surfaces. To call {{SetRenderTarget}} with a cube texture, you must select an individual face using {{GetCubeMapSurface}} and pass the resulting surface to SetRenderTarget . This method is designed to be used for loading image files stored as RT_RCDATA, which is an application-defined resource (raw data). Otherwise this method will fail. For details on <see cref="SlimDX2.Windows.Paletteentry"/>, see the Platform SDK.  Note that as of DirectX 8.0, the peFlags member of the PALETTEENTRY structure does not function as documented in the Platform SDK. The peFlags  member is now the alpha channel for 8-bit palettized formats. D3DXCreateCubeTextureFromFileInMemoryEx uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="pSrcData"> Pointer to the file in memory from which to create the cube texture. See Remarks. </param>
        /// <param name="srcDataSize"> Size of the file in memory, in bytes. </param>
        /// <param name="size"> Width (or height) in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If D3DUSAGE_RENDERTARGET is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the cube texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.MtUnknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the cube texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant, and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <param name="pPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. See Remarks. </param>
        /// <param name="ppCubeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileInMemoryEx([None] LPDIRECT3DDEVICE9 pDevice,[None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] UINT Size,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result CreateCubeTextureFromFileInMemoryEx(SlimDX2.Direct3D9.Device pDevice, IntPtr pSrcData, int srcDataSize, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out SlimDX2.Direct3D9.CubeTexture ppCubeTexture) {
            unsafe {
                IntPtr ppCubeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromFileInMemoryEx_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcData,  srcDataSize,  size,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  pSrcInfo, ref  pPalette, out ppCubeTexture_);
                ppCubeTexture = (ppCubeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(ppCubeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileInMemoryEx([None] LPDIRECT3DDEVICE9 pDevice,[None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] UINT Size,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromFileInMemoryEx", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromFileInMemoryEx_(IntPtr pDevice, IntPtr pSrcData, int srcDataSize, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out IntPtr ppCubeTexture);		
        
        /// <summary>	
        /// Creates a volume texture from a file. This is a more advanced function than <see cref="SlimDX2.Direct3D9.D3DX9.CreateVolumeTextureFromFileInMemory"/>.	
        /// </summary>	
        /// <remarks>	
        ///  This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileformat"/>. When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="pSrcData"> Pointer to the file in memory from which to create the volume texture. </param>
        /// <param name="srcDataSize"> Size of the file in memory, in bytes. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="depth"> Depth, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Caps9"/>. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the  pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE_DYNAMIC is specified,  Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.MtUnknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> Combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="int"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="pSrcInfo"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled in with a description of the data in the source image file, or NULL. </param>
        /// <param name="pPalette"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="ppVolumeTexture"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileInMemoryEx([None] LPDIRECT3DDEVICE9 pDevice,[None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] UINT Width,[None] UINT Height,[None] UINT Depth,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result CreateVolumeTextureFromFileInMemoryEx(SlimDX2.Direct3D9.Device pDevice, IntPtr pSrcData, int srcDataSize, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out SlimDX2.Direct3D9.VolumeTexture ppVolumeTexture) {
            unsafe {
                IntPtr ppVolumeTexture_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromFileInMemoryEx_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  pSrcData,  srcDataSize,  width,  height,  depth,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  pSrcInfo, ref  pPalette, out ppVolumeTexture_);
                ppVolumeTexture = (ppVolumeTexture_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(ppVolumeTexture_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileInMemoryEx([None] LPDIRECT3DDEVICE9 pDevice,[None] LPCVOID pSrcData,[None] UINT SrcDataSize,[None] UINT Width,[None] UINT Height,[None] UINT Depth,[None] UINT MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromFileInMemoryEx", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromFileInMemoryEx_(IntPtr pDevice, IntPtr pSrcData, int srcDataSize, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, int colorKey, ref SlimDX2.Direct3D9.ImageInformation pSrcInfo, ref SlimDX2.Windows.Paletteentry pPalette, out IntPtr ppVolumeTexture);		
        
        /// <summary>	
        /// Saves a texture to a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXSaveTextureToFileW. Otherwise, the function call resolves to D3DXSaveTextureToFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats. If the volume is nondynamic (because of a usage parameter set to 0 at the creation) and located in video memory (the memory pool set to D3DPOOL_DEFAULT), D3DXSaveTextureToFile will fail because D3DX cannot lock nondynamic volumes located in video memory. 	
        /// </remarks>	
        /// <param name="pDestFile"> Pointer to a string that specifies the file name of the destination image. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileformat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcTexture"> Pointer to <see cref="SlimDX2.Direct3D9.BaseTexture"/> interface, containing the texture to be saved. </param>
        /// <param name="pSrcPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXSaveTextureToFileA([None] const char* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DBASETEXTURE9 pSrcTexture,[None] const PALETTEENTRY* pSrcPalette)</unmanaged>
		public static SlimDX2.Result SaveTextureToFileA(string pDestFile, SlimDX2.Direct3D9.ImageFileformat destFormat, SlimDX2.Direct3D9.BaseTexture pSrcTexture, ref SlimDX2.Windows.Paletteentry pSrcPalette) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveTextureToFileA_( pDestFile,  destFormat, (pSrcTexture == null)?IntPtr.Zero:pSrcTexture.NativePointer, ref  pSrcPalette);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveTextureToFileA([None] const char* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DBASETEXTURE9 pSrcTexture,[None] const PALETTEENTRY* pSrcPalette)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveTextureToFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveTextureToFileA_([MarshalAs(UnmanagedType.LPStr),In] string pDestFile, SlimDX2.Direct3D9.ImageFileformat destFormat, IntPtr pSrcTexture, ref SlimDX2.Windows.Paletteentry pSrcPalette);		
        
        /// <summary>	
        /// Saves a texture to a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXSaveTextureToFileW. Otherwise, the function call resolves to D3DXSaveTextureToFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats. If the volume is nondynamic (because of a usage parameter set to 0 at the creation) and located in video memory (the memory pool set to D3DPOOL_DEFAULT), D3DXSaveTextureToFile will fail because D3DX cannot lock nondynamic volumes located in video memory. 	
        /// </remarks>	
        /// <param name="pDestFile"> Pointer to a string that specifies the file name of the destination image. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileformat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcTexture"> Pointer to <see cref="SlimDX2.Direct3D9.BaseTexture"/> interface, containing the texture to be saved. </param>
        /// <param name="pSrcPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXSaveTextureToFileW([None] const wchar* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DBASETEXTURE9 pSrcTexture,[None] const PALETTEENTRY* pSrcPalette)</unmanaged>
		public static SlimDX2.Result SaveTextureToFileW(string pDestFile, SlimDX2.Direct3D9.ImageFileformat destFormat, SlimDX2.Direct3D9.BaseTexture pSrcTexture, ref SlimDX2.Windows.Paletteentry pSrcPalette) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveTextureToFileW_( pDestFile,  destFormat, (pSrcTexture == null)?IntPtr.Zero:pSrcTexture.NativePointer, ref  pSrcPalette);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveTextureToFileW([None] const wchar* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DBASETEXTURE9 pSrcTexture,[None] const PALETTEENTRY* pSrcPalette)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveTextureToFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveTextureToFileW_([MarshalAs(UnmanagedType.LPWStr),In] string pDestFile, SlimDX2.Direct3D9.ImageFileformat destFormat, IntPtr pSrcTexture, ref SlimDX2.Windows.Paletteentry pSrcPalette);		
        
        /// <summary>	
        /// Saves a texture to an image file.	
        /// </summary>	
        /// <remarks>	
        ///  This function handles conversion to and from compressed texture formats. 	
        /// </remarks>	
        /// <param name="ppDestBuf"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> that will store the image. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileformat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcTexture"> Pointer to <see cref="SlimDX2.Direct3D9.BaseTexture"/> interface containing the image to be saved. </param>
        /// <param name="pSrcPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXSaveTextureToFileInMemory([None] LPD3DXBUFFER* ppDestBuf,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DBASETEXTURE9 pSrcTexture,[None] const PALETTEENTRY* pSrcPalette)</unmanaged>
		public static SlimDX2.Result SaveTextureToFileInMemory(out SlimDX2.Direct3D9.Buffer ppDestBuf, SlimDX2.Direct3D9.ImageFileformat destFormat, SlimDX2.Direct3D9.BaseTexture pSrcTexture, ref SlimDX2.Windows.Paletteentry pSrcPalette) {
            unsafe {
                IntPtr ppDestBuf_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveTextureToFileInMemory_(out ppDestBuf_,  destFormat, (pSrcTexture == null)?IntPtr.Zero:pSrcTexture.NativePointer, ref  pSrcPalette);
                ppDestBuf = (ppDestBuf_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppDestBuf_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveTextureToFileInMemory([None] LPD3DXBUFFER* ppDestBuf,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DBASETEXTURE9 pSrcTexture,[None] const PALETTEENTRY* pSrcPalette)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveTextureToFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveTextureToFileInMemory_(out IntPtr ppDestBuf, SlimDX2.Direct3D9.ImageFileformat destFormat, IntPtr pSrcTexture, ref SlimDX2.Windows.Paletteentry pSrcPalette);		
        
        /// <summary>	
        /// Filters mipmap levels of a texture.	
        /// </summary>	
        /// <remarks>	
        ///  A filter is recursively applied to each texture level to generate the next texture level. Writing to a non-level-zero surface of the texture will not cause the dirty rectangle to be updated. If D3DXFilterTexture is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call {{AddDirtyRect}} on the texture. Textures created in the default pool (D3DPOOL_DEFAULT) cannot be used with D3DXFilterTexture (unless created with D3DUSAGE_DYNAMIC) because a lock operation is needed on the object. Note that locks are prohibited on textures in the default pool (unless they are dynamic). For details on <see cref="SlimDX2.Windows.Paletteentry"/>, see the Platform SDK. Note that as of DirectX 8.0, the peFlags member of the PALETTEENTRY structure does not function as documented in the Platform SDK. The peFlags member is now the alpha channel for 8-bit palettized formats. There is only one texture filtering function, but two macros that call this method. 	
        /// <code> #define D3DXFilterCubeTexture D3DXFilterTexture	
        /// #define D3DXFilterVolumeTexture D3DXFilterTexture </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="pBaseTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.BaseTexture"/> interface that represents the texture object to filter. </param>
        /// <param name="pPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure that represents a 256-color palette to fill in, or NULL for nonpalettized formats. If a palette is not specified, the default Direct3D palette (an all opaque white palette) is provided. See Remarks. </param>
        /// <param name="srcLevel"> Level whose image is used to generate the subsequent levels. Specifying D3DX_DEFAULT for this parameter is equivalent to specifying 0. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}} controlling how the mipmap is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX if the texture size is a power of two, and D3DX_FILTER_BOX | D3DX_FILTER_DITHER otherwise. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXFilterTexture([None] LPDIRECT3DBASETEXTURE9 pBaseTexture,[None] const PALETTEENTRY* pPalette,[None] UINT SrcLevel,[None] int Filter)</unmanaged>
		public static SlimDX2.Result FilterTexture(SlimDX2.Direct3D9.BaseTexture pBaseTexture, ref SlimDX2.Windows.Paletteentry pPalette, int srcLevel, int filter) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFilterTexture_((pBaseTexture == null)?IntPtr.Zero:pBaseTexture.NativePointer, ref  pPalette,  srcLevel,  filter);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFilterTexture([None] LPDIRECT3DBASETEXTURE9 pBaseTexture,[None] const PALETTEENTRY* pPalette,[None] UINT SrcLevel,[None] int Filter)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFilterTexture", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFilterTexture_(IntPtr pBaseTexture, ref SlimDX2.Windows.Paletteentry pPalette, int srcLevel, int filter);		
        
        /// <summary>	
        /// Uses a user-provided function to fill each texel of each mip level of a given texture.	
        /// </summary>	
        /// <remarks>	
        ///  Here is an example that creates a function called ColorFill, which relies on D3DXFillTexture. 	
        /// <code> // Define a function that matches the prototype of LPD3DXFILL3D	
        /// VOID WINAPI ColorFill (D3DXVECTOR4* pOut, const D3DXVECTOR2* pTexCoord, 	
        /// const D3DXVECTOR2* pTexelSize, LPVOID pData)	
        /// { *pOut = D3DXVECTOR4(pTexCoord-&gt;x, pTexCoord-&gt;y, 0.0f, 0.0f);	
        /// } // Fill the texture using D3DXFillTexture	
        /// if (FAILED (hr = D3DXFillTexture (m_pTexture, ColorFill, NULL)))	
        /// { return hr;	
        /// } </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="pTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the filled texture. </param>
        /// <param name="pFunction"> Pointer to a user-provided evaluator function, which will be used to compute the value of each texel. The function follows the prototype of <see cref="IntPtr"/>. </param>
        /// <param name="pData"> Pointer to an arbitrary block of user-defined data. This pointer will be passed to the function provided in pFunction. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXFillTexture([None] LPDIRECT3DTEXTURE9 pTexture,[None] LPD3DXFILL2D pFunction,[None] void* pData)</unmanaged>
		public static SlimDX2.Result FillTexture(SlimDX2.Direct3D9.Texture pTexture, IntPtr pFunction, IntPtr pData) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFillTexture_((pTexture == null)?IntPtr.Zero:pTexture.NativePointer,  pFunction,  pData);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFillTexture([None] LPDIRECT3DTEXTURE9 pTexture,[None] LPD3DXFILL2D pFunction,[None] void* pData)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillTexture", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFillTexture_(IntPtr pTexture, IntPtr pFunction, IntPtr pData);		
        
        /// <summary>	
        /// Uses a user-provided function to fill each texel of each mip level of a given cube texture.	
        /// </summary>	
        /// <remarks>	
        ///  Here is an example that creates a function called ColorCubeFill, which relies on D3DXFillCubeTexture. 	
        /// <code> // Define a function that matches the prototype of LPD3DXFILL3D	
        /// VOID WINAPI ColorCubeFill (D3DXVECTOR4* pOut, const D3DXVECTOR3* pTexCoord, 	
        /// const D3DXVECTOR3* pTexelSize, LPVOID pData)	
        /// { *pOut = D3DXVECTOR4(pTexCoord-&gt;x, pTexCoord-&gt;y, pTexCoord-&gt;z, 0.0f);	
        /// } // Fill the texture using D3DXFillCubeTexture	
        /// if (FAILED (hr = D3DXFillCubeTexture (m_pTexture, ColorCubeFill, NULL)))	
        /// { return hr;	
        /// } </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="pCubeTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the filled texture. </param>
        /// <param name="pFunction"> Pointer to a user-provided evaluator function, which will be used to compute the value of each texel. The function follows the prototype of <see cref="IntPtr"/>. </param>
        /// <param name="pData"> Pointer to an arbitrary block of user-defined data. This pointer will be passed to the function provided in pFunction. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXFillCubeTexture([None] LPDIRECT3DCUBETEXTURE9 pCubeTexture,[None] LPD3DXFILL3D pFunction,[None] void* pData)</unmanaged>
		public static SlimDX2.Result FillCubeTexture(SlimDX2.Direct3D9.CubeTexture pCubeTexture, IntPtr pFunction, IntPtr pData) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFillCubeTexture_((pCubeTexture == null)?IntPtr.Zero:pCubeTexture.NativePointer,  pFunction,  pData);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFillCubeTexture([None] LPDIRECT3DCUBETEXTURE9 pCubeTexture,[None] LPD3DXFILL3D pFunction,[None] void* pData)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillCubeTexture", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFillCubeTexture_(IntPtr pCubeTexture, IntPtr pFunction, IntPtr pData);		
        
        /// <summary>	
        /// Uses a user-provided function to fill each texel of each mip level of a given volume texture.	
        /// </summary>	
        /// <remarks>	
        ///  If the volume is non-dynamic (because usage is set to 0 when it is  created), and located in video memory (the memory pool set to D3DPOOL_DEFAULT), D3DXFillVolumeTexture will fail because the volume cannot be locked. This example creates a function called ColorVolumeFill, which relies on D3DXFillVolumeTexture. 	
        /// <code> // Define a function that matches the prototype of LPD3DXFILL3D	
        /// VOID WINAPI ColorVolumeFill (D3DXVECTOR4* pOut, const D3DXVECTOR3* pTexCoord, 	
        /// const D3DXVECTOR3* pTexelSize, LPVOID pData)	
        /// { *pOut = D3DXVECTOR4(pTexCoord-&gt;x, pTexCoord-&gt;y, pTexCoord-&gt;z, 0.0f);	
        /// } // Fill volume texture	
        /// if (FAILED (hr = D3DXFillVolumeTexture (m_pTexture, ColorVolumeFill, NULL)))	
        /// { return hr;	
        /// } </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="pVolumeTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the filled texture. </param>
        /// <param name="pFunction"> Pointer to a user-provided evaluator function, which will be used to compute the value of each texel. The function follows the prototype of <see cref="IntPtr"/>. </param>
        /// <param name="pData"> Pointer to an arbitrary block of user-defined data. This pointer will be passed to the function provided in pFunction. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXFillVolumeTexture([None] LPDIRECT3DVOLUMETEXTURE9 pVolumeTexture,[None] LPD3DXFILL3D pFunction,[None] void* pData)</unmanaged>
		public static SlimDX2.Result FillVolumeTexture(SlimDX2.Direct3D9.VolumeTexture pVolumeTexture, IntPtr pFunction, IntPtr pData) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFillVolumeTexture_((pVolumeTexture == null)?IntPtr.Zero:pVolumeTexture.NativePointer,  pFunction,  pData);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFillVolumeTexture([None] LPDIRECT3DVOLUMETEXTURE9 pVolumeTexture,[None] LPD3DXFILL3D pFunction,[None] void* pData)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillVolumeTexture", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFillVolumeTexture_(IntPtr pVolumeTexture, IntPtr pFunction, IntPtr pData);		
        
        /// <summary>	
        /// Uses a compiled high-level shader language (HLSL) function to fill each texel of each mipmap level of a texture.	
        /// </summary>	
        /// <remarks>	
        ///  The texture target must be an HLSL function that takes contains the following semantics:  One input parameter must use a POSITION semantic. One input parameter must use a PSIZE semantic. The function must return a parameter that uses the COLOR semantic.  The following is an example of such an HLSL function: 	
        /// <code> float4 TextureGradientFill( float2 vTexCoord : POSITION,  float2 vTexelSize : PSIZE) : COLOR  { float r,g, b, xSq,ySq, a; xSq = 2.f*vTexCoord.x-1.f; xSq *= xSq; ySq = 2.f*vTexCoord.y-1.f; ySq *= ySq; a = sqrt(xSq+ySq); if (a &gt; 1.0f) { a = 1.0f-(a-1.0f); } else if (a &lt; 0.2f) { a = 0.2f; } r = 1-vTexCoord.x; g = 1-vTexCoord.y; b = vTexCoord.x; return float4(r, g, b, a); }; </code>	
        /// 	
        ///  Note that the input parameters can be in any order, but both input semantics must be represented. 	
        /// </remarks>	
        /// <param name="pTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> object, representing the texture to be filled. </param>
        /// <param name="pTextureShader"> Pointer to a <see cref="SlimDX2.Direct3D9.TextureShader"/> texture shader object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXFillTextureTX([None] LPDIRECT3DTEXTURE9 pTexture,[None] LPD3DXTEXTURESHADER pTextureShader)</unmanaged>
		public static SlimDX2.Result FillTextureTX(SlimDX2.Direct3D9.Texture pTexture, SlimDX2.Direct3D9.TextureShader pTextureShader) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFillTextureTX_((pTexture == null)?IntPtr.Zero:pTexture.NativePointer, (pTextureShader == null)?IntPtr.Zero:pTextureShader.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFillTextureTX([None] LPDIRECT3DTEXTURE9 pTexture,[None] LPD3DXTEXTURESHADER pTextureShader)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillTextureTX", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFillTextureTX_(IntPtr pTexture, IntPtr pTextureShader);		
        
        /// <summary>	
        /// Uses a compiled high-level shader language (HLSL) function to fill each texel of each mipmap level of a texture.	
        /// </summary>	
        /// <remarks>	
        ///  The texture target must be an HLSL function that takes contains the following semantics:  One input parameter must use a POSITION semantic. One input parameter must use a PSIZE semantic. The function must return a parameter that uses the COLOR semantic.  The input parameters can be in any order. For an example, see <see cref="SlimDX2.Direct3D9.D3DX9.FillTextureTX"/>  	
        /// </remarks>	
        /// <param name="pCubeTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> object, representing the texture to be filled. </param>
        /// <param name="pTextureShader"> Pointer to a <see cref="SlimDX2.Direct3D9.TextureShader"/> texture shader object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXFillCubeTextureTX([None] LPDIRECT3DCUBETEXTURE9 pCubeTexture,[None] LPD3DXTEXTURESHADER pTextureShader)</unmanaged>
		public static SlimDX2.Result FillCubeTextureTX(SlimDX2.Direct3D9.CubeTexture pCubeTexture, SlimDX2.Direct3D9.TextureShader pTextureShader) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFillCubeTextureTX_((pCubeTexture == null)?IntPtr.Zero:pCubeTexture.NativePointer, (pTextureShader == null)?IntPtr.Zero:pTextureShader.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFillCubeTextureTX([None] LPDIRECT3DCUBETEXTURE9 pCubeTexture,[None] LPD3DXTEXTURESHADER pTextureShader)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillCubeTextureTX", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFillCubeTextureTX_(IntPtr pCubeTexture, IntPtr pTextureShader);		
        
        /// <summary>	
        /// Uses a compiled high-level shader language (HLSL) function to fill each texel of each mipmap level of a texture.	
        /// </summary>	
        /// <remarks>	
        ///  The texture target must be an HLSL function that takes contains the following semantics:  One input parameter must use a POSITION semantic. One input parameter must use a PSIZE semantic. The function must return a parameter that uses the COLOR semantic.  The input parameters can be in any order. For an example, see <see cref="SlimDX2.Direct3D9.D3DX9.FillTextureTX"/>  	
        /// </remarks>	
        /// <param name="pVolumeTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> object, representing the texture to be filled. </param>
        /// <param name="pTextureShader"> Pointer to a <see cref="SlimDX2.Direct3D9.TextureShader"/> texture shader object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following:D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXFillVolumeTextureTX([None] LPDIRECT3DVOLUMETEXTURE9 pVolumeTexture,[None] LPD3DXTEXTURESHADER pTextureShader)</unmanaged>
		public static SlimDX2.Result FillVolumeTextureTX(SlimDX2.Direct3D9.VolumeTexture pVolumeTexture, SlimDX2.Direct3D9.TextureShader pTextureShader) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFillVolumeTextureTX_((pVolumeTexture == null)?IntPtr.Zero:pVolumeTexture.NativePointer, (pTextureShader == null)?IntPtr.Zero:pTextureShader.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFillVolumeTextureTX([None] LPDIRECT3DVOLUMETEXTURE9 pVolumeTexture,[None] LPD3DXTEXTURESHADER pTextureShader)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillVolumeTextureTX", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFillVolumeTextureTX_(IntPtr pVolumeTexture, IntPtr pTextureShader);		
        
        /// <summary>	
        /// Converts a height map into a normal map. The (x,y,z) components of each normal are mapped to the (r,g,b) channels of the output texture.	
        /// </summary>	
        /// <remarks>	
        ///  This method computes the normal by using the central difference with a kernel size of 3x3. The central differencing denominator used is 2.0. RGB channels in the destination contain biased (x,y,z) components of the normal. 	
        /// </remarks>	
        /// <param name="pTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the destination texture. </param>
        /// <param name="pSrcTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the source height-map texture. </param>
        /// <param name="pSrcPalette"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> type that contains the source palette of 256 colors or NULL. </param>
        /// <param name="flags"> One or more {{D3DX_NORMALMAP}} flags that control generation of normal maps. </param>
        /// <param name="channel"> One {{D3DX_CHANNEL}} flag specifying the source of height information. </param>
        /// <param name="amplitude"> Constant value multiplier that increases (or decreases) the values in the normal map. Higher values usually make bumps more visible, lower values usually make bumps less visible. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following value: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXComputeNormalMap([None] LPDIRECT3DTEXTURE9 pTexture,[None] LPDIRECT3DTEXTURE9 pSrcTexture,[None] const PALETTEENTRY* pSrcPalette,[None] int Flags,[None] int Channel,[None] FLOAT Amplitude)</unmanaged>
		public static SlimDX2.Result ComputeNormalMap(SlimDX2.Direct3D9.Texture pTexture, SlimDX2.Direct3D9.Texture pSrcTexture, ref SlimDX2.Windows.Paletteentry pSrcPalette, int flags, int channel, float amplitude) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeNormalMap_((pTexture == null)?IntPtr.Zero:pTexture.NativePointer, (pSrcTexture == null)?IntPtr.Zero:pSrcTexture.NativePointer, ref  pSrcPalette,  flags,  channel,  amplitude);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeNormalMap([None] LPDIRECT3DTEXTURE9 pTexture,[None] LPDIRECT3DTEXTURE9 pSrcTexture,[None] const PALETTEENTRY* pSrcPalette,[None] int Flags,[None] int Channel,[None] FLOAT Amplitude)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeNormalMap", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeNormalMap_(IntPtr pTexture, IntPtr pSrcTexture, ref SlimDX2.Windows.Paletteentry pSrcPalette, int flags, int channel, float amplitude);		
        
        /// <summary>	
        /// Uses a left-handed coordinate system to create a mesh containing an 	
        /// n-sided polygon.	
        /// </summary>	
        /// <remarks>	
        ///  The created polygon is centered at the origin. This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} flexible vertex format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the created polygon mesh. </param>
        /// <param name="length"> Length of each side. </param>
        /// <param name="sides"> Number of sides for the polygon. Value must be greater than or equal to 3. </param>
        /// <param name="ppMesh"> Address of a pointer to the output shape, an <see cref="SlimDX2.Direct3D9.Mesh"/> interface. </param>
        /// <param name="ppAdjacency"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface. When the method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreatePolygon([None] LPDIRECT3DDEVICE9 pDevice,[None] FLOAT Length,[None] UINT Sides,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		public static SlimDX2.Result CreatePolygon(SlimDX2.Direct3D9.Device pDevice, float length, int sides, out SlimDX2.Direct3D9.Mesh ppMesh, out SlimDX2.Direct3D9.Buffer ppAdjacency) {
            unsafe {
                IntPtr ppMesh_ = IntPtr.Zero;
                IntPtr ppAdjacency_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreatePolygon_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  length,  sides, out ppMesh_, out ppAdjacency_);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);
                ppAdjacency = (ppAdjacency_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAdjacency_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreatePolygon([None] LPDIRECT3DDEVICE9 pDevice,[None] FLOAT Length,[None] UINT Sides,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreatePolygon", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreatePolygon_(IntPtr pDevice, float length, int sides, out IntPtr ppMesh, out IntPtr ppAdjacency);		
        
        /// <summary>	
        /// Uses a left-handed coordinate system to create a mesh containing an axis-aligned box.	
        /// </summary>	
        /// <remarks>	
        ///  The created box is centered at the origin. This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} flexible vertex format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the created box mesh. </param>
        /// <param name="width"> Width of the box, along the x-axis. </param>
        /// <param name="height"> Height of the box, along the y-axis. </param>
        /// <param name="depth"> Depth of the box, along the z-axis. </param>
        /// <param name="ppMesh"> Address of a pointer to the output shape, an <see cref="SlimDX2.Direct3D9.Mesh"/> interface. </param>
        /// <param name="ppAdjacency"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateBox([None] LPDIRECT3DDEVICE9 pDevice,[None] FLOAT Width,[None] FLOAT Height,[None] FLOAT Depth,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		public static SlimDX2.Result CreateBox(SlimDX2.Direct3D9.Device pDevice, float width, float height, float depth, out SlimDX2.Direct3D9.Mesh ppMesh, out SlimDX2.Direct3D9.Buffer ppAdjacency) {
            unsafe {
                IntPtr ppMesh_ = IntPtr.Zero;
                IntPtr ppAdjacency_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateBox_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  width,  height,  depth, out ppMesh_, out ppAdjacency_);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);
                ppAdjacency = (ppAdjacency_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAdjacency_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateBox([None] LPDIRECT3DDEVICE9 pDevice,[None] FLOAT Width,[None] FLOAT Height,[None] FLOAT Depth,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateBox", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateBox_(IntPtr pDevice, float width, float height, float depth, out IntPtr ppMesh, out IntPtr ppAdjacency);		
        
        /// <summary>	
        /// Uses a left-handed coordinate system to create a mesh containing a cylinder.	
        /// </summary>	
        /// <remarks>	
        ///  The created cylinder is centered at the origin, and its axis is aligned with the z-axis. This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} flexible vertex format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the created cylinder mesh. </param>
        /// <param name="radius1"> Radius at the negative Z end. Value should be greater than or equal to 0.0f. </param>
        /// <param name="radius2"> Radius at the positive Z end. Value should be greater than or equal to 0.0f. </param>
        /// <param name="length"> Length of the cylinder along the z-axis. </param>
        /// <param name="slices"> Number of slices about the main axis. </param>
        /// <param name="stacks"> Number of stacks along the main axis. </param>
        /// <param name="ppMesh"> Address of a pointer to the output shape, an <see cref="SlimDX2.Direct3D9.Mesh"/> interface. </param>
        /// <param name="ppAdjacency"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface. When the method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCylinder([None] LPDIRECT3DDEVICE9 pDevice,[None] FLOAT Radius1,[None] FLOAT Radius2,[None] FLOAT Length,[None] UINT Slices,[None] UINT Stacks,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		public static SlimDX2.Result CreateCylinder(SlimDX2.Direct3D9.Device pDevice, float radius1, float radius2, float length, int slices, int stacks, out SlimDX2.Direct3D9.Mesh ppMesh, out SlimDX2.Direct3D9.Buffer ppAdjacency) {
            unsafe {
                IntPtr ppMesh_ = IntPtr.Zero;
                IntPtr ppAdjacency_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCylinder_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  radius1,  radius2,  length,  slices,  stacks, out ppMesh_, out ppAdjacency_);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);
                ppAdjacency = (ppAdjacency_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAdjacency_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCylinder([None] LPDIRECT3DDEVICE9 pDevice,[None] FLOAT Radius1,[None] FLOAT Radius2,[None] FLOAT Length,[None] UINT Slices,[None] UINT Stacks,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCylinder", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCylinder_(IntPtr pDevice, float radius1, float radius2, float length, int slices, int stacks, out IntPtr ppMesh, out IntPtr ppAdjacency);		
        
        /// <summary>	
        /// Uses a left-handed coordinate system to create a mesh containing a sphere.	
        /// </summary>	
        /// <remarks>	
        ///  The created sphere is centered at the origin, and its axis is aligned with the z-axis. This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} flexible vertex format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the created sphere mesh. </param>
        /// <param name="radius"> Radius of the sphere. This value should be greater than or equal to 0.0f. </param>
        /// <param name="slices"> Number of slices about the main axis. </param>
        /// <param name="stacks"> Number of stacks along the main axis. </param>
        /// <param name="ppMesh"> Address of a pointer to the output shape, an <see cref="SlimDX2.Direct3D9.Mesh"/> interface. </param>
        /// <param name="ppAdjacency"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface. When the method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateSphere([None] LPDIRECT3DDEVICE9 pDevice,[None] FLOAT Radius,[None] UINT Slices,[None] UINT Stacks,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		public static SlimDX2.Result CreateSphere(SlimDX2.Direct3D9.Device pDevice, float radius, int slices, int stacks, out SlimDX2.Direct3D9.Mesh ppMesh, out SlimDX2.Direct3D9.Buffer ppAdjacency) {
            unsafe {
                IntPtr ppMesh_ = IntPtr.Zero;
                IntPtr ppAdjacency_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateSphere_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  radius,  slices,  stacks, out ppMesh_, out ppAdjacency_);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);
                ppAdjacency = (ppAdjacency_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAdjacency_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateSphere([None] LPDIRECT3DDEVICE9 pDevice,[None] FLOAT Radius,[None] UINT Slices,[None] UINT Stacks,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSphere", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateSphere_(IntPtr pDevice, float radius, int slices, int stacks, out IntPtr ppMesh, out IntPtr ppAdjacency);		
        
        /// <summary>	
        /// Uses a left-handed coordinate system to create a mesh containing a torus.	
        /// </summary>	
        /// <remarks>	
        ///  The created torus is centered at the origin, and its axis is aligned with the z-axis. The inner radius of the torus is the radius of the cross-section (the minor radius), and the outer radius of the torus is the radius of the central hole.  This function returns a mesh that can be used later for drawing or manipulation by the application. This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} flexible vertex format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the created torus mesh. </param>
        /// <param name="innerRadius"> Inner-radius of the torus. Value should be greater than or equal to 0.0f. </param>
        /// <param name="outerRadius"> Outer-radius of the torus. Value should be greater than or equal to 0.0f. </param>
        /// <param name="sides"> Number of sides in a cross-section. Value must be greater than or equal to 3. </param>
        /// <param name="rings"> Number of rings making up the torus. Value must be greater than or equal to 3. </param>
        /// <param name="ppMesh"> Address of a pointer to the output shape, an <see cref="SlimDX2.Direct3D9.Mesh"/> interface. </param>
        /// <param name="ppAdjacency"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface. When the method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTorus([None] LPDIRECT3DDEVICE9 pDevice,[None] FLOAT InnerRadius,[None] FLOAT OuterRadius,[None] UINT Sides,[None] UINT Rings,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		public static SlimDX2.Result CreateTorus(SlimDX2.Direct3D9.Device pDevice, float innerRadius, float outerRadius, int sides, int rings, out SlimDX2.Direct3D9.Mesh ppMesh, out SlimDX2.Direct3D9.Buffer ppAdjacency) {
            unsafe {
                IntPtr ppMesh_ = IntPtr.Zero;
                IntPtr ppAdjacency_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTorus_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  innerRadius,  outerRadius,  sides,  rings, out ppMesh_, out ppAdjacency_);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);
                ppAdjacency = (ppAdjacency_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAdjacency_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTorus([None] LPDIRECT3DDEVICE9 pDevice,[None] FLOAT InnerRadius,[None] FLOAT OuterRadius,[None] UINT Sides,[None] UINT Rings,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTorus", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTorus_(IntPtr pDevice, float innerRadius, float outerRadius, int sides, int rings, out IntPtr ppMesh, out IntPtr ppAdjacency);		
        
        /// <summary>	
        /// Uses a left-handed coordinate system to create a mesh containing a teapot.	
        /// </summary>	
        /// <remarks>	
        ///  This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} flexible vertex format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the created teapot mesh. </param>
        /// <param name="ppMesh"> Address of a pointer to the output shape, an <see cref="SlimDX2.Direct3D9.Mesh"/> interface. </param>
        /// <param name="ppAdjacency"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Buffer"/> interface. When the method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTeapot([None] LPDIRECT3DDEVICE9 pDevice,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		public static SlimDX2.Result CreateTeapot(SlimDX2.Direct3D9.Device pDevice, out SlimDX2.Direct3D9.Mesh ppMesh, out SlimDX2.Direct3D9.Buffer ppAdjacency) {
            unsafe {
                IntPtr ppMesh_ = IntPtr.Zero;
                IntPtr ppAdjacency_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTeapot_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer, out ppMesh_, out ppAdjacency_);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);
                ppAdjacency = (ppAdjacency_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAdjacency_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTeapot([None] LPDIRECT3DDEVICE9 pDevice,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTeapot", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTeapot_(IntPtr pDevice, out IntPtr ppMesh, out IntPtr ppAdjacency);		
        
        /// <summary>	
        /// Creates a mesh containing the specified text, using the font associated with the device context.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextW. Otherwise, the function call resolves to D3DXCreateTextA because ANSI strings are being used. This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} flexible vertex format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device that created the mesh. </param>
        /// <param name="hDC"> Device context, containing the font for output. The font selected by the device context must be a TrueType font. </param>
        /// <param name="pText"> Pointer to a string that specifies the text to generate. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="deviation"> Maximum chordal deviation from TrueType font outlines. </param>
        /// <param name="extrusion"> Amount to extrude text in the negative z-direction. </param>
        /// <param name="ppMesh"> Pointer to the returned mesh. </param>
        /// <param name="ppAdjacency"> Pointer to a buffer containing adjacency information. May be NULL. </param>
        /// <param name="pGlyphMetrics"> Pointer to an array of {{GLYPHMETRICSFLOAT}} structures that contain the glyph metric data. Each element contains information about the position and orientation of the corresponding glyph in the string. The number of elements in the array should be equal to the number of characters in the string. Note that the origin in each structure is not relative to the entire string, but rather is relative to that character cell. To compute the entire bounding box, add the increment for each glyph while traversing the string. If you are not concerned with the glyph sizes, set this parameter to NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextA([None] LPDIRECT3DDEVICE9 pDevice,[None] HDC hDC,[None] const char* pText,[None] FLOAT Deviation,[None] FLOAT Extrusion,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency,[None] LPGLYPHMETRICSFLOAT pGlyphMetrics)</unmanaged>
		public static SlimDX2.Result CreateTextA(SlimDX2.Direct3D9.Device pDevice, IntPtr hDC, string pText, float deviation, float extrusion, out SlimDX2.Direct3D9.Mesh ppMesh, out SlimDX2.Direct3D9.Buffer ppAdjacency, IntPtr pGlyphMetrics) {
            unsafe {
                IntPtr ppMesh_ = IntPtr.Zero;
                IntPtr ppAdjacency_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hDC,  pText,  deviation,  extrusion, out ppMesh_, out ppAdjacency_,  pGlyphMetrics);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);
                ppAdjacency = (ppAdjacency_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAdjacency_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextA([None] LPDIRECT3DDEVICE9 pDevice,[None] HDC hDC,[None] const char* pText,[None] FLOAT Deviation,[None] FLOAT Extrusion,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency,[None] LPGLYPHMETRICSFLOAT pGlyphMetrics)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextA_(IntPtr pDevice, IntPtr hDC, [MarshalAs(UnmanagedType.LPStr),In] string pText, float deviation, float extrusion, out IntPtr ppMesh, out IntPtr ppAdjacency, IntPtr pGlyphMetrics);		
        
        /// <summary>	
        /// Creates a mesh containing the specified text, using the font associated with the device context.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextW. Otherwise, the function call resolves to D3DXCreateTextA because ANSI strings are being used. This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} flexible vertex format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device that created the mesh. </param>
        /// <param name="hDC"> Device context, containing the font for output. The font selected by the device context must be a TrueType font. </param>
        /// <param name="pText"> Pointer to a string that specifies the text to generate. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="deviation"> Maximum chordal deviation from TrueType font outlines. </param>
        /// <param name="extrusion"> Amount to extrude text in the negative z-direction. </param>
        /// <param name="ppMesh"> Pointer to the returned mesh. </param>
        /// <param name="ppAdjacency"> Pointer to a buffer containing adjacency information. May be NULL. </param>
        /// <param name="pGlyphMetrics"> Pointer to an array of {{GLYPHMETRICSFLOAT}} structures that contain the glyph metric data. Each element contains information about the position and orientation of the corresponding glyph in the string. The number of elements in the array should be equal to the number of characters in the string. Note that the origin in each structure is not relative to the entire string, but rather is relative to that character cell. To compute the entire bounding box, add the increment for each glyph while traversing the string. If you are not concerned with the glyph sizes, set this parameter to NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextW([None] LPDIRECT3DDEVICE9 pDevice,[None] HDC hDC,[None] const wchar* pText,[None] FLOAT Deviation,[None] FLOAT Extrusion,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency,[None] LPGLYPHMETRICSFLOAT pGlyphMetrics)</unmanaged>
		public static SlimDX2.Result CreateTextW(SlimDX2.Direct3D9.Device pDevice, IntPtr hDC, string pText, float deviation, float extrusion, out SlimDX2.Direct3D9.Mesh ppMesh, out SlimDX2.Direct3D9.Buffer ppAdjacency, IntPtr pGlyphMetrics) {
            unsafe {
                IntPtr ppMesh_ = IntPtr.Zero;
                IntPtr ppAdjacency_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hDC,  pText,  deviation,  extrusion, out ppMesh_, out ppAdjacency_,  pGlyphMetrics);
                ppMesh = (ppMesh_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Mesh(ppMesh_);
                ppAdjacency = (ppAdjacency_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Buffer(ppAdjacency_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextW([None] LPDIRECT3DDEVICE9 pDevice,[None] HDC hDC,[None] const wchar* pText,[None] FLOAT Deviation,[None] FLOAT Extrusion,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency,[None] LPGLYPHMETRICSFLOAT pGlyphMetrics)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextW_(IntPtr pDevice, IntPtr hDC, [MarshalAs(UnmanagedType.LPWStr),In] string pText, float deviation, float extrusion, out IntPtr ppMesh, out IntPtr ppAdjacency, IntPtr pGlyphMetrics);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="filename">No documentation.</param>
        /// <param name="meshOptions">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="pAlloc">No documentation.</param>
        /// <param name="pUserDataLoader">No documentation.</param>
        /// <param name="ppFrameHierarchy">No documentation.</param>
        /// <param name="ppAnimController">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXLoadMeshHierarchyFromXA([None] const char* Filename,[None] int MeshOptions,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXALLOCATEHIERARCHY pAlloc,[None] LPD3DXLOADUSERDATA pUserDataLoader,[None] LPD3DXFRAME* ppFrameHierarchy,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
		public static SlimDX2.Result LoadMeshHierarchyFromXA(string filename, int meshOptions, SlimDX2.Direct3D9.Device pD3DDevice, SlimDX2.Direct3D9.AllocateHierarchy pAlloc, SlimDX2.Direct3D9.LoadUserData pUserDataLoader, ref SlimDX2.Direct3D9.Frame ppFrameHierarchy, out SlimDX2.Direct3D9.AnimationController ppAnimController) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native ppFrameHierarchy_ = new SlimDX2.Direct3D9.Frame.__Native();
                ppFrameHierarchy.__MarshalTo(ref ppFrameHierarchy_);
                IntPtr ppAnimController_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadMeshHierarchyFromXA_( filename,  meshOptions, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, (pAlloc == null)?IntPtr.Zero:pAlloc.NativePointer, (pUserDataLoader == null)?IntPtr.Zero:pUserDataLoader.NativePointer, ref  ppFrameHierarchy_, out ppAnimController_);
                ppAnimController = (ppAnimController_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.AnimationController(ppAnimController_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadMeshHierarchyFromXA([None] const char* Filename,[None] int MeshOptions,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXALLOCATEHIERARCHY pAlloc,[None] LPD3DXLOADUSERDATA pUserDataLoader,[None] LPD3DXFRAME* ppFrameHierarchy,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshHierarchyFromXA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadMeshHierarchyFromXA_([MarshalAs(UnmanagedType.LPStr),In] string filename, int meshOptions, IntPtr pD3DDevice, IntPtr pAlloc, IntPtr pUserDataLoader, ref SlimDX2.Direct3D9.Frame.__Native ppFrameHierarchy, out IntPtr ppAnimController);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="filename">No documentation.</param>
        /// <param name="meshOptions">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="pAlloc">No documentation.</param>
        /// <param name="pUserDataLoader">No documentation.</param>
        /// <param name="ppFrameHierarchy">No documentation.</param>
        /// <param name="ppAnimController">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXLoadMeshHierarchyFromXW([None] const wchar* Filename,[None] int MeshOptions,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXALLOCATEHIERARCHY pAlloc,[None] LPD3DXLOADUSERDATA pUserDataLoader,[None] LPD3DXFRAME* ppFrameHierarchy,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
		public static SlimDX2.Result LoadMeshHierarchyFromXW(string filename, int meshOptions, SlimDX2.Direct3D9.Device pD3DDevice, SlimDX2.Direct3D9.AllocateHierarchy pAlloc, SlimDX2.Direct3D9.LoadUserData pUserDataLoader, ref SlimDX2.Direct3D9.Frame ppFrameHierarchy, out SlimDX2.Direct3D9.AnimationController ppAnimController) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native ppFrameHierarchy_ = new SlimDX2.Direct3D9.Frame.__Native();
                ppFrameHierarchy.__MarshalTo(ref ppFrameHierarchy_);
                IntPtr ppAnimController_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadMeshHierarchyFromXW_( filename,  meshOptions, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, (pAlloc == null)?IntPtr.Zero:pAlloc.NativePointer, (pUserDataLoader == null)?IntPtr.Zero:pUserDataLoader.NativePointer, ref  ppFrameHierarchy_, out ppAnimController_);
                ppAnimController = (ppAnimController_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.AnimationController(ppAnimController_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadMeshHierarchyFromXW([None] const wchar* Filename,[None] int MeshOptions,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXALLOCATEHIERARCHY pAlloc,[None] LPD3DXLOADUSERDATA pUserDataLoader,[None] LPD3DXFRAME* ppFrameHierarchy,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshHierarchyFromXW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadMeshHierarchyFromXW_([MarshalAs(UnmanagedType.LPWStr),In] string filename, int meshOptions, IntPtr pD3DDevice, IntPtr pAlloc, IntPtr pUserDataLoader, ref SlimDX2.Direct3D9.Frame.__Native ppFrameHierarchy, out IntPtr ppAnimController);		
        
        /// <summary>	
        /// Loads the first frame hierarchy from a .x file.	
        /// </summary>	
        /// <remarks>	
        ///  All the meshes in the file will be collapsed into one output mesh. If the file contains a frame hierarchy, all the transformations will be applied to the mesh. 	
        /// </remarks>	
        /// <param name="memory"> Pointer to a buffer that contains the mesh hierarchy. </param>
        /// <param name="sizeOfMemory"> Size of the pMemory buffer, in bytes. </param>
        /// <param name="meshOptions"> Combination of one or more flags from the {{D3DXMESH}} enumeration that specify creation options for the mesh. </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device object associated with the mesh. </param>
        /// <param name="pAlloc"> Pointer to an <see cref="SlimDX2.Direct3D9.AllocateHierarchy"/> interface. </param>
        /// <param name="pUserDataLoader"> Application provided interface that allows loading of user data. See <see cref="SlimDX2.Direct3D9.LoadUserData"/>. </param>
        /// <param name="ppFrameHierarchy"> Returns a pointer to the loaded frame hierarchy. See <see cref="SlimDX2.Direct3D9.Frame"/>. </param>
        /// <param name="ppAnimController"> Returns a pointer to the animation controller corresponding to animation in the .x file. This is created with default tracks and events. See <see cref="SlimDX2.Direct3D9.AnimationController"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXLoadMeshHierarchyFromXInMemory([None] LPCVOID Memory,[None] int SizeOfMemory,[None] int MeshOptions,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXALLOCATEHIERARCHY pAlloc,[None] LPD3DXLOADUSERDATA pUserDataLoader,[None] LPD3DXFRAME* ppFrameHierarchy,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
		public static SlimDX2.Result LoadMeshHierarchyFromXInMemory(IntPtr memory, int sizeOfMemory, int meshOptions, SlimDX2.Direct3D9.Device pD3DDevice, SlimDX2.Direct3D9.AllocateHierarchy pAlloc, SlimDX2.Direct3D9.LoadUserData pUserDataLoader, ref SlimDX2.Direct3D9.Frame ppFrameHierarchy, out SlimDX2.Direct3D9.AnimationController ppAnimController) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native ppFrameHierarchy_ = new SlimDX2.Direct3D9.Frame.__Native();
                ppFrameHierarchy.__MarshalTo(ref ppFrameHierarchy_);
                IntPtr ppAnimController_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadMeshHierarchyFromXInMemory_( memory,  sizeOfMemory,  meshOptions, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, (pAlloc == null)?IntPtr.Zero:pAlloc.NativePointer, (pUserDataLoader == null)?IntPtr.Zero:pUserDataLoader.NativePointer, ref  ppFrameHierarchy_, out ppAnimController_);
                ppAnimController = (ppAnimController_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.AnimationController(ppAnimController_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadMeshHierarchyFromXInMemory([None] LPCVOID Memory,[None] int SizeOfMemory,[None] int MeshOptions,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXALLOCATEHIERARCHY pAlloc,[None] LPD3DXLOADUSERDATA pUserDataLoader,[None] LPD3DXFRAME* ppFrameHierarchy,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshHierarchyFromXInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadMeshHierarchyFromXInMemory_(IntPtr memory, int sizeOfMemory, int meshOptions, IntPtr pD3DDevice, IntPtr pAlloc, IntPtr pUserDataLoader, ref SlimDX2.Direct3D9.Frame.__Native ppFrameHierarchy, out IntPtr ppAnimController);		
        
        /// <summary>	
        /// Creates a .x file and saves the mesh hierarchy and corresponding animations in it.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXSaveMeshHierarchyToFileW. Otherwise, the function call resolves to D3DXSaveMeshHierarchyToFileA. This function does not save compressed animation sets. 	
        /// </remarks>	
        /// <param name="filename"> Pointer to a string that specifies the name of the .x file identifying the saved mesh. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="xFormat"> Format of the .x file (text or binary, compressed or not). See D3DXF_FILEFORMAT. D3DXF_FILEFORMAT_COMPRESSED can be combined (using a logical OR) with either the D3DXF_FILEFORMAT_BINARY or D3DXF_FILEFORMAT_TEXT flags to reduce the output file size. </param>
        /// <param name="pFrameRoot"> Root node of the hierarchy to be saved. See <see cref="SlimDX2.Direct3D9.Frame"/>. </param>
        /// <param name="pAnimcontroller"> Animation controller that has animation sets to be stored. See <see cref="SlimDX2.Direct3D9.AnimationController"/>. </param>
        /// <param name="pUserDataSaver"> Application-provided interface that allows saving of user data. See <see cref="SlimDX2.Direct3D9.SaveUserData"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXSaveMeshHierarchyToFileA([None] const char* Filename,[None] int XFormat,[None] const D3DXFRAME* pFrameRoot,[None] LPD3DXANIMATIONCONTROLLER pAnimcontroller,[None] LPD3DXSAVEUSERDATA pUserDataSaver)</unmanaged>
		public static SlimDX2.Result SaveMeshHierarchyToFileA(string filename, int xFormat, ref SlimDX2.Direct3D9.Frame pFrameRoot, SlimDX2.Direct3D9.AnimationController pAnimcontroller, SlimDX2.Direct3D9.SaveUserData pUserDataSaver) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pFrameRoot_ = new SlimDX2.Direct3D9.Frame.__Native();
                pFrameRoot.__MarshalTo(ref pFrameRoot_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveMeshHierarchyToFileA_( filename,  xFormat, ref  pFrameRoot_, (pAnimcontroller == null)?IntPtr.Zero:pAnimcontroller.NativePointer, (pUserDataSaver == null)?IntPtr.Zero:pUserDataSaver.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveMeshHierarchyToFileA([None] const char* Filename,[None] int XFormat,[None] const D3DXFRAME* pFrameRoot,[None] LPD3DXANIMATIONCONTROLLER pAnimcontroller,[None] LPD3DXSAVEUSERDATA pUserDataSaver)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveMeshHierarchyToFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveMeshHierarchyToFileA_([MarshalAs(UnmanagedType.LPStr),In] string filename, int xFormat, ref SlimDX2.Direct3D9.Frame.__Native pFrameRoot, IntPtr pAnimcontroller, IntPtr pUserDataSaver);		
        
        /// <summary>	
        /// Creates a .x file and saves the mesh hierarchy and corresponding animations in it.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXSaveMeshHierarchyToFileW. Otherwise, the function call resolves to D3DXSaveMeshHierarchyToFileA. This function does not save compressed animation sets. 	
        /// </remarks>	
        /// <param name="filename"> Pointer to a string that specifies the name of the .x file identifying the saved mesh. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="xFormat"> Format of the .x file (text or binary, compressed or not). See D3DXF_FILEFORMAT. D3DXF_FILEFORMAT_COMPRESSED can be combined (using a logical OR) with either the D3DXF_FILEFORMAT_BINARY or D3DXF_FILEFORMAT_TEXT flags to reduce the output file size. </param>
        /// <param name="pFrameRoot"> Root node of the hierarchy to be saved. See <see cref="SlimDX2.Direct3D9.Frame"/>. </param>
        /// <param name="pAnimController"> Animation controller that has animation sets to be stored. See <see cref="SlimDX2.Direct3D9.AnimationController"/>. </param>
        /// <param name="pUserDataSaver"> Application-provided interface that allows saving of user data. See <see cref="SlimDX2.Direct3D9.SaveUserData"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXSaveMeshHierarchyToFileW([None] const wchar* Filename,[None] int XFormat,[None] const D3DXFRAME* pFrameRoot,[None] LPD3DXANIMATIONCONTROLLER pAnimController,[None] LPD3DXSAVEUSERDATA pUserDataSaver)</unmanaged>
		public static SlimDX2.Result SaveMeshHierarchyToFileW(string filename, int xFormat, ref SlimDX2.Direct3D9.Frame pFrameRoot, SlimDX2.Direct3D9.AnimationController pAnimController, SlimDX2.Direct3D9.SaveUserData pUserDataSaver) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pFrameRoot_ = new SlimDX2.Direct3D9.Frame.__Native();
                pFrameRoot.__MarshalTo(ref pFrameRoot_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveMeshHierarchyToFileW_( filename,  xFormat, ref  pFrameRoot_, (pAnimController == null)?IntPtr.Zero:pAnimController.NativePointer, (pUserDataSaver == null)?IntPtr.Zero:pUserDataSaver.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveMeshHierarchyToFileW([None] const wchar* Filename,[None] int XFormat,[None] const D3DXFRAME* pFrameRoot,[None] LPD3DXANIMATIONCONTROLLER pAnimController,[None] LPD3DXSAVEUSERDATA pUserDataSaver)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveMeshHierarchyToFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveMeshHierarchyToFileW_([MarshalAs(UnmanagedType.LPWStr),In] string filename, int xFormat, ref SlimDX2.Direct3D9.Frame.__Native pFrameRoot, IntPtr pAnimController, IntPtr pUserDataSaver);		
        
        /// <summary>	
        /// Destroys the subtree of frames under the root, including the root.	
        /// </summary>	
        /// <param name="pFrameRoot"> Pointer to the root node. </param>
        /// <param name="pAlloc"> Allocation interface used to deallocate nodes of the frame hierarchy. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXFrameDestroy([None] LPD3DXFRAME pFrameRoot,[None] LPD3DXALLOCATEHIERARCHY pAlloc)</unmanaged>
		public static SlimDX2.Result FrameDestroy(ref SlimDX2.Direct3D9.Frame pFrameRoot, SlimDX2.Direct3D9.AllocateHierarchy pAlloc) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pFrameRoot_ = new SlimDX2.Direct3D9.Frame.__Native();
                pFrameRoot.__MarshalTo(ref pFrameRoot_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFrameDestroy_(ref  pFrameRoot_, (pAlloc == null)?IntPtr.Zero:pAlloc.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFrameDestroy([None] LPD3DXFRAME pFrameRoot,[None] LPD3DXALLOCATEHIERARCHY pAlloc)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFrameDestroy", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFrameDestroy_(ref SlimDX2.Direct3D9.Frame.__Native pFrameRoot, IntPtr pAlloc);		
        
        /// <summary>	
        /// Adds a child frame to a frame.	
        /// </summary>	
        /// <param name="pFrameParent"> Pointer to the parent node. </param>
        /// <param name="pFrameChild"> Pointer to the child node. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXFrameAppendChild([None] LPD3DXFRAME pFrameParent,[None] const D3DXFRAME* pFrameChild)</unmanaged>
		public static SlimDX2.Result FrameAppendChild(ref SlimDX2.Direct3D9.Frame pFrameParent, ref SlimDX2.Direct3D9.Frame pFrameChild) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pFrameParent_ = new SlimDX2.Direct3D9.Frame.__Native();
                pFrameParent.__MarshalTo(ref pFrameParent_);
                SlimDX2.Direct3D9.Frame.__Native pFrameChild_ = new SlimDX2.Direct3D9.Frame.__Native();
                pFrameChild.__MarshalTo(ref pFrameChild_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFrameAppendChild_(ref  pFrameParent_, ref  pFrameChild_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFrameAppendChild([None] LPD3DXFRAME pFrameParent,[None] const D3DXFRAME* pFrameChild)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFrameAppendChild", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFrameAppendChild_(ref SlimDX2.Direct3D9.Frame.__Native pFrameParent, ref SlimDX2.Direct3D9.Frame.__Native pFrameChild);		
        
        /// <summary>	
        /// Finds the child frame of a root frame.	
        /// </summary>	
        /// <param name="pFrameRoot"> Pointer to the root frame. See <see cref="SlimDX2.Direct3D9.Frame"/>. </param>
        /// <param name="name"> Name of the child frame to find. </param>
        /// <returns> {{LPD3DXFRAME}} Returns the child frame if it is found, or NULL otherwise. See <see cref="SlimDX2.Direct3D9.Frame"/>. </returns>
        /// <unmanaged>LPD3DXFRAME D3DXFrameFind([None] const D3DXFRAME* pFrameRoot,[None] const char* Name)</unmanaged>
		public static SlimDX2.Direct3D9.Frame FrameFind(ref SlimDX2.Direct3D9.Frame pFrameRoot, string name) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pFrameRoot_ = new SlimDX2.Direct3D9.Frame.__Native();
                pFrameRoot.__MarshalTo(ref pFrameRoot_);
                SlimDX2.Direct3D9.Frame __result__;
                __result__= (SlimDX2.Direct3D9.Frame)D3DXFrameFind_(ref  pFrameRoot_,  name);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>LPD3DXFRAME D3DXFrameFind([None] const D3DXFRAME* pFrameRoot,[None] const char* Name)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFrameFind", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Direct3D9.Frame D3DXFrameFind_(ref SlimDX2.Direct3D9.Frame.__Native pFrameRoot, [MarshalAs(UnmanagedType.LPStr),In] string name);		
        
        /// <summary>	
        /// Given a frame hierarchy, registers all the named matrices in the animation mixer.	
        /// </summary>	
        /// <param name="pFrameRoot"> The top level node in the frame hierarchy. </param>
        /// <param name="pAnimController"> Pointer to the animation controller object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXFrameRegisterNamedMatrices([None] LPD3DXFRAME pFrameRoot,[None] LPD3DXANIMATIONCONTROLLER pAnimController)</unmanaged>
		public static SlimDX2.Result FrameRegisterNamedMatrices(ref SlimDX2.Direct3D9.Frame pFrameRoot, SlimDX2.Direct3D9.AnimationController pAnimController) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pFrameRoot_ = new SlimDX2.Direct3D9.Frame.__Native();
                pFrameRoot.__MarshalTo(ref pFrameRoot_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFrameRegisterNamedMatrices_(ref  pFrameRoot_, (pAnimController == null)?IntPtr.Zero:pAnimController.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFrameRegisterNamedMatrices([None] LPD3DXFRAME pFrameRoot,[None] LPD3DXANIMATIONCONTROLLER pAnimController)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFrameRegisterNamedMatrices", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFrameRegisterNamedMatrices_(ref SlimDX2.Direct3D9.Frame.__Native pFrameRoot, IntPtr pAnimController);		
        
        /// <summary>	
        /// Counts number of frames in a subtree that have non-null names.	
        /// </summary>	
        /// <param name="pFrameRoot"> Pointer to the root node of the subtree. </param>
        /// <returns> {{UINT}} Returns the frame count. </returns>
        /// <unmanaged>UINT D3DXFrameNumNamedMatrices([None] const D3DXFRAME* pFrameRoot)</unmanaged>
		public static int FrameNumNamedMatrices(ref SlimDX2.Direct3D9.Frame pFrameRoot) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pFrameRoot_ = new SlimDX2.Direct3D9.Frame.__Native();
                pFrameRoot.__MarshalTo(ref pFrameRoot_);
                int __result__;
                __result__= (int)D3DXFrameNumNamedMatrices_(ref  pFrameRoot_);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>UINT D3DXFrameNumNamedMatrices([None] const D3DXFRAME* pFrameRoot)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFrameNumNamedMatrices", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DXFrameNumNamedMatrices_(ref SlimDX2.Direct3D9.Frame.__Native pFrameRoot);		
        
        /// <summary>	
        /// Computes the bounding sphere of all the meshes in the frame hierarchy.	
        /// </summary>	
        /// <param name="pFrameRoot"> Pointer to the root node. </param>
        /// <param name="pObjectCenter"> Returns the center of the bounding sphere. </param>
        /// <param name="pObjectRadius"> Returns the radius of the bounding sphere. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXFrameCalculateBoundingSphere([None] const D3DXFRAME* pFrameRoot,[None] LPD3DXVECTOR3 pObjectCenter,[None] FLOAT* pObjectRadius)</unmanaged>
		public static SlimDX2.Result FrameCalculateBoundingSphere(ref SlimDX2.Direct3D9.Frame pFrameRoot, ref SlimMath.Vector3 pObjectCenter, ref float pObjectRadius) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pFrameRoot_ = new SlimDX2.Direct3D9.Frame.__Native();
                pFrameRoot.__MarshalTo(ref pFrameRoot_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFrameCalculateBoundingSphere_(ref  pFrameRoot_, ref  pObjectCenter, ref  pObjectRadius);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFrameCalculateBoundingSphere([None] const D3DXFRAME* pFrameRoot,[None] LPD3DXVECTOR3 pObjectCenter,[None] FLOAT* pObjectRadius)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFrameCalculateBoundingSphere", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFrameCalculateBoundingSphere_(ref SlimDX2.Direct3D9.Frame.__Native pFrameRoot, ref SlimMath.Vector3 pObjectCenter, ref float pObjectRadius);		
        
        /// <summary>	
        /// Creates a <see cref="SlimDX2.Direct3D9.KeyframedAnimationSet"/> key framed animation set interface.	
        /// </summary>	
        /// <param name="pName"> Pointer to the name of the animation set. </param>
        /// <param name="ticksPerSecond"> Number of key frame ticks that elapse per second. </param>
        /// <param name="playback"> Type of the animation set playback loop. See <see cref="SlimDX2.Direct3D9.PlaybackType"/>. </param>
        /// <param name="numAnimations"> Number of scale, rotate, and translate (SRT) animation sets. </param>
        /// <param name="numCallbackKeys"> Number of callback keys. </param>
        /// <param name="pCallbackKeys"> Pointer to a <see cref="SlimDX2.Direct3D9.KeyCallback"/> structure that stores user callback data. </param>
        /// <param name="ppAnimationSet"> Address of a pointer to the <see cref="SlimDX2.Direct3D9.KeyframedAnimationSet"/> key framed animation set interface. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateKeyframedAnimationSet([None] const char* pName,[None] DOUBLE TicksPerSecond,[None] D3DXPLAYBACK_TYPE Playback,[None] UINT NumAnimations,[None] UINT NumCallbackKeys,[None] const D3DXKEY_CALLBACK* pCallbackKeys,[None] LPD3DXKEYFRAMEDANIMATIONSET* ppAnimationSet)</unmanaged>
		public static SlimDX2.Result CreateKeyframedAnimationSet(string pName, double ticksPerSecond, SlimDX2.Direct3D9.PlaybackType playback, int numAnimations, int numCallbackKeys, ref SlimDX2.Direct3D9.KeyCallback pCallbackKeys, out SlimDX2.Direct3D9.KeyframedAnimationSet ppAnimationSet) {
            unsafe {
                IntPtr ppAnimationSet_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateKeyframedAnimationSet_( pName,  ticksPerSecond,  playback,  numAnimations,  numCallbackKeys, ref  pCallbackKeys, out ppAnimationSet_);
                ppAnimationSet = (ppAnimationSet_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.KeyframedAnimationSet(ppAnimationSet_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateKeyframedAnimationSet([None] const char* pName,[None] DOUBLE TicksPerSecond,[None] D3DXPLAYBACK_TYPE Playback,[None] UINT NumAnimations,[None] UINT NumCallbackKeys,[None] const D3DXKEY_CALLBACK* pCallbackKeys,[None] LPD3DXKEYFRAMEDANIMATIONSET* ppAnimationSet)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateKeyframedAnimationSet", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateKeyframedAnimationSet_([MarshalAs(UnmanagedType.LPStr),In] string pName, double ticksPerSecond, SlimDX2.Direct3D9.PlaybackType playback, int numAnimations, int numCallbackKeys, ref SlimDX2.Direct3D9.KeyCallback pCallbackKeys, out IntPtr ppAnimationSet);		
        
        /// <summary>	
        /// Creates a <see cref="SlimDX2.Direct3D9.CompressedAnimationSet"/> key framed animation set interface that stores key frame data in a compressed format.	
        /// </summary>	
        /// <param name="pName"> Pointer to the name of the animation set. </param>
        /// <param name="ticksPerSecond"> Number of key frame ticks that elapse per second. </param>
        /// <param name="playback"> Type of the animation set playback loop. See <see cref="SlimDX2.Direct3D9.PlaybackType"/>. </param>
        /// <param name="pCompressedData"> Pointer to the <see cref="SlimDX2.Direct3D9.Buffer"/> buffer that stores the animation set as compressed data. </param>
        /// <param name="numCallbackKeys"> Number of callback keys. </param>
        /// <param name="pCallbackKeys"> Pointer to a <see cref="SlimDX2.Direct3D9.KeyCallback"/> structure that stores user callback data. </param>
        /// <param name="ppAnimationSet"> Address of a pointer to the <see cref="SlimDX2.Direct3D9.CompressedAnimationSet"/> interface that stores key framed animation set data in a compressed format. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCompressedAnimationSet([None] const char* pName,[None] DOUBLE TicksPerSecond,[None] D3DXPLAYBACK_TYPE Playback,[None] LPD3DXBUFFER pCompressedData,[None] UINT NumCallbackKeys,[None] const D3DXKEY_CALLBACK* pCallbackKeys,[None] LPD3DXCOMPRESSEDANIMATIONSET* ppAnimationSet)</unmanaged>
		public static SlimDX2.Result CreateCompressedAnimationSet(string pName, double ticksPerSecond, SlimDX2.Direct3D9.PlaybackType playback, SlimDX2.Direct3D9.Buffer pCompressedData, int numCallbackKeys, ref SlimDX2.Direct3D9.KeyCallback pCallbackKeys, out SlimDX2.Direct3D9.CompressedAnimationSet ppAnimationSet) {
            unsafe {
                IntPtr ppAnimationSet_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCompressedAnimationSet_( pName,  ticksPerSecond,  playback, (pCompressedData == null)?IntPtr.Zero:pCompressedData.NativePointer,  numCallbackKeys, ref  pCallbackKeys, out ppAnimationSet_);
                ppAnimationSet = (ppAnimationSet_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CompressedAnimationSet(ppAnimationSet_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCompressedAnimationSet([None] const char* pName,[None] DOUBLE TicksPerSecond,[None] D3DXPLAYBACK_TYPE Playback,[None] LPD3DXBUFFER pCompressedData,[None] UINT NumCallbackKeys,[None] const D3DXKEY_CALLBACK* pCallbackKeys,[None] LPD3DXCOMPRESSEDANIMATIONSET* ppAnimationSet)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCompressedAnimationSet", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCompressedAnimationSet_([MarshalAs(UnmanagedType.LPStr),In] string pName, double ticksPerSecond, SlimDX2.Direct3D9.PlaybackType playback, IntPtr pCompressedData, int numCallbackKeys, ref SlimDX2.Direct3D9.KeyCallback pCallbackKeys, out IntPtr ppAnimationSet);		
        
        /// <summary>	
        /// Creates an animation controller object.	
        /// </summary>	
        /// <remarks>	
        ///  An animation controller controls an animation mixer. The controller adds methods to modify blending parameters over time to enable smooth transitions. 	
        /// </remarks>	
        /// <param name="maxNumMatrices"> Maximum number of animation outputs the controller can support. </param>
        /// <param name="maxNumAnimationSets"> Maximum number of animation sets that can be mixed. </param>
        /// <param name="maxNumTracks"> Maximum number of animation sets that can be mixed simultaneously. </param>
        /// <param name="maxNumEvents"> Maximum number of outstanding events that the controller will support. </param>
        /// <param name="ppAnimController"> Pointer to the animation controller object created. See <see cref="SlimDX2.Direct3D9.AnimationController"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateAnimationController([None] UINT MaxNumMatrices,[None] UINT MaxNumAnimationSets,[None] UINT MaxNumTracks,[None] UINT MaxNumEvents,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
		public static SlimDX2.Result CreateAnimationController(int maxNumMatrices, int maxNumAnimationSets, int maxNumTracks, int maxNumEvents, out SlimDX2.Direct3D9.AnimationController ppAnimController) {
            unsafe {
                IntPtr ppAnimController_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateAnimationController_( maxNumMatrices,  maxNumAnimationSets,  maxNumTracks,  maxNumEvents, out ppAnimController_);
                ppAnimController = (ppAnimController_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.AnimationController(ppAnimController_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateAnimationController([None] UINT MaxNumMatrices,[None] UINT MaxNumAnimationSets,[None] UINT MaxNumTracks,[None] UINT MaxNumEvents,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateAnimationController", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateAnimationController_(int maxNumMatrices, int maxNumAnimationSets, int maxNumTracks, int maxNumEvents, out IntPtr ppAnimController);		
    }
}