// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Functions for SlimDX2.Direct3D9 namespace.
//     This code was generated by a tool.
//     Date : 11/15/2010 14:52:49
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace SlimDX2.Direct3D9 {


	/// <summary>
    /// D3D9 Functions.
    /// </summary>
    static partial class D3D9 {   
        
        /// <summary>Constant None.</summary>
        public const int SdkVersion = 32;
        
        /// <summary>	
        /// Create an IDirect3D9 object and return an interface to it.	
        /// </summary>	
        /// <remarks>	
        ///  The Direct3D object is the first Direct3D COM object that your graphical application needs to create and the last object that your application needs to release. Functions for enumerating and retrieving capabilities of a device are accessible through the Direct3D object. This enables applications to select devices without creating them. Create an IDirect3D9 object as shown here: 	
        /// <code> LPDIRECT3D9 g_pD3D = NULL; if( NULL == (g_pD3D = Direct3DCreate9(D3D_SDK_VERSION))) return E_FAIL; </code>	
        /// 	
        ///  The IDirect3D9 interface supports enumeration of active display adapters and allows the creation of <see cref="SlimDX2.Direct3D9.Device"/> objects. If the user dynamically adds adapters (either by adding devices to the desktop, or by hot-docking a laptop), those devices will not be included in the enumeration. Creating a new IDirect3D9 interface will expose the new devices. D3D_SDK_VERSION is passed to this function to ensure that the header files against which an application is compiled match the version of the runtime DLL's that are installed on the machine. D3D_SDK_VERSION is only changed in the runtime when a header change (or other code change) would require an application to be rebuilt. If this function fails, it indicates that the header file version does not match the runtime DLL version. For an example, see {{Creating a Device (Direct3D 9)}}. 	
        /// </remarks>	
        /// <param name="sDKVersion"> The value of this parameter should be D3D_SDK_VERSION. See Remarks. </param>
        /// <returns> <see cref="SlimDX2.Direct3D9.Direct3D"/> If successful, this function returns a pointer to an <see cref="SlimDX2.Direct3D9.Direct3D"/> interface; otherwise, a NULL pointer is returned. </returns>
        /// <unmanaged>IDirect3D9* Direct3DCreate9([None] int SDKVersion)</unmanaged>
		public static SlimDX2.Direct3D9.Direct3D Direct3DCreate9(int sDKVersion) {
            unsafe {
                SlimDX2.Direct3D9.Direct3D __result__;
                __result__= (SlimDX2.Direct3D9.Direct3D)new SlimDX2.Direct3D9.Direct3D((IntPtr)Direct3DCreate9_( sDKVersion));
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>IDirect3D9* Direct3DCreate9([None] int SDKVersion)</unmanaged>
		[DllImport("d3d9.dll", EntryPoint = "Direct3DCreate9", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static IntPtr Direct3DCreate9_(int sDKVersion);		
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct3D9.Direct3D9Ex"/> object and returns an interface to it.	
        /// </summary>	
        /// <remarks>	
        ///   The <see cref="SlimDX2.Direct3D9.Direct3D9Ex"/> object is the first object that the application creates and the last object thta the application releases. Functions for enumerating and retrieving capabilities of a device are accessible through the IDirect3D9Ex object. This enables applications to select devices without creating them.   The <see cref="SlimDX2.Direct3D9.Direct3D9Ex"/> interface supports enumeration of active display adapters and allows the creation of IDirect3D9Ex objects. If the user dynamically adds adapters (either by adding devices to the desktop, or by hot-docking a laptop), these devices are not included in the enumeration. Creating a new IDirect3D9Ex interface will expose the new devices.   Pass the D3D_SDK_VERSION flag to this function to ensure that header files used in the compiled application match the version of the installed runtime DLLs. D3D_SDK_VERSION is changed in the runtime only when a header or another code change would require rebuilding the application. If this function fails, it indicates that the versions of the header file and the runtime DLL do not match.  Note??Direct3DCreate9Ex is supported only in Windows Vista, Windows Server 2008, and Windows 7.   Earlier versions of the D3D9.dll library do not include Direct3D9Ex and Direct3DCreate9Ex.  	
        /// </remarks>	
        /// <param name="sDKVersion"> The value of this parameter should be D3D_SDK_VERSION. See Remarks. </param>
        /// <param name="arg1">  Address of a pointer to an <see cref="SlimDX2.Direct3D9.Direct3D9Ex"/> interface, representing the created IDirect3D9Ex object. If the function fails, NULL is inserted here.  </param>
        /// <returns> <see cref="int"/>   D3DERR_NOTAVAILABLE if Direct3DEx features are not supported (no WDDM driver is installed) or if the SDKVersion does not match the version of the DLL.   D3DERR_OUTOFMEMORY if out-of-memory conditions are detected when creating the enumerator object.  S_OK if the creation of the enumerator object is successful.  </returns>
        /// <unmanaged>HRESULT Direct3DCreate9Ex([None] int SDKVersion,[None] IDirect3D9Ex** arg1)</unmanaged>
		public static SlimDX2.Result Direct3DCreate9Ex(int sDKVersion, out SlimDX2.Direct3D9.Direct3D9Ex arg1) {
            unsafe {
                IntPtr arg1_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)Direct3DCreate9Ex_( sDKVersion, out arg1_);
                arg1 = (arg1_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Direct3D9Ex(arg1_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT Direct3DCreate9Ex([None] int SDKVersion,[None] IDirect3D9Ex** arg1)</unmanaged>
		[DllImport("d3d9.dll", EntryPoint = "Direct3DCreate9Ex", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result Direct3DCreate9Ex_(int sDKVersion, out IntPtr arg1);		
    }

	/// <summary>
    /// D3DX9 Functions.
    /// </summary>
    static partial class D3DX9 {   
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="col">No documentation.</param>
        /// <param name="wszName">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>int D3DPERF_BeginEvent([None] D3DCOLOR col,[None] const wchar_t* wszName)</unmanaged>
		public static int D3DPERFBeginEvent(SlimMath.Color4 col, string wszName) {
            unsafe {
                int __result__;
                __result__= (int)D3DPERF_BeginEvent_( col,  wszName);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>int D3DPERF_BeginEvent([None] D3DCOLOR col,[None] const wchar_t* wszName)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_BeginEvent", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DPERF_BeginEvent_(SlimMath.Color4 col, [MarshalAs(UnmanagedType.LPWStr),In] string wszName);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int D3DPERF_EndEvent()</unmanaged>
		public static int D3DPERFEndEvent() {
            unsafe {
                int __result__;
                __result__= (int)D3DPERF_EndEvent_();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>int D3DPERF_EndEvent()</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_EndEvent", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DPERF_EndEvent_();		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="col">No documentation.</param>
        /// <param name="wszName">No documentation.</param>
        /// <unmanaged>void D3DPERF_SetMarker([None] D3DCOLOR col,[None] const wchar_t* wszName)</unmanaged>
		public static void D3DPERFSetMarker(SlimMath.Color4 col, string wszName) {
            unsafe {
                D3DPERF_SetMarker_( col,  wszName);
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>void D3DPERF_SetMarker([None] D3DCOLOR col,[None] const wchar_t* wszName)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_SetMarker", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static void D3DPERF_SetMarker_(SlimMath.Color4 col, [MarshalAs(UnmanagedType.LPWStr),In] string wszName);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="col">No documentation.</param>
        /// <param name="wszName">No documentation.</param>
        /// <unmanaged>void D3DPERF_SetRegion([None] D3DCOLOR col,[None] const wchar_t* wszName)</unmanaged>
		public static void D3DPERFSetRegion(SlimMath.Color4 col, string wszName) {
            unsafe {
                D3DPERF_SetRegion_( col,  wszName);
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>void D3DPERF_SetRegion([None] D3DCOLOR col,[None] const wchar_t* wszName)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_SetRegion", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static void D3DPERF_SetRegion_(SlimMath.Color4 col, [MarshalAs(UnmanagedType.LPWStr),In] string wszName);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>BOOL D3DPERF_QueryRepeatFrame()</unmanaged>
		public static bool D3DPERFQueryRepeatFrame() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=D3DPERF_QueryRepeatFrame_());
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>BOOL D3DPERF_QueryRepeatFrame()</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_QueryRepeatFrame", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DPERF_QueryRepeatFrame_();		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwOptions">No documentation.</param>
        /// <unmanaged>void D3DPERF_SetOptions([None] int dwOptions)</unmanaged>
		public static void D3DPERFSetOptions(int dwOptions) {
            unsafe {
                D3DPERF_SetOptions_( dwOptions);
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>void D3DPERF_SetOptions([None] int dwOptions)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_SetOptions", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static void D3DPERF_SetOptions_(int dwOptions);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>int D3DPERF_GetStatus()</unmanaged>
		public static int D3DPERFGetStatus() {
            unsafe {
                int __result__;
                __result__= (int)D3DPERF_GetStatus_();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>int D3DPERF_GetStatus()</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_GetStatus", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DPERF_GetStatus_();		
        
        /// <summary>	
        /// Verify that the version of D3DX you compiled with is the version that you are running.	
        /// </summary>	
        /// <remarks>	
        ///  Use this function during the initialization of your application like this: 	
        /// <code> HRESULT CD3DXMyApplication::Initialize(HINSTANCE hInstance,  LPCSTR szWindowName, LPCSTR szClassName, UINT uWidth, UINT uHeight)	
        /// { HRESULT hr; if (!D3DXCheckVersion(D3D_SDK_VERSION, D3DX_SDK_VERSION)) return E_FAIL; ...	
        /// } </code>	
        /// 	
        ///  Use <see cref="SlimDX2.Direct3D9.D3D9.Direct3DCreate9"/> to verify that the correct runtime is installed. 	
        /// </remarks>	
        /// <param name="d3DSdkVersion"> Use D3D_SDK_VERSION. See remarks. </param>
        /// <param name="d3DXSdkVersion"> Use D3DX_SDK_VERSION. See remarks. </param>
        /// <returns> {{BOOL}} Returns TRUE if the version of D3DX you compiled against is the version you are running with; otherwise, FALSE is returned. </returns>
        /// <unmanaged>BOOL D3DXCheckVersion([None] int D3DSdkVersion,[None] int D3DXSdkVersion)</unmanaged>
		public static bool D3DXCheckVersion(int d3DSdkVersion, int d3DXSdkVersion) {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=D3DXCheckVersion_( d3DSdkVersion,  d3DXSdkVersion));
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>BOOL D3DXCheckVersion([None] int D3DSdkVersion,[None] int D3DXSdkVersion)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCheckVersion", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DXCheckVersion_(int d3DSdkVersion, int d3DXSdkVersion);		
        
        /// <summary>	
        /// Turns on or off all D3DX debug output.	
        /// </summary>	
        /// <param name="mute"> If TRUE, debugger output is halted; if FALSE, debug output is enabled. </param>
        /// <returns> {{BOOL}} Returns the previous value of Mute. </returns>
        /// <unmanaged>BOOL D3DXDebugMute([None] BOOL Mute)</unmanaged>
		public static bool D3DXDebugMute(bool mute) {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=D3DXDebugMute_( mute));
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>BOOL D3DXDebugMute([None] BOOL Mute)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXDebugMute", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DXDebugMute_(bool mute);		
        
        /// <summary>	
        /// Creates a sprite object which is associated with a particular device. Sprite objects are used to draw 2D images to the screen.	
        /// </summary>	
        /// <remarks>	
        ///  This interface can be used to draw two dimensional images in screen space of the associated device. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device to be associated with the sprite. </param>
        /// <param name="spriteRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXSprite"/> interface. This interface allows the user to access sprite functions.  </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK.If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateSprite([None] LPDIRECT3DDEVICE9 pDevice,[None] LPD3DXSPRITE* ppSprite)</unmanaged>
		public static SlimDX2.Result D3DXCreateSprite(SlimDX2.Direct3D9.Device pDevice, out SlimDX2.Direct3D9.ID3DXSprite spriteRef) {
            unsafe {
                IntPtr spriteRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateSprite_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer, out spriteRef_);
                spriteRef = (spriteRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXSprite(spriteRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateSprite([None] LPDIRECT3DDEVICE9 pDevice,[None] LPD3DXSPRITE* ppSprite)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSprite", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateSprite_(IntPtr pDevice, out IntPtr spriteRef);		
        
        /// <summary>	
        /// Creates a font object for a device and font.	
        /// </summary>	
        /// <remarks>	
        ///  The creation of an ID3DXFont object requires that the device supports 32-bit color. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateFontW. Otherwise, the function call resolves to D3DXCreateFontA because ANSI strings are being used. If you want more information about font parameters, see {{The Logical Font}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device to be associated with the font object. </param>
        /// <param name="height"> The height of the characters in logical units. </param>
        /// <param name="width"> The width of the characters in logical units. </param>
        /// <param name="weight"> Typeface weight. One example is bold. </param>
        /// <param name="mipLevels"> The number of mipmap levels. </param>
        /// <param name="italic"> True for italic font, false otherwise. </param>
        /// <param name="charSet"> The character set of the font. </param>
        /// <param name="outputPrecision"> Specifies how Windows should attempt to match the desired font sizes and characteristics with actual fonts. Use OUT_TT_ONLY_PRECIS for instance, to ensure that you always get a TrueType font. </param>
        /// <param name="quality"> Specifies how Windows should match the desired font with a real font. It applies to raster fonts only and should not affect TrueType fonts. </param>
        /// <param name="pitchAndFamily"> Pitch and family index. </param>
        /// <param name="faceNameRef"> String containing the typeface name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.  </param>
        /// <param name="fontRef"> Returns a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXFont"/> interface, representing the created font object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateFontA([None] LPDIRECT3DDEVICE9 pDevice,[None] int Height,[None] int Width,[None] int Weight,[None] int MipLevels,[None] BOOL Italic,[None] int CharSet,[None] int OutputPrecision,[None] int Quality,[None] int PitchAndFamily,[None] const char* pFaceName,[None] LPD3DXFONT* ppFont)</unmanaged>
		public static SlimDX2.Result D3DXCreateFontA(SlimDX2.Direct3D9.Device pDevice, int height, int width, int weight, int mipLevels, bool italic, int charSet, int outputPrecision, int quality, int pitchAndFamily, string faceNameRef, out SlimDX2.Direct3D9.ID3DXFont fontRef) {
            unsafe {
                IntPtr fontRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateFontA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  height,  width,  weight,  mipLevels,  italic,  charSet,  outputPrecision,  quality,  pitchAndFamily,  faceNameRef, out fontRef_);
                fontRef = (fontRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXFont(fontRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateFontA([None] LPDIRECT3DDEVICE9 pDevice,[None] int Height,[None] int Width,[None] int Weight,[None] int MipLevels,[None] BOOL Italic,[None] int CharSet,[None] int OutputPrecision,[None] int Quality,[None] int PitchAndFamily,[None] const char* pFaceName,[None] LPD3DXFONT* ppFont)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateFontA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateFontA_(IntPtr pDevice, int height, int width, int weight, int mipLevels, bool italic, int charSet, int outputPrecision, int quality, int pitchAndFamily, [MarshalAs(UnmanagedType.LPStr),In] string faceNameRef, out IntPtr fontRef);		
        
        /// <summary>	
        /// Creates a font object for a device and font.	
        /// </summary>	
        /// <remarks>	
        ///  The creation of an ID3DXFont object requires that the device supports 32-bit color. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateFontW. Otherwise, the function call resolves to D3DXCreateFontA because ANSI strings are being used. If you want more information about font parameters, see {{The Logical Font}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device to be associated with the font object. </param>
        /// <param name="height"> The height of the characters in logical units. </param>
        /// <param name="width"> The width of the characters in logical units. </param>
        /// <param name="weight"> Typeface weight. One example is bold. </param>
        /// <param name="mipLevels"> The number of mipmap levels. </param>
        /// <param name="italic"> True for italic font, false otherwise. </param>
        /// <param name="charSet"> The character set of the font. </param>
        /// <param name="outputPrecision"> Specifies how Windows should attempt to match the desired font sizes and characteristics with actual fonts. Use OUT_TT_ONLY_PRECIS for instance, to ensure that you always get a TrueType font. </param>
        /// <param name="quality"> Specifies how Windows should match the desired font with a real font. It applies to raster fonts only and should not affect TrueType fonts. </param>
        /// <param name="pitchAndFamily"> Pitch and family index. </param>
        /// <param name="faceNameRef"> String containing the typeface name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.  </param>
        /// <param name="fontRef"> Returns a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXFont"/> interface, representing the created font object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateFontW([None] LPDIRECT3DDEVICE9 pDevice,[None] int Height,[None] int Width,[None] int Weight,[None] int MipLevels,[None] BOOL Italic,[None] int CharSet,[None] int OutputPrecision,[None] int Quality,[None] int PitchAndFamily,[None] const wchar_t* pFaceName,[None] LPD3DXFONT* ppFont)</unmanaged>
		public static SlimDX2.Result D3DXCreateFontW(SlimDX2.Direct3D9.Device pDevice, int height, int width, int weight, int mipLevels, bool italic, int charSet, int outputPrecision, int quality, int pitchAndFamily, string faceNameRef, out SlimDX2.Direct3D9.ID3DXFont fontRef) {
            unsafe {
                IntPtr fontRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateFontW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  height,  width,  weight,  mipLevels,  italic,  charSet,  outputPrecision,  quality,  pitchAndFamily,  faceNameRef, out fontRef_);
                fontRef = (fontRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXFont(fontRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateFontW([None] LPDIRECT3DDEVICE9 pDevice,[None] int Height,[None] int Width,[None] int Weight,[None] int MipLevels,[None] BOOL Italic,[None] int CharSet,[None] int OutputPrecision,[None] int Quality,[None] int PitchAndFamily,[None] const wchar_t* pFaceName,[None] LPD3DXFONT* ppFont)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateFontW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateFontW_(IntPtr pDevice, int height, int width, int weight, int mipLevels, bool italic, int charSet, int outputPrecision, int quality, int pitchAndFamily, [MarshalAs(UnmanagedType.LPWStr),In] string faceNameRef, out IntPtr fontRef);		
        
        /// <summary>	
        /// Creates a font object indirectly for both a device and a font.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateFontIndirectW. Otherwise, the function call resolves to D3DXCreateFontIndirectA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device to be associated with the font object. </param>
        /// <param name="descRef"> Pointer to a {{D3DXFONT_DESC}} structure, describing the attributes of the font object to create. If the compiler settings require Unicode, the data type D3DXFONT_DESC resolves to D3DXFONT_DESCW; otherwise, the data type resolves to D3DXFONT_DESCA. See Remarks. </param>
        /// <param name="fontRef"> Returns a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXFont"/> interface, representing the created font object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateFontIndirectW([None] LPDIRECT3DDEVICE9 pDevice,[None] const D3DXFONT_DESCW* pDesc,[None] LPD3DXFONT* ppFont)</unmanaged>
		public static SlimDX2.Result CreateFontIndirect(SlimDX2.Direct3D9.Device pDevice, ref SlimDX2.Direct3D9.FontDescription descRef, out SlimDX2.Direct3D9.ID3DXFont fontRef) {
            unsafe {
                SlimDX2.Direct3D9.FontDescription.__Native descRef_ = new SlimDX2.Direct3D9.FontDescription.__Native();
                descRef.__MarshalTo(ref descRef_);
                IntPtr fontRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateFontIndirectW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer, ref  descRef_, out fontRef_);
                fontRef = (fontRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXFont(fontRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateFontIndirectW([None] LPDIRECT3DDEVICE9 pDevice,[None] const D3DXFONT_DESCW* pDesc,[None] LPD3DXFONT* ppFont)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateFontIndirectW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateFontIndirectW_(IntPtr pDevice, ref SlimDX2.Direct3D9.FontDescription.__Native descRef, out IntPtr fontRef);		
        
        /// <summary>	
        /// Creates a render surface.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device to be associated with the render surface. </param>
        /// <param name="width"> Width of the render surface, in pixels. </param>
        /// <param name="height"> Height of the render surface, in pixels. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the pixel format of the render surface. </param>
        /// <param name="depthStencil"> If TRUE, the render surface supports a depth-stencil surface. Otherwise, this member is set to FALSE. This function will create a new depth buffer. </param>
        /// <param name="depthStencilFormat"> If  DepthStencil is set to TRUE, this parameter is a member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the depth-stencil format of the render surface. </param>
        /// <param name="renderToSurfaceRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXRenderToSurface"/> interface, representing the created render surface. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateRenderToSurface([None] LPDIRECT3DDEVICE9 pDevice,[None] int Width,[None] int Height,[None] D3DFORMAT Format,[None] BOOL DepthStencil,[None] D3DFORMAT DepthStencilFormat,[None] LPD3DXRENDERTOSURFACE* ppRenderToSurface)</unmanaged>
		public static SlimDX2.Result D3DXCreateRenderToSurface(SlimDX2.Direct3D9.Device pDevice, int width, int height, SlimDX2.Direct3D9.Format format, bool depthStencil, SlimDX2.Direct3D9.Format depthStencilFormat, out SlimDX2.Direct3D9.ID3DXRenderToSurface renderToSurfaceRef) {
            unsafe {
                IntPtr renderToSurfaceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateRenderToSurface_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  width,  height,  format,  depthStencil,  depthStencilFormat, out renderToSurfaceRef_);
                renderToSurfaceRef = (renderToSurfaceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXRenderToSurface(renderToSurfaceRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateRenderToSurface([None] LPDIRECT3DDEVICE9 pDevice,[None] int Width,[None] int Height,[None] D3DFORMAT Format,[None] BOOL DepthStencil,[None] D3DFORMAT DepthStencilFormat,[None] LPD3DXRENDERTOSURFACE* ppRenderToSurface)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateRenderToSurface", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateRenderToSurface_(IntPtr pDevice, int width, int height, SlimDX2.Direct3D9.Format format, bool depthStencil, SlimDX2.Direct3D9.Format depthStencilFormat, out IntPtr renderToSurfaceRef);		
        
        /// <summary>	
        /// Creates a render environment map.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, which is the device to associate with the render surface. </param>
        /// <param name="size"> Size of the render surface. </param>
        /// <param name="mipLevels"> The number of mipmap levels. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type that describes the pixel format of the environment map. </param>
        /// <param name="depthStencil"> If TRUE, the render surface supports a depth-stencil surface. Otherwise, this member is set to FALSE. </param>
        /// <param name="depthStencilFormat"> If DepthStencil is set to TRUE, this parameter is a member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type that describes the depth-stencil format of the environment map. </param>
        /// <param name="renderToEnvMapRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.RenderToEnvironmentMap"/> interface that represents the created render environment map. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateRenderToEnvMap([None] LPDIRECT3DDEVICE9 pDevice,[None] int Size,[None] int MipLevels,[None] D3DFORMAT Format,[None] BOOL DepthStencil,[None] D3DFORMAT DepthStencilFormat,[None] LPD3DXRenderToEnvMap* ppRenderToEnvMap)</unmanaged>
		public static SlimDX2.Result D3DXCreateRenderToEnvMap(SlimDX2.Direct3D9.Device pDevice, int size, int mipLevels, SlimDX2.Direct3D9.Format format, bool depthStencil, SlimDX2.Direct3D9.Format depthStencilFormat, out SlimDX2.Direct3D9.RenderToEnvironmentMap renderToEnvMapRef) {
            unsafe {
                IntPtr renderToEnvMapRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateRenderToEnvMap_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  size,  mipLevels,  format,  depthStencil,  depthStencilFormat, out renderToEnvMapRef_);
                renderToEnvMapRef = (renderToEnvMapRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.RenderToEnvironmentMap(renderToEnvMapRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateRenderToEnvMap([None] LPDIRECT3DDEVICE9 pDevice,[None] int Size,[None] int MipLevels,[None] D3DFORMAT Format,[None] BOOL DepthStencil,[None] D3DFORMAT DepthStencilFormat,[None] LPD3DXRenderToEnvMap* ppRenderToEnvMap)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateRenderToEnvMap", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateRenderToEnvMap_(IntPtr pDevice, int size, int mipLevels, SlimDX2.Direct3D9.Format format, bool depthStencil, SlimDX2.Direct3D9.Format depthStencilFormat, out IntPtr renderToEnvMapRef);		
        
        /// <summary>	
        /// Uses a left-handed coordinate system to create a line.	
        /// </summary>	
        /// <remarks>	
        ///  This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} Flexible Vertex Format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the created box mesh. </param>
        /// <param name="lineRef"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXLine"/> interface. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateLine([None] LPDIRECT3DDEVICE9 pDevice,[None] LPD3DXLINE* ppLine)</unmanaged>
		public static SlimDX2.Result D3DXCreateLine(SlimDX2.Direct3D9.Device pDevice, out SlimDX2.Direct3D9.ID3DXLine lineRef) {
            unsafe {
                IntPtr lineRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateLine_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer, out lineRef_);
                lineRef = (lineRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXLine(lineRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateLine([None] LPDIRECT3DDEVICE9 pDevice,[None] LPD3DXLINE* ppLine)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateLine", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateLine_(IntPtr pDevice, out IntPtr lineRef);		
        
        /// <summary>	
        /// Creates an instance of an <see cref="SlimDX2.Direct3D9.ID3DXFile"/> object.	
        /// </summary>	
        /// <remarks>	
        ///  After using this function, use {{RegisterTemplates}} or {{RegisterEnumTemplates}} to register  templates, {{CreateEnumObject}} to create an enumerator object, or {{CreateSaveObject}} to create a save object. 	
        /// </remarks>	
        /// <param name="lplpDirectXFile"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXFile"/> interface, representing the created .x file object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following: E_POINTER, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXFileCreate([None] ID3DXFile** lplpDirectXFile)</unmanaged>
		public static SlimDX2.Result D3DXFileCreate(out SlimDX2.Direct3D9.ID3DXFile lplpDirectXFile) {
            unsafe {
                IntPtr lplpDirectXFile_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFileCreate_(out lplpDirectXFile_);
                lplpDirectXFile = (lplpDirectXFile_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXFile(lplpDirectXFile_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFileCreate([None] ID3DXFile** lplpDirectXFile)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFileCreate", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFileCreate_(out IntPtr lplpDirectXFile);		
        
        /// <summary>	
        /// Creates a mesh object using a declarator.	
        /// </summary>	
        /// <param name="numFaces"> Number of faces for the mesh. The valid range for this number is greater than 0, and one less than the maximum DWORD (typically 65534), because the last index is reserved. </param>
        /// <param name="numVertices"> Number of vertices for the mesh. This parameter must be greater than 0. </param>
        /// <param name="options"> Combination of one or more flags from the  {{D3DXMESH}} enumeration, specifying options for the mesh.  </param>
        /// <param name="declarationRef"> Array of <see cref="SlimDX2.Direct3D9.VertexElement"/> elements, describing the vertex format for the returned mesh. This parameter must map directly to a flexible vertex format (FVF). </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device object to be associated with the mesh. </param>
        /// <param name="meshRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface, representing the created mesh object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateMesh([None] int NumFaces,[None] int NumVertices,[None] int Options,[None] const D3DVERTEXELEMENT9* pDeclaration,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result D3DXCreateMesh(int numFaces, int numVertices, int options, ref SlimDX2.Direct3D9.VertexElement declarationRef, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.ID3DXMesh meshRef) {
            unsafe {
                IntPtr meshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateMesh_( numFaces,  numVertices,  options, ref  declarationRef, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out meshRef_);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateMesh([None] int NumFaces,[None] int NumVertices,[None] int Options,[None] const D3DVERTEXELEMENT9* pDeclaration,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateMesh_(int numFaces, int numVertices, int options, ref SlimDX2.Direct3D9.VertexElement declarationRef, IntPtr pD3DDevice, out IntPtr meshRef);		
        
        /// <summary>	
        /// Creates a mesh object using a flexible vertex format (FVF) code.	
        /// </summary>	
        /// <param name="numFaces"> Number of faces for the mesh. The valid range for this number is greater than 0, and one less than the max DWORD value, typically 232 - 1, because the last index is reserved. </param>
        /// <param name="numVertices"> Number of vertices for the mesh. This parameter must be greater than 0. </param>
        /// <param name="options"> Combination of one or more flags from the  {{D3DXMESH}} enumeration, specifying creation options for the mesh.  </param>
        /// <param name="fvf"> Combination of <see cref="SlimDX2.Direct3D9.VertexFormat"/> that describes the vertex format for the returned mesh. This function does not support D3DFVF_XYZRHW. </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device object to be associated with the mesh. </param>
        /// <param name="meshRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface, representing the created mesh object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateMeshFVF([None] int NumFaces,[None] int NumVertices,[None] int Options,[None] int FVF,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result D3DXCreateMeshFVF(int numFaces, int numVertices, int options, int fvf, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.ID3DXMesh meshRef) {
            unsafe {
                IntPtr meshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateMeshFVF_( numFaces,  numVertices,  options,  fvf, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out meshRef_);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateMeshFVF([None] int NumFaces,[None] int NumVertices,[None] int Options,[None] int FVF,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateMeshFVF", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateMeshFVF_(int numFaces, int numVertices, int options, int fvf, IntPtr pD3DDevice, out IntPtr meshRef);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="pMesh">No documentation.</param>
        /// <param name="adjacencyRef">No documentation.</param>
        /// <param name="vertexAttributeWeightsRef">No documentation.</param>
        /// <param name="vertexWeightsRef">No documentation.</param>
        /// <param name="sMeshRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXCreateSPMesh([None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,[None] const float* pVertexWeights,[None] LPD3DXSPMESH* ppSMesh)</unmanaged>
		public static SlimDX2.Result D3DXCreateSPMesh(SlimDX2.Direct3D9.ID3DXMesh pMesh, ref int adjacencyRef, ref SlimDX2.Direct3D9.AttributeWeights vertexAttributeWeightsRef, ref float vertexWeightsRef, out SlimDX2.Direct3D9.SimplificationMesh sMeshRef) {
            unsafe {
                SlimDX2.Direct3D9.AttributeWeights.__Native vertexAttributeWeightsRef_ = new SlimDX2.Direct3D9.AttributeWeights.__Native();
                vertexAttributeWeightsRef.__MarshalTo(ref vertexAttributeWeightsRef_);
                IntPtr sMeshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateSPMesh_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  adjacencyRef, ref  vertexAttributeWeightsRef_, ref  vertexWeightsRef, out sMeshRef_);
                sMeshRef = (sMeshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.SimplificationMesh(sMeshRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateSPMesh([None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,[None] const float* pVertexWeights,[None] LPD3DXSPMESH* ppSMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSPMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateSPMesh_(IntPtr pMesh, ref int adjacencyRef, ref SlimDX2.Direct3D9.AttributeWeights.__Native vertexAttributeWeightsRef, ref float vertexWeightsRef, out IntPtr sMeshRef);		
        
        /// <summary>	
        /// Cleans a mesh, preparing it for simplification.	
        /// </summary>	
        /// <remarks>	
        ///  This function cleans a mesh using the cleaning method and options specified in the CleanType parameter. See the <see cref="SlimDX2.Direct3D9.CleanType"/> enumeration for a description of the available options. 	
        /// </remarks>	
        /// <param name="cleanType"> Vertex operations to perform in preparation for mesh cleaning. See <see cref="SlimDX2.Direct3D9.CleanType"/>. </param>
        /// <param name="pMeshIn"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface, representing the mesh to be cleaned. </param>
        /// <param name="adjacencyInRef"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh to be cleaned. </param>
        /// <param name="meshOutRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface, representing the returned cleaned mesh. The same mesh is returned that was passed in if no cleaning was necessary. </param>
        /// <param name="adjacencyOutRef"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the output mesh. </param>
        /// <param name="errorsAndWarningsRef"> Returns a buffer containing a string of errors and warnings, which explain the problems found in the mesh. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCleanMesh([None] D3DXCLEANTYPE CleanType,[None] LPD3DXMESH pMeshIn,[None] const int* pAdjacencyIn,[None] LPD3DXMESH* ppMeshOut,[None] int* pAdjacencyOut,[None] LPD3DXBUFFER* ppErrorsAndWarnings)</unmanaged>
		public static SlimDX2.Result D3DXCleanMesh(SlimDX2.Direct3D9.CleanType cleanType, SlimDX2.Direct3D9.ID3DXMesh pMeshIn, ref int adjacencyInRef, out SlimDX2.Direct3D9.ID3DXMesh meshOutRef, ref int adjacencyOutRef, out SlimDX2.Direct3D9.ShaderBytecode errorsAndWarningsRef) {
            unsafe {
                IntPtr meshOutRef_ = IntPtr.Zero;
                IntPtr errorsAndWarningsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCleanMesh_( cleanType, (pMeshIn == null)?IntPtr.Zero:pMeshIn.NativePointer, ref  adjacencyInRef, out meshOutRef_, ref  adjacencyOutRef, out errorsAndWarningsRef_);
                meshOutRef = (meshOutRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshOutRef_);
                errorsAndWarningsRef = (errorsAndWarningsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorsAndWarningsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCleanMesh([None] D3DXCLEANTYPE CleanType,[None] LPD3DXMESH pMeshIn,[None] const int* pAdjacencyIn,[None] LPD3DXMESH* ppMeshOut,[None] int* pAdjacencyOut,[None] LPD3DXBUFFER* ppErrorsAndWarnings)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCleanMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCleanMesh_(SlimDX2.Direct3D9.CleanType cleanType, IntPtr pMeshIn, ref int adjacencyInRef, out IntPtr meshOutRef, ref int adjacencyOutRef, out IntPtr errorsAndWarningsRef);		
        
        /// <summary>	
        /// Validates a mesh.	
        /// </summary>	
        /// <remarks>	
        ///  This method validates the mesh by checking for invalid indices. Error information is available from the debugger output. 	
        /// </remarks>	
        /// <param name="pMeshIn"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface, representing the mesh to be tested. </param>
        /// <param name="adjacencyRef"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh to be tested. </param>
        /// <param name="errorsAndWarningsRef"> Returns a buffer containing a string of errors and warnings, which explain the problems found in the mesh. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DXERR_INVALIDMESH, D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXValidMesh([None] LPD3DXMESH pMeshIn,[None] const int* pAdjacency,[None] LPD3DXBUFFER* ppErrorsAndWarnings)</unmanaged>
		public static SlimDX2.Result D3DXValidMesh(SlimDX2.Direct3D9.ID3DXMesh pMeshIn, ref int adjacencyRef, out SlimDX2.Direct3D9.ShaderBytecode errorsAndWarningsRef) {
            unsafe {
                IntPtr errorsAndWarningsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXValidMesh_((pMeshIn == null)?IntPtr.Zero:pMeshIn.NativePointer, ref  adjacencyRef, out errorsAndWarningsRef_);
                errorsAndWarningsRef = (errorsAndWarningsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorsAndWarningsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXValidMesh([None] LPD3DXMESH pMeshIn,[None] const int* pAdjacency,[None] LPD3DXBUFFER* ppErrorsAndWarnings)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXValidMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXValidMesh_(IntPtr pMeshIn, ref int adjacencyRef, out IntPtr errorsAndWarningsRef);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="pMesh">No documentation.</param>
        /// <param name="adjacencyRef">No documentation.</param>
        /// <param name="vertexAttributeWeightsRef">No documentation.</param>
        /// <param name="vertexWeightsRef">No documentation.</param>
        /// <param name="minValue">No documentation.</param>
        /// <param name="options">No documentation.</param>
        /// <param name="pMeshRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXGeneratePMesh([None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,[None] const float* pVertexWeights,[None] int MinValue,[None] int Options,[None] LPD3DXPMESH* ppPMesh)</unmanaged>
		public static SlimDX2.Result D3DXGeneratePMesh(SlimDX2.Direct3D9.ID3DXMesh pMesh, ref int adjacencyRef, ref SlimDX2.Direct3D9.AttributeWeights vertexAttributeWeightsRef, ref float vertexWeightsRef, int minValue, int options, out SlimDX2.Direct3D9.ID3DXPMesh pMeshRef) {
            unsafe {
                SlimDX2.Direct3D9.AttributeWeights.__Native vertexAttributeWeightsRef_ = new SlimDX2.Direct3D9.AttributeWeights.__Native();
                vertexAttributeWeightsRef.__MarshalTo(ref vertexAttributeWeightsRef_);
                IntPtr pMeshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGeneratePMesh_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  adjacencyRef, ref  vertexAttributeWeightsRef_, ref  vertexWeightsRef,  minValue,  options, out pMeshRef_);
                pMeshRef = (pMeshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXPMesh(pMeshRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGeneratePMesh([None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,[None] const float* pVertexWeights,[None] int MinValue,[None] int Options,[None] LPD3DXPMESH* ppPMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGeneratePMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGeneratePMesh_(IntPtr pMesh, ref int adjacencyRef, ref SlimDX2.Direct3D9.AttributeWeights.__Native vertexAttributeWeightsRef, ref float vertexWeightsRef, int minValue, int options, out IntPtr pMeshRef);		
        
        /// <summary>	
        /// Generates a simplified mesh using the provided weights that come as close as possible to the given MinValue.	
        /// </summary>	
        /// <remarks>	
        ///  This function generates a mesh that has MinValue vertices or faces. If the simplification process cannot reduce the mesh to MinValue, the call still succeeds because MinValue is a desired minimum, not an absolute minimum. If pVertexAttributeWeights is set to NULL, the following values are assigned to the default <see cref="SlimDX2.Direct3D9.AttributeWeights"/> structure. 	
        /// <code> D3DXATTRIBUTEWEIGHTS AttributeWeights; AttributeWeights.Position  = 1.0;	
        /// AttributeWeights.Boundary =  1.0;	
        /// AttributeWeights.Normal   =  1.0;	
        /// AttributeWeights.Diffuse  =  0.0;	
        /// AttributeWeights.Specular =  0.0;	
        /// AttributeWeights.Tex[8]   =  {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}; </code>	
        /// 	
        ///  This default structure is what most applications should use because it considers only geometric and normal adjustment. Only in special cases will the other member fields need to be modified.  	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface, representing the source mesh. </param>
        /// <param name="adjacencyRef"> Pointer to an array of three  DWORDs per face that specify the three neighbors for each face in the mesh to be simplified. </param>
        /// <param name="vertexAttributeWeightsRef"> Pointer to a <see cref="SlimDX2.Direct3D9.AttributeWeights"/> structure, containing the weight for each vertex component. If this parameter is set to NULL, a default structure is used. See Remarks. </param>
        /// <param name="vertexWeightsRef"> Pointer to an array of vertex weights. If this parameter is set to NULL, all vertex weights are set to 1.0. </param>
        /// <param name="minValue"> Number of vertices or faces, depending on the flag set in the  Options parameter, by which to simplify the source mesh. </param>
        /// <param name="options"> Specifies simplification options for the mesh. One of the flags in {{D3DXMESHSIMP}} can be set. </param>
        /// <param name="meshRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface, representing the returned simplification mesh. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXSimplifyMesh([None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,[None] const float* pVertexWeights,[None] int MinValue,[None] int Options,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result D3DXSimplifyMesh(SlimDX2.Direct3D9.ID3DXMesh pMesh, ref int adjacencyRef, ref SlimDX2.Direct3D9.AttributeWeights vertexAttributeWeightsRef, ref float vertexWeightsRef, int minValue, int options, out SlimDX2.Direct3D9.ID3DXMesh meshRef) {
            unsafe {
                SlimDX2.Direct3D9.AttributeWeights.__Native vertexAttributeWeightsRef_ = new SlimDX2.Direct3D9.AttributeWeights.__Native();
                vertexAttributeWeightsRef.__MarshalTo(ref vertexAttributeWeightsRef_);
                IntPtr meshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSimplifyMesh_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  adjacencyRef, ref  vertexAttributeWeightsRef_, ref  vertexWeightsRef,  minValue,  options, out meshRef_);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSimplifyMesh([None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,[None] const float* pVertexWeights,[None] int MinValue,[None] int Options,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSimplifyMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSimplifyMesh_(IntPtr pMesh, ref int adjacencyRef, ref SlimDX2.Direct3D9.AttributeWeights.__Native vertexAttributeWeightsRef, ref float vertexWeightsRef, int minValue, int options, out IntPtr meshRef);		
        
        /// <summary>	
        /// Computes a bounding sphere for the mesh.	
        /// </summary>	
        /// <param name="firstPositionRef"> Pointer to first position. </param>
        /// <param name="numVertices"> Number of vertices. </param>
        /// <param name="dwStride"> Number of bytes between position vectors.  Use {{GetNumBytesPerVertex}}, {{D3DXGetFVFVertexSize}}, or {{D3DXGetDeclVertexSize}} to get the vertex stride. </param>
        /// <param name="centerRef">  <see cref="SlimMath.Vector3"/> structure, defining the coordinate center of the returned bounding sphere. </param>
        /// <param name="radiusRef"> Radius of the returned bounding sphere. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXComputeBoundingSphere([None] const D3DXVECTOR3* pFirstPosition,[None] int NumVertices,[None] int dwStride,[None] D3DXVECTOR3* pCenter,[None] float* pRadius)</unmanaged>
		public static SlimDX2.Result D3DXComputeBoundingSphere(ref SlimMath.Vector3 firstPositionRef, int numVertices, int dwStride, ref SlimMath.Vector3 centerRef, ref float radiusRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeBoundingSphere_(ref  firstPositionRef,  numVertices,  dwStride, ref  centerRef, ref  radiusRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeBoundingSphere([None] const D3DXVECTOR3* pFirstPosition,[None] int NumVertices,[None] int dwStride,[None] D3DXVECTOR3* pCenter,[None] float* pRadius)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeBoundingSphere", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeBoundingSphere_(ref SlimMath.Vector3 firstPositionRef, int numVertices, int dwStride, ref SlimMath.Vector3 centerRef, ref float radiusRef);		
        
        /// <summary>	
        /// Computes a coordinate-axis oriented bounding box.	
        /// </summary>	
        /// <remarks>	
        ///  	
        /// </remarks>	
        /// <param name="firstPositionRef"> Pointer to the first position. </param>
        /// <param name="numVertices"> Number of vertices. </param>
        /// <param name="dwStride"> Count or number of bytes between vertices. </param>
        /// <param name="minRef"> Pointer to a <see cref="SlimMath.Vector3"/> structure, describing the returned lower-left corner of the bounding box. See Remarks. </param>
        /// <param name="maxRef"> Pointer to a  <see cref="SlimMath.Vector3"/> structure, describing the returned upper-right corner of the bounding box. See Remarks. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXComputeBoundingBox([None] const D3DXVECTOR3* pFirstPosition,[None] int NumVertices,[None] int dwStride,[None] D3DXVECTOR3* pMin,[None] D3DXVECTOR3* pMax)</unmanaged>
		public static SlimDX2.Result D3DXComputeBoundingBox(ref SlimMath.Vector3 firstPositionRef, int numVertices, int dwStride, ref SlimMath.Vector3 minRef, ref SlimMath.Vector3 maxRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeBoundingBox_(ref  firstPositionRef,  numVertices,  dwStride, ref  minRef, ref  maxRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeBoundingBox([None] const D3DXVECTOR3* pFirstPosition,[None] int NumVertices,[None] int dwStride,[None] D3DXVECTOR3* pMin,[None] D3DXVECTOR3* pMax)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeBoundingBox", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeBoundingBox_(ref SlimMath.Vector3 firstPositionRef, int numVertices, int dwStride, ref SlimMath.Vector3 minRef, ref SlimMath.Vector3 maxRef);		
        
        /// <summary>	
        /// Computes unit normals for each vertex in a mesh. Provided to support legacy applications. Use <see cref="SlimDX2.Direct3D9.D3DX9.D3DXComputeTangentFrameEx"/> for better results.	
        /// </summary>	
        /// <remarks>	
        ///  The input mesh must have the <see cref="SlimDX2.Direct3D9.VertexFormat.Normal"/> flag specified in its flexible vertex format (FVF). A normal for a vertex is generated by averaging the normals of all faces that share that vertex. If adjacency is provided, replicated vertices are ignored and "smoothed" over. If adjacency is not provided, replicated vertices will have normals averaged in from only the faces explicitly referencing them. This function simply calls <see cref="SlimDX2.Direct3D9.D3DX9.D3DXComputeTangentFrameEx"/> with the following input parameters: 	
        /// <code> D3DXComputeTangentFrameEx( pMesh, D3DX_DEFAULT, 0, D3DX_DEFAULT, 0, D3DX_DEFAULT, 0, D3DDECLUSAGE_NORMAL, 0, D3DXTANGENT_GENERATE_IN_PLACE | D3DXTANGENT_CALCULATE_NORMALS, pAdjacency, -1.01f, -0.01f, -1.01f, NULL, NULL); </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXBaseMesh"/> interface, representing the normalized mesh object. </param>
        /// <param name="adjacencyRef"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the created progressive mesh. This parameter is optional and should be set to NULL if it is unused. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXComputeNormals([None] LPD3DXBASEMESH pMesh,[None] const int* pAdjacency)</unmanaged>
		public static SlimDX2.Result D3DXComputeNormals(SlimDX2.Direct3D9.ID3DXBaseMesh pMesh, ref int adjacencyRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeNormals_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  adjacencyRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeNormals([None] LPD3DXBASEMESH pMesh,[None] const int* pAdjacency)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeNormals", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeNormals_(IntPtr pMesh, ref int adjacencyRef);		
        
        /// <summary>	
        /// Creates a buffer object.	
        /// </summary>	
        /// <param name="numBytes"> Size of the buffer to create, in bytes. </param>
        /// <param name="bufferRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface, representing the created buffer object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateBuffer([None] int NumBytes,[None] LPD3DXBUFFER* ppBuffer)</unmanaged>
		public static SlimDX2.Result D3DXCreateBuffer(int numBytes, out SlimDX2.Direct3D9.ShaderBytecode bufferRef) {
            unsafe {
                IntPtr bufferRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateBuffer_( numBytes, out bufferRef_);
                bufferRef = (bufferRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(bufferRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateBuffer([None] int NumBytes,[None] LPD3DXBUFFER* ppBuffer)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateBuffer", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateBuffer_(int numBytes, out IntPtr bufferRef);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="filenameRef">No documentation.</param>
        /// <param name="options">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="adjacencyRef">No documentation.</param>
        /// <param name="materialsRef">No documentation.</param>
        /// <param name="effectInstancesRef">No documentation.</param>
        /// <param name="numMaterialsRef">No documentation.</param>
        /// <param name="meshRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXA([None] const char* pFilename,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result D3DXLoadMeshFromXA(string filenameRef, int options, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.ShaderBytecode adjacencyRef, out SlimDX2.Direct3D9.ShaderBytecode materialsRef, out SlimDX2.Direct3D9.ShaderBytecode effectInstancesRef, ref int numMaterialsRef, out SlimDX2.Direct3D9.ID3DXMesh meshRef) {
            unsafe {
                IntPtr adjacencyRef_ = IntPtr.Zero;
                IntPtr materialsRef_ = IntPtr.Zero;
                IntPtr effectInstancesRef_ = IntPtr.Zero;
                IntPtr meshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadMeshFromXA_( filenameRef,  options, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out adjacencyRef_, out materialsRef_, out effectInstancesRef_, ref  numMaterialsRef, out meshRef_);
                adjacencyRef = (adjacencyRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(adjacencyRef_);
                materialsRef = (materialsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(materialsRef_);
                effectInstancesRef = (effectInstancesRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(effectInstancesRef_);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXA([None] const char* pFilename,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshFromXA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadMeshFromXA_([MarshalAs(UnmanagedType.LPStr),In] string filenameRef, int options, IntPtr pD3DDevice, out IntPtr adjacencyRef, out IntPtr materialsRef, out IntPtr effectInstancesRef, ref int numMaterialsRef, out IntPtr meshRef);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="filenameRef">No documentation.</param>
        /// <param name="options">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="adjacencyRef">No documentation.</param>
        /// <param name="materialsRef">No documentation.</param>
        /// <param name="effectInstancesRef">No documentation.</param>
        /// <param name="numMaterialsRef">No documentation.</param>
        /// <param name="meshRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXW([None] const wchar_t* pFilename,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result D3DXLoadMeshFromXW(string filenameRef, int options, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.ShaderBytecode adjacencyRef, out SlimDX2.Direct3D9.ShaderBytecode materialsRef, out SlimDX2.Direct3D9.ShaderBytecode effectInstancesRef, ref int numMaterialsRef, out SlimDX2.Direct3D9.ID3DXMesh meshRef) {
            unsafe {
                IntPtr adjacencyRef_ = IntPtr.Zero;
                IntPtr materialsRef_ = IntPtr.Zero;
                IntPtr effectInstancesRef_ = IntPtr.Zero;
                IntPtr meshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadMeshFromXW_( filenameRef,  options, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out adjacencyRef_, out materialsRef_, out effectInstancesRef_, ref  numMaterialsRef, out meshRef_);
                adjacencyRef = (adjacencyRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(adjacencyRef_);
                materialsRef = (materialsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(materialsRef_);
                effectInstancesRef = (effectInstancesRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(effectInstancesRef_);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXW([None] const wchar_t* pFilename,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshFromXW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadMeshFromXW_([MarshalAs(UnmanagedType.LPWStr),In] string filenameRef, int options, IntPtr pD3DDevice, out IntPtr adjacencyRef, out IntPtr materialsRef, out IntPtr effectInstancesRef, ref int numMaterialsRef, out IntPtr meshRef);		
        
        /// <summary>	
        /// Loads a mesh from memory.	
        /// </summary>	
        /// <remarks>	
        ///  All the meshes in the file will be collapsed into one output mesh. If the file contains a frame hierarchy, all the transformations will be applied to the mesh. For mesh files that do not contain effect instance information, default effect instances will be generated from the material information in the .x file. A default effect instance will have default values that correspond to the members of the <see cref="SlimDX2.Direct3D9.Material"/> structure. The default texture name is also filled in, but is handled differently. The name will be Texture0@Name, which corresponds to an effect variable by the name of "Texture0" with an annotation called "Name." This will contain the string file name for the texture. 	
        /// </remarks>	
        /// <param name="memory"> Pointer to the memory buffer which contains the mesh data. </param>
        /// <param name="sizeOfMemory"> Size of the file in memory, in bytes. </param>
        /// <param name="options"> Combination of one or more flags from the {{D3DXMESH}} enumeration, specifying creation options for the mesh. </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device object associated with the mesh. </param>
        /// <param name="adjacencyRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. </param>
        /// <param name="materialsRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface. When this method returns, this parameter is filled with an array of <see cref="SlimDX2.Direct3D9.ExtendedMaterial"/> structures, containing information saved in the DirectX file. </param>
        /// <param name="effectInstancesRef"> Pointer to a buffer containing an array of effect instances, one per attribute group in the returned mesh. An effect instance is a particular instance of state information used to initialize an effect. See <see cref="SlimDX2.Direct3D9.EffectInstance"/>. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. </param>
        /// <param name="numMaterialsRef"> Pointer to the number of <see cref="SlimDX2.Direct3D9.ExtendedMaterial"/> structures in the ppMaterials array, when the method returns. </param>
        /// <param name="meshRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface, representing the loaded mesh. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXInMemory([None] const void* Memory,[None] int SizeOfMemory,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result D3DXLoadMeshFromXInMemory(IntPtr memory, int sizeOfMemory, int options, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.ShaderBytecode adjacencyRef, out SlimDX2.Direct3D9.ShaderBytecode materialsRef, out SlimDX2.Direct3D9.ShaderBytecode effectInstancesRef, ref int numMaterialsRef, out SlimDX2.Direct3D9.ID3DXMesh meshRef) {
            unsafe {
                IntPtr adjacencyRef_ = IntPtr.Zero;
                IntPtr materialsRef_ = IntPtr.Zero;
                IntPtr effectInstancesRef_ = IntPtr.Zero;
                IntPtr meshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadMeshFromXInMemory_( memory,  sizeOfMemory,  options, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out adjacencyRef_, out materialsRef_, out effectInstancesRef_, ref  numMaterialsRef, out meshRef_);
                adjacencyRef = (adjacencyRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(adjacencyRef_);
                materialsRef = (materialsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(materialsRef_);
                effectInstancesRef = (effectInstancesRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(effectInstancesRef_);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXInMemory([None] const void* Memory,[None] int SizeOfMemory,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshFromXInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadMeshFromXInMemory_(IntPtr memory, int sizeOfMemory, int options, IntPtr pD3DDevice, out IntPtr adjacencyRef, out IntPtr materialsRef, out IntPtr effectInstancesRef, ref int numMaterialsRef, out IntPtr meshRef);		
        
        /// <summary>	
        /// Loads a mesh from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  See {{FindResource}} to find out more about the Module, Name and Type parameters. All the meshes in the file will be collapsed into one output mesh. If the file contains a frame hierarchy, all the transformations will be applied to the mesh. For mesh files that do not contain effect instance information, default effect instances will be generated from the material information in the .x file. A default effect instance will have default values that correspond to the members of the <see cref="SlimDX2.Direct3D9.Material"/> structure. The default texture name is also filled in, but is handled differently. The name will be Texture0@Name, which corresponds to an effect variable by the name of "Texture0" with an annotation called "Name." This will contain the string file name for the texture. 	
        /// </remarks>	
        /// <param name="module"> Handle to the module where the resource is located, or NULL for the module associated with the image the operating system used to create the current process. See remarks. </param>
        /// <param name="name"> Pointer to a string that specifies the resource to create the mesh from. See remarks. </param>
        /// <param name="type"> Pointer to a string that specifies the resource type. See remarks. </param>
        /// <param name="options"> Combination of one or more flags from the {{D3DXMESH}} enumeration that specify creation options for the mesh. </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device object associated with the mesh. </param>
        /// <param name="adjacencyRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. </param>
        /// <param name="materialsRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface. When this method returns, this parameter is filled with an array of <see cref="SlimDX2.Direct3D9.ExtendedMaterial"/> structures, containing information saved in the DirectX file. </param>
        /// <param name="effectInstancesRef"> Pointer to a buffer containing an array of effect instances, one per attribute group in the returned mesh. An effect instance is a particular instance of state information used to initialize an effect. See <see cref="SlimDX2.Direct3D9.EffectInstance"/>. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. </param>
        /// <param name="numMaterialsRef"> Pointer to the number of <see cref="SlimDX2.Direct3D9.ExtendedMaterial"/> structures in the ppMaterials array, when the method returns. </param>
        /// <param name="meshRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface, representing the loaded mesh. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXResource([None] void* Module,[None] const char* Name,[None] const char* Type,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result D3DXLoadMeshFromXResource(IntPtr module, string name, string type, int options, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.ShaderBytecode adjacencyRef, out SlimDX2.Direct3D9.ShaderBytecode materialsRef, out SlimDX2.Direct3D9.ShaderBytecode effectInstancesRef, ref int numMaterialsRef, out SlimDX2.Direct3D9.ID3DXMesh meshRef) {
            unsafe {
                IntPtr adjacencyRef_ = IntPtr.Zero;
                IntPtr materialsRef_ = IntPtr.Zero;
                IntPtr effectInstancesRef_ = IntPtr.Zero;
                IntPtr meshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadMeshFromXResource_( module,  name,  type,  options, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out adjacencyRef_, out materialsRef_, out effectInstancesRef_, ref  numMaterialsRef, out meshRef_);
                adjacencyRef = (adjacencyRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(adjacencyRef_);
                materialsRef = (materialsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(materialsRef_);
                effectInstancesRef = (effectInstancesRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(effectInstancesRef_);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXResource([None] void* Module,[None] const char* Name,[None] const char* Type,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshFromXResource", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadMeshFromXResource_(IntPtr module, [MarshalAs(UnmanagedType.LPStr),In] string name, [MarshalAs(UnmanagedType.LPStr),In] string type, int options, IntPtr pD3DDevice, out IntPtr adjacencyRef, out IntPtr materialsRef, out IntPtr effectInstancesRef, ref int numMaterialsRef, out IntPtr meshRef);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="filenameRef">No documentation.</param>
        /// <param name="pMesh">No documentation.</param>
        /// <param name="adjacencyRef">No documentation.</param>
        /// <param name="materialsRef">No documentation.</param>
        /// <param name="effectInstancesRef">No documentation.</param>
        /// <param name="numMaterials">No documentation.</param>
        /// <param name="format">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXSaveMeshToXA([None] const char* pFilename,[None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXMATERIAL* pMaterials,[None] const D3DXEFFECTINSTANCE* pEffectInstances,[None] int NumMaterials,[None] int Format)</unmanaged>
		public static SlimDX2.Result D3DXSaveMeshToXA(string filenameRef, SlimDX2.Direct3D9.ID3DXMesh pMesh, ref int adjacencyRef, ref SlimDX2.Direct3D9.ExtendedMaterial materialsRef, ref SlimDX2.Direct3D9.EffectInstance effectInstancesRef, int numMaterials, int format) {
            unsafe {
                SlimDX2.Direct3D9.ExtendedMaterial.__Native materialsRef_ = new SlimDX2.Direct3D9.ExtendedMaterial.__Native();
                materialsRef.__MarshalTo(ref materialsRef_);
                SlimDX2.Direct3D9.EffectInstance.__Native effectInstancesRef_ = new SlimDX2.Direct3D9.EffectInstance.__Native();
                effectInstancesRef.__MarshalTo(ref effectInstancesRef_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveMeshToXA_( filenameRef, (pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  adjacencyRef, ref  materialsRef_, ref  effectInstancesRef_,  numMaterials,  format);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveMeshToXA([None] const char* pFilename,[None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXMATERIAL* pMaterials,[None] const D3DXEFFECTINSTANCE* pEffectInstances,[None] int NumMaterials,[None] int Format)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveMeshToXA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveMeshToXA_([MarshalAs(UnmanagedType.LPStr),In] string filenameRef, IntPtr pMesh, ref int adjacencyRef, ref SlimDX2.Direct3D9.ExtendedMaterial.__Native materialsRef, ref SlimDX2.Direct3D9.EffectInstance.__Native effectInstancesRef, int numMaterials, int format);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="filenameRef">No documentation.</param>
        /// <param name="pMesh">No documentation.</param>
        /// <param name="adjacencyRef">No documentation.</param>
        /// <param name="materialsRef">No documentation.</param>
        /// <param name="effectInstancesRef">No documentation.</param>
        /// <param name="numMaterials">No documentation.</param>
        /// <param name="format">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXSaveMeshToXW([None] const wchar_t* pFilename,[None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXMATERIAL* pMaterials,[None] const D3DXEFFECTINSTANCE* pEffectInstances,[None] int NumMaterials,[None] int Format)</unmanaged>
		public static SlimDX2.Result D3DXSaveMeshToXW(string filenameRef, SlimDX2.Direct3D9.ID3DXMesh pMesh, ref int adjacencyRef, ref SlimDX2.Direct3D9.ExtendedMaterial materialsRef, ref SlimDX2.Direct3D9.EffectInstance effectInstancesRef, int numMaterials, int format) {
            unsafe {
                SlimDX2.Direct3D9.ExtendedMaterial.__Native materialsRef_ = new SlimDX2.Direct3D9.ExtendedMaterial.__Native();
                materialsRef.__MarshalTo(ref materialsRef_);
                SlimDX2.Direct3D9.EffectInstance.__Native effectInstancesRef_ = new SlimDX2.Direct3D9.EffectInstance.__Native();
                effectInstancesRef.__MarshalTo(ref effectInstancesRef_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveMeshToXW_( filenameRef, (pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  adjacencyRef, ref  materialsRef_, ref  effectInstancesRef_,  numMaterials,  format);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveMeshToXW([None] const wchar_t* pFilename,[None] LPD3DXMESH pMesh,[None] const int* pAdjacency,[None] const D3DXMATERIAL* pMaterials,[None] const D3DXEFFECTINSTANCE* pEffectInstances,[None] int NumMaterials,[None] int Format)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveMeshToXW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveMeshToXW_([MarshalAs(UnmanagedType.LPWStr),In] string filenameRef, IntPtr pMesh, ref int adjacencyRef, ref SlimDX2.Direct3D9.ExtendedMaterial.__Native materialsRef, ref SlimDX2.Direct3D9.EffectInstance.__Native effectInstancesRef, int numMaterials, int format);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="streamRef">No documentation.</param>
        /// <param name="options">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="materialsRef">No documentation.</param>
        /// <param name="effectInstancesRef">No documentation.</param>
        /// <param name="numMaterialsRef">No documentation.</param>
        /// <param name="pMeshRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXCreatePMeshFromStream([None] void* pStream,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXPMESH* ppPMesh)</unmanaged>
		public static SlimDX2.Result D3DXCreatePMeshFromStream(IntPtr streamRef, int options, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.ShaderBytecode materialsRef, out SlimDX2.Direct3D9.ShaderBytecode effectInstancesRef, ref int numMaterialsRef, out SlimDX2.Direct3D9.ID3DXPMesh pMeshRef) {
            unsafe {
                IntPtr materialsRef_ = IntPtr.Zero;
                IntPtr effectInstancesRef_ = IntPtr.Zero;
                IntPtr pMeshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreatePMeshFromStream_( streamRef,  options, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out materialsRef_, out effectInstancesRef_, ref  numMaterialsRef, out pMeshRef_);
                materialsRef = (materialsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(materialsRef_);
                effectInstancesRef = (effectInstancesRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(effectInstancesRef_);
                pMeshRef = (pMeshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXPMesh(pMeshRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreatePMeshFromStream([None] void* pStream,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXPMESH* ppPMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreatePMeshFromStream", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreatePMeshFromStream_(IntPtr streamRef, int options, IntPtr pD3DDevice, out IntPtr materialsRef, out IntPtr effectInstancesRef, ref int numMaterialsRef, out IntPtr pMeshRef);		
        
        /// <summary>	
        /// Creates an empty skin mesh object using a declarator.	
        /// </summary>	
        /// <remarks>	
        ///  Use {{SetBoneInfluence}} to populate the empty skin mesh object returned by this method. 	
        /// </remarks>	
        /// <param name="numVertices"> Number of vertices for the skin mesh. </param>
        /// <param name="declarationRef"> Array of <see cref="SlimDX2.Direct3D9.VertexElement"/> elements, describing the vertex format for the returned mesh. </param>
        /// <param name="numBones"> Number of bones for the skin mesh. </param>
        /// <param name="skinInfoRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXSkinInfo"/> interface, representing the created skin mesh object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be: E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateSkinInfo([None] int NumVertices,[None] const D3DVERTEXELEMENT9* pDeclaration,[None] int NumBones,[None] LPD3DXSKININFO* ppSkinInfo)</unmanaged>
		public static SlimDX2.Result D3DXCreateSkinInfo(int numVertices, ref SlimDX2.Direct3D9.VertexElement declarationRef, int numBones, out SlimDX2.Direct3D9.ID3DXSkinInfo skinInfoRef) {
            unsafe {
                IntPtr skinInfoRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateSkinInfo_( numVertices, ref  declarationRef,  numBones, out skinInfoRef_);
                skinInfoRef = (skinInfoRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXSkinInfo(skinInfoRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateSkinInfo([None] int NumVertices,[None] const D3DVERTEXELEMENT9* pDeclaration,[None] int NumBones,[None] LPD3DXSKININFO* ppSkinInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSkinInfo", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateSkinInfo_(int numVertices, ref SlimDX2.Direct3D9.VertexElement declarationRef, int numBones, out IntPtr skinInfoRef);		
        
        /// <summary>	
        /// Creates an empty skin mesh object using a flexible vertex format (FVF) code.	
        /// </summary>	
        /// <remarks>	
        ///  Use {{SetBoneInfluence}} to populate the empty skin mesh object returned by this method. 	
        /// </remarks>	
        /// <param name="numVertices"> Number of vertices for the skin mesh. </param>
        /// <param name="fvf"> Combination of <see cref="SlimDX2.Direct3D9.VertexFormat"/> that describes the vertex format for the returned skin mesh. </param>
        /// <param name="numBones"> Number of bones for the skin mesh. </param>
        /// <param name="skinInfoRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXSkinInfo"/> interface, representing the created skin information object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateSkinInfoFVF([None] int NumVertices,[None] int FVF,[None] int NumBones,[None] LPD3DXSKININFO* ppSkinInfo)</unmanaged>
		public static SlimDX2.Result D3DXCreateSkinInfoFVF(int numVertices, int fvf, int numBones, out SlimDX2.Direct3D9.ID3DXSkinInfo skinInfoRef) {
            unsafe {
                IntPtr skinInfoRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateSkinInfoFVF_( numVertices,  fvf,  numBones, out skinInfoRef_);
                skinInfoRef = (skinInfoRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXSkinInfo(skinInfoRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateSkinInfoFVF([None] int NumVertices,[None] int FVF,[None] int NumBones,[None] LPD3DXSKININFO* ppSkinInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSkinInfoFVF", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateSkinInfoFVF_(int numVertices, int fvf, int numBones, out IntPtr skinInfoRef);		
        
        /// <summary>	
        /// Loads a mesh from an <see cref="SlimDX2.Direct3D9.ID3DXFileData"/> object.	
        /// </summary>	
        /// <remarks>	
        ///  For mesh files that do not contain effect instance information, default effect instances will be generated from the material information in the .x file. A default effect instance will have default values that correspond to the members of the <see cref="SlimDX2.Direct3D9.Material"/> structure. The default texture name is also filled in, but is handled differently. The name will be Texture0@Name, which corresponds to an effect variable by the name of "Texture0" with an annotation called "Name." This will contain the string file name for the texture. 	
        /// </remarks>	
        /// <param name="pxofMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXFileData"/> interface, representing the file data object to load. </param>
        /// <param name="options"> Combination of one or more flags from the {{D3DXMESH}} enumeration, specifying creation options for the mesh. </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device object associated with the mesh. </param>
        /// <param name="adjacencyRef"> Pointer to a buffer that contains adjacency data.  The adjacency data contains an array of three DWORDs per face that specify the three neighbors for each face in the mesh. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. </param>
        /// <param name="materialsRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface. When the method returns, this parameter is filled with an array of <see cref="SlimDX2.Direct3D9.ExtendedMaterial"/> structures. </param>
        /// <param name="effectInstancesRef"> Pointer to a buffer containing an array of effect instances, one per attribute group in the returned mesh. An effect instance is a particular instance of state information used to initialize an effect. See <see cref="SlimDX2.Direct3D9.EffectInstance"/>. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. </param>
        /// <param name="numMaterialsRef"> Pointer to the number of <see cref="SlimDX2.Direct3D9.ExtendedMaterial"/> structures in the  ppMaterials array, when the method returns. </param>
        /// <param name="meshRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface, representing the loaded mesh. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXof([None] LPD3DXFILEDATA pxofMesh,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result D3DXLoadMeshFromXof(SlimDX2.Direct3D9.ID3DXFileData pxofMesh, int options, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.ShaderBytecode adjacencyRef, out SlimDX2.Direct3D9.ShaderBytecode materialsRef, out SlimDX2.Direct3D9.ShaderBytecode effectInstancesRef, ref int numMaterialsRef, out SlimDX2.Direct3D9.ID3DXMesh meshRef) {
            unsafe {
                IntPtr adjacencyRef_ = IntPtr.Zero;
                IntPtr materialsRef_ = IntPtr.Zero;
                IntPtr effectInstancesRef_ = IntPtr.Zero;
                IntPtr meshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadMeshFromXof_((pxofMesh == null)?IntPtr.Zero:pxofMesh.NativePointer,  options, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out adjacencyRef_, out materialsRef_, out effectInstancesRef_, ref  numMaterialsRef, out meshRef_);
                adjacencyRef = (adjacencyRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(adjacencyRef_);
                materialsRef = (materialsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(materialsRef_);
                effectInstancesRef = (effectInstancesRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(effectInstancesRef_);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadMeshFromXof([None] LPD3DXFILEDATA pxofMesh,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshFromXof", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadMeshFromXof_(IntPtr pxofMesh, int options, IntPtr pD3DDevice, out IntPtr adjacencyRef, out IntPtr materialsRef, out IntPtr effectInstancesRef, ref int numMaterialsRef, out IntPtr meshRef);		
        
        /// <summary>	
        /// Loads a skin mesh from a DirectX .x file data object.	
        /// </summary>	
        /// <remarks>	
        ///  This method takes a pointer to an internal object in the .x file, enabling you to load the frame hierarchy. For mesh files that do not contain effect instance information, default effect instances will be generated from the material information in the .x file. A default effect instance will have default values that correspond to the members of the <see cref="SlimDX2.Direct3D9.Material"/> structure. The default texture name is also filled in, but is handled differently. The name will be Texture0@Name, which corresponds to an effect variable by the name of "Texture0" with an annotation called "Name." This will contain the string file name for the texture. 	
        /// </remarks>	
        /// <param name="pxofMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXFileData"/> interface, representing the file data object to load. </param>
        /// <param name="options"> Combination of one or more flags, from the {{D3DXMESH}} enumeration, specifying creation options for the mesh. </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device object associated with the mesh. </param>
        /// <param name="adjacencyRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface. When this method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh. </param>
        /// <param name="materialsRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface. When the method returns, this parameter is filled with an array of <see cref="SlimDX2.Direct3D9.ExtendedMaterial"/> structures. </param>
        /// <param name="effectInstancesRef"> Pointer to a buffer containing an array of effect instances, one per attribute group in the returned mesh. An effect instance is a particular instance of state information used to initialize an effect. See <see cref="SlimDX2.Direct3D9.EffectInstance"/>. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. </param>
        /// <param name="matOutRef"> Pointer to the number of <see cref="SlimDX2.Direct3D9.ExtendedMaterial"/> structures in the  ppMaterials array, when the method returns. </param>
        /// <param name="skinInfoRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXSkinInfo"/> interface, which represents the skinning information. 									  </param>
        /// <param name="meshRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface, which represents the loaded mesh. 									  </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY </returns>
        /// <unmanaged>HRESULT D3DXLoadSkinMeshFromXof([None] LPD3DXFILEDATA pxofMesh,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pMatOut,[None] LPD3DXSKININFO* ppSkinInfo,[None] LPD3DXMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result D3DXLoadSkinMeshFromXof(SlimDX2.Direct3D9.ID3DXFileData pxofMesh, int options, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.ShaderBytecode adjacencyRef, out SlimDX2.Direct3D9.ShaderBytecode materialsRef, out SlimDX2.Direct3D9.ShaderBytecode effectInstancesRef, ref int matOutRef, out SlimDX2.Direct3D9.ID3DXSkinInfo skinInfoRef, out SlimDX2.Direct3D9.ID3DXMesh meshRef) {
            unsafe {
                IntPtr adjacencyRef_ = IntPtr.Zero;
                IntPtr materialsRef_ = IntPtr.Zero;
                IntPtr effectInstancesRef_ = IntPtr.Zero;
                IntPtr skinInfoRef_ = IntPtr.Zero;
                IntPtr meshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadSkinMeshFromXof_((pxofMesh == null)?IntPtr.Zero:pxofMesh.NativePointer,  options, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out adjacencyRef_, out materialsRef_, out effectInstancesRef_, ref  matOutRef, out skinInfoRef_, out meshRef_);
                adjacencyRef = (adjacencyRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(adjacencyRef_);
                materialsRef = (materialsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(materialsRef_);
                effectInstancesRef = (effectInstancesRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(effectInstancesRef_);
                skinInfoRef = (skinInfoRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXSkinInfo(skinInfoRef_);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadSkinMeshFromXof([None] LPD3DXFILEDATA pxofMesh,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppAdjacency,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pMatOut,[None] LPD3DXSKININFO* ppSkinInfo,[None] LPD3DXMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSkinMeshFromXof", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadSkinMeshFromXof_(IntPtr pxofMesh, int options, IntPtr pD3DDevice, out IntPtr adjacencyRef, out IntPtr materialsRef, out IntPtr effectInstancesRef, ref int matOutRef, out IntPtr skinInfoRef, out IntPtr meshRef);		
        
        /// <summary>	
        /// Creates a skin mesh from another mesh.	
        /// </summary>	
        /// <param name="pMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXBaseMesh"/> object, the mesh from which to create the skin mesh. </param>
        /// <param name="numBones"> The length of the array attached to the BoneId. See <see cref="SlimDX2.Direct3D9.BoneCombination"/>. </param>
        /// <param name="boneCombinationTableRef"> Pointer to an array of bone combinations. See <see cref="SlimDX2.Direct3D9.BoneCombination"/>. </param>
        /// <param name="skinInfoRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXSkinInfo"/> interface representing the created skin mesh object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateSkinInfoFromBlendedMesh([None] LPD3DXBASEMESH pMesh,[None] int NumBones,[None] const D3DXBONECOMBINATION* pBoneCombinationTable,[None] LPD3DXSKININFO* ppSkinInfo)</unmanaged>
		public static SlimDX2.Result D3DXCreateSkinInfoFromBlendedMesh(SlimDX2.Direct3D9.ID3DXBaseMesh pMesh, int numBones, ref SlimDX2.Direct3D9.BoneCombination boneCombinationTableRef, out SlimDX2.Direct3D9.ID3DXSkinInfo skinInfoRef) {
            unsafe {
                IntPtr skinInfoRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateSkinInfoFromBlendedMesh_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  numBones, ref  boneCombinationTableRef, out skinInfoRef_);
                skinInfoRef = (skinInfoRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXSkinInfo(skinInfoRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateSkinInfoFromBlendedMesh([None] LPD3DXBASEMESH pMesh,[None] int NumBones,[None] const D3DXBONECOMBINATION* pBoneCombinationTable,[None] LPD3DXSKININFO* ppSkinInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSkinInfoFromBlendedMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateSkinInfoFromBlendedMesh_(IntPtr pMesh, int numBones, ref SlimDX2.Direct3D9.BoneCombination boneCombinationTableRef, out IntPtr skinInfoRef);		
        
        /// <summary>	
        /// Tessellates the given mesh using the N-patch tessellation scheme.	
        /// </summary>	
        /// <remarks>	
        ///  This function tessellates by using the N-patch algorithm. 	
        /// </remarks>	
        /// <param name="pMeshIn"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface, representing the mesh to tessellate. </param>
        /// <param name="adjacencyInRef"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the source mesh. This parameter may be NULL. </param>
        /// <param name="numSegs"> Number of segments per edge to tessellate. </param>
        /// <param name="quadraticInterpNormals"> Set to TRUE to use quadratic interpolation for normals; set to FALSE for linear interpolation. </param>
        /// <param name="meshOutRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface, representing the returned tessellated mesh. </param>
        /// <param name="adjacencyOutRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface. If the value of this parameter is not set to NULL&gt;, this buffer will contain an array of three DWORDs per face that specify the three neighbors for each face in the output mesh. This parameter may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXTessellateNPatches([None] LPD3DXMESH pMeshIn,[None] const int* pAdjacencyIn,[None] float NumSegs,[None] BOOL QuadraticInterpNormals,[None] LPD3DXMESH* ppMeshOut,[None] LPD3DXBUFFER* ppAdjacencyOut)</unmanaged>
		public static SlimDX2.Result D3DXTessellateNPatches(SlimDX2.Direct3D9.ID3DXMesh pMeshIn, ref int adjacencyInRef, float numSegs, bool quadraticInterpNormals, out SlimDX2.Direct3D9.ID3DXMesh meshOutRef, out SlimDX2.Direct3D9.ShaderBytecode adjacencyOutRef) {
            unsafe {
                IntPtr meshOutRef_ = IntPtr.Zero;
                IntPtr adjacencyOutRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXTessellateNPatches_((pMeshIn == null)?IntPtr.Zero:pMeshIn.NativePointer, ref  adjacencyInRef,  numSegs,  quadraticInterpNormals, out meshOutRef_, out adjacencyOutRef_);
                meshOutRef = (meshOutRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshOutRef_);
                adjacencyOutRef = (adjacencyOutRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(adjacencyOutRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXTessellateNPatches([None] LPD3DXMESH pMeshIn,[None] const int* pAdjacencyIn,[None] float NumSegs,[None] BOOL QuadraticInterpNormals,[None] LPD3DXMESH* ppMeshOut,[None] LPD3DXBUFFER* ppAdjacencyOut)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXTessellateNPatches", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXTessellateNPatches_(IntPtr pMeshIn, ref int adjacencyInRef, float numSegs, bool quadraticInterpNormals, out IntPtr meshOutRef, out IntPtr adjacencyOutRef);		
        
        /// <summary>	
        /// Generates an output vertex declaration from the input declaration. The output declaration is intended for use by the mesh tessellation functions.	
        /// </summary>	
        /// <param name="outputRef"> Pointer to the output vertex declaration. See <see cref="SlimDX2.Direct3D9.VertexElement"/>. </param>
        /// <param name="inputRef"> Pointer to the input vertex declaration. See <see cref="SlimDX2.Direct3D9.VertexElement"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXGenerateOutputDecl([None] D3DVERTEXELEMENT9* pOutput,[None] const D3DVERTEXELEMENT9* pInput)</unmanaged>
		public static SlimDX2.Result D3DXGenerateOutputDecl(ref SlimDX2.Direct3D9.VertexElement outputRef, ref SlimDX2.Direct3D9.VertexElement inputRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGenerateOutputDecl_(ref  outputRef, ref  inputRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGenerateOutputDecl([None] D3DVERTEXELEMENT9* pOutput,[None] const D3DVERTEXELEMENT9* pInput)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGenerateOutputDecl", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGenerateOutputDecl_(ref SlimDX2.Direct3D9.VertexElement outputRef, ref SlimDX2.Direct3D9.VertexElement inputRef);		
        
        /// <summary>	
        /// Loads a patch mesh from an <see cref="SlimDX2.Direct3D9.ID3DXFileData"/> object.	
        /// </summary>	
        /// <remarks>	
        ///  For mesh files that do not contain effect instance information, default effect instances will be generated from the material information in the .x file. A default effect instance will have default values that correspond to the members of the <see cref="SlimDX2.Direct3D9.Material"/> structure. The default texture name is also filled in, but is handled differently. The name will be Texture0@Name, which corresponds to an effect variable by the name of "Texture0" with an annotation called "Name." This will contain the string file name for the texture. 	
        /// </remarks>	
        /// <param name="pXofObjMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXFileData"/> interface, representing the file data object to load. </param>
        /// <param name="options"> Combination of one or more {{D3DXMESH}} flags, specifying creation options for the mesh. </param>
        /// <param name="pD3DDevice"> Pointer to the device that the mesh is created from. </param>
        /// <param name="materialsRef"> Array of materials contained in the mesh. Each material is indexed by an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface. </param>
        /// <param name="effectInstancesRef"> Pointer to a buffer containing an array of effect instances, one per attribute group in the returned mesh. An effect instance is a particular instance of state information used to initialize an effect. See <see cref="SlimDX2.Direct3D9.EffectInstance"/>. For more information about accessing the buffer, see <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. </param>
        /// <param name="numMaterialsRef"> Pointer that contains the number of materials in the mesh. </param>
        /// <param name="meshRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXPatchMesh"/> interface, representing the loaded mesh. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXLoadPatchMeshFromXof([None] LPD3DXFILEDATA pXofObjMesh,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXPATCHMESH* ppMesh)</unmanaged>
		public static SlimDX2.Result D3DXLoadPatchMeshFromXof(SlimDX2.Direct3D9.ID3DXFileData pXofObjMesh, int options, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.ShaderBytecode materialsRef, out SlimDX2.Direct3D9.ShaderBytecode effectInstancesRef, ref int numMaterialsRef, out SlimDX2.Direct3D9.ID3DXPatchMesh meshRef) {
            unsafe {
                IntPtr materialsRef_ = IntPtr.Zero;
                IntPtr effectInstancesRef_ = IntPtr.Zero;
                IntPtr meshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadPatchMeshFromXof_((pXofObjMesh == null)?IntPtr.Zero:pXofObjMesh.NativePointer,  options, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out materialsRef_, out effectInstancesRef_, ref  numMaterialsRef, out meshRef_);
                materialsRef = (materialsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(materialsRef_);
                effectInstancesRef = (effectInstancesRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(effectInstancesRef_);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXPatchMesh(meshRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadPatchMeshFromXof([None] LPD3DXFILEDATA pXofObjMesh,[None] int Options,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXBUFFER* ppMaterials,[None] LPD3DXBUFFER* ppEffectInstances,[None] int* pNumMaterials,[None] LPD3DXPATCHMESH* ppMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadPatchMeshFromXof", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadPatchMeshFromXof_(IntPtr pXofObjMesh, int options, IntPtr pD3DDevice, out IntPtr materialsRef, out IntPtr effectInstancesRef, ref int numMaterialsRef, out IntPtr meshRef);		
        
        /// <summary>	
        /// Gets the size of the rectangle patch.	
        /// </summary>	
        /// <param name="fNumSegsRef"> Number of segments per edge to tessellate. </param>
        /// <param name="dwTrianglesRef"> Pointer to a DWORD that contains the number of triangles in the patch. </param>
        /// <param name="dwVerticesRef"> Pointer to a DWORD that contains the number of vertices in the patch. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXRectPatchSize([None] const float* pfNumSegs,[None] int* pdwTriangles,[None] int* pdwVertices)</unmanaged>
		public static SlimDX2.Result D3DXRectPatchSize(ref float fNumSegsRef, ref int dwTrianglesRef, ref int dwVerticesRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXRectPatchSize_(ref  fNumSegsRef, ref  dwTrianglesRef, ref  dwVerticesRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXRectPatchSize([None] const float* pfNumSegs,[None] int* pdwTriangles,[None] int* pdwVertices)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXRectPatchSize", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXRectPatchSize_(ref float fNumSegsRef, ref int dwTrianglesRef, ref int dwVerticesRef);		
        
        /// <summary>	
        /// Gets the size of the triangle patch.	
        /// </summary>	
        /// <param name="fNumSegsRef"> Number of segments per edge to tessellate. </param>
        /// <param name="dwTrianglesRef"> Pointer to a DWORD that contains the number of triangles in the patch. </param>
        /// <param name="dwVerticesRef"> Pointer to a DWORD that contains the number of vertices in the triangle patch. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXTriPatchSize([None] const float* pfNumSegs,[None] int* pdwTriangles,[None] int* pdwVertices)</unmanaged>
		public static SlimDX2.Result D3DXTriPatchSize(ref float fNumSegsRef, ref int dwTrianglesRef, ref int dwVerticesRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXTriPatchSize_(ref  fNumSegsRef, ref  dwTrianglesRef, ref  dwVerticesRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXTriPatchSize([None] const float* pfNumSegs,[None] int* pdwTriangles,[None] int* pdwVertices)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXTriPatchSize", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXTriPatchSize_(ref float fNumSegsRef, ref int dwTrianglesRef, ref int dwVerticesRef);		
        
        /// <summary>	
        /// Tessellates a rectangular higher-order surface patch into a triangle mesh.	
        /// </summary>	
        /// <remarks>	
        ///  Use <see cref="SlimDX2.Direct3D9.D3DX9.D3DXRectPatchSize"/> to get the number of output vertices and indices that the tessellation function needs. 	
        /// </remarks>	
        /// <param name="pVB"> Vertex buffer containing the patch data. </param>
        /// <param name="numSegsRef"> Pointer to an array of four floating-point values that identify the number of segments into which each edge of the rectangle patch should be divided when tessellated. See <see cref="SlimDX2.Direct3D9.RectanglePatchInfo"/>. </param>
        /// <param name="dwInDeclRef"> Vertex declaration structure that defines the vertex data. See <see cref="SlimDX2.Direct3D9.VertexElement"/>. </param>
        /// <param name="rectPatchInfoRef"> Describes a rectangular patch. See <see cref="SlimDX2.Direct3D9.RectanglePatchInfo"/>. </param>
        /// <param name="pMesh"> Pointer to the created mesh. See <see cref="SlimDX2.Direct3D9.ID3DXMesh"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXTessellateRectPatch([None] LPDIRECT3DVERTEXBUFFER9 pVB,[None] const float* pNumSegs,[None] const D3DVERTEXELEMENT9* pdwInDecl,[None] const D3DRECTPATCH_INFO* pRectPatchInfo,[None] LPD3DXMESH pMesh)</unmanaged>
		public static SlimDX2.Result D3DXTessellateRectPatch(SlimDX2.Direct3D9.VertexBuffer pVB, ref float numSegsRef, ref SlimDX2.Direct3D9.VertexElement dwInDeclRef, ref SlimDX2.Direct3D9.RectanglePatchInfo rectPatchInfoRef, SlimDX2.Direct3D9.ID3DXMesh pMesh) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXTessellateRectPatch_((pVB == null)?IntPtr.Zero:pVB.NativePointer, ref  numSegsRef, ref  dwInDeclRef, ref  rectPatchInfoRef, (pMesh == null)?IntPtr.Zero:pMesh.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXTessellateRectPatch([None] LPDIRECT3DVERTEXBUFFER9 pVB,[None] const float* pNumSegs,[None] const D3DVERTEXELEMENT9* pdwInDecl,[None] const D3DRECTPATCH_INFO* pRectPatchInfo,[None] LPD3DXMESH pMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXTessellateRectPatch", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXTessellateRectPatch_(IntPtr pVB, ref float numSegsRef, ref SlimDX2.Direct3D9.VertexElement dwInDeclRef, ref SlimDX2.Direct3D9.RectanglePatchInfo rectPatchInfoRef, IntPtr pMesh);		
        
        /// <summary>	
        /// Tessellates a triangular higher-order surface patch into a triangle mesh.	
        /// </summary>	
        /// <remarks>	
        ///  Use <see cref="SlimDX2.Direct3D9.D3DX9.D3DXTriPatchSize"/> to get the number of output vertices and indices that the tessellation function needs. 	
        /// </remarks>	
        /// <param name="pVB"> Vertex buffer containing the patch data. </param>
        /// <param name="numSegsRef"> Pointer to an array of three floating-point values that identify the number of segments into which each edge of the triangle patch should be divided when tessellated. See <see cref="SlimDX2.Direct3D9.TrianglePatchInfo"/>. </param>
        /// <param name="inDeclRef"> Vertex declaration structure that defines the vertex data. See <see cref="SlimDX2.Direct3D9.VertexElement"/>. </param>
        /// <param name="triPatchInfoRef"> Describes a triangle patch. See <see cref="SlimDX2.Direct3D9.TrianglePatchInfo"/>. </param>
        /// <param name="pMesh"> Pointer to the created mesh. See <see cref="SlimDX2.Direct3D9.ID3DXMesh"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXTessellateTriPatch([None] LPDIRECT3DVERTEXBUFFER9 pVB,[None] const float* pNumSegs,[None] const D3DVERTEXELEMENT9* pInDecl,[None] const D3DTRIPATCH_INFO* pTriPatchInfo,[None] LPD3DXMESH pMesh)</unmanaged>
		public static SlimDX2.Result D3DXTessellateTriPatch(SlimDX2.Direct3D9.VertexBuffer pVB, ref float numSegsRef, ref SlimDX2.Direct3D9.VertexElement inDeclRef, ref SlimDX2.Direct3D9.TrianglePatchInfo triPatchInfoRef, SlimDX2.Direct3D9.ID3DXMesh pMesh) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXTessellateTriPatch_((pVB == null)?IntPtr.Zero:pVB.NativePointer, ref  numSegsRef, ref  inDeclRef, ref  triPatchInfoRef, (pMesh == null)?IntPtr.Zero:pMesh.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXTessellateTriPatch([None] LPDIRECT3DVERTEXBUFFER9 pVB,[None] const float* pNumSegs,[None] const D3DVERTEXELEMENT9* pInDecl,[None] const D3DTRIPATCH_INFO* pTriPatchInfo,[None] LPD3DXMESH pMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXTessellateTriPatch", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXTessellateTriPatch_(IntPtr pVB, ref float numSegsRef, ref SlimDX2.Direct3D9.VertexElement inDeclRef, ref SlimDX2.Direct3D9.TrianglePatchInfo triPatchInfoRef, IntPtr pMesh);		
        
        /// <summary>	
        /// Creates an N-patch mesh from a triangle mesh.	
        /// </summary>	
        /// <param name="pMeshSysMem"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface that represents the triangle mesh object. </param>
        /// <param name="atchMeshRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXPatchMesh"/> interface that represents the created patch mesh object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateNPatchMesh([None] LPD3DXMESH pMeshSysMem,[None] LPD3DXPATCHMESH* pPatchMesh)</unmanaged>
		public static SlimDX2.Result D3DXCreateNPatchMesh(SlimDX2.Direct3D9.ID3DXMesh pMeshSysMem, out SlimDX2.Direct3D9.ID3DXPatchMesh atchMeshRef) {
            unsafe {
                IntPtr atchMeshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateNPatchMesh_((pMeshSysMem == null)?IntPtr.Zero:pMeshSysMem.NativePointer, out atchMeshRef_);
                atchMeshRef = (atchMeshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXPatchMesh(atchMeshRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateNPatchMesh([None] LPD3DXMESH pMeshSysMem,[None] LPD3DXPATCHMESH* pPatchMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateNPatchMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateNPatchMesh_(IntPtr pMeshSysMem, out IntPtr atchMeshRef);		
        
        /// <summary>	
        /// Creates a mesh from a control-patch mesh.	
        /// </summary>	
        /// <remarks>	
        ///  This method takes an input patch mesh and converts it to a tessellated mesh. Patch meshes use 16-bit index buffers. Therefore, indices to {{LockIndexBuffer}} are 16 bits. 	
        /// </remarks>	
        /// <param name="infoRef"> Patch information structure. For more information, see <see cref="SlimDX2.Direct3D9.PatchInfo"/>. </param>
        /// <param name="dwNumPatches"> Number of patches. </param>
        /// <param name="dwNumVertices"> Number of control vertices in the patch. </param>
        /// <param name="dwOptions"> Unused. Reserved for later use. </param>
        /// <param name="declRef"> Array of <see cref="SlimDX2.Direct3D9.VertexElement"/> elements, describing the vertex format for the returned mesh. </param>
        /// <param name="pD3DDevice"> Pointer the device that creates the patch mesh. See <see cref="SlimDX2.Direct3D9.Device"/>. </param>
        /// <param name="atchMeshRef"> Pointer to the <see cref="SlimDX2.Direct3D9.ID3DXPatchMesh"/> object that is created. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreatePatchMesh([None] const D3DXPATCHINFO* pInfo,[None] int dwNumPatches,[None] int dwNumVertices,[None] int dwOptions,[None] const D3DVERTEXELEMENT9* pDecl,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXPATCHMESH* pPatchMesh)</unmanaged>
		public static SlimDX2.Result D3DXCreatePatchMesh(ref SlimDX2.Direct3D9.PatchInfo infoRef, int dwNumPatches, int dwNumVertices, int dwOptions, ref SlimDX2.Direct3D9.VertexElement declRef, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.ID3DXPatchMesh atchMeshRef) {
            unsafe {
                IntPtr atchMeshRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreatePatchMesh_(ref  infoRef,  dwNumPatches,  dwNumVertices,  dwOptions, ref  declRef, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out atchMeshRef_);
                atchMeshRef = (atchMeshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXPatchMesh(atchMeshRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreatePatchMesh([None] const D3DXPATCHINFO* pInfo,[None] int dwNumPatches,[None] int dwNumVertices,[None] int dwOptions,[None] const D3DVERTEXELEMENT9* pDecl,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXPATCHMESH* pPatchMesh)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreatePatchMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreatePatchMesh_(ref SlimDX2.Direct3D9.PatchInfo infoRef, int dwNumPatches, int dwNumVertices, int dwOptions, ref SlimDX2.Direct3D9.VertexElement declRef, IntPtr pD3DDevice, out IntPtr atchMeshRef);		
        
        /// <summary>	
        /// Validates a patch mesh, returning the number of degenerate vertices and patches.	
        /// </summary>	
        /// <remarks>	
        ///  This method validates the mesh by checking for invalid indices. Error information is available from the debugger output. 	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXPatchMesh"/> interface, representing the patch mesh to be tested. </param>
        /// <param name="dwcDegenerateVertices"> Returns the number of degenerate vertices in the patch mesh. </param>
        /// <param name="dwcDegeneratePatches"> Returns the number of degenerate patches in the patch mesh. </param>
        /// <param name="errorsAndWarningsRef"> Returns a pointer to a buffer containing a string of errors and warnings that explain the problems found in the patch mesh. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXValidPatchMesh([None] LPD3DXPATCHMESH pMesh,[None] int* dwcDegenerateVertices,[None] int* dwcDegeneratePatches,[None] LPD3DXBUFFER* ppErrorsAndWarnings)</unmanaged>
		public static SlimDX2.Result D3DXValidPatchMesh(SlimDX2.Direct3D9.ID3DXPatchMesh pMesh, ref int dwcDegenerateVertices, ref int dwcDegeneratePatches, out SlimDX2.Direct3D9.ShaderBytecode errorsAndWarningsRef) {
            unsafe {
                IntPtr errorsAndWarningsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXValidPatchMesh_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  dwcDegenerateVertices, ref  dwcDegeneratePatches, out errorsAndWarningsRef_);
                errorsAndWarningsRef = (errorsAndWarningsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorsAndWarningsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXValidPatchMesh([None] LPD3DXPATCHMESH pMesh,[None] int* dwcDegenerateVertices,[None] int* dwcDegeneratePatches,[None] LPD3DXBUFFER* ppErrorsAndWarnings)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXValidPatchMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXValidPatchMesh_(IntPtr pMesh, ref int dwcDegenerateVertices, ref int dwcDegeneratePatches, out IntPtr errorsAndWarningsRef);		
        
        /// <summary>	
        /// Returns a declarator from a flexible vertex format (FVF) code.	
        /// </summary>	
        /// <param name="fvf"> Combination of <see cref="SlimDX2.Direct3D9.VertexFormat"/> that describes the FVF from which to generate the returned declarator array. </param>
        /// <param name="pDeclarator"> An array of <see cref="SlimDX2.Direct3D9.VertexElement"/> elements describing the vertex format of the mesh vertices. The upper limit of this declarator array is {{MAX_FVF_DECL_SIZE}}. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DXERR_INVALIDMESH. </returns>
        /// <unmanaged>HRESULT D3DXDeclaratorFromFVF([None] int FVF,[None] D3DVERTEXELEMENT9 pDeclarator[65])</unmanaged>
		public static SlimDX2.Result D3DXDeclaratorFromFVF(int fvf, SlimDX2.Direct3D9.VertexElement[] pDeclarator) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXDeclaratorFromFVF_( fvf,  pDeclarator);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXDeclaratorFromFVF([None] int FVF,[None] D3DVERTEXELEMENT9 pDeclarator[65])</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXDeclaratorFromFVF", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXDeclaratorFromFVF_(int fvf, SlimDX2.Direct3D9.VertexElement[] pDeclarator);		
        
        /// <summary>	
        /// Returns a flexible vertex format (FVF) code from a declarator.	
        /// </summary>	
        /// <remarks>	
        ///  This function will fail for any declarator that does not map directly to an FVF. 	
        /// </remarks>	
        /// <param name="declaratorRef"> Array of <see cref="SlimDX2.Direct3D9.VertexElement"/> elements, describing the FVF code. </param>
        /// <param name="fVFRef"> Pointer to a  DWORD value, representing the returned combination of <see cref="SlimDX2.Direct3D9.VertexFormat"/> that describes the vertex format returned from the declarator. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXFVFFromDeclarator([None] const D3DVERTEXELEMENT9* pDeclarator,[None] int* pFVF)</unmanaged>
		public static SlimDX2.Result D3DXFVFFromDeclarator(ref SlimDX2.Direct3D9.VertexElement declaratorRef, ref int fVFRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFVFFromDeclarator_(ref  declaratorRef, ref  fVFRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFVFFromDeclarator([None] const D3DVERTEXELEMENT9* pDeclarator,[None] int* pFVF)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFVFFromDeclarator", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFVFFromDeclarator_(ref SlimDX2.Direct3D9.VertexElement declaratorRef, ref int fVFRef);		
        
        /// <summary>	
        /// Welds together replicated vertices that have equal attributes. This method uses specified epsilon values for equality comparisons.	
        /// </summary>	
        /// <remarks>	
        ///  This function uses supplied adjacency information to determine the points that are replicated. Vertices are merged based on an epsilon comparison. Vertices with equal position must already have been calculated and represented by point-representative data. This function combines logically-welded vertices that have similar components, such as normals or texture coordinates within pEpsilons. The following example code calls this function with welding enabled. Vertices are compared using epsilon values for normal vector and vertex position. A pointer is returned to a face remapping array (pFaceRemap). 	
        /// <code> TCHAR            strMediaPath[512];       // X-file path 	
        /// LPD3DXBUFFER     pAdjacencyBuffer = NULL; // adjacency data buffer	
        /// LPD3DXBUFFER     pD3DXMtrlBuffer  = NULL; // material buffer	
        /// LPD3DXMESH       pMesh            = NULL; // mesh object	
        /// DWORD            m_dwNumMaterials;        // number of materials	
        /// D3DXWELDEPSILONS Epsilons;                // structure with epsilon values	
        /// DWORD            *pFaceRemap[65536];      // face remapping array	
        /// DWORD            i;                       // internal variable // Load the mesh from the specified file hr = D3DXLoadMeshFromX ( strMediaPath, D3DXMESH_MANAGED, m_pd3dDevice, &amp;pAdjacencyBuffer, &amp;pD3DXMtrlBuffer, NULL, &amp;m_dwNumMaterials, &amp;pMesh ) ) if( FAILED( hr ) )  goto End;              // Go to error handling // Set epsilon values Epsilons.Normal = 0.001; Epsilons.Position = 0.1; // Weld the vertices for( i=0; i &lt; 65536; i++ ) {  pFaceRemap[i] = 0;  } hr = D3DXWeldVertices ( pMesh, D3DXWELDEPSILONS_WELDPARTIALMATCHES, &amp;Epsilons, (DWORD*)pAdjacencyBuffer-&gt;GetBufferPointer(), (DWORD*)pAdjacencyBuffer-&gt;GetBufferPointer(), (DWORD*)pFaceRemap, NULL ) if( FAILED( hr ) )  goto End;              // Go to error handling </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> object, the mesh from which to weld vertices. </param>
        /// <param name="flags"> Combination of one or more flags from {{D3DXWELDEPSILONSFLAGS}}. </param>
        /// <param name="epsilonsRef"> Pointer to a {{D3DXWeldEpsilons}} structure, specifying the epsilon values to be used for this method. Use NULL to initialize all structure members to a default value of 1.0e-6f. </param>
        /// <param name="adjacencyInRef"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the source mesh. If the edge has no adjacent faces, the value is 0xffffffff. If this parameter is set to NULL, <see cref="SlimDX2.Direct3D9.ID3DXBaseMesh.GenerateAdjacency"/> will be called to create logical adjacency information. </param>
        /// <param name="adjacencyOutRef"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the optimized mesh. If the edge has no adjacent faces, the value is 0xffffffff. </param>
        /// <param name="faceRemapRef"> An array of DWORDs, one per face, that identifies the original mesh face that corresponds to each face in the welded mesh. </param>
        /// <param name="vertexRemapRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface, which contains a DWORD for each vertex that specifies how the new vertices map to the old vertices. This remap is useful if you need to alter external data based on the new vertex mapping. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXWeldVertices([None] LPD3DXMESH pMesh,[None] int Flags,[None] const D3DXWELDEPSILONS* pEpsilons,[None] const int* pAdjacencyIn,[None] int* pAdjacencyOut,[None] int* pFaceRemap,[None] LPD3DXBUFFER* ppVertexRemap)</unmanaged>
		public static SlimDX2.Result D3DXWeldVertices(SlimDX2.Direct3D9.ID3DXMesh pMesh, int flags, ref SlimDX2.Direct3D9.WeldEpsilons epsilonsRef, ref int adjacencyInRef, ref int adjacencyOutRef, ref int faceRemapRef, out SlimDX2.Direct3D9.ShaderBytecode vertexRemapRef) {
            unsafe {
                SlimDX2.Direct3D9.WeldEpsilons.__Native epsilonsRef_ = new SlimDX2.Direct3D9.WeldEpsilons.__Native();
                epsilonsRef.__MarshalTo(ref epsilonsRef_);
                IntPtr vertexRemapRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXWeldVertices_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  flags, ref  epsilonsRef_, ref  adjacencyInRef, ref  adjacencyOutRef, ref  faceRemapRef, out vertexRemapRef_);
                vertexRemapRef = (vertexRemapRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(vertexRemapRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXWeldVertices([None] LPD3DXMESH pMesh,[None] int Flags,[None] const D3DXWELDEPSILONS* pEpsilons,[None] const int* pAdjacencyIn,[None] int* pAdjacencyOut,[None] int* pFaceRemap,[None] LPD3DXBUFFER* ppVertexRemap)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXWeldVertices", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXWeldVertices_(IntPtr pMesh, int flags, ref SlimDX2.Direct3D9.WeldEpsilons.__Native epsilonsRef, ref int adjacencyInRef, ref int adjacencyOutRef, ref int faceRemapRef, out IntPtr vertexRemapRef);		
        
        /// <summary>	
        /// Determines if a ray intersects with a mesh.	
        /// </summary>	
        /// <remarks>	
        ///  The D3DXIntersect function provides a way to understand points in and around a triangle, independent of where the triangle is actually located. This function returns the resulting point by using the following equation: V1 + U(V2 - V1) + V(V3 - V1). Any point in the plane V1V2V3 can be represented by the barycentric coordinate (U,V). The parameter U controls how much V2 gets weighted into the result, and the parameter V controls how much V3 gets weighted into the result. Lastly, the value of [1 - (U + V)] controls how much V1 gets weighted into the result. Barycentric coordinates are a form of general coordinates. In this context, using barycentric coordinates represents a change in coordinate systems. What holds true for Cartesian coordinates holds true for barycentric coordinates. Barycentric coordinates define a point inside a triangle in terms of the triangle's vertices.  For a more in-depth description of barycentric coordinates, see {{Mathworld's Barycentric Coordinates Description}}. 	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXBaseMesh"/> interface, representing the mesh to be tested. </param>
        /// <param name="rayPosRef"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the point where the ray begins. </param>
        /// <param name="rayDirRef"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the direction of the ray. </param>
        /// <param name="hitRef"> Pointer to a  BOOL. If the ray intersects a triangular face on the mesh, this value will be set to TRUE. Otherwise, this value is set to FALSE. </param>
        /// <param name="faceIndexRef"> Pointer to an index value of the face closest to the ray origin, if pHit is TRUE. </param>
        /// <param name="uRef"> Pointer to a barycentric hit coordinate, U. </param>
        /// <param name="vRef"> Pointer to a barycentric hit coordinate, V. </param>
        /// <param name="distRef"> Pointer to a ray intersection parameter distance. </param>
        /// <param name="allHitsRef"> Pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> object, containing an array of {{D3DXINTERSECTINFO}} structures. </param>
        /// <param name="countOfHitsRef"> Pointer to a DWORD that contains the number of entries in the ppAllHits array. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be: E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXIntersect([None] LPD3DXBASEMESH pMesh,[None] const D3DXVECTOR3* pRayPos,[None] const D3DXVECTOR3* pRayDir,[None] BOOL* pHit,[None] int* pFaceIndex,[None] float* pU,[None] float* pV,[None] float* pDist,[None] LPD3DXBUFFER* ppAllHits,[None] int* pCountOfHits)</unmanaged>
		public static SlimDX2.Result D3DXIntersect(SlimDX2.Direct3D9.ID3DXBaseMesh pMesh, ref SlimMath.Vector3 rayPosRef, ref SlimMath.Vector3 rayDirRef, ref bool hitRef, ref int faceIndexRef, ref float uRef, ref float vRef, ref float distRef, out SlimDX2.Direct3D9.ShaderBytecode allHitsRef, ref int countOfHitsRef) {
            unsafe {
                IntPtr allHitsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXIntersect_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  rayPosRef, ref  rayDirRef, ref  hitRef, ref  faceIndexRef, ref  uRef, ref  vRef, ref  distRef, out allHitsRef_, ref  countOfHitsRef);
                allHitsRef = (allHitsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(allHitsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXIntersect([None] LPD3DXBASEMESH pMesh,[None] const D3DXVECTOR3* pRayPos,[None] const D3DXVECTOR3* pRayDir,[None] BOOL* pHit,[None] int* pFaceIndex,[None] float* pU,[None] float* pV,[None] float* pDist,[None] LPD3DXBUFFER* ppAllHits,[None] int* pCountOfHits)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXIntersect", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXIntersect_(IntPtr pMesh, ref SlimMath.Vector3 rayPosRef, ref SlimMath.Vector3 rayDirRef, ref bool hitRef, ref int faceIndexRef, ref float uRef, ref float vRef, ref float distRef, out IntPtr allHitsRef, ref int countOfHitsRef);		
        
        /// <summary>	
        /// Intersects the specified ray with the given mesh subset. This provides similar functionality to <see cref="SlimDX2.Direct3D9.D3DX9.D3DXIntersect"/>.	
        /// </summary>	
        /// <remarks>	
        ///  The D3DXIntersectSubset function provides a way to understand points in and around a triangle, independent of where the triangle is actually located. This function returns the resulting point by using the following equation: V1 + U(V2 - V1) + V(V3 - V1). Any point in the plane V1V2V3 can be represented by the barycentric coordinate (U,V). The parameter U controls how much V2 gets weighted into the result and the parameter V controls how much V3 gets weighted into the result. Lastly, the value of [1 - (U + V)] controls how much V1 gets weighted into the result. Barycentric coordinates are a form of general coordinates. In this context, using barycentric coordinates represents a change in coordinate systems. What holds true for Cartesian coordinates holds true for barycentric coordinates. Barycentric coordinates define a point inside a triangle in terms of the triangle's vertices.  For a more in-depth description of barycentric coordinates, see {{Mathworld's Barycentric Coordinates Description}}. 	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXBaseMesh"/> interface, representing the mesh to be tested. The mesh must be attribute sorted. </param>
        /// <param name="attribId"> Attribute identifier of the subset to intersect with. </param>
        /// <param name="rayPosRef"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the point where the ray begins. </param>
        /// <param name="rayDirRef"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the direction of the ray. </param>
        /// <param name="hitRef"> Pointer to a BOOL. If the ray intersects a triangular face on the mesh, this value will be set to TRUE. Otherwise, this value is set to FALSE. </param>
        /// <param name="faceIndexRef"> Pointer to an index value of the face closest to the ray origin, if pHit is TRUE. </param>
        /// <param name="uRef"> Pointer to a barycentric hit coordinate, U. </param>
        /// <param name="vRef"> Pointer to a barycentric hit coordinate, V. </param>
        /// <param name="distRef"> Pointer to a ray intersection parameter distance. </param>
        /// <param name="allHitsRef"> Array of {{D3DXINTERSECTINFO}} structures, representing all hits, not just closest hits. </param>
        /// <param name="countOfHitsRef"> Number of elements in the array returned from ppAllHits. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following value: E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXIntersectSubset([None] LPD3DXBASEMESH pMesh,[None] int AttribId,[None] const D3DXVECTOR3* pRayPos,[None] const D3DXVECTOR3* pRayDir,[None] BOOL* pHit,[None] int* pFaceIndex,[None] float* pU,[None] float* pV,[None] float* pDist,[None] LPD3DXBUFFER* ppAllHits,[None] int* pCountOfHits)</unmanaged>
		public static SlimDX2.Result D3DXIntersectSubset(SlimDX2.Direct3D9.ID3DXBaseMesh pMesh, int attribId, ref SlimMath.Vector3 rayPosRef, ref SlimMath.Vector3 rayDirRef, ref bool hitRef, ref int faceIndexRef, ref float uRef, ref float vRef, ref float distRef, out SlimDX2.Direct3D9.ShaderBytecode allHitsRef, ref int countOfHitsRef) {
            unsafe {
                IntPtr allHitsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXIntersectSubset_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  attribId, ref  rayPosRef, ref  rayDirRef, ref  hitRef, ref  faceIndexRef, ref  uRef, ref  vRef, ref  distRef, out allHitsRef_, ref  countOfHitsRef);
                allHitsRef = (allHitsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(allHitsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXIntersectSubset([None] LPD3DXBASEMESH pMesh,[None] int AttribId,[None] const D3DXVECTOR3* pRayPos,[None] const D3DXVECTOR3* pRayDir,[None] BOOL* pHit,[None] int* pFaceIndex,[None] float* pU,[None] float* pV,[None] float* pDist,[None] LPD3DXBUFFER* ppAllHits,[None] int* pCountOfHits)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXIntersectSubset", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXIntersectSubset_(IntPtr pMesh, int attribId, ref SlimMath.Vector3 rayPosRef, ref SlimMath.Vector3 rayDirRef, ref bool hitRef, ref int faceIndexRef, ref float uRef, ref float vRef, ref float distRef, out IntPtr allHitsRef, ref int countOfHitsRef);		
        
        /// <summary>	
        /// Splits a mesh into meshes smaller than the specified size.	
        /// </summary>	
        /// <remarks>	
        ///  A common use of this function is to split a mesh with 32-bit indices (more than 65535 vertices) into more than one mesh, each of which has 16-bit indices. The adjacency, vertex remap and face remap arrays are arrays are DWORDs where each array contains n DWORD pointers, followed by the DWORD data referenced by the pointers. For example, to obtain the face remap information for face 3 in mesh 2, the following code could be used, assuming the face remap data was returned in a variable named ppFaceRemapArrayOut. 	
        /// <code> const DWORD **face_remaps =  static_cast&lt;DWORD **&gt;(ppFaceRemapArrayOut-&gt;GetBufferPointer());	
        /// const DWORD remap = face_remaps[2][3]; </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="pMeshIn"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface, representing the source mesh. </param>
        /// <param name="adjacencyInRef"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh to be simplified. </param>
        /// <param name="maxSize">  Maximum number of vertices in the resulting mesh. </param>
        /// <param name="options"> Option flags for the new meshes. </param>
        /// <param name="meshesOutRef"> Number of meshes returned. </param>
        /// <param name="meshArrayOutRef"> Buffer containing an array of <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interfaces for the new meshes. For a source mesh split into n meshes, ppMeshArrayOut is an array of n ID3DXMesh pointers. </param>
        /// <param name="adjacencyArrayOutRef"> Buffer containing an array of adjacency arrays (DWORDs) for the new meshes. See <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. This parameter is optional. </param>
        /// <param name="faceRemapArrayOutRef"> Buffer containing an array of face remap arrays (DWORDs) for the new meshes. See <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. This parameter is optional. </param>
        /// <param name="vertRemapArrayOutRef"> Buffer containing an array of vertex remap arrays for the new meshes. See <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. This parameter is optional. </param>
        /// <returns> void If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXSplitMesh([None] LPD3DXMESH pMeshIn,[None] const int* pAdjacencyIn,[None] const int MaxSize,[None] const int Options,[None] int* pMeshesOut,[None] LPD3DXBUFFER* ppMeshArrayOut,[None] LPD3DXBUFFER* ppAdjacencyArrayOut,[None] LPD3DXBUFFER* ppFaceRemapArrayOut,[None] LPD3DXBUFFER* ppVertRemapArrayOut)</unmanaged>
		public static SlimDX2.Result D3DXSplitMesh(SlimDX2.Direct3D9.ID3DXMesh pMeshIn, ref int adjacencyInRef, int maxSize, int options, ref int meshesOutRef, out SlimDX2.Direct3D9.ShaderBytecode meshArrayOutRef, out SlimDX2.Direct3D9.ShaderBytecode adjacencyArrayOutRef, out SlimDX2.Direct3D9.ShaderBytecode faceRemapArrayOutRef, out SlimDX2.Direct3D9.ShaderBytecode vertRemapArrayOutRef) {
            unsafe {
                IntPtr meshArrayOutRef_ = IntPtr.Zero;
                IntPtr adjacencyArrayOutRef_ = IntPtr.Zero;
                IntPtr faceRemapArrayOutRef_ = IntPtr.Zero;
                IntPtr vertRemapArrayOutRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSplitMesh_((pMeshIn == null)?IntPtr.Zero:pMeshIn.NativePointer, ref  adjacencyInRef,  maxSize,  options, ref  meshesOutRef, out meshArrayOutRef_, out adjacencyArrayOutRef_, out faceRemapArrayOutRef_, out vertRemapArrayOutRef_);
                meshArrayOutRef = (meshArrayOutRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(meshArrayOutRef_);
                adjacencyArrayOutRef = (adjacencyArrayOutRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(adjacencyArrayOutRef_);
                faceRemapArrayOutRef = (faceRemapArrayOutRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(faceRemapArrayOutRef_);
                vertRemapArrayOutRef = (vertRemapArrayOutRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(vertRemapArrayOutRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSplitMesh([None] LPD3DXMESH pMeshIn,[None] const int* pAdjacencyIn,[None] const int MaxSize,[None] const int Options,[None] int* pMeshesOut,[None] LPD3DXBUFFER* ppMeshArrayOut,[None] LPD3DXBUFFER* ppAdjacencyArrayOut,[None] LPD3DXBUFFER* ppFaceRemapArrayOut,[None] LPD3DXBUFFER* ppVertRemapArrayOut)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSplitMesh", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSplitMesh_(IntPtr pMeshIn, ref int adjacencyInRef, int maxSize, int options, ref int meshesOutRef, out IntPtr meshArrayOutRef, out IntPtr adjacencyArrayOutRef, out IntPtr faceRemapArrayOutRef, out IntPtr vertRemapArrayOutRef);		
        
        /// <summary>	
        /// Computes the intersection of a ray and a triangle.	
        /// </summary>	
        /// <remarks>	
        ///  The <see cref="SlimDX2.Direct3D9.D3DX9.D3DXIntersect"/> function provides a way to understand points in and around a triangle, independent of where the triangle is actually located. This function returns the resulting point by using the following equation: V1 + U(V2 - V1) + V(V3 - V1). Any point in the plane V1V2V3 can be represented by the barycentric coordinate (U,V). The parameter U controls how much V2 gets weighted into the result, and the parameter V controls how much V3 gets weighted into the result. Lastly, the value of [1 - (U + V)] controls how much V1 gets weighted into the result. Barycentric coordinates are a form of general coordinates. In this context, using barycentric coordinates represents a change in coordinate systems. What holds true for Cartesian coordinates holds true for barycentric coordinates. Barycentric coordinates define a point inside a triangle in terms of the triangle's vertices.  For a more in-depth description of barycentric coordinates, see {{Mathworld's Barycentric Coordinates Description}}. 	
        /// </remarks>	
        /// <param name="arg0Ref"> Pointer to a <see cref="SlimMath.Vector3"/> structure, describing the first triangle vertex position. </param>
        /// <param name="arg1Ref"> Pointer to a <see cref="SlimMath.Vector3"/> structure, describing the second triangle vertex position. </param>
        /// <param name="arg2Ref"> Pointer to a <see cref="SlimMath.Vector3"/> structure, describing the third triangle vertex position. </param>
        /// <param name="rayPosRef"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the point where the ray begins. </param>
        /// <param name="rayDirRef"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the direction of the ray. </param>
        /// <param name="uRef"> Barycentric hit coordinates, U. </param>
        /// <param name="vRef"> Barycentric hit coordinates, V. </param>
        /// <param name="distRef"> Ray-intersection parameter distance. </param>
        /// <returns> {{BOOL}} Returns TRUE if the ray intersects the area of the triangle. Otherwise, returns FALSE. </returns>
        /// <unmanaged>BOOL D3DXIntersectTri([None] const D3DXVECTOR3* p0,[None] const D3DXVECTOR3* p1,[None] const D3DXVECTOR3* p2,[None] const D3DXVECTOR3* pRayPos,[None] const D3DXVECTOR3* pRayDir,[None] float* pU,[None] float* pV,[None] float* pDist)</unmanaged>
		public static bool D3DXIntersectTri(ref SlimMath.Vector3 arg0Ref, ref SlimMath.Vector3 arg1Ref, ref SlimMath.Vector3 arg2Ref, ref SlimMath.Vector3 rayPosRef, ref SlimMath.Vector3 rayDirRef, ref float uRef, ref float vRef, ref float distRef) {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=D3DXIntersectTri_(ref  arg0Ref, ref  arg1Ref, ref  arg2Ref, ref  rayPosRef, ref  rayDirRef, ref  uRef, ref  vRef, ref  distRef));
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>BOOL D3DXIntersectTri([None] const D3DXVECTOR3* p0,[None] const D3DXVECTOR3* p1,[None] const D3DXVECTOR3* p2,[None] const D3DXVECTOR3* pRayPos,[None] const D3DXVECTOR3* pRayDir,[None] float* pU,[None] float* pV,[None] float* pDist)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXIntersectTri", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DXIntersectTri_(ref SlimMath.Vector3 arg0Ref, ref SlimMath.Vector3 arg1Ref, ref SlimMath.Vector3 arg2Ref, ref SlimMath.Vector3 rayPosRef, ref SlimMath.Vector3 rayDirRef, ref float uRef, ref float vRef, ref float distRef);		
        
        /// <summary>	
        /// Determines if a ray intersects the volume of a sphere's bounding box.	
        /// </summary>	
        /// <remarks>	
        ///  D3DXSphereBoundProbe determines if the ray intersects the volume of the sphere's bounding box, not just the surface of the sphere. 	
        /// </remarks>	
        /// <param name="centerRef"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the center coordinate of the sphere. </param>
        /// <param name="radius"> Radius of the sphere. </param>
        /// <param name="rayPositionRef"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the origin coordinate of the ray. </param>
        /// <param name="rayDirectionRef"> Pointer to a <see cref="SlimMath.Vector3"/> structure, specifying the direction of the ray. This vector should not be (0,0,0) but does not need to be normalized. </param>
        /// <returns> {{BOOL}} Returns TRUE if the ray intersects the volume of the sphere's bounding box. Otherwise, returns FALSE. </returns>
        /// <unmanaged>BOOL D3DXSphereBoundProbe([None] const D3DXVECTOR3* pCenter,[None] float Radius,[None] const D3DXVECTOR3* pRayPosition,[None] const D3DXVECTOR3* pRayDirection)</unmanaged>
		public static bool D3DXSphereBoundProbe(ref SlimMath.Vector3 centerRef, float radius, ref SlimMath.Vector3 rayPositionRef, ref SlimMath.Vector3 rayDirectionRef) {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=D3DXSphereBoundProbe_(ref  centerRef,  radius, ref  rayPositionRef, ref  rayDirectionRef));
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>BOOL D3DXSphereBoundProbe([None] const D3DXVECTOR3* pCenter,[None] float Radius,[None] const D3DXVECTOR3* pRayPosition,[None] const D3DXVECTOR3* pRayDirection)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSphereBoundProbe", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DXSphereBoundProbe_(ref SlimMath.Vector3 centerRef, float radius, ref SlimMath.Vector3 rayPositionRef, ref SlimMath.Vector3 rayDirectionRef);		
        
        /// <summary>	
        /// Determines whether a ray intersects the volume of a box's bounding box.	
        /// </summary>	
        /// <remarks>	
        ///  D3DXBoxBoundProbe determines if the ray intersects the volume of the box's bounding box, not just the surface of the box. The values passed to D3DXBoxBoundProbe are xmin, xmax, ymin, ymax, zmin, and zmax. Thus, the following defines the corners of the bounding box. 	
        /// <code> xmax, ymax, zmax	
        /// xmax, ymax, zmin	
        /// xmax, ymin, zmax	
        /// xmax, ymin, zmin	
        /// xmin, ymax, zmax	
        /// xmin, ymax, zmin	
        /// xmin, ymin, zmax	
        /// xmin, ymin, zmin </code>	
        /// 	
        ///  The depth of the bounding box in the z direction is zmax - zmin, in the y direction is ymax - ymin, and in the x direction is xmax - xmin. For example, with the following minimum and maximum vectors, min (-1, -1, -1) and max (1, 1, 1), the bounding box is defined in the following manner. 	
        /// <code> 1,  1,  1 1,  1, -1 1, -1,  1 1, -1, -1	
        /// -1,  1,  1	
        /// -1,  1, -1	
        /// -1, -1,  1	
        /// -1, -1, -l </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="minRef"> Pointer to a <see cref="SlimMath.Vector3"/>, describing the lower-left corner of the bounding box. See Remarks. </param>
        /// <param name="maxRef"> Pointer to a  <see cref="SlimMath.Vector3"/> structure, describing the upper-right corner of the bounding box. See Remarks. </param>
        /// <param name="rayPositionRef"> Pointer to a D3DXVECTOR3 structure, specifying the origin coordinate of the ray. </param>
        /// <param name="rayDirectionRef"> Pointer to a D3DXVECTOR3 structure, specifying the direction of the ray. This vector should not be (0,0,0) but does not need to be normalized. </param>
        /// <returns> {{BOOL}} Returns TRUE if the ray intersects the volume of the box's bounding box. Otherwise, returns FALSE. </returns>
        /// <unmanaged>BOOL D3DXBoxBoundProbe([None] const D3DXVECTOR3* pMin,[None] const D3DXVECTOR3* pMax,[None] const D3DXVECTOR3* pRayPosition,[None] const D3DXVECTOR3* pRayDirection)</unmanaged>
		public static bool D3DXBoxBoundProbe(ref SlimMath.Vector3 minRef, ref SlimMath.Vector3 maxRef, ref SlimMath.Vector3 rayPositionRef, ref SlimMath.Vector3 rayDirectionRef) {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=D3DXBoxBoundProbe_(ref  minRef, ref  maxRef, ref  rayPositionRef, ref  rayDirectionRef));
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>BOOL D3DXBoxBoundProbe([None] const D3DXVECTOR3* pMin,[None] const D3DXVECTOR3* pMax,[None] const D3DXVECTOR3* pRayPosition,[None] const D3DXVECTOR3* pRayDirection)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXBoxBoundProbe", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DXBoxBoundProbe_(ref SlimMath.Vector3 minRef, ref SlimMath.Vector3 maxRef, ref SlimMath.Vector3 rayPositionRef, ref SlimMath.Vector3 rayDirectionRef);		
        
        /// <summary>	
        ///  Compute tangent, binormal, and normal vectors for a mesh.	
        /// </summary>	
        /// <remarks>	
        ///  This function simply calls <see cref="SlimDX2.Direct3D9.D3DX9.D3DXComputeTangentFrameEx"/> with the following input parameters: 	
        /// <code> D3DXComputeTangentFrameEx(pMesh, D3DDECLUSAGE_TEXCOORD, 0,    D3DDECLUSAGE_BINORMAL, 0, D3DDECLUSAGE_TANGENT, 0,  D3DDECLUSAGE_NORMAL, 0,  dwOptions | D3DXTANGENT_GENERATE_IN_PLACE, NULL, 0.01f, 0.25f, 0.01f, NULL, NULL); </code>	
        /// 	
        ///  Singularities are handled as required by grouping edges and splitting vertices. If any vertices need to be split, the function will fail. The computed normal vector at each vertex is always normalized to have unit length. The most robust solution for computing orthogonal Cartesian coordinates is to not set flags D3DXTANGENT_ORTHOGONALIZE_FROM_U and D3DXTANGENT_ORTHOGONALIZE_FROM_V, so that orthogonal coordinates are computed from both UV texture coordinates. However, in this case, if either U or V is zero, then the function will compute orthogonal coordinates using D3DXTANGENT_ORTHOGONALIZE_FROM_V or D3DXTANGENT_ORTHOGONALIZE_FROM_U respectively. 	
        /// </remarks>	
        /// <param name="meshRef"> Pointer to an input <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> mesh object. </param>
        /// <param name="dwOptions"> Combination of one or more <see cref="SlimDX2.Direct3D9.TangentOptions"/> flags.   Use NULL to specify the following options:  Weight the normal vector length by the angle, in radians, subtended by the two edges leaving the vertex. Compute orthogonal Cartesian coordinates from the UV texture coordinates. Textures are not wrapped in either U or V directions Partial derivatives with respect to texture coordinates are normalized. Vertices are ordered in a counterclockwise direction around each triangle. Use per-vertex normal vectors already present in the input mesh. The results will be stored in the original input mesh. The function will fail if new vertices need to be created.  </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXComputeTangentFrame([None] ID3DXMesh* pMesh,[None] int dwOptions)</unmanaged>
		public static SlimDX2.Result D3DXComputeTangentFrame(SlimDX2.Direct3D9.ID3DXMesh meshRef, int dwOptions) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeTangentFrame_((meshRef == null)?IntPtr.Zero:meshRef.NativePointer,  dwOptions);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeTangentFrame([None] ID3DXMesh* pMesh,[None] int dwOptions)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeTangentFrame", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeTangentFrame_(IntPtr meshRef, int dwOptions);		
        
        /// <summary>	
        /// Performs tangent frame computations on a mesh. Tangent, binormal, and optionally normal vectors are generated. Singularities are handled as required by grouping edges and splitting vertices.	
        /// </summary>	
        /// <remarks>	
        ///  A simplified version of this function is available as <see cref="SlimDX2.Direct3D9.D3DX9.D3DXComputeTangentFrame"/>. The computed normal vector at each vertex is always normalized to have unit length. The most robust solution for computing orthogonal Cartesian coordinates is to not set flags D3DXTANGENT_ORTHOGONALIZE_FROM_U and D3DXTANGENT_ORTHOGONALIZE_FROM_V, so that orthogonal coordinates are computed from both texture coordinates u and v. However, in this case, if either u or v is zero, then the function will compute orthogonal coordinates using D3DXTANGENT_ORTHOGONALIZE_FROM_V or D3DXTANGENT_ORTHOGONALIZE_FROM_U, respectively. 	
        /// </remarks>	
        /// <param name="meshRef"> Pointer to an input <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> mesh object. </param>
        /// <param name="dwTextureInSemantic"> Specifies the texture coordinate input semantic. If D3DX_DEFAULT, the function assumes that there are no texture coordinates, and the function will fail unless normal vector calculation is specified. </param>
        /// <param name="dwTextureInIndex"> If a mesh has multiple texture coordinates, specifies the texture coordinate to use for the tangent frame computations. If zero, the mesh has only a single texture coordinate. </param>
        /// <param name="dwUPartialOutSemantic"> Specifies the output semantic for the type, typically D3DDECLUSAGE_TANGENT, that describes where the partial derivative with respect to the U texture coordinate will be stored. If D3DX_DEFAULT, then this partial derivative will not be stored. </param>
        /// <param name="dwUPartialOutIndex"> Specifies the semantic index at which to store the partial derivative with respect to the U texture coordinate. </param>
        /// <param name="dwVPartialOutSemantic"> Specifies the <see cref="SlimDX2.Direct3D9.DeclarationUsage"/> type, typically D3DDECLUSAGE_BINORMAL, that describes where the partial derivative with respect to the V texture coordinate will be stored. If D3DX_DEFAULT, then this partial derivative will not be stored. </param>
        /// <param name="dwVPartialOutIndex"> Specifies the semantic index at which to store the partial derivative with respect to the V texture coordinate. </param>
        /// <param name="dwNormalOutSemantic"> Specifies the output normal semantic, typically D3DDECLUSAGE_NORMAL, that describes where the normal vector at each vertex will be stored. If D3DX_DEFAULT, then this normal vector will not be stored. </param>
        /// <param name="dwNormalOutIndex"> Specifies the semantic index at which to store the normal vector at each vertex. </param>
        /// <param name="dwOptions"> Combination of one or more <see cref="SlimDX2.Direct3D9.TangentOptions"/> flags that specify tangent frame computation options. If NULL, the following options will be specified:  Description <see cref="SlimDX2.Direct3D9.TangentOptions"/> Flag Value Weight the normal vector length by the angle, in radians, subtended by the two edges leaving the vertex.&amp; !( D3DXTANGENT_WEIGHT_BY_AREA | D3DXTANGENT_WEIGHT_EQUAL ) Compute orthogonal Cartesian coordinates from texture coordinates (u, v). See Remarks.&amp; !( D3DXTANGENT_ORTHOGONALIZE_FROM_U | D3DXTANGENT_ORTHOGONALIZE_FROM_V ) Textures are not wrapped in either u or v directions&amp; !( D3DXTANGENT_WRAP_UV ) Partial derivatives with respect to texture coordinates are normalized.&amp; !( D3DXTANGENT_DONT_NORMALIZE_PARTIALS ) Vertices are ordered in a counterclockwise direction around each triangle.&amp; !( D3DXTANGENT_WIND_CW ) Use per-vertex normal vectors already present in the input mesh.&amp; !( D3DXTANGENT_CALCULATE_NORMALS )  ? If D3DXTANGENT_GENERATE_IN_PLACE is not set, the input mesh is cloned. The original mesh must therefore have sufficient space to store the computed normal vector and partial derivative data. </param>
        /// <param name="dwAdjacencyRef"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh. The number of bytes in this array must be at least 3 * {{GetNumFaces}} * sizeof(DWORD). </param>
        /// <param name="fPartialEdgeThreshold"> Specifies the maximum cosine of the angle at which two partial derivatives are deemed to be incompatible with each other. If the dot product of the direction of the two partial derivatives in adjacent triangles is less than or equal to this threshold, then the vertices shared between these triangles will be split. </param>
        /// <param name="fSingularPointThreshold"> Specifies the maximum magnitude of a partial derivative at which a vertex will be deemed singular. As multiple triangles are incident on a point that have nearby tangent frames, but altogether cancel each other out (such as at the top of a sphere), the magnitude of the partial derivative will decrease. If the magnitude is less than or equal to this threshold, then the vertex will be split for every triangle that contains it. </param>
        /// <param name="fNormalEdgeThreshold"> Similar to fPartialEdgeThreshold, specifies the maximum cosine of the angle between two normals that is a threshold beyond which vertices shared between triangles will be split. If the dot product of the two normals is less than the threshold, the shared vertices will be split, forming a hard edge between neighboring triangles. If the dot product is more than the threshold, neighboring triangles will have their normals interpolated. </param>
        /// <param name="meshOutRef"> Address of a pointer to an output <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> mesh object that receives the computed tangent, binormal, and normal vector data. </param>
        /// <param name="vertexMappingRef"> Address of a pointer to an output <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> buffer object that receives a mapping of new vertices computed by this method to the original vertices. The buffer is an array of DWORDs, with the array size defined as the number of vertices in ppMeshOut. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXComputeTangentFrameEx([None] ID3DXMesh* pMesh,[None] int dwTextureInSemantic,[None] int dwTextureInIndex,[None] int dwUPartialOutSemantic,[None] int dwUPartialOutIndex,[None] int dwVPartialOutSemantic,[None] int dwVPartialOutIndex,[None] int dwNormalOutSemantic,[None] int dwNormalOutIndex,[None] int dwOptions,[None] const int* pdwAdjacency,[None] float fPartialEdgeThreshold,[None] float fSingularPointThreshold,[None] float fNormalEdgeThreshold,[None] ID3DXMesh** ppMeshOut,[None] ID3DXBuffer** ppVertexMapping)</unmanaged>
		public static SlimDX2.Result D3DXComputeTangentFrameEx(SlimDX2.Direct3D9.ID3DXMesh meshRef, int dwTextureInSemantic, int dwTextureInIndex, int dwUPartialOutSemantic, int dwUPartialOutIndex, int dwVPartialOutSemantic, int dwVPartialOutIndex, int dwNormalOutSemantic, int dwNormalOutIndex, int dwOptions, ref int dwAdjacencyRef, float fPartialEdgeThreshold, float fSingularPointThreshold, float fNormalEdgeThreshold, out SlimDX2.Direct3D9.ID3DXMesh meshOutRef, out SlimDX2.Direct3D9.ShaderBytecode vertexMappingRef) {
            unsafe {
                IntPtr meshOutRef_ = IntPtr.Zero;
                IntPtr vertexMappingRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeTangentFrameEx_((meshRef == null)?IntPtr.Zero:meshRef.NativePointer,  dwTextureInSemantic,  dwTextureInIndex,  dwUPartialOutSemantic,  dwUPartialOutIndex,  dwVPartialOutSemantic,  dwVPartialOutIndex,  dwNormalOutSemantic,  dwNormalOutIndex,  dwOptions, ref  dwAdjacencyRef,  fPartialEdgeThreshold,  fSingularPointThreshold,  fNormalEdgeThreshold, out meshOutRef_, out vertexMappingRef_);
                meshOutRef = (meshOutRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshOutRef_);
                vertexMappingRef = (vertexMappingRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(vertexMappingRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeTangentFrameEx([None] ID3DXMesh* pMesh,[None] int dwTextureInSemantic,[None] int dwTextureInIndex,[None] int dwUPartialOutSemantic,[None] int dwUPartialOutIndex,[None] int dwVPartialOutSemantic,[None] int dwVPartialOutIndex,[None] int dwNormalOutSemantic,[None] int dwNormalOutIndex,[None] int dwOptions,[None] const int* pdwAdjacency,[None] float fPartialEdgeThreshold,[None] float fSingularPointThreshold,[None] float fNormalEdgeThreshold,[None] ID3DXMesh** ppMeshOut,[None] ID3DXBuffer** ppVertexMapping)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeTangentFrameEx", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeTangentFrameEx_(IntPtr meshRef, int dwTextureInSemantic, int dwTextureInIndex, int dwUPartialOutSemantic, int dwUPartialOutIndex, int dwVPartialOutSemantic, int dwVPartialOutIndex, int dwNormalOutSemantic, int dwNormalOutIndex, int dwOptions, ref int dwAdjacencyRef, float fPartialEdgeThreshold, float fSingularPointThreshold, float fNormalEdgeThreshold, out IntPtr meshOutRef, out IntPtr vertexMappingRef);		
        
        /// <summary>	
        /// Computes the tangent vectors for the texture coordinates given in the texture stage. Provided to support legacy applications. Use <see cref="SlimDX2.Direct3D9.D3DX9.D3DXComputeTangentFrameEx"/> for better results.	
        /// </summary>	
        /// <remarks>	
        ///  If the mesh vertex declaration specifies tangent or binormal fields, D3DXComputeTangent will update any user-supplied tangent or binormal data. Alternatively, set TangentIndex to {{D3DX_DEFAULT}} to not update the user-supplied tangent data, or set BinormIndex to D3DX_DEFAULT to not update the user-supplied binormal data. TexStageIndex cannot be set to D3DX_DEFAULT. D3DXComputeTangent depends on the mesh vertex declaration containing either the binormal field (BinormIndex), the tangent field (TangentIndex), or both. If both are missing, this function will fail. This function simply calls <see cref="SlimDX2.Direct3D9.D3DX9.D3DXComputeTangentFrameEx"/> with the following input parameters: 	
        /// <code> D3DXComputeTangentFrameEx( Mesh, D3DDECLUSAGE_TEXCOORD, TexStageIndex, ( BinormIndex == D3DX_DEFAULT ) ? D3DX_DEFAULT : D3DDECLUSAGE_BINORMAL, // provides backward function compatibility BinormIndex, ( TangentIndex == D3DX_DEFAULT ) ? D3DX_DEFAULT : D3DDECLUSAGE_TANGENT, TangentIndex, D3DX_DEFAULT, // do not store normals 0, ( Wrap ? D3DXTANGENT_WRAP_UV : 0 ) | D3DXTANGENT_GENERATE_IN_PLACE | D3DXTANGENT_ORTHOGONALIZE_FROM_U, pAdjacency, -1.01f, -0.01f, -1.01f, NULL, NULL); </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="mesh"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface that represent the input mesh. </param>
        /// <param name="texStage"> Index that represents the texture stage. </param>
        /// <param name="tangentIndex"> Index that provides the usage index for the tangent data. The vertex declaration implies the usage; this index modifies the usage with the usage index. For more information about a vertex declaration, see {{Vertex Declaration (Direct3D 9)}}. </param>
        /// <param name="binormIndex"> Index that provides the usage index for the binormal data. The vertex declaration implies the usage; this index modifies the usage with the usage index. For more information about a vertex declaration, see {{Vertex Declaration (Direct3D 9)}}. </param>
        /// <param name="wrap"> Set this value to 0 for no wrapping, or to 1 for wrapping in the U and V directions. </param>
        /// <param name="adjacencyRef"> Pointer to an array of three DWORDs per face to be filled with adjacent face indices. The number of bytes in this array must be at least ((3 * {{GetNumFaces}}) * sizeof(DWORD)). </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXComputeTangent([None] LPD3DXMESH Mesh,[None] int TexStage,[None] int TangentIndex,[None] int BinormIndex,[None] int Wrap,[None] const int* pAdjacency)</unmanaged>
		public static SlimDX2.Result D3DXComputeTangent(SlimDX2.Direct3D9.ID3DXMesh mesh, int texStage, int tangentIndex, int binormIndex, int wrap, ref int adjacencyRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeTangent_((mesh == null)?IntPtr.Zero:mesh.NativePointer,  texStage,  tangentIndex,  binormIndex,  wrap, ref  adjacencyRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeTangent([None] LPD3DXMESH Mesh,[None] int TexStage,[None] int TangentIndex,[None] int BinormIndex,[None] int Wrap,[None] const int* pAdjacency)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeTangent", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeTangent_(IntPtr mesh, int texStage, int tangentIndex, int binormIndex, int wrap, ref int adjacencyRef);		
        
        /// <summary>	
        /// Create a UV atlas for a mesh.	
        /// </summary>	
        /// <remarks>	
        ///  D3DXUVAtlasCreate can partition mesh geometry two ways:  Based on the number of charts Based on the maximum allowed stretch. If the maximum allowed stretch is 0, each triangle will likely be in its own chart.  	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an input mesh (see <see cref="SlimDX2.Direct3D9.ID3DXMesh"/>) which contains the object geometry for calculating the atlas. At a minimum, the mesh must contain position data and 2D texture coordinates. </param>
        /// <param name="uMaxChartNumber"> The maximum number of charts to partition the mesh into. See remarks about the partitioning modes. Use 0 to tell D3DX that the atlas should be parameterized based on stretch. </param>
        /// <param name="fMaxStretch"> The amount of stretching allowed. 0 means no stretching is allowed, 1 means any amount of stretching can be used. </param>
        /// <param name="uWidth"> Texture width. </param>
        /// <param name="uHeight"> Texture height. </param>
        /// <param name="fGutter"> The minimum distance, in texels, between two charts on the atlas. The gutter is always scaled by the width; so, if a gutter of 2.5 is used on a 512x512 texture, then the minimum distance between two charts is 2.5 / 512.0 texels. </param>
        /// <param name="dwTextureIndex"> Zero-based texture coordinate index that identifies which set of texture coordinates to use. </param>
        /// <param name="dwAdjacencyRef"> A pointer to an array of adjacency data. with 3 DWORDs per face, indicating which triangles are adjacent to each other (see <see cref="SlimDX2.Direct3D9.ID3DXBaseMesh.GenerateAdjacency"/>). </param>
        /// <param name="dwFalseEdgeAdjacencyRef"> An array with 3 DWORDS per face. Each face indicates if an edge is false or not. A non-false edge is indicated by -1, a false edge is indicated by any other value. This enables the parameterization of a mesh of quads where the edges down the middle of each quad will not be cut. </param>
        /// <param name="fIMTArrayRef"> A pointer to an array of integrated metric tensors that describes how to stretch a triangle (see {{IntegratedMetricTensor}}). </param>
        /// <param name="pStatusCallback"> A pointer to a callback function (see {{LPD3DXUVATLASCB}}) that is useful for monitoring progress. </param>
        /// <param name="fCallbackFrequency"> Specify how often D3DX will call the callback; a reasonable default value is 0.0001f. </param>
        /// <param name="userContextRef"> Pointer to a user-defined value which is passed to the callback function; typically used by an application to pass a pointer to a data structure that provides context information for the callback function. </param>
        /// <param name="dwOptions"> Specify the quality of the charts generated. See {{D3DXUVATLAS}}. </param>
        /// <param name="meshOutRef"> Pointer to the created mesh with the atlas (see <see cref="SlimDX2.Direct3D9.ID3DXMesh"/>). </param>
        /// <param name="facePartitioningRef"> A pointer to an array of the final face-partitioning data. Each element contains one DWORD per face (see <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>). </param>
        /// <param name="vertexRemapArrayRef"> A pointer to an array of remapped vertices. Each array element identifies the original vertex that each final vertex came from (if the vertex was split during remapping). Each array element contains one DWORD per vertex. </param>
        /// <param name="fMaxStretchOutRef"> A pointer to the maximum stretch value generated by the atlas algorithm. The range is between 0.0 and 1.0. </param>
        /// <param name="uNumChartsOutRef"> A pointer to the number of charts created by the atlas algorithm. If dwMaxChartNumber is too low, this parameter will return the minimum number of charts required to create an atlas. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK; otherwise, the value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXUVAtlasCreate([None] LPD3DXMESH pMesh,[None] int uMaxChartNumber,[None] float fMaxStretch,[None] int uWidth,[None] int uHeight,[None] float fGutter,[None] int dwTextureIndex,[None] const int* pdwAdjacency,[None] const int* pdwFalseEdgeAdjacency,[None] const float* pfIMTArray,[None] LPD3DXUVATLASCB pStatusCallback,[None] float fCallbackFrequency,[None] void* pUserContext,[None] int dwOptions,[None] LPD3DXMESH* ppMeshOut,[None] LPD3DXBUFFER* ppFacePartitioning,[None] LPD3DXBUFFER* ppVertexRemapArray,[None] float* pfMaxStretchOut,[None] int* puNumChartsOut)</unmanaged>
		public static SlimDX2.Result D3DXUVAtlasCreate(SlimDX2.Direct3D9.ID3DXMesh pMesh, int uMaxChartNumber, float fMaxStretch, int uWidth, int uHeight, float fGutter, int dwTextureIndex, ref int dwAdjacencyRef, ref int dwFalseEdgeAdjacencyRef, ref float fIMTArrayRef, SlimDX2.FunctionCallback pStatusCallback, float fCallbackFrequency, IntPtr userContextRef, int dwOptions, out SlimDX2.Direct3D9.ID3DXMesh meshOutRef, out SlimDX2.Direct3D9.ShaderBytecode facePartitioningRef, out SlimDX2.Direct3D9.ShaderBytecode vertexRemapArrayRef, ref float fMaxStretchOutRef, ref int uNumChartsOutRef) {
            unsafe {
                IntPtr meshOutRef_ = IntPtr.Zero;
                IntPtr facePartitioningRef_ = IntPtr.Zero;
                IntPtr vertexRemapArrayRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXUVAtlasCreate_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  uMaxChartNumber,  fMaxStretch,  uWidth,  uHeight,  fGutter,  dwTextureIndex, ref  dwAdjacencyRef, ref  dwFalseEdgeAdjacencyRef, ref  fIMTArrayRef,  pStatusCallback,  fCallbackFrequency,  userContextRef,  dwOptions, out meshOutRef_, out facePartitioningRef_, out vertexRemapArrayRef_, ref  fMaxStretchOutRef, ref  uNumChartsOutRef);
                meshOutRef = (meshOutRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshOutRef_);
                facePartitioningRef = (facePartitioningRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(facePartitioningRef_);
                vertexRemapArrayRef = (vertexRemapArrayRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(vertexRemapArrayRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXUVAtlasCreate([None] LPD3DXMESH pMesh,[None] int uMaxChartNumber,[None] float fMaxStretch,[None] int uWidth,[None] int uHeight,[None] float fGutter,[None] int dwTextureIndex,[None] const int* pdwAdjacency,[None] const int* pdwFalseEdgeAdjacency,[None] const float* pfIMTArray,[None] LPD3DXUVATLASCB pStatusCallback,[None] float fCallbackFrequency,[None] void* pUserContext,[None] int dwOptions,[None] LPD3DXMESH* ppMeshOut,[None] LPD3DXBUFFER* ppFacePartitioning,[None] LPD3DXBUFFER* ppVertexRemapArray,[None] float* pfMaxStretchOut,[None] int* puNumChartsOut)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXUVAtlasCreate", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXUVAtlasCreate_(IntPtr pMesh, int uMaxChartNumber, float fMaxStretch, int uWidth, int uHeight, float fGutter, int dwTextureIndex, ref int dwAdjacencyRef, ref int dwFalseEdgeAdjacencyRef, ref float fIMTArrayRef, SlimDX2.FunctionCallback pStatusCallback, float fCallbackFrequency, IntPtr userContextRef, int dwOptions, out IntPtr meshOutRef, out IntPtr facePartitioningRef, out IntPtr vertexRemapArrayRef, ref float fMaxStretchOutRef, ref int uNumChartsOutRef);		
        
        /// <summary>	
        /// Create a UV atlas for a mesh.	
        /// </summary>	
        /// <remarks>	
        ///  D3DXUVAtlasPartition is similar to <see cref="SlimDX2.Direct3D9.D3DX9.D3DXUVAtlasCreate"/>, except that D3DXUVAtlasPartition does not performing the final packing step. 	
        /// </remarks>	
        /// <param name="pMesh"> Pointer to an input mesh (see <see cref="SlimDX2.Direct3D9.ID3DXMesh"/>) that contains the object geometry for calculating the atlas. At a minimum, the mesh must contain position data and 2D texture coordinates. </param>
        /// <param name="uMaxChartNumber"> The maximum number of charts to partition the mesh into. See remarks about the partitioning modes. Use 0 to tell D3DX that the atlas should be parameterized based on stretch. </param>
        /// <param name="fMaxStretch"> The amount of stretching allowed. 0 means no stretching is allowed, 1 means any amount of stretching can be used. </param>
        /// <param name="dwTextureIndex"> Zero-based texture coordinate index that identifies which set of texture coordinates to use. </param>
        /// <param name="dwAdjacencyRef"> A pointer to an array of adjacency data with 3 DWORDs per face, indicating which triangles are adjacent to each other (see <see cref="SlimDX2.Direct3D9.ID3DXBaseMesh.GenerateAdjacency"/>). </param>
        /// <param name="dwFalseEdgeAdjacencyRef"> An array with 3 DWORDS per face. Each face indicates if an edge is false or not. A non-false edge is indicated by -1, a false edge is indicated by any other value. This enables the parameterization of a mesh of quads where the edges down the middle of each quad will not be cut. </param>
        /// <param name="fIMTArrayRef"> A pointer to an array of integrated metric tensors that describes how to stretch a triangle (see {{IntegratedMetricTensor}}). </param>
        /// <param name="pStatusCallback"> A pointer to a callback function (see {{LPD3DXUVATLASCB}}) that is useful for monitoring progress. </param>
        /// <param name="fCallbackFrequency"> Specify how often D3DX will call the callback; a reasonable default value is 0.0001f. </param>
        /// <param name="userContextRef"> Pointer to a user-defined value that is passed to the callback function; typically used by an application to pass a pointer to a data structure that provides context information for the callback function. </param>
        /// <param name="dwOptions"> Specify the quality of the charts generated by combining one or more {{D3DXUVATLAS}} flags. </param>
        /// <param name="meshOutRef"> Pointer to the created mesh with the atlas (see <see cref="SlimDX2.Direct3D9.ID3DXMesh"/>). </param>
        /// <param name="facePartitioningRef"> A pointer to an array of the final face-partitioning data. Each element contains one DWORD per face (see <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>). </param>
        /// <param name="vertexRemapArrayRef"> A pointer to an array of remapped vertices. Each array element identifies the original vertex each final vertex came from (if the vertex was split during remapping). Each array element contains one DWORD per vertex. </param>
        /// <param name="partitionResultAdjacencyRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface. This buffer will contain an array of three DWORDs per face that specify the three neighbors for each face in the output mesh. This parameter must not be NULL, because the subsequent call to D3DXUVAtlasPack() requires it. </param>
        /// <param name="fMaxStretchOutRef"> A pointer to the maximum stretch value generated by the atlas algorithm. The range is between 0.0 and 1.0. </param>
        /// <param name="uNumChartsOutRef"> A pointer to the number of charts created by the atlas algorithm. If dwMaxChartNumber is too low, this parameter will return the minimum number of charts required to create an atlas. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK; otherwise, the value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXUVAtlasPartition([None] LPD3DXMESH pMesh,[None] int uMaxChartNumber,[None] float fMaxStretch,[None] int dwTextureIndex,[None] const int* pdwAdjacency,[None] const int* pdwFalseEdgeAdjacency,[None] const float* pfIMTArray,[None] LPD3DXUVATLASCB pStatusCallback,[None] float fCallbackFrequency,[None] void* pUserContext,[None] int dwOptions,[None] LPD3DXMESH* ppMeshOut,[None] LPD3DXBUFFER* ppFacePartitioning,[None] LPD3DXBUFFER* ppVertexRemapArray,[None] LPD3DXBUFFER* ppPartitionResultAdjacency,[None] float* pfMaxStretchOut,[None] int* puNumChartsOut)</unmanaged>
		public static SlimDX2.Result D3DXUVAtlasPartition(SlimDX2.Direct3D9.ID3DXMesh pMesh, int uMaxChartNumber, float fMaxStretch, int dwTextureIndex, ref int dwAdjacencyRef, ref int dwFalseEdgeAdjacencyRef, ref float fIMTArrayRef, SlimDX2.FunctionCallback pStatusCallback, float fCallbackFrequency, IntPtr userContextRef, int dwOptions, out SlimDX2.Direct3D9.ID3DXMesh meshOutRef, out SlimDX2.Direct3D9.ShaderBytecode facePartitioningRef, out SlimDX2.Direct3D9.ShaderBytecode vertexRemapArrayRef, out SlimDX2.Direct3D9.ShaderBytecode partitionResultAdjacencyRef, ref float fMaxStretchOutRef, ref int uNumChartsOutRef) {
            unsafe {
                IntPtr meshOutRef_ = IntPtr.Zero;
                IntPtr facePartitioningRef_ = IntPtr.Zero;
                IntPtr vertexRemapArrayRef_ = IntPtr.Zero;
                IntPtr partitionResultAdjacencyRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXUVAtlasPartition_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  uMaxChartNumber,  fMaxStretch,  dwTextureIndex, ref  dwAdjacencyRef, ref  dwFalseEdgeAdjacencyRef, ref  fIMTArrayRef,  pStatusCallback,  fCallbackFrequency,  userContextRef,  dwOptions, out meshOutRef_, out facePartitioningRef_, out vertexRemapArrayRef_, out partitionResultAdjacencyRef_, ref  fMaxStretchOutRef, ref  uNumChartsOutRef);
                meshOutRef = (meshOutRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshOutRef_);
                facePartitioningRef = (facePartitioningRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(facePartitioningRef_);
                vertexRemapArrayRef = (vertexRemapArrayRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(vertexRemapArrayRef_);
                partitionResultAdjacencyRef = (partitionResultAdjacencyRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(partitionResultAdjacencyRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXUVAtlasPartition([None] LPD3DXMESH pMesh,[None] int uMaxChartNumber,[None] float fMaxStretch,[None] int dwTextureIndex,[None] const int* pdwAdjacency,[None] const int* pdwFalseEdgeAdjacency,[None] const float* pfIMTArray,[None] LPD3DXUVATLASCB pStatusCallback,[None] float fCallbackFrequency,[None] void* pUserContext,[None] int dwOptions,[None] LPD3DXMESH* ppMeshOut,[None] LPD3DXBUFFER* ppFacePartitioning,[None] LPD3DXBUFFER* ppVertexRemapArray,[None] LPD3DXBUFFER* ppPartitionResultAdjacency,[None] float* pfMaxStretchOut,[None] int* puNumChartsOut)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXUVAtlasPartition", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXUVAtlasPartition_(IntPtr pMesh, int uMaxChartNumber, float fMaxStretch, int dwTextureIndex, ref int dwAdjacencyRef, ref int dwFalseEdgeAdjacencyRef, ref float fIMTArrayRef, SlimDX2.FunctionCallback pStatusCallback, float fCallbackFrequency, IntPtr userContextRef, int dwOptions, out IntPtr meshOutRef, out IntPtr facePartitioningRef, out IntPtr vertexRemapArrayRef, out IntPtr partitionResultAdjacencyRef, ref float fMaxStretchOutRef, ref int uNumChartsOutRef);		
        
        /// <summary>	
        /// Pack mesh partitioning data into an atlas.	
        /// </summary>	
        /// <param name="meshRef"> Pointer to an input mesh (see <see cref="SlimDX2.Direct3D9.ID3DXMesh"/>) which contains the object geometry for calculating the atlas. At a minimum, the mesh must contain position data and 2D texture coordinates. </param>
        /// <param name="uWidth"> Texture width. </param>
        /// <param name="uHeight"> Texture height. </param>
        /// <param name="fGutter"> The minimum distance, in texels, between two charts on the atlas. The gutter is always scaled by the width; so, if a gutter of 2.5 is used on a 512x512 texture, then the minimum distance between two charts is 2.5 / 512.0 texels. </param>
        /// <param name="dwTextureIndex"> Zero-based texture coordinate index that identifies which set of texture coordinates to use. </param>
        /// <param name="dwPartitionResultAdjacencyRef"> Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh. It should be derived from the ppPartitionResultAdjacency returned from <see cref="SlimDX2.Direct3D9.D3DX9.D3DXUVAtlasPartition"/>. This value cannot be NULL, because Pack needs to know where charts were cut in the partition step in order to find the edges of each chart. </param>
        /// <param name="pStatusCallback"> A pointer to a callback function (see {{LPD3DXUVATLASCB}}) that is useful for monitoring progress. </param>
        /// <param name="fCallbackFrequency"> Specify how often D3DX will call the callback; a reasonable default value is 0.0001f. </param>
        /// <param name="userContextRef"> A void pointer to be passed back to the callback function. </param>
        /// <param name="dwOptions"> This options parameter is currently reserved. </param>
        /// <param name="pFacePartitioning"> A pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> containing the array of the final face-partitioning. Each element contains one DWORD per face. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK; otherwise, the value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXUVAtlasPack([None] ID3DXMesh* pMesh,[None] int uWidth,[None] int uHeight,[None] float fGutter,[None] int dwTextureIndex,[None] const int* pdwPartitionResultAdjacency,[None] LPD3DXUVATLASCB pStatusCallback,[None] float fCallbackFrequency,[None] void* pUserContext,[None] int dwOptions,[None] LPD3DXBUFFER pFacePartitioning)</unmanaged>
		public static SlimDX2.Result D3DXUVAtlasPack(SlimDX2.Direct3D9.ID3DXMesh meshRef, int uWidth, int uHeight, float fGutter, int dwTextureIndex, ref int dwPartitionResultAdjacencyRef, SlimDX2.FunctionCallback pStatusCallback, float fCallbackFrequency, IntPtr userContextRef, int dwOptions, SlimDX2.Direct3D9.ShaderBytecode pFacePartitioning) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXUVAtlasPack_((meshRef == null)?IntPtr.Zero:meshRef.NativePointer,  uWidth,  uHeight,  fGutter,  dwTextureIndex, ref  dwPartitionResultAdjacencyRef,  pStatusCallback,  fCallbackFrequency,  userContextRef,  dwOptions, (pFacePartitioning == null)?IntPtr.Zero:pFacePartitioning.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXUVAtlasPack([None] ID3DXMesh* pMesh,[None] int uWidth,[None] int uHeight,[None] float fGutter,[None] int dwTextureIndex,[None] const int* pdwPartitionResultAdjacency,[None] LPD3DXUVATLASCB pStatusCallback,[None] float fCallbackFrequency,[None] void* pUserContext,[None] int dwOptions,[None] LPD3DXBUFFER pFacePartitioning)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXUVAtlasPack", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXUVAtlasPack_(IntPtr meshRef, int uWidth, int uHeight, float fGutter, int dwTextureIndex, ref int dwPartitionResultAdjacencyRef, SlimDX2.FunctionCallback pStatusCallback, float fCallbackFrequency, IntPtr userContextRef, int dwOptions, IntPtr pFacePartitioning);		
        
        /// <summary>	
        /// Calculate per-triangle IMT's from from per-vertex data. This function allows you to calculate the IMT based off of any value in a mesh (color, normal, etc).	
        /// </summary>	
        /// <param name="pMesh"> A pointer to an input mesh (see <see cref="SlimDX2.Direct3D9.ID3DXMesh"/>) which contains the object geometry for calculating the IMT. </param>
        /// <param name="fVertexSignalRef"> A pointer to an array of per-vertex data from which IMT will be computed. The array size is  uSignalStride * v, where v is the number of vertices in the mesh. </param>
        /// <param name="uSignalDimension"> The number of floats per vertex. </param>
        /// <param name="uSignalStride"> The number of bytes per vertex in the array. This must be a multiple of sizeof(float) </param>
        /// <param name="dwOptions"> Texture wrap options. This is a combination of one or more {{D3DXIMT FLAGS}}. </param>
        /// <param name="pStatusCallback"> A pointer to a callback function to monitor IMT computation progress. </param>
        /// <param name="userContextRef"> A pointer to a user-defined variable which is passed to the status callback function. Typically used by an application to pass a pointer to a data structure that provides context information for the callback function. </param>
        /// <param name="iMTDataRef"> A pointer to the buffer (see <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>) containing the returned IMT array. This array can be provided as input to the D3DX {{UVAtlas Functions}} to prioritize texture-space allocation in the texture parameterization. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK; otherwise, the value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXComputeIMTFromPerVertexSignal([None] LPD3DXMESH pMesh,[None] const float* pfVertexSignal,[None] int uSignalDimension,[None] int uSignalStride,[None] int dwOptions,[None] LPD3DXUVATLASCB pStatusCallback,[None] void* pUserContext,[None] LPD3DXBUFFER* ppIMTData)</unmanaged>
		public static SlimDX2.Result D3DXComputeIMTFromPerVertexSignal(SlimDX2.Direct3D9.ID3DXMesh pMesh, ref float fVertexSignalRef, int uSignalDimension, int uSignalStride, int dwOptions, SlimDX2.FunctionCallback pStatusCallback, IntPtr userContextRef, out SlimDX2.Direct3D9.ShaderBytecode iMTDataRef) {
            unsafe {
                IntPtr iMTDataRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeIMTFromPerVertexSignal_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer, ref  fVertexSignalRef,  uSignalDimension,  uSignalStride,  dwOptions,  pStatusCallback,  userContextRef, out iMTDataRef_);
                iMTDataRef = (iMTDataRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(iMTDataRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeIMTFromPerVertexSignal([None] LPD3DXMESH pMesh,[None] const float* pfVertexSignal,[None] int uSignalDimension,[None] int uSignalStride,[None] int dwOptions,[None] LPD3DXUVATLASCB pStatusCallback,[None] void* pUserContext,[None] LPD3DXBUFFER* ppIMTData)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeIMTFromPerVertexSignal", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeIMTFromPerVertexSignal_(IntPtr pMesh, ref float fVertexSignalRef, int uSignalDimension, int uSignalStride, int dwOptions, SlimDX2.FunctionCallback pStatusCallback, IntPtr userContextRef, out IntPtr iMTDataRef);		
        
        /// <summary>	
        /// Calculates per-triangle IMT's from a custom application-specified signal that varies over the surface of the mesh (generally at a higher frequency than vertex data). The signal is evaluated via a user-specified callback function.	
        /// </summary>	
        /// <remarks>	
        ///  This function requires that the input mesh contain a signal-to-mesh texture mapping (ie. texture coordinates). It allows the user to define a signal arbitrarily over the surface of the mesh. 	
        /// </remarks>	
        /// <param name="pMesh"> A pointer to an input mesh (see <see cref="SlimDX2.Direct3D9.ID3DXMesh"/>) which contains the object geometry for calculating the IMT. </param>
        /// <param name="dwTextureIndex"> Zero-based texture coordinate index that identifies which set of texture coordinates to use. </param>
        /// <param name="uSignalDimension"> The number of components in each data point in the signal. </param>
        /// <param name="fMaxUVDistance"> The maximum distance between vertices; the algorithm continues  subdividing until the distance between all vertices is less than or equal to fMaxUVDistance. </param>
        /// <param name="dwOptions"> Texture wrap options. This is a combination of one or more {{D3DXIMT FLAGS}}. </param>
        /// <param name="pSignalCallback"> A pointer to a user-provided evaluator function, which will be used to compute the signal value at arbitrary U,V coordinates. The function follows the prototype of {{LPD3DXIMTSIGNALCALLBACK}}. </param>
        /// <param name="userDataRef"> A pointer to a user-defined value which is passed to the signal callback function. Typically used by an application to pass a pointer to a data structure that provides context information for the callback function. </param>
        /// <param name="pStatusCallback"> A pointer to a callback function to monitor IMT computation progress. </param>
        /// <param name="userContextRef"> A pointer to a user-defined variable which is passed to the status callback function. Typically used by an application to pass a pointer to a data structure that provides context information for the callback function. </param>
        /// <param name="iMTDataRef"> A pointer to the buffer (see <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>) containing the returned IMT array. This array can be provided as input to the D3DX {{UVAtlas Functions}} to prioritize texture-space allocation in the texture parameterization. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK; otherwise, the value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXComputeIMTFromSignal([None] LPD3DXMESH pMesh,[None] int dwTextureIndex,[None] int uSignalDimension,[None] float fMaxUVDistance,[None] int dwOptions,[None] LPD3DXIMTSIGNALCALLBACK pSignalCallback,[None] void* pUserData,[None] LPD3DXUVATLASCB pStatusCallback,[None] void* pUserContext,[None] LPD3DXBUFFER* ppIMTData)</unmanaged>
		public static SlimDX2.Result D3DXComputeIMTFromSignal(SlimDX2.Direct3D9.ID3DXMesh pMesh, int dwTextureIndex, int uSignalDimension, float fMaxUVDistance, int dwOptions, SlimDX2.FunctionCallback pSignalCallback, IntPtr userDataRef, SlimDX2.FunctionCallback pStatusCallback, IntPtr userContextRef, out SlimDX2.Direct3D9.ShaderBytecode iMTDataRef) {
            unsafe {
                IntPtr iMTDataRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeIMTFromSignal_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  dwTextureIndex,  uSignalDimension,  fMaxUVDistance,  dwOptions,  pSignalCallback,  userDataRef,  pStatusCallback,  userContextRef, out iMTDataRef_);
                iMTDataRef = (iMTDataRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(iMTDataRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeIMTFromSignal([None] LPD3DXMESH pMesh,[None] int dwTextureIndex,[None] int uSignalDimension,[None] float fMaxUVDistance,[None] int dwOptions,[None] LPD3DXIMTSIGNALCALLBACK pSignalCallback,[None] void* pUserData,[None] LPD3DXUVATLASCB pStatusCallback,[None] void* pUserContext,[None] LPD3DXBUFFER* ppIMTData)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeIMTFromSignal", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeIMTFromSignal_(IntPtr pMesh, int dwTextureIndex, int uSignalDimension, float fMaxUVDistance, int dwOptions, SlimDX2.FunctionCallback pSignalCallback, IntPtr userDataRef, SlimDX2.FunctionCallback pStatusCallback, IntPtr userContextRef, out IntPtr iMTDataRef);		
        
        /// <summary>	
        /// Calculates per-triangle IMT's from a texture mapped onto a mesh, to be used optionally as input to the D3DX {{UVAtlas Functions}}.	
        /// </summary>	
        /// <remarks>	
        ///  Given a texture that maps over the surface of the mesh, the algorithm computes the IMT for each face. This will cause triangles containing lower-frequency signal data to take up less space in the final texture atlas when parameterized with the UVAtlas functions. The texture is assumed to be interpolated over the mesh bilinearly. 	
        /// </remarks>	
        /// <param name="pMesh"> A pointer to an input mesh (see <see cref="SlimDX2.Direct3D9.ID3DXMesh"/>) which contains the object geometry for calculating the IMT. </param>
        /// <param name="pTexture"> A pointer to the texture (see <see cref="SlimDX2.Direct3D9.Texture"/>) that is mapped to the mesh. </param>
        /// <param name="dwTextureIndex"> Zero-based texture coordinate index that identifies which set of texture coordinates to use. </param>
        /// <param name="dwOptions"> Texture wrap options. This is a combination of one or more {{D3DXIMT FLAGS}}. </param>
        /// <param name="pStatusCallback"> A pointer to a callback function to monitor IMT computation progress. </param>
        /// <param name="userContextRef"> A pointer to a user-defined variable which is passed to the status callback function. Typically used by an application to pass a pointer to a data structure that provides context information for the callback function. </param>
        /// <param name="iMTDataRef"> A pointer to the buffer (see <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>) containing the returned IMT array. This array can be provided as input to the D3DX {{UVAtlas Functions}} to prioritize texture-space allocation in the texture parameterization. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK; otherwise, the value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXComputeIMTFromTexture([None] LPD3DXMESH pMesh,[None] LPDIRECT3DTEXTURE9 pTexture,[None] int dwTextureIndex,[None] int dwOptions,[None] LPD3DXUVATLASCB pStatusCallback,[None] void* pUserContext,[None] LPD3DXBUFFER* ppIMTData)</unmanaged>
		public static SlimDX2.Result D3DXComputeIMTFromTexture(SlimDX2.Direct3D9.ID3DXMesh pMesh, SlimDX2.Direct3D9.Texture pTexture, int dwTextureIndex, int dwOptions, SlimDX2.FunctionCallback pStatusCallback, IntPtr userContextRef, out SlimDX2.Direct3D9.ShaderBytecode iMTDataRef) {
            unsafe {
                IntPtr iMTDataRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeIMTFromTexture_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer, (pTexture == null)?IntPtr.Zero:pTexture.NativePointer,  dwTextureIndex,  dwOptions,  pStatusCallback,  userContextRef, out iMTDataRef_);
                iMTDataRef = (iMTDataRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(iMTDataRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeIMTFromTexture([None] LPD3DXMESH pMesh,[None] LPDIRECT3DTEXTURE9 pTexture,[None] int dwTextureIndex,[None] int dwOptions,[None] LPD3DXUVATLASCB pStatusCallback,[None] void* pUserContext,[None] LPD3DXBUFFER* ppIMTData)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeIMTFromTexture", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeIMTFromTexture_(IntPtr pMesh, IntPtr pTexture, int dwTextureIndex, int dwOptions, SlimDX2.FunctionCallback pStatusCallback, IntPtr userContextRef, out IntPtr iMTDataRef);		
        
        /// <summary>	
        /// Calculate per-triangle IMT's from per-texel data. This function is similar to <see cref="SlimDX2.Direct3D9.D3DX9.D3DXComputeIMTFromTexture"/>, but it uses a float array to pass in the data, and it can calculate higher dimensional values than 4.	
        /// </summary>	
        /// <param name="pMesh"> A pointer to an input mesh (see <see cref="SlimDX2.Direct3D9.ID3DXMesh"/>) which contains the object geometry for calculating the IMT. </param>
        /// <param name="dwTextureIndex"> Zero-based texture coordinate index that identifies which set of texture coordinates to use. </param>
        /// <param name="fTexelSignalRef"> A pointer to an array of input texels from which IMT will be computed. The array size is uWidth*uHeight*uComponents. </param>
        /// <param name="uWidth"> Texture width in pixels. </param>
        /// <param name="uHeight"> Texture height in pixels. </param>
        /// <param name="uSignalDimension"> The number of floats per-component in each element of the signal array. </param>
        /// <param name="uComponents"> The number of components in each texel. </param>
        /// <param name="dwOptions"> Texture wrap options. This is a combination of one or more {{D3DXIMT FLAGS}}. </param>
        /// <param name="pStatusCallback"> A pointer to a callback function to monitor IMT computation progress. </param>
        /// <param name="userContextRef"> A pointer to a user-defined variable which is passed to the status callback function. Typically used by an application to pass a pointer to a data structure that provides context information for the callback function. </param>
        /// <param name="iMTDataRef"> A pointer to the buffer (see <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>) containing the returned IMT array. This array can be provided as input to the D3DX {{UVAtlas Functions}} to prioritize texture-space allocation in the texture parameterization. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK; otherwise, the value is D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXComputeIMTFromPerTexelSignal([None] LPD3DXMESH pMesh,[None] int dwTextureIndex,[None] float* pfTexelSignal,[None] int uWidth,[None] int uHeight,[None] int uSignalDimension,[None] int uComponents,[None] int dwOptions,[None] LPD3DXUVATLASCB pStatusCallback,[None] void* pUserContext,[None] LPD3DXBUFFER* ppIMTData)</unmanaged>
		public static SlimDX2.Result D3DXComputeIMTFromPerTexelSignal(SlimDX2.Direct3D9.ID3DXMesh pMesh, int dwTextureIndex, ref float fTexelSignalRef, int uWidth, int uHeight, int uSignalDimension, int uComponents, int dwOptions, SlimDX2.FunctionCallback pStatusCallback, IntPtr userContextRef, out SlimDX2.Direct3D9.ShaderBytecode iMTDataRef) {
            unsafe {
                IntPtr iMTDataRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeIMTFromPerTexelSignal_((pMesh == null)?IntPtr.Zero:pMesh.NativePointer,  dwTextureIndex, ref  fTexelSignalRef,  uWidth,  uHeight,  uSignalDimension,  uComponents,  dwOptions,  pStatusCallback,  userContextRef, out iMTDataRef_);
                iMTDataRef = (iMTDataRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(iMTDataRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeIMTFromPerTexelSignal([None] LPD3DXMESH pMesh,[None] int dwTextureIndex,[None] float* pfTexelSignal,[None] int uWidth,[None] int uHeight,[None] int uSignalDimension,[None] int uComponents,[None] int dwOptions,[None] LPD3DXUVATLASCB pStatusCallback,[None] void* pUserContext,[None] LPD3DXBUFFER* ppIMTData)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeIMTFromPerTexelSignal", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeIMTFromPerTexelSignal_(IntPtr pMesh, int dwTextureIndex, ref float fTexelSignalRef, int uWidth, int uHeight, int uSignalDimension, int uComponents, int dwOptions, SlimDX2.FunctionCallback pStatusCallback, IntPtr userContextRef, out IntPtr iMTDataRef);		
        
        /// <summary>	
        /// Converts the specified mesh subset into a single triangle strip.	
        /// </summary>	
        /// <remarks>	
        ///  Before running this function, call {{Optimize}} or <see cref="SlimDX2.Direct3D9.D3DX9.D3DXOptimizeFaces"/>, with the D3DXMESHOPT_ATTRSORT flag set. 	
        /// </remarks>	
        /// <param name="meshIn"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXBaseMesh"/> interface, representing the mesh to convert to a strip. </param>
        /// <param name="attribId"> Attribute ID of the mesh subset to convert to strips. </param>
        /// <param name="iBOptions"> Combination of one or more flags from the {{D3DXMESH}} enumeration, specifying options for creating the index buffer. Cannot be D3DXMESH_32BIT. The index buffer will be created with 32-bit or 16-bit indices, depending on the format of the index buffer of the mesh specified by the MeshIn parameter. </param>
        /// <param name="indexBufferRef"> Pointer to an <see cref="SlimDX2.Direct3D9.IndexBuffer"/> interface, representing the index buffer containing the strip. </param>
        /// <param name="numIndicesRef"> Number of indices in the buffer returned in the ppIndexBuffer parameter. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXConvertMeshSubsetToSingleStrip([None] LPD3DXBASEMESH MeshIn,[None] int AttribId,[None] int IBOptions,[None] LPDIRECT3DINDEXBUFFER9* ppIndexBuffer,[None] int* pNumIndices)</unmanaged>
		public static SlimDX2.Result D3DXConvertMeshSubsetToSingleStrip(SlimDX2.Direct3D9.ID3DXBaseMesh meshIn, int attribId, int iBOptions, out SlimDX2.Direct3D9.IndexBuffer indexBufferRef, ref int numIndicesRef) {
            unsafe {
                IntPtr indexBufferRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXConvertMeshSubsetToSingleStrip_((meshIn == null)?IntPtr.Zero:meshIn.NativePointer,  attribId,  iBOptions, out indexBufferRef_, ref  numIndicesRef);
                indexBufferRef = (indexBufferRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.IndexBuffer(indexBufferRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXConvertMeshSubsetToSingleStrip([None] LPD3DXBASEMESH MeshIn,[None] int AttribId,[None] int IBOptions,[None] LPDIRECT3DINDEXBUFFER9* ppIndexBuffer,[None] int* pNumIndices)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXConvertMeshSubsetToSingleStrip", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXConvertMeshSubsetToSingleStrip_(IntPtr meshIn, int attribId, int iBOptions, out IntPtr indexBufferRef, ref int numIndicesRef);		
        
        /// <summary>	
        /// Convert the specified mesh subset into a series of strips.	
        /// </summary>	
        /// <remarks>	
        ///  Before running this function, call {{Optimize}} or <see cref="SlimDX2.Direct3D9.D3DX9.D3DXOptimizeFaces"/>, with the D3DXMESHOPT_ATTRSORT flag set. 	
        /// </remarks>	
        /// <param name="meshIn"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXBaseMesh"/> interface, representing the mesh to convert to a strip. </param>
        /// <param name="attribId"> Attribute ID of the mesh subset to convert to strips. </param>
        /// <param name="iBOptions"> Combination of one or more flags from the {{D3DXMESH}} enumeration, specifying options for creating the index buffer. Cannot be D3DXMESH_32BIT. The index buffer will be created with 32-bit or 16-bit indices depending on the format of the index buffer of the mesh specified by the MeshIn parameter. </param>
        /// <param name="indexBufferRef"> Pointer to an <see cref="SlimDX2.Direct3D9.IndexBuffer"/> interface, representing index buffer containing the strip. </param>
        /// <param name="numIndicesRef"> Number of indices in the buffer returned in the ppIndexBuffer parameter. </param>
        /// <param name="stripLengthsRef"> Buffer containing an array of one DWORD per strip, which specifies the number of triangles in the that strip. </param>
        /// <param name="numStripsRef"> Number of individual strips in the index buffer and corresponding strip length array. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXConvertMeshSubsetToStrips([None] LPD3DXBASEMESH MeshIn,[None] int AttribId,[None] int IBOptions,[None] LPDIRECT3DINDEXBUFFER9* ppIndexBuffer,[None] int* pNumIndices,[None] LPD3DXBUFFER* ppStripLengths,[None] int* pNumStrips)</unmanaged>
		public static SlimDX2.Result D3DXConvertMeshSubsetToStrips(SlimDX2.Direct3D9.ID3DXBaseMesh meshIn, int attribId, int iBOptions, out SlimDX2.Direct3D9.IndexBuffer indexBufferRef, ref int numIndicesRef, out SlimDX2.Direct3D9.ShaderBytecode stripLengthsRef, ref int numStripsRef) {
            unsafe {
                IntPtr indexBufferRef_ = IntPtr.Zero;
                IntPtr stripLengthsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXConvertMeshSubsetToStrips_((meshIn == null)?IntPtr.Zero:meshIn.NativePointer,  attribId,  iBOptions, out indexBufferRef_, ref  numIndicesRef, out stripLengthsRef_, ref  numStripsRef);
                indexBufferRef = (indexBufferRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.IndexBuffer(indexBufferRef_);
                stripLengthsRef = (stripLengthsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(stripLengthsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXConvertMeshSubsetToStrips([None] LPD3DXBASEMESH MeshIn,[None] int AttribId,[None] int IBOptions,[None] LPDIRECT3DINDEXBUFFER9* ppIndexBuffer,[None] int* pNumIndices,[None] LPD3DXBUFFER* ppStripLengths,[None] int* pNumStrips)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXConvertMeshSubsetToStrips", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXConvertMeshSubsetToStrips_(IntPtr meshIn, int attribId, int iBOptions, out IntPtr indexBufferRef, ref int numIndicesRef, out IntPtr stripLengthsRef, ref int numStripsRef);		
        
        /// <summary>	
        /// Generates an optimized face remapping for a triangle list.	
        /// </summary>	
        /// <remarks>	
        ///  This function's optimization procedure is functionally equivalent to calling <see cref="SlimDX2.Direct3D9.ID3DXMesh.Optimize"/> with the D3DXMESHOPT_DEVICEINDEPENDENT flag, but this function makes more efficient use of vertex caches. 	
        /// </remarks>	
        /// <param name="bIndicesRef"> Pointer to triangle list indices to use for ordering vertices. </param>
        /// <param name="cFaces"> Number of faces in the triangle list. For 16-bit meshes, this is limited to 2^16 - 1 (65535) or fewer faces. </param>
        /// <param name="cVertices"> Number of vertices referenced by the triangle list. </param>
        /// <param name="b32BitIndices"> Flag indicating index type: TRUE if indices are 32-bit (more than 65535 indices), FALSE if indices are 16-bit (65535 or fewer indices). </param>
        /// <param name="faceRemapRef"> Pointer to the original mesh face that was split to generate the current face. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXOptimizeFaces([None] const void* pbIndices,[None] int cFaces,[None] int cVertices,[None] BOOL b32BitIndices,[None] int* pFaceRemap)</unmanaged>
		public static SlimDX2.Result D3DXOptimizeFaces(IntPtr bIndicesRef, int cFaces, int cVertices, bool b32BitIndices, ref int faceRemapRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXOptimizeFaces_( bIndicesRef,  cFaces,  cVertices,  b32BitIndices, ref  faceRemapRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXOptimizeFaces([None] const void* pbIndices,[None] int cFaces,[None] int cVertices,[None] BOOL b32BitIndices,[None] int* pFaceRemap)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXOptimizeFaces", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXOptimizeFaces_(IntPtr bIndicesRef, int cFaces, int cVertices, bool b32BitIndices, ref int faceRemapRef);		
        
        /// <summary>	
        /// Generates an optimized vertex remapping for a triangle list. This function is commonly used after applying the face remapping generated by <see cref="SlimDX2.Direct3D9.D3DX9.D3DXOptimizeFaces"/>.	
        /// </summary>	
        /// <remarks>	
        ///  By default, a mesh uses 16 bit indices when it is created unless the application specifies otherwise. To check whether an existing mesh uses 16-bit or 32-bit indices, call <see cref="SlimDX2.Direct3D9.ID3DXBaseMesh.GetOptions"/> and check for the D3DXMESH_32BIT flag. 	
        /// </remarks>	
        /// <param name="bIndicesRef"> Pointer to triangle list indices to use for ordering vertices. </param>
        /// <param name="cFaces"> Number of faces in the triangle list. </param>
        /// <param name="cVertices"> Number of vertices referenced by the triangle list. </param>
        /// <param name="b32BitIndices"> Flag indicating index type: TRUE if indices are 32-bit (more than 65535 vertices), FALSE if indices are 16-bit (65535 or fewer vertices). </param>
        /// <param name="vertexRemapRef"> Pointer to a destination buffer that will contain the new index for each vertex. The value stored in pVertexRemap for a given element is the source vertex location in the new vertex ordering. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXOptimizeVertices([None] const void* pbIndices,[None] int cFaces,[None] int cVertices,[None] BOOL b32BitIndices,[None] int* pVertexRemap)</unmanaged>
		public static SlimDX2.Result D3DXOptimizeVertices(IntPtr bIndicesRef, int cFaces, int cVertices, bool b32BitIndices, ref int vertexRemapRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXOptimizeVertices_( bIndicesRef,  cFaces,  cVertices,  b32BitIndices, ref  vertexRemapRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXOptimizeVertices([None] const void* pbIndices,[None] int cFaces,[None] int cVertices,[None] BOOL b32BitIndices,[None] int* pVertexRemap)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXOptimizeVertices", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXOptimizeVertices_(IntPtr bIndicesRef, int cFaces, int cVertices, bool b32BitIndices, ref int vertexRemapRef);		
        
        /// <summary>	
        /// Concatenates a group of meshes into one common mesh. This method can optionally apply a matrix transformation to each input mesh and its texture coordinates.	
        /// </summary>	
        /// <remarks>	
        ///  If no {{vertex declaration}} is given as part of the Options mesh creation parameter, the method will generate a union of all of the vertex declarations of the submeshes, promoting channels and types if necessary. The method will create an attribute table from attribute tables of the input meshes. To ensure creation of an attribute table, call {{Optimize}} with Flags set to D3DXMESHOPT_COMPACT and D3DXMESHOPT_ATTRSORT (see {{D3DXMESHOPT}}). 	
        /// </remarks>	
        /// <param name="meshesRef"> Array of input mesh pointers (see <see cref="SlimDX2.Direct3D9.ID3DXMesh"/>). The number of elements in the array is NumMeshes. </param>
        /// <param name="numMeshes"> Number of input meshes to concatenate. </param>
        /// <param name="options"> Mesh creation options; this is a combination of one or more {{D3DXMESH}} flags. The mesh creation options are equivalent to the options parameter required by <see cref="SlimDX2.Direct3D9.D3DX9.D3DXCreateMesh"/>. </param>
        /// <param name="geomXFormsRef"> Optional array of geometry transforms. The number of elements in the array is NumMeshes; each element is a transformation matrix (see <see cref="SlimMath.Matrix"/>). May be NULL. </param>
        /// <param name="textureXFormsRef"> Optional array of texture transforms. The number of elements in the array is NumMeshes; each element is a transformation matrix (see <see cref="SlimMath.Matrix"/>). This parameter may be NULL. </param>
        /// <param name="declRef"> Optional pointer to a vertex declaration (see <see cref="SlimDX2.Direct3D9.VertexElement"/>). This parameter may be NULL. </param>
        /// <param name="pD3DDevice"> Pointer to a <see cref="SlimDX2.Direct3D9.Device"/> device that is used to create the new mesh. </param>
        /// <param name="meshOutRef"> Address of a pointer to the mesh created (see <see cref="SlimDX2.Direct3D9.ID3DXMesh"/>). </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of these: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXConcatenateMeshes([None] LPD3DXMESH* ppMeshes,[None] int NumMeshes,[None] int Options,[None] const D3DXMATRIX* pGeomXForms,[None] const D3DXMATRIX* pTextureXForms,[None] const D3DVERTEXELEMENT9* pDecl,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXMESH* ppMeshOut)</unmanaged>
		public static SlimDX2.Result D3DXConcatenateMeshes(out SlimDX2.Direct3D9.ID3DXMesh meshesRef, int numMeshes, int options, ref SlimMath.Matrix geomXFormsRef, ref SlimMath.Matrix textureXFormsRef, ref SlimDX2.Direct3D9.VertexElement declRef, SlimDX2.Direct3D9.Device pD3DDevice, out SlimDX2.Direct3D9.ID3DXMesh meshOutRef) {
            unsafe {
                IntPtr meshesRef_ = IntPtr.Zero;
                IntPtr meshOutRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXConcatenateMeshes_(out meshesRef_,  numMeshes,  options, ref  geomXFormsRef, ref  textureXFormsRef, ref  declRef, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, out meshOutRef_);
                meshesRef = (meshesRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshesRef_);
                meshOutRef = (meshOutRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshOutRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXConcatenateMeshes([None] LPD3DXMESH* ppMeshes,[None] int NumMeshes,[None] int Options,[None] const D3DXMATRIX* pGeomXForms,[None] const D3DXMATRIX* pTextureXForms,[None] const D3DVERTEXELEMENT9* pDecl,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXMESH* ppMeshOut)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXConcatenateMeshes", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXConcatenateMeshes_(out IntPtr meshesRef, int numMeshes, int options, ref SlimMath.Matrix geomXFormsRef, ref SlimMath.Matrix textureXFormsRef, ref SlimDX2.Direct3D9.VertexElement declRef, IntPtr pD3DDevice, out IntPtr meshOutRef);		
        
        /// <summary>	
        /// Assemble a shader.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXAssembleShaderFromFileW. Otherwise, the function call resolves to D3DXAssembleShaderFromFileA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="definesRef"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="shaderRef"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="errorMsgsRef"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXAssembleShaderFromFileA([None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result D3DXAssembleShaderFromFileA(string srcFileRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, int flags, out SlimDX2.Direct3D9.ShaderBytecode shaderRef, out SlimDX2.Direct3D9.ShaderBytecode errorMsgsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr shaderRef_ = IntPtr.Zero;
                IntPtr errorMsgsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXAssembleShaderFromFileA_( srcFileRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out shaderRef_, out errorMsgsRef_);
                shaderRef = (shaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(shaderRef_);
                errorMsgsRef = (errorMsgsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorMsgsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXAssembleShaderFromFileA([None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXAssembleShaderFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXAssembleShaderFromFileA_([MarshalAs(UnmanagedType.LPStr),In] string srcFileRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, int flags, out IntPtr shaderRef, out IntPtr errorMsgsRef);		
        
        /// <summary>	
        /// Assemble a shader.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXAssembleShaderFromFileW. Otherwise, the function call resolves to D3DXAssembleShaderFromFileA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="definesRef"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="shaderRef"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="errorMsgsRef"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXAssembleShaderFromFileW([None] const wchar_t* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result D3DXAssembleShaderFromFileW(string srcFileRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, int flags, out SlimDX2.Direct3D9.ShaderBytecode shaderRef, out SlimDX2.Direct3D9.ShaderBytecode errorMsgsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr shaderRef_ = IntPtr.Zero;
                IntPtr errorMsgsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXAssembleShaderFromFileW_( srcFileRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out shaderRef_, out errorMsgsRef_);
                shaderRef = (shaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(shaderRef_);
                errorMsgsRef = (errorMsgsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorMsgsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXAssembleShaderFromFileW([None] const wchar_t* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXAssembleShaderFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXAssembleShaderFromFileW_([MarshalAs(UnmanagedType.LPWStr),In] string srcFileRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, int flags, out IntPtr shaderRef, out IntPtr errorMsgsRef);		
        
        /// <summary>	
        /// Assemble a shader.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXAssembleShaderFromResourceW. Otherwise, the function call resolves to D3DXAssembleShaderFromResourceA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="definesRef"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="shaderRef"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="errorMsgsRef"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXAssembleShaderFromResourceA([None] void* hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result D3DXAssembleShaderFromResourceA(IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, int flags, out SlimDX2.Direct3D9.ShaderBytecode shaderRef, out SlimDX2.Direct3D9.ShaderBytecode errorMsgsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr shaderRef_ = IntPtr.Zero;
                IntPtr errorMsgsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXAssembleShaderFromResourceA_( hSrcModule,  srcResourceRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out shaderRef_, out errorMsgsRef_);
                shaderRef = (shaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(shaderRef_);
                errorMsgsRef = (errorMsgsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorMsgsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXAssembleShaderFromResourceA([None] void* hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXAssembleShaderFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXAssembleShaderFromResourceA_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string srcResourceRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, int flags, out IntPtr shaderRef, out IntPtr errorMsgsRef);		
        
        /// <summary>	
        /// Assemble a shader.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXAssembleShaderFromResourceW. Otherwise, the function call resolves to D3DXAssembleShaderFromResourceA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="definesRef"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="shaderRef"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="errorMsgsRef"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXAssembleShaderFromResourceW([None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result D3DXAssembleShaderFromResourceW(IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, int flags, out SlimDX2.Direct3D9.ShaderBytecode shaderRef, out SlimDX2.Direct3D9.ShaderBytecode errorMsgsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr shaderRef_ = IntPtr.Zero;
                IntPtr errorMsgsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXAssembleShaderFromResourceW_( hSrcModule,  srcResourceRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out shaderRef_, out errorMsgsRef_);
                shaderRef = (shaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(shaderRef_);
                errorMsgsRef = (errorMsgsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorMsgsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXAssembleShaderFromResourceW([None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXAssembleShaderFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXAssembleShaderFromResourceW_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string srcResourceRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, int flags, out IntPtr shaderRef, out IntPtr errorMsgsRef);		
        
        /// <summary>	
        /// Assemble a shader.	
        /// </summary>	
        /// <param name="srcDataRef"> Pointer to a memory buffer that contains the shader data. </param>
        /// <param name="srcDataLen"> Length of the effect data, in bytes. </param>
        /// <param name="definesRef"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="shaderRef"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information. </param>
        /// <param name="errorMsgsRef"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXAssembleShader([None] const char* pSrcData,[None] int SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result D3DXAssembleShader(string srcDataRef, int srcDataLen, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, int flags, out SlimDX2.Direct3D9.ShaderBytecode shaderRef, out SlimDX2.Direct3D9.ShaderBytecode errorMsgsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr shaderRef_ = IntPtr.Zero;
                IntPtr errorMsgsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXAssembleShader_( srcDataRef,  srcDataLen, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out shaderRef_, out errorMsgsRef_);
                shaderRef = (shaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(shaderRef_);
                errorMsgsRef = (errorMsgsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorMsgsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXAssembleShader([None] const char* pSrcData,[None] int SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXAssembleShader", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXAssembleShader_([MarshalAs(UnmanagedType.LPStr),In] string srcDataRef, int srcDataLen, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, int flags, out IntPtr shaderRef, out IntPtr errorMsgsRef);		
        
        /// <summary>	
        /// Compile a shader file.	
        /// </summary>	
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. </param>
        /// <param name="definesRef"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="functionNameRef"> Pointer to the shader entry point function where execution begins. </param>
        /// <param name="rofileRef"> Pointer to a shader profile which determines the shader instruction set. See {{D3DXGetVertexShaderProfile}} or {{D3DXGetPixelShaderProfile}} for a list of the profiles available. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="shaderRef"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="errorMsgsRef"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <param name="constantTableRef"> Returns an <see cref="SlimDX2.Direct3D9.ID3DXConstantTable"/> interface, which can be used to access shader constants. This value can be NULL. If you compile your application as large address aware (that is, you use the /LARGEADDRESSAWARE linker option to handle addresses larger than 2 GB), you cannot use this parameter and must set it to NULL. Instead, you must use the <see cref="SlimDX2.Direct3D9.D3DX9.D3DXGetShaderConstantTableEx"/> function to retrieve the shader-constant table that is embedded inside the shader. In this D3DXGetShaderConstantTableEx call, you must pass the D3DXCONSTTABLE_LARGEADDRESSAWARE flag to the Flags parameter to specify to access up to 4 GB of virtual address space. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCompileShaderFromFileA([None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		public static SlimDX2.Result D3DXCompileShaderFromFileA(string srcFileRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, string functionNameRef, string rofileRef, int flags, out SlimDX2.Direct3D9.ShaderBytecode shaderRef, out SlimDX2.Direct3D9.ShaderBytecode errorMsgsRef, out SlimDX2.Direct3D9.ID3DXConstantTable constantTableRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr shaderRef_ = IntPtr.Zero;
                IntPtr errorMsgsRef_ = IntPtr.Zero;
                IntPtr constantTableRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCompileShaderFromFileA_( srcFileRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  functionNameRef,  rofileRef,  flags, out shaderRef_, out errorMsgsRef_, out constantTableRef_);
                shaderRef = (shaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(shaderRef_);
                errorMsgsRef = (errorMsgsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorMsgsRef_);
                constantTableRef = (constantTableRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXConstantTable(constantTableRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCompileShaderFromFileA([None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCompileShaderFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCompileShaderFromFileA_([MarshalAs(UnmanagedType.LPStr),In] string srcFileRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, [MarshalAs(UnmanagedType.LPStr),In] string functionNameRef, [MarshalAs(UnmanagedType.LPStr),In] string rofileRef, int flags, out IntPtr shaderRef, out IntPtr errorMsgsRef, out IntPtr constantTableRef);		
        
        /// <summary>	
        /// Compile a shader file.	
        /// </summary>	
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. </param>
        /// <param name="definesRef"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="functionNameRef"> Pointer to the shader entry point function where execution begins. </param>
        /// <param name="rofileRef"> Pointer to a shader profile which determines the shader instruction set. See {{D3DXGetVertexShaderProfile}} or {{D3DXGetPixelShaderProfile}} for a list of the profiles available. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="shaderRef"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="errorMsgsRef"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <param name="constantTableRef"> Returns an <see cref="SlimDX2.Direct3D9.ID3DXConstantTable"/> interface, which can be used to access shader constants. This value can be NULL. If you compile your application as large address aware (that is, you use the /LARGEADDRESSAWARE linker option to handle addresses larger than 2 GB), you cannot use this parameter and must set it to NULL. Instead, you must use the <see cref="SlimDX2.Direct3D9.D3DX9.D3DXGetShaderConstantTableEx"/> function to retrieve the shader-constant table that is embedded inside the shader. In this D3DXGetShaderConstantTableEx call, you must pass the D3DXCONSTTABLE_LARGEADDRESSAWARE flag to the Flags parameter to specify to access up to 4 GB of virtual address space. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCompileShaderFromFileW([None] const wchar_t* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		public static SlimDX2.Result D3DXCompileShaderFromFileW(string srcFileRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, string functionNameRef, string rofileRef, int flags, out SlimDX2.Direct3D9.ShaderBytecode shaderRef, out SlimDX2.Direct3D9.ShaderBytecode errorMsgsRef, out SlimDX2.Direct3D9.ID3DXConstantTable constantTableRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr shaderRef_ = IntPtr.Zero;
                IntPtr errorMsgsRef_ = IntPtr.Zero;
                IntPtr constantTableRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCompileShaderFromFileW_( srcFileRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  functionNameRef,  rofileRef,  flags, out shaderRef_, out errorMsgsRef_, out constantTableRef_);
                shaderRef = (shaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(shaderRef_);
                errorMsgsRef = (errorMsgsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorMsgsRef_);
                constantTableRef = (constantTableRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXConstantTable(constantTableRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCompileShaderFromFileW([None] const wchar_t* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCompileShaderFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCompileShaderFromFileW_([MarshalAs(UnmanagedType.LPWStr),In] string srcFileRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, [MarshalAs(UnmanagedType.LPWStr),In] string functionNameRef, [MarshalAs(UnmanagedType.LPWStr),In] string rofileRef, int flags, out IntPtr shaderRef, out IntPtr errorMsgsRef, out IntPtr constantTableRef);		
        
        /// <summary>	
        /// Compile a shader file.	
        /// </summary>	
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. </param>
        /// <param name="definesRef"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file, or will error when compiled from a resource or memory. </param>
        /// <param name="functionNameRef"> Pointer to the shader entry point function where execution begins. </param>
        /// <param name="rofileRef"> Pointer to a shader profile which determines the shader instruction set. See {{D3DXGetVertexShaderProfile}} or {{D3DXGetPixelShaderProfile}} for a list of the profiles available. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="shaderRef"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="errorMsgsRef"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <param name="constantTableRef"> Returns an <see cref="SlimDX2.Direct3D9.ID3DXConstantTable"/> interface, which can be used to access shader constants. This value can be NULL. If you compile your application as large address aware (that is, you use the /LARGEADDRESSAWARE linker option to handle addresses larger than 2 GB), you cannot use this parameter and must set it to NULL. Instead, you must use the <see cref="SlimDX2.Direct3D9.D3DX9.D3DXGetShaderConstantTableEx"/> function to retrieve the shader-constant table that is embedded inside the shader. In this D3DXGetShaderConstantTableEx call, you must pass the D3DXCONSTTABLE_LARGEADDRESSAWARE flag to the Flags parameter to specify to access up to 4 GB of virtual address space. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCompileShaderFromResourceA([None] void* hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		public static SlimDX2.Result D3DXCompileShaderFromResourceA(IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, string functionNameRef, string rofileRef, int flags, out SlimDX2.Direct3D9.ShaderBytecode shaderRef, out SlimDX2.Direct3D9.ShaderBytecode errorMsgsRef, out SlimDX2.Direct3D9.ID3DXConstantTable constantTableRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr shaderRef_ = IntPtr.Zero;
                IntPtr errorMsgsRef_ = IntPtr.Zero;
                IntPtr constantTableRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCompileShaderFromResourceA_( hSrcModule,  srcResourceRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  functionNameRef,  rofileRef,  flags, out shaderRef_, out errorMsgsRef_, out constantTableRef_);
                shaderRef = (shaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(shaderRef_);
                errorMsgsRef = (errorMsgsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorMsgsRef_);
                constantTableRef = (constantTableRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXConstantTable(constantTableRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCompileShaderFromResourceA([None] void* hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCompileShaderFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCompileShaderFromResourceA_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string srcResourceRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, [MarshalAs(UnmanagedType.LPStr),In] string functionNameRef, [MarshalAs(UnmanagedType.LPStr),In] string rofileRef, int flags, out IntPtr shaderRef, out IntPtr errorMsgsRef, out IntPtr constantTableRef);		
        
        /// <summary>	
        /// Compile a shader file.	
        /// </summary>	
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. </param>
        /// <param name="definesRef"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file, or will error when compiled from a resource or memory. </param>
        /// <param name="functionNameRef"> Pointer to the shader entry point function where execution begins. </param>
        /// <param name="rofileRef"> Pointer to a shader profile which determines the shader instruction set. See {{D3DXGetVertexShaderProfile}} or {{D3DXGetPixelShaderProfile}} for a list of the profiles available. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="shaderRef"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="errorMsgsRef"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be NULL. </param>
        /// <param name="constantTableRef"> Returns an <see cref="SlimDX2.Direct3D9.ID3DXConstantTable"/> interface, which can be used to access shader constants. This value can be NULL. If you compile your application as large address aware (that is, you use the /LARGEADDRESSAWARE linker option to handle addresses larger than 2 GB), you cannot use this parameter and must set it to NULL. Instead, you must use the <see cref="SlimDX2.Direct3D9.D3DX9.D3DXGetShaderConstantTableEx"/> function to retrieve the shader-constant table that is embedded inside the shader. In this D3DXGetShaderConstantTableEx call, you must pass the D3DXCONSTTABLE_LARGEADDRESSAWARE flag to the Flags parameter to specify to access up to 4 GB of virtual address space. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCompileShaderFromResourceW([None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		public static SlimDX2.Result D3DXCompileShaderFromResourceW(IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, string functionNameRef, string rofileRef, int flags, out SlimDX2.Direct3D9.ShaderBytecode shaderRef, out SlimDX2.Direct3D9.ShaderBytecode errorMsgsRef, out SlimDX2.Direct3D9.ID3DXConstantTable constantTableRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr shaderRef_ = IntPtr.Zero;
                IntPtr errorMsgsRef_ = IntPtr.Zero;
                IntPtr constantTableRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCompileShaderFromResourceW_( hSrcModule,  srcResourceRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  functionNameRef,  rofileRef,  flags, out shaderRef_, out errorMsgsRef_, out constantTableRef_);
                shaderRef = (shaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(shaderRef_);
                errorMsgsRef = (errorMsgsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorMsgsRef_);
                constantTableRef = (constantTableRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXConstantTable(constantTableRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCompileShaderFromResourceW([None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCompileShaderFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCompileShaderFromResourceW_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string srcResourceRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, [MarshalAs(UnmanagedType.LPWStr),In] string functionNameRef, [MarshalAs(UnmanagedType.LPWStr),In] string rofileRef, int flags, out IntPtr shaderRef, out IntPtr errorMsgsRef, out IntPtr constantTableRef);		
        
        /// <summary>	
        /// Compile a shader file.	
        /// </summary>	
        /// <param name="srcDataRef"> Pointer to a string that contains the shader. </param>
        /// <param name="srcDataLen"> Length of the data in bytes. </param>
        /// <param name="definesRef"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="functionNameRef"> Pointer to a string that contains the name of the shader entry point function where execution begins. </param>
        /// <param name="rofileRef"> Pointer to a shader profile which determines the shader instruction set. See {{D3DXGetVertexShaderProfile}} or {{D3DXGetPixelShaderProfile}} for a list of the profiles available. </param>
        /// <param name="flags"> Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See {{D3DXSHADER Flags}} for details. </param>
        /// <param name="shaderRef"> Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.   </param>
        /// <param name="errorMsgsRef"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode.  This value may be NULL. </param>
        /// <param name="constantTableRef"> Returns an <see cref="SlimDX2.Direct3D9.ID3DXConstantTable"/> interface, which can be used to access shader constants. This value can be NULL. If you compile your application as large address aware (that is, you use the /LARGEADDRESSAWARE linker option to handle addresses larger than 2 GB), you cannot use this parameter and must set it to NULL. Instead, you must use the <see cref="SlimDX2.Direct3D9.D3DX9.D3DXGetShaderConstantTableEx"/> function to retrieve the shader-constant table that is embedded inside the shader. In this D3DXGetShaderConstantTableEx call, you must pass the D3DXCONSTTABLE_LARGEADDRESSAWARE flag to the Flags parameter to specify to access up to 4 GB of virtual address space. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCompileShader([None] const char* pSrcData,[None] int SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		public static SlimDX2.Result D3DXCompileShader(string srcDataRef, int srcDataLen, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, string functionNameRef, string rofileRef, int flags, out SlimDX2.Direct3D9.ShaderBytecode shaderRef, out SlimDX2.Direct3D9.ShaderBytecode errorMsgsRef, out SlimDX2.Direct3D9.ID3DXConstantTable constantTableRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr shaderRef_ = IntPtr.Zero;
                IntPtr errorMsgsRef_ = IntPtr.Zero;
                IntPtr constantTableRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCompileShader_( srcDataRef,  srcDataLen, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  functionNameRef,  rofileRef,  flags, out shaderRef_, out errorMsgsRef_, out constantTableRef_);
                shaderRef = (shaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(shaderRef_);
                errorMsgsRef = (errorMsgsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorMsgsRef_);
                constantTableRef = (constantTableRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXConstantTable(constantTableRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCompileShader([None] const char* pSrcData,[None] int SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pFunctionName,[None] const char* pProfile,[None] int Flags,[None] LPD3DXBUFFER* ppShader,[None] LPD3DXBUFFER* ppErrorMsgs,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCompileShader", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCompileShader_([MarshalAs(UnmanagedType.LPStr),In] string srcDataRef, int srcDataLen, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, [MarshalAs(UnmanagedType.LPStr),In] string functionNameRef, [MarshalAs(UnmanagedType.LPStr),In] string rofileRef, int flags, out IntPtr shaderRef, out IntPtr errorMsgsRef, out IntPtr constantTableRef);		
        
        /// <summary>	
        /// Disassemble a shader.	
        /// </summary>	
        /// <param name="shaderRef"> Pointer to a memory buffer that contains the shader data. </param>
        /// <param name="enableColorCode"> Enable color code to make it easier to read the disassembly. </param>
        /// <param name="commentsRef"> An optional NULL-terminated comment string. This value may be NULL. </param>
        /// <param name="disassemblyRef"> Returns a buffer containing the disassembled shader. See <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXDisassembleShader([None] const int* pShader,[None] BOOL EnableColorCode,[None] const char* pComments,[None] LPD3DXBUFFER* ppDisassembly)</unmanaged>
		public static SlimDX2.Result D3DXDisassembleShader(ref int shaderRef, bool enableColorCode, string commentsRef, out SlimDX2.Direct3D9.ShaderBytecode disassemblyRef) {
            unsafe {
                IntPtr disassemblyRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXDisassembleShader_(ref  shaderRef,  enableColorCode,  commentsRef, out disassemblyRef_);
                disassemblyRef = (disassemblyRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(disassemblyRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXDisassembleShader([None] const int* pShader,[None] BOOL EnableColorCode,[None] const char* pComments,[None] LPD3DXBUFFER* ppDisassembly)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXDisassembleShader", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXDisassembleShader_(ref int shaderRef, bool enableColorCode, [MarshalAs(UnmanagedType.LPStr),In] string commentsRef, out IntPtr disassemblyRef);		
        
        /// <summary>	
        /// Searches through a shader for a particular comment. The comment is identified by a four-character code (FOURCC) in the first DWORD of the comment.	
        /// </summary>	
        /// <param name="functionRef"> Pointer to the shader function DWORD stream. </param>
        /// <param name="fourCC"> FOURCC code that identifies the comment block. See {{FourCC Formats}}. </param>
        /// <param name="dataRef"> Returns a pointer to the comment data (not including the comment token and FOURCC code). This value can be NULL. </param>
        /// <param name="sizeInBytesRef"> Returns the size of the comment data in bytes. This value can be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the comment is not found, and no other error has occurred, S_FALSE is returned. </returns>
        /// <unmanaged>HRESULT D3DXFindShaderComment([None] const int* pFunction,[None] int FourCC,[None] const void** ppData,[None] int* pSizeInBytes)</unmanaged>
		public static SlimDX2.Result D3DXFindShaderComment(ref int functionRef, int fourCC, IntPtr dataRef, ref int sizeInBytesRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFindShaderComment_(ref  functionRef,  fourCC,  dataRef, ref  sizeInBytesRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFindShaderComment([None] const int* pFunction,[None] int FourCC,[None] const void** ppData,[None] int* pSizeInBytes)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFindShaderComment", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFindShaderComment_(ref int functionRef, int fourCC, IntPtr dataRef, ref int sizeInBytesRef);		
        
        /// <summary>	
        /// Returns the shader version of the compiled shader.	
        /// </summary>	
        /// <param name="functionRef"> Pointer to the function DWORD stream. </param>
        /// <returns> {{DWORD}} Returns the shader version of the given shader, or zero if the shader  function is NULL. </returns>
        /// <unmanaged>int D3DXGetShaderVersion([None] const int* pFunction)</unmanaged>
		public static int D3DXGetShaderVersion(ref int functionRef) {
            unsafe {
                int __result__;
                __result__= (int)D3DXGetShaderVersion_(ref  functionRef);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>int D3DXGetShaderVersion([None] const int* pFunction)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderVersion", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static int D3DXGetShaderVersion_(ref int functionRef);		
        
        /// <summary>	
        /// Gets the semantics for the shader inputs. Use this method to determine the input vertex format.	
        /// </summary>	
        /// <remarks>	
        ///  Use D3DXGetShaderInputSemantics to return a list of input semantics required by the shader. This is the way to find out what the input vertex format is for a high-level shader language (HLSL) shader. If the shader has additional inputs that your vertex declaration is missing, you could create an extra vertex stream that has a stride of 0 that has the missing components with default values. For instance, this technique could be used to provide default vertex color for models that do not specify it. 	
        /// </remarks>	
        /// <param name="functionRef"> Pointer to the shader function DWORD stream. </param>
        /// <param name="semanticsRef"> Pointer to an array of <see cref="SlimDX2.Direct3D9.ShaderSemantic"/> structures.  The function will fill this array with the semantics for each input element referenced by the shader. This array is assumed to contain at least MAXD3DDECLLENGTH elements. However, calling D3DXGetShaderInputSemantics with pSemantics = NULL will return the number of elements  needed for pCount. </param>
        /// <param name="countRef"> Returns the number of elements in pSemantics. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXGetShaderInputSemantics([None] const int* pFunction,[None] D3DXSEMANTIC* pSemantics,[None] int* pCount)</unmanaged>
		public static SlimDX2.Result D3DXGetShaderInputSemantics(ref int functionRef, ref SlimDX2.Direct3D9.ShaderSemantic semanticsRef, ref int countRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetShaderInputSemantics_(ref  functionRef, ref  semanticsRef, ref  countRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetShaderInputSemantics([None] const int* pFunction,[None] D3DXSEMANTIC* pSemantics,[None] int* pCount)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderInputSemantics", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetShaderInputSemantics_(ref int functionRef, ref SlimDX2.Direct3D9.ShaderSemantic semanticsRef, ref int countRef);		
        
        /// <summary>	
        /// Get the semantics for all shader output elements.	
        /// </summary>	
        /// <param name="functionRef"> Pointer to the shader function DWORD stream. </param>
        /// <param name="semanticsRef"> Pointer to an array of <see cref="SlimDX2.Direct3D9.ShaderSemantic"/> structures.  The function will fill this array with the semantics for each output element referenced by the shader.  This array is assumed to contain at least MAXD3DDECLLENGTH elements. However, calling D3DXGetShaderOutputSemantics with pSemantics = NULL will return the number of elements  needed for pCount. </param>
        /// <param name="countRef"> Returns the number of elements in pSemantics. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXGetShaderOutputSemantics([None] const int* pFunction,[None] D3DXSEMANTIC* pSemantics,[None] int* pCount)</unmanaged>
		public static SlimDX2.Result D3DXGetShaderOutputSemantics(ref int functionRef, ref SlimDX2.Direct3D9.ShaderSemantic semanticsRef, ref int countRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetShaderOutputSemantics_(ref  functionRef, ref  semanticsRef, ref  countRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetShaderOutputSemantics([None] const int* pFunction,[None] D3DXSEMANTIC* pSemantics,[None] int* pCount)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderOutputSemantics", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetShaderOutputSemantics_(ref int functionRef, ref SlimDX2.Direct3D9.ShaderSemantic semanticsRef, ref int countRef);		
        
        /// <summary>	
        /// Get the sampler names referenced in a shader.	
        /// </summary>	
        /// <param name="functionRef"> Pointer to the shader function DWORD stream. </param>
        /// <param name="samplersRef"> Pointer to an array of LPCSTRs. The function will fill this array with pointers to the sampler names contained within pFunction. The maximum array size is the maximum number of sampler registers (16 for vs_3_0 and ps_3_0). To find the number of samplers used, check pCount after calling D3DXGetShaderSamplers with pSamplers = NULL. </param>
        /// <param name="countRef"> Returns the number of samplers referenced by the shader. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXGetShaderSamplers([None] const int* pFunction,[None] const char** pSamplers,[None] int* pCount)</unmanaged>
		public static SlimDX2.Result D3DXGetShaderSamplers(ref int functionRef, string samplersRef, ref int countRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetShaderSamplers_(ref  functionRef,  samplersRef, ref  countRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetShaderSamplers([None] const int* pFunction,[None] const char** pSamplers,[None] int* pCount)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderSamplers", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetShaderSamplers_(ref int functionRef, [MarshalAs(UnmanagedType.LPStr),In] string samplersRef, ref int countRef);		
        
        /// <summary>	
        /// Gets the shader-constant table embedded inside a shader.	
        /// </summary>	
        /// <remarks>	
        ///  A constant table is generated by <see cref="SlimDX2.Direct3D9.D3DX9.D3DXCompileShader"/> and embedded in the shader body. If you need additional virtual address space, see <see cref="SlimDX2.Direct3D9.D3DX9.D3DXGetShaderConstantTableEx"/>. 	
        /// </remarks>	
        /// <param name="functionRef"> Pointer to the function DWORD stream. </param>
        /// <param name="constantTableRef"> Returns the constant table interface (see <see cref="SlimDX2.Direct3D9.ID3DXConstantTable"/>) that manages the constant table. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXGetShaderConstantTable([None] const int* pFunction,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		public static SlimDX2.Result D3DXGetShaderConstantTable(ref int functionRef, out SlimDX2.Direct3D9.ID3DXConstantTable constantTableRef) {
            unsafe {
                IntPtr constantTableRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetShaderConstantTable_(ref  functionRef, out constantTableRef_);
                constantTableRef = (constantTableRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXConstantTable(constantTableRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetShaderConstantTable([None] const int* pFunction,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderConstantTable", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetShaderConstantTable_(ref int functionRef, out IntPtr constantTableRef);		
        
        /// <summary>	
        /// Gets the shader-constant table embedded inside a shader.	
        /// </summary>	
        /// <remarks>	
        ///  A constant table is generated by <see cref="SlimDX2.Direct3D9.D3DX9.D3DXCompileShader"/> and embedded in the shader body. 	
        /// </remarks>	
        /// <param name="functionRef"> Pointer to the function DWORD stream. </param>
        /// <param name="flags"> Use the D3DXCONSTTABLE_LARGEADDRESSAWARE flag to access up to 4 GB of virtual address space (instead of the default of 2 GB). If you do not need the additional virtual address space, use <see cref="SlimDX2.Direct3D9.D3DX9.D3DXGetShaderConstantTable"/>. </param>
        /// <param name="constantTableRef"> Returns the constant table interface (see <see cref="SlimDX2.Direct3D9.ID3DXConstantTable"/>) that manages the constant table. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXGetShaderConstantTableEx([None] const int* pFunction,[None] int Flags,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		public static SlimDX2.Result D3DXGetShaderConstantTableEx(ref int functionRef, int flags, out SlimDX2.Direct3D9.ID3DXConstantTable constantTableRef) {
            unsafe {
                IntPtr constantTableRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetShaderConstantTableEx_(ref  functionRef,  flags, out constantTableRef_);
                constantTableRef = (constantTableRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXConstantTable(constantTableRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetShaderConstantTableEx([None] const int* pFunction,[None] int Flags,[None] LPD3DXCONSTANTTABLE* ppConstantTable)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderConstantTableEx", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetShaderConstantTableEx_(ref int functionRef, int flags, out IntPtr constantTableRef);		
        
        /// <summary>	
        /// Creates a texture shader object from the compiled shader.	
        /// </summary>	
        /// <param name="functionRef"> Pointer to the function DWORD stream. </param>
        /// <param name="textureShaderRef"> Returns an <see cref="SlimDX2.Direct3D9.ID3DXTextureShader"/> object which can be used to procedurally fill the contents of a texture using the <see cref="SlimDX2.Direct3D9.D3DX9.D3DXFillTextureTX"/> functions. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureShader([None] const int* pFunction,[None] LPD3DXTEXTURESHADER* ppTextureShader)</unmanaged>
		public static SlimDX2.Result D3DXCreateTextureShader(ref int functionRef, out SlimDX2.Direct3D9.ID3DXTextureShader textureShaderRef) {
            unsafe {
                IntPtr textureShaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureShader_(ref  functionRef, out textureShaderRef_);
                textureShaderRef = (textureShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXTextureShader(textureShaderRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureShader([None] const int* pFunction,[None] LPD3DXTEXTURESHADER* ppTextureShader)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureShader", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureShader_(ref int functionRef, out IntPtr textureShaderRef);		
        
        /// <summary>	
        /// Preprocesses a shader file without performing compilation. This resolves all #defines and #includes, providing a self-contained shader for subsequent compilation.	
        /// </summary>	
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename of the shader. </param>
        /// <param name="definesRef"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="shaderTextRef"> Returns a buffer containing a single large string that represents the resulting formatted token stream. </param>
        /// <param name="errorMsgsRef"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode.  This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromFileA([None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result D3DXPreprocessShaderFromFileA(string srcFileRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, out SlimDX2.Direct3D9.ShaderBytecode shaderTextRef, out SlimDX2.Direct3D9.ShaderBytecode errorMsgsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr shaderTextRef_ = IntPtr.Zero;
                IntPtr errorMsgsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXPreprocessShaderFromFileA_( srcFileRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer, out shaderTextRef_, out errorMsgsRef_);
                shaderTextRef = (shaderTextRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(shaderTextRef_);
                errorMsgsRef = (errorMsgsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorMsgsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromFileA([None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXPreprocessShaderFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXPreprocessShaderFromFileA_([MarshalAs(UnmanagedType.LPStr),In] string srcFileRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, out IntPtr shaderTextRef, out IntPtr errorMsgsRef);		
        
        /// <summary>	
        /// Preprocesses a shader file without performing compilation. This resolves all #defines and #includes, providing a self-contained shader for subsequent compilation.	
        /// </summary>	
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename of the shader. </param>
        /// <param name="definesRef"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="shaderTextRef"> Returns a buffer containing a single large string that represents the resulting formatted token stream. </param>
        /// <param name="errorMsgsRef"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode.  This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromFileW([None] const wchar_t* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result D3DXPreprocessShaderFromFileW(string srcFileRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, out SlimDX2.Direct3D9.ShaderBytecode shaderTextRef, out SlimDX2.Direct3D9.ShaderBytecode errorMsgsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr shaderTextRef_ = IntPtr.Zero;
                IntPtr errorMsgsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXPreprocessShaderFromFileW_( srcFileRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer, out shaderTextRef_, out errorMsgsRef_);
                shaderTextRef = (shaderTextRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(shaderTextRef_);
                errorMsgsRef = (errorMsgsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorMsgsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromFileW([None] const wchar_t* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXPreprocessShaderFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXPreprocessShaderFromFileW_([MarshalAs(UnmanagedType.LPWStr),In] string srcFileRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, out IntPtr shaderTextRef, out IntPtr errorMsgsRef);		
        
        /// <summary>	
        /// Preprocesses a shader resource without performing compilation. This resolves all #defines and #includes, providing a self-contained shader for subsequent compilation. 	
        /// </summary>	
        /// <param name="hSrcModule"> Handle to the module that holds the shader resource. If this value is NULL, the current module will be used. </param>
        /// <param name="srcResourceRef"> String that represents the name of the resource in the module. </param>
        /// <param name="definesRef"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="shaderTextRef"> Returns a buffer containing a single large string that represents the resulting formatted token stream. </param>
        /// <param name="errorMsgsRef"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode.  This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromResourceA([None] void* hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result D3DXPreprocessShaderFromResourceA(IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, out SlimDX2.Direct3D9.ShaderBytecode shaderTextRef, out SlimDX2.Direct3D9.ShaderBytecode errorMsgsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr shaderTextRef_ = IntPtr.Zero;
                IntPtr errorMsgsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXPreprocessShaderFromResourceA_( hSrcModule,  srcResourceRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer, out shaderTextRef_, out errorMsgsRef_);
                shaderTextRef = (shaderTextRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(shaderTextRef_);
                errorMsgsRef = (errorMsgsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorMsgsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromResourceA([None] void* hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXPreprocessShaderFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXPreprocessShaderFromResourceA_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string srcResourceRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, out IntPtr shaderTextRef, out IntPtr errorMsgsRef);		
        
        /// <summary>	
        /// Preprocesses a shader resource without performing compilation. This resolves all #defines and #includes, providing a self-contained shader for subsequent compilation. 	
        /// </summary>	
        /// <param name="hSrcModule"> Handle to the module that holds the shader resource. If this value is NULL, the current module will be used. </param>
        /// <param name="srcResourceRef"> String that represents the name of the resource in the module. </param>
        /// <param name="definesRef"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="shaderTextRef"> Returns a buffer containing a single large string that represents the resulting formatted token stream. </param>
        /// <param name="errorMsgsRef"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode.  This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromResourceW([None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result D3DXPreprocessShaderFromResourceW(IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, out SlimDX2.Direct3D9.ShaderBytecode shaderTextRef, out SlimDX2.Direct3D9.ShaderBytecode errorMsgsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr shaderTextRef_ = IntPtr.Zero;
                IntPtr errorMsgsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXPreprocessShaderFromResourceW_( hSrcModule,  srcResourceRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer, out shaderTextRef_, out errorMsgsRef_);
                shaderTextRef = (shaderTextRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(shaderTextRef_);
                errorMsgsRef = (errorMsgsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorMsgsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromResourceW([None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXPreprocessShaderFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXPreprocessShaderFromResourceW_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string srcResourceRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, out IntPtr shaderTextRef, out IntPtr errorMsgsRef);		
        
        /// <summary>	
        /// Preprocesses a shader without performing compilation. This resolves all #defines and #includes, providing a self-contained shader for subsequent compilation. 	
        /// </summary>	
        /// <param name="srcDataRef"> Pointer to a string that contains the shader. </param>
        /// <param name="srcDataSize"> Length of the data in bytes. </param>
        /// <param name="definesRef"> An optional NULL terminated array of <see cref="SlimDX2.Direct3D9.Macro"/> structures. This value may be NULL. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </param>
        /// <param name="shaderTextRef"> Returns a buffer containing a single large string that represents the resulting formatted token stream. </param>
        /// <param name="errorMsgsRef"> Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode.  This value may be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXPreprocessShader([None] const char* pSrcData,[None] int SrcDataSize,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		public static SlimDX2.Result D3DXPreprocessShader(string srcDataRef, int srcDataSize, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, out SlimDX2.Direct3D9.ShaderBytecode shaderTextRef, out SlimDX2.Direct3D9.ShaderBytecode errorMsgsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr shaderTextRef_ = IntPtr.Zero;
                IntPtr errorMsgsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXPreprocessShader_( srcDataRef,  srcDataSize, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer, out shaderTextRef_, out errorMsgsRef_);
                shaderTextRef = (shaderTextRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(shaderTextRef_);
                errorMsgsRef = (errorMsgsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(errorMsgsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXPreprocessShader([None] const char* pSrcData,[None] int SrcDataSize,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] LPD3DXBUFFER* ppShaderText,[None] LPD3DXBUFFER* ppErrorMsgs)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXPreprocessShader", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXPreprocessShader_([MarshalAs(UnmanagedType.LPStr),In] string srcDataRef, int srcDataSize, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, out IntPtr shaderTextRef, out IntPtr errorMsgsRef);		
        
        /// <summary>	
        /// Create an effect pool. A pool is used to share parameters between effects.	
        /// </summary>	
        /// <remarks>	
        ///  For effects within a pool, shared parameters with the same name share values.  	
        /// </remarks>	
        /// <param name="poolRef"> Returns a pointer to the created pool. </param>
        /// <returns> <see cref="int"/> If the method succeeds, the return value is S_OK. If the arguments are invalid, the method will return D3DERR_INVALIDCALL. If the method fails, the return value will be E_FAIL. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectPool([None] LPD3DXEFFECTPOOL* ppPool)</unmanaged>
		public static SlimDX2.Result D3DXCreateEffectPool(out SlimDX2.Direct3D9.ID3DXEffectPool poolRef) {
            unsafe {
                IntPtr poolRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectPool_(out poolRef_);
                poolRef = (poolRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXEffectPool(poolRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectPool([None] LPD3DXEFFECTPOOL* ppPool)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectPool", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectPool_(out IntPtr poolRef);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description.	
        /// </summary>	
        /// <remarks>	
        ///  If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectFromFileW. Otherwise, the function call resolves to D3DXCreateEffectFromFileA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device that will create the effect. See <see cref="SlimDX2.Direct3D9.Device"/>. </param>
        /// <param name="srcFileRef"> Pointer to the filename. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="definesRef"> Optional NULL-terminated array of preprocessor macro definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> If pSrcFile contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, pSrcFile contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to a <see cref="SlimDX2.Direct3D9.ID3DXEffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="effectRef"> Returns a pointer to a buffer containing the compiled effect. See <see cref="SlimDX2.Direct3D9.ID3DXEffect"/>. </param>
        /// <param name="compilationErrorsRef"> Returns a pointer to a buffer containing a listing of compile errors. See <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result D3DXCreateEffectFromFileA(SlimDX2.Direct3D9.Device pDevice, string srcFileRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, int flags, SlimDX2.Direct3D9.ID3DXEffectPool pPool, out SlimDX2.Direct3D9.ID3DXEffect effectRef, out SlimDX2.Direct3D9.ShaderBytecode compilationErrorsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr effectRef_ = IntPtr.Zero;
                IntPtr compilationErrorsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectFromFileA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcFileRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out effectRef_, out compilationErrorsRef_);
                effectRef = (effectRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXEffect(effectRef_);
                compilationErrorsRef = (compilationErrorsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(compilationErrorsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectFromFileA_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPStr),In] string srcFileRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, int flags, IntPtr pPool, out IntPtr effectRef, out IntPtr compilationErrorsRef);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description.	
        /// </summary>	
        /// <remarks>	
        ///  If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectFromFileW. Otherwise, the function call resolves to D3DXCreateEffectFromFileA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device that will create the effect. See <see cref="SlimDX2.Direct3D9.Device"/>. </param>
        /// <param name="srcFileRef"> Pointer to the filename. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="definesRef"> Optional NULL-terminated array of preprocessor macro definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> If pSrcFile contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, pSrcFile contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to a <see cref="SlimDX2.Direct3D9.ID3DXEffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="effectRef"> Returns a pointer to a buffer containing the compiled effect. See <see cref="SlimDX2.Direct3D9.ID3DXEffect"/>. </param>
        /// <param name="compilationErrorsRef"> Returns a pointer to a buffer containing a listing of compile errors. See <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar_t* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result D3DXCreateEffectFromFileW(SlimDX2.Direct3D9.Device pDevice, string srcFileRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, int flags, SlimDX2.Direct3D9.ID3DXEffectPool pPool, out SlimDX2.Direct3D9.ID3DXEffect effectRef, out SlimDX2.Direct3D9.ShaderBytecode compilationErrorsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr effectRef_ = IntPtr.Zero;
                IntPtr compilationErrorsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectFromFileW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcFileRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out effectRef_, out compilationErrorsRef_);
                effectRef = (effectRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXEffect(effectRef_);
                compilationErrorsRef = (compilationErrorsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(compilationErrorsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar_t* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectFromFileW_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPWStr),In] string srcFileRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, int flags, IntPtr pPool, out IntPtr effectRef, out IntPtr compilationErrorsRef);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description.	
        /// </summary>	
        /// <remarks>	
        ///  If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectFromResourceW. Otherwise, the function call resolves to D3DXCreateEffectFromResourceA because ANSI strings are being used. D3DXCreateEffectFromResource loads data from a resource of type RT_RCDATA. See MSDN for more information about Windows resources. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device. </param>
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="srcResourceRef"> Pointer to the resource. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="definesRef"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> If hSrcModule contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, hSrcModule contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to a <see cref="SlimDX2.Direct3D9.ID3DXEffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="effectRef"> Returns a buffer containing the compiled effect. </param>
        /// <param name="compilationErrorsRef"> Returns a buffer containing a listing of compile errors. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result D3DXCreateEffectFromResourceA(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, int flags, SlimDX2.Direct3D9.ID3DXEffectPool pPool, out SlimDX2.Direct3D9.ID3DXEffect effectRef, out SlimDX2.Direct3D9.ShaderBytecode compilationErrorsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr effectRef_ = IntPtr.Zero;
                IntPtr compilationErrorsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectFromResourceA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  srcResourceRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out effectRef_, out compilationErrorsRef_);
                effectRef = (effectRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXEffect(effectRef_);
                compilationErrorsRef = (compilationErrorsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(compilationErrorsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectFromResourceA_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string srcResourceRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, int flags, IntPtr pPool, out IntPtr effectRef, out IntPtr compilationErrorsRef);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description.	
        /// </summary>	
        /// <remarks>	
        ///  If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectFromResourceW. Otherwise, the function call resolves to D3DXCreateEffectFromResourceA because ANSI strings are being used. D3DXCreateEffectFromResource loads data from a resource of type RT_RCDATA. See MSDN for more information about Windows resources. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device. </param>
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="srcResourceRef"> Pointer to the resource. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="definesRef"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> If hSrcModule contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, hSrcModule contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to a <see cref="SlimDX2.Direct3D9.ID3DXEffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="effectRef"> Returns a buffer containing the compiled effect. </param>
        /// <param name="compilationErrorsRef"> Returns a buffer containing a listing of compile errors. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result D3DXCreateEffectFromResourceW(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, int flags, SlimDX2.Direct3D9.ID3DXEffectPool pPool, out SlimDX2.Direct3D9.ID3DXEffect effectRef, out SlimDX2.Direct3D9.ShaderBytecode compilationErrorsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr effectRef_ = IntPtr.Zero;
                IntPtr compilationErrorsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectFromResourceW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  srcResourceRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out effectRef_, out compilationErrorsRef_);
                effectRef = (effectRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXEffect(effectRef_);
                compilationErrorsRef = (compilationErrorsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(compilationErrorsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectFromResourceW_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string srcResourceRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, int flags, IntPtr pPool, out IntPtr effectRef, out IntPtr compilationErrorsRef);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description.	
        /// </summary>	
        /// <param name="pDevice"> Pointer to the device that will create the effect. See <see cref="SlimDX2.Direct3D9.Device"/>. </param>
        /// <param name="srcDataRef"> Pointer to a buffer containing an effect description. </param>
        /// <param name="srcDataLen"> Length of the effect data, in bytes. </param>
        /// <param name="definesRef"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> If pSrcData contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, pSrcData contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to a <see cref="SlimDX2.Direct3D9.ID3DXEffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="effectRef"> Returns a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXEffect"/> interface. </param>
        /// <param name="compilationErrorsRef"> Returns a buffer containing a listing of compile errors. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffect([None] LPDIRECT3DDEVICE9 pDevice,[None] const void* pSrcData,[None] int SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result D3DXCreateEffect(SlimDX2.Direct3D9.Device pDevice, IntPtr srcDataRef, int srcDataLen, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, int flags, SlimDX2.Direct3D9.ID3DXEffectPool pPool, out SlimDX2.Direct3D9.ID3DXEffect effectRef, out SlimDX2.Direct3D9.ShaderBytecode compilationErrorsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr effectRef_ = IntPtr.Zero;
                IntPtr compilationErrorsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffect_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcDataRef,  srcDataLen, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out effectRef_, out compilationErrorsRef_);
                effectRef = (effectRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXEffect(effectRef_);
                compilationErrorsRef = (compilationErrorsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(compilationErrorsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffect([None] LPDIRECT3DDEVICE9 pDevice,[None] const void* pSrcData,[None] int SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffect", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffect_(IntPtr pDevice, IntPtr srcDataRef, int srcDataLen, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, int flags, IntPtr pPool, out IntPtr effectRef, out IntPtr compilationErrorsRef);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description. This function is an extended version of {{D3DXCreateEffectFromFile}} that allows an application to control which parameters are ignored by the effects system.	
        /// </summary>	
        /// <remarks>	
        ///  This function is an extended version of {{D3DXCreateEffectFromFile}} that allows an application to specify which effect constants will be managed by the application. A constant that is managed by the application is ignored by the effects system. That is, the application is responsible for initializing the constant as well as saving and restoring its state whenever appropriate. This function checks each constant in pSkipConstants to see that:  It is bound to a constant register. It is only used in HLSL shader code.   If a constant is named in the string that is not present in the effect, it is ignored. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectFromFileW. Otherwise, the function call resolves to D3DXCreateEffectFromFileA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device that will create the effect. See <see cref="SlimDX2.Direct3D9.Device"/>. </param>
        /// <param name="srcFileRef"> Pointer to the filename. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="definesRef"> Optional NULL-terminated array of preprocessor macro definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="skipConstantsRef"> A string of effect parameters that will be ignored by the effect system. The string must be NULL terminated, and needs to contain the name of each application-managed constant  separated by a semicolon. </param>
        /// <param name="flags"> If pSrcFile contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, pSrcFile contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to a <see cref="SlimDX2.Direct3D9.ID3DXEffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="effectRef"> Returns a pointer to a buffer containing the compiled effect. See <see cref="SlimDX2.Direct3D9.ID3DXEffect"/>. </param>
        /// <param name="compilationErrorsRef"> Returns a pointer to a buffer containing a listing of compile errors. See <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileExA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result D3DXCreateEffectFromFileExA(SlimDX2.Direct3D9.Device pDevice, string srcFileRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, string skipConstantsRef, int flags, SlimDX2.Direct3D9.ID3DXEffectPool pPool, out SlimDX2.Direct3D9.ID3DXEffect effectRef, out SlimDX2.Direct3D9.ShaderBytecode compilationErrorsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr effectRef_ = IntPtr.Zero;
                IntPtr compilationErrorsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectFromFileExA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcFileRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  skipConstantsRef,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out effectRef_, out compilationErrorsRef_);
                effectRef = (effectRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXEffect(effectRef_);
                compilationErrorsRef = (compilationErrorsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(compilationErrorsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileExA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromFileExA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectFromFileExA_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPStr),In] string srcFileRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, [MarshalAs(UnmanagedType.LPStr),In] string skipConstantsRef, int flags, IntPtr pPool, out IntPtr effectRef, out IntPtr compilationErrorsRef);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description. This function is an extended version of {{D3DXCreateEffectFromFile}} that allows an application to control which parameters are ignored by the effects system.	
        /// </summary>	
        /// <remarks>	
        ///  This function is an extended version of {{D3DXCreateEffectFromFile}} that allows an application to specify which effect constants will be managed by the application. A constant that is managed by the application is ignored by the effects system. That is, the application is responsible for initializing the constant as well as saving and restoring its state whenever appropriate. This function checks each constant in pSkipConstants to see that:  It is bound to a constant register. It is only used in HLSL shader code.   If a constant is named in the string that is not present in the effect, it is ignored. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectFromFileW. Otherwise, the function call resolves to D3DXCreateEffectFromFileA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device that will create the effect. See <see cref="SlimDX2.Direct3D9.Device"/>. </param>
        /// <param name="srcFileRef"> Pointer to the filename. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="definesRef"> Optional NULL-terminated array of preprocessor macro definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="skipConstantsRef"> A string of effect parameters that will be ignored by the effect system. The string must be NULL terminated, and needs to contain the name of each application-managed constant  separated by a semicolon. </param>
        /// <param name="flags"> If pSrcFile contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, pSrcFile contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to a <see cref="SlimDX2.Direct3D9.ID3DXEffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="effectRef"> Returns a pointer to a buffer containing the compiled effect. See <see cref="SlimDX2.Direct3D9.ID3DXEffect"/>. </param>
        /// <param name="compilationErrorsRef"> Returns a pointer to a buffer containing a listing of compile errors. See <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileExW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar_t* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result D3DXCreateEffectFromFileExW(SlimDX2.Direct3D9.Device pDevice, string srcFileRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, string skipConstantsRef, int flags, SlimDX2.Direct3D9.ID3DXEffectPool pPool, out SlimDX2.Direct3D9.ID3DXEffect effectRef, out SlimDX2.Direct3D9.ShaderBytecode compilationErrorsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr effectRef_ = IntPtr.Zero;
                IntPtr compilationErrorsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectFromFileExW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcFileRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  skipConstantsRef,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out effectRef_, out compilationErrorsRef_);
                effectRef = (effectRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXEffect(effectRef_);
                compilationErrorsRef = (compilationErrorsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(compilationErrorsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileExW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar_t* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromFileExW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectFromFileExW_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPWStr),In] string srcFileRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, [MarshalAs(UnmanagedType.LPWStr),In] string skipConstantsRef, int flags, IntPtr pPool, out IntPtr effectRef, out IntPtr compilationErrorsRef);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description. This is an extended version of {{D3DXCreateEffectFromResource}} that allows an application to control which parameters are ignored by the effects system.	
        /// </summary>	
        /// <remarks>	
        ///  This function is an extended version of {{D3DXCreateEffectFromResource}} that allows an application to specify which effect constants will be managed by the application. A constant that is managed by the application is ignored by the effects system. That is, the application is responsible for initializing the constant as well as saving and restoring its state whenever appropriate. This function checks each constant in pSkipConstants to see that:  It is bound to a constant register. It is only used in HLSL shader code.   If a constant is named in the string that is not present in the effect, it is ignored. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectFromResourceW. Otherwise, the function call resolves to D3DXCreateEffectFromResourceA because ANSI strings are being used. D3DXCreateEffectFromResource loads data from a resource of type RT_RCDATA. See MSDN for more information about Windows resources. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device. </param>
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="srcResourceRef"> Pointer to the resource. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="definesRef"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="skipConstantsRef"> A string of effect parameters that will be ignored by the effect system. The string must be NULL terminated, and needs to contain the name of each application-managed constant  separated by a semicolon. </param>
        /// <param name="flags"> If pSrcResource contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, pSrcResource contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXEffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="effectRef"> Returns a buffer containing the compiled effect. </param>
        /// <param name="compilationErrorsRef"> Returns a buffer containing a listing of compile errors. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceExA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result D3DXCreateEffectFromResourceExA(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, string skipConstantsRef, int flags, SlimDX2.Direct3D9.ID3DXEffectPool pPool, out SlimDX2.Direct3D9.ID3DXEffect effectRef, out SlimDX2.Direct3D9.ShaderBytecode compilationErrorsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr effectRef_ = IntPtr.Zero;
                IntPtr compilationErrorsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectFromResourceExA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  srcResourceRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  skipConstantsRef,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out effectRef_, out compilationErrorsRef_);
                effectRef = (effectRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXEffect(effectRef_);
                compilationErrorsRef = (compilationErrorsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(compilationErrorsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceExA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromResourceExA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectFromResourceExA_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string srcResourceRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, [MarshalAs(UnmanagedType.LPStr),In] string skipConstantsRef, int flags, IntPtr pPool, out IntPtr effectRef, out IntPtr compilationErrorsRef);		
        
        /// <summary>	
        /// Create an effect from an ASCII or binary effect description. This is an extended version of {{D3DXCreateEffectFromResource}} that allows an application to control which parameters are ignored by the effects system.	
        /// </summary>	
        /// <remarks>	
        ///  This function is an extended version of {{D3DXCreateEffectFromResource}} that allows an application to specify which effect constants will be managed by the application. A constant that is managed by the application is ignored by the effects system. That is, the application is responsible for initializing the constant as well as saving and restoring its state whenever appropriate. This function checks each constant in pSkipConstants to see that:  It is bound to a constant register. It is only used in HLSL shader code.   If a constant is named in the string that is not present in the effect, it is ignored. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectFromResourceW. Otherwise, the function call resolves to D3DXCreateEffectFromResourceA because ANSI strings are being used. D3DXCreateEffectFromResource loads data from a resource of type RT_RCDATA. See MSDN for more information about Windows resources. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device. </param>
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="srcResourceRef"> Pointer to the resource. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="definesRef"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="skipConstantsRef"> A string of effect parameters that will be ignored by the effect system. The string must be NULL terminated, and needs to contain the name of each application-managed constant  separated by a semicolon. </param>
        /// <param name="flags"> If pSrcResource contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, pSrcResource contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXEffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="effectRef"> Returns a buffer containing the compiled effect. </param>
        /// <param name="compilationErrorsRef"> Returns a buffer containing a listing of compile errors. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceExW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result D3DXCreateEffectFromResourceExW(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, string skipConstantsRef, int flags, SlimDX2.Direct3D9.ID3DXEffectPool pPool, out SlimDX2.Direct3D9.ID3DXEffect effectRef, out SlimDX2.Direct3D9.ShaderBytecode compilationErrorsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr effectRef_ = IntPtr.Zero;
                IntPtr compilationErrorsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectFromResourceExW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  srcResourceRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  skipConstantsRef,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out effectRef_, out compilationErrorsRef_);
                effectRef = (effectRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXEffect(effectRef_);
                compilationErrorsRef = (compilationErrorsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(compilationErrorsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceExW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromResourceExW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectFromResourceExW_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string srcResourceRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, [MarshalAs(UnmanagedType.LPWStr),In] string skipConstantsRef, int flags, IntPtr pPool, out IntPtr effectRef, out IntPtr compilationErrorsRef);		
        
        /// <summary>	
        /// Creates an effect from an ASCII or binary effect description. This function is an extended version of <see cref="SlimDX2.Direct3D9.D3DX9.D3DXCreateEffect"/> that allows an application to control which parameters are ignored by the effects system.	
        /// </summary>	
        /// <remarks>	
        ///  This function is an extended version of <see cref="SlimDX2.Direct3D9.D3DX9.D3DXCreateEffect"/> that allows an application to specify which effect constants will be managed by the application. A constant that is managed by the application is ignored by the effects system. That is, the application is responsible for initializing the constant as well as saving and restoring its state whenever appropriate. This function checks each constant in pSkipConstants to see that:  It is bound to a constant register. It is only used in HLSL shader code.   If a constant is named in the string that is not present in the effect, it is ignored. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device that will create the effect. See <see cref="SlimDX2.Direct3D9.Device"/>. </param>
        /// <param name="srcDataRef"> Pointer to a buffer containing an effect description. </param>
        /// <param name="srcDataLen"> Length of the effect data, in bytes. </param>
        /// <param name="definesRef"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="skipConstantsRef"> A string of effect parameters that will be ignored by the effect system. The string must be NULL terminated, and needs to contain the name of each application-managed constant  separated by a semicolon. </param>
        /// <param name="flags"> If pSrcData contains a text effect, flags can be a combination of {{D3DXSHADER Flags}} and {{D3DXFX}} flags; otherwise, pSrcData contains a binary effect and the only flags honored are D3DXFX flags. The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="pPool"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXEffectPool"/> object to use for shared parameters. If this value is NULL, no parameters will be shared. </param>
        /// <param name="effectRef"> Returns a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXEffect"/> interface. </param>
        /// <param name="compilationErrorsRef"> Returns a buffer containing a list of compile errors. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectEx([None] LPDIRECT3DDEVICE9 pDevice,[None] const void* pSrcData,[None] int SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		public static SlimDX2.Result D3DXCreateEffectEx(SlimDX2.Direct3D9.Device pDevice, IntPtr srcDataRef, int srcDataLen, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, string skipConstantsRef, int flags, SlimDX2.Direct3D9.ID3DXEffectPool pPool, out SlimDX2.Direct3D9.ID3DXEffect effectRef, out SlimDX2.Direct3D9.ShaderBytecode compilationErrorsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr effectRef_ = IntPtr.Zero;
                IntPtr compilationErrorsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectEx_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcDataRef,  srcDataLen, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  skipConstantsRef,  flags, (pPool == null)?IntPtr.Zero:pPool.NativePointer, out effectRef_, out compilationErrorsRef_);
                effectRef = (effectRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXEffect(effectRef_);
                compilationErrorsRef = (compilationErrorsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(compilationErrorsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectEx([None] LPDIRECT3DDEVICE9 pDevice,[None] const void* pSrcData,[None] int SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] const char* pSkipConstants,[None] int Flags,[None] LPD3DXEFFECTPOOL pPool,[None] LPD3DXEFFECT* ppEffect,[None] LPD3DXBUFFER* ppCompilationErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectEx", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectEx_(IntPtr pDevice, IntPtr srcDataRef, int srcDataLen, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, [MarshalAs(UnmanagedType.LPStr),In] string skipConstantsRef, int flags, IntPtr pPool, out IntPtr effectRef, out IntPtr compilationErrorsRef);		
        
        /// <summary>	
        /// Creates an effect compiler from an ASCII effect description.	
        /// </summary>	
        /// <remarks>	
        ///  If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectCompilerFromFileW. Otherwise, the function call resolves to D3DXCreateEffectCompilerFromFileA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="srcFileRef"> Pointer to the filename. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="definesRef"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> Compile options identified by various flags (see {{D3DXSHADER Flags}}). The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="compilerRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXEffectCompiler"/> interface, containing the effect compiler.  </param>
        /// <param name="parseErrorsRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface, containing any error messages that occurred during compilation. This parameter can be set to NULL to ignore error messages.  </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromFileA([None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		public static SlimDX2.Result D3DXCreateEffectCompilerFromFileA(string srcFileRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, int flags, out SlimDX2.Direct3D9.ID3DXEffectCompiler compilerRef, out SlimDX2.Direct3D9.ShaderBytecode parseErrorsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr compilerRef_ = IntPtr.Zero;
                IntPtr parseErrorsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectCompilerFromFileA_( srcFileRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out compilerRef_, out parseErrorsRef_);
                compilerRef = (compilerRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXEffectCompiler(compilerRef_);
                parseErrorsRef = (parseErrorsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(parseErrorsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromFileA([None] const char* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectCompilerFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectCompilerFromFileA_([MarshalAs(UnmanagedType.LPStr),In] string srcFileRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, int flags, out IntPtr compilerRef, out IntPtr parseErrorsRef);		
        
        /// <summary>	
        /// Creates an effect compiler from an ASCII effect description.	
        /// </summary>	
        /// <remarks>	
        ///  If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectCompilerFromFileW. Otherwise, the function call resolves to D3DXCreateEffectCompilerFromFileA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="srcFileRef"> Pointer to the filename. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="definesRef"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> Compile options identified by various flags (see {{D3DXSHADER Flags}}). The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="compilerRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXEffectCompiler"/> interface, containing the effect compiler.  </param>
        /// <param name="parseErrorsRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface, containing any error messages that occurred during compilation. This parameter can be set to NULL to ignore error messages.  </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromFileW([None] const wchar_t* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		public static SlimDX2.Result D3DXCreateEffectCompilerFromFileW(string srcFileRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, int flags, out SlimDX2.Direct3D9.ID3DXEffectCompiler compilerRef, out SlimDX2.Direct3D9.ShaderBytecode parseErrorsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr compilerRef_ = IntPtr.Zero;
                IntPtr parseErrorsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectCompilerFromFileW_( srcFileRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out compilerRef_, out parseErrorsRef_);
                compilerRef = (compilerRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXEffectCompiler(compilerRef_);
                parseErrorsRef = (parseErrorsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(parseErrorsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromFileW([None] const wchar_t* pSrcFile,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectCompilerFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectCompilerFromFileW_([MarshalAs(UnmanagedType.LPWStr),In] string srcFileRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, int flags, out IntPtr compilerRef, out IntPtr parseErrorsRef);		
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct3D9.ID3DXEffectCompiler"/> from an ASCII effect description.	
        /// </summary>	
        /// <remarks>	
        ///  If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectCompilerFromResourceW. Otherwise, the function call resolves to D3DXCreateEffectCompilerFromResourceA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="srcResourceRef"> Pointer to the resource. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="definesRef"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> Compile options identified by various flags (see {{D3DXSHADER Flags}}). The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="compilerRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXEffectCompiler"/> interface, containing the effect compiler.  </param>
        /// <param name="parseErrorsRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface, containing any error messages that occurred during compilation. This parameter can be set to NULL to ignore error messages.  </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromResourceA([None] void* hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		public static SlimDX2.Result D3DXCreateEffectCompilerFromResourceA(IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, int flags, out SlimDX2.Direct3D9.ID3DXEffectCompiler compilerRef, out SlimDX2.Direct3D9.ShaderBytecode parseErrorsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr compilerRef_ = IntPtr.Zero;
                IntPtr parseErrorsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectCompilerFromResourceA_( hSrcModule,  srcResourceRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out compilerRef_, out parseErrorsRef_);
                compilerRef = (compilerRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXEffectCompiler(compilerRef_);
                parseErrorsRef = (parseErrorsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(parseErrorsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromResourceA([None] void* hSrcModule,[None] const char* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectCompilerFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectCompilerFromResourceA_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string srcResourceRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, int flags, out IntPtr compilerRef, out IntPtr parseErrorsRef);		
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct3D9.ID3DXEffectCompiler"/> from an ASCII effect description.	
        /// </summary>	
        /// <remarks>	
        ///  If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR. The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateEffectCompilerFromResourceW. Otherwise, the function call resolves to D3DXCreateEffectCompilerFromResourceA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="hSrcModule"> Handle to a module containing the effect description. If this parameter is NULL, the current module will be used. </param>
        /// <param name="srcResourceRef"> Pointer to the resource. This parameter supports both Unicode and ANSI strings. See Remarks. </param>
        /// <param name="definesRef"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> Compile options identified by various flags (see {{D3DXSHADER Flags}}). The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="compilerRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXEffectCompiler"/> interface, containing the effect compiler.  </param>
        /// <param name="parseErrorsRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface, containing any error messages that occurred during compilation. This parameter can be set to NULL to ignore error messages.  </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromResourceW([None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		public static SlimDX2.Result D3DXCreateEffectCompilerFromResourceW(IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, int flags, out SlimDX2.Direct3D9.ID3DXEffectCompiler compilerRef, out SlimDX2.Direct3D9.ShaderBytecode parseErrorsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr compilerRef_ = IntPtr.Zero;
                IntPtr parseErrorsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectCompilerFromResourceW_( hSrcModule,  srcResourceRef, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out compilerRef_, out parseErrorsRef_);
                compilerRef = (compilerRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXEffectCompiler(compilerRef_);
                parseErrorsRef = (parseErrorsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(parseErrorsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromResourceW([None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectCompilerFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectCompilerFromResourceW_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string srcResourceRef, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, int flags, out IntPtr compilerRef, out IntPtr parseErrorsRef);		
        
        /// <summary>	
        /// Creates an effect compiler from an ASCII effect description.	
        /// </summary>	
        /// <param name="srcDataRef"> Pointer to a buffer containing an effect description. </param>
        /// <param name="srcDataLen"> Length, in bytes, of the effect data. </param>
        /// <param name="definesRef"> Pointer to the preprocessor definitions. See <see cref="SlimDX2.Direct3D9.Macro"/>. </param>
        /// <param name="pInclude"> Optional interface pointer, <see cref="SlimDX2.Direct3D9.ID3DXInclude"/>, to use for handling #include directives. If this value is NULL, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.  </param>
        /// <param name="flags"> Compile options identified by various flags (see {{D3DXSHADER Flags}}). The Direct3D 10 HLSL compiler is now the default. See {{Effect-Compiler Tool}} for details. </param>
        /// <param name="compilerRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ID3DXEffectCompiler"/> interface containing the effect compiler.  </param>
        /// <param name="parseErrorsRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface containing any error messages that occurred during compilation. This parameter can be set to NULL to ignore error messages.  </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateEffectCompiler([None] const char* pSrcData,[None] int SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		public static SlimDX2.Result D3DXCreateEffectCompiler(string srcDataRef, int srcDataLen, ref SlimDX2.Direct3D9.Macro definesRef, SlimDX2.Direct3D9.ID3DXInclude pInclude, int flags, out SlimDX2.Direct3D9.ID3DXEffectCompiler compilerRef, out SlimDX2.Direct3D9.ShaderBytecode parseErrorsRef) {
            unsafe {
                SlimDX2.Direct3D9.Macro.__Native definesRef_ = new SlimDX2.Direct3D9.Macro.__Native();
                definesRef.__MarshalTo(ref definesRef_);
                IntPtr compilerRef_ = IntPtr.Zero;
                IntPtr parseErrorsRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateEffectCompiler_( srcDataRef,  srcDataLen, ref  definesRef_, (pInclude == null)?IntPtr.Zero:pInclude.NativePointer,  flags, out compilerRef_, out parseErrorsRef_);
                compilerRef = (compilerRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXEffectCompiler(compilerRef_);
                parseErrorsRef = (parseErrorsRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(parseErrorsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateEffectCompiler([None] const char* pSrcData,[None] int SrcDataLen,[None] const D3DXMACRO* pDefines,[None] LPD3DXINCLUDE pInclude,[None] int Flags,[None] LPD3DXEFFECTCOMPILER* ppCompiler,[None] LPD3DXBUFFER* ppParseErrors)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectCompiler", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateEffectCompiler_([MarshalAs(UnmanagedType.LPStr),In] string srcDataRef, int srcDataLen, ref SlimDX2.Direct3D9.Macro.__Native definesRef, IntPtr pInclude, int flags, out IntPtr compilerRef, out IntPtr parseErrorsRef);		
        
        /// <summary>	
        /// Disassemble an effect.	
        /// </summary>	
        /// <param name="pEffect"> Pointer to an <see cref="SlimDX2.Direct3D9.ID3DXEffect"/> interface that contains the effect. </param>
        /// <param name="enableColorCode"> Enable color coding to make the disassembly easier to read. </param>
        /// <param name="disassemblyRef"> Returns a buffer containing the disassembled shader. See <see cref="SlimDX2.Direct3D9.ShaderBytecode"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXDisassembleEffect([None] LPD3DXEFFECT pEffect,[None] BOOL EnableColorCode,[None] LPD3DXBUFFER* ppDisassembly)</unmanaged>
		public static SlimDX2.Result D3DXDisassembleEffect(SlimDX2.Direct3D9.ID3DXEffect pEffect, bool enableColorCode, out SlimDX2.Direct3D9.ShaderBytecode disassemblyRef) {
            unsafe {
                IntPtr disassemblyRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXDisassembleEffect_((pEffect == null)?IntPtr.Zero:pEffect.NativePointer,  enableColorCode, out disassemblyRef_);
                disassemblyRef = (disassemblyRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(disassemblyRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXDisassembleEffect([None] LPD3DXEFFECT pEffect,[None] BOOL EnableColorCode,[None] LPD3DXBUFFER* ppDisassembly)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXDisassembleEffect", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXDisassembleEffect_(IntPtr pEffect, bool enableColorCode, out IntPtr disassemblyRef);		
        
        /// <summary>	
        /// Retrieves information about a given image file.	
        /// </summary>	
        /// <remarks>	
        ///  This function supports both Unicode and ANSI strings. 	
        /// </remarks>	
        /// <param name="srcFileRef"> File name of image to retrieve information about. If UNICODE or _UNICODE are defined, this parameter type is LPCWSTR, otherwise, the type is LPCSTR. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with the description of the data in the source file. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromFileA([None] const char* pSrcFile,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result D3DXGetImageInfoFromFileA(string srcFileRef, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetImageInfoFromFileA_( srcFileRef, ref  srcInfoRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromFileA([None] const char* pSrcFile,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetImageInfoFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetImageInfoFromFileA_([MarshalAs(UnmanagedType.LPStr),In] string srcFileRef, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef);		
        
        /// <summary>	
        /// Retrieves information about a given image file.	
        /// </summary>	
        /// <remarks>	
        ///  This function supports both Unicode and ANSI strings. 	
        /// </remarks>	
        /// <param name="srcFileRef"> File name of image to retrieve information about. If UNICODE or _UNICODE are defined, this parameter type is LPCWSTR, otherwise, the type is LPCSTR. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with the description of the data in the source file. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromFileW([None] const wchar_t* pSrcFile,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result D3DXGetImageInfoFromFileW(string srcFileRef, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetImageInfoFromFileW_( srcFileRef, ref  srcInfoRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromFileW([None] const wchar_t* pSrcFile,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetImageInfoFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetImageInfoFromFileW_([MarshalAs(UnmanagedType.LPWStr),In] string srcFileRef, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef);		
        
        /// <summary>	
        /// Retrieves information about a given image in a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXGetImageInfoFromResourceW. Otherwise, the function call resolves to D3DXGetImageInfoFromResourceA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="hSrcModule"> Module where the resource is loaded. Set this parameter to NULL to specify the module associated with the image that the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with the description of the data in the source file. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromResourceA([None] void* hSrcModule,[None] const char* pSrcResource,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result D3DXGetImageInfoFromResourceA(IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetImageInfoFromResourceA_( hSrcModule,  srcResourceRef, ref  srcInfoRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromResourceA([None] void* hSrcModule,[None] const char* pSrcResource,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetImageInfoFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetImageInfoFromResourceA_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string srcResourceRef, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef);		
        
        /// <summary>	
        /// Retrieves information about a given image in a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXGetImageInfoFromResourceW. Otherwise, the function call resolves to D3DXGetImageInfoFromResourceA because ANSI strings are being used. 	
        /// </remarks>	
        /// <param name="hSrcModule"> Module where the resource is loaded. Set this parameter to NULL to specify the module associated with the image that the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with the description of the data in the source file. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromResourceW([None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result D3DXGetImageInfoFromResourceW(IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetImageInfoFromResourceW_( hSrcModule,  srcResourceRef, ref  srcInfoRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromResourceW([None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetImageInfoFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetImageInfoFromResourceW_(IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string srcResourceRef, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef);		
        
        /// <summary>	
        /// Retrieves information about a given image file in memory.	
        /// </summary>	
        /// <param name="srcDataRef"> VOID pointer to the source file in memory. </param>
        /// <param name="srcDataSize"> Size of file in memory, in bytes. . </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with the description of the data in the source file. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromFileInMemory([None] const void* pSrcData,[None] int SrcDataSize,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result D3DXGetImageInfoFromFileInMemory(IntPtr srcDataRef, int srcDataSize, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXGetImageInfoFromFileInMemory_( srcDataRef,  srcDataSize, ref  srcInfoRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXGetImageInfoFromFileInMemory([None] const void* pSrcData,[None] int SrcDataSize,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetImageInfoFromFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXGetImageInfoFromFileInMemory_(IntPtr srcDataRef, int srcDataSize, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef);		
        
        /// <summary>	
        /// Loads a surface from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXLoadSurfaceFromFileW. Otherwise, the function call resolves to D3DXLoadSurfaceFromFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats and supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Writing to a non-level-zero surface will not cause the dirty rectangle to be updated. If D3DXLoadSurfaceFromFile is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call {{AddDirtyRect}} on the surface. 	
        /// </remarks>	
        /// <param name="pDestSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface. Specifies the destination surface, which receives the image. </param>
        /// <param name="destPaletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="destRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the destination rectangle. Set this parameter to NULL to specify the entire surface. </param>
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="srcRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire image. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromFileA([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] const char* pSrcFile,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result D3DXLoadSurfaceFromFileA(SlimDX2.Direct3D9.Surface pDestSurface, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Rectangle destRectRef, string srcFileRef, ref SlimDX2.Rectangle srcRectRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadSurfaceFromFileA_((pDestSurface == null)?IntPtr.Zero:pDestSurface.NativePointer, ref  destPaletteRef, ref  destRectRef,  srcFileRef, ref  srcRectRef,  filter,  colorKey, ref  srcInfoRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromFileA([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] const char* pSrcFile,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadSurfaceFromFileA_(IntPtr pDestSurface, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Rectangle destRectRef, [MarshalAs(UnmanagedType.LPStr),In] string srcFileRef, ref SlimDX2.Rectangle srcRectRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef);		
        
        /// <summary>	
        /// Loads a surface from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXLoadSurfaceFromFileW. Otherwise, the function call resolves to D3DXLoadSurfaceFromFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats and supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Writing to a non-level-zero surface will not cause the dirty rectangle to be updated. If D3DXLoadSurfaceFromFile is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call {{AddDirtyRect}} on the surface. 	
        /// </remarks>	
        /// <param name="pDestSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface. Specifies the destination surface, which receives the image. </param>
        /// <param name="destPaletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="destRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the destination rectangle. Set this parameter to NULL to specify the entire surface. </param>
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="srcRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire image. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromFileW([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] const wchar_t* pSrcFile,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result D3DXLoadSurfaceFromFileW(SlimDX2.Direct3D9.Surface pDestSurface, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Rectangle destRectRef, string srcFileRef, ref SlimDX2.Rectangle srcRectRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadSurfaceFromFileW_((pDestSurface == null)?IntPtr.Zero:pDestSurface.NativePointer, ref  destPaletteRef, ref  destRectRef,  srcFileRef, ref  srcRectRef,  filter,  colorKey, ref  srcInfoRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromFileW([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] const wchar_t* pSrcFile,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadSurfaceFromFileW_(IntPtr pDestSurface, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Rectangle destRectRef, [MarshalAs(UnmanagedType.LPWStr),In] string srcFileRef, ref SlimDX2.Rectangle srcRectRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef);		
        
        /// <summary>	
        /// Loads a surface from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXLoadSurfaceFromResourceW. Otherwise, the function call resolves to D3DXLoadSurfaceFromResourceA because ANSI strings are being used. The resource being loaded must be of type RT_BITMAP or RT_RCDATA. Resource type RT_RCDATA is used to load formats other than bitmaps (such as .tga, .jpg, and .dds). This function handles conversion to and from compressed texture formats. Writing to a non-level-zero surface will not cause the dirty rectangle to be updated. If {{D3DXLoadSurfaceFromFile}} is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call {{AddDirtyRect}} on the surface. 	
        /// </remarks>	
        /// <param name="pDestSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface. Specifies the destination surface, which receives the image. </param>
        /// <param name="destPaletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="destRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the destination rectangle. Set this parameter to NULL to specify the entire surface. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="srcRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire image. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromResourceA([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] void* hSrcModule,[None] const char* pSrcResource,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result D3DXLoadSurfaceFromResourceA(SlimDX2.Direct3D9.Surface pDestSurface, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Rectangle destRectRef, IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Rectangle srcRectRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadSurfaceFromResourceA_((pDestSurface == null)?IntPtr.Zero:pDestSurface.NativePointer, ref  destPaletteRef, ref  destRectRef,  hSrcModule,  srcResourceRef, ref  srcRectRef,  filter,  colorKey, ref  srcInfoRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromResourceA([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] void* hSrcModule,[None] const char* pSrcResource,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadSurfaceFromResourceA_(IntPtr pDestSurface, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Rectangle destRectRef, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string srcResourceRef, ref SlimDX2.Rectangle srcRectRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef);		
        
        /// <summary>	
        /// Loads a surface from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXLoadSurfaceFromResourceW. Otherwise, the function call resolves to D3DXLoadSurfaceFromResourceA because ANSI strings are being used. The resource being loaded must be of type RT_BITMAP or RT_RCDATA. Resource type RT_RCDATA is used to load formats other than bitmaps (such as .tga, .jpg, and .dds). This function handles conversion to and from compressed texture formats. Writing to a non-level-zero surface will not cause the dirty rectangle to be updated. If {{D3DXLoadSurfaceFromFile}} is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call {{AddDirtyRect}} on the surface. 	
        /// </remarks>	
        /// <param name="pDestSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface. Specifies the destination surface, which receives the image. </param>
        /// <param name="destPaletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="destRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the destination rectangle. Set this parameter to NULL to specify the entire surface. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="srcRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire image. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromResourceW([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result D3DXLoadSurfaceFromResourceW(SlimDX2.Direct3D9.Surface pDestSurface, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Rectangle destRectRef, IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Rectangle srcRectRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadSurfaceFromResourceW_((pDestSurface == null)?IntPtr.Zero:pDestSurface.NativePointer, ref  destPaletteRef, ref  destRectRef,  hSrcModule,  srcResourceRef, ref  srcRectRef,  filter,  colorKey, ref  srcInfoRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromResourceW([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadSurfaceFromResourceW_(IntPtr pDestSurface, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Rectangle destRectRef, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string srcResourceRef, ref SlimDX2.Rectangle srcRectRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef);		
        
        /// <summary>	
        /// Loads a surface from a file in memory.	
        /// </summary>	
        /// <remarks>	
        ///  This function handles conversion to and from compressed texture formats and supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Writing to a non-level-zero surface will not cause the dirty rectangle to be updated. If D3DXLoadSurfaceFromFileInMemory is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call {{AddDirtyRect}} on the surface. 	
        /// </remarks>	
        /// <param name="pDestSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface. Specifies the destination surface, which receives the image. </param>
        /// <param name="destPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="destRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the destination rectangle. Set this parameter to NULL to specify the entire surface. </param>
        /// <param name="srcDataRef"> Pointer to the file in memory from which to load the surface. </param>
        /// <param name="srcDataSize"> Size of the file in memory, in bytes. </param>
        /// <param name="srcRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire image. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromFileInMemory([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] const void* pSrcData,[None] int SrcDataSize,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result D3DXLoadSurfaceFromFileInMemory(SlimDX2.Direct3D9.Surface pDestSurface, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Rectangle destRectRef, IntPtr srcDataRef, int srcDataSize, ref SlimDX2.Rectangle srcRectRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadSurfaceFromFileInMemory_((pDestSurface == null)?IntPtr.Zero:pDestSurface.NativePointer, ref  destPaletteRef, ref  destRectRef,  srcDataRef,  srcDataSize, ref  srcRectRef,  filter,  colorKey, ref  srcInfoRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromFileInMemory([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] const void* pSrcData,[None] int SrcDataSize,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadSurfaceFromFileInMemory_(IntPtr pDestSurface, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Rectangle destRectRef, IntPtr srcDataRef, int srcDataSize, ref SlimDX2.Rectangle srcRectRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef);		
        
        /// <summary>	
        /// Loads a surface from another surface with color conversion.	
        /// </summary>	
        /// <remarks>	
        ///  This function handles conversion to and from compressed texture formats. Writing to a non-level-zero surface will not cause the dirty rectangle to be updated. If D3DXLoadSurfaceFromSurface is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call {{AddDirtyRect}} on the surface. 	
        /// </remarks>	
        /// <param name="pDestSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface. Specifies the destination surface, which receives the image. </param>
        /// <param name="destPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="destRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the destination rectangle. Set this parameter to NULL to specify the entire surface. </param>
        /// <param name="pSrcSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface, representing the source surface. </param>
        /// <param name="srcPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the source palette of 256 colors or NULL. </param>
        /// <param name="srcRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire surface. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromSurface([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] LPDIRECT3DSURFACE9 pSrcSurface,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey)</unmanaged>
		public static SlimDX2.Result D3DXLoadSurfaceFromSurface(SlimDX2.Direct3D9.Surface pDestSurface, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Rectangle destRectRef, SlimDX2.Direct3D9.Surface pSrcSurface, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Rectangle srcRectRef, int filter, SlimMath.Color4 colorKey) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadSurfaceFromSurface_((pDestSurface == null)?IntPtr.Zero:pDestSurface.NativePointer, ref  destPaletteRef, ref  destRectRef, (pSrcSurface == null)?IntPtr.Zero:pSrcSurface.NativePointer, ref  srcPaletteRef, ref  srcRectRef,  filter,  colorKey);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromSurface([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] LPDIRECT3DSURFACE9 pSrcSurface,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromSurface", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadSurfaceFromSurface_(IntPtr pDestSurface, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Rectangle destRectRef, IntPtr pSrcSurface, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Rectangle srcRectRef, int filter, SlimMath.Color4 colorKey);		
        
        /// <summary>	
        /// Loads a surface from memory.	
        /// </summary>	
        /// <remarks>	
        ///  This function handles conversion to and from compressed texture formats. Writing to a non-level-zero surface will not cause the dirty rectangle to be updated. If D3DXLoadSurfaceFromMemory is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call {{AddDirtyRect}} on the surface. 	
        /// </remarks>	
        /// <param name="pDestSurface"> Pointer to an <see cref="SlimDX2.Direct3D9.Surface"/> interface. Specifies the destination surface, which receives the image. </param>
        /// <param name="destPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="destRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the destination rectangle. Set this parameter to NULL to specify the entire surface. </param>
        /// <param name="srcMemoryRef"> Pointer to the upper left corner of the source image in memory. </param>
        /// <param name="srcFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, the pixel format of the source image. </param>
        /// <param name="srcPitch"> Pitch of source image, in bytes. For DXT formats, this number should represent the width of one row of cells, in bytes. </param>
        /// <param name="srcPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the source palette of 256 colors or NULL. </param>
        /// <param name="srcRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the dimensions of the source image in memory. This value cannot be NULL. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromMemory([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] const void* pSrcMemory,[None] D3DFORMAT SrcFormat,[None] int SrcPitch,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey)</unmanaged>
		public static SlimDX2.Result D3DXLoadSurfaceFromMemory(SlimDX2.Direct3D9.Surface pDestSurface, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Rectangle destRectRef, IntPtr srcMemoryRef, SlimDX2.Direct3D9.Format srcFormat, int srcPitch, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Rectangle srcRectRef, int filter, SlimMath.Color4 colorKey) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadSurfaceFromMemory_((pDestSurface == null)?IntPtr.Zero:pDestSurface.NativePointer, ref  destPaletteRef, ref  destRectRef,  srcMemoryRef,  srcFormat,  srcPitch, ref  srcPaletteRef, ref  srcRectRef,  filter,  colorKey);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromMemory([None] LPDIRECT3DSURFACE9 pDestSurface,[None] const PALETTEENTRY* pDestPalette,[None] const RECT* pDestRect,[None] const void* pSrcMemory,[None] D3DFORMAT SrcFormat,[None] int SrcPitch,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect,[None] int Filter,[None] D3DCOLOR ColorKey)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadSurfaceFromMemory_(IntPtr pDestSurface, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Rectangle destRectRef, IntPtr srcMemoryRef, SlimDX2.Direct3D9.Format srcFormat, int srcPitch, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Rectangle srcRectRef, int filter, SlimMath.Color4 colorKey);		
        
        /// <summary>	
        /// Saves a surface to a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXSaveSurfaceToFileW. Otherwise, the function call resolves to D3DXSaveSurfaceToFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats. 	
        /// </remarks>	
        /// <param name="destFileRef"> Pointer to a string that specifies the file name of the destination image. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileFormat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcSurface"> Pointer to <see cref="SlimDX2.Direct3D9.Surface"/> interface, containing the image to be saved. </param>
        /// <param name="srcPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <param name="srcRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire image. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXSaveSurfaceToFileA([None] const char* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DSURFACE9 pSrcSurface,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect)</unmanaged>
		public static SlimDX2.Result D3DXSaveSurfaceToFileA(string destFileRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, SlimDX2.Direct3D9.Surface pSrcSurface, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Rectangle srcRectRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveSurfaceToFileA_( destFileRef,  destFormat, (pSrcSurface == null)?IntPtr.Zero:pSrcSurface.NativePointer, ref  srcPaletteRef, ref  srcRectRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveSurfaceToFileA([None] const char* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DSURFACE9 pSrcSurface,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveSurfaceToFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveSurfaceToFileA_([MarshalAs(UnmanagedType.LPStr),In] string destFileRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, IntPtr pSrcSurface, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Rectangle srcRectRef);		
        
        /// <summary>	
        /// Saves a surface to a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXSaveSurfaceToFileW. Otherwise, the function call resolves to D3DXSaveSurfaceToFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats. 	
        /// </remarks>	
        /// <param name="destFileRef"> Pointer to a string that specifies the file name of the destination image. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileFormat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcSurface"> Pointer to <see cref="SlimDX2.Direct3D9.Surface"/> interface, containing the image to be saved. </param>
        /// <param name="srcPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <param name="srcRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire image. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXSaveSurfaceToFileW([None] const wchar_t* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DSURFACE9 pSrcSurface,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect)</unmanaged>
		public static SlimDX2.Result D3DXSaveSurfaceToFileW(string destFileRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, SlimDX2.Direct3D9.Surface pSrcSurface, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Rectangle srcRectRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveSurfaceToFileW_( destFileRef,  destFormat, (pSrcSurface == null)?IntPtr.Zero:pSrcSurface.NativePointer, ref  srcPaletteRef, ref  srcRectRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveSurfaceToFileW([None] const wchar_t* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DSURFACE9 pSrcSurface,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveSurfaceToFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveSurfaceToFileW_([MarshalAs(UnmanagedType.LPWStr),In] string destFileRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, IntPtr pSrcSurface, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Rectangle srcRectRef);		
        
        /// <summary>	
        /// Saves a surface to an image file.	
        /// </summary>	
        /// <remarks>	
        ///  This function handles conversion to and from compressed texture formats. 	
        /// </remarks>	
        /// <param name="destBufRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> that will store the image. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileFormat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcSurface"> Pointer to <see cref="SlimDX2.Direct3D9.Surface"/> interface containing the image to be saved. </param>
        /// <param name="srcPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <param name="srcRectRef"> Pointer to a <see cref="SlimDX2.Rectangle"/> structure. Specifies the source rectangle. Set this parameter to NULL to specify the entire image. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXSaveSurfaceToFileInMemory([None] LPD3DXBUFFER* ppDestBuf,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DSURFACE9 pSrcSurface,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect)</unmanaged>
		public static SlimDX2.Result D3DXSaveSurfaceToFileInMemory(out SlimDX2.Direct3D9.ShaderBytecode destBufRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, SlimDX2.Direct3D9.Surface pSrcSurface, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Rectangle srcRectRef) {
            unsafe {
                IntPtr destBufRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveSurfaceToFileInMemory_(out destBufRef_,  destFormat, (pSrcSurface == null)?IntPtr.Zero:pSrcSurface.NativePointer, ref  srcPaletteRef, ref  srcRectRef);
                destBufRef = (destBufRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(destBufRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveSurfaceToFileInMemory([None] LPD3DXBUFFER* ppDestBuf,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DSURFACE9 pSrcSurface,[None] const PALETTEENTRY* pSrcPalette,[None] const RECT* pSrcRect)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveSurfaceToFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveSurfaceToFileInMemory_(out IntPtr destBufRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, IntPtr pSrcSurface, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Rectangle srcRectRef);		
        
        /// <summary>	
        /// Loads a volume from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXLoadVolumeFromFileW. Otherwise, the function call resolves to D3DXLoadVolumeFromFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats and supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If D3DXLoadVolumeFromFile is called and the texture was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <see cref="SlimDX2.Direct3D9.VolumeTexture.AddDirtyBox"/> on the volume texture. 	
        /// </remarks>	
        /// <param name="pDestVolume"> Pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface. Specifies the destination volume. </param>
        /// <param name="destPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="destBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the destination box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="srcBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromFileA([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] const char* pSrcFile,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result D3DXLoadVolumeFromFileA(SlimDX2.Direct3D9.Volume pDestVolume, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Direct3D9.Box destBoxRef, string srcFileRef, ref SlimDX2.Direct3D9.Box srcBoxRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadVolumeFromFileA_((pDestVolume == null)?IntPtr.Zero:pDestVolume.NativePointer, ref  destPaletteRef, ref  destBoxRef,  srcFileRef, ref  srcBoxRef,  filter,  colorKey, ref  srcInfoRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromFileA([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] const char* pSrcFile,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadVolumeFromFileA_(IntPtr pDestVolume, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Direct3D9.Box destBoxRef, [MarshalAs(UnmanagedType.LPStr),In] string srcFileRef, ref SlimDX2.Direct3D9.Box srcBoxRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef);		
        
        /// <summary>	
        /// Loads a volume from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXLoadVolumeFromFileW. Otherwise, the function call resolves to D3DXLoadVolumeFromFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats and supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If D3DXLoadVolumeFromFile is called and the texture was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <see cref="SlimDX2.Direct3D9.VolumeTexture.AddDirtyBox"/> on the volume texture. 	
        /// </remarks>	
        /// <param name="pDestVolume"> Pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface. Specifies the destination volume. </param>
        /// <param name="destPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="destBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the destination box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="srcBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromFileW([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] const wchar_t* pSrcFile,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result D3DXLoadVolumeFromFileW(SlimDX2.Direct3D9.Volume pDestVolume, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Direct3D9.Box destBoxRef, string srcFileRef, ref SlimDX2.Direct3D9.Box srcBoxRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadVolumeFromFileW_((pDestVolume == null)?IntPtr.Zero:pDestVolume.NativePointer, ref  destPaletteRef, ref  destBoxRef,  srcFileRef, ref  srcBoxRef,  filter,  colorKey, ref  srcInfoRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromFileW([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] const wchar_t* pSrcFile,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadVolumeFromFileW_(IntPtr pDestVolume, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Direct3D9.Box destBoxRef, [MarshalAs(UnmanagedType.LPWStr),In] string srcFileRef, ref SlimDX2.Direct3D9.Box srcBoxRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef);		
        
        /// <summary>	
        /// Loads a volume from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The resource being loaded must be a bitmap resource(RT_BITMAP). This function handles conversion to and from compressed texture formats. Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If {{D3DXLoadVolumeFromFile}} is called and the texture was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <see cref="SlimDX2.Direct3D9.VolumeTexture.AddDirtyBox"/> on the volume texture. This function supports both Unicode and ANSI strings. 	
        /// </remarks>	
        /// <param name="pDestVolume"> Pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface. Specifies the destination volume. </param>
        /// <param name="destPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="destBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the destination box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the file name of the source image.  If UNICODE or _UNICODE are defined, this parameter type is LPCWSTR, otherwise, the type is LPCSTR. </param>
        /// <param name="srcBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromResourceA([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] void* hSrcModule,[None] const char* pSrcResource,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result D3DXLoadVolumeFromResourceA(SlimDX2.Direct3D9.Volume pDestVolume, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Direct3D9.Box destBoxRef, IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Direct3D9.Box srcBoxRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadVolumeFromResourceA_((pDestVolume == null)?IntPtr.Zero:pDestVolume.NativePointer, ref  destPaletteRef, ref  destBoxRef,  hSrcModule,  srcResourceRef, ref  srcBoxRef,  filter,  colorKey, ref  srcInfoRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromResourceA([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] void* hSrcModule,[None] const char* pSrcResource,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadVolumeFromResourceA_(IntPtr pDestVolume, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Direct3D9.Box destBoxRef, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string srcResourceRef, ref SlimDX2.Direct3D9.Box srcBoxRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef);		
        
        /// <summary>	
        /// Loads a volume from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The resource being loaded must be a bitmap resource(RT_BITMAP). This function handles conversion to and from compressed texture formats. Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If {{D3DXLoadVolumeFromFile}} is called and the texture was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <see cref="SlimDX2.Direct3D9.VolumeTexture.AddDirtyBox"/> on the volume texture. This function supports both Unicode and ANSI strings. 	
        /// </remarks>	
        /// <param name="pDestVolume"> Pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface. Specifies the destination volume. </param>
        /// <param name="destPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="destBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the destination box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the file name of the source image.  If UNICODE or _UNICODE are defined, this parameter type is LPCWSTR, otherwise, the type is LPCSTR. </param>
        /// <param name="srcBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromResourceW([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result D3DXLoadVolumeFromResourceW(SlimDX2.Direct3D9.Volume pDestVolume, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Direct3D9.Box destBoxRef, IntPtr hSrcModule, string srcResourceRef, ref SlimDX2.Direct3D9.Box srcBoxRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadVolumeFromResourceW_((pDestVolume == null)?IntPtr.Zero:pDestVolume.NativePointer, ref  destPaletteRef, ref  destBoxRef,  hSrcModule,  srcResourceRef, ref  srcBoxRef,  filter,  colorKey, ref  srcInfoRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromResourceW([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadVolumeFromResourceW_(IntPtr pDestVolume, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Direct3D9.Box destBoxRef, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string srcResourceRef, ref SlimDX2.Direct3D9.Box srcBoxRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef);		
        
        /// <summary>	
        /// Loads a volume from a file in memory.	
        /// </summary>	
        /// <remarks>	
        ///  This function handles conversion to and from compressed texture formats and supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If D3DXLoadVolumeFromFileInMemory is called and the texture was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <see cref="SlimDX2.Direct3D9.VolumeTexture.AddDirtyBox"/> on the volume texture. 	
        /// </remarks>	
        /// <param name="pDestVolume"> Pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface. Specifies the destination volume. </param>
        /// <param name="destPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="destBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the destination box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="srcDataRef"> Pointer to the file in memory from which to load the volume. </param>
        /// <param name="srcDataSize"> Size in bytes of the file in memory. </param>
        /// <param name="srcBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromFileInMemory([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] const void* pSrcData,[None] int SrcDataSize,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		public static SlimDX2.Result D3DXLoadVolumeFromFileInMemory(SlimDX2.Direct3D9.Volume pDestVolume, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Direct3D9.Box destBoxRef, IntPtr srcDataRef, int srcDataSize, ref SlimDX2.Direct3D9.Box srcBoxRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadVolumeFromFileInMemory_((pDestVolume == null)?IntPtr.Zero:pDestVolume.NativePointer, ref  destPaletteRef, ref  destBoxRef,  srcDataRef,  srcDataSize, ref  srcBoxRef,  filter,  colorKey, ref  srcInfoRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromFileInMemory([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] const void* pSrcData,[None] int SrcDataSize,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadVolumeFromFileInMemory_(IntPtr pDestVolume, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Direct3D9.Box destBoxRef, IntPtr srcDataRef, int srcDataSize, ref SlimDX2.Direct3D9.Box srcBoxRef, int filter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef);		
        
        /// <summary>	
        /// Loads a volume from another volume.	
        /// </summary>	
        /// <remarks>	
        ///  Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If D3DXLoadVolumeFromVolume is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <see cref="SlimDX2.Direct3D9.VolumeTexture.AddDirtyBox"/> on the surface. 	
        /// </remarks>	
        /// <param name="pDestVolume"> Pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface. Specifies the destination volume, which receives the image. </param>
        /// <param name="destPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="destBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the destination box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="pSrcVolume"> A Pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface. Specifies the source volume. </param>
        /// <param name="srcPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the source palette of 256 colors or NULL. </param>
        /// <param name="srcBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromVolume([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] LPDIRECT3DVOLUME9 pSrcVolume,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey)</unmanaged>
		public static SlimDX2.Result D3DXLoadVolumeFromVolume(SlimDX2.Direct3D9.Volume pDestVolume, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Direct3D9.Box destBoxRef, SlimDX2.Direct3D9.Volume pSrcVolume, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Direct3D9.Box srcBoxRef, int filter, SlimMath.Color4 colorKey) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadVolumeFromVolume_((pDestVolume == null)?IntPtr.Zero:pDestVolume.NativePointer, ref  destPaletteRef, ref  destBoxRef, (pSrcVolume == null)?IntPtr.Zero:pSrcVolume.NativePointer, ref  srcPaletteRef, ref  srcBoxRef,  filter,  colorKey);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromVolume([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] LPDIRECT3DVOLUME9 pSrcVolume,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromVolume", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadVolumeFromVolume_(IntPtr pDestVolume, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Direct3D9.Box destBoxRef, IntPtr pSrcVolume, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Direct3D9.Box srcBoxRef, int filter, SlimMath.Color4 colorKey);		
        
        /// <summary>	
        /// Loads a volume from memory.	
        /// </summary>	
        /// <remarks>	
        ///  Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If D3DXLoadVolumeFromMemory is called and the texture was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <see cref="SlimDX2.Direct3D9.VolumeTexture.AddDirtyBox"/> on the volume texture. 	
        /// </remarks>	
        /// <param name="pDestVolume"> Pointer to an <see cref="SlimDX2.Direct3D9.Volume"/> interface. Specifies the destination volume, which receives the image. </param>
        /// <param name="destPaletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, the destination palette of 256 colors or NULL. </param>
        /// <param name="destBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the destination box. Set this parameter to NULL to specify the entire volume. </param>
        /// <param name="srcMemoryRef"> Pointer to the top-left corner of the source volume in memory. </param>
        /// <param name="srcFormat"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, the pixel format of the source volume. </param>
        /// <param name="srcRowPitch"> Pitch of source image, in bytes. For DXT formats (compressed texture formats), this number should represent the size of one row of cells, in bytes. </param>
        /// <param name="srcSlicePitch"> Pitch of source image, in bytes. For DXT formats (compressed texture formats), this number should represent the size of one slice of cells, in bytes. </param>
        /// <param name="srcPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure, the source palette of 256 colors or NULL. </param>
        /// <param name="srcBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. NULL is not a valid value for this parameter. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromMemory([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] const void* pSrcMemory,[None] D3DFORMAT SrcFormat,[None] int SrcRowPitch,[None] int SrcSlicePitch,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey)</unmanaged>
		public static SlimDX2.Result D3DXLoadVolumeFromMemory(SlimDX2.Direct3D9.Volume pDestVolume, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Direct3D9.Box destBoxRef, IntPtr srcMemoryRef, SlimDX2.Direct3D9.Format srcFormat, int srcRowPitch, int srcSlicePitch, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Direct3D9.Box srcBoxRef, int filter, SlimMath.Color4 colorKey) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadVolumeFromMemory_((pDestVolume == null)?IntPtr.Zero:pDestVolume.NativePointer, ref  destPaletteRef, ref  destBoxRef,  srcMemoryRef,  srcFormat,  srcRowPitch,  srcSlicePitch, ref  srcPaletteRef, ref  srcBoxRef,  filter,  colorKey);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadVolumeFromMemory([None] LPDIRECT3DVOLUME9 pDestVolume,[None] const PALETTEENTRY* pDestPalette,[None] const D3DBOX* pDestBox,[None] const void* pSrcMemory,[None] D3DFORMAT SrcFormat,[None] int SrcRowPitch,[None] int SrcSlicePitch,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox,[None] int Filter,[None] D3DCOLOR ColorKey)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadVolumeFromMemory_(IntPtr pDestVolume, ref SlimDX2.Windows.Paletteentry destPaletteRef, ref SlimDX2.Direct3D9.Box destBoxRef, IntPtr srcMemoryRef, SlimDX2.Direct3D9.Format srcFormat, int srcRowPitch, int srcSlicePitch, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Direct3D9.Box srcBoxRef, int filter, SlimMath.Color4 colorKey);		
        
        /// <summary>	
        /// Saves a volume to a file on disk.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXSaveVolumeToFileW. Otherwise, the function call resolves to &gt;D3DXSaveVolumeToFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats. If the volume is nondynamic (because of a usage parameter set to 0 at the creation) and located in video memory (the memory pool set to D3DPOOL_DEFAULT), {{D3DXSaveTextureToFile}} will fail because D3DX cannot lock nondynamic volumes located in video memory. 	
        /// </remarks>	
        /// <param name="destFileRef"> Pointer to a string that specifies the file name of the destination image. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileFormat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcVolume"> Pointer to <see cref="SlimDX2.Direct3D9.Volume"/> interface containing the image to be saved. </param>
        /// <param name="srcPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <param name="srcBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXSaveVolumeToFileA([None] const char* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DVOLUME9 pSrcVolume,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox)</unmanaged>
		public static SlimDX2.Result D3DXSaveVolumeToFileA(string destFileRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, SlimDX2.Direct3D9.Volume pSrcVolume, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Direct3D9.Box srcBoxRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveVolumeToFileA_( destFileRef,  destFormat, (pSrcVolume == null)?IntPtr.Zero:pSrcVolume.NativePointer, ref  srcPaletteRef, ref  srcBoxRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveVolumeToFileA([None] const char* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DVOLUME9 pSrcVolume,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveVolumeToFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveVolumeToFileA_([MarshalAs(UnmanagedType.LPStr),In] string destFileRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, IntPtr pSrcVolume, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Direct3D9.Box srcBoxRef);		
        
        /// <summary>	
        /// Saves a volume to a file on disk.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXSaveVolumeToFileW. Otherwise, the function call resolves to &gt;D3DXSaveVolumeToFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats. If the volume is nondynamic (because of a usage parameter set to 0 at the creation) and located in video memory (the memory pool set to D3DPOOL_DEFAULT), {{D3DXSaveTextureToFile}} will fail because D3DX cannot lock nondynamic volumes located in video memory. 	
        /// </remarks>	
        /// <param name="destFileRef"> Pointer to a string that specifies the file name of the destination image. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileFormat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcVolume"> Pointer to <see cref="SlimDX2.Direct3D9.Volume"/> interface containing the image to be saved. </param>
        /// <param name="srcPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <param name="srcBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXSaveVolumeToFileW([None] const wchar_t* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DVOLUME9 pSrcVolume,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox)</unmanaged>
		public static SlimDX2.Result D3DXSaveVolumeToFileW(string destFileRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, SlimDX2.Direct3D9.Volume pSrcVolume, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Direct3D9.Box srcBoxRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveVolumeToFileW_( destFileRef,  destFormat, (pSrcVolume == null)?IntPtr.Zero:pSrcVolume.NativePointer, ref  srcPaletteRef, ref  srcBoxRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveVolumeToFileW([None] const wchar_t* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DVOLUME9 pSrcVolume,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveVolumeToFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveVolumeToFileW_([MarshalAs(UnmanagedType.LPWStr),In] string destFileRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, IntPtr pSrcVolume, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Direct3D9.Box srcBoxRef);		
        
        /// <summary>	
        /// Saves a volume to a buffer. The method creates an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> buffer to store the data, and returns that object.	
        /// </summary>	
        /// <param name="destBufRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> buffer that will store the image. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileFormat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcVolume"> Pointer to <see cref="SlimDX2.Direct3D9.Volume"/> interface containing the image to be saved. </param>
        /// <param name="srcPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <param name="srcBoxRef"> Pointer to a <see cref="SlimDX2.Direct3D9.Box"/> structure. Specifies the source box. Set this parameter to NULL to specify the entire volume. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXSaveVolumeToFileInMemory([None] LPD3DXBUFFER* ppDestBuf,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DVOLUME9 pSrcVolume,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox)</unmanaged>
		public static SlimDX2.Result D3DXSaveVolumeToFileInMemory(out SlimDX2.Direct3D9.ShaderBytecode destBufRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, SlimDX2.Direct3D9.Volume pSrcVolume, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Direct3D9.Box srcBoxRef) {
            unsafe {
                IntPtr destBufRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveVolumeToFileInMemory_(out destBufRef_,  destFormat, (pSrcVolume == null)?IntPtr.Zero:pSrcVolume.NativePointer, ref  srcPaletteRef, ref  srcBoxRef);
                destBufRef = (destBufRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(destBufRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveVolumeToFileInMemory([None] LPD3DXBUFFER* ppDestBuf,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DVOLUME9 pSrcVolume,[None] const PALETTEENTRY* pSrcPalette,[None] const D3DBOX* pSrcBox)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveVolumeToFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveVolumeToFileInMemory_(out IntPtr destBufRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, IntPtr pSrcVolume, ref SlimDX2.Windows.Paletteentry srcPaletteRef, ref SlimDX2.Direct3D9.Box srcBoxRef);		
        
        /// <summary>	
        /// Checks texture-creation parameters.	
        /// </summary>	
        /// <remarks>	
        ///  If parameters to this function are invalid, this function returns corrected parameters. This function uses the following heuristics when comparing the requested requirements against available formats:  Do not choose a format that has fewer channels. Avoid {{FOURCC}} And 24-bit formats unless explicitly requested. Try not to add new channels. Try not to change the number of bits per channel. Try to avoid converting between types of formats. For instance, avoid converting an ARGB format to a depth format.  	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="widthRef"> Pointer to the requested width in pixels, or NULL. Returns the corrected size. </param>
        /// <param name="heightRef"> Pointer to the requested height in pixels, or NULL. Returns the corrected size. </param>
        /// <param name="numMipLevelsRef"> Pointer to number of requested mipmap levels, or NULL. Returns the corrected number of mipmap levels. </param>
        /// <param name="usage"> 0 or <see cref="SlimDX2.Direct3D9.Usage.RenderTarget"/>. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If D3DUSAGE_RENDERTARGET is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. </param>
        /// <param name="formatRef"> Pointer to a member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type. Specifies the desired pixel format, or NULL. Returns the corrected format. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE. </returns>
        /// <unmanaged>HRESULT D3DXCheckTextureRequirements([None] LPDIRECT3DDEVICE9 pDevice,[None] int* pWidth,[None] int* pHeight,[None] int* pNumMipLevels,[None] int Usage,[None] D3DFORMAT* pFormat,[None] D3DPOOL Pool)</unmanaged>
		public static SlimDX2.Result D3DXCheckTextureRequirements(SlimDX2.Direct3D9.Device pDevice, ref int widthRef, ref int heightRef, ref int numMipLevelsRef, int usage, ref SlimDX2.Direct3D9.Format formatRef, SlimDX2.Direct3D9.Pool pool) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCheckTextureRequirements_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer, ref  widthRef, ref  heightRef, ref  numMipLevelsRef,  usage, ref  formatRef,  pool);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCheckTextureRequirements([None] LPDIRECT3DDEVICE9 pDevice,[None] int* pWidth,[None] int* pHeight,[None] int* pNumMipLevels,[None] int Usage,[None] D3DFORMAT* pFormat,[None] D3DPOOL Pool)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCheckTextureRequirements", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCheckTextureRequirements_(IntPtr pDevice, ref int widthRef, ref int heightRef, ref int numMipLevelsRef, int usage, ref SlimDX2.Direct3D9.Format formatRef, SlimDX2.Direct3D9.Pool pool);		
        
        /// <summary>	
        /// Checks cube-texture-creation parameters.	
        /// </summary>	
        /// <remarks>	
        ///  If parameters to this function are invalid, this function returns corrected parameters. Cube textures differ from other surfaces in that they are collections of surfaces. To call {{SetRenderTarget}} with a cube texture, you must select an individual face using {{GetCubeMapSurface}} and pass the resulting surface to SetRenderTarget. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="sizeRef"> Pointer to the requested width and height in pixels, or NULL. Returns the corrected size. </param>
        /// <param name="numMipLevelsRef"> Pointer to the number of requested mipmap levels, or NULL. Returns the corrected number of mipmap levels. </param>
        /// <param name="usage"> 0 or D3DUSAGE_RENDERTARGET. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If D3DUSAGE_RENDERTARGET is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. </param>
        /// <param name="formatRef"> Pointer to a member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type. Specifies the desired pixel format, or NULL. Returns the corrected format. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXCheckCubeTextureRequirements([None] LPDIRECT3DDEVICE9 pDevice,[None] int* pSize,[None] int* pNumMipLevels,[None] int Usage,[None] D3DFORMAT* pFormat,[None] D3DPOOL Pool)</unmanaged>
		public static SlimDX2.Result D3DXCheckCubeTextureRequirements(SlimDX2.Direct3D9.Device pDevice, ref int sizeRef, ref int numMipLevelsRef, int usage, ref SlimDX2.Direct3D9.Format formatRef, SlimDX2.Direct3D9.Pool pool) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCheckCubeTextureRequirements_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer, ref  sizeRef, ref  numMipLevelsRef,  usage, ref  formatRef,  pool);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCheckCubeTextureRequirements([None] LPDIRECT3DDEVICE9 pDevice,[None] int* pSize,[None] int* pNumMipLevels,[None] int Usage,[None] D3DFORMAT* pFormat,[None] D3DPOOL Pool)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCheckCubeTextureRequirements", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCheckCubeTextureRequirements_(IntPtr pDevice, ref int sizeRef, ref int numMipLevelsRef, int usage, ref SlimDX2.Direct3D9.Format formatRef, SlimDX2.Direct3D9.Pool pool);		
        
        /// <summary>	
        /// Checks volume-texture-creation parameters.	
        /// </summary>	
        /// <remarks>	
        ///  If parameters to this function are invalid, this function returns corrected parameters. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the volume texture. </param>
        /// <param name="widthRef"> Pointer to the requested width in pixels, or NULL. Returns the corrected size. </param>
        /// <param name="heightRef"> Pointer to the requested height in pixels, or NULL. Returns the corrected size. </param>
        /// <param name="depthRef"> Pointer to the requested depth in pixels, or NULL. Returns the corrected size. </param>
        /// <param name="numMipLevelsRef"> Pointer to the number of requested mipmap levels, or NULL. Returns the corrected number of mipmap levels. </param>
        /// <param name="usage"> Currently not used, set to 0. </param>
        /// <param name="formatRef"> Pointer to a member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type. Specifies the desired pixel format, or NULL. Returns the corrected format. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the volume texture should be placed. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXCheckVolumeTextureRequirements([None] LPDIRECT3DDEVICE9 pDevice,[None] int* pWidth,[None] int* pHeight,[None] int* pDepth,[None] int* pNumMipLevels,[None] int Usage,[None] D3DFORMAT* pFormat,[None] D3DPOOL Pool)</unmanaged>
		public static SlimDX2.Result D3DXCheckVolumeTextureRequirements(SlimDX2.Direct3D9.Device pDevice, ref int widthRef, ref int heightRef, ref int depthRef, ref int numMipLevelsRef, int usage, ref SlimDX2.Direct3D9.Format formatRef, SlimDX2.Direct3D9.Pool pool) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCheckVolumeTextureRequirements_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer, ref  widthRef, ref  heightRef, ref  depthRef, ref  numMipLevelsRef,  usage, ref  formatRef,  pool);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCheckVolumeTextureRequirements([None] LPDIRECT3DDEVICE9 pDevice,[None] int* pWidth,[None] int* pHeight,[None] int* pDepth,[None] int* pNumMipLevels,[None] int Usage,[None] D3DFORMAT* pFormat,[None] D3DPOOL Pool)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCheckVolumeTextureRequirements", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCheckVolumeTextureRequirements_(IntPtr pDevice, ref int widthRef, ref int heightRef, ref int depthRef, ref int numMipLevelsRef, int usage, ref SlimDX2.Direct3D9.Format formatRef, SlimDX2.Direct3D9.Pool pool);		
        
        /// <summary>	
        /// Creates an empty texture, adjusting the calling parameters as needed.	
        /// </summary>	
        /// <remarks>	
        ///  Internally, D3DXCreateTexture uses <see cref="SlimDX2.Direct3D9.D3DX9.D3DXCheckTextureRequirements"/> to adjust the calling parameters. Therefore, calls to D3DXCreateTexture will often succeed where calls to {{CreateTexture}} would fail. If both Height and Width are set to {{D3DX_DEFAULT}}, a value of 256 is used for both parameters. If either Height or Width is set to D3DX_DEFAULT And the other parameter is set to a numeric value, the texture will be square with both the height and width equal to the numeric value. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="width"> Width in pixels. If this value is 0, a value of 1 is used. See Remarks. </param>
        /// <param name="height"> Height in pixels. If this value is 0, a value of 1 is used. See Remarks. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, <see cref="SlimDX2.Direct3D9.Usage.RenderTarget"/>, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target by calling the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE_DYNAMIC is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture may be of a different format from that specified, if the device does not support the requested format. Applications should check the format of the returned texture to see if it matches the format requested. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="textureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTexture([None] LPDIRECT3DDEVICE9 pDevice,[None] int Width,[None] int Height,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateTexture(SlimDX2.Direct3D9.Device pDevice, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.Texture textureRef) {
            unsafe {
                IntPtr textureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTexture_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  width,  height,  mipLevels,  usage,  format,  pool, out textureRef_);
                textureRef = (textureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(textureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTexture([None] LPDIRECT3DDEVICE9 pDevice,[None] int Width,[None] int Height,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTexture", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTexture_(IntPtr pDevice, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out IntPtr textureRef);		
        
        /// <summary>	
        /// Creates an empty cube texture, adjusting the calling parameters as needed.	
        /// </summary>	
        /// <remarks>	
        ///  Cube textures differ from other surfaces in that they are collections of surfaces.  Internally, D3DXCreateCubeTexture uses <see cref="SlimDX2.Direct3D9.D3DX9.D3DXCheckCubeTextureRequirements"/> to adjust the calling parameters. Therefore, calls to D3DXCreateCubeTexture will often succeed where calls to {{CreateCubeTexture}} would fail. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="size"> Width and height of the cube texture, in pixels. For example, if the cube texture is an 8-pixel by 8-pixel cube, the value for this parameter should be 8. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If D3DUSAGE_RENDERTARGET is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the cube texture. The returned cube texture might have a different format from that specified by  Format. Applications should check the format of the returned cube texture. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the cube texture should be placed. </param>
        /// <param name="cubeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTexture([None] LPDIRECT3DDEVICE9 pDevice,[None] int Size,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateCubeTexture(SlimDX2.Direct3D9.Device pDevice, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.CubeTexture cubeTextureRef) {
            unsafe {
                IntPtr cubeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTexture_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  size,  mipLevels,  usage,  format,  pool, out cubeTextureRef_);
                cubeTextureRef = (cubeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(cubeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTexture([None] LPDIRECT3DDEVICE9 pDevice,[None] int Size,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTexture", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTexture_(IntPtr pDevice, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out IntPtr cubeTextureRef);		
        
        /// <summary>	
        /// Creates an empty volume texture, adjusting the calling parameters as needed.	
        /// </summary>	
        /// <remarks>	
        ///  Internally, D3DXCreateVolumeTexture uses <see cref="SlimDX2.Direct3D9.D3DX9.D3DXCheckVolumeTextureRequirements"/> to adjust the calling parameters. Therefore, calls to D3DXCreateVolumeTexture will often succeed where calls to {{CreateVolumeTexture}} would fail. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the volume texture. </param>
        /// <param name="width"> Width in pixels. This value must be nonzero. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="height"> Height in pixels. This value must be nonzero. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="depth"> Depth in pixels. This value must be nonzero. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0 or D3DUSAGE_DYNAMIC. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the volume texture. The returned volume texture might have a different format from that specified by Format. Applications should check the format of the returned volume texture. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the volume texture should be placed. </param>
        /// <param name="volumeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the created volume texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, E_OUTOFMEMORY . </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTexture([None] LPDIRECT3DDEVICE9 pDevice,[None] int Width,[None] int Height,[None] int Depth,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateVolumeTexture(SlimDX2.Direct3D9.Device pDevice, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out SlimDX2.Direct3D9.VolumeTexture volumeTextureRef) {
            unsafe {
                IntPtr volumeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTexture_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  width,  height,  depth,  mipLevels,  usage,  format,  pool, out volumeTextureRef_);
                volumeTextureRef = (volumeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(volumeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTexture([None] LPDIRECT3DDEVICE9 pDevice,[None] int Width,[None] int Height,[None] int Depth,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTexture", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTexture_(IntPtr pDevice, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, out IntPtr volumeTextureRef);		
        
        /// <summary>	
        /// Creates a texture from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromFileW. Otherwise, the function call resolves to D3DXCreateTextureFromFileA because ANSI strings are being used. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. The function is equivalent to D3DXCreateTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture). Mipmapped textures automatically have each level filled with the loaded texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, the images need to be loaded manually. Note that a resource created with this function will be placed in the memory class denoted by D3DPOOL_MANAGED. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. For the best performance when using D3DXCreateTextureFromFile:  Doing image scaling and format conversion at load time can be slow. Store images in the format and resolution they will be used. If the target hardware requires power of two dimensions, create and store images using power of two dimensions. Consider using DirectDraw surface (DDS) files. Because DDS files can be used to represent any Direct3D 9 texture format, they are very easy for D3DX to read. Also, they can store mipmaps, so any mipmap-generation algorithms can be used to author the images.  	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="textureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateTextureFromFileA(SlimDX2.Direct3D9.Device pDevice, string srcFileRef, out SlimDX2.Direct3D9.Texture textureRef) {
            unsafe {
                IntPtr textureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromFileA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcFileRef, out textureRef_);
                textureRef = (textureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(textureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromFileA_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPStr),In] string srcFileRef, out IntPtr textureRef);		
        
        /// <summary>	
        /// Creates a texture from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromFileW. Otherwise, the function call resolves to D3DXCreateTextureFromFileA because ANSI strings are being used. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. The function is equivalent to D3DXCreateTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture). Mipmapped textures automatically have each level filled with the loaded texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, the images need to be loaded manually. Note that a resource created with this function will be placed in the memory class denoted by D3DPOOL_MANAGED. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. For the best performance when using D3DXCreateTextureFromFile:  Doing image scaling and format conversion at load time can be slow. Store images in the format and resolution they will be used. If the target hardware requires power of two dimensions, create and store images using power of two dimensions. Consider using DirectDraw surface (DDS) files. Because DDS files can be used to represent any Direct3D 9 texture format, they are very easy for D3DX to read. Also, they can store mipmaps, so any mipmap-generation algorithms can be used to author the images.  	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="textureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar_t* pSrcFile,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateTextureFromFileW(SlimDX2.Direct3D9.Device pDevice, string srcFileRef, out SlimDX2.Direct3D9.Texture textureRef) {
            unsafe {
                IntPtr textureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromFileW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcFileRef, out textureRef_);
                textureRef = (textureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(textureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar_t* pSrcFile,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromFileW_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPWStr),In] string srcFileRef, out IntPtr textureRef);		
        
        /// <summary>	
        /// Creates a cube texture from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateCubeTextureFromFileW. Otherwise, the function call resolves to D3DXCreateCubeTextureFromFileA because ANSI strings are being used. The function is equivalent to D3DXCreateCubeTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppCubeTexture). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. D3DXCreateCubeTextureFromFile uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="cubeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateCubeTextureFromFileA(SlimDX2.Direct3D9.Device pDevice, string srcFileRef, out SlimDX2.Direct3D9.CubeTexture cubeTextureRef) {
            unsafe {
                IntPtr cubeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromFileA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcFileRef, out cubeTextureRef_);
                cubeTextureRef = (cubeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(cubeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromFileA_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPStr),In] string srcFileRef, out IntPtr cubeTextureRef);		
        
        /// <summary>	
        /// Creates a cube texture from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateCubeTextureFromFileW. Otherwise, the function call resolves to D3DXCreateCubeTextureFromFileA because ANSI strings are being used. The function is equivalent to D3DXCreateCubeTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppCubeTexture). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. D3DXCreateCubeTextureFromFile uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="cubeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar_t* pSrcFile,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateCubeTextureFromFileW(SlimDX2.Direct3D9.Device pDevice, string srcFileRef, out SlimDX2.Direct3D9.CubeTexture cubeTextureRef) {
            unsafe {
                IntPtr cubeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromFileW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcFileRef, out cubeTextureRef_);
                cubeTextureRef = (cubeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(cubeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar_t* pSrcFile,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromFileW_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPWStr),In] string srcFileRef, out IntPtr cubeTextureRef);		
        
        /// <summary>	
        /// Creates a volume texture from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateVolumeTextureFromFileW. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromFileA because ANSI strings are being used. The function is equivalent to D3DXCreateVolumeTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppVolumeTexture). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Mipmapped textures automatically have each level filled with the loaded texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, then the images need to be loaded manually. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the volume texture. </param>
        /// <param name="srcFileRef"> Pointer to a string that specifies the file name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="volumeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateVolumeTextureFromFileA(SlimDX2.Direct3D9.Device pDevice, string srcFileRef, out SlimDX2.Direct3D9.VolumeTexture volumeTextureRef) {
            unsafe {
                IntPtr volumeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromFileA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcFileRef, out volumeTextureRef_);
                volumeTextureRef = (volumeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(volumeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromFileA_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPStr),In] string srcFileRef, out IntPtr volumeTextureRef);		
        
        /// <summary>	
        /// Creates a volume texture from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateVolumeTextureFromFileW. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromFileA because ANSI strings are being used. The function is equivalent to D3DXCreateVolumeTextureFromFileEx(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppVolumeTexture). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Mipmapped textures automatically have each level filled with the loaded texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, then the images need to be loaded manually. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the volume texture. </param>
        /// <param name="srcFileRef"> Pointer to a string that specifies the file name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="volumeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar_t* pSrcFile,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateVolumeTextureFromFileW(SlimDX2.Direct3D9.Device pDevice, string srcFileRef, out SlimDX2.Direct3D9.VolumeTexture volumeTextureRef) {
            unsafe {
                IntPtr volumeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromFileW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcFileRef, out volumeTextureRef_);
                volumeTextureRef = (volumeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(volumeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar_t* pSrcFile,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromFileW_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPWStr),In] string srcFileRef, out IntPtr volumeTextureRef);		
        
        /// <summary>	
        /// Creates a texture from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromResourceW. Otherwise, the function call resolves to D3DXCreateTextureFromResourceA because ANSI strings are being used. The function is equivalent to D3DXCreateTextureFromResourceEx(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture). The resource being loaded must be of type RT_BITMAP or RT_RCDATA. Resource type RT_RCDATA is used to load formats other than bitmaps (such as .tga, .jpg, and .dds). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="textureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const char* pSrcResource,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateTextureFromResourceA(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string srcResourceRef, out SlimDX2.Direct3D9.Texture textureRef) {
            unsafe {
                IntPtr textureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromResourceA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  srcResourceRef, out textureRef_);
                textureRef = (textureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(textureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const char* pSrcResource,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromResourceA_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string srcResourceRef, out IntPtr textureRef);		
        
        /// <summary>	
        /// Creates a texture from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromResourceW. Otherwise, the function call resolves to D3DXCreateTextureFromResourceA because ANSI strings are being used. The function is equivalent to D3DXCreateTextureFromResourceEx(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture). The resource being loaded must be of type RT_BITMAP or RT_RCDATA. Resource type RT_RCDATA is used to load formats other than bitmaps (such as .tga, .jpg, and .dds). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="textureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateTextureFromResourceW(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string srcResourceRef, out SlimDX2.Direct3D9.Texture textureRef) {
            unsafe {
                IntPtr textureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromResourceW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  srcResourceRef, out textureRef_);
                textureRef = (textureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(textureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromResourceW_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string srcResourceRef, out IntPtr textureRef);		
        
        /// <summary>	
        /// Creates a cube texture from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting determines the function version. If Unicode is defined, the function call resolves to D3DXCreateCubeTextureFromResourceW. Otherwise, the function call resolves to D3DXCreateCubeTextureFromResourceA because ANSI strings are being used. The function is equivalent to D3DXCreateCubeTextureFromResourceEx(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppCubeTexture). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. D3DXCreateCubeTextureFromResource uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for the module associated with the image the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="cubeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const char* pSrcResource,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateCubeTextureFromResourceA(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string srcResourceRef, out SlimDX2.Direct3D9.CubeTexture cubeTextureRef) {
            unsafe {
                IntPtr cubeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromResourceA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  srcResourceRef, out cubeTextureRef_);
                cubeTextureRef = (cubeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(cubeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const char* pSrcResource,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromResourceA_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string srcResourceRef, out IntPtr cubeTextureRef);		
        
        /// <summary>	
        /// Creates a cube texture from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting determines the function version. If Unicode is defined, the function call resolves to D3DXCreateCubeTextureFromResourceW. Otherwise, the function call resolves to D3DXCreateCubeTextureFromResourceA because ANSI strings are being used. The function is equivalent to D3DXCreateCubeTextureFromResourceEx(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppCubeTexture). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. D3DXCreateCubeTextureFromResource uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for the module associated with the image the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="cubeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateCubeTextureFromResourceW(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string srcResourceRef, out SlimDX2.Direct3D9.CubeTexture cubeTextureRef) {
            unsafe {
                IntPtr cubeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromResourceW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  srcResourceRef, out cubeTextureRef_);
                cubeTextureRef = (cubeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(cubeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromResourceW_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string srcResourceRef, out IntPtr cubeTextureRef);		
        
        /// <summary>	
        /// Creates a volume texture from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateVolumeTextureFromResourceW. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromResourceA because ANSI strings are being used. The function is equivalent to D3DXCreateVolumeTextureFromResourceEx(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppVolumeTexture). The resource being loaded must be an application-defined resource (RT_RCDATA). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the volume texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for the module associated with the image the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="volumeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const char* pSrcResource,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateVolumeTextureFromResourceA(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string srcResourceRef, out SlimDX2.Direct3D9.VolumeTexture volumeTextureRef) {
            unsafe {
                IntPtr volumeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromResourceA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  srcResourceRef, out volumeTextureRef_);
                volumeTextureRef = (volumeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(volumeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const char* pSrcResource,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromResourceA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromResourceA_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string srcResourceRef, out IntPtr volumeTextureRef);		
        
        /// <summary>	
        /// Creates a volume texture from a resource.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateVolumeTextureFromResourceW. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromResourceA because ANSI strings are being used. The function is equivalent to D3DXCreateVolumeTextureFromResourceEx(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppVolumeTexture). The resource being loaded must be an application-defined resource (RT_RCDATA). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the volume texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for the module associated with the image the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="volumeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateVolumeTextureFromResourceW(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string srcResourceRef, out SlimDX2.Direct3D9.VolumeTexture volumeTextureRef) {
            unsafe {
                IntPtr volumeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromResourceW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  srcResourceRef, out volumeTextureRef_);
                volumeTextureRef = (volumeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(volumeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromResourceW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromResourceW_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string srcResourceRef, out IntPtr volumeTextureRef);		
        
        /// <summary>	
        /// Creates a texture from a file. This is a more advanced function than {{D3DXCreateTextureFromFile}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromFileExW. Otherwise, the function call resolves to D3DXCreateTextureFromFileExA because ANSI strings are being used. Use <see cref="SlimDX2.Direct3D9.D3DX9.D3DXCheckTextureRequirements"/> to determine if your device can support the texture given the current state. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Mipmapped textures automatically have each level filled with the loaded texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, then the images need to be loaded manually. For the best performance when using D3DXCreateTextureFromFileEx:  Doing image scaling and format conversion at load time can be slow. Store images in the format and resolution they will be used. If the target hardware requires power of 2 dimensions, then create and store images using power of 2 dimensions. For mipmap image creation at load time, filter using {{D3DX_FILTER_BOX}}. A box filter is much faster than other filter types such as D3DX_FILTER_TRIANGLE. Consider using DDS files. Since DDS files can be used to represent any Direct3D 9 texture format, they are very easy for D3DX to read. Also, they can store mipmaps, so any mipmap-generation algorithms can be used to author the images.  When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file and rounded up to a power of two. If the device supports non-power of 2 textures and {{D3DX_DEFAULT_NONPOW2}} is specified, the size will not be rounded. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file and rounded up to a power of two. If the device supports non-power of 2 textures and {{D3DX_DEFAULT_NONPOW2}} is sepcified, the size will not be rounded. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. If D3DX_FROM_FILE, the size will be taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="usage"> 0, <see cref="SlimDX2.Direct3D9.Usage.RenderTarget"/>, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET    or D3DUSAGE_DYNAMIC is specified, Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. See {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If D3DFMT_UNKNOWN, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} constants controlling how the image is filtered. Specifying {{D3DX_DEFAULT}} for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} constants controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the color key. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled in with a description of the data in the source image file, or NULL. </param>
        /// <param name="aletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="textureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileExA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] int Width,[None] int Height,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateTextureFromFileExA(SlimDX2.Direct3D9.Device pDevice, string srcFileRef, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out SlimDX2.Direct3D9.Texture textureRef) {
            unsafe {
                IntPtr textureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromFileExA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcFileRef,  width,  height,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  srcInfoRef, ref  aletteRef, out textureRef_);
                textureRef = (textureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(textureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileExA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] int Width,[None] int Height,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromFileExA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromFileExA_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPStr),In] string srcFileRef, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out IntPtr textureRef);		
        
        /// <summary>	
        /// Creates a texture from a file. This is a more advanced function than {{D3DXCreateTextureFromFile}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromFileExW. Otherwise, the function call resolves to D3DXCreateTextureFromFileExA because ANSI strings are being used. Use <see cref="SlimDX2.Direct3D9.D3DX9.D3DXCheckTextureRequirements"/> to determine if your device can support the texture given the current state. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Mipmapped textures automatically have each level filled with the loaded texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, then the images need to be loaded manually. For the best performance when using D3DXCreateTextureFromFileEx:  Doing image scaling and format conversion at load time can be slow. Store images in the format and resolution they will be used. If the target hardware requires power of 2 dimensions, then create and store images using power of 2 dimensions. For mipmap image creation at load time, filter using {{D3DX_FILTER_BOX}}. A box filter is much faster than other filter types such as D3DX_FILTER_TRIANGLE. Consider using DDS files. Since DDS files can be used to represent any Direct3D 9 texture format, they are very easy for D3DX to read. Also, they can store mipmaps, so any mipmap-generation algorithms can be used to author the images.  When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file and rounded up to a power of two. If the device supports non-power of 2 textures and {{D3DX_DEFAULT_NONPOW2}} is specified, the size will not be rounded. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file and rounded up to a power of two. If the device supports non-power of 2 textures and {{D3DX_DEFAULT_NONPOW2}} is sepcified, the size will not be rounded. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. If D3DX_FROM_FILE, the size will be taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="usage"> 0, <see cref="SlimDX2.Direct3D9.Usage.RenderTarget"/>, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET    or D3DUSAGE_DYNAMIC is specified, Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. See {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If D3DFMT_UNKNOWN, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} constants controlling how the image is filtered. Specifying {{D3DX_DEFAULT}} for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} constants controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the color key. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled in with a description of the data in the source image file, or NULL. </param>
        /// <param name="aletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="textureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileExW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar_t* pSrcFile,[None] int Width,[None] int Height,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateTextureFromFileExW(SlimDX2.Direct3D9.Device pDevice, string srcFileRef, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out SlimDX2.Direct3D9.Texture textureRef) {
            unsafe {
                IntPtr textureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromFileExW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcFileRef,  width,  height,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  srcInfoRef, ref  aletteRef, out textureRef_);
                textureRef = (textureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(textureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileExW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar_t* pSrcFile,[None] int Width,[None] int Height,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromFileExW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromFileExW_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPWStr),In] string srcFileRef, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out IntPtr textureRef);		
        
        /// <summary>	
        /// Creates a cube texture from a file. This is a more advanced function than {{D3DXCreateCubeTextureFromFile}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateCubeTextureFromFileExW. Otherwise, the function call resolves to D3DXCreateCubeTextureFromFileExA because ANSI strings are being used. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Cube textures differ from other surfaces in that they are collections of surfaces. To call {{SetRenderTarget}} with a cube texture, you must select an individual face using {{GetCubeMapSurface}} and pass the resulting surface to SetRenderTarget. D3DXCreateCubeTextureFromFileEx uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="size"> Width and height of the cube texture, in pixels. For example, if the cube texture is an 8-pixel by 8-pixel cube, the value for this parameter should be 8. If this value is 0 or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0 or D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If D3DUSAGE_RENDERTARGET is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the cube texture. The returned cube texture might have a different format from that specified by Format. Applications should check the format of the returned cube texture. If <see cref="SlimDX2.Direct3D9.Format.Unknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the cube texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} constants, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} constants controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant, and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <param name="aletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="cubeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileExA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] int Size,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateCubeTextureFromFileExA(SlimDX2.Direct3D9.Device pDevice, string srcFileRef, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out SlimDX2.Direct3D9.CubeTexture cubeTextureRef) {
            unsafe {
                IntPtr cubeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromFileExA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcFileRef,  size,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  srcInfoRef, ref  aletteRef, out cubeTextureRef_);
                cubeTextureRef = (cubeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(cubeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileExA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] int Size,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromFileExA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromFileExA_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPStr),In] string srcFileRef, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out IntPtr cubeTextureRef);		
        
        /// <summary>	
        /// Creates a cube texture from a file. This is a more advanced function than {{D3DXCreateCubeTextureFromFile}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateCubeTextureFromFileExW. Otherwise, the function call resolves to D3DXCreateCubeTextureFromFileExA because ANSI strings are being used. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Cube textures differ from other surfaces in that they are collections of surfaces. To call {{SetRenderTarget}} with a cube texture, you must select an individual face using {{GetCubeMapSurface}} and pass the resulting surface to SetRenderTarget. D3DXCreateCubeTextureFromFileEx uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="size"> Width and height of the cube texture, in pixels. For example, if the cube texture is an 8-pixel by 8-pixel cube, the value for this parameter should be 8. If this value is 0 or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0 or D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If D3DUSAGE_RENDERTARGET is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the cube texture. The returned cube texture might have a different format from that specified by Format. Applications should check the format of the returned cube texture. If <see cref="SlimDX2.Direct3D9.Format.Unknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the cube texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} constants, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} constants controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant, and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <param name="aletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="cubeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileExW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar_t* pSrcFile,[None] int Size,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateCubeTextureFromFileExW(SlimDX2.Direct3D9.Device pDevice, string srcFileRef, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out SlimDX2.Direct3D9.CubeTexture cubeTextureRef) {
            unsafe {
                IntPtr cubeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromFileExW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcFileRef,  size,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  srcInfoRef, ref  aletteRef, out cubeTextureRef_);
                cubeTextureRef = (cubeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(cubeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileExW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar_t* pSrcFile,[None] int Size,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromFileExW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromFileExW_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPWStr),In] string srcFileRef, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out IntPtr cubeTextureRef);		
        
        /// <summary>	
        /// Creates a volume texture from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateVolumeTextureFromFileExW. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromFileExA because ANSI strings are being used. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Mipmapped textures automatically have each level filled with the loaded volume texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, then the images need to be loaded manually. When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="depth"> Depth, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the  pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE_DYNAMIC is specified,  Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.Unknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled in with a description of the data in the source image file, or NULL. </param>
        /// <param name="aletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="volumeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileExA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] int Width,[None] int Height,[None] int Depth,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateVolumeTextureFromFileExA(SlimDX2.Direct3D9.Device pDevice, string srcFileRef, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out SlimDX2.Direct3D9.VolumeTexture volumeTextureRef) {
            unsafe {
                IntPtr volumeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromFileExA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcFileRef,  width,  height,  depth,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  srcInfoRef, ref  aletteRef, out volumeTextureRef_);
                volumeTextureRef = (volumeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(volumeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileExA([None] LPDIRECT3DDEVICE9 pDevice,[None] const char* pSrcFile,[None] int Width,[None] int Height,[None] int Depth,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromFileExA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromFileExA_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPStr),In] string srcFileRef, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out IntPtr volumeTextureRef);		
        
        /// <summary>	
        /// Creates a volume texture from a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateVolumeTextureFromFileExW. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromFileExA because ANSI strings are being used. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Mipmapped textures automatically have each level filled with the loaded volume texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, then the images need to be loaded manually. When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="srcFileRef"> Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="depth"> Depth, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the  pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE_DYNAMIC is specified,  Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.Unknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled in with a description of the data in the source image file, or NULL. </param>
        /// <param name="aletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="volumeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileExW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar_t* pSrcFile,[None] int Width,[None] int Height,[None] int Depth,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateVolumeTextureFromFileExW(SlimDX2.Direct3D9.Device pDevice, string srcFileRef, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out SlimDX2.Direct3D9.VolumeTexture volumeTextureRef) {
            unsafe {
                IntPtr volumeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromFileExW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcFileRef,  width,  height,  depth,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  srcInfoRef, ref  aletteRef, out volumeTextureRef_);
                volumeTextureRef = (volumeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(volumeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileExW([None] LPDIRECT3DDEVICE9 pDevice,[None] const wchar_t* pSrcFile,[None] int Width,[None] int Height,[None] int Depth,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromFileExW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromFileExW_(IntPtr pDevice, [MarshalAs(UnmanagedType.LPWStr),In] string srcFileRef, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out IntPtr volumeTextureRef);		
        
        /// <summary>	
        /// Creates a texture from a resource. This is a more advanced function than {{D3DXCreateTextureFromResource}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromResourceExW. Otherwise, the function call resolves to D3DXCreateTextureFromResourceExA because ANSI strings are being used. The resource being loaded must be of type RT_BITMAP or RT_RCDATA. Resource type RT_RCDATA is used to load formats other than bitmaps (such as .tga, .jpg, and .dds). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE is specified, Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Performance Optimizations (Direct3D 9)}}Using Dynamic Textures. </param>
        /// <param name="format"> A member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.Unknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <param name="aletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in or NULL. </param>
        /// <param name="textureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceExA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const char* pSrcResource,[None] int Width,[None] int Height,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateTextureFromResourceExA(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string srcResourceRef, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out SlimDX2.Direct3D9.Texture textureRef) {
            unsafe {
                IntPtr textureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromResourceExA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  srcResourceRef,  width,  height,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  srcInfoRef, ref  aletteRef, out textureRef_);
                textureRef = (textureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(textureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceExA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const char* pSrcResource,[None] int Width,[None] int Height,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromResourceExA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromResourceExA_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string srcResourceRef, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out IntPtr textureRef);		
        
        /// <summary>	
        /// Creates a texture from a resource. This is a more advanced function than {{D3DXCreateTextureFromResource}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextureFromResourceExW. Otherwise, the function call resolves to D3DXCreateTextureFromResourceExA because ANSI strings are being used. The resource being loaded must be of type RT_BITMAP or RT_RCDATA. Resource type RT_RCDATA is used to load formats other than bitmaps (such as .tga, .jpg, and .dds). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE is specified, Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Performance Optimizations (Direct3D 9)}}Using Dynamic Textures. </param>
        /// <param name="format"> A member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.Unknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <param name="aletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in or NULL. </param>
        /// <param name="textureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceExW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] int Width,[None] int Height,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateTextureFromResourceExW(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string srcResourceRef, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out SlimDX2.Direct3D9.Texture textureRef) {
            unsafe {
                IntPtr textureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromResourceExW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  srcResourceRef,  width,  height,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  srcInfoRef, ref  aletteRef, out textureRef_);
                textureRef = (textureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(textureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceExW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] int Width,[None] int Height,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromResourceExW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromResourceExW_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string srcResourceRef, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out IntPtr textureRef);		
        
        /// <summary>	
        /// Creates a cube texture from a resource specified by a string. This is a more advanced function than {{D3DXCreateCubeTextureFromResource}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting determines the function version. If Unicode is defined, the function call resolves to D3DXCreateCubeTextureFromResourceExW. Otherwise, the function call resolves to D3DXCreateCubeTextureFromResourceExA because ANSI strings are being used. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Cube textures differ from other surfaces in that they are collections of surfaces. To call {{SetRenderTarget}} with a cube texture, you must select an individual face using {{GetCubeMapSurface}} and pass the resulting surface to  SetRenderTarget. D3DXCreateCubeTextureFromResourceEx uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for the module associated with the image the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="size"> Width and height of the cube texture, in pixels. For example, if the cube texture is an 8-pixel by 8-pixel cube, the value for this parameter should be 8. If this value is 0 or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0 or D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the  pNewRenderTarget parameter of the {{SetRenderTarget}} method. If D3DUSAGE_RENDERTARGET is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the cube texture. The returned cube texture might have a different format from that specified by Format. Applications should check the format of the returned cube texture. If <see cref="SlimDX2.Direct3D9.Format.Unknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the cube texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant, and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <param name="aletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in or NULL. </param>
        /// <param name="cubeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceExA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const char* pSrcResource,[None] int Size,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateCubeTextureFromResourceExA(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string srcResourceRef, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out SlimDX2.Direct3D9.CubeTexture cubeTextureRef) {
            unsafe {
                IntPtr cubeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromResourceExA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  srcResourceRef,  size,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  srcInfoRef, ref  aletteRef, out cubeTextureRef_);
                cubeTextureRef = (cubeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(cubeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceExA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const char* pSrcResource,[None] int Size,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromResourceExA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromResourceExA_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string srcResourceRef, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out IntPtr cubeTextureRef);		
        
        /// <summary>	
        /// Creates a cube texture from a resource specified by a string. This is a more advanced function than {{D3DXCreateCubeTextureFromResource}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting determines the function version. If Unicode is defined, the function call resolves to D3DXCreateCubeTextureFromResourceExW. Otherwise, the function call resolves to D3DXCreateCubeTextureFromResourceExA because ANSI strings are being used. This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Cube textures differ from other surfaces in that they are collections of surfaces. To call {{SetRenderTarget}} with a cube texture, you must select an individual face using {{GetCubeMapSurface}} and pass the resulting surface to  SetRenderTarget. D3DXCreateCubeTextureFromResourceEx uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for the module associated with the image the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="size"> Width and height of the cube texture, in pixels. For example, if the cube texture is an 8-pixel by 8-pixel cube, the value for this parameter should be 8. If this value is 0 or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0 or D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the  pNewRenderTarget parameter of the {{SetRenderTarget}} method. If D3DUSAGE_RENDERTARGET is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the cube texture. The returned cube texture might have a different format from that specified by Format. Applications should check the format of the returned cube texture. If <see cref="SlimDX2.Direct3D9.Format.Unknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the cube texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}}, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant, and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <param name="aletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in or NULL. </param>
        /// <param name="cubeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceExW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] int Size,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateCubeTextureFromResourceExW(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string srcResourceRef, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out SlimDX2.Direct3D9.CubeTexture cubeTextureRef) {
            unsafe {
                IntPtr cubeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromResourceExW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  srcResourceRef,  size,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  srcInfoRef, ref  aletteRef, out cubeTextureRef_);
                cubeTextureRef = (cubeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(cubeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceExW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] int Size,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromResourceExW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromResourceExW_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string srcResourceRef, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out IntPtr cubeTextureRef);		
        
        /// <summary>	
        /// Creates a volume texture from a resource specified by a string. This is a more advanced function than {{D3DXCreateVolumeTextureFromResource}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateVolumeTextureFromResourceExW. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromResourceExA because ANSI strings are being used. The resource being loaded must be an application-defined resource (RT_RCDATA). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="depth"> Depth, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE_DYNAMIC is specified, Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.Unknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled in with a description of the data in the source image file, or NULL. </param>
        /// <param name="aletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="volumeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceExA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const char* pSrcResource,[None] int Width,[None] int Height,[None] int Depth,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateVolumeTextureFromResourceExA(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string srcResourceRef, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out SlimDX2.Direct3D9.VolumeTexture volumeTextureRef) {
            unsafe {
                IntPtr volumeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromResourceExA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  srcResourceRef,  width,  height,  depth,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  srcInfoRef, ref  aletteRef, out volumeTextureRef_);
                volumeTextureRef = (volumeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(volumeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceExA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const char* pSrcResource,[None] int Width,[None] int Height,[None] int Depth,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromResourceExA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromResourceExA_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPStr),In] string srcResourceRef, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out IntPtr volumeTextureRef);		
        
        /// <summary>	
        /// Creates a volume texture from a resource specified by a string. This is a more advanced function than {{D3DXCreateVolumeTextureFromResource}}.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateVolumeTextureFromResourceExW. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromResourceExA because ANSI strings are being used. The resource being loaded must be an application-defined resource (RT_RCDATA). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="hSrcModule"> Handle to the module where the resource is located, or NULL for module associated with the image the operating system used to create the current process. </param>
        /// <param name="srcResourceRef"> Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="depth"> Depth, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE_DYNAMIC is specified, Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.Unknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled in with a description of the data in the source image file, or NULL. </param>
        /// <param name="aletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="volumeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceExW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] int Width,[None] int Height,[None] int Depth,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateVolumeTextureFromResourceExW(SlimDX2.Direct3D9.Device pDevice, IntPtr hSrcModule, string srcResourceRef, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out SlimDX2.Direct3D9.VolumeTexture volumeTextureRef) {
            unsafe {
                IntPtr volumeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromResourceExW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hSrcModule,  srcResourceRef,  width,  height,  depth,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  srcInfoRef, ref  aletteRef, out volumeTextureRef_);
                volumeTextureRef = (volumeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(volumeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceExW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hSrcModule,[None] const wchar_t* pSrcResource,[None] int Width,[None] int Height,[None] int Depth,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromResourceExW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromResourceExW_(IntPtr pDevice, IntPtr hSrcModule, [MarshalAs(UnmanagedType.LPWStr),In] string srcResourceRef, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out IntPtr volumeTextureRef);		
        
        /// <summary>	
        /// Creates a texture from a file in memory.	
        /// </summary>	
        /// <remarks>	
        ///  The function is equivalent to D3DXCreateTextureFromFileInMemoryEx(pDevice, pSrcData, SrcDataSize, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture). This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface representing the device to be associated with the texture. </param>
        /// <param name="srcDataRef"> Pointer to the file in memory from which to create the texture. </param>
        /// <param name="srcDataSize"> Size in bytes of the file in memory. </param>
        /// <param name="textureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileInMemory([None] LPDIRECT3DDEVICE9 pDevice,[None] const void* pSrcData,[None] int SrcDataSize,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateTextureFromFileInMemory(SlimDX2.Direct3D9.Device pDevice, IntPtr srcDataRef, int srcDataSize, out SlimDX2.Direct3D9.Texture textureRef) {
            unsafe {
                IntPtr textureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromFileInMemory_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcDataRef,  srcDataSize, out textureRef_);
                textureRef = (textureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(textureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileInMemory([None] LPDIRECT3DDEVICE9 pDevice,[None] const void* pSrcData,[None] int SrcDataSize,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromFileInMemory_(IntPtr pDevice, IntPtr srcDataRef, int srcDataSize, out IntPtr textureRef);		
        
        /// <summary>	
        /// Creates a cube texture from a file in memory.	
        /// </summary>	
        /// <remarks>	
        ///  This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. The function is equivalent to D3DXCreateCubeTextureFromFileInMemoryEx(pDevice, pSrcData, SrcDataSize, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppCubeTexture). Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. This method is designed to be used for loading image files stored as RT_RCDATA, which is an application-defined resource (raw data). Otherwise this method will fail. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. D3DXCreateCubeTextureFromFileInMemory uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="srcDataRef"> Pointer to the file in memory from which to create the cubemap. See Remarks. </param>
        /// <param name="srcDataSize"> Size of the file in memory, in bytes. </param>
        /// <param name="cubeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileInMemory([None] LPDIRECT3DDEVICE9 pDevice,[None] const void* pSrcData,[None] int SrcDataSize,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateCubeTextureFromFileInMemory(SlimDX2.Direct3D9.Device pDevice, IntPtr srcDataRef, int srcDataSize, out SlimDX2.Direct3D9.CubeTexture cubeTextureRef) {
            unsafe {
                IntPtr cubeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromFileInMemory_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcDataRef,  srcDataSize, out cubeTextureRef_);
                cubeTextureRef = (cubeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(cubeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileInMemory([None] LPDIRECT3DDEVICE9 pDevice,[None] const void* pSrcData,[None] int SrcDataSize,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromFileInMemory_(IntPtr pDevice, IntPtr srcDataRef, int srcDataSize, out IntPtr cubeTextureRef);		
        
        /// <summary>	
        /// Creates a volume texture from a file in memory.	
        /// </summary>	
        /// <remarks>	
        ///  This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. The function is equivalent to D3DXCreateVolumeTextureFromFileInMemoryEx(pDevice, pSrcFile, SrcData, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppVolumeTexture). Note that a resource created with this function when called from a IDirect3DDevice9 object will be placed in the memory class denoted by D3DPOOL_MANAGED.  When this method is called from a IDirect3DDevice9Ex object the resource will be placed in the memory class denoted by D3DPOOL_DEFAULT. Filtering is automatically applied to a texture created using this method. The filtering is equivalent to D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER in {{D3DX_FILTER}}. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the volume texture. </param>
        /// <param name="srcDataRef"> Pointer to the file in memory from which to create the volume texture. </param>
        /// <param name="srcDataSize"> Size of the file in memory, in bytes. </param>
        /// <param name="volumeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileInMemory([None] LPDIRECT3DDEVICE9 pDevice,[None] const void* pSrcData,[None] int SrcDataSize,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateVolumeTextureFromFileInMemory(SlimDX2.Direct3D9.Device pDevice, IntPtr srcDataRef, int srcDataSize, out SlimDX2.Direct3D9.VolumeTexture volumeTextureRef) {
            unsafe {
                IntPtr volumeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromFileInMemory_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcDataRef,  srcDataSize, out volumeTextureRef_);
                volumeTextureRef = (volumeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(volumeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileInMemory([None] LPDIRECT3DDEVICE9 pDevice,[None] const void* pSrcData,[None] int SrcDataSize,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromFileInMemory_(IntPtr pDevice, IntPtr srcDataRef, int srcDataSize, out IntPtr volumeTextureRef);		
        
        /// <summary>	
        /// Creates a texture from a file in memory. This is a more advanced function than <see cref="SlimDX2.Direct3D9.D3DX9.D3DXCreateTextureFromFileInMemory"/>.	
        /// </summary>	
        /// <remarks>	
        ///  This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. For details about  <see cref="SlimDX2.Windows.Paletteentry"/>, see the Platform SDK. Note that as of DirectX 8.0, the peFlags member of the PALETTEENTRY structure does not function as documented in the Platform SDK. The peFlags member is now the alpha channel for 8-bit palettized formats. When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="srcDataRef"> Pointer to the file in memory from which to create the texture. </param>
        /// <param name="srcDataSize"> Size of the file in memory, in bytes. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the  pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE_DYNAMIC is specified, Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.Unknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> Combination of one or more flags controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. Each valid filter must contain one of the flags in {{D3DX_FILTER}}.  </param>
        /// <param name="mipFilter"> Combination of one or more flags controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. Each valid filter must contain one of the flags in {{D3DX_FILTER}}. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <param name="aletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. See Remarks. </param>
        /// <param name="textureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileInMemoryEx([None] LPDIRECT3DDEVICE9 pDevice,[None] const void* pSrcData,[None] int SrcDataSize,[None] int Width,[None] int Height,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateTextureFromFileInMemoryEx(SlimDX2.Direct3D9.Device pDevice, IntPtr srcDataRef, int srcDataSize, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out SlimDX2.Direct3D9.Texture textureRef) {
            unsafe {
                IntPtr textureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextureFromFileInMemoryEx_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcDataRef,  srcDataSize,  width,  height,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  srcInfoRef, ref  aletteRef, out textureRef_);
                textureRef = (textureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.Texture(textureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileInMemoryEx([None] LPDIRECT3DDEVICE9 pDevice,[None] const void* pSrcData,[None] int SrcDataSize,[None] int Width,[None] int Height,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DTEXTURE9* ppTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromFileInMemoryEx", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextureFromFileInMemoryEx_(IntPtr pDevice, IntPtr srcDataRef, int srcDataSize, int width, int height, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out IntPtr textureRef);		
        
        /// <summary>	
        /// Creates a cube texture from a file in memory. This is a more advanced function than <see cref="SlimDX2.Direct3D9.D3DX9.D3DXCreateCubeTextureFromFileInMemory"/>.	
        /// </summary>	
        /// <remarks>	
        ///  This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. Cube textures differ from other surfaces in that they are collections of surfaces. To call {{SetRenderTarget}} with a cube texture, you must select an individual face using {{GetCubeMapSurface}} and pass the resulting surface to SetRenderTarget . This method is designed to be used for loading image files stored as RT_RCDATA, which is an application-defined resource (raw data). Otherwise this method will fail. For details on <see cref="SlimDX2.Windows.Paletteentry"/>, see the Platform SDK.  Note that as of DirectX 8.0, the peFlags member of the PALETTEENTRY structure does not function as documented in the Platform SDK. The peFlags  member is now the alpha channel for 8-bit palettized formats. D3DXCreateCubeTextureFromFileInMemoryEx uses the DirectDraw surface (DDS) file format. The {{DirectX Texture Editor (Dxtex.exe)}} enables you to generate a cube map from other file formats and save it in the DDS file format When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the cube texture. </param>
        /// <param name="srcDataRef"> Pointer to the file in memory from which to create the cube texture. See Remarks. </param>
        /// <param name="srcDataSize"> Size of the file in memory, in bytes. </param>
        /// <param name="size"> Width (or height) in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the {{SetRenderTarget}} method. If D3DUSAGE_RENDERTARGET is specified, the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the cube texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.Unknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the cube texture should be placed. </param>
        /// <param name="filter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> A combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant, and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled with a description of the data in the source image file, or NULL. </param>
        /// <param name="aletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. See Remarks. </param>
        /// <param name="cubeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the created cube texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileInMemoryEx([None] LPDIRECT3DDEVICE9 pDevice,[None] const void* pSrcData,[None] int SrcDataSize,[None] int Size,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateCubeTextureFromFileInMemoryEx(SlimDX2.Direct3D9.Device pDevice, IntPtr srcDataRef, int srcDataSize, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out SlimDX2.Direct3D9.CubeTexture cubeTextureRef) {
            unsafe {
                IntPtr cubeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCubeTextureFromFileInMemoryEx_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcDataRef,  srcDataSize,  size,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  srcInfoRef, ref  aletteRef, out cubeTextureRef_);
                cubeTextureRef = (cubeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.CubeTexture(cubeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileInMemoryEx([None] LPDIRECT3DDEVICE9 pDevice,[None] const void* pSrcData,[None] int SrcDataSize,[None] int Size,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DCUBETEXTURE9* ppCubeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromFileInMemoryEx", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCubeTextureFromFileInMemoryEx_(IntPtr pDevice, IntPtr srcDataRef, int srcDataSize, int size, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out IntPtr cubeTextureRef);		
        
        /// <summary>	
        /// Creates a volume texture from a file. This is a more advanced function than <see cref="SlimDX2.Direct3D9.D3DX9.D3DXCreateVolumeTextureFromFileInMemory"/>.	
        /// </summary>	
        /// <remarks>	
        ///  This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <see cref="SlimDX2.Direct3D9.ImageFileFormat"/>. When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter. 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device to be associated with the texture. </param>
        /// <param name="srcDataRef"> Pointer to the file in memory from which to create the volume texture. </param>
        /// <param name="srcDataSize"> Size of the file in memory, in bytes. </param>
        /// <param name="width"> Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="height"> Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="depth"> Depth, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <see cref="SlimDX2.Direct3D9.Capabilities"/>. </param>
        /// <param name="mipLevels"> Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created. </param>
        /// <param name="usage"> 0, D3DUSAGE_RENDERTARGET, or D3DUSAGE_DYNAMIC. Setting this flag to D3DUSAGE_RENDERTARGET indicates that the surface is to be used as a render target. The resource can then be passed to the  pNewRenderTarget parameter of the {{SetRenderTarget}} method. If either D3DUSAGE_RENDERTARGET or D3DUSAGE_DYNAMIC is specified,  Pool must be set to D3DPOOL_DEFAULT, and the application should check that the device supports this operation by calling {{CheckDeviceFormat}}. D3DUSAGE_DYNAMIC indicates that the surface should be handled dynamically. For more information about using dynamic textures, see {{Using Dynamic Textures}}. </param>
        /// <param name="format"> Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by Format. Applications should check the format of the returned texture. If <see cref="SlimDX2.Direct3D9.Format.Unknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities. </param>
        /// <param name="pool"> Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, describing the memory class into which the texture should be placed. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER. </param>
        /// <param name="mipFilter"> Combination of one or more {{D3DX_FILTER}} controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels. </param>
        /// <param name="colorKey">  <see cref="SlimMath.Color4"/> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000. </param>
        /// <param name="srcInfoRef"> Pointer to a <see cref="SlimDX2.Direct3D9.ImageInformation"/> structure to be filled in with a description of the data in the source image file, or NULL. </param>
        /// <param name="aletteRef"> Pointer to a  <see cref="SlimDX2.Windows.Paletteentry"/> structure, representing a 256-color palette to fill in, or NULL. </param>
        /// <param name="volumeTextureRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the created texture object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_OUTOFVIDEOMEMORY, D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileInMemoryEx([None] LPDIRECT3DDEVICE9 pDevice,[None] const void* pSrcData,[None] int SrcDataSize,[None] int Width,[None] int Height,[None] int Depth,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		public static SlimDX2.Result D3DXCreateVolumeTextureFromFileInMemoryEx(SlimDX2.Direct3D9.Device pDevice, IntPtr srcDataRef, int srcDataSize, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out SlimDX2.Direct3D9.VolumeTexture volumeTextureRef) {
            unsafe {
                IntPtr volumeTextureRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateVolumeTextureFromFileInMemoryEx_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  srcDataRef,  srcDataSize,  width,  height,  depth,  mipLevels,  usage,  format,  pool,  filter,  mipFilter,  colorKey, ref  srcInfoRef, ref  aletteRef, out volumeTextureRef_);
                volumeTextureRef = (volumeTextureRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.VolumeTexture(volumeTextureRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileInMemoryEx([None] LPDIRECT3DDEVICE9 pDevice,[None] const void* pSrcData,[None] int SrcDataSize,[None] int Width,[None] int Height,[None] int Depth,[None] int MipLevels,[None] int Usage,[None] D3DFORMAT Format,[None] D3DPOOL Pool,[None] int Filter,[None] int MipFilter,[None] D3DCOLOR ColorKey,[None] D3DXIMAGE_INFO* pSrcInfo,[None] PALETTEENTRY* pPalette,[None] LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromFileInMemoryEx", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateVolumeTextureFromFileInMemoryEx_(IntPtr pDevice, IntPtr srcDataRef, int srcDataSize, int width, int height, int depth, int mipLevels, int usage, SlimDX2.Direct3D9.Format format, SlimDX2.Direct3D9.Pool pool, int filter, int mipFilter, SlimMath.Color4 colorKey, ref SlimDX2.Direct3D9.ImageInformation srcInfoRef, ref SlimDX2.Windows.Paletteentry aletteRef, out IntPtr volumeTextureRef);		
        
        /// <summary>	
        /// Saves a texture to a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXSaveTextureToFileW. Otherwise, the function call resolves to D3DXSaveTextureToFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats. If the volume is nondynamic (because of a usage parameter set to 0 at the creation) and located in video memory (the memory pool set to D3DPOOL_DEFAULT), D3DXSaveTextureToFile will fail because D3DX cannot lock nondynamic volumes located in video memory. 	
        /// </remarks>	
        /// <param name="destFileRef"> Pointer to a string that specifies the file name of the destination image. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileFormat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcTexture"> Pointer to <see cref="SlimDX2.Direct3D9.BaseTexture"/> interface, containing the texture to be saved. </param>
        /// <param name="srcPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXSaveTextureToFileA([None] const char* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DBASETEXTURE9 pSrcTexture,[None] const PALETTEENTRY* pSrcPalette)</unmanaged>
		public static SlimDX2.Result D3DXSaveTextureToFileA(string destFileRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, SlimDX2.Direct3D9.BaseTexture pSrcTexture, ref SlimDX2.Windows.Paletteentry srcPaletteRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveTextureToFileA_( destFileRef,  destFormat, (pSrcTexture == null)?IntPtr.Zero:pSrcTexture.NativePointer, ref  srcPaletteRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveTextureToFileA([None] const char* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DBASETEXTURE9 pSrcTexture,[None] const PALETTEENTRY* pSrcPalette)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveTextureToFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveTextureToFileA_([MarshalAs(UnmanagedType.LPStr),In] string destFileRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, IntPtr pSrcTexture, ref SlimDX2.Windows.Paletteentry srcPaletteRef);		
        
        /// <summary>	
        /// Saves a texture to a file.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to D3DXSaveTextureToFileW. Otherwise, the function call resolves to D3DXSaveTextureToFileA because ANSI strings are being used. This function handles conversion to and from compressed texture formats. If the volume is nondynamic (because of a usage parameter set to 0 at the creation) and located in video memory (the memory pool set to D3DPOOL_DEFAULT), D3DXSaveTextureToFile will fail because D3DX cannot lock nondynamic volumes located in video memory. 	
        /// </remarks>	
        /// <param name="destFileRef"> Pointer to a string that specifies the file name of the destination image. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileFormat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcTexture"> Pointer to <see cref="SlimDX2.Direct3D9.BaseTexture"/> interface, containing the texture to be saved. </param>
        /// <param name="srcPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL </returns>
        /// <unmanaged>HRESULT D3DXSaveTextureToFileW([None] const wchar_t* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DBASETEXTURE9 pSrcTexture,[None] const PALETTEENTRY* pSrcPalette)</unmanaged>
		public static SlimDX2.Result D3DXSaveTextureToFileW(string destFileRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, SlimDX2.Direct3D9.BaseTexture pSrcTexture, ref SlimDX2.Windows.Paletteentry srcPaletteRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveTextureToFileW_( destFileRef,  destFormat, (pSrcTexture == null)?IntPtr.Zero:pSrcTexture.NativePointer, ref  srcPaletteRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveTextureToFileW([None] const wchar_t* pDestFile,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DBASETEXTURE9 pSrcTexture,[None] const PALETTEENTRY* pSrcPalette)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveTextureToFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveTextureToFileW_([MarshalAs(UnmanagedType.LPWStr),In] string destFileRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, IntPtr pSrcTexture, ref SlimDX2.Windows.Paletteentry srcPaletteRef);		
        
        /// <summary>	
        /// Saves a texture to an image file.	
        /// </summary>	
        /// <remarks>	
        ///  This function handles conversion to and from compressed texture formats. 	
        /// </remarks>	
        /// <param name="destBufRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> that will store the image. </param>
        /// <param name="destFormat">  <see cref="SlimDX2.Direct3D9.ImageFileFormat"/> specifying the file format to use when saving. This function supports saving to all D3DXIMAGE_FILEFORMAT formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga). </param>
        /// <param name="pSrcTexture"> Pointer to <see cref="SlimDX2.Direct3D9.BaseTexture"/> interface containing the image to be saved. </param>
        /// <param name="srcPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure containing a palette of 256 colors. This parameter can be NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXSaveTextureToFileInMemory([None] LPD3DXBUFFER* ppDestBuf,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DBASETEXTURE9 pSrcTexture,[None] const PALETTEENTRY* pSrcPalette)</unmanaged>
		public static SlimDX2.Result D3DXSaveTextureToFileInMemory(out SlimDX2.Direct3D9.ShaderBytecode destBufRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, SlimDX2.Direct3D9.BaseTexture pSrcTexture, ref SlimDX2.Windows.Paletteentry srcPaletteRef) {
            unsafe {
                IntPtr destBufRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveTextureToFileInMemory_(out destBufRef_,  destFormat, (pSrcTexture == null)?IntPtr.Zero:pSrcTexture.NativePointer, ref  srcPaletteRef);
                destBufRef = (destBufRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(destBufRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveTextureToFileInMemory([None] LPD3DXBUFFER* ppDestBuf,[None] D3DXIMAGE_FILEFORMAT DestFormat,[None] LPDIRECT3DBASETEXTURE9 pSrcTexture,[None] const PALETTEENTRY* pSrcPalette)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveTextureToFileInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveTextureToFileInMemory_(out IntPtr destBufRef, SlimDX2.Direct3D9.ImageFileFormat destFormat, IntPtr pSrcTexture, ref SlimDX2.Windows.Paletteentry srcPaletteRef);		
        
        /// <summary>	
        /// Filters mipmap levels of a texture.	
        /// </summary>	
        /// <remarks>	
        ///  A filter is recursively applied to each texture level to generate the next texture level. Writing to a non-level-zero surface of the texture will not cause the dirty rectangle to be updated. If D3DXFilterTexture is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call {{AddDirtyRect}} on the texture. Textures created in the default pool (D3DPOOL_DEFAULT) cannot be used with D3DXFilterTexture (unless created with D3DUSAGE_DYNAMIC) because a lock operation is needed on the object. Note that locks are prohibited on textures in the default pool (unless they are dynamic). For details on <see cref="SlimDX2.Windows.Paletteentry"/>, see the Platform SDK. Note that as of DirectX 8.0, the peFlags member of the PALETTEENTRY structure does not function as documented in the Platform SDK. The peFlags member is now the alpha channel for 8-bit palettized formats. There is only one texture filtering function, but two macros that call this method. 	
        /// <code> #define D3DXFilterCubeTexture D3DXFilterTexture	
        /// #define D3DXFilterVolumeTexture D3DXFilterTexture </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="pBaseTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.BaseTexture"/> interface that represents the texture object to filter. </param>
        /// <param name="aletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> structure that represents a 256-color palette to fill in, or NULL for nonpalettized formats. If a palette is not specified, the default Direct3D palette (an all opaque white palette) is provided. See Remarks. </param>
        /// <param name="srcLevel"> Level whose image is used to generate the subsequent levels. Specifying D3DX_DEFAULT for this parameter is equivalent to specifying 0. </param>
        /// <param name="filter"> Combination of one or more {{D3DX_FILTER}} controlling how the mipmap is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying D3DX_FILTER_BOX if the texture size is a power of two, and D3DX_FILTER_BOX | D3DX_FILTER_DITHER otherwise. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA. </returns>
        /// <unmanaged>HRESULT D3DXFilterTexture([None] LPDIRECT3DBASETEXTURE9 pBaseTexture,[None] const PALETTEENTRY* pPalette,[None] int SrcLevel,[None] int Filter)</unmanaged>
		public static SlimDX2.Result D3DXFilterTexture(SlimDX2.Direct3D9.BaseTexture pBaseTexture, ref SlimDX2.Windows.Paletteentry aletteRef, int srcLevel, int filter) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFilterTexture_((pBaseTexture == null)?IntPtr.Zero:pBaseTexture.NativePointer, ref  aletteRef,  srcLevel,  filter);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFilterTexture([None] LPDIRECT3DBASETEXTURE9 pBaseTexture,[None] const PALETTEENTRY* pPalette,[None] int SrcLevel,[None] int Filter)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFilterTexture", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFilterTexture_(IntPtr pBaseTexture, ref SlimDX2.Windows.Paletteentry aletteRef, int srcLevel, int filter);		
        
        /// <summary>	
        /// Uses a user-provided function to fill each texel of each mip level of a given texture.	
        /// </summary>	
        /// <remarks>	
        ///  Here is an example that creates a function called ColorFill, which relies on D3DXFillTexture. 	
        /// <code> // Define a function that matches the prototype of LPD3DXFILL3D	
        /// VOID WINAPI ColorFill (D3DXVECTOR4* pOut, const D3DXVECTOR2* pTexCoord, 	
        /// const D3DXVECTOR2* pTexelSize, LPVOID pData)	
        /// { *pOut = D3DXVECTOR4(pTexCoord-&gt;x, pTexCoord-&gt;y, 0.0f, 0.0f);	
        /// } // Fill the texture using D3DXFillTexture	
        /// if (FAILED (hr = D3DXFillTexture (m_pTexture, ColorFill, NULL)))	
        /// { return hr;	
        /// } </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="pTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the filled texture. </param>
        /// <param name="pFunction"> Pointer to a user-provided evaluator function, which will be used to compute the value of each texel. The function follows the prototype of {{LPD3DXFILL2D}}. </param>
        /// <param name="dataRef"> Pointer to an arbitrary block of user-defined data. This pointer will be passed to the function provided in pFunction. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXFillTexture([None] LPDIRECT3DTEXTURE9 pTexture,[None] LPD3DXFILL2D pFunction,[None] void* pData)</unmanaged>
		public static SlimDX2.Result D3DXFillTexture(SlimDX2.Direct3D9.Texture pTexture, SlimDX2.FunctionCallback pFunction, IntPtr dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFillTexture_((pTexture == null)?IntPtr.Zero:pTexture.NativePointer,  pFunction,  dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFillTexture([None] LPDIRECT3DTEXTURE9 pTexture,[None] LPD3DXFILL2D pFunction,[None] void* pData)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillTexture", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFillTexture_(IntPtr pTexture, SlimDX2.FunctionCallback pFunction, IntPtr dataRef);		
        
        /// <summary>	
        /// Uses a user-provided function to fill each texel of each mip level of a given cube texture.	
        /// </summary>	
        /// <remarks>	
        ///  Here is an example that creates a function called ColorCubeFill, which relies on D3DXFillCubeTexture. 	
        /// <code> // Define a function that matches the prototype of LPD3DXFILL3D	
        /// VOID WINAPI ColorCubeFill (D3DXVECTOR4* pOut, const D3DXVECTOR3* pTexCoord, 	
        /// const D3DXVECTOR3* pTexelSize, LPVOID pData)	
        /// { *pOut = D3DXVECTOR4(pTexCoord-&gt;x, pTexCoord-&gt;y, pTexCoord-&gt;z, 0.0f);	
        /// } // Fill the texture using D3DXFillCubeTexture	
        /// if (FAILED (hr = D3DXFillCubeTexture (m_pTexture, ColorCubeFill, NULL)))	
        /// { return hr;	
        /// } </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="pCubeTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> interface, representing the filled texture. </param>
        /// <param name="pFunction"> Pointer to a user-provided evaluator function, which will be used to compute the value of each texel. The function follows the prototype of {{LPD3DXFILL3D}}. </param>
        /// <param name="dataRef"> Pointer to an arbitrary block of user-defined data. This pointer will be passed to the function provided in pFunction. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXFillCubeTexture([None] LPDIRECT3DCUBETEXTURE9 pCubeTexture,[None] LPD3DXFILL3D pFunction,[None] void* pData)</unmanaged>
		public static SlimDX2.Result D3DXFillCubeTexture(SlimDX2.Direct3D9.CubeTexture pCubeTexture, SlimDX2.FunctionCallback pFunction, IntPtr dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFillCubeTexture_((pCubeTexture == null)?IntPtr.Zero:pCubeTexture.NativePointer,  pFunction,  dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFillCubeTexture([None] LPDIRECT3DCUBETEXTURE9 pCubeTexture,[None] LPD3DXFILL3D pFunction,[None] void* pData)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillCubeTexture", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFillCubeTexture_(IntPtr pCubeTexture, SlimDX2.FunctionCallback pFunction, IntPtr dataRef);		
        
        /// <summary>	
        /// Uses a user-provided function to fill each texel of each mip level of a given volume texture.	
        /// </summary>	
        /// <remarks>	
        ///  If the volume is non-dynamic (because usage is set to 0 when it is  created), and located in video memory (the memory pool set to D3DPOOL_DEFAULT), D3DXFillVolumeTexture will fail because the volume cannot be locked. This example creates a function called ColorVolumeFill, which relies on D3DXFillVolumeTexture. 	
        /// <code> // Define a function that matches the prototype of LPD3DXFILL3D	
        /// VOID WINAPI ColorVolumeFill (D3DXVECTOR4* pOut, const D3DXVECTOR3* pTexCoord, 	
        /// const D3DXVECTOR3* pTexelSize, LPVOID pData)	
        /// { *pOut = D3DXVECTOR4(pTexCoord-&gt;x, pTexCoord-&gt;y, pTexCoord-&gt;z, 0.0f);	
        /// } // Fill volume texture	
        /// if (FAILED (hr = D3DXFillVolumeTexture (m_pTexture, ColorVolumeFill, NULL)))	
        /// { return hr;	
        /// } </code>	
        /// 	
        ///  	
        /// </remarks>	
        /// <param name="pVolumeTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> interface, representing the filled texture. </param>
        /// <param name="pFunction"> Pointer to a user-provided evaluator function, which will be used to compute the value of each texel. The function follows the prototype of {{LPD3DXFILL3D}}. </param>
        /// <param name="dataRef"> Pointer to an arbitrary block of user-defined data. This pointer will be passed to the function provided in pFunction. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXFillVolumeTexture([None] LPDIRECT3DVOLUMETEXTURE9 pVolumeTexture,[None] LPD3DXFILL3D pFunction,[None] void* pData)</unmanaged>
		public static SlimDX2.Result D3DXFillVolumeTexture(SlimDX2.Direct3D9.VolumeTexture pVolumeTexture, SlimDX2.FunctionCallback pFunction, IntPtr dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFillVolumeTexture_((pVolumeTexture == null)?IntPtr.Zero:pVolumeTexture.NativePointer,  pFunction,  dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFillVolumeTexture([None] LPDIRECT3DVOLUMETEXTURE9 pVolumeTexture,[None] LPD3DXFILL3D pFunction,[None] void* pData)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillVolumeTexture", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFillVolumeTexture_(IntPtr pVolumeTexture, SlimDX2.FunctionCallback pFunction, IntPtr dataRef);		
        
        /// <summary>	
        /// Uses a compiled high-level shader language (HLSL) function to fill each texel of each mipmap level of a texture.	
        /// </summary>	
        /// <remarks>	
        ///  The texture target must be an HLSL function that takes contains the following semantics:  One input parameter must use a POSITION semantic. One input parameter must use a PSIZE semantic. The function must return a parameter that uses the COLOR semantic.  The following is an example of such an HLSL function: 	
        /// <code> float4 TextureGradientFill( float2 vTexCoord : POSITION,  float2 vTexelSize : PSIZE) : COLOR  { float r,g, b, xSq,ySq, a; xSq = 2.f*vTexCoord.x-1.f; xSq *= xSq; ySq = 2.f*vTexCoord.y-1.f; ySq *= ySq; a = sqrt(xSq+ySq); if (a &gt; 1.0f) { a = 1.0f-(a-1.0f); } else if (a &lt; 0.2f) { a = 0.2f; } r = 1-vTexCoord.x; g = 1-vTexCoord.y; b = vTexCoord.x; return float4(r, g, b, a); }; </code>	
        /// 	
        ///  Note that the input parameters can be in any order, but both input semantics must be represented. 	
        /// </remarks>	
        /// <param name="pTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> object, representing the texture to be filled. </param>
        /// <param name="pTextureShader"> Pointer to a <see cref="SlimDX2.Direct3D9.ID3DXTextureShader"/> texture shader object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXFillTextureTX([None] LPDIRECT3DTEXTURE9 pTexture,[None] LPD3DXTEXTURESHADER pTextureShader)</unmanaged>
		public static SlimDX2.Result D3DXFillTextureTX(SlimDX2.Direct3D9.Texture pTexture, SlimDX2.Direct3D9.ID3DXTextureShader pTextureShader) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFillTextureTX_((pTexture == null)?IntPtr.Zero:pTexture.NativePointer, (pTextureShader == null)?IntPtr.Zero:pTextureShader.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFillTextureTX([None] LPDIRECT3DTEXTURE9 pTexture,[None] LPD3DXTEXTURESHADER pTextureShader)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillTextureTX", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFillTextureTX_(IntPtr pTexture, IntPtr pTextureShader);		
        
        /// <summary>	
        /// Uses a compiled high-level shader language (HLSL) function to fill each texel of each mipmap level of a texture.	
        /// </summary>	
        /// <remarks>	
        ///  The texture target must be an HLSL function that takes contains the following semantics:  One input parameter must use a POSITION semantic. One input parameter must use a PSIZE semantic. The function must return a parameter that uses the COLOR semantic.  The input parameters can be in any order. For an example, see <see cref="SlimDX2.Direct3D9.D3DX9.D3DXFillTextureTX"/>  	
        /// </remarks>	
        /// <param name="pCubeTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.CubeTexture"/> object, representing the texture to be filled. </param>
        /// <param name="pTextureShader"> Pointer to a <see cref="SlimDX2.Direct3D9.ID3DXTextureShader"/> texture shader object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXFillCubeTextureTX([None] LPDIRECT3DCUBETEXTURE9 pCubeTexture,[None] LPD3DXTEXTURESHADER pTextureShader)</unmanaged>
		public static SlimDX2.Result D3DXFillCubeTextureTX(SlimDX2.Direct3D9.CubeTexture pCubeTexture, SlimDX2.Direct3D9.ID3DXTextureShader pTextureShader) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFillCubeTextureTX_((pCubeTexture == null)?IntPtr.Zero:pCubeTexture.NativePointer, (pTextureShader == null)?IntPtr.Zero:pTextureShader.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFillCubeTextureTX([None] LPDIRECT3DCUBETEXTURE9 pCubeTexture,[None] LPD3DXTEXTURESHADER pTextureShader)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillCubeTextureTX", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFillCubeTextureTX_(IntPtr pCubeTexture, IntPtr pTextureShader);		
        
        /// <summary>	
        /// Uses a compiled high-level shader language (HLSL) function to fill each texel of each mipmap level of a texture.	
        /// </summary>	
        /// <remarks>	
        ///  The texture target must be an HLSL function that takes contains the following semantics:  One input parameter must use a POSITION semantic. One input parameter must use a PSIZE semantic. The function must return a parameter that uses the COLOR semantic.  The input parameters can be in any order. For an example, see <see cref="SlimDX2.Direct3D9.D3DX9.D3DXFillTextureTX"/>  	
        /// </remarks>	
        /// <param name="pVolumeTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.VolumeTexture"/> object, representing the texture to be filled. </param>
        /// <param name="pTextureShader"> Pointer to a <see cref="SlimDX2.Direct3D9.ID3DXTextureShader"/> texture shader object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following:D3DERR_NOTAVAILABLE, D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXFillVolumeTextureTX([None] LPDIRECT3DVOLUMETEXTURE9 pVolumeTexture,[None] LPD3DXTEXTURESHADER pTextureShader)</unmanaged>
		public static SlimDX2.Result D3DXFillVolumeTextureTX(SlimDX2.Direct3D9.VolumeTexture pVolumeTexture, SlimDX2.Direct3D9.ID3DXTextureShader pTextureShader) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFillVolumeTextureTX_((pVolumeTexture == null)?IntPtr.Zero:pVolumeTexture.NativePointer, (pTextureShader == null)?IntPtr.Zero:pTextureShader.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFillVolumeTextureTX([None] LPDIRECT3DVOLUMETEXTURE9 pVolumeTexture,[None] LPD3DXTEXTURESHADER pTextureShader)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillVolumeTextureTX", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFillVolumeTextureTX_(IntPtr pVolumeTexture, IntPtr pTextureShader);		
        
        /// <summary>	
        /// Converts a height map into a normal map. The (x,y,z) components of each normal are mapped to the (r,g,b) channels of the output texture.	
        /// </summary>	
        /// <remarks>	
        ///  This method computes the normal by using the central difference with a kernel size of 3x3. The central differencing denominator used is 2.0. RGB channels in the destination contain biased (x,y,z) components of the normal. 	
        /// </remarks>	
        /// <param name="pTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the destination texture. </param>
        /// <param name="pSrcTexture"> Pointer to an <see cref="SlimDX2.Direct3D9.Texture"/> interface, representing the source height-map texture. </param>
        /// <param name="srcPaletteRef"> Pointer to a <see cref="SlimDX2.Windows.Paletteentry"/> type that contains the source palette of 256 colors or NULL. </param>
        /// <param name="flags"> One or more {{D3DX_NORMALMAP}} flags that control generation of normal maps. </param>
        /// <param name="channel"> One {{D3DX_CHANNEL}} flag specifying the source of height information. </param>
        /// <param name="amplitude"> Constant value multiplier that increases (or decreases) the values in the normal map. Higher values usually make bumps more visible, lower values usually make bumps less visible. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be the following value: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXComputeNormalMap([None] LPDIRECT3DTEXTURE9 pTexture,[None] LPDIRECT3DTEXTURE9 pSrcTexture,[None] const PALETTEENTRY* pSrcPalette,[None] int Flags,[None] int Channel,[None] float Amplitude)</unmanaged>
		public static SlimDX2.Result D3DXComputeNormalMap(SlimDX2.Direct3D9.Texture pTexture, SlimDX2.Direct3D9.Texture pSrcTexture, ref SlimDX2.Windows.Paletteentry srcPaletteRef, int flags, int channel, float amplitude) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXComputeNormalMap_((pTexture == null)?IntPtr.Zero:pTexture.NativePointer, (pSrcTexture == null)?IntPtr.Zero:pSrcTexture.NativePointer, ref  srcPaletteRef,  flags,  channel,  amplitude);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXComputeNormalMap([None] LPDIRECT3DTEXTURE9 pTexture,[None] LPDIRECT3DTEXTURE9 pSrcTexture,[None] const PALETTEENTRY* pSrcPalette,[None] int Flags,[None] int Channel,[None] float Amplitude)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeNormalMap", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXComputeNormalMap_(IntPtr pTexture, IntPtr pSrcTexture, ref SlimDX2.Windows.Paletteentry srcPaletteRef, int flags, int channel, float amplitude);		
        
        /// <summary>	
        /// Uses a left-handed coordinate system to create a mesh containing an 	
        /// n-sided polygon.	
        /// </summary>	
        /// <remarks>	
        ///  The created polygon is centered at the origin. This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} flexible vertex format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the created polygon mesh. </param>
        /// <param name="length"> Length of each side. </param>
        /// <param name="sides"> Number of sides for the polygon. Value must be greater than or equal to 3. </param>
        /// <param name="meshRef"> Address of a pointer to the output shape, an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface. </param>
        /// <param name="adjacencyRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface. When the method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreatePolygon([None] LPDIRECT3DDEVICE9 pDevice,[None] float Length,[None] int Sides,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		public static SlimDX2.Result D3DXCreatePolygon(SlimDX2.Direct3D9.Device pDevice, float length, int sides, out SlimDX2.Direct3D9.ID3DXMesh meshRef, out SlimDX2.Direct3D9.ShaderBytecode adjacencyRef) {
            unsafe {
                IntPtr meshRef_ = IntPtr.Zero;
                IntPtr adjacencyRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreatePolygon_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  length,  sides, out meshRef_, out adjacencyRef_);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshRef_);
                adjacencyRef = (adjacencyRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(adjacencyRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreatePolygon([None] LPDIRECT3DDEVICE9 pDevice,[None] float Length,[None] int Sides,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreatePolygon", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreatePolygon_(IntPtr pDevice, float length, int sides, out IntPtr meshRef, out IntPtr adjacencyRef);		
        
        /// <summary>	
        /// Uses a left-handed coordinate system to create a mesh containing an axis-aligned box.	
        /// </summary>	
        /// <remarks>	
        ///  The created box is centered at the origin. This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} flexible vertex format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the created box mesh. </param>
        /// <param name="width"> Width of the box, along the x-axis. </param>
        /// <param name="height"> Height of the box, along the y-axis. </param>
        /// <param name="depth"> Depth of the box, along the z-axis. </param>
        /// <param name="meshRef"> Address of a pointer to the output shape, an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface. </param>
        /// <param name="adjacencyRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateBox([None] LPDIRECT3DDEVICE9 pDevice,[None] float Width,[None] float Height,[None] float Depth,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		public static SlimDX2.Result D3DXCreateBox(SlimDX2.Direct3D9.Device pDevice, float width, float height, float depth, out SlimDX2.Direct3D9.ID3DXMesh meshRef, out SlimDX2.Direct3D9.ShaderBytecode adjacencyRef) {
            unsafe {
                IntPtr meshRef_ = IntPtr.Zero;
                IntPtr adjacencyRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateBox_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  width,  height,  depth, out meshRef_, out adjacencyRef_);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshRef_);
                adjacencyRef = (adjacencyRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(adjacencyRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateBox([None] LPDIRECT3DDEVICE9 pDevice,[None] float Width,[None] float Height,[None] float Depth,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateBox", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateBox_(IntPtr pDevice, float width, float height, float depth, out IntPtr meshRef, out IntPtr adjacencyRef);		
        
        /// <summary>	
        /// Uses a left-handed coordinate system to create a mesh containing a cylinder.	
        /// </summary>	
        /// <remarks>	
        ///  The created cylinder is centered at the origin, and its axis is aligned with the z-axis. This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} flexible vertex format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the created cylinder mesh. </param>
        /// <param name="radius1"> Radius at the negative Z end. Value should be greater than or equal to 0.0f. </param>
        /// <param name="radius2"> Radius at the positive Z end. Value should be greater than or equal to 0.0f. </param>
        /// <param name="length"> Length of the cylinder along the z-axis. </param>
        /// <param name="slices"> Number of slices about the main axis. </param>
        /// <param name="stacks"> Number of stacks along the main axis. </param>
        /// <param name="meshRef"> Address of a pointer to the output shape, an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface. </param>
        /// <param name="adjacencyRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface. When the method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCylinder([None] LPDIRECT3DDEVICE9 pDevice,[None] float Radius1,[None] float Radius2,[None] float Length,[None] int Slices,[None] int Stacks,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		public static SlimDX2.Result D3DXCreateCylinder(SlimDX2.Direct3D9.Device pDevice, float radius1, float radius2, float length, int slices, int stacks, out SlimDX2.Direct3D9.ID3DXMesh meshRef, out SlimDX2.Direct3D9.ShaderBytecode adjacencyRef) {
            unsafe {
                IntPtr meshRef_ = IntPtr.Zero;
                IntPtr adjacencyRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCylinder_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  radius1,  radius2,  length,  slices,  stacks, out meshRef_, out adjacencyRef_);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshRef_);
                adjacencyRef = (adjacencyRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(adjacencyRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCylinder([None] LPDIRECT3DDEVICE9 pDevice,[None] float Radius1,[None] float Radius2,[None] float Length,[None] int Slices,[None] int Stacks,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCylinder", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCylinder_(IntPtr pDevice, float radius1, float radius2, float length, int slices, int stacks, out IntPtr meshRef, out IntPtr adjacencyRef);		
        
        /// <summary>	
        /// Uses a left-handed coordinate system to create a mesh containing a sphere.	
        /// </summary>	
        /// <remarks>	
        ///  The created sphere is centered at the origin, and its axis is aligned with the z-axis. This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} flexible vertex format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the created sphere mesh. </param>
        /// <param name="radius"> Radius of the sphere. This value should be greater than or equal to 0.0f. </param>
        /// <param name="slices"> Number of slices about the main axis. </param>
        /// <param name="stacks"> Number of stacks along the main axis. </param>
        /// <param name="meshRef"> Address of a pointer to the output shape, an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface. </param>
        /// <param name="adjacencyRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface. When the method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateSphere([None] LPDIRECT3DDEVICE9 pDevice,[None] float Radius,[None] int Slices,[None] int Stacks,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		public static SlimDX2.Result D3DXCreateSphere(SlimDX2.Direct3D9.Device pDevice, float radius, int slices, int stacks, out SlimDX2.Direct3D9.ID3DXMesh meshRef, out SlimDX2.Direct3D9.ShaderBytecode adjacencyRef) {
            unsafe {
                IntPtr meshRef_ = IntPtr.Zero;
                IntPtr adjacencyRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateSphere_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  radius,  slices,  stacks, out meshRef_, out adjacencyRef_);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshRef_);
                adjacencyRef = (adjacencyRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(adjacencyRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateSphere([None] LPDIRECT3DDEVICE9 pDevice,[None] float Radius,[None] int Slices,[None] int Stacks,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSphere", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateSphere_(IntPtr pDevice, float radius, int slices, int stacks, out IntPtr meshRef, out IntPtr adjacencyRef);		
        
        /// <summary>	
        /// Uses a left-handed coordinate system to create a mesh containing a torus.	
        /// </summary>	
        /// <remarks>	
        ///  The created torus is centered at the origin, and its axis is aligned with the z-axis. The inner radius of the torus is the radius of the cross-section (the minor radius), and the outer radius of the torus is the radius of the central hole.  This function returns a mesh that can be used later for drawing or manipulation by the application. This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} flexible vertex format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the created torus mesh. </param>
        /// <param name="innerRadius"> Inner-radius of the torus. Value should be greater than or equal to 0.0f. </param>
        /// <param name="outerRadius"> Outer-radius of the torus. Value should be greater than or equal to 0.0f. </param>
        /// <param name="sides"> Number of sides in a cross-section. Value must be greater than or equal to 3. </param>
        /// <param name="rings"> Number of rings making up the torus. Value must be greater than or equal to 3. </param>
        /// <param name="meshRef"> Address of a pointer to the output shape, an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface. </param>
        /// <param name="adjacencyRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface. When the method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTorus([None] LPDIRECT3DDEVICE9 pDevice,[None] float InnerRadius,[None] float OuterRadius,[None] int Sides,[None] int Rings,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		public static SlimDX2.Result D3DXCreateTorus(SlimDX2.Direct3D9.Device pDevice, float innerRadius, float outerRadius, int sides, int rings, out SlimDX2.Direct3D9.ID3DXMesh meshRef, out SlimDX2.Direct3D9.ShaderBytecode adjacencyRef) {
            unsafe {
                IntPtr meshRef_ = IntPtr.Zero;
                IntPtr adjacencyRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTorus_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  innerRadius,  outerRadius,  sides,  rings, out meshRef_, out adjacencyRef_);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshRef_);
                adjacencyRef = (adjacencyRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(adjacencyRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTorus([None] LPDIRECT3DDEVICE9 pDevice,[None] float InnerRadius,[None] float OuterRadius,[None] int Sides,[None] int Rings,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTorus", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTorus_(IntPtr pDevice, float innerRadius, float outerRadius, int sides, int rings, out IntPtr meshRef, out IntPtr adjacencyRef);		
        
        /// <summary>	
        /// Uses a left-handed coordinate system to create a mesh containing a teapot.	
        /// </summary>	
        /// <remarks>	
        ///  This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} flexible vertex format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, representing the device associated with the created teapot mesh. </param>
        /// <param name="meshRef"> Address of a pointer to the output shape, an <see cref="SlimDX2.Direct3D9.ID3DXMesh"/> interface. </param>
        /// <param name="adjacencyRef"> Address of a pointer to an <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> interface. When the method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh. NULL can be specified. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTeapot([None] LPDIRECT3DDEVICE9 pDevice,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		public static SlimDX2.Result D3DXCreateTeapot(SlimDX2.Direct3D9.Device pDevice, out SlimDX2.Direct3D9.ID3DXMesh meshRef, out SlimDX2.Direct3D9.ShaderBytecode adjacencyRef) {
            unsafe {
                IntPtr meshRef_ = IntPtr.Zero;
                IntPtr adjacencyRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTeapot_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer, out meshRef_, out adjacencyRef_);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshRef_);
                adjacencyRef = (adjacencyRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(adjacencyRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTeapot([None] LPDIRECT3DDEVICE9 pDevice,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTeapot", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTeapot_(IntPtr pDevice, out IntPtr meshRef, out IntPtr adjacencyRef);		
        
        /// <summary>	
        /// Creates a mesh containing the specified text, using the font associated with the device context.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextW. Otherwise, the function call resolves to D3DXCreateTextA because ANSI strings are being used. This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} flexible vertex format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device that created the mesh. </param>
        /// <param name="hDC"> Device context, containing the font for output. The font selected by the device context must be a TrueType font. </param>
        /// <param name="textRef"> Pointer to a string that specifies the text to generate. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="deviation"> Maximum chordal deviation from TrueType font outlines. </param>
        /// <param name="extrusion"> Amount to extrude text in the negative z-direction. </param>
        /// <param name="meshRef"> Pointer to the returned mesh. </param>
        /// <param name="adjacencyRef"> Pointer to a buffer containing adjacency information. May be NULL. </param>
        /// <param name="pGlyphMetrics"> Pointer to an array of {{GLYPHMETRICSFLOAT}} structures that contain the glyph metric data. Each element contains information about the position and orientation of the corresponding glyph in the string. The number of elements in the array should be equal to the number of characters in the string. Note that the origin in each structure is not relative to the entire string, but rather is relative to that character cell. To compute the entire bounding box, add the increment for each glyph while traversing the string. If you are not concerned with the glyph sizes, set this parameter to NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hDC,[None] const char* pText,[None] float Deviation,[None] float Extrusion,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency,[None] LPGLYPHMETRICSFLOAT pGlyphMetrics)</unmanaged>
		public static SlimDX2.Result D3DXCreateTextA(SlimDX2.Direct3D9.Device pDevice, IntPtr hDC, string textRef, float deviation, float extrusion, out SlimDX2.Direct3D9.ID3DXMesh meshRef, out SlimDX2.Direct3D9.ShaderBytecode adjacencyRef, IntPtr pGlyphMetrics) {
            unsafe {
                IntPtr meshRef_ = IntPtr.Zero;
                IntPtr adjacencyRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextA_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hDC,  textRef,  deviation,  extrusion, out meshRef_, out adjacencyRef_,  pGlyphMetrics);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshRef_);
                adjacencyRef = (adjacencyRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(adjacencyRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextA([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hDC,[None] const char* pText,[None] float Deviation,[None] float Extrusion,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency,[None] LPGLYPHMETRICSFLOAT pGlyphMetrics)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextA_(IntPtr pDevice, IntPtr hDC, [MarshalAs(UnmanagedType.LPStr),In] string textRef, float deviation, float extrusion, out IntPtr meshRef, out IntPtr adjacencyRef, IntPtr pGlyphMetrics);		
        
        /// <summary>	
        /// Creates a mesh containing the specified text, using the font associated with the device context.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXCreateTextW. Otherwise, the function call resolves to D3DXCreateTextA because ANSI strings are being used. This function creates a mesh with the D3DXMESH_MANAGED creation option and {{D3DFVF_XYZ | D3DFVF_NORMAL}} flexible vertex format (FVF). 	
        /// </remarks>	
        /// <param name="pDevice"> Pointer to the device that created the mesh. </param>
        /// <param name="hDC"> Device context, containing the font for output. The font selected by the device context must be a TrueType font. </param>
        /// <param name="textRef"> Pointer to a string that specifies the text to generate. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="deviation"> Maximum chordal deviation from TrueType font outlines. </param>
        /// <param name="extrusion"> Amount to extrude text in the negative z-direction. </param>
        /// <param name="meshRef"> Pointer to the returned mesh. </param>
        /// <param name="adjacencyRef"> Pointer to a buffer containing adjacency information. May be NULL. </param>
        /// <param name="pGlyphMetrics"> Pointer to an array of {{GLYPHMETRICSFLOAT}} structures that contain the glyph metric data. Each element contains information about the position and orientation of the corresponding glyph in the string. The number of elements in the array should be equal to the number of characters in the string. Note that the origin in each structure is not relative to the entire string, but rather is relative to that character cell. To compute the entire bounding box, add the increment for each glyph while traversing the string. If you are not concerned with the glyph sizes, set this parameter to NULL. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateTextW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hDC,[None] const wchar_t* pText,[None] float Deviation,[None] float Extrusion,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency,[None] LPGLYPHMETRICSFLOAT pGlyphMetrics)</unmanaged>
		public static SlimDX2.Result D3DXCreateTextW(SlimDX2.Direct3D9.Device pDevice, IntPtr hDC, string textRef, float deviation, float extrusion, out SlimDX2.Direct3D9.ID3DXMesh meshRef, out SlimDX2.Direct3D9.ShaderBytecode adjacencyRef, IntPtr pGlyphMetrics) {
            unsafe {
                IntPtr meshRef_ = IntPtr.Zero;
                IntPtr adjacencyRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateTextW_((pDevice == null)?IntPtr.Zero:pDevice.NativePointer,  hDC,  textRef,  deviation,  extrusion, out meshRef_, out adjacencyRef_,  pGlyphMetrics);
                meshRef = (meshRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXMesh(meshRef_);
                adjacencyRef = (adjacencyRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ShaderBytecode(adjacencyRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateTextW([None] LPDIRECT3DDEVICE9 pDevice,[None] void* hDC,[None] const wchar_t* pText,[None] float Deviation,[None] float Extrusion,[None] LPD3DXMESH* ppMesh,[None] LPD3DXBUFFER* ppAdjacency,[None] LPGLYPHMETRICSFLOAT pGlyphMetrics)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateTextW_(IntPtr pDevice, IntPtr hDC, [MarshalAs(UnmanagedType.LPWStr),In] string textRef, float deviation, float extrusion, out IntPtr meshRef, out IntPtr adjacencyRef, IntPtr pGlyphMetrics);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="filename">No documentation.</param>
        /// <param name="meshOptions">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="pAlloc">No documentation.</param>
        /// <param name="pUserDataLoader">No documentation.</param>
        /// <param name="frameHierarchyRef">No documentation.</param>
        /// <param name="animControllerRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXLoadMeshHierarchyFromXA([None] const char* Filename,[None] int MeshOptions,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXALLOCATEHIERARCHY pAlloc,[None] LPD3DXLOADUSERDATA pUserDataLoader,[None] LPD3DXFRAME* ppFrameHierarchy,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
		public static SlimDX2.Result D3DXLoadMeshHierarchyFromXA(string filename, int meshOptions, SlimDX2.Direct3D9.Device pD3DDevice, SlimDX2.Direct3D9.IAllocateHierarchy pAlloc, SlimDX2.Direct3D9.ILoadUserData pUserDataLoader, ref SlimDX2.Direct3D9.Frame frameHierarchyRef, out SlimDX2.Direct3D9.ID3DXAnimationController animControllerRef) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native frameHierarchyRef_ = new SlimDX2.Direct3D9.Frame.__Native();
                frameHierarchyRef.__MarshalTo(ref frameHierarchyRef_);
                IntPtr animControllerRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadMeshHierarchyFromXA_( filename,  meshOptions, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, (pAlloc == null)?IntPtr.Zero:pAlloc.NativePointer, (pUserDataLoader == null)?IntPtr.Zero:pUserDataLoader.NativePointer, ref  frameHierarchyRef_, out animControllerRef_);
                animControllerRef = (animControllerRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXAnimationController(animControllerRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadMeshHierarchyFromXA([None] const char* Filename,[None] int MeshOptions,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXALLOCATEHIERARCHY pAlloc,[None] LPD3DXLOADUSERDATA pUserDataLoader,[None] LPD3DXFRAME* ppFrameHierarchy,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshHierarchyFromXA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadMeshHierarchyFromXA_([MarshalAs(UnmanagedType.LPStr),In] string filename, int meshOptions, IntPtr pD3DDevice, IntPtr pAlloc, IntPtr pUserDataLoader, ref SlimDX2.Direct3D9.Frame.__Native frameHierarchyRef, out IntPtr animControllerRef);		
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="filename">No documentation.</param>
        /// <param name="meshOptions">No documentation.</param>
        /// <param name="pD3DDevice">No documentation.</param>
        /// <param name="pAlloc">No documentation.</param>
        /// <param name="pUserDataLoader">No documentation.</param>
        /// <param name="frameHierarchyRef">No documentation.</param>
        /// <param name="animControllerRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT D3DXLoadMeshHierarchyFromXW([None] const wchar_t* Filename,[None] int MeshOptions,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXALLOCATEHIERARCHY pAlloc,[None] LPD3DXLOADUSERDATA pUserDataLoader,[None] LPD3DXFRAME* ppFrameHierarchy,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
		public static SlimDX2.Result D3DXLoadMeshHierarchyFromXW(string filename, int meshOptions, SlimDX2.Direct3D9.Device pD3DDevice, SlimDX2.Direct3D9.IAllocateHierarchy pAlloc, SlimDX2.Direct3D9.ILoadUserData pUserDataLoader, ref SlimDX2.Direct3D9.Frame frameHierarchyRef, out SlimDX2.Direct3D9.ID3DXAnimationController animControllerRef) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native frameHierarchyRef_ = new SlimDX2.Direct3D9.Frame.__Native();
                frameHierarchyRef.__MarshalTo(ref frameHierarchyRef_);
                IntPtr animControllerRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadMeshHierarchyFromXW_( filename,  meshOptions, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, (pAlloc == null)?IntPtr.Zero:pAlloc.NativePointer, (pUserDataLoader == null)?IntPtr.Zero:pUserDataLoader.NativePointer, ref  frameHierarchyRef_, out animControllerRef_);
                animControllerRef = (animControllerRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXAnimationController(animControllerRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadMeshHierarchyFromXW([None] const wchar_t* Filename,[None] int MeshOptions,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXALLOCATEHIERARCHY pAlloc,[None] LPD3DXLOADUSERDATA pUserDataLoader,[None] LPD3DXFRAME* ppFrameHierarchy,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshHierarchyFromXW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadMeshHierarchyFromXW_([MarshalAs(UnmanagedType.LPWStr),In] string filename, int meshOptions, IntPtr pD3DDevice, IntPtr pAlloc, IntPtr pUserDataLoader, ref SlimDX2.Direct3D9.Frame.__Native frameHierarchyRef, out IntPtr animControllerRef);		
        
        /// <summary>	
        /// Loads the first frame hierarchy from a .x file.	
        /// </summary>	
        /// <remarks>	
        ///  All the meshes in the file will be collapsed into one output mesh. If the file contains a frame hierarchy, all the transformations will be applied to the mesh. 	
        /// </remarks>	
        /// <param name="memory"> Pointer to a buffer that contains the mesh hierarchy. </param>
        /// <param name="sizeOfMemory"> Size of the pMemory buffer, in bytes. </param>
        /// <param name="meshOptions"> Combination of one or more flags from the {{D3DXMESH}} enumeration that specify creation options for the mesh. </param>
        /// <param name="pD3DDevice"> Pointer to an <see cref="SlimDX2.Direct3D9.Device"/> interface, the device object associated with the mesh. </param>
        /// <param name="pAlloc"> Pointer to an <see cref="SlimDX2.Direct3D9.IAllocateHierarchy"/> interface. </param>
        /// <param name="pUserDataLoader"> Application provided interface that allows loading of user data. See <see cref="SlimDX2.Direct3D9.ILoadUserData"/>. </param>
        /// <param name="frameHierarchyRef"> Returns a pointer to the loaded frame hierarchy. See <see cref="SlimDX2.Direct3D9.Frame"/>. </param>
        /// <param name="animControllerRef"> Returns a pointer to the animation controller corresponding to animation in the .x file. This is created with default tracks and events. See <see cref="SlimDX2.Direct3D9.ID3DXAnimationController"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXLoadMeshHierarchyFromXInMemory([None] const void* Memory,[None] int SizeOfMemory,[None] int MeshOptions,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXALLOCATEHIERARCHY pAlloc,[None] LPD3DXLOADUSERDATA pUserDataLoader,[None] LPD3DXFRAME* ppFrameHierarchy,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
		public static SlimDX2.Result D3DXLoadMeshHierarchyFromXInMemory(IntPtr memory, int sizeOfMemory, int meshOptions, SlimDX2.Direct3D9.Device pD3DDevice, SlimDX2.Direct3D9.IAllocateHierarchy pAlloc, SlimDX2.Direct3D9.ILoadUserData pUserDataLoader, ref SlimDX2.Direct3D9.Frame frameHierarchyRef, out SlimDX2.Direct3D9.ID3DXAnimationController animControllerRef) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native frameHierarchyRef_ = new SlimDX2.Direct3D9.Frame.__Native();
                frameHierarchyRef.__MarshalTo(ref frameHierarchyRef_);
                IntPtr animControllerRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXLoadMeshHierarchyFromXInMemory_( memory,  sizeOfMemory,  meshOptions, (pD3DDevice == null)?IntPtr.Zero:pD3DDevice.NativePointer, (pAlloc == null)?IntPtr.Zero:pAlloc.NativePointer, (pUserDataLoader == null)?IntPtr.Zero:pUserDataLoader.NativePointer, ref  frameHierarchyRef_, out animControllerRef_);
                animControllerRef = (animControllerRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXAnimationController(animControllerRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXLoadMeshHierarchyFromXInMemory([None] const void* Memory,[None] int SizeOfMemory,[None] int MeshOptions,[None] LPDIRECT3DDEVICE9 pD3DDevice,[None] LPD3DXALLOCATEHIERARCHY pAlloc,[None] LPD3DXLOADUSERDATA pUserDataLoader,[None] LPD3DXFRAME* ppFrameHierarchy,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshHierarchyFromXInMemory", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXLoadMeshHierarchyFromXInMemory_(IntPtr memory, int sizeOfMemory, int meshOptions, IntPtr pD3DDevice, IntPtr pAlloc, IntPtr pUserDataLoader, ref SlimDX2.Direct3D9.Frame.__Native frameHierarchyRef, out IntPtr animControllerRef);		
        
        /// <summary>	
        /// Creates a .x file and saves the mesh hierarchy and corresponding animations in it.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXSaveMeshHierarchyToFileW. Otherwise, the function call resolves to D3DXSaveMeshHierarchyToFileA. This function does not save compressed animation sets. 	
        /// </remarks>	
        /// <param name="filename"> Pointer to a string that specifies the name of the .x file identifying the saved mesh. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="xFormat"> Format of the .x file (text or binary, compressed or not). See D3DXF_FILEFORMAT. D3DXF_FILEFORMAT_COMPRESSED can be combined (using a logical OR) with either the D3DXF_FILEFORMAT_BINARY or D3DXF_FILEFORMAT_TEXT flags to reduce the output file size. </param>
        /// <param name="frameRootRef"> Root node of the hierarchy to be saved. See <see cref="SlimDX2.Direct3D9.Frame"/>. </param>
        /// <param name="pAnimcontroller"> Animation controller that has animation sets to be stored. See <see cref="SlimDX2.Direct3D9.ID3DXAnimationController"/>. </param>
        /// <param name="pUserDataSaver"> Application-provided interface that allows saving of user data. See <see cref="SlimDX2.Direct3D9.ISaveUserData"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXSaveMeshHierarchyToFileA([None] const char* Filename,[None] int XFormat,[None] const D3DXFRAME* pFrameRoot,[None] LPD3DXANIMATIONCONTROLLER pAnimcontroller,[None] LPD3DXSAVEUSERDATA pUserDataSaver)</unmanaged>
		public static SlimDX2.Result D3DXSaveMeshHierarchyToFileA(string filename, int xFormat, ref SlimDX2.Direct3D9.Frame frameRootRef, SlimDX2.Direct3D9.ID3DXAnimationController pAnimcontroller, SlimDX2.Direct3D9.ISaveUserData pUserDataSaver) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native frameRootRef_ = new SlimDX2.Direct3D9.Frame.__Native();
                frameRootRef.__MarshalTo(ref frameRootRef_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveMeshHierarchyToFileA_( filename,  xFormat, ref  frameRootRef_, (pAnimcontroller == null)?IntPtr.Zero:pAnimcontroller.NativePointer, (pUserDataSaver == null)?IntPtr.Zero:pUserDataSaver.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveMeshHierarchyToFileA([None] const char* Filename,[None] int XFormat,[None] const D3DXFRAME* pFrameRoot,[None] LPD3DXANIMATIONCONTROLLER pAnimcontroller,[None] LPD3DXSAVEUSERDATA pUserDataSaver)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveMeshHierarchyToFileA", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveMeshHierarchyToFileA_([MarshalAs(UnmanagedType.LPStr),In] string filename, int xFormat, ref SlimDX2.Direct3D9.Frame.__Native frameRootRef, IntPtr pAnimcontroller, IntPtr pUserDataSaver);		
        
        /// <summary>	
        /// Creates a .x file and saves the mesh hierarchy and corresponding animations in it.	
        /// </summary>	
        /// <remarks>	
        ///  The compiler setting also determines the function version. If Unicode is defined, the function call resolves to D3DXSaveMeshHierarchyToFileW. Otherwise, the function call resolves to D3DXSaveMeshHierarchyToFileA. This function does not save compressed animation sets. 	
        /// </remarks>	
        /// <param name="filename"> Pointer to a string that specifies the name of the .x file identifying the saved mesh. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </param>
        /// <param name="xFormat"> Format of the .x file (text or binary, compressed or not). See D3DXF_FILEFORMAT. D3DXF_FILEFORMAT_COMPRESSED can be combined (using a logical OR) with either the D3DXF_FILEFORMAT_BINARY or D3DXF_FILEFORMAT_TEXT flags to reduce the output file size. </param>
        /// <param name="frameRootRef"> Root node of the hierarchy to be saved. See <see cref="SlimDX2.Direct3D9.Frame"/>. </param>
        /// <param name="pAnimController"> Animation controller that has animation sets to be stored. See <see cref="SlimDX2.Direct3D9.ID3DXAnimationController"/>. </param>
        /// <param name="pUserDataSaver"> Application-provided interface that allows saving of user data. See <see cref="SlimDX2.Direct3D9.ISaveUserData"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be: D3DERR_INVALIDCALL. </returns>
        /// <unmanaged>HRESULT D3DXSaveMeshHierarchyToFileW([None] const wchar_t* Filename,[None] int XFormat,[None] const D3DXFRAME* pFrameRoot,[None] LPD3DXANIMATIONCONTROLLER pAnimController,[None] LPD3DXSAVEUSERDATA pUserDataSaver)</unmanaged>
		public static SlimDX2.Result D3DXSaveMeshHierarchyToFileW(string filename, int xFormat, ref SlimDX2.Direct3D9.Frame frameRootRef, SlimDX2.Direct3D9.ID3DXAnimationController pAnimController, SlimDX2.Direct3D9.ISaveUserData pUserDataSaver) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native frameRootRef_ = new SlimDX2.Direct3D9.Frame.__Native();
                frameRootRef.__MarshalTo(ref frameRootRef_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXSaveMeshHierarchyToFileW_( filename,  xFormat, ref  frameRootRef_, (pAnimController == null)?IntPtr.Zero:pAnimController.NativePointer, (pUserDataSaver == null)?IntPtr.Zero:pUserDataSaver.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXSaveMeshHierarchyToFileW([None] const wchar_t* Filename,[None] int XFormat,[None] const D3DXFRAME* pFrameRoot,[None] LPD3DXANIMATIONCONTROLLER pAnimController,[None] LPD3DXSAVEUSERDATA pUserDataSaver)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveMeshHierarchyToFileW", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXSaveMeshHierarchyToFileW_([MarshalAs(UnmanagedType.LPWStr),In] string filename, int xFormat, ref SlimDX2.Direct3D9.Frame.__Native frameRootRef, IntPtr pAnimController, IntPtr pUserDataSaver);		
        
        /// <summary>	
        /// Destroys the subtree of frames under the root, including the root.	
        /// </summary>	
        /// <param name="pFrameRoot"> Pointer to the root node. </param>
        /// <param name="pAlloc"> Allocation interface used to deallocate nodes of the frame hierarchy. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXFrameDestroy([None] LPD3DXFRAME pFrameRoot,[None] LPD3DXALLOCATEHIERARCHY pAlloc)</unmanaged>
		public static SlimDX2.Result D3DXFrameDestroy(ref SlimDX2.Direct3D9.Frame pFrameRoot, SlimDX2.Direct3D9.IAllocateHierarchy pAlloc) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pFrameRoot_ = new SlimDX2.Direct3D9.Frame.__Native();
                pFrameRoot.__MarshalTo(ref pFrameRoot_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFrameDestroy_(ref  pFrameRoot_, (pAlloc == null)?IntPtr.Zero:pAlloc.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFrameDestroy([None] LPD3DXFRAME pFrameRoot,[None] LPD3DXALLOCATEHIERARCHY pAlloc)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFrameDestroy", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFrameDestroy_(ref SlimDX2.Direct3D9.Frame.__Native pFrameRoot, IntPtr pAlloc);		
        
        /// <summary>	
        /// Adds a child frame to a frame.	
        /// </summary>	
        /// <param name="pFrameParent"> Pointer to the parent node. </param>
        /// <param name="frameChildRef"> Pointer to the child node. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXFrameAppendChild([None] LPD3DXFRAME pFrameParent,[None] const D3DXFRAME* pFrameChild)</unmanaged>
		public static SlimDX2.Result D3DXFrameAppendChild(ref SlimDX2.Direct3D9.Frame pFrameParent, ref SlimDX2.Direct3D9.Frame frameChildRef) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pFrameParent_ = new SlimDX2.Direct3D9.Frame.__Native();
                pFrameParent.__MarshalTo(ref pFrameParent_);
                SlimDX2.Direct3D9.Frame.__Native frameChildRef_ = new SlimDX2.Direct3D9.Frame.__Native();
                frameChildRef.__MarshalTo(ref frameChildRef_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFrameAppendChild_(ref  pFrameParent_, ref  frameChildRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFrameAppendChild([None] LPD3DXFRAME pFrameParent,[None] const D3DXFRAME* pFrameChild)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFrameAppendChild", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFrameAppendChild_(ref SlimDX2.Direct3D9.Frame.__Native pFrameParent, ref SlimDX2.Direct3D9.Frame.__Native frameChildRef);		
        
        /// <summary>	
        /// Finds the child frame of a root frame.	
        /// </summary>	
        /// <param name="frameRootRef"> Pointer to the root frame. See <see cref="SlimDX2.Direct3D9.Frame"/>. </param>
        /// <param name="name"> Name of the child frame to find. </param>
        /// <returns> {{LPD3DXFRAME}} Returns the child frame if it is found, or NULL otherwise. See <see cref="SlimDX2.Direct3D9.Frame"/>. </returns>
        /// <unmanaged>LPD3DXFRAME D3DXFrameFind([None] const D3DXFRAME* pFrameRoot,[None] const char* Name)</unmanaged>
		public static IntPtr D3DXFrameFind(ref SlimDX2.Direct3D9.Frame frameRootRef, string name) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native frameRootRef_ = new SlimDX2.Direct3D9.Frame.__Native();
                frameRootRef.__MarshalTo(ref frameRootRef_);
                IntPtr __result__;
                __result__= (IntPtr)D3DXFrameFind_(ref  frameRootRef_,  name);
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>LPD3DXFRAME D3DXFrameFind([None] const D3DXFRAME* pFrameRoot,[None] const char* Name)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFrameFind", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static IntPtr D3DXFrameFind_(ref SlimDX2.Direct3D9.Frame.__Native frameRootRef, [MarshalAs(UnmanagedType.LPStr),In] string name);		
        
        /// <summary>	
        /// Given a frame hierarchy, registers all the named matrices in the animation mixer.	
        /// </summary>	
        /// <param name="pFrameRoot"> The top level node in the frame hierarchy. </param>
        /// <param name="pAnimController"> Pointer to the animation controller object. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXFrameRegisterNamedMatrices([None] LPD3DXFRAME pFrameRoot,[None] LPD3DXANIMATIONCONTROLLER pAnimController)</unmanaged>
		public static SlimDX2.Result D3DXFrameRegisterNamedMatrices(ref SlimDX2.Direct3D9.Frame pFrameRoot, SlimDX2.Direct3D9.ID3DXAnimationController pAnimController) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native pFrameRoot_ = new SlimDX2.Direct3D9.Frame.__Native();
                pFrameRoot.__MarshalTo(ref pFrameRoot_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFrameRegisterNamedMatrices_(ref  pFrameRoot_, (pAnimController == null)?IntPtr.Zero:pAnimController.NativePointer);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFrameRegisterNamedMatrices([None] LPD3DXFRAME pFrameRoot,[None] LPD3DXANIMATIONCONTROLLER pAnimController)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFrameRegisterNamedMatrices", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFrameRegisterNamedMatrices_(ref SlimDX2.Direct3D9.Frame.__Native pFrameRoot, IntPtr pAnimController);		
        
        /// <summary>	
        /// Computes the bounding sphere of all the meshes in the frame hierarchy.	
        /// </summary>	
        /// <param name="frameRootRef"> Pointer to the root node. </param>
        /// <param name="pObjectCenter"> Returns the center of the bounding sphere. </param>
        /// <param name="objectRadiusRef"> Returns the radius of the bounding sphere. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXFrameCalculateBoundingSphere([None] const D3DXFRAME* pFrameRoot,[None] LPD3DXVECTOR3 pObjectCenter,[None] float* pObjectRadius)</unmanaged>
		public static SlimDX2.Result D3DXFrameCalculateBoundingSphere(ref SlimDX2.Direct3D9.Frame frameRootRef, ref SlimMath.Vector3 pObjectCenter, ref float objectRadiusRef) {
            unsafe {
                SlimDX2.Direct3D9.Frame.__Native frameRootRef_ = new SlimDX2.Direct3D9.Frame.__Native();
                frameRootRef.__MarshalTo(ref frameRootRef_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXFrameCalculateBoundingSphere_(ref  frameRootRef_, ref  pObjectCenter, ref  objectRadiusRef);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXFrameCalculateBoundingSphere([None] const D3DXFRAME* pFrameRoot,[None] LPD3DXVECTOR3 pObjectCenter,[None] float* pObjectRadius)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXFrameCalculateBoundingSphere", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXFrameCalculateBoundingSphere_(ref SlimDX2.Direct3D9.Frame.__Native frameRootRef, ref SlimMath.Vector3 pObjectCenter, ref float objectRadiusRef);		
        
        /// <summary>	
        /// Creates a <see cref="SlimDX2.Direct3D9.ID3DXKeyframedAnimationSet"/> key framed animation set interface.	
        /// </summary>	
        /// <param name="nameRef"> Pointer to the name of the animation set. </param>
        /// <param name="ticksPerSecond"> Number of key frame ticks that elapse per second. </param>
        /// <param name="playback"> Type of the animation set playback loop. See <see cref="SlimDX2.Direct3D9.PlaybackType"/>. </param>
        /// <param name="numAnimations"> Number of scale, rotate, and translate (SRT) animation sets. </param>
        /// <param name="numCallbackKeys"> Number of callback keys. </param>
        /// <param name="callbackKeysRef"> Pointer to a <see cref="SlimDX2.Direct3D9.CallbackKey"/> structure that stores user callback data. </param>
        /// <param name="animationSetRef"> Address of a pointer to the <see cref="SlimDX2.Direct3D9.ID3DXKeyframedAnimationSet"/> key framed animation set interface. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateKeyframedAnimationSet([None] const char* pName,[None] double TicksPerSecond,[None] D3DXPLAYBACK_TYPE Playback,[None] int NumAnimations,[None] int NumCallbackKeys,[None] const D3DXKEY_CALLBACK* pCallbackKeys,[None] LPD3DXKEYFRAMEDANIMATIONSET* ppAnimationSet)</unmanaged>
		public static SlimDX2.Result D3DXCreateKeyframedAnimationSet(string nameRef, double ticksPerSecond, SlimDX2.Direct3D9.PlaybackType playback, int numAnimations, int numCallbackKeys, ref SlimDX2.Direct3D9.CallbackKey callbackKeysRef, out SlimDX2.Direct3D9.ID3DXKeyframedAnimationSet animationSetRef) {
            unsafe {
                IntPtr animationSetRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateKeyframedAnimationSet_( nameRef,  ticksPerSecond,  playback,  numAnimations,  numCallbackKeys, ref  callbackKeysRef, out animationSetRef_);
                animationSetRef = (animationSetRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXKeyframedAnimationSet(animationSetRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateKeyframedAnimationSet([None] const char* pName,[None] double TicksPerSecond,[None] D3DXPLAYBACK_TYPE Playback,[None] int NumAnimations,[None] int NumCallbackKeys,[None] const D3DXKEY_CALLBACK* pCallbackKeys,[None] LPD3DXKEYFRAMEDANIMATIONSET* ppAnimationSet)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateKeyframedAnimationSet", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateKeyframedAnimationSet_([MarshalAs(UnmanagedType.LPStr),In] string nameRef, double ticksPerSecond, SlimDX2.Direct3D9.PlaybackType playback, int numAnimations, int numCallbackKeys, ref SlimDX2.Direct3D9.CallbackKey callbackKeysRef, out IntPtr animationSetRef);		
        
        /// <summary>	
        /// Creates a <see cref="SlimDX2.Direct3D9.ID3DXCompressedAnimationSet"/> key framed animation set interface that stores key frame data in a compressed format.	
        /// </summary>	
        /// <param name="nameRef"> Pointer to the name of the animation set. </param>
        /// <param name="ticksPerSecond"> Number of key frame ticks that elapse per second. </param>
        /// <param name="playback"> Type of the animation set playback loop. See <see cref="SlimDX2.Direct3D9.PlaybackType"/>. </param>
        /// <param name="pCompressedData"> Pointer to the <see cref="SlimDX2.Direct3D9.ShaderBytecode"/> buffer that stores the animation set as compressed data. </param>
        /// <param name="numCallbackKeys"> Number of callback keys. </param>
        /// <param name="callbackKeysRef"> Pointer to a <see cref="SlimDX2.Direct3D9.CallbackKey"/> structure that stores user callback data. </param>
        /// <param name="animationSetRef"> Address of a pointer to the <see cref="SlimDX2.Direct3D9.ID3DXCompressedAnimationSet"/> interface that stores key framed animation set data in a compressed format. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateCompressedAnimationSet([None] const char* pName,[None] double TicksPerSecond,[None] D3DXPLAYBACK_TYPE Playback,[None] LPD3DXBUFFER pCompressedData,[None] int NumCallbackKeys,[None] const D3DXKEY_CALLBACK* pCallbackKeys,[None] LPD3DXCOMPRESSEDANIMATIONSET* ppAnimationSet)</unmanaged>
		public static SlimDX2.Result D3DXCreateCompressedAnimationSet(string nameRef, double ticksPerSecond, SlimDX2.Direct3D9.PlaybackType playback, SlimDX2.Direct3D9.ShaderBytecode pCompressedData, int numCallbackKeys, ref SlimDX2.Direct3D9.CallbackKey callbackKeysRef, out SlimDX2.Direct3D9.ID3DXCompressedAnimationSet animationSetRef) {
            unsafe {
                IntPtr animationSetRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateCompressedAnimationSet_( nameRef,  ticksPerSecond,  playback, (pCompressedData == null)?IntPtr.Zero:pCompressedData.NativePointer,  numCallbackKeys, ref  callbackKeysRef, out animationSetRef_);
                animationSetRef = (animationSetRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXCompressedAnimationSet(animationSetRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateCompressedAnimationSet([None] const char* pName,[None] double TicksPerSecond,[None] D3DXPLAYBACK_TYPE Playback,[None] LPD3DXBUFFER pCompressedData,[None] int NumCallbackKeys,[None] const D3DXKEY_CALLBACK* pCallbackKeys,[None] LPD3DXCOMPRESSEDANIMATIONSET* ppAnimationSet)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCompressedAnimationSet", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateCompressedAnimationSet_([MarshalAs(UnmanagedType.LPStr),In] string nameRef, double ticksPerSecond, SlimDX2.Direct3D9.PlaybackType playback, IntPtr pCompressedData, int numCallbackKeys, ref SlimDX2.Direct3D9.CallbackKey callbackKeysRef, out IntPtr animationSetRef);		
        
        /// <summary>	
        /// Creates an animation controller object.	
        /// </summary>	
        /// <remarks>	
        ///  An animation controller controls an animation mixer. The controller adds methods to modify blending parameters over time to enable smooth transitions. 	
        /// </remarks>	
        /// <param name="maxNumMatrices"> Maximum number of animation outputs the controller can support. </param>
        /// <param name="maxNumAnimationSets"> Maximum number of animation sets that can be mixed. </param>
        /// <param name="maxNumTracks"> Maximum number of animation sets that can be mixed simultaneously. </param>
        /// <param name="maxNumEvents"> Maximum number of outstanding events that the controller will support. </param>
        /// <param name="animControllerRef"> Pointer to the animation controller object created. See <see cref="SlimDX2.Direct3D9.ID3DXAnimationController"/>. </param>
        /// <returns> <see cref="int"/> If the function succeeds, the return value is D3D_OK. If the function fails, the return value can be one of the following values: D3DERR_INVALIDCALL, E_OUTOFMEMORY. </returns>
        /// <unmanaged>HRESULT D3DXCreateAnimationController([None] int MaxNumMatrices,[None] int MaxNumAnimationSets,[None] int MaxNumTracks,[None] int MaxNumEvents,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
		public static SlimDX2.Result D3DXCreateAnimationController(int maxNumMatrices, int maxNumAnimationSets, int maxNumTracks, int maxNumEvents, out SlimDX2.Direct3D9.ID3DXAnimationController animControllerRef) {
            unsafe {
                IntPtr animControllerRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)D3DXCreateAnimationController_( maxNumMatrices,  maxNumAnimationSets,  maxNumTracks,  maxNumEvents, out animControllerRef_);
                animControllerRef = (animControllerRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D9.ID3DXAnimationController(animControllerRef_);
                __result__.CheckError();
                return __result__;
            }
        }
		
		/// <summary>Native Interop Function</summary>
        /// <unmanaged>HRESULT D3DXCreateAnimationController([None] int MaxNumMatrices,[None] int MaxNumAnimationSets,[None] int MaxNumTracks,[None] int MaxNumEvents,[None] LPD3DXANIMATIONCONTROLLER* ppAnimController)</unmanaged>
		[DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateAnimationController", CallingConvention = CallingConvention.StdCall, PreserveSig = true), SuppressUnmanagedCodeSecurityAttribute]
		private extern static SlimDX2.Result D3DXCreateAnimationController_(int maxNumMatrices, int maxNumAnimationSets, int maxNumTracks, int maxNumEvents, out IntPtr animControllerRef);		
    }
}