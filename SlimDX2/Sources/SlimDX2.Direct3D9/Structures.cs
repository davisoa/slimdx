// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Structs for SlimDX2.Direct3D9 namespace.
//     This code was generated by a tool.
//     Date : 11/15/2010 14:52:48
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace SlimDX2.Direct3D9 {

    
    /// <summary>	
    /// Defines the window dimensions of a render-target surface onto which a 3D volume projects.	
    /// </summary>	
    /// <remarks>	
    ///  The X, Y, Width, and Height members describe the position and dimensions of the viewport on the render-target surface. Usually, applications render to the entire target surface; when rendering on a 640 x 480 surface, these members should be 0, 0, 640, and 480, respectively. The MinZ and MaxZ are typically set to 0.0 and 1.0 but can be set to other values to achieve specific effects. For example, you might set them both to 0.0 to force the system to render objects to the foreground of a scene, or both to 1.0 to force the objects into the background.  When the viewport parameters for a device change (because of a call to the {{SetViewport}} method), the driver builds a new transformation matrix. 	
    /// </remarks>	
    /// <unmanaged>D3DVIEWPORT9</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct Viewport {	
        
        /// <summary>	
        ///  Pixel coordinate of the upper-left corner of the viewport on the render-target surface. Unless you want to render to a subset of the surface, this member can be set to 0.  	
        /// </summary>	
        /// <unmanaged>int X</unmanaged>
        public int X;
        
        /// <summary>	
        ///  Pixel coordinate of the upper-left corner of the viewport on the render-target surface. Unless you want to render to a subset of the surface, this member can be set to 0.  	
        /// </summary>	
        /// <unmanaged>int Y</unmanaged>
        public int Y;
        
        /// <summary>	
        ///  Width dimension of the clip volume, in pixels. Unless you are rendering only to a subset of the surface, this member should be set to the width dimension of the render-target surface.  	
        /// </summary>	
        /// <unmanaged>int Width</unmanaged>
        public int Width;
        
        /// <summary>	
        ///  Height dimension of the clip volume, in pixels. Unless you are rendering only to a subset of the surface, this member should be set to the height dimension of the render-target surface.  	
        /// </summary>	
        /// <unmanaged>int Height</unmanaged>
        public int Height;
        
        /// <summary>	
        ///  Together with MaxZ, value describing the range of depth values into which a scene is to be rendered, the minimum and maximum values of the clip volume. Most applications set this value to 0.0. Clipping is performed after applying the projection matrix.  	
        /// </summary>	
        /// <unmanaged>float MinZ</unmanaged>
        public float MinZ;
        
        /// <summary>	
        ///  Together with MinZ, value describing the range of depth values into which a scene is to be rendered, the minimum and maximum values of the clip volume. Most applications set this value to 1.0. Clipping is performed after applying the projection matrix.  	
        /// </summary>	
        /// <unmanaged>float MaxZ</unmanaged>
        public float MaxZ;
    }
    
    /// <summary>	
    /// Describes the current clip status.	
    /// </summary>	
    /// <remarks>	
    ///  When clipping is enabled during vertex processing (by {{ProcessVertices}}, {{DrawPrimitive}}, or other drawing functions), Direct3D computes a clip code for every vertex. The clip code is a combination of D3DCS_* bits. When a vertex is outside a particular clipping plane, the corresponding bit is set in the clipping code. Direct3D maintains the clip status using D3DCLIPSTATUS9, which has ClipUnion and ClipIntersection members. ClipUnion is a bitwise OR of all vertex clip codes and ClipIntersection is a bitwise AND of all vertex clip codes. Initial values are zero for ClipUnion and 0xFFFFFFFF for ClipIntersection. When D3DRS_CLIPPING is set to FALSE, ClipUnion and ClipIntersection are set to zero. Direct3D updates the clip status during drawing calls. To compute clip status for a particular object, set ClipUnion and ClipIntersection to their initial value and continue drawing.  Clip status is not updated by {{DrawRectPatch}} and {{DrawTriPatch}} because there is no software emulation for them. 	
    /// </remarks>	
    /// <unmanaged>D3DCLIPSTATUS9</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ClipStatus {	
        
        /// <summary>	
        ///  Clip union flags that describe the current clip status. This member can be one or more of the following flags:  ValueMeaning  D3DCS_ALL   Combination of all clip flags.   D3DCS_LEFT   All vertices are clipped by the left plane of the viewing frustum.   D3DCS_RIGHT   All vertices are clipped by the right plane of the viewing frustum.   D3DCS_TOP   All vertices are clipped by the top plane of the viewing frustum.   D3DCS_BOTTOM   All vertices are clipped by the bottom plane of the viewing frustum.   D3DCS_FRONT   All vertices are clipped by the front plane of the viewing frustum.   D3DCS_BACK   All vertices are clipped by the back plane of the viewing frustum.   D3DCS_PLANE0   Application-defined clipping planes.   D3DCS_PLANE1   Application-defined clipping planes.   D3DCS_PLANE2   Application-defined clipping planes.   D3DCS_PLANE3   Application-defined clipping planes.   D3DCS_PLANE4   Application-defined clipping planes.   D3DCS_PLANE5   Application-defined clipping planes.   ? 	
        /// </summary>	
        /// <unmanaged>int ClipUnion</unmanaged>
        public int ClipUnion;
        
        /// <summary>	
        ///  Clip intersection flags that describe the current clip status. This member can take the same flags as ClipUnion.  	
        /// </summary>	
        /// <unmanaged>int ClipIntersection</unmanaged>
        public int ClipIntersection;
    }
    
    /// <summary>	
    /// Specifies material properties.	
    /// </summary>	
    /// <remarks>	
    ///  To turn off specular highlights, set D3DRS_SPECULARENABLE to FALSE, using <see cref="SlimDX2.Direct3D9.RenderState"/>. This is the fastest option because no specular highlights will be calculated. For more information about using the lighting engine to calculate specular lighting, see {{Specular Lighting (Direct3D 9)}}. 	
    /// </remarks>	
    /// <unmanaged>D3DMATERIAL9</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct Material {	
        
        /// <summary>	
        ///  Value specifying the diffuse color of the material. See <see cref="SlimMath.Color4"/>.  	
        /// </summary>	
        /// <unmanaged>D3DCOLORVALUE Diffuse</unmanaged>
        public SlimMath.Color4 Diffuse;
        
        /// <summary>	
        ///  Value specifying the ambient color of the material. See <see cref="SlimMath.Color4"/>.  	
        /// </summary>	
        /// <unmanaged>D3DCOLORVALUE Ambient</unmanaged>
        public SlimMath.Color4 Ambient;
        
        /// <summary>	
        ///  Value specifying the specular color of the material. See <see cref="SlimMath.Color4"/>.  	
        /// </summary>	
        /// <unmanaged>D3DCOLORVALUE Specular</unmanaged>
        public SlimMath.Color4 Specular;
        
        /// <summary>	
        ///  Value specifying the emissive color of the material. See <see cref="SlimMath.Color4"/>.  	
        /// </summary>	
        /// <unmanaged>D3DCOLORVALUE Emissive</unmanaged>
        public SlimMath.Color4 Emissive;
        
        /// <summary>	
        ///  Floating-point value specifying the sharpness of specular highlights. The higher the value, the sharper the highlight. 	
        /// </summary>	
        /// <unmanaged>float Power</unmanaged>
        public float Power;
    }
    
    /// <summary>	
    /// Defines a set of lighting properties.	
    /// </summary>	
    /// <unmanaged>D3DLIGHT9</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct Light {	
        
        /// <summary>	
        ///  Type of the light source. This value is one of the members of the <see cref="SlimDX2.Direct3D9.LightType"/> enumerated type.  	
        /// </summary>	
        /// <unmanaged>D3DLIGHTTYPE Type</unmanaged>
        public SlimDX2.Direct3D9.LightType Type;
        
        /// <summary>	
        ///  Diffuse color emitted by the light. This member is a <see cref="SlimMath.Color4"/> structure.  	
        /// </summary>	
        /// <unmanaged>D3DCOLORVALUE Diffuse</unmanaged>
        public SlimMath.Color4 Diffuse;
        
        /// <summary>	
        ///  Specular color emitted by the light. This member is a <see cref="SlimMath.Color4"/> structure.  	
        /// </summary>	
        /// <unmanaged>D3DCOLORVALUE Specular</unmanaged>
        public SlimMath.Color4 Specular;
        
        /// <summary>	
        ///  Ambient color emitted by the light. This member is a <see cref="SlimMath.Color4"/> structure.  	
        /// </summary>	
        /// <unmanaged>D3DCOLORVALUE Ambient</unmanaged>
        public SlimMath.Color4 Ambient;
        
        /// <summary>	
        ///  Position of the light in world space, specified by a <see cref="SlimMath.Vector3"/> structure. This member has no meaning for directional lights and is ignored in that case.  	
        /// </summary>	
        /// <unmanaged>D3DVECTOR Position</unmanaged>
        public SlimMath.Vector3 Position;
        
        /// <summary>	
        ///  Direction that the light is pointing in world space, specified by a <see cref="SlimMath.Vector3"/> structure. This member has meaning only for directional and spotlights. This vector need not be normalized, but it should have a nonzero length.  	
        /// </summary>	
        /// <unmanaged>D3DVECTOR Direction</unmanaged>
        public SlimMath.Vector3 Direction;
        
        /// <summary>	
        ///  Distance beyond which the light has no effect. The maximum allowable value for this member is the square root of FLT_MAX. This member does not affect directional lights.  	
        /// </summary>	
        /// <unmanaged>float Range</unmanaged>
        public float Range;
        
        /// <summary>	
        ///  Decrease in illumination between a spotlight's inner cone (the angle specified by  Theta) and the outer edge of the outer cone (the angle specified by Phi).  The effect of falloff on the lighting is subtle. Furthermore, a small performance penalty is incurred by shaping the falloff curve. For these reasons, most developers set this value to 1.0. 	
        /// </summary>	
        /// <unmanaged>float Falloff</unmanaged>
        public float Falloff;
        
        /// <summary>	
        ///  Value specifying how the light intensity changes over distance. Attenuation values are ignored for directional lights. This member represents an attenuation constant. For information about attenuation, see {{Light Properties (Direct3D 9)}}. Valid values for this member range from 0.0 to infinity. For non-directional lights, all three attenuation values should not be set to 0.0 at the same time.  	
        /// </summary>	
        /// <unmanaged>float Attenuation0</unmanaged>
        public float Attenuation0;
        
        /// <summary>	
        ///  Value specifying how the light intensity changes over distance. Attenuation values are ignored for directional lights. This member represents an attenuation constant. For information about attenuation, see {{Light Properties (Direct3D 9)}}. Valid values for this member range from 0.0 to infinity. For non-directional lights, all three attenuation values should not be set to 0.0 at the same time. 	
        /// </summary>	
        /// <unmanaged>float Attenuation1</unmanaged>
        public float Attenuation1;
        
        /// <summary>	
        ///  Value specifying how the light intensity changes over distance. Attenuation values are ignored for directional lights. This member represents an attenuation constant. For information about attenuation, see {{Light Properties (Direct3D 9)}}. Valid values for this member range from 0.0 to infinity. For non-directional lights, all three attenuation values should not be set to 0.0 at the same time. 	
        /// </summary>	
        /// <unmanaged>float Attenuation2</unmanaged>
        public float Attenuation2;
        
        /// <summary>	
        ///  Angle, in radians, of a spotlight's inner cone - that is, the fully illuminated spotlight cone. This value must be in the range from 0 through the value specified by Phi. 	
        /// </summary>	
        /// <unmanaged>float Theta</unmanaged>
        public float Theta;
        
        /// <summary>	
        ///  Angle, in radians, defining the outer edge of the spotlight's outer cone. Points outside this cone are not lit by the spotlight. This value must be between 0 and pi.  	
        /// </summary>	
        /// <unmanaged>float Phi</unmanaged>
        public float Phi;
    }
    
    /// <summary>	
    /// Defines the vertex data layout. Each vertex can contain one or more data types, and each data type is described by a vertex element.	
    /// </summary>	
    /// <remarks>	
    ///  Vertex data is defined using an array of D3DVERTEXELEMENT9 structures. Use {{D3DDECL_END}} to declare the last element in the declaration.  	
    /// </remarks>	
    /// <unmanaged>D3DVERTEXELEMENT9</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct VertexElement {	
        
        /// <summary>	
        ///  Stream number. 	
        /// </summary>	
        /// <unmanaged>short Stream</unmanaged>
        public short Stream;
        
        /// <summary>	
        ///  Offset from the beginning of the vertex data to the data associated with the particular data type. 	
        /// </summary>	
        /// <unmanaged>short Offset</unmanaged>
        public short Offset;
        
        /// <summary>	
        ///  The data type, specified as a <see cref="SlimDX2.Direct3D9.DeclarationType"/>. One of several predefined types that define the data size. Some methods have an implied type. 	
        /// </summary>	
        /// <unmanaged>byte Type</unmanaged>
        public SlimDX2.Direct3D9.DeclarationType Type;
        
        /// <summary>	
        ///  The method specifies the tessellator processing, which determines how the tessellator interprets (or operates on) the vertex data. For more information, see <see cref="SlimDX2.Direct3D9.DeclarationMethod"/>. 	
        /// </summary>	
        /// <unmanaged>byte Method</unmanaged>
        public SlimDX2.Direct3D9.DeclarationMethod Method;
        
        /// <summary>	
        ///  Defines what the data will be used for; that is, the interoperability between vertex data layouts and vertex shaders. Each usage acts to bind a vertex declaration to a vertex shader. In some cases, they have a special interpretation. For example, an element that specifies D3DDECLUSAGE_NORMAL or D3DDECLUSAGE_POSITION is used by the N-patch tessellator to set up tessellation. See <see cref="SlimDX2.Direct3D9.DeclarationUsage"/> for a list of the available semantics. D3DDECLUSAGE_TEXCOORD can be used for user-defined fields (which don't have an existing usage defined). 	
        /// </summary>	
        /// <unmanaged>byte Usage</unmanaged>
        public SlimDX2.Direct3D9.DeclarationUsage Usage;
        
        /// <summary>	
        ///  Modifies the usage data to allow the user to specify multiple usage types. 	
        /// </summary>	
        /// <unmanaged>byte UsageIndex</unmanaged>
        public byte UsageIndex;
    }
    
    /// <summary>	
    /// Describes the display mode.	
    /// </summary>	
    /// <unmanaged>D3DDISPLAYMODE</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct DisplayMode {	
        
        /// <summary>	
        ///  Screen width, in pixels.  	
        /// </summary>	
        /// <unmanaged>int Width</unmanaged>
        public int Width;
        
        /// <summary>	
        ///  Screen height, in pixels.  	
        /// </summary>	
        /// <unmanaged>int Height</unmanaged>
        public int Height;
        
        /// <summary>	
        ///  Refresh rate. The value of 0 indicates an adapter default.  	
        /// </summary>	
        /// <unmanaged>int RefreshRate</unmanaged>
        public int RefreshRate;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the surface format of the display mode.  	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
    }
    
    /// <summary>	
    /// Describes the creation parameters for a device.	
    /// </summary>	
    /// <unmanaged>D3DDEVICE_CREATION_PARAMETERS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct CreationParameters {	
        
        /// <summary>	
        ///  Ordinal number that denotes the display adapter. D3DADAPTER_DEFAULT is always the primary display adapter.  Use this ordinal as the Adapter parameter for any of the <see cref="SlimDX2.Direct3D9.Direct3D"/> methods. Note that different instances of Direct3D 9.0 objects can use different ordinals. Adapters can enter or leave a system when users, for example, add or remove monitors from a multiple-monitor system or when they hot-swap a laptop. Consequently, use this ordinal only in a Direct3D 9.0 instance known to be valid, that is, either the Direct3D 9.0 that created this <see cref="SlimDX2.Direct3D9.Device"/> interface or the Direct3D 9.0 returned from {{GetDirect3D}}, as called through this IDirect3DDevice9 interface. 	
        /// </summary>	
        /// <unmanaged>int AdapterOrdinal</unmanaged>
        public int AdapterOrdinal;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.DeviceType"/> enumerated type. Denotes the amount of emulated functionality for this device. The value of this parameter mirrors the value passed to the {{CreateDevice}} call that created this device. 	
        /// </summary>	
        /// <unmanaged>D3DDEVTYPE DeviceType</unmanaged>
        public SlimDX2.Direct3D9.DeviceType DeviceType;
        
        /// <summary>	
        ///  Window handle to which focus belongs for this Direct3D device. The value of this parameter mirrors the value passed to the {{CreateDevice}} call that created this device. 	
        /// </summary>	
        /// <unmanaged>void* hFocusWindow</unmanaged>
        public IntPtr HFocusWindow;
        
        /// <summary>	
        ///  A combination of one or more {{D3DCREATE}} constants that control global behavior of the device. These constants mirror the constants passed to {{CreateDevice}} when the device was created. 	
        /// </summary>	
        /// <unmanaged>int BehaviorFlags</unmanaged>
        public int BehaviorFlags;
    }
    
    /// <summary>	
    /// Describes the presentation parameters.	
    /// </summary>	
    /// <unmanaged>D3DPRESENT_PARAMETERS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct PresentParameters {	
        
        /// <summary>	
        ///  Width of the new swap chain's back buffers, in pixels. If Windowed is FALSE (the presentation is full-screen), this value must equal the width of one of the enumerated display modes found through {{EnumAdapterModes}}. If Windowed is TRUE and either BackBufferWidth or BackBufferHeight is zero, the corresponding dimension of the client area of the hDeviceWindow (or the focus window, if hDeviceWindow is NULL) is taken. 	
        /// </summary>	
        /// <unmanaged>int BackBufferWidth</unmanaged>
        public int BackBufferWidth;
        
        /// <summary>	
        ///  Height of the new swap chain's back buffers, in pixels. If Windowed is FALSE (the presentation is full-screen), this value must equal the height of one of the enumerated display modes found through {{EnumAdapterModes}}. If Windowed is TRUE and either BackBufferWidth or BackBufferHeight is zero, the corresponding dimension of the client area of the hDeviceWindow (or the focus window, if hDeviceWindow is NULL) is taken. 	
        /// </summary>	
        /// <unmanaged>int BackBufferHeight</unmanaged>
        public int BackBufferHeight;
        
        /// <summary>	
        ///  The back buffer format. For more information about formats, see <see cref="SlimDX2.Direct3D9.Format"/>. This value must be one of the render-target formats as validated by {{CheckDeviceType}}. You can use {{GetDisplayMode}} to obtain the current format. In fact, D3DFMT_UNKNOWN can be specified for the BackBufferFormat while in windowed mode. This tells the runtime to use the current display-mode format and eliminates the need to call {{GetDisplayMode}}. For windowed applications, the back buffer format no longer needs to match the display-mode format because color conversion can now be done by the hardware (if the hardware supports color conversion). The set of possible back buffer formats is constrained, but the runtime will allow any valid back buffer format to be presented to any desktop format. (There is the additional requirement that the device be operable in the desktop mode; devices typically do not operate in 8 bits per pixel modes.) Full-screen applications cannot do color conversion. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT BackBufferFormat</unmanaged>
        public SlimDX2.Direct3D9.Format BackBufferFormat;
        
        /// <summary>	
        ///  This value can be between 0 and <see cref="SlimDX2.Direct3D9.Present.BackBuffersMaximum"/> (or <see cref="SlimDX2.Direct3D9.Present.BackBuffersMaximumEx"/> when using Direct3D 9Ex). Values of 0 are treated as 1. If the number of back buffers cannot be created, the runtime will fail the method call and fill this value with the number of back buffers that could be created. As a result, an application can call the method twice with the same D3DPRESENT_PARAMETERS structure and expect it to work the second time. The method fails if one back buffer cannot be created. The value of BackBufferCount influences what set of swap effects are allowed. Specifically, any D3DSWAPEFFECT_COPY swap effect requires that there be exactly one back buffer. 	
        /// </summary>	
        /// <unmanaged>int BackBufferCount</unmanaged>
        public int BackBufferCount;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.MultisampleType"/> enumerated type. The value must be D3DMULTISAMPLE_NONE unless SwapEffect has been set to D3DSWAPEFFECT_DISCARD. Multisampling is supported only if the swap effect is D3DSWAPEFFECT_DISCARD. 	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_TYPE MultiSampleType</unmanaged>
        public SlimDX2.Direct3D9.MultisampleType MultiSampleType;
        
        /// <summary>	
        ///  Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by  {{CheckDeviceMultiSampleType}}. Passing a larger value returns the error D3DERR_INVALIDCALL. Paired values of render targets or of depth stencil surfaces and <see cref="SlimDX2.Direct3D9.MultisampleType"/> must match. 	
        /// </summary>	
        /// <unmanaged>int MultiSampleQuality</unmanaged>
        public int MultiSampleQuality;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.SwapEffect"/> enumerated type. The runtime will guarantee the implied semantics concerning buffer swap behavior; therefore, if Windowed is TRUE and SwapEffect is set to D3DSWAPEFFECT_FLIP, the runtime will create one extra back buffer and copy whichever becomes the front buffer at presentation time. D3DSWAPEFFECT_COPY requires that BackBufferCount be set to 1. D3DSWAPEFFECT_DISCARD will be enforced in the debug runtime by filling any buffer with noise after it is presented.   Differences between Direct3D9 and Direct3D9Ex In Direct3D9Ex, D3DSWAPEFFECT_FLIPEX is added to designate when an application is adopting flip mode. That is, whan an application's frame is passed in window's mode (instead of copied) to the Desktop Window Manager(DWM) for composition. Flip mode provides more efficient memory bandwidth and enables an application to take advantage of full-screen-present statistics. It does not change full screen behavior. Flip mode behavior is available beginning with Windows 7.   ? 	
        /// </summary>	
        /// <unmanaged>D3DSWAPEFFECT SwapEffect</unmanaged>
        public SlimDX2.Direct3D9.SwapEffect SwapEffect;
        
        /// <summary>	
        ///  The device window determines the location and size of the back buffer on screen. This is used by Direct3D when the back buffer contents are copied to the front buffer during {{Present}}.   For a full-screen application, this is a handle to the top window (which is the focus window).  For applications that use multiple full-screen devices (such as a multimonitor system), exactly one device can use the focus window as the device window. All other devices must have unique device windows.  For a windowed-mode application, this handle will be the default target window for {{Present}}. If this handle is NULL, the focus window will be taken.  Note that no attempt is made by the runtime to reflect user changes in window size. The back buffer is not implicitly reset when this window is reset. However, the {{Present}} method does automatically track window position changes. 	
        /// </summary>	
        /// <unmanaged>void* hDeviceWindow</unmanaged>
        public IntPtr DeviceWindowHandle;
        
        /// <summary>	
        ///  TRUE if the application runs windowed; FALSE if the application runs full-screen. 	
        /// </summary>	
        /// <unmanaged>BOOL Windowed</unmanaged>
        public bool Windowed { 
            get { 
                return (_Windowed!=0)?true:false; 
            }
            set { 
                _Windowed = value?1:0;
            }
        }
        internal int _Windowed;
        
        /// <summary>	
        ///  If this value is TRUE, Direct3D will manage depth buffers for the application. The device will create a depth-stencil buffer when it is created. The depth-stencil buffer will be automatically set as the render target of the device. When the device is reset, the depth-stencil buffer will be automatically destroyed and recreated in the new size. If EnableAutoDepthStencil is TRUE, then AutoDepthStencilFormat must be a valid depth-stencil format. 	
        /// </summary>	
        /// <unmanaged>BOOL EnableAutoDepthStencil</unmanaged>
        public bool EnableAutoDepthStencil { 
            get { 
                return (_EnableAutoDepthStencil!=0)?true:false; 
            }
            set { 
                _EnableAutoDepthStencil = value?1:0;
            }
        }
        internal int _EnableAutoDepthStencil;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type. The format of the automatic depth-stencil surface that the device will create. This member is ignored unless EnableAutoDepthStencil is TRUE. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT AutoDepthStencilFormat</unmanaged>
        public SlimDX2.Direct3D9.Format AutoDepthStencilFormat;
        
        /// <summary>	
        ///  One of the {{D3DPRESENTFLAG}} constants. 	
        /// </summary>	
        /// <unmanaged>int Flags</unmanaged>
        public SlimDX2.Direct3D9.PresentFlags PresentFlags;
        
        /// <summary>	
        ///  The rate at which the display adapter refreshes the screen. The value depends on the mode in which the application is running:  For windowed mode, the refresh rate must be 0. For full-screen mode, the refresh rate is one of the refresh rates returned by {{EnumAdapterModes}}.  	
        /// </summary>	
        /// <unmanaged>int FullScreen_RefreshRateInHz</unmanaged>
        public int FullScreenRefreshRateInHz;
        
        /// <summary>	
        ///  The maximum rate at which the swap chain's back buffers can be presented to the front buffer. For a detailed explanation of the modes and the intervals that are supported, see <see cref="SlimDX2.Direct3D9.Present"/>. 	
        /// </summary>	
        /// <unmanaged>int PresentationInterval</unmanaged>
        public SlimDX2.Direct3D9.PresentInterval PresentationInterval;
    }
    
    /// <summary>	
    /// Contains red, green, and blue ramp data.	
    /// </summary>	
    /// <unmanaged>D3DGAMMARAMP</unmanaged>
    public  partial struct GammaRamp {	
        
        /// <summary>	
        ///  Array of 256  WORD element that describes the red gamma ramp.  	
        /// </summary>	
        /// <unmanaged>short red[256]</unmanaged>
        public short[] Red { 
            get { 
                if (_Red == null) {
                    _Red = new short[256];
                }
                return _Red; 
            }
        }
        internal short[] _Red;
        
        /// <summary>	
        ///  Array of 256  WORD element that describes the green gamma ramp.  	
        /// </summary>	
        /// <unmanaged>short green[256]</unmanaged>
        public short[] Green { 
            get { 
                if (_Green == null) {
                    _Green = new short[256];
                }
                return _Green; 
            }
        }
        internal short[] _Green;
        
        /// <summary>	
        ///  Array of 256  WORD element that describes the blue gamma ramp.  	
        /// </summary>	
        /// <unmanaged>short blue[256]</unmanaged>
        public short[] Blue { 
            get { 
                if (_Blue == null) {
                    _Blue = new short[256];
                }
                return _Blue; 
            }
        }
        internal short[] _Blue;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public fixed short Red[256];
            public fixed short Green[256];
            public fixed short Blue[256];
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            fixed (void* __to = &this.Red[0]) fixed (void* __from = @ref.Red) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 256*sizeof ( short));
            fixed (void* __to = &this.Green[0]) fixed (void* __from = @ref.Green) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 256*sizeof ( short));
            fixed (void* __to = &this.Blue[0]) fixed (void* __from = @ref.Blue) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 256*sizeof ( short));
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            fixed (void* __to = @ref.Red) fixed (void* __from = &this.Red[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 256*sizeof ( short));
            fixed (void* __to = @ref.Green) fixed (void* __from = &this.Green[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 256*sizeof ( short));
            fixed (void* __to = @ref.Blue) fixed (void* __from = &this.Blue[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 256*sizeof ( short));
		
		}
    }
    
    /// <summary>	
    /// Describes a vertex buffer.	
    /// </summary>	
    /// <unmanaged>D3DVERTEXBUFFER_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct VertexBufferDescription {	
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the surface format of the vertex buffer data. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.ResourceType"/> enumerated type, identifying this resource as a vertex buffer. 	
        /// </summary>	
        /// <unmanaged>D3DRESOURCETYPE Type</unmanaged>
        public SlimDX2.Direct3D9.ResourceType Type;
        
        /// <summary>	
        ///  Combination of one or more <see cref="SlimDX2.Direct3D9.Usage"/> flags. 	
        /// </summary>	
        /// <unmanaged>int Usage</unmanaged>
        public int Usage;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, specifying the class of memory allocated for this vertex buffer. 	
        /// </summary>	
        /// <unmanaged>D3DPOOL Pool</unmanaged>
        public SlimDX2.Direct3D9.Pool Pool;
        
        /// <summary>	
        ///  Size of the vertex buffer, in bytes. 	
        /// </summary>	
        /// <unmanaged>int Size</unmanaged>
        public int Size;
        
        /// <summary>	
        ///  Combination of <see cref="SlimDX2.Direct3D9.VertexFormat"/> that describes the vertex format of the vertices in this buffer. 	
        /// </summary>	
        /// <unmanaged>int FVF</unmanaged>
        public SlimDX2.Direct3D9.VertexFormat Fvf;
    }
    
    /// <summary>	
    /// Describes an index buffer.	
    /// </summary>	
    /// <unmanaged>D3DINDEXBUFFER_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct IndexBufferDescription {	
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the surface format of the index buffer data. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.ResourceType"/> enumerated type, identifying this resource as an index buffer. 	
        /// </summary>	
        /// <unmanaged>D3DRESOURCETYPE Type</unmanaged>
        public SlimDX2.Direct3D9.ResourceType Type;
        
        /// <summary>	
        ///  Combination of one or more of the following flags, specifying the usage for this resource.  ValueMeaning  D3DUSAGE_DONOTCLIP   Set to indicate that the index buffer content will never require clipping.   D3DUSAGE_DYNAMIC   Set to indicate that the index buffer requires dynamic memory use. This is useful for drivers because it enables them to decide where to place the buffer. In general, static index buffers are placed in video memory and dynamic index buffers are placed in AGP memory. Note that there is no separate static usage; if you do not specify D3DUSAGE_DYNAMIC the index buffer is made static. D3DUSAGE_DYNAMIC is strictly enforced through the D3DLOCK_DISCARD and D3DLOCK_NOOVERWRITE locking flags. As a result, D3DLOCK_DISCARD and D3DLOCK_NOOVERWRITE are only valid on index buffers created with D3DUSAGE_DYNAMIC; they are not valid flags on static vertex buffers. For more information about using dynamic index buffers, see {{Using Dynamic Vertex and Index Buffers}}. Note that D3DUSAGE_DYNAMIC cannot be specified on managed index buffers. For more information, see {{Managing Resources (Direct3D 9)}}.   D3DUSAGE_RTPATCHES   Set to indicate when the index buffer is to be used for drawing high-order primitives.   D3DUSAGE_NPATCHES   Set to indicate when the index buffer is to be used for drawing N patches.   D3DUSAGE_POINTS   Set to indicate when the index buffer is to be used for drawing point sprites or indexed point lists.   D3DUSAGE_SOFTWAREPROCESSING   Set to indicate that the buffer is to be used with software processing.   D3DUSAGE_WRITEONLY   Informs the system that the application writes only to the index buffer. Using this flag enables the driver to choose the best memory location for efficient write operations and rendering. Attempts to read from an index buffer that is created with this capability can result in degraded performance.   ? 	
        /// </summary>	
        /// <unmanaged>int Usage</unmanaged>
        public int Usage;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, specifying the class of memory allocated for this index buffer. 	
        /// </summary>	
        /// <unmanaged>D3DPOOL Pool</unmanaged>
        public SlimDX2.Direct3D9.Pool Pool;
        
        /// <summary>	
        ///  Size of the index buffer, in bytes. 	
        /// </summary>	
        /// <unmanaged>int Size</unmanaged>
        public int Size;
    }
    
    /// <summary>	
    /// Describes a surface.	
    /// </summary>	
    /// <unmanaged>D3DSURFACE_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct SurfaceDescription {	
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the surface format.  	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.ResourceType"/> enumerated type, identifying this resource as a surface.  	
        /// </summary>	
        /// <unmanaged>D3DRESOURCETYPE Type</unmanaged>
        public SlimDX2.Direct3D9.ResourceType Type;
        
        /// <summary>	
        ///  Either the D3DUSAGE_DEPTHSTENCIL or D3DUSAGE_RENDERTARGET values. For more information, see <see cref="SlimDX2.Direct3D9.Usage"/>. 	
        /// </summary>	
        /// <unmanaged>int Usage</unmanaged>
        public int Usage;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, specifying the class of memory allocated for this surface. 	
        /// </summary>	
        /// <unmanaged>D3DPOOL Pool</unmanaged>
        public SlimDX2.Direct3D9.Pool Pool;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.MultisampleType"/> enumerated type, specifying the levels of full-scene multisampling supported by the surface. 	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_TYPE MultiSampleType</unmanaged>
        public SlimDX2.Direct3D9.MultisampleType MultiSampleType;
        
        /// <summary>	
        ///  Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by  {{CheckDeviceMultiSampleType}}. Passing a larger value returns the error, D3DERR_INVALIDCALL. The MultisampleQuality values of paired render targets, depth stencil surfaces and the MultiSample type must all match. 	
        /// </summary>	
        /// <unmanaged>int MultiSampleQuality</unmanaged>
        public int MultiSampleQuality;
        
        /// <summary>	
        ///  Width of the surface, in pixels. 	
        /// </summary>	
        /// <unmanaged>int Width</unmanaged>
        public int Width;
        
        /// <summary>	
        ///  Height of the surface, in pixels. 	
        /// </summary>	
        /// <unmanaged>int Height</unmanaged>
        public int Height;
    }
    
    /// <summary>	
    /// Describes a volume.	
    /// </summary>	
    /// <unmanaged>D3DVOLUME_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct VolumeDescription {	
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the surface format of the volume.  	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.ResourceType"/> enumerated type, identifying this resource as a volume.  	
        /// </summary>	
        /// <unmanaged>D3DRESOURCETYPE Type</unmanaged>
        public SlimDX2.Direct3D9.ResourceType Type;
        
        /// <summary>	
        ///  Currently not used. Always returned as 0.  	
        /// </summary>	
        /// <unmanaged>int Usage</unmanaged>
        public int Usage;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, specifying the class of memory allocated for this volume.  	
        /// </summary>	
        /// <unmanaged>D3DPOOL Pool</unmanaged>
        public SlimDX2.Direct3D9.Pool Pool;
        
        /// <summary>	
        ///  Width of the volume, in pixels.  	
        /// </summary>	
        /// <unmanaged>int Width</unmanaged>
        public int Width;
        
        /// <summary>	
        ///  Height of the volume, in pixels.  	
        /// </summary>	
        /// <unmanaged>int Height</unmanaged>
        public int Height;
        
        /// <summary>	
        ///  Depth of the volume, in pixels.  	
        /// </summary>	
        /// <unmanaged>int Depth</unmanaged>
        public int Depth;
    }
    
    /// <summary>	
    /// Describes a locked rectangular region.	
    /// </summary>	
    /// <remarks>	
    ///  The pitch for DXTn formats is different from what was returned in DirectX 7. It now refers to the number of bytes in a row of blocks. For example, if you have a width of 16, then you will have a pitch of 4 blocks (4*8 for DXT1, 4*16 for DXT2-5.) 	
    /// </remarks>	
    /// <unmanaged>D3DLOCKED_RECT</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct LockedRect {	
        
        /// <summary>	
        ///  Number of bytes in one row of the surface. 	
        /// </summary>	
        /// <unmanaged>int Pitch</unmanaged>
        public int Pitch;
        
        /// <summary>	
        ///  Pointer to the locked bits. If a <see cref="SlimDX2.Rectangle"/> was provided to the {{LockRect}} call, pBits will be appropriately offset from the start of the surface. 	
        /// </summary>	
        /// <unmanaged>void* pBits</unmanaged>
        public IntPtr PBits;
    }
    
    /// <summary>	
    /// Defines a volume.	
    /// </summary>	
    /// <remarks>	
    ///  D3DBOX includes the left, top, and front edges; however, the right, bottom, and back edges are not included. For example, a box that is 100 units wide and begins at 0 (thus, including the points up to and including 99) would be expressed with a value of 0 for the Left member and a value of 100 for the Right member. Note that a value of 99 is not used for the Right member. The restrictions on side ordering observed for D3DBOX are left to right, top to bottom, and front to back. 	
    /// </remarks>	
    /// <unmanaged>D3DBOX</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct Box {	
        
        /// <summary>	
        ///  Position of the left side of the box on the x-axis. 	
        /// </summary>	
        /// <unmanaged>int Left</unmanaged>
        public int Left;
        
        /// <summary>	
        ///  Position of the top of the box on the y-axis. 	
        /// </summary>	
        /// <unmanaged>int Top</unmanaged>
        public int Top;
        
        /// <summary>	
        ///  Position of the right side of the box on the x-axis. 	
        /// </summary>	
        /// <unmanaged>int Right</unmanaged>
        public int Right;
        
        /// <summary>	
        ///  Position of the bottom of the box on the y-axis. 	
        /// </summary>	
        /// <unmanaged>int Bottom</unmanaged>
        public int Bottom;
        
        /// <summary>	
        ///  Position of the front of the box on the z-axis. 	
        /// </summary>	
        /// <unmanaged>int Front</unmanaged>
        public int Front;
        
        /// <summary>	
        ///  Position of the back of the box on the z-axis. 	
        /// </summary>	
        /// <unmanaged>int Back</unmanaged>
        public int Back;
    }
    
    /// <summary>	
    /// Describes a locked box (volume).	
    /// </summary>	
    /// <remarks>	
    ///  Volumes can be visualized as being organized into slices of width x height 2D surfaces stacked up to make a width x height x depth volume. For more information, see {{Volume Texture Resources (Direct3D 9)}}. 	
    /// </remarks>	
    /// <unmanaged>D3DLOCKED_BOX</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct LockedBox {	
        
        /// <summary>	
        ///  Byte offset from the left edge of one row to the left edge of the next row. 	
        /// </summary>	
        /// <unmanaged>int RowPitch</unmanaged>
        public int RowPitch;
        
        /// <summary>	
        ///  Byte offset from the top-left of one slice to the top-left of the next deepest slice.  	
        /// </summary>	
        /// <unmanaged>int SlicePitch</unmanaged>
        public int SlicePitch;
        
        /// <summary>	
        ///  Pointer to the beginning of the volume box. If a <see cref="SlimDX2.Direct3D9.Box"/> was provided to the LockBox call, pBits will be appropriately offset from the start of the volume.  	
        /// </summary>	
        /// <unmanaged>void* pBits</unmanaged>
        public IntPtr PBits;
    }
    
    /// <summary>	
    /// Describes a rectangular high-order patch.	
    /// </summary>	
    /// <remarks>	
    ///  The following diagram identifies the parameters that specify a rectangle patch. ?  Diagram of a rectangular high-order patch and the parameters that specify it ? Each of the vertices in the vertex buffer is shown as a black dot. In this case, the vertex buffer has 20 vertices in it, 16 of which are in the rectangle patch. The stride is the number of vertices in the width of the vertex buffer, in this case five. The x offset to the first vertex is called the StartIndexVertexWidth and is in this case 1. The y offset to the first patch vertex is called the StartIndexVertexHeight and is in this case 0. To render a stream of individual rectangular patches (non-mosaic), you should interpret your geometry as a long narrow (1 x N) rectangular patch. The D3DRECTPATCH_INFO structure for such a strip (cubic B?zier) would be set up in the following manner. 	
    /// <code> D3DRECTPATCH_INFO RectInfo; RectInfo.Width = 4;	
    /// RectInfo.Height = 4;	
    /// RectInfo.Stride = 4;	
    /// RectInfo.Basis = D3DBASIS_BEZIER;	
    /// RectInfo.Order = D3DORDER_CUBIC;	
    /// RectInfo.StartVertexOffsetWidth = 0;	
    /// RectInfo.StartVertexOffsetHeight = 4*i;  // The variable i is the index of the 	
    /// //   patch you want to render. </code>	
    /// 	
    ///  	
    /// </remarks>	
    /// <unmanaged>D3DRECTPATCH_INFO</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct RectanglePatchInfo {	
        
        /// <summary>	
        ///  Starting vertex offset width, in number of vertices.  	
        /// </summary>	
        /// <unmanaged>int StartVertexOffsetWidth</unmanaged>
        public int StartVertexOffsetWidth;
        
        /// <summary>	
        ///  Starting vertex offset height, in number of vertices.  	
        /// </summary>	
        /// <unmanaged>int StartVertexOffsetHeight</unmanaged>
        public int StartVertexOffsetHeight;
        
        /// <summary>	
        ///  Width of each vertex, in number of vertices.  	
        /// </summary>	
        /// <unmanaged>int Width</unmanaged>
        public int Width;
        
        /// <summary>	
        ///  Height of each vertex, in number of vertices.  	
        /// </summary>	
        /// <unmanaged>int Height</unmanaged>
        public int Height;
        
        /// <summary>	
        ///  Width of the imaginary two-dimensional vertex array, which occupies the same space as the vertex buffer. For an example, see the diagram below.  	
        /// </summary>	
        /// <unmanaged>int Stride</unmanaged>
        public int Stride;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Basis"/> enumerated type, defining the basis type for the rectangular high-order patch.   ValueOrder supportedWidth and height D3DBASIS_BEZIERLinear, cubic, and quinticWidth = height = (DWORD)order + 1 D3DBASIS_BSPLINELinear, cubic, and quinticWidth = height &gt; (DWORD)order D3DBASIS_INTERPOLATECubicWidth = height &gt; (DWORD)order  ? 	
        /// </summary>	
        /// <unmanaged>D3DBASISTYPE Basis</unmanaged>
        public SlimDX2.Direct3D9.Basis Basis;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Degree"/> enumerated type, defining the degree for the rectangular patch.  	
        /// </summary>	
        /// <unmanaged>D3DDEGREETYPE Degree</unmanaged>
        public SlimDX2.Direct3D9.Degree Degree;
    }
    
    /// <summary>	
    /// Describes a triangular high-order patch.	
    /// </summary>	
    /// <remarks>	
    ///  For example, the following diagram identifies the vertex order and segment numbers for a cubic B?zier triangle patch. The vertex order determines the segment numbers used by {{DrawTriPatch}}. The offset is the number of bytes to the first triangle patch vertex in the vertex buffer. ?  Diagram of a triangular high-order patch with nine vertices ? 	
    /// </remarks>	
    /// <unmanaged>D3DTRIPATCH_INFO</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct TrianglePatchInfo {	
        
        /// <summary>	
        ///  Starting vertex offset, in number of vertices.  	
        /// </summary>	
        /// <unmanaged>int StartVertexOffset</unmanaged>
        public int StartVertexOffset;
        
        /// <summary>	
        ///  Number of vertices. 	
        /// </summary>	
        /// <unmanaged>int NumVertices</unmanaged>
        public int NumVertices;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Basis"/> enumerated type, which defines the basis type for the triangular high-order patch. The only valid value for this member is D3DBASIS_BEZIER. 	
        /// </summary>	
        /// <unmanaged>D3DBASISTYPE Basis</unmanaged>
        public SlimDX2.Direct3D9.Basis Basis;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Degree"/> enumerated type, defining the degree type for the triangular high-order patch.  ValueNumber of vertices D3DDEGREE_CUBIC10 D3DDEGREE_LINEAR3 D3DDEGREE_QUADRATICN/A D3DDEGREE_QUINTIC21  ? N/A - Not available. Not supported. 	
        /// </summary>	
        /// <unmanaged>D3DDEGREETYPE Degree</unmanaged>
        public SlimDX2.Direct3D9.Degree Degree;
    }
    
    /// <summary>	
    /// Contains information identifying the adapter.	
    /// </summary>	
    /// <remarks>	
    ///  The following pseudocode example illustrates the version format encoded in the DriverVersion, DriverVersionLowPart, and DriverVersionHighPart members. 	
    /// <code> Product = HIWORD(DriverVersion.HighPart)	
    /// Version = LOWORD(DriverVersion.HighPart)	
    /// SubVersion = HIWORD(DriverVersion.LowPart)	
    /// Build = LOWORD(DriverVersion.LowPart) </code>	
    /// 	
    ///  See the Platform SDK for more information about the HIWORD macro, the LOWORD macro, and the LARGE_INTEGER structure. MAX_DEVICE_IDENTIFIER_STRING is a constant with the following definition. 	
    /// <code> #define MAX_DEVICE_IDENTIFIER_STRING        512 </code>	
    /// 	
    ///  The VendorId, DeviceId, SubSysId, and Revision members can be used in tandem to identify particular chip sets. However, use these members with caution. 	
    /// </remarks>	
    /// <unmanaged>D3DADAPTER_IDENTIFIER9</unmanaged>
    public  partial struct AdapterDetails {	
        
        /// <summary>	
        ///  Used for presentation to the user. This should not be used to identify particular drivers, because many different strings might be associated with the same device and driver from different vendors. 	
        /// </summary>	
        /// <unmanaged>char Driver[512]</unmanaged>
        public string Driver;
        
        /// <summary>	
        ///  Used for presentation to the user. 	
        /// </summary>	
        /// <unmanaged>char Description[512]</unmanaged>
        public string Description;
        
        /// <summary>	
        ///  Device name for GDI. 	
        /// </summary>	
        /// <unmanaged>char DeviceName[32]</unmanaged>
        public string DeviceName;
        
        /// <summary>	
        ///  Identify the version of the Direct3D driver. It is legal to do less than and greater than comparisons on the 64-bit signed integer value. However, exercise caution if you use this element to identify problematic drivers. Instead, you should use DeviceIdentifier. See Remarks. 	
        /// </summary>	
        /// <unmanaged>int DriverVersionLowPart</unmanaged>
        public int DriverVersionLowPart;
        
        /// <summary>	
        ///  Identify the version of the Direct3D driver. It is legal to do &lt; and &gt; comparisons on the 64-bit signed integer value. However, exercise caution if you use this element to identify problematic drivers. Instead, you should use DeviceIdentifier. See Remarks. 	
        /// </summary>	
        /// <unmanaged>int DriverVersionHighPart</unmanaged>
        public int DriverVersionHighPart;
        
        /// <summary>	
        ///  Identify the version of the Direct3D driver. It is legal to do &lt; and &gt; comparisons on the 64-bit signed integer value. However, exercise caution if you use this element to identify problematic drivers. Instead, you should use DeviceIdentifier. See Remarks. 	
        /// </summary>	
        /// <unmanaged>int VendorId</unmanaged>
        public int VendorId;
        
        /// <summary>	
        ///  Can be used to help identify a particular chip set. Query this member to identify the manufacturer. The value can be zero if unknown. 	
        /// </summary>	
        /// <unmanaged>int DeviceId</unmanaged>
        public int DeviceId;
        
        /// <summary>	
        ///  Can be used to help identify a particular chip set. Query this member to identify the type of chip set. The value can be zero if unknown. 	
        /// </summary>	
        /// <unmanaged>int SubSysId</unmanaged>
        public int SubSysId;
        
        /// <summary>	
        ///  Can be used to help identify a particular chip set. Query this member to identify the subsystem, typically the particular board. The value can be zero if unknown. 	
        /// </summary>	
        /// <unmanaged>int Revision</unmanaged>
        public int Revision;
        
        /// <summary>	
        ///  Can be used to help identify a particular chip set. Query this member to identify the revision level of the chip set. The value can be zero if unknown. 	
        /// </summary>	
        /// <unmanaged>GUID DeviceIdentifier</unmanaged>
        public Guid DeviceIdentifier;
        
        /// <summary>	
        ///  Can be queried to check changes in the driver and chip set. This GUID is a unique identifier for the driver and chip set pair. Query this member to track changes to the driver and chip set in order to generate a new profile for the graphics subsystem. DeviceIdentifier can also be used to identify particular problematic drivers. 	
        /// </summary>	
        /// <unmanaged>int WHQLLevel</unmanaged>
        public int WHQLLevel;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public fixed byte Driver[512];
            public fixed byte Description[512];
            public fixed byte DeviceName[32];
            public int DriverVersionLowPart;
            public int DriverVersionHighPart;
            public int VendorId;
            public int DeviceId;
            public int SubSysId;
            public int Revision;
            public Guid DeviceIdentifier;
            public int WHQLLevel;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            fixed (void* __ptr = @ref.Driver) this.Driver = new string((sbyte*)__ptr, 0, 512);
            fixed (void* __ptr = @ref.Description) this.Description = new string((sbyte*)__ptr, 0, 512);
            fixed (void* __ptr = @ref.DeviceName) this.DeviceName = new string((sbyte*)__ptr, 0, 32);
            this.DriverVersionLowPart = @ref.DriverVersionLowPart;
            this.DriverVersionHighPart = @ref.DriverVersionHighPart;
            this.VendorId = @ref.VendorId;
            this.DeviceId = @ref.DeviceId;
            this.SubSysId = @ref.SubSysId;
            this.Revision = @ref.Revision;
            this.DeviceIdentifier = @ref.DeviceIdentifier;
            this.WHQLLevel = @ref.WHQLLevel;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            IntPtr Driver_ = Marshal.StringToHGlobalAnsi(this.Driver);
            fixed (void* __ptr = @ref.Driver) Utilities.CopyMemory((IntPtr)__ptr, Driver_, this.Driver.Length);
            Marshal.FreeHGlobal( Driver_);
            IntPtr Description_ = Marshal.StringToHGlobalAnsi(this.Description);
            fixed (void* __ptr = @ref.Description) Utilities.CopyMemory((IntPtr)__ptr, Description_, this.Description.Length);
            Marshal.FreeHGlobal( Description_);
            IntPtr DeviceName_ = Marshal.StringToHGlobalAnsi(this.DeviceName);
            fixed (void* __ptr = @ref.DeviceName) Utilities.CopyMemory((IntPtr)__ptr, DeviceName_, this.DeviceName.Length);
            Marshal.FreeHGlobal( DeviceName_);
            @ref.DriverVersionLowPart = this.DriverVersionLowPart;
            @ref.DriverVersionHighPart = this.DriverVersionHighPart;
            @ref.VendorId = this.VendorId;
            @ref.DeviceId = this.DeviceId;
            @ref.SubSysId = this.SubSysId;
            @ref.Revision = this.Revision;
            @ref.DeviceIdentifier = this.DeviceIdentifier;
            @ref.WHQLLevel = this.WHQLLevel;
		
		}
    }
    
    /// <summary>	
    /// Describes the raster status.	
    /// </summary>	
    /// <unmanaged>D3DRASTER_STATUS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct RasterStatus {	
        
        /// <summary>	
        ///  TRUE if the raster is in the vertical blank period. FALSE if the raster is not in the vertical blank period.  	
        /// </summary>	
        /// <unmanaged>BOOL InVBlank</unmanaged>
        public bool InVBlank { 
            get { 
                return (_InVBlank!=0)?true:false; 
            }
            set { 
                _InVBlank = value?1:0;
            }
        }
        internal int _InVBlank;
        
        /// <summary>	
        ///  If InVBlank is FALSE, then this value is an integer roughly corresponding to the current scan line painted by the raster. Scan lines are numbered in the same way as Direct3D surface coordinates: 0 is the top of the primary surface, extending to the value (height of the surface - 1) at the bottom of the display. If InVBlank is TRUE, then this value is set to zero and can be ignored. 	
        /// </summary>	
        /// <unmanaged>int ScanLine</unmanaged>
        public int ScanLine;
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DPRESENTSTATS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct PresentationStatistics {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int PresentCount</unmanaged>
        public int PresentCount;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int PresentRefreshCount</unmanaged>
        public int PresentRefreshCount;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int SyncRefreshCount</unmanaged>
        public int SyncRefreshCount;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>__int64 SyncQPCTime</unmanaged>
        public long SyncQPCTime;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>__int64 SyncGPUTime</unmanaged>
        public long SyncGPUTime;
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DDISPLAYMODEEX</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct DisplayModeEx {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int Size</unmanaged>
        public int Size;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int Width</unmanaged>
        public int Width;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int Height</unmanaged>
        public int Height;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int RefreshRate</unmanaged>
        public int RefreshRate;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSCANLINEORDERING ScanLineOrdering</unmanaged>
        public SlimDX2.Direct3D9.ScanlineOrdering ScanLineOrdering;
    }
    
    /// <summary>	
    /// Specifies types of display modes to filter out.	
    /// </summary>	
    /// <unmanaged>D3DDISPLAYMODEFILTER</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct DisplayModeFilter {	
        
        /// <summary>	
        ///  The size of this structure. This should always be set to sizeof(D3DDISPLAYMODEFILTER). 	
        /// </summary>	
        /// <unmanaged>int Size</unmanaged>
        public int Size;
        
        /// <summary>	
        ///  The display mode format to filter out. See <see cref="SlimDX2.Direct3D9.Format"/>. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        ///  Whether the scanline ordering is interlaced or progressive. See <see cref="SlimDX2.Direct3D9.ScanlineOrdering"/>. 	
        /// </summary>	
        /// <unmanaged>D3DSCANLINEORDERING ScanLineOrdering</unmanaged>
        public SlimDX2.Direct3D9.ScanlineOrdering ScanLineOrdering;
    }
    
    /// <summary>	
    /// Vertex shader caps.	
    /// </summary>	
    /// <unmanaged>D3DVSHADERCAPS2_0</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct VertexShader20Caps {	
        
        /// <summary>	
        ///  Instruction predication is supported if this value is nonzero. See {{setp_comp - vs}}. 	
        /// </summary>	
        /// <unmanaged>int Caps</unmanaged>
        public int Caps;
        
        /// <summary>	
        ///   Either 0 or 24, which represents the depth of the dynamic flow control instruction nesting. See {{D3DVS20CAPS}}. 	
        /// </summary>	
        /// <unmanaged>int DynamicFlowControlDepth</unmanaged>
        public int DynamicFlowControlDepth;
        
        /// <summary>	
        ///  The number of temporary registers supported. See {{D3DVS20CAPS}}. 	
        /// </summary>	
        /// <unmanaged>int NumTemps</unmanaged>
        public int NumTemps;
        
        /// <summary>	
        ///  The depth of nesting of the {{loop - vs}}/{{rep - vs}} and {{call - vs}}/{{callnz bool - vs}} instructions. See {{D3DVS20CAPS}}. 	
        /// </summary>	
        /// <unmanaged>int StaticFlowControlDepth</unmanaged>
        public int StaticFlowControlDepth;
    }
    
    /// <summary>	
    /// Pixel shader driver caps.	
    /// </summary>	
    /// <unmanaged>D3DPSHADERCAPS2_0</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct PixelShader20Caps {	
        
        /// <summary>	
        ///  Instruction predication is supported if this value is nonzero. See {{setp_comp - vs}}. 	
        /// </summary>	
        /// <unmanaged>int Caps</unmanaged>
        public int Caps;
        
        /// <summary>	
        ///  Either 0 or 24, which represents the depth of the dynamic flow control instruction nesting. See D3DPSHADERCAPS2_0. 	
        /// </summary>	
        /// <unmanaged>int DynamicFlowControlDepth</unmanaged>
        public int DynamicFlowControlDepth;
        
        /// <summary>	
        ///  The number of temporary registers supported. See D3DPSHADERCAPS2_0. 	
        /// </summary>	
        /// <unmanaged>int NumTemps</unmanaged>
        public int NumTemps;
        
        /// <summary>	
        ///  The depth of nesting of the {{loop - vs}}/{{rep - vs}} and {{call - vs}}/{{callnz bool - vs}} instructions. See D3DPSHADERCAPS2_0. 	
        /// </summary>	
        /// <unmanaged>int StaticFlowControlDepth</unmanaged>
        public int StaticFlowControlDepth;
        
        /// <summary>	
        ///  The number of instruction slots supported. See D3DPSHADERCAPS2_0. 	
        /// </summary>	
        /// <unmanaged>int NumInstructionSlots</unmanaged>
        public int NumInstructionSlots;
    }
    
    /// <summary>	
    /// Represents the capabilities of the hardware exposed through the Direct3D object.	
    /// </summary>	
    /// <remarks>	
    ///  The MaxTextureBlendStages and MaxSimultaneousTextures members might seem similar, but they contain different information. The MaxTextureBlendStages member contains the total number of texture-blending stages supported by the current device, and the MaxSimultaneousTextures member describes how many of those stages can have textures bound to them by using the {{SetTexture}} method. When the driver fills this structure, it can set values for execute-buffer capabilities, even when the interface being used to retrieve the capabilities (such as <see cref="SlimDX2.Direct3D9.Device"/>) does not support execute buffers. In general, performance problems may occur if you use a texture and then modify it during a scene. Ensure that no texture used in the current {{BeginScene}} and {{EndScene}} block is evicted unless absolutely necessary. In the case of extremely high texture usage within a scene, the results are undefined. This occurs when you modify a texture that you have used in the scene and there is no spare texture memory available. For such systems, the contents of the z-buffer become invalid at EndScene. Applications should not call {{UpdateSurface}} to or from the back buffer on this type of hardware inside a BeginScene/EndScene pair. In addition, applications should not try to access the z-buffer if the D3DPRASTERCAPS_ZBUFFERLESSHSR capability flag is set. Finally, applications should not lock the back buffer or the z-buffer inside a BeginScene/EndScene pair. The following flags concerning mipmapped textures are not supported in Direct3D 9.   D3DPTFILTERCAPS_LINEAR D3DPTFILTERCAPS_LINEARMIPLINEAR D3DPTFILTERCAPS_LINEARMIPNEAREST D3DPTFILTERCAPS_MIPNEAREST D3DPTFILTERCAPS_NEAREST  	
    /// </remarks>	
    /// <unmanaged>D3DCAPS9</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct Capabilities {	
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DXFONT_DESCW</unmanaged>
    public  partial struct FontDescription {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int Height</unmanaged>
        public int Height;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int Width</unmanaged>
        public int Width;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int Weight</unmanaged>
        public int Weight;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>int MipLevels</unmanaged>
        public int MipLevels;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>BOOL Italic</unmanaged>
        public bool Italic { 
            get { 
                return (_Italic!=0)?true:false; 
            }
            set { 
                _Italic = value?1:0;
            }
        }
        internal int _Italic;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>byte CharSet</unmanaged>
        public byte CharSet;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>byte OutputPrecision</unmanaged>
        public byte OutputPrecision;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>byte Quality</unmanaged>
        public byte Quality;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>byte PitchAndFamily</unmanaged>
        public byte PitchAndFamily;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>wchar_t FaceName[32]</unmanaged>
        public string FaceName;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public int Height;
            public int Width;
            public int Weight;
            public int MipLevels;
            public int _Italic;
            public byte CharSet;
            public byte OutputPrecision;
            public byte Quality;
            public byte PitchAndFamily;
            public fixed char FaceName[32];
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Height = @ref.Height;
            this.Width = @ref.Width;
            this.Weight = @ref.Weight;
            this.MipLevels = @ref.MipLevels;
            this._Italic = @ref._Italic;
            this.CharSet = @ref.CharSet;
            this.OutputPrecision = @ref.OutputPrecision;
            this.Quality = @ref.Quality;
            this.PitchAndFamily = @ref.PitchAndFamily;
            fixed (char* __ptr = @ref.FaceName) this.FaceName = new string(__ptr, 0, 32);
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Height = this.Height;
            @ref.Width = this.Width;
            @ref.Weight = this.Weight;
            @ref.MipLevels = this.MipLevels;
            @ref._Italic = this._Italic;
            @ref.CharSet = this.CharSet;
            @ref.OutputPrecision = this.OutputPrecision;
            @ref.Quality = this.Quality;
            @ref.PitchAndFamily = this.PitchAndFamily;
            fixed (char* __psrc = this.FaceName) fixed (char* __ptr = @ref.FaceName) Utilities.CopyMemory((IntPtr)__ptr, (IntPtr)__psrc, FaceName.Length * 2);
		
		}
    }
    
    /// <summary>	
    /// Describes a render surface.	
    /// </summary>	
    /// <unmanaged>D3DXRTS_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct RenderToSurfaceDescription {	
        
        /// <summary>	
        ///  Width of the render surface, in pixels. 	
        /// </summary>	
        /// <unmanaged>int Width</unmanaged>
        public int Width;
        
        /// <summary>	
        ///  Height of the render surface, in pixels. 	
        /// </summary>	
        /// <unmanaged>int Height</unmanaged>
        public int Height;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the pixel format of the render surface. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        ///  If TRUE, the render surface supports a depth-stencil surface; otherwise this member is set to FALSE. 	
        /// </summary>	
        /// <unmanaged>BOOL DepthStencil</unmanaged>
        public bool DepthStencil { 
            get { 
                return (_DepthStencil!=0)?true:false; 
            }
            set { 
                _DepthStencil = value?1:0;
            }
        }
        internal int _DepthStencil;
        
        /// <summary>	
        ///  If DepthStencil is set to TRUE, this parameter is a member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type,  describing the depth-stencil format of the render surface. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT DepthStencilFormat</unmanaged>
        public SlimDX2.Direct3D9.Format DepthStencilFormat;
    }
    
    /// <summary>	
    /// Describes an off-screen render target used by an instance of <see cref="SlimDX2.Direct3D9.RenderToEnvironmentMap"/>.	
    /// </summary>	
    /// <remarks>	
    ///  This method is used to return the creation parameters used when creating an <see cref="SlimDX2.Direct3D9.RenderToEnvironmentMap"/> object. 	
    /// </remarks>	
    /// <unmanaged>D3DXRTE_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct RenderToEnvironmentMapDescription {	
        
        /// <summary>	
        ///  Width and height in pixels. 	
        /// </summary>	
        /// <unmanaged>int Size</unmanaged>
        public int Size;
        
        /// <summary>	
        ///  Maximum level of detail (LOD) number. 	
        /// </summary>	
        /// <unmanaged>int MipLevels</unmanaged>
        public int MipLevels;
        
        /// <summary>	
        ///  Color buffer format. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        ///  Indicates if the z-buffer is needed. 	
        /// </summary>	
        /// <unmanaged>BOOL DepthStencil</unmanaged>
        public bool DepthStencil { 
            get { 
                return (_DepthStencil!=0)?true:false; 
            }
            set { 
                _DepthStencil = value?1:0;
            }
        }
        internal int _DepthStencil;
        
        /// <summary>	
        ///  Format of the depth buffer. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT DepthStencilFormat</unmanaged>
        public SlimDX2.Direct3D9.Format DepthStencilFormat;
    }
    
    /// <summary>	
    /// Stores an attribute table entry.	
    /// </summary>	
    /// <remarks>	
    ///  An attribute table is used to identify areas of the mesh that need to be drawn with different textures, render states, materials, and so on.  In addition, the application can use the attribute table to hide portions of a mesh by not drawing a given attribute identifier (AttribId) when drawing the frame. The LPD3DXATTRIBUTERANGE type is defined as a pointer to the D3DXATTRIBUTERANGE structure.  	
    /// <code> typedef D3DXATTRIBUTERANGE* LPD3DXATTRIBUTERANGE; </code>	
    /// 	
    ///  	
    /// </remarks>	
    /// <unmanaged>D3DXATTRIBUTERANGE</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct AttributeRange {	
        
        /// <summary>	
        ///  Attribute table identifier. 	
        /// </summary>	
        /// <unmanaged>int AttribId</unmanaged>
        public int AttribId;
        
        /// <summary>	
        ///  Starting face. 	
        /// </summary>	
        /// <unmanaged>int FaceStart</unmanaged>
        public int FaceStart;
        
        /// <summary>	
        ///  Face count. 	
        /// </summary>	
        /// <unmanaged>int FaceCount</unmanaged>
        public int FaceCount;
        
        /// <summary>	
        ///  Starting vertex. 	
        /// </summary>	
        /// <unmanaged>int VertexStart</unmanaged>
        public int VertexStart;
        
        /// <summary>	
        ///  Vertex count. 	
        /// </summary>	
        /// <unmanaged>int VertexCount</unmanaged>
        public int VertexCount;
    }
    
    /// <summary>	
    /// Returns material information saved in Direct3D (.x) files.	
    /// </summary>	
    /// <remarks>	
    ///  The {{D3DXLoadMeshFromX}} and <see cref="SlimDX2.Direct3D9.D3DX9.D3DXLoadMeshFromXof"/> functions return an array of D3DXMATERIAL structures  that specify the material color and name of the texture for each material in the mesh. The application is then required to load the texture. The LPD3DXMATERIAL type is defined as a pointer to the D3DXMATERIAL structure.  	
    /// <code> typedef struct D3DXMATERIAL* LPD3DXMATERIAL; </code>	
    /// 	
    ///  	
    /// </remarks>	
    /// <unmanaged>D3DXMATERIAL</unmanaged>
    public  partial struct ExtendedMaterial {	
        
        /// <summary>	
        ///   <see cref="SlimDX2.Direct3D9.Material"/> structure that describes the material properties. 	
        /// </summary>	
        /// <unmanaged>D3DMATERIAL9 MatD3D</unmanaged>
        public SlimDX2.Direct3D9.Material MatD3D;
        
        /// <summary>	
        ///  Pointer to a string that specifies the file name of the texture. 	
        /// </summary>	
        /// <unmanaged>char* pTextureFilename</unmanaged>
        public string PTextureFilename;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public SlimDX2.Direct3D9.Material MatD3D;
            public IntPtr PTextureFilename;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.PTextureFilename != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.PTextureFilename);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.MatD3D = @ref.MatD3D;
            this.PTextureFilename = ( @ref.PTextureFilename == IntPtr.Zero )?null:new string((sbyte*)@ref.PTextureFilename);
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.MatD3D = this.MatD3D;
            @ref.PTextureFilename = ( this.PTextureFilename == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.PTextureFilename);
		
		}
    }
    
    /// <summary>	
    /// Effect default parameters.	
    /// </summary>	
    /// <unmanaged>D3DXEFFECTDEFAULT</unmanaged>
    public  partial struct EffectDefault {	
        
        /// <summary>	
        ///  Parameter name. 	
        /// </summary>	
        /// <unmanaged>char* pParamName</unmanaged>
        public string PParamName;
        
        /// <summary>	
        ///  Data type in pValue. For more information, see <see cref="SlimDX2.Direct3D9.EffectDefaultType"/>  	
        /// </summary>	
        /// <unmanaged>D3DXEFFECTDEFAULTTYPE Type</unmanaged>
        public SlimDX2.Direct3D9.EffectDefaultType Type;
        
        /// <summary>	
        ///  Size, in bytes, of the data pointed to by pValue. 	
        /// </summary>	
        /// <unmanaged>int NumBytes</unmanaged>
        public int NumBytes;
        
        /// <summary>	
        ///  Pointer to the memory location that contains the data. 	
        /// </summary>	
        /// <unmanaged>void* pValue</unmanaged>
        public IntPtr PValue;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr PParamName;
            public SlimDX2.Direct3D9.EffectDefaultType Type;
            public int NumBytes;
            public IntPtr PValue;
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.PParamName = ( @ref.PParamName == IntPtr.Zero )?null:new string((sbyte*)@ref.PParamName);
            this.Type = @ref.Type;
            this.NumBytes = @ref.NumBytes;
            this.PValue = @ref.PValue;
        }
    }
    
    /// <summary>	
    /// Data type for managing a set of default effect parameters.	
    /// </summary>	
    /// <unmanaged>D3DXEFFECTINSTANCE</unmanaged>
    public  partial struct EffectInstance {	
        
        /// <summary>	
        ///  Name of the effect file. 	
        /// </summary>	
        /// <unmanaged>char* pEffectFilename</unmanaged>
        public string PEffectFilename;
        
        /// <summary>	
        ///  Number of default parameters. 	
        /// </summary>	
        /// <unmanaged>int NumDefaults</unmanaged>
        public int NumDefaults;
        
        /// <summary>	
        ///  Pointer to an array of <see cref="SlimDX2.Direct3D9.EffectDefault"/> elements, each of which contains an  effect parameter. 	
        /// </summary>	
        /// <unmanaged>LPD3DXEFFECTDEFAULT pDefaults</unmanaged>
        public IntPtr PDefaults;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr PEffectFilename;
            public int NumDefaults;
            public IntPtr PDefaults;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.PEffectFilename != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.PEffectFilename);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.PEffectFilename = ( @ref.PEffectFilename == IntPtr.Zero )?null:new string((sbyte*)@ref.PEffectFilename);
            this.NumDefaults = @ref.NumDefaults;
            this.PDefaults = @ref.PDefaults;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.PEffectFilename = ( this.PEffectFilename == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.PEffectFilename);
            @ref.NumDefaults = this.NumDefaults;
            @ref.PDefaults = this.PDefaults;
		
		}
    }
    
    /// <summary>	
    /// Specifies mesh weight attributes.	
    /// </summary>	
    /// <remarks>	
    ///  This structure describes how a simplification operation will consider vertex data when calculating relative costs between collapsing edges.  For example, if the Normal field is 0.0, the simplification operation will ignore the vertex normal component when calculating the error for the collapse.  However, if the Normal field is 1.0, the simplification operation will use the vertex normal component. If the Normal field is 2.0, double the amount of errors;  if the Normal field is 4.0, then quadruple the number of errors, and so on. The LPD3DXATTRIBUTEWEIGHTS type is defined as a pointer to the D3DXATTRIBUTEWEIGHTS structure.  	
    /// <code> typedef D3DXATTRIBUTEWEIGHTS* LPD3DXATTRIBUTEWEIGHTS; </code>	
    /// 	
    ///  	
    /// </remarks>	
    /// <unmanaged>D3DXATTRIBUTEWEIGHTS</unmanaged>
    public  partial struct AttributeWeights {	
        
        /// <summary>	
        ///  Position. 	
        /// </summary>	
        /// <unmanaged>float Position</unmanaged>
        public float Position;
        
        /// <summary>	
        ///  Blend weight. 	
        /// </summary>	
        /// <unmanaged>float Boundary</unmanaged>
        public float Boundary;
        
        /// <summary>	
        ///  Normal. 	
        /// </summary>	
        /// <unmanaged>float Normal</unmanaged>
        public float Normal;
        
        /// <summary>	
        ///  Diffuse lighting value. 	
        /// </summary>	
        /// <unmanaged>float Diffuse</unmanaged>
        public float Diffuse;
        
        /// <summary>	
        ///  Specular lighting value. 	
        /// </summary>	
        /// <unmanaged>float Specular</unmanaged>
        public float Specular;
        
        /// <summary>	
        ///  Eight texture coordinates. 	
        /// </summary>	
        /// <unmanaged>float Texcoord[8]</unmanaged>
        public float[] Texcoord { 
            get { 
                if (_Texcoord == null) {
                    _Texcoord = new float[8];
                }
                return _Texcoord; 
            }
        }
        internal float[] _Texcoord;
        
        /// <summary>	
        ///  Tangent. 	
        /// </summary>	
        /// <unmanaged>float Tangent</unmanaged>
        public float Tangent;
        
        /// <summary>	
        ///  Binormal. 	
        /// </summary>	
        /// <unmanaged>float Binormal</unmanaged>
        public float Binormal;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public float Position;
            public float Boundary;
            public float Normal;
            public float Diffuse;
            public float Specular;
            public fixed float Texcoord[8];
            public float Tangent;
            public float Binormal;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Position = @ref.Position;
            this.Boundary = @ref.Boundary;
            this.Normal = @ref.Normal;
            this.Diffuse = @ref.Diffuse;
            this.Specular = @ref.Specular;
            fixed (void* __to = &this.Texcoord[0]) fixed (void* __from = @ref.Texcoord) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 8*sizeof ( float));
            this.Tangent = @ref.Tangent;
            this.Binormal = @ref.Binormal;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Position = this.Position;
            @ref.Boundary = this.Boundary;
            @ref.Normal = this.Normal;
            @ref.Diffuse = this.Diffuse;
            @ref.Specular = this.Specular;
            fixed (void* __to = @ref.Texcoord) fixed (void* __from = &this.Texcoord[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 8*sizeof ( float));
            @ref.Tangent = this.Tangent;
            @ref.Binormal = this.Binormal;
		
		}
    }
    
    /// <summary>	
    /// Specifies tolerance values for each vertex component when comparing vertices to determine if they are similar enough to be welded together.	
    /// </summary>	
    /// <remarks>	
    ///  The LPD3DXWeldEpsilons type is defined as a pointer to the D3DXWeldEpsilons structure. 	
    /// <code> typedef D3DXWELDEPSILONS *LPD3DXWELDEPSILONS; </code>	
    /// 	
    ///  	
    /// </remarks>	
    /// <unmanaged>D3DXWELDEPSILONS</unmanaged>
    public  partial struct WeldEpsilons {	
        
        /// <summary>	
        ///  Position 	
        /// </summary>	
        /// <unmanaged>float Position</unmanaged>
        public float Position;
        
        /// <summary>	
        ///  Blend weight 	
        /// </summary>	
        /// <unmanaged>float BlendWeights</unmanaged>
        public float BlendWeights;
        
        /// <summary>	
        ///  Normal 	
        /// </summary>	
        /// <unmanaged>float Normal</unmanaged>
        public float Normal;
        
        /// <summary>	
        ///  Point size value 	
        /// </summary>	
        /// <unmanaged>float PSize</unmanaged>
        public float PSize;
        
        /// <summary>	
        ///  Specular lighting value 	
        /// </summary>	
        /// <unmanaged>float Specular</unmanaged>
        public float Specular;
        
        /// <summary>	
        ///  Diffuse lighting value 	
        /// </summary>	
        /// <unmanaged>float Diffuse</unmanaged>
        public float Diffuse;
        
        /// <summary>	
        ///  Eight texture coordinates 	
        /// </summary>	
        /// <unmanaged>float Texcoord[8]</unmanaged>
        public float[] Texcoord { 
            get { 
                if (_Texcoord == null) {
                    _Texcoord = new float[8];
                }
                return _Texcoord; 
            }
        }
        internal float[] _Texcoord;
        
        /// <summary>	
        ///  Tangent 	
        /// </summary>	
        /// <unmanaged>float Tangent</unmanaged>
        public float Tangent;
        
        /// <summary>	
        ///  Binormal 	
        /// </summary>	
        /// <unmanaged>float Binormal</unmanaged>
        public float Binormal;
        
        /// <summary>	
        ///  Tessellation factor 	
        /// </summary>	
        /// <unmanaged>float TessFactor</unmanaged>
        public float TessFactor;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public float Position;
            public float BlendWeights;
            public float Normal;
            public float PSize;
            public float Specular;
            public float Diffuse;
            public fixed float Texcoord[8];
            public float Tangent;
            public float Binormal;
            public float TessFactor;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Position = @ref.Position;
            this.BlendWeights = @ref.BlendWeights;
            this.Normal = @ref.Normal;
            this.PSize = @ref.PSize;
            this.Specular = @ref.Specular;
            this.Diffuse = @ref.Diffuse;
            fixed (void* __to = &this.Texcoord[0]) fixed (void* __from = @ref.Texcoord) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 8*sizeof ( float));
            this.Tangent = @ref.Tangent;
            this.Binormal = @ref.Binormal;
            this.TessFactor = @ref.TessFactor;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Position = this.Position;
            @ref.BlendWeights = this.BlendWeights;
            @ref.Normal = this.Normal;
            @ref.PSize = this.PSize;
            @ref.Specular = this.Specular;
            @ref.Diffuse = this.Diffuse;
            fixed (void* __to = @ref.Texcoord) fixed (void* __from = &this.Texcoord[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 8*sizeof ( float));
            @ref.Tangent = this.Tangent;
            @ref.Binormal = this.Binormal;
            @ref.TessFactor = this.TessFactor;
		
		}
    }
    
    /// <summary>	
    /// Describes a subset of the mesh that has the same attribute and bone combination.	
    /// </summary>	
    /// <remarks>	
    ///  The subset of the mesh described by D3DXBONECOMBINATION can be rendered in a single drawing call. 	
    /// </remarks>	
    /// <unmanaged>D3DXBONECOMBINATION</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct BoneCombination {	
        
        /// <summary>	
        ///  Attribute table identifier. 	
        /// </summary>	
        /// <unmanaged>int AttribId</unmanaged>
        public int AttribId;
        
        /// <summary>	
        ///  Starting face. 	
        /// </summary>	
        /// <unmanaged>int FaceStart</unmanaged>
        public int FaceStart;
        
        /// <summary>	
        ///  Face count. 	
        /// </summary>	
        /// <unmanaged>int FaceCount</unmanaged>
        public int FaceCount;
        
        /// <summary>	
        ///  Starting vertex. 	
        /// </summary>	
        /// <unmanaged>int VertexStart</unmanaged>
        public int VertexStart;
        
        /// <summary>	
        ///  Vertex count. 	
        /// </summary>	
        /// <unmanaged>int VertexCount</unmanaged>
        public int VertexCount;
        
        /// <summary>	
        ///  Pointer to an array of values that identify each of the bones that can be drawn in a single drawing call.  Note that the array can be of variable length to accommodate variable length bone combinations of {{ConvertToIndexedBlendedMesh}}.   The size of the array varies based on the type of mesh generated. A non-indexed mesh array size is equal to the number of weights per  vertex (pMaxVertexInfl in {{ConvertToBlendedMesh}}). An indexed mesh array size is equal to the number of bone matrix  palette entries (paletteSize in {{ConvertToIndexedBlendedMesh}}). 	
        /// </summary>	
        /// <unmanaged>int* BoneId</unmanaged>
        public IntPtr BoneId;
    }
    
    /// <summary>	
    /// Structure that contains the attributes of a patch mesh.	
    /// </summary>	
    /// <remarks>	
    ///  A mesh is a set of faces, each of which is described by a simple polygon. Objects can be created by connecting several meshes together.  A patch mesh is constructed from patches. A patch is a four-sided piece of geometry constructed from curves.  The type of curve used and the order of the curve can be varied so that the patch surface will fit almost any surface shape. The following types of patch combinations are supported:  Patch TypeBasisDegree RectangleBezier2,3,5 RectangleB-Spline2,3,5 RectangleCatmull-Rom3 TriangleBezier2,3,5 N-patchN/A3  ? 	
    /// </remarks>	
    /// <unmanaged>D3DXPATCHINFO</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct PatchInfo {	
        
        /// <summary>	
        ///  The patch type. For information about patch types, see <see cref="SlimDX2.Direct3D9.PatchMeshType"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXPATCHMESHTYPE PatchType</unmanaged>
        public SlimDX2.Direct3D9.PatchMeshType PatchType;
        
        /// <summary>	
        ///  Degree of the curves used to construct the patch. For information about the degrees supported, see <see cref="SlimDX2.Direct3D9.Degree"/>. 	
        /// </summary>	
        /// <unmanaged>D3DDEGREETYPE Degree</unmanaged>
        public SlimDX2.Direct3D9.Degree Degree;
        
        /// <summary>	
        ///  Type of curve used to construct the patch. For information about the basis types supported, see <see cref="SlimDX2.Direct3D9.Basis"/>. 	
        /// </summary>	
        /// <unmanaged>D3DBASISTYPE Basis</unmanaged>
        public SlimDX2.Direct3D9.Basis Basis;
    }
    
    /// <summary>	
    /// Identifies compressed key frame animation data.	
    /// </summary>	
    /// <unmanaged>XFILECOMPRESSEDANIMATIONSET</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 1 )]
    public  partial struct Xfilecompressedanimationset {	
    }
    
    /// <summary>	
    /// Describes preprocessor definitions used by an effect object.	
    /// </summary>	
    /// <remarks>	
    ///  To use D3DXMACROs in more than one line, prefix each new line character with a backslash (like a #define in the C language). For example: 	
    /// <code> sample=	
    /// macro.Name = "DO_CODE_BLOCK";	
    /// macro.Definition = "/* here is a block of code */\\\n" "{ do something ... }\\\n"; </code>	
    /// 	
    ///  Notice the 3 backslash characters at the end of the line. The first two are required to output a single '\', followed by the newline character "\n". Optionally, you may also want to terminate your lines using "\\\r\n". 	
    /// </remarks>	
    /// <unmanaged>D3DXMACRO</unmanaged>
    public  partial struct Macro {	
        
        /// <summary>	
        ///  Preprocessor name. 	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        ///  Definition name. 	
        /// </summary>	
        /// <unmanaged>const char* Definition</unmanaged>
        public string Definition;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public IntPtr Definition;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
                if (this.Definition != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Definition);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.Definition = ( @ref.Definition == IntPtr.Zero )?null:new string((sbyte*)@ref.Definition);
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.Definition = ( this.Definition == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Definition);
		
		}
    }
    
    /// <summary>	
    /// Semantics map a parameter to vertex or pixel shader registers. They can also be optional descriptive strings attached to non-register parameters.  	
    /// </summary>	
    /// <remarks>	
    ///  Semantics are required for vertex and pixel shader, input and output registers. 	
    /// </remarks>	
    /// <unmanaged>D3DXSEMANTIC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ShaderSemantic {	
        
        /// <summary>	
        ///  Options that identify how resources are used. See <see cref="SlimDX2.Direct3D9.DeclarationUsage"/>. 	
        /// </summary>	
        /// <unmanaged>int Usage</unmanaged>
        public int Usage;
        
        /// <summary>	
        ///  Options that modify how the usage is interpreted. The usage and usage index make up a vertex declaration. See {{Vertex Declaration (Direct3D 9)}}. 	
        /// </summary>	
        /// <unmanaged>int UsageIndex</unmanaged>
        public int UsageIndex;
    }
    
    /// <summary>	
    /// A description of the constant table.	
    /// </summary>	
    /// <unmanaged>D3DXCONSTANTTABLE_DESC</unmanaged>
    public  partial struct ConstantTableDescription {	
        
        /// <summary>	
        ///  Name of the constant table creator. 	
        /// </summary>	
        /// <unmanaged>const char* Creator</unmanaged>
        public string Creator;
        
        /// <summary>	
        ///  Shader version. 	
        /// </summary>	
        /// <unmanaged>int Version</unmanaged>
        public int Version;
        
        /// <summary>	
        ///  Number of constants in the constant table. 	
        /// </summary>	
        /// <unmanaged>int Constants</unmanaged>
        public int Constants;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Creator;
            public int Version;
            public int Constants;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Creator != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Creator);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Creator = ( @ref.Creator == IntPtr.Zero )?null:new string((sbyte*)@ref.Creator);
            this.Version = @ref.Version;
            this.Constants = @ref.Constants;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Creator = ( this.Creator == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Creator);
            @ref.Version = this.Version;
            @ref.Constants = this.Constants;
		
		}
    }
    
    /// <summary>	
    /// A description of a constant in a constant table.	
    /// </summary>	
    /// <unmanaged>D3DXCONSTANT_DESC</unmanaged>
    public  partial struct ConstantDescription {	
        
        /// <summary>	
        ///  Name of the constant. 	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        ///  Constant data type. See <see cref="SlimDX2.Direct3D9.RegisterSet"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXREGISTER_SET RegisterSet</unmanaged>
        public SlimDX2.Direct3D9.RegisterSet RegisterSet;
        
        /// <summary>	
        ///  Zero-based index of the constant in the table. 	
        /// </summary>	
        /// <unmanaged>int RegisterIndex</unmanaged>
        public int RegisterIndex;
        
        /// <summary>	
        ///  Number of registers that contain data. 	
        /// </summary>	
        /// <unmanaged>int RegisterCount</unmanaged>
        public int RegisterCount;
        
        /// <summary>	
        ///  Parameter class. See <see cref="SlimDX2.Direct3D9.ParameterClass"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXPARAMETER_CLASS Class</unmanaged>
        public SlimDX2.Direct3D9.ParameterClass Class;
        
        /// <summary>	
        ///  Parameter type. See <see cref="SlimDX2.Direct3D9.ParameterType"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXPARAMETER_TYPE Type</unmanaged>
        public SlimDX2.Direct3D9.ParameterType Type;
        
        /// <summary>	
        ///  Number of rows. 	
        /// </summary>	
        /// <unmanaged>int Rows</unmanaged>
        public int Rows;
        
        /// <summary>	
        ///  Number of columns. 	
        /// </summary>	
        /// <unmanaged>int Columns</unmanaged>
        public int Columns;
        
        /// <summary>	
        ///  Number of elements in the array. 	
        /// </summary>	
        /// <unmanaged>int Elements</unmanaged>
        public int Elements;
        
        /// <summary>	
        ///  Number of structure member sub-parameters. 	
        /// </summary>	
        /// <unmanaged>int StructMembers</unmanaged>
        public int StructMembers;
        
        /// <summary>	
        ///  Data size in number of bytes. 	
        /// </summary>	
        /// <unmanaged>int Bytes</unmanaged>
        public int Bytes;
        
        /// <summary>	
        ///  Pointer to the default value. 	
        /// </summary>	
        /// <unmanaged>const void* DefaultValue</unmanaged>
        public IntPtr DefaultValue;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public SlimDX2.Direct3D9.RegisterSet RegisterSet;
            public int RegisterIndex;
            public int RegisterCount;
            public SlimDX2.Direct3D9.ParameterClass Class;
            public SlimDX2.Direct3D9.ParameterType Type;
            public int Rows;
            public int Columns;
            public int Elements;
            public int StructMembers;
            public int Bytes;
            public IntPtr DefaultValue;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.RegisterSet = @ref.RegisterSet;
            this.RegisterIndex = @ref.RegisterIndex;
            this.RegisterCount = @ref.RegisterCount;
            this.Class = @ref.Class;
            this.Type = @ref.Type;
            this.Rows = @ref.Rows;
            this.Columns = @ref.Columns;
            this.Elements = @ref.Elements;
            this.StructMembers = @ref.StructMembers;
            this.Bytes = @ref.Bytes;
            this.DefaultValue = @ref.DefaultValue;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.RegisterSet = this.RegisterSet;
            @ref.RegisterIndex = this.RegisterIndex;
            @ref.RegisterCount = this.RegisterCount;
            @ref.Class = this.Class;
            @ref.Type = this.Type;
            @ref.Rows = this.Rows;
            @ref.Columns = this.Columns;
            @ref.Elements = this.Elements;
            @ref.StructMembers = this.StructMembers;
            @ref.Bytes = this.Bytes;
            @ref.DefaultValue = this.DefaultValue;
		
		}
    }
    
    /// <summary>	
    /// Helper structure for managing a shader constant table. This can also be done using <see cref="SlimDX2.Direct3D9.ID3DXConstantTable"/>.	
    /// </summary>	
    /// <remarks>	
    ///  Shader constant information is included in a tab-delimited table of comments.  All offsets are measured in bytes from the beginning of the structure.  Entries in the constant table are sorted by Creator in ascending order. A shader constant table can be managed with the <see cref="SlimDX2.Direct3D9.ID3DXConstantTable"/> interfaces.  Alternatively, you can manage the constant table with D3DXSHADER_CONSTANTTABLE. This size member is often initialized using the following: 	
    /// <code> D3DXSHADER_CONSTANTTABLE constantTable;	
    /// constantTable.Size = sizeof(D3DXSHADER_CONSTANTTABLE) </code>	
    /// 	
    ///  	
    /// </remarks>	
    /// <unmanaged>D3DXSHADER_CONSTANTTABLE</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ShaderConstanttable {	
        
        /// <summary>	
        ///  Size of the structure. See Remarks. 	
        /// </summary>	
        /// <unmanaged>int Size</unmanaged>
        public int Size;
        
        /// <summary>	
        ///  Offset from the beginning of this structure, in bytes, to the string that contains the name of the creator. 	
        /// </summary>	
        /// <unmanaged>int Creator</unmanaged>
        public int Creator;
        
        /// <summary>	
        ///  Shader version. 	
        /// </summary>	
        /// <unmanaged>int Version</unmanaged>
        public int Version;
        
        /// <summary>	
        ///  Number of constants. 	
        /// </summary>	
        /// <unmanaged>int Constants</unmanaged>
        public int Constants;
        
        /// <summary>	
        ///  Array of constant information, D3DXSHADER_CONSTANTINFO[Constants]. See <see cref="SlimDX2.Direct3D9.ShaderConstantinfo"/>. 	
        /// </summary>	
        /// <unmanaged>int ConstantInfo</unmanaged>
        public int ConstantInfo;
        
        /// <summary>	
        ///  The {{D3DXSHADER Flags}} flags used to compile the shader. 	
        /// </summary>	
        /// <unmanaged>int Flags</unmanaged>
        public int Flags;
        
        /// <summary>	
        ///  Offset into the string that contains the target. 	
        /// </summary>	
        /// <unmanaged>int Target</unmanaged>
        public int Target;
    }
    
    /// <summary>	
    /// 	
    /// <code> typedef struct D3DXSHADER_CONSTANTINFO { DWORD Name; WORD  RegisterSet; WORD  RegisterIndex; WORD  RegisterCount; WORD  Reserved; DWORD TypeInfo; DWORD DefaultValue;	
    /// } D3DXSHADER_CONSTANTINFO, *LPD3DXSHADER_CONSTANTINFO;	
    /// </code>	
    /// 	
    /// </summary>	
    /// <unmanaged>D3DXSHADER_CONSTANTINFO</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ShaderConstantinfo {	
        
        /// <summary>	
        ///  Offset from the beginning of this structure, in bytes, to the string that contains the constant information. 	
        /// </summary>	
        /// <unmanaged>int Name</unmanaged>
        public int Name;
        
        /// <summary>	
        ///  Register set. See <see cref="SlimDX2.Direct3D9.RegisterSet"/>. 	
        /// </summary>	
        /// <unmanaged>short RegisterSet</unmanaged>
        public short RegisterSet;
        
        /// <summary>	
        ///  The register index. 	
        /// </summary>	
        /// <unmanaged>short RegisterIndex</unmanaged>
        public short RegisterIndex;
        
        /// <summary>	
        ///  Number of registers. 	
        /// </summary>	
        /// <unmanaged>short RegisterCount</unmanaged>
        public short RegisterCount;
        
        /// <summary>	
        ///  Reserved. 	
        /// </summary>	
        /// <unmanaged>short Reserved</unmanaged>
        public short Reserved;
        
        /// <summary>	
        ///  Offset from the beginning of this structure, in bytes, to the string that contains the {{D3DXSHADER_TYPEINFO}} information. 	
        /// </summary>	
        /// <unmanaged>int TypeInfo</unmanaged>
        public int TypeInfo;
        
        /// <summary>	
        ///  Offset from the beginning of this structure, in bytes, to the string that contains the default value. 	
        /// </summary>	
        /// <unmanaged>int DefaultValue</unmanaged>
        public int DefaultValue;
    }
    
    /// <summary>	
    /// Describes an effect object.	
    /// </summary>	
    /// <remarks>	
    ///  An effect object can contain multiple rendering techniques and parameters for the same effect. 	
    /// </remarks>	
    /// <unmanaged>D3DXEFFECT_DESC</unmanaged>
    public  partial struct EffectDescription {	
        
        /// <summary>	
        ///  String that contains the name of the effect creator. 	
        /// </summary>	
        /// <unmanaged>const char* Creator</unmanaged>
        public string Creator;
        
        /// <summary>	
        ///  Number of parameters used for effect. 	
        /// </summary>	
        /// <unmanaged>int Parameters</unmanaged>
        public int Parameters;
        
        /// <summary>	
        ///  Number of techniques that can render the effect. 	
        /// </summary>	
        /// <unmanaged>int Techniques</unmanaged>
        public int Techniques;
        
        /// <summary>	
        ///  Number of functions that can render the effect. 	
        /// </summary>	
        /// <unmanaged>int Functions</unmanaged>
        public int Functions;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Creator;
            public int Parameters;
            public int Techniques;
            public int Functions;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Creator != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Creator);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Creator = ( @ref.Creator == IntPtr.Zero )?null:new string((sbyte*)@ref.Creator);
            this.Parameters = @ref.Parameters;
            this.Techniques = @ref.Techniques;
            this.Functions = @ref.Functions;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Creator = ( this.Creator == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Creator);
            @ref.Parameters = this.Parameters;
            @ref.Techniques = this.Techniques;
            @ref.Functions = this.Functions;
		
		}
    }
    
    /// <summary>	
    /// Describes a parameter used for an effect object.	
    /// </summary>	
    /// <unmanaged>D3DXPARAMETER_DESC</unmanaged>
    public  partial struct ParameterDescription {	
        
        /// <summary>	
        ///  Name of the parameter. 	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        ///  Semantic meaning, also called the usage. 	
        /// </summary>	
        /// <unmanaged>const char* Semantic</unmanaged>
        public string Semantic;
        
        /// <summary>	
        ///  Parameter class. Set this to one of the values in <see cref="SlimDX2.Direct3D9.ParameterClass"/>.  	
        /// </summary>	
        /// <unmanaged>D3DXPARAMETER_CLASS Class</unmanaged>
        public SlimDX2.Direct3D9.ParameterClass Class;
        
        /// <summary>	
        ///  Parameter type. Set this to one of the values in <see cref="SlimDX2.Direct3D9.ParameterType"/>.  	
        /// </summary>	
        /// <unmanaged>D3DXPARAMETER_TYPE Type</unmanaged>
        public SlimDX2.Direct3D9.ParameterType Type;
        
        /// <summary>	
        ///  Number of rows in the array. 	
        /// </summary>	
        /// <unmanaged>int Rows</unmanaged>
        public int Rows;
        
        /// <summary>	
        ///  Number of columns in the array. 	
        /// </summary>	
        /// <unmanaged>int Columns</unmanaged>
        public int Columns;
        
        /// <summary>	
        ///  Number of elements in the array. 	
        /// </summary>	
        /// <unmanaged>int Elements</unmanaged>
        public int Elements;
        
        /// <summary>	
        ///  Number of annotations. 	
        /// </summary>	
        /// <unmanaged>int Annotations</unmanaged>
        public int Annotations;
        
        /// <summary>	
        ///  Number of structure members. 	
        /// </summary>	
        /// <unmanaged>int StructMembers</unmanaged>
        public int StructMembers;
        
        /// <summary>	
        ///  Parameter attributes. See {{Effect Constants}}. 	
        /// </summary>	
        /// <unmanaged>int Flags</unmanaged>
        public int Flags;
        
        /// <summary>	
        ///  The size of the parameter, in bytes.  	
        /// </summary>	
        /// <unmanaged>int Bytes</unmanaged>
        public int Bytes;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public IntPtr Semantic;
            public SlimDX2.Direct3D9.ParameterClass Class;
            public SlimDX2.Direct3D9.ParameterType Type;
            public int Rows;
            public int Columns;
            public int Elements;
            public int Annotations;
            public int StructMembers;
            public int Flags;
            public int Bytes;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
                if (this.Semantic != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Semantic);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.Semantic = ( @ref.Semantic == IntPtr.Zero )?null:new string((sbyte*)@ref.Semantic);
            this.Class = @ref.Class;
            this.Type = @ref.Type;
            this.Rows = @ref.Rows;
            this.Columns = @ref.Columns;
            this.Elements = @ref.Elements;
            this.Annotations = @ref.Annotations;
            this.StructMembers = @ref.StructMembers;
            this.Flags = @ref.Flags;
            this.Bytes = @ref.Bytes;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.Semantic = ( this.Semantic == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Semantic);
            @ref.Class = this.Class;
            @ref.Type = this.Type;
            @ref.Rows = this.Rows;
            @ref.Columns = this.Columns;
            @ref.Elements = this.Elements;
            @ref.Annotations = this.Annotations;
            @ref.StructMembers = this.StructMembers;
            @ref.Flags = this.Flags;
            @ref.Bytes = this.Bytes;
		
		}
    }
    
    /// <summary>	
    /// Describes a technique used by an effect.	
    /// </summary>	
    /// <remarks>	
    ///  Some video cards can render two textures in a single pass. However, if a card does not have this capability, it is often possible to render the same effect in two passes, using one texture for each pass. 	
    /// </remarks>	
    /// <unmanaged>D3DXTECHNIQUE_DESC</unmanaged>
    public  partial struct TechniqueDescription {	
        
        /// <summary>	
        ///  String that contains the technique name. 	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        ///  Number of rendering passes the technique requires. See Remarks. 	
        /// </summary>	
        /// <unmanaged>int Passes</unmanaged>
        public int Passes;
        
        /// <summary>	
        ///  The number of annotations. See {{Add Information to Effect Parameters with_Annotations}}. 	
        /// </summary>	
        /// <unmanaged>int Annotations</unmanaged>
        public int Annotations;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public int Passes;
            public int Annotations;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.Passes = @ref.Passes;
            this.Annotations = @ref.Annotations;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.Passes = this.Passes;
            @ref.Annotations = this.Annotations;
		
		}
    }
    
    /// <summary>	
    /// Describes a pass for an effect object.	
    /// </summary>	
    /// <unmanaged>D3DXPASS_DESC</unmanaged>
    public  partial struct PassDescription {	
        
        /// <summary>	
        ///  String value used for the pass. 	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        ///  Annotations are user-specific data that can be attached to any technique, pass, or parameter. See {{Add Information to Effect Parameters with_Annotations}}. 	
        /// </summary>	
        /// <unmanaged>int Annotations</unmanaged>
        public int Annotations;
        
        /// <summary>	
        ///  Pointer to the vertex shader function. If an effect is created with {{D3DXFX_NOT_CLONEABLE}}, this structure will return a NULL pointer when called by {{GetPassDesc}}. 	
        /// </summary>	
        /// <unmanaged>const int* pVertexShaderFunction</unmanaged>
        public IntPtr PVertexShaderFunction;
        
        /// <summary>	
        ///  Pointer to the pixel shader function. If an effect is created with {{D3DXFX_NOT_CLONEABLE}}, this structure will return a NULL pointer when called by {{GetPassDesc}}. 	
        /// </summary>	
        /// <unmanaged>const int* pPixelShaderFunction</unmanaged>
        public IntPtr PPixelShaderFunction;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public int Annotations;
            public IntPtr PVertexShaderFunction;
            public IntPtr PPixelShaderFunction;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.Annotations = @ref.Annotations;
            this.PVertexShaderFunction = @ref.PVertexShaderFunction;
            this.PPixelShaderFunction = @ref.PPixelShaderFunction;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.Annotations = this.Annotations;
            @ref.PVertexShaderFunction = this.PVertexShaderFunction;
            @ref.PPixelShaderFunction = this.PPixelShaderFunction;
		
		}
    }
    
    /// <summary>	
    /// Describes a function used by an effect.	
    /// </summary>	
    /// <unmanaged>D3DXFUNCTION_DESC</unmanaged>
    public  partial struct FunctionDescription {	
        
        /// <summary>	
        ///  Function name. 	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        ///  Unused. This member will always be set to zero by {{GetFunctionDesc}}.  	
        /// </summary>	
        /// <unmanaged>int Annotations</unmanaged>
        public int Annotations;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public int Annotations;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.Annotations = @ref.Annotations;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.Annotations = this.Annotations;
		
		}
    }
    
    /// <summary>	
    /// Returns a description of the original contents of an image file.	
    /// </summary>	
    /// <unmanaged>D3DXIMAGE_INFO</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ImageInformation {	
        
        /// <summary>	
        ///  Width of original image in pixels. 	
        /// </summary>	
        /// <unmanaged>int Width</unmanaged>
        public int Width;
        
        /// <summary>	
        ///  Height of original image in pixels. 	
        /// </summary>	
        /// <unmanaged>int Height</unmanaged>
        public int Height;
        
        /// <summary>	
        ///  Depth of original image in pixels. 	
        /// </summary>	
        /// <unmanaged>int Depth</unmanaged>
        public int Depth;
        
        /// <summary>	
        ///  Number of mip levels in original image. 	
        /// </summary>	
        /// <unmanaged>int MipLevels</unmanaged>
        public int MipLevels;
        
        /// <summary>	
        ///  A value from the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type that most closely describes the data in the original image. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        ///  Represents the type of the texture stored in the file. It is either D3DRTYPE_TEXTURE, D3DRTYPE_VOLUMETEXTURE, or D3DRTYPE_CubeTexture. 	
        /// </summary>	
        /// <unmanaged>D3DRESOURCETYPE ResourceType</unmanaged>
        public SlimDX2.Direct3D9.ResourceType ResourceType;
        
        /// <summary>	
        ///  Represents the format of the image file. 	
        /// </summary>	
        /// <unmanaged>D3DXIMAGE_FILEFORMAT ImageFileFormat</unmanaged>
        public SlimDX2.Direct3D9.ImageFileFormat ImageFileFormat;
    }
    
    /// <summary>	
    /// Mesh data structure.	
    /// </summary>	
    /// <unmanaged>D3DXMESHDATA</unmanaged>
    [StructLayout(LayoutKind.Explicit, Pack = 0 )]
    public  partial struct MeshData {	
        
        /// <summary>	
        ///  Defines the mesh data type. See <see cref="SlimDX2.Direct3D9.MeshDataType"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHDATATYPE Type</unmanaged>
        [FieldOffset(0)]
        public SlimDX2.Direct3D9.MeshDataType Type;
        
        /// <summary>	
        ///  Pointer to a mesh. See <see cref="SlimDX2.Direct3D9.ID3DXMesh"/>. 	
        /// </summary>	
        /// <unmanaged>LPD3DXMESH pMesh</unmanaged>
        [FieldOffset(4)]
        public IntPtr PMesh;
        
        /// <summary>	
        ///  Pointer to a patch mesh. See <see cref="SlimDX2.Direct3D9.ID3DXPatchMesh"/>. 	
        /// </summary>	
        /// <unmanaged>LPD3DXPMESH pPMesh</unmanaged>
        [FieldOffset(4)]
        public IntPtr PPMesh;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>LPD3DXPATCHMESH pPatchMesh</unmanaged>
        [FieldOffset(4)]
        public IntPtr PPatchMesh;
    }
    
    /// <summary>	
    /// Encapsulates a mesh object in a transformation frame hierarchy.	
    /// </summary>	
    /// <remarks>	
    ///  An application can derive from this structure to add other data. 	
    /// </remarks>	
    /// <unmanaged>D3DXMESHCONTAINER</unmanaged>
    public  partial struct MeshContainer {	
        
        /// <summary>	
        ///  Mesh name. 	
        /// </summary>	
        /// <unmanaged>char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        ///  Type of data in the mesh. See <see cref="SlimDX2.Direct3D9.MeshData"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHDATA MeshData</unmanaged>
        public SlimDX2.Direct3D9.MeshData MeshData;
        
        /// <summary>	
        ///  Array of mesh materials. See <see cref="SlimDX2.Direct3D9.ExtendedMaterial"/>. 	
        /// </summary>	
        /// <unmanaged>LPD3DXMATERIAL pMaterials</unmanaged>
        public IntPtr PMaterials;
        
        /// <summary>	
        ///  Pointer to a set of default effect parameters. See <see cref="SlimDX2.Direct3D9.EffectInstance"/>. 	
        /// </summary>	
        /// <unmanaged>LPD3DXEFFECTINSTANCE pEffects</unmanaged>
        public IntPtr PEffects;
        
        /// <summary>	
        ///  Number of materials in the mesh. 	
        /// </summary>	
        /// <unmanaged>int NumMaterials</unmanaged>
        public int NumMaterials;
        
        /// <summary>	
        ///  Pointer to an array of three DWORDs per triangle of the mesh that contains adjacency information. 	
        /// </summary>	
        /// <unmanaged>int* pAdjacency</unmanaged>
        public IntPtr PAdjacency;
        
        /// <summary>	
        ///  Pointer to the skin information interface. See <see cref="SlimDX2.Direct3D9.ID3DXSkinInfo"/>. 	
        /// </summary>	
        /// <unmanaged>LPD3DXSKININFO pSkinInfo</unmanaged>
        public IntPtr PSkinInfo;
        
        /// <summary>	
        ///  Pointer to the next mesh container. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHCONTAINER* pNextMeshContainer</unmanaged>
        public IntPtr PNextMeshContainer;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public SlimDX2.Direct3D9.MeshData MeshData;
            public IntPtr PMaterials;
            public IntPtr PEffects;
            public int NumMaterials;
            public IntPtr PAdjacency;
            public IntPtr PSkinInfo;
            public IntPtr PNextMeshContainer;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.MeshData = @ref.MeshData;
            this.PMaterials = @ref.PMaterials;
            this.PEffects = @ref.PEffects;
            this.NumMaterials = @ref.NumMaterials;
            this.PAdjacency = @ref.PAdjacency;
            this.PSkinInfo = @ref.PSkinInfo;
            this.PNextMeshContainer = @ref.PNextMeshContainer;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.MeshData = this.MeshData;
            @ref.PMaterials = this.PMaterials;
            @ref.PEffects = this.PEffects;
            @ref.NumMaterials = this.NumMaterials;
            @ref.PAdjacency = this.PAdjacency;
            @ref.PSkinInfo = this.PSkinInfo;
            @ref.PNextMeshContainer = this.PNextMeshContainer;
		
		}
    }
    
    /// <summary>	
    /// Encapsulates a transform frame in a transformation frame hierarchy.	
    /// </summary>	
    /// <remarks>	
    ///  An application can derive from this structure to add other data. 	
    /// </remarks>	
    /// <unmanaged>D3DXFRAME</unmanaged>
    public  partial struct Frame {	
        
        /// <summary>	
        ///  Name of the frame. 	
        /// </summary>	
        /// <unmanaged>char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        ///  Transformation matrix. 	
        /// </summary>	
        /// <unmanaged>D3DXMATRIX TransformationMatrix</unmanaged>
        public SlimMath.Matrix TransformationMatrix;
        
        /// <summary>	
        ///  Pointer to the mesh container. 	
        /// </summary>	
        /// <unmanaged>LPD3DXMESHCONTAINER pMeshContainer</unmanaged>
        public IntPtr PMeshContainer;
        
        /// <summary>	
        ///  Pointer to a sibling frame. 	
        /// </summary>	
        /// <unmanaged>D3DXFRAME* pFrameSibling</unmanaged>
        public IntPtr PFrameSibling;
        
        /// <summary>	
        ///  Pointer to a child frame. 	
        /// </summary>	
        /// <unmanaged>D3DXFRAME* pFrameFirstChild</unmanaged>
        public IntPtr PFrameFirstChild;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public SlimMath.Matrix TransformationMatrix;
            public IntPtr PMeshContainer;
            public IntPtr PFrameSibling;
            public IntPtr PFrameFirstChild;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.TransformationMatrix = @ref.TransformationMatrix;
            this.PMeshContainer = @ref.PMeshContainer;
            this.PFrameSibling = @ref.PFrameSibling;
            this.PFrameFirstChild = @ref.PFrameFirstChild;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.TransformationMatrix = this.TransformationMatrix;
            @ref.PMeshContainer = this.PMeshContainer;
            @ref.PFrameSibling = this.PFrameSibling;
            @ref.PFrameFirstChild = this.PFrameFirstChild;
		
		}
    }
    
    /// <summary>	
    /// Describes a vector key for use in key frame animation. It specifies a vector at a given time. This is used for scale and translation keys.	
    /// </summary>	
    /// <unmanaged>D3DXKEY_VECTOR3</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ScaleKey {	
        
        /// <summary>	
        ///  Key frame time stamp. 	
        /// </summary>	
        /// <unmanaged>float Time</unmanaged>
        public float Time;
        
        /// <summary>	
        ///   <see cref="SlimMath.Vector3"/> 3D vector that supplies scale and/or translation values. 	
        /// </summary>	
        /// <unmanaged>D3DXVECTOR3 Value</unmanaged>
        public SlimMath.Vector3 Value;
    }
    
    /// <summary>	
    /// Describes a quaternion key for use in key frame animation. A quaternion key is a quaternion value at a given time.	
    /// </summary>	
    /// <unmanaged>D3DXKEY_QUATERNION</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct RotationKey {	
        
        /// <summary>	
        ///  Time value. 	
        /// </summary>	
        /// <unmanaged>float Time</unmanaged>
        public float Time;
        
        /// <summary>	
        ///   <see cref="SlimMath.Quaternion"/> quaternion that supplies rotation values. 	
        /// </summary>	
        /// <unmanaged>D3DXQUATERNION Value</unmanaged>
        public SlimMath.Quaternion Value;
    }
    
    /// <summary>	
    /// Describes a callback key for use in key frame animation.	
    /// </summary>	
    /// <unmanaged>D3DXKEY_CALLBACK</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct CallbackKey {	
        
        /// <summary>	
        ///  Key frame time stamp. 	
        /// </summary>	
        /// <unmanaged>float Time</unmanaged>
        public float Time;
        
        /// <summary>	
        ///  Pointer to user callback data. 	
        /// </summary>	
        /// <unmanaged>void* pCallbackData</unmanaged>
        public IntPtr PCallbackData;
    }
    
    /// <summary>	
    /// Describes an animation track and specifies blending weight, speed, and position for the track at a given time.	
    /// </summary>	
    /// <remarks>	
    ///  Tracks with the same priority are blended together, and the two resulting values are then blended using the priority blend factor.  A track must have an animation set (stored separately) associated with it. 	
    /// </remarks>	
    /// <unmanaged>D3DXTRACK_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct TrackDescription {	
        
        /// <summary>	
        ///  Priority type, as defined in <see cref="SlimDX2.Direct3D9.TrackPriority"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXPRIORITY_TYPE Priority</unmanaged>
        public SlimDX2.Direct3D9.TrackPriority Priority;
        
        /// <summary>	
        ///  Weight value. The weight determines the proportion of this track to blend with other tracks. 	
        /// </summary>	
        /// <unmanaged>float Weight</unmanaged>
        public float Weight;
        
        /// <summary>	
        ///  Speed value. This is used similarly to a multiplier to scale the period of the track. 	
        /// </summary>	
        /// <unmanaged>float Speed</unmanaged>
        public float Speed;
        
        /// <summary>	
        ///  Time position of the track, in the local timeframe of its current animation set. 	
        /// </summary>	
        /// <unmanaged>double Position</unmanaged>
        public double Position;
        
        /// <summary>	
        ///  Track enable/disable. To enable, set to TRUE. To disable, set to FALSE. 	
        /// </summary>	
        /// <unmanaged>BOOL Enable</unmanaged>
        public bool Enable { 
            get { 
                return (_Enable!=0)?true:false; 
            }
            set { 
                _Enable = value?1:0;
            }
        }
        internal int _Enable;
    }
    
    /// <summary>	
    /// Describes an animation event.	
    /// </summary>	
    /// <unmanaged>D3DXEVENT_DESC</unmanaged>
    [StructLayout(LayoutKind.Explicit, Pack = 0 )]
    public  partial struct EventDescription {	
        
        /// <summary>	
        ///  Event type, as defined in <see cref="SlimDX2.Direct3D9.EventType"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXEVENT_TYPE Type</unmanaged>
        [FieldOffset(0)]
        public SlimDX2.Direct3D9.EventType Type;
        
        /// <summary>	
        ///  Event track identifier. 	
        /// </summary>	
        /// <unmanaged>int Track</unmanaged>
        [FieldOffset(4)]
        public int Track;
        
        /// <summary>	
        ///  Start time of the event in global time. 	
        /// </summary>	
        /// <unmanaged>double StartTime</unmanaged>
        [FieldOffset(8)]
        public double StartTime;
        
        /// <summary>	
        ///  Duration of the event in global time. 	
        /// </summary>	
        /// <unmanaged>double Duration</unmanaged>
        [FieldOffset(16)]
        public double Duration;
        
        /// <summary>	
        ///  Transition style of the event, as defined in <see cref="SlimDX2.Direct3D9.TransitionType"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXTRANSITION_TYPE Transition</unmanaged>
        [FieldOffset(24)]
        public SlimDX2.Direct3D9.TransitionType Transition;
        
        /// <summary>	
        ///  Track weight for the event. 	
        /// </summary>	
        /// <unmanaged>float Weight</unmanaged>
        [FieldOffset(28)]
        public float Weight;
        
        /// <summary>	
        ///  Track speed for the event. 	
        /// </summary>	
        /// <unmanaged>float Speed</unmanaged>
        [FieldOffset(28)]
        public float Speed;
        
        /// <summary>	
        ///  Track position for the event. 	
        /// </summary>	
        /// <unmanaged>double Position</unmanaged>
        [FieldOffset(28)]
        public double Position;
        
        /// <summary>	
        ///  Enable flag. 	
        /// </summary>	
        /// <unmanaged>BOOL Enable</unmanaged>
        public bool Enable { 
            get { 
                return (_Enable!=0)?true:false; 
            }
            set { 
                _Enable = value?1:0;
            }
        }
        [FieldOffset(28)]
        internal int _Enable;
    }
}
