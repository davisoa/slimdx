// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Structs for SlimDX2.Direct3D9 namespace.
//     This code was generated by a tool.
//     Date : 11/14/2010 00:36:11
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace SlimDX2.Direct3D9 {

    
    /// <summary>	
    /// Defines the window dimensions of a render-target surface onto which a 3D volume projects.	
    /// </summary>	
    /// <remarks>	
    ///  The X, Y, Width, and Height members describe the position and dimensions of the viewport on the render-target surface. Usually, applications render to the entire target surface; when rendering on a 640 x 480 surface, these members should be 0, 0, 640, and 480, respectively. The MinZ and MaxZ are typically set to 0.0 and 1.0 but can be set to other values to achieve specific effects. For example, you might set them both to 0.0 to force the system to render objects to the foreground of a scene, or both to 1.0 to force the objects into the background.  When the viewport parameters for a device change (because of a call to the {{SetViewport}} method), the driver builds a new transformation matrix. 	
    /// </remarks>	
    /// <unmanaged>D3DVIEWPORT9</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct Viewport {	
        
        /// <summary>	
        ///  Pixel coordinate of the upper-left corner of the viewport on the render-target surface. Unless you want to render to a subset of the surface, this member can be set to 0.  	
        /// </summary>	
        /// <unmanaged>int X</unmanaged>
        public int X;
        
        /// <summary>	
        ///  Pixel coordinate of the upper-left corner of the viewport on the render-target surface. Unless you want to render to a subset of the surface, this member can be set to 0.  	
        /// </summary>	
        /// <unmanaged>int Y</unmanaged>
        public int Y;
        
        /// <summary>	
        ///  Width dimension of the clip volume, in pixels. Unless you are rendering only to a subset of the surface, this member should be set to the width dimension of the render-target surface.  	
        /// </summary>	
        /// <unmanaged>int Width</unmanaged>
        public int Width;
        
        /// <summary>	
        ///  Height dimension of the clip volume, in pixels. Unless you are rendering only to a subset of the surface, this member should be set to the height dimension of the render-target surface.  	
        /// </summary>	
        /// <unmanaged>int Height</unmanaged>
        public int Height;
        
        /// <summary>	
        ///  Together with MaxZ, value describing the range of depth values into which a scene is to be rendered, the minimum and maximum values of the clip volume. Most applications set this value to 0.0. Clipping is performed after applying the projection matrix.  	
        /// </summary>	
        /// <unmanaged>float MinZ</unmanaged>
        public float MinZ;
        
        /// <summary>	
        ///  Together with MinZ, value describing the range of depth values into which a scene is to be rendered, the minimum and maximum values of the clip volume. Most applications set this value to 1.0. Clipping is performed after applying the projection matrix.  	
        /// </summary>	
        /// <unmanaged>float MaxZ</unmanaged>
        public float MaxZ;
    }
    
    /// <summary>	
    /// Describes the current clip status.	
    /// </summary>	
    /// <remarks>	
    ///  When clipping is enabled during vertex processing (by {{ProcessVertices}}, {{DrawPrimitive}}, or other drawing functions), Direct3D computes a clip code for every vertex. The clip code is a combination of D3DCS_* bits. When a vertex is outside a particular clipping plane, the corresponding bit is set in the clipping code. Direct3D maintains the clip status using D3DCLIPSTATUS9, which has ClipUnion and ClipIntersection members. ClipUnion is a bitwise OR of all vertex clip codes and ClipIntersection is a bitwise AND of all vertex clip codes. Initial values are zero for ClipUnion and 0xFFFFFFFF for ClipIntersection. When D3DRS_CLIPPING is set to FALSE, ClipUnion and ClipIntersection are set to zero. Direct3D updates the clip status during drawing calls. To compute clip status for a particular object, set ClipUnion and ClipIntersection to their initial value and continue drawing.  Clip status is not updated by {{DrawRectPatch}} and {{DrawTriPatch}} because there is no software emulation for them. 	
    /// </remarks>	
    /// <unmanaged>D3DCLIPSTATUS9</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ClipStatus {	
        
        /// <summary>	
        ///  Clip union flags that describe the current clip status. This member can be one or more of the following flags:  ValueMeaning  D3DCS_ALL   Combination of all clip flags.   D3DCS_LEFT   All vertices are clipped by the left plane of the viewing frustum.   D3DCS_RIGHT   All vertices are clipped by the right plane of the viewing frustum.   D3DCS_TOP   All vertices are clipped by the top plane of the viewing frustum.   D3DCS_BOTTOM   All vertices are clipped by the bottom plane of the viewing frustum.   D3DCS_FRONT   All vertices are clipped by the front plane of the viewing frustum.   D3DCS_BACK   All vertices are clipped by the back plane of the viewing frustum.   D3DCS_PLANE0   Application-defined clipping planes.   D3DCS_PLANE1   Application-defined clipping planes.   D3DCS_PLANE2   Application-defined clipping planes.   D3DCS_PLANE3   Application-defined clipping planes.   D3DCS_PLANE4   Application-defined clipping planes.   D3DCS_PLANE5   Application-defined clipping planes.   ? 	
        /// </summary>	
        /// <unmanaged>int ClipUnion</unmanaged>
        public int ClipUnion;
        
        /// <summary>	
        ///  Clip intersection flags that describe the current clip status. This member can take the same flags as ClipUnion.  	
        /// </summary>	
        /// <unmanaged>int ClipIntersection</unmanaged>
        public int ClipIntersection;
    }
    
    /// <summary>	
    /// Specifies material properties.	
    /// </summary>	
    /// <remarks>	
    ///  To turn off specular highlights, set D3DRS_SPECULARENABLE to FALSE, using <see cref="SlimDX2.Direct3D9.RenderState"/>. This is the fastest option because no specular highlights will be calculated. For more information about using the lighting engine to calculate specular lighting, see {{Specular Lighting (Direct3D 9)}}. 	
    /// </remarks>	
    /// <unmanaged>D3DMATERIAL9</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct Material {	
        
        /// <summary>	
        ///  Value specifying the diffuse color of the material. See <see cref="SlimMath.Color4"/>.  	
        /// </summary>	
        /// <unmanaged>D3DCOLORVALUE Diffuse</unmanaged>
        public SlimMath.Color4 Diffuse;
        
        /// <summary>	
        ///  Value specifying the ambient color of the material. See <see cref="SlimMath.Color4"/>.  	
        /// </summary>	
        /// <unmanaged>D3DCOLORVALUE Ambient</unmanaged>
        public SlimMath.Color4 Ambient;
        
        /// <summary>	
        ///  Value specifying the specular color of the material. See <see cref="SlimMath.Color4"/>.  	
        /// </summary>	
        /// <unmanaged>D3DCOLORVALUE Specular</unmanaged>
        public SlimMath.Color4 Specular;
        
        /// <summary>	
        ///  Value specifying the emissive color of the material. See <see cref="SlimMath.Color4"/>.  	
        /// </summary>	
        /// <unmanaged>D3DCOLORVALUE Emissive</unmanaged>
        public SlimMath.Color4 Emissive;
        
        /// <summary>	
        ///  Floating-point value specifying the sharpness of specular highlights. The higher the value, the sharper the highlight. 	
        /// </summary>	
        /// <unmanaged>float Power</unmanaged>
        public float Power;
    }
    
    /// <summary>	
    /// Defines a set of lighting properties.	
    /// </summary>	
    /// <unmanaged>D3DLIGHT9</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct Light {	
        
        /// <summary>	
        ///  Type of the light source. This value is one of the members of the <see cref="SlimDX2.Direct3D9.LightType"/> enumerated type.  	
        /// </summary>	
        /// <unmanaged>D3DLIGHTTYPE Type</unmanaged>
        public SlimDX2.Direct3D9.LightType Type;
        
        /// <summary>	
        ///  Diffuse color emitted by the light. This member is a <see cref="SlimMath.Color4"/> structure.  	
        /// </summary>	
        /// <unmanaged>D3DCOLORVALUE Diffuse</unmanaged>
        public SlimMath.Color4 Diffuse;
        
        /// <summary>	
        ///  Specular color emitted by the light. This member is a <see cref="SlimMath.Color4"/> structure.  	
        /// </summary>	
        /// <unmanaged>D3DCOLORVALUE Specular</unmanaged>
        public SlimMath.Color4 Specular;
        
        /// <summary>	
        ///  Ambient color emitted by the light. This member is a <see cref="SlimMath.Color4"/> structure.  	
        /// </summary>	
        /// <unmanaged>D3DCOLORVALUE Ambient</unmanaged>
        public SlimMath.Color4 Ambient;
        
        /// <summary>	
        ///  Position of the light in world space, specified by a <see cref="SlimMath.Vector3"/> structure. This member has no meaning for directional lights and is ignored in that case.  	
        /// </summary>	
        /// <unmanaged>D3DVECTOR Position</unmanaged>
        public SlimMath.Vector3 Position;
        
        /// <summary>	
        ///  Direction that the light is pointing in world space, specified by a <see cref="SlimMath.Vector3"/> structure. This member has meaning only for directional and spotlights. This vector need not be normalized, but it should have a nonzero length.  	
        /// </summary>	
        /// <unmanaged>D3DVECTOR Direction</unmanaged>
        public SlimMath.Vector3 Direction;
        
        /// <summary>	
        ///  Distance beyond which the light has no effect. The maximum allowable value for this member is the square root of FLT_MAX. This member does not affect directional lights.  	
        /// </summary>	
        /// <unmanaged>float Range</unmanaged>
        public float Range;
        
        /// <summary>	
        ///  Decrease in illumination between a spotlight's inner cone (the angle specified by  Theta) and the outer edge of the outer cone (the angle specified by Phi).  The effect of falloff on the lighting is subtle. Furthermore, a small performance penalty is incurred by shaping the falloff curve. For these reasons, most developers set this value to 1.0. 	
        /// </summary>	
        /// <unmanaged>float Falloff</unmanaged>
        public float Falloff;
        
        /// <summary>	
        ///  Value specifying how the light intensity changes over distance. Attenuation values are ignored for directional lights. This member represents an attenuation constant. For information about attenuation, see {{Light Properties (Direct3D 9)}}. Valid values for this member range from 0.0 to infinity. For non-directional lights, all three attenuation values should not be set to 0.0 at the same time.  	
        /// </summary>	
        /// <unmanaged>float Attenuation0</unmanaged>
        public float Attenuation0;
        
        /// <summary>	
        ///  Value specifying how the light intensity changes over distance. Attenuation values are ignored for directional lights. This member represents an attenuation constant. For information about attenuation, see {{Light Properties (Direct3D 9)}}. Valid values for this member range from 0.0 to infinity. For non-directional lights, all three attenuation values should not be set to 0.0 at the same time. 	
        /// </summary>	
        /// <unmanaged>float Attenuation1</unmanaged>
        public float Attenuation1;
        
        /// <summary>	
        ///  Value specifying how the light intensity changes over distance. Attenuation values are ignored for directional lights. This member represents an attenuation constant. For information about attenuation, see {{Light Properties (Direct3D 9)}}. Valid values for this member range from 0.0 to infinity. For non-directional lights, all three attenuation values should not be set to 0.0 at the same time. 	
        /// </summary>	
        /// <unmanaged>float Attenuation2</unmanaged>
        public float Attenuation2;
        
        /// <summary>	
        ///  Angle, in radians, of a spotlight's inner cone - that is, the fully illuminated spotlight cone. This value must be in the range from 0 through the value specified by Phi. 	
        /// </summary>	
        /// <unmanaged>float Theta</unmanaged>
        public float Theta;
        
        /// <summary>	
        ///  Angle, in radians, defining the outer edge of the spotlight's outer cone. Points outside this cone are not lit by the spotlight. This value must be between 0 and pi.  	
        /// </summary>	
        /// <unmanaged>float Phi</unmanaged>
        public float Phi;
    }
    
    /// <summary>	
    /// Defines the vertex data layout. Each vertex can contain one or more data types, and each data type is described by a vertex element.	
    /// </summary>	
    /// <remarks>	
    ///  Vertex data is defined using an array of D3DVERTEXELEMENT9 structures. Use {{D3DDECL_END}} to declare the last element in the declaration.  	
    /// </remarks>	
    /// <unmanaged>D3DVERTEXELEMENT9</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct VertexElement {	
        
        /// <summary>	
        ///  Stream number. 	
        /// </summary>	
        /// <unmanaged>WORD Stream</unmanaged>
        public short Stream;
        
        /// <summary>	
        ///  Offset from the beginning of the vertex data to the data associated with the particular data type. 	
        /// </summary>	
        /// <unmanaged>WORD Offset</unmanaged>
        public short Offset;
        
        /// <summary>	
        ///  The data type, specified as a <see cref="SlimDX2.Direct3D9.DeclarationType"/>. One of several predefined types that define the data size. Some methods have an implied type. 	
        /// </summary>	
        /// <unmanaged>byte Type</unmanaged>
        public SlimDX2.Direct3D9.DeclarationType Type;
        
        /// <summary>	
        ///  The method specifies the tessellator processing, which determines how the tessellator interprets (or operates on) the vertex data. For more information, see <see cref="SlimDX2.Direct3D9.DeclarationMethod"/>. 	
        /// </summary>	
        /// <unmanaged>byte Method</unmanaged>
        public SlimDX2.Direct3D9.DeclarationMethod Method;
        
        /// <summary>	
        ///  Defines what the data will be used for; that is, the interoperability between vertex data layouts and vertex shaders. Each usage acts to bind a vertex declaration to a vertex shader. In some cases, they have a special interpretation. For example, an element that specifies D3DDECLUSAGE_NORMAL or D3DDECLUSAGE_POSITION is used by the N-patch tessellator to set up tessellation. See <see cref="SlimDX2.Direct3D9.DeclarationUsage"/> for a list of the available semantics. D3DDECLUSAGE_TEXCOORD can be used for user-defined fields (which don't have an existing usage defined). 	
        /// </summary>	
        /// <unmanaged>byte Usage</unmanaged>
        public SlimDX2.Direct3D9.DeclarationUsage Usage;
        
        /// <summary>	
        ///  Modifies the usage data to allow the user to specify multiple usage types. 	
        /// </summary>	
        /// <unmanaged>byte UsageIndex</unmanaged>
        public byte UsageIndex;
    }
    
    /// <summary>	
    /// Describes the display mode.	
    /// </summary>	
    /// <unmanaged>D3DDISPLAYMODE</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct DisplayMode {	
        
        /// <summary>	
        ///  Screen width, in pixels.  	
        /// </summary>	
        /// <unmanaged>UINT Width</unmanaged>
        public int Width;
        
        /// <summary>	
        ///  Screen height, in pixels.  	
        /// </summary>	
        /// <unmanaged>UINT Height</unmanaged>
        public int Height;
        
        /// <summary>	
        ///  Refresh rate. The value of 0 indicates an adapter default.  	
        /// </summary>	
        /// <unmanaged>UINT RefreshRate</unmanaged>
        public int RefreshRate;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the surface format of the display mode.  	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
    }
    
    /// <summary>	
    /// Describes the creation parameters for a device.	
    /// </summary>	
    /// <unmanaged>D3DDEVICE_CREATION_PARAMETERS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct CreationParameters {	
        
        /// <summary>	
        ///  Ordinal number that denotes the display adapter. D3DADAPTER_DEFAULT is always the primary display adapter.  Use this ordinal as the Adapter parameter for any of the <see cref="SlimDX2.Direct3D9.Direct3D"/> methods. Note that different instances of Direct3D 9.0 objects can use different ordinals. Adapters can enter or leave a system when users, for example, add or remove monitors from a multiple-monitor system or when they hot-swap a laptop. Consequently, use this ordinal only in a Direct3D 9.0 instance known to be valid, that is, either the Direct3D 9.0 that created this <see cref="SlimDX2.Direct3D9.Device"/> interface or the Direct3D 9.0 returned from {{GetDirect3D}}, as called through this IDirect3DDevice9 interface. 	
        /// </summary>	
        /// <unmanaged>UINT AdapterOrdinal</unmanaged>
        public int AdapterOrdinal;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.DeviceType"/> enumerated type. Denotes the amount of emulated functionality for this device. The value of this parameter mirrors the value passed to the {{CreateDevice}} call that created this device. 	
        /// </summary>	
        /// <unmanaged>D3DDEVTYPE DeviceType</unmanaged>
        public SlimDX2.Direct3D9.DeviceType DeviceType;
        
        /// <summary>	
        ///  Window handle to which focus belongs for this Direct3D device. The value of this parameter mirrors the value passed to the {{CreateDevice}} call that created this device. 	
        /// </summary>	
        /// <unmanaged>HWND hFocusWindow</unmanaged>
        public IntPtr HFocusWindow;
        
        /// <summary>	
        ///  A combination of one or more {{D3DCREATE}} constants that control global behavior of the device. These constants mirror the constants passed to {{CreateDevice}} when the device was created. 	
        /// </summary>	
        /// <unmanaged>int BehaviorFlags</unmanaged>
        public int BehaviorFlags;
    }
    
    /// <summary>	
    /// Describes the presentation parameters.	
    /// </summary>	
    /// <unmanaged>D3DPRESENT_PARAMETERS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct PresentParameters {	
        
        /// <summary>	
        ///  Width of the new swap chain's back buffers, in pixels. If Windowed is FALSE (the presentation is full-screen), this value must equal the width of one of the enumerated display modes found through {{EnumAdapterModes}}. If Windowed is TRUE and either BackBufferWidth or BackBufferHeight is zero, the corresponding dimension of the client area of the hDeviceWindow (or the focus window, if hDeviceWindow is NULL) is taken. 	
        /// </summary>	
        /// <unmanaged>UINT BackBufferWidth</unmanaged>
        public int BackBufferWidth;
        
        /// <summary>	
        ///  Height of the new swap chain's back buffers, in pixels. If Windowed is FALSE (the presentation is full-screen), this value must equal the height of one of the enumerated display modes found through {{EnumAdapterModes}}. If Windowed is TRUE and either BackBufferWidth or BackBufferHeight is zero, the corresponding dimension of the client area of the hDeviceWindow (or the focus window, if hDeviceWindow is NULL) is taken. 	
        /// </summary>	
        /// <unmanaged>UINT BackBufferHeight</unmanaged>
        public int BackBufferHeight;
        
        /// <summary>	
        ///  The back buffer format. For more information about formats, see <see cref="SlimDX2.Direct3D9.Format"/>. This value must be one of the render-target formats as validated by {{CheckDeviceType}}. You can use {{GetDisplayMode}} to obtain the current format. In fact, D3DFMT_UNKNOWN can be specified for the BackBufferFormat while in windowed mode. This tells the runtime to use the current display-mode format and eliminates the need to call {{GetDisplayMode}}. For windowed applications, the back buffer format no longer needs to match the display-mode format because color conversion can now be done by the hardware (if the hardware supports color conversion). The set of possible back buffer formats is constrained, but the runtime will allow any valid back buffer format to be presented to any desktop format. (There is the additional requirement that the device be operable in the desktop mode; devices typically do not operate in 8 bits per pixel modes.) Full-screen applications cannot do color conversion. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT BackBufferFormat</unmanaged>
        public SlimDX2.Direct3D9.Format BackBufferFormat;
        
        /// <summary>	
        ///  This value can be between 0 and <see cref="SlimDX2.Direct3D9.Present.BackBuffersMaximum"/> (or <see cref="SlimDX2.Direct3D9.Present.BackBuffersMaximumEx"/> when using Direct3D 9Ex). Values of 0 are treated as 1. If the number of back buffers cannot be created, the runtime will fail the method call and fill this value with the number of back buffers that could be created. As a result, an application can call the method twice with the same D3DPRESENT_PARAMETERS structure and expect it to work the second time. The method fails if one back buffer cannot be created. The value of BackBufferCount influences what set of swap effects are allowed. Specifically, any D3DSWAPEFFECT_COPY swap effect requires that there be exactly one back buffer. 	
        /// </summary>	
        /// <unmanaged>UINT BackBufferCount</unmanaged>
        public int BackBufferCount;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.MultisampleType"/> enumerated type. The value must be D3DMULTISAMPLE_NONE unless SwapEffect has been set to D3DSWAPEFFECT_DISCARD. Multisampling is supported only if the swap effect is D3DSWAPEFFECT_DISCARD. 	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_TYPE MultiSampleType</unmanaged>
        public SlimDX2.Direct3D9.MultisampleType MultiSampleType;
        
        /// <summary>	
        ///  Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by  {{CheckDeviceMultiSampleType}}. Passing a larger value returns the error D3DERR_INVALIDCALL. Paired values of render targets or of depth stencil surfaces and <see cref="SlimDX2.Direct3D9.MultisampleType"/> must match. 	
        /// </summary>	
        /// <unmanaged>int MultiSampleQuality</unmanaged>
        public int MultiSampleQuality;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.SwapEffect"/> enumerated type. The runtime will guarantee the implied semantics concerning buffer swap behavior; therefore, if Windowed is TRUE and SwapEffect is set to D3DSWAPEFFECT_FLIP, the runtime will create one extra back buffer and copy whichever becomes the front buffer at presentation time. D3DSWAPEFFECT_COPY requires that BackBufferCount be set to 1. D3DSWAPEFFECT_DISCARD will be enforced in the debug runtime by filling any buffer with noise after it is presented.   Differences between Direct3D9 and Direct3D9Ex In Direct3D9Ex, D3DSWAPEFFECT_FLIPEX is added to designate when an application is adopting flip mode. That is, whan an application's frame is passed in window's mode (instead of copied) to the Desktop Window Manager(DWM) for composition. Flip mode provides more efficient memory bandwidth and enables an application to take advantage of full-screen-present statistics. It does not change full screen behavior. Flip mode behavior is available beginning with Windows 7.   ? 	
        /// </summary>	
        /// <unmanaged>D3DSWAPEFFECT SwapEffect</unmanaged>
        public SlimDX2.Direct3D9.SwapEffect SwapEffect;
        
        /// <summary>	
        ///  The device window determines the location and size of the back buffer on screen. This is used by Direct3D when the back buffer contents are copied to the front buffer during {{Present}}.   For a full-screen application, this is a handle to the top window (which is the focus window).  For applications that use multiple full-screen devices (such as a multimonitor system), exactly one device can use the focus window as the device window. All other devices must have unique device windows.  For a windowed-mode application, this handle will be the default target window for {{Present}}. If this handle is NULL, the focus window will be taken.  Note that no attempt is made by the runtime to reflect user changes in window size. The back buffer is not implicitly reset when this window is reset. However, the {{Present}} method does automatically track window position changes. 	
        /// </summary>	
        /// <unmanaged>HWND hDeviceWindow</unmanaged>
        public IntPtr DeviceWindowHandle;
        
        /// <summary>	
        ///  TRUE if the application runs windowed; FALSE if the application runs full-screen. 	
        /// </summary>	
        /// <unmanaged>BOOL Windowed</unmanaged>
        public bool Windowed { 
            get { 
                return (_Windowed!=0)?true:false; 
            }
            set { 
                _Windowed = value?1:0;
            }
        }
        internal int _Windowed;
        
        /// <summary>	
        ///  If this value is TRUE, Direct3D will manage depth buffers for the application. The device will create a depth-stencil buffer when it is created. The depth-stencil buffer will be automatically set as the render target of the device. When the device is reset, the depth-stencil buffer will be automatically destroyed and recreated in the new size. If EnableAutoDepthStencil is TRUE, then AutoDepthStencilFormat must be a valid depth-stencil format. 	
        /// </summary>	
        /// <unmanaged>BOOL EnableAutoDepthStencil</unmanaged>
        public bool EnableAutoDepthStencil { 
            get { 
                return (_EnableAutoDepthStencil!=0)?true:false; 
            }
            set { 
                _EnableAutoDepthStencil = value?1:0;
            }
        }
        internal int _EnableAutoDepthStencil;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type. The format of the automatic depth-stencil surface that the device will create. This member is ignored unless EnableAutoDepthStencil is TRUE. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT AutoDepthStencilFormat</unmanaged>
        public SlimDX2.Direct3D9.Format AutoDepthStencilFormat;
        
        /// <summary>	
        ///  One of the {{D3DPRESENTFLAG}} constants. 	
        /// </summary>	
        /// <unmanaged>int Flags</unmanaged>
        public SlimDX2.Direct3D9.PresentFlags PresentFlags;
        
        /// <summary>	
        ///  The rate at which the display adapter refreshes the screen. The value depends on the mode in which the application is running:  For windowed mode, the refresh rate must be 0. For full-screen mode, the refresh rate is one of the refresh rates returned by {{EnumAdapterModes}}.  	
        /// </summary>	
        /// <unmanaged>UINT FullScreen_RefreshRateInHz</unmanaged>
        public int FullScreenRefreshRateInHz;
        
        /// <summary>	
        ///  The maximum rate at which the swap chain's back buffers can be presented to the front buffer. For a detailed explanation of the modes and the intervals that are supported, see <see cref="SlimDX2.Direct3D9.Present"/>. 	
        /// </summary>	
        /// <unmanaged>UINT PresentationInterval</unmanaged>
        public SlimDX2.Direct3D9.PresentInterval PresentationInterval;
    }
    
    /// <summary>	
    /// Contains red, green, and blue ramp data.	
    /// </summary>	
    /// <unmanaged>D3DGAMMARAMP</unmanaged>
    public  partial struct GammaRamp {	
        
        /// <summary>	
        ///  Array of 256  WORD element that describes the red gamma ramp.  	
        /// </summary>	
        /// <unmanaged>WORD red[256]</unmanaged>
        public short[] Red { 
            get { 
                if (_Red == null) {
                    _Red = new short[256];
                }
                return _Red; 
            }
        }
        internal short[] _Red;
        
        /// <summary>	
        ///  Array of 256  WORD element that describes the green gamma ramp.  	
        /// </summary>	
        /// <unmanaged>WORD green[256]</unmanaged>
        public short[] Green { 
            get { 
                if (_Green == null) {
                    _Green = new short[256];
                }
                return _Green; 
            }
        }
        internal short[] _Green;
        
        /// <summary>	
        ///  Array of 256  WORD element that describes the blue gamma ramp.  	
        /// </summary>	
        /// <unmanaged>WORD blue[256]</unmanaged>
        public short[] Blue { 
            get { 
                if (_Blue == null) {
                    _Blue = new short[256];
                }
                return _Blue; 
            }
        }
        internal short[] _Blue;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public fixed short Red[256];
            public fixed short Green[256];
            public fixed short Blue[256];
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            fixed (void* __to = &this.Red[0]) fixed (void* __from = @ref.Red) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 256*sizeof ( short));
            fixed (void* __to = &this.Green[0]) fixed (void* __from = @ref.Green) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 256*sizeof ( short));
            fixed (void* __to = &this.Blue[0]) fixed (void* __from = @ref.Blue) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 256*sizeof ( short));
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            fixed (void* __to = @ref.Red) fixed (void* __from = &this.Red[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 256*sizeof ( short));
            fixed (void* __to = @ref.Green) fixed (void* __from = &this.Green[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 256*sizeof ( short));
            fixed (void* __to = @ref.Blue) fixed (void* __from = &this.Blue[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 256*sizeof ( short));
		
		}
    }
    
    /// <summary>	
    /// Describes a vertex buffer.	
    /// </summary>	
    /// <unmanaged>D3DVERTEXBUFFER_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct VertexBufferDescription {	
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the surface format of the vertex buffer data. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.ResourceType"/> enumerated type, identifying this resource as a vertex buffer. 	
        /// </summary>	
        /// <unmanaged>D3DRESOURCETYPE Type</unmanaged>
        public SlimDX2.Direct3D9.ResourceType Type;
        
        /// <summary>	
        ///  Combination of one or more <see cref="SlimDX2.Direct3D9.Usage"/> flags. 	
        /// </summary>	
        /// <unmanaged>int Usage</unmanaged>
        public int Usage;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, specifying the class of memory allocated for this vertex buffer. 	
        /// </summary>	
        /// <unmanaged>D3DPOOL Pool</unmanaged>
        public SlimDX2.Direct3D9.Pool Pool;
        
        /// <summary>	
        ///  Size of the vertex buffer, in bytes. 	
        /// </summary>	
        /// <unmanaged>UINT Size</unmanaged>
        public int Size;
        
        /// <summary>	
        ///  Combination of <see cref="SlimDX2.Direct3D9.VertexFormat"/> that describes the vertex format of the vertices in this buffer. 	
        /// </summary>	
        /// <unmanaged>int FVF</unmanaged>
        public SlimDX2.Direct3D9.VertexFormat Fvf;
    }
    
    /// <summary>	
    /// Describes an index buffer.	
    /// </summary>	
    /// <unmanaged>D3DINDEXBUFFER_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct IndexBufferDescription {	
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the surface format of the index buffer data. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.ResourceType"/> enumerated type, identifying this resource as an index buffer. 	
        /// </summary>	
        /// <unmanaged>D3DRESOURCETYPE Type</unmanaged>
        public SlimDX2.Direct3D9.ResourceType Type;
        
        /// <summary>	
        ///  Combination of one or more of the following flags, specifying the usage for this resource.  ValueMeaning  D3DUSAGE_DONOTCLIP   Set to indicate that the index buffer content will never require clipping.   D3DUSAGE_DYNAMIC   Set to indicate that the index buffer requires dynamic memory use. This is useful for drivers because it enables them to decide where to place the buffer. In general, static index buffers are placed in video memory and dynamic index buffers are placed in AGP memory. Note that there is no separate static usage; if you do not specify D3DUSAGE_DYNAMIC the index buffer is made static. D3DUSAGE_DYNAMIC is strictly enforced through the D3DLOCK_DISCARD and D3DLOCK_NOOVERWRITE locking flags. As a result, D3DLOCK_DISCARD and D3DLOCK_NOOVERWRITE are only valid on index buffers created with D3DUSAGE_DYNAMIC; they are not valid flags on static vertex buffers. For more information about using dynamic index buffers, see {{Using Dynamic Vertex and Index Buffers}}. Note that D3DUSAGE_DYNAMIC cannot be specified on managed index buffers. For more information, see {{Managing Resources (Direct3D 9)}}.   D3DUSAGE_RTPATCHES   Set to indicate when the index buffer is to be used for drawing high-order primitives.   D3DUSAGE_NPATCHES   Set to indicate when the index buffer is to be used for drawing N patches.   D3DUSAGE_POINTS   Set to indicate when the index buffer is to be used for drawing point sprites or indexed point lists.   D3DUSAGE_SOFTWAREPROCESSING   Set to indicate that the buffer is to be used with software processing.   D3DUSAGE_WRITEONLY   Informs the system that the application writes only to the index buffer. Using this flag enables the driver to choose the best memory location for efficient write operations and rendering. Attempts to read from an index buffer that is created with this capability can result in degraded performance.   ? 	
        /// </summary>	
        /// <unmanaged>int Usage</unmanaged>
        public int Usage;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, specifying the class of memory allocated for this index buffer. 	
        /// </summary>	
        /// <unmanaged>D3DPOOL Pool</unmanaged>
        public SlimDX2.Direct3D9.Pool Pool;
        
        /// <summary>	
        ///  Size of the index buffer, in bytes. 	
        /// </summary>	
        /// <unmanaged>UINT Size</unmanaged>
        public int Size;
    }
    
    /// <summary>	
    /// Describes a surface.	
    /// </summary>	
    /// <unmanaged>D3DSURFACE_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct SurfaceDescription {	
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the surface format.  	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.ResourceType"/> enumerated type, identifying this resource as a surface.  	
        /// </summary>	
        /// <unmanaged>D3DRESOURCETYPE Type</unmanaged>
        public SlimDX2.Direct3D9.ResourceType Type;
        
        /// <summary>	
        ///  Either the D3DUSAGE_DEPTHSTENCIL or D3DUSAGE_RENDERTARGET values. For more information, see <see cref="SlimDX2.Direct3D9.Usage"/>. 	
        /// </summary>	
        /// <unmanaged>int Usage</unmanaged>
        public int Usage;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, specifying the class of memory allocated for this surface. 	
        /// </summary>	
        /// <unmanaged>D3DPOOL Pool</unmanaged>
        public SlimDX2.Direct3D9.Pool Pool;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.MultisampleType"/> enumerated type, specifying the levels of full-scene multisampling supported by the surface. 	
        /// </summary>	
        /// <unmanaged>D3DMULTISAMPLE_TYPE MultiSampleType</unmanaged>
        public SlimDX2.Direct3D9.MultisampleType MultiSampleType;
        
        /// <summary>	
        ///  Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by  {{CheckDeviceMultiSampleType}}. Passing a larger value returns the error, D3DERR_INVALIDCALL. The MultisampleQuality values of paired render targets, depth stencil surfaces and the MultiSample type must all match. 	
        /// </summary>	
        /// <unmanaged>int MultiSampleQuality</unmanaged>
        public int MultiSampleQuality;
        
        /// <summary>	
        ///  Width of the surface, in pixels. 	
        /// </summary>	
        /// <unmanaged>UINT Width</unmanaged>
        public int Width;
        
        /// <summary>	
        ///  Height of the surface, in pixels. 	
        /// </summary>	
        /// <unmanaged>UINT Height</unmanaged>
        public int Height;
    }
    
    /// <summary>	
    /// Describes a volume.	
    /// </summary>	
    /// <unmanaged>D3DVOLUME_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct VolumeDescription {	
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the surface format of the volume.  	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.ResourceType"/> enumerated type, identifying this resource as a volume.  	
        /// </summary>	
        /// <unmanaged>D3DRESOURCETYPE Type</unmanaged>
        public SlimDX2.Direct3D9.ResourceType Type;
        
        /// <summary>	
        ///  Currently not used. Always returned as 0.  	
        /// </summary>	
        /// <unmanaged>int Usage</unmanaged>
        public int Usage;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Pool"/> enumerated type, specifying the class of memory allocated for this volume.  	
        /// </summary>	
        /// <unmanaged>D3DPOOL Pool</unmanaged>
        public SlimDX2.Direct3D9.Pool Pool;
        
        /// <summary>	
        ///  Width of the volume, in pixels.  	
        /// </summary>	
        /// <unmanaged>UINT Width</unmanaged>
        public int Width;
        
        /// <summary>	
        ///  Height of the volume, in pixels.  	
        /// </summary>	
        /// <unmanaged>UINT Height</unmanaged>
        public int Height;
        
        /// <summary>	
        ///  Depth of the volume, in pixels.  	
        /// </summary>	
        /// <unmanaged>UINT Depth</unmanaged>
        public int Depth;
    }
    
    /// <summary>	
    /// Describes a locked rectangular region.	
    /// </summary>	
    /// <remarks>	
    ///  The pitch for DXTn formats is different from what was returned in DirectX 7. It now refers to the number of bytes in a row of blocks. For example, if you have a width of 16, then you will have a pitch of 4 blocks (4*8 for DXT1, 4*16 for DXT2-5.) 	
    /// </remarks>	
    /// <unmanaged>D3DLOCKED_RECT</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct LockedRect {	
        
        /// <summary>	
        ///  Number of bytes in one row of the surface. 	
        /// </summary>	
        /// <unmanaged>INT Pitch</unmanaged>
        public int Pitch;
        
        /// <summary>	
        ///  Pointer to the locked bits. If a <see cref="SlimDX2.Rectangle"/> was provided to the {{LockRect}} call, pBits will be appropriately offset from the start of the surface. 	
        /// </summary>	
        /// <unmanaged>void* pBits</unmanaged>
        public IntPtr PBits;
    }
    
    /// <summary>	
    /// Defines a volume.	
    /// </summary>	
    /// <remarks>	
    ///  D3DBOX includes the left, top, and front edges; however, the right, bottom, and back edges are not included. For example, a box that is 100 units wide and begins at 0 (thus, including the points up to and including 99) would be expressed with a value of 0 for the Left member and a value of 100 for the Right member. Note that a value of 99 is not used for the Right member. The restrictions on side ordering observed for D3DBOX are left to right, top to bottom, and front to back. 	
    /// </remarks>	
    /// <unmanaged>D3DBOX</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct Box {	
        
        /// <summary>	
        ///  Position of the left side of the box on the x-axis. 	
        /// </summary>	
        /// <unmanaged>UINT Left</unmanaged>
        public int Left;
        
        /// <summary>	
        ///  Position of the top of the box on the y-axis. 	
        /// </summary>	
        /// <unmanaged>UINT Top</unmanaged>
        public int Top;
        
        /// <summary>	
        ///  Position of the right side of the box on the x-axis. 	
        /// </summary>	
        /// <unmanaged>UINT Right</unmanaged>
        public int Right;
        
        /// <summary>	
        ///  Position of the bottom of the box on the y-axis. 	
        /// </summary>	
        /// <unmanaged>UINT Bottom</unmanaged>
        public int Bottom;
        
        /// <summary>	
        ///  Position of the front of the box on the z-axis. 	
        /// </summary>	
        /// <unmanaged>UINT Front</unmanaged>
        public int Front;
        
        /// <summary>	
        ///  Position of the back of the box on the z-axis. 	
        /// </summary>	
        /// <unmanaged>UINT Back</unmanaged>
        public int Back;
    }
    
    /// <summary>	
    /// Describes a locked box (volume).	
    /// </summary>	
    /// <remarks>	
    ///  Volumes can be visualized as being organized into slices of width x height 2D surfaces stacked up to make a width x height x depth volume. For more information, see {{Volume Texture Resources (Direct3D 9)}}. 	
    /// </remarks>	
    /// <unmanaged>D3DLOCKED_BOX</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct LockedBox {	
        
        /// <summary>	
        ///  Byte offset from the left edge of one row to the left edge of the next row. 	
        /// </summary>	
        /// <unmanaged>INT RowPitch</unmanaged>
        public int RowPitch;
        
        /// <summary>	
        ///  Byte offset from the top-left of one slice to the top-left of the next deepest slice.  	
        /// </summary>	
        /// <unmanaged>INT SlicePitch</unmanaged>
        public int SlicePitch;
        
        /// <summary>	
        ///  Pointer to the beginning of the volume box. If a <see cref="SlimDX2.Direct3D9.Box"/> was provided to the LockBox call, pBits will be appropriately offset from the start of the volume.  	
        /// </summary>	
        /// <unmanaged>void* pBits</unmanaged>
        public IntPtr PBits;
    }
    
    /// <summary>	
    /// Describes a rectangular high-order patch.	
    /// </summary>	
    /// <remarks>	
    ///  The following diagram identifies the parameters that specify a rectangle patch. ?  Diagram of a rectangular high-order patch and the parameters that specify it ? Each of the vertices in the vertex buffer is shown as a black dot. In this case, the vertex buffer has 20 vertices in it, 16 of which are in the rectangle patch. The stride is the number of vertices in the width of the vertex buffer, in this case five. The x offset to the first vertex is called the StartIndexVertexWidth and is in this case 1. The y offset to the first patch vertex is called the StartIndexVertexHeight and is in this case 0. To render a stream of individual rectangular patches (non-mosaic), you should interpret your geometry as a long narrow (1 x N) rectangular patch. The D3DRECTPATCH_INFO structure for such a strip (cubic B?zier) would be set up in the following manner. 	
    /// <code> D3DRECTPATCH_INFO RectInfo; RectInfo.Width = 4;	
    /// RectInfo.Height = 4;	
    /// RectInfo.Stride = 4;	
    /// RectInfo.Basis = D3DBASIS_BEZIER;	
    /// RectInfo.Order = D3DORDER_CUBIC;	
    /// RectInfo.StartVertexOffsetWidth = 0;	
    /// RectInfo.StartVertexOffsetHeight = 4*i;  // The variable i is the index of the 	
    /// //   patch you want to render. </code>	
    /// 	
    ///  	
    /// </remarks>	
    /// <unmanaged>D3DRECTPATCH_INFO</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct RectanglePatchInfo {	
        
        /// <summary>	
        ///  Starting vertex offset width, in number of vertices.  	
        /// </summary>	
        /// <unmanaged>UINT StartVertexOffsetWidth</unmanaged>
        public int StartVertexOffsetWidth;
        
        /// <summary>	
        ///  Starting vertex offset height, in number of vertices.  	
        /// </summary>	
        /// <unmanaged>UINT StartVertexOffsetHeight</unmanaged>
        public int StartVertexOffsetHeight;
        
        /// <summary>	
        ///  Width of each vertex, in number of vertices.  	
        /// </summary>	
        /// <unmanaged>UINT Width</unmanaged>
        public int Width;
        
        /// <summary>	
        ///  Height of each vertex, in number of vertices.  	
        /// </summary>	
        /// <unmanaged>UINT Height</unmanaged>
        public int Height;
        
        /// <summary>	
        ///  Width of the imaginary two-dimensional vertex array, which occupies the same space as the vertex buffer. For an example, see the diagram below.  	
        /// </summary>	
        /// <unmanaged>UINT Stride</unmanaged>
        public int Stride;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Basis"/> enumerated type, defining the basis type for the rectangular high-order patch.   ValueOrder supportedWidth and height D3DBASIS_BEZIERLinear, cubic, and quinticWidth = height = (DWORD)order + 1 D3DBASIS_BSPLINELinear, cubic, and quinticWidth = height &gt; (DWORD)order D3DBASIS_INTERPOLATECubicWidth = height &gt; (DWORD)order  ? 	
        /// </summary>	
        /// <unmanaged>D3DBASISTYPE Basis</unmanaged>
        public SlimDX2.Direct3D9.Basis Basis;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Degree"/> enumerated type, defining the degree for the rectangular patch.  	
        /// </summary>	
        /// <unmanaged>D3DDEGREETYPE Degree</unmanaged>
        public SlimDX2.Direct3D9.Degree Degree;
    }
    
    /// <summary>	
    /// Describes a triangular high-order patch.	
    /// </summary>	
    /// <remarks>	
    ///  For example, the following diagram identifies the vertex order and segment numbers for a cubic B?zier triangle patch. The vertex order determines the segment numbers used by {{DrawTriPatch}}. The offset is the number of bytes to the first triangle patch vertex in the vertex buffer. ?  Diagram of a triangular high-order patch with nine vertices ? 	
    /// </remarks>	
    /// <unmanaged>D3DTRIPATCH_INFO</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct TrianglePatchInfo {	
        
        /// <summary>	
        ///  Starting vertex offset, in number of vertices.  	
        /// </summary>	
        /// <unmanaged>UINT StartVertexOffset</unmanaged>
        public int StartVertexOffset;
        
        /// <summary>	
        ///  Number of vertices. 	
        /// </summary>	
        /// <unmanaged>UINT NumVertices</unmanaged>
        public int NumVertices;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Basis"/> enumerated type, which defines the basis type for the triangular high-order patch. The only valid value for this member is D3DBASIS_BEZIER. 	
        /// </summary>	
        /// <unmanaged>D3DBASISTYPE Basis</unmanaged>
        public SlimDX2.Direct3D9.Basis Basis;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Degree"/> enumerated type, defining the degree type for the triangular high-order patch.  ValueNumber of vertices D3DDEGREE_CUBIC10 D3DDEGREE_LINEAR3 D3DDEGREE_QUADRATICN/A D3DDEGREE_QUINTIC21  ? N/A - Not available. Not supported. 	
        /// </summary>	
        /// <unmanaged>D3DDEGREETYPE Degree</unmanaged>
        public SlimDX2.Direct3D9.Degree Degree;
    }
    
    /// <summary>	
    /// Contains information identifying the adapter.	
    /// </summary>	
    /// <remarks>	
    ///  The following pseudocode example illustrates the version format encoded in the DriverVersion, DriverVersionLowPart, and DriverVersionHighPart members. 	
    /// <code> Product = HIWORD(DriverVersion.HighPart)	
    /// Version = LOWORD(DriverVersion.HighPart)	
    /// SubVersion = HIWORD(DriverVersion.LowPart)	
    /// Build = LOWORD(DriverVersion.LowPart) </code>	
    /// 	
    ///  See the Platform SDK for more information about the HIWORD macro, the LOWORD macro, and the LARGE_INTEGER structure. MAX_DEVICE_IDENTIFIER_STRING is a constant with the following definition. 	
    /// <code> #define MAX_DEVICE_IDENTIFIER_STRING        512 </code>	
    /// 	
    ///  The VendorId, DeviceId, SubSysId, and Revision members can be used in tandem to identify particular chip sets. However, use these members with caution. 	
    /// </remarks>	
    /// <unmanaged>D3DADAPTER_IDENTIFIER9</unmanaged>
    public  partial struct AdapterDetails {	
        
        /// <summary>	
        ///  Used for presentation to the user. This should not be used to identify particular drivers, because many different strings might be associated with the same device and driver from different vendors. 	
        /// </summary>	
        /// <unmanaged>char Driver[512]</unmanaged>
        public string Driver;
        
        /// <summary>	
        ///  Used for presentation to the user. 	
        /// </summary>	
        /// <unmanaged>char Description[512]</unmanaged>
        public string Description;
        
        /// <summary>	
        ///  Device name for GDI. 	
        /// </summary>	
        /// <unmanaged>char DeviceName[32]</unmanaged>
        public string DeviceName;
        
        /// <summary>	
        ///  Identify the version of the Direct3D driver. It is legal to do less than and greater than comparisons on the 64-bit signed integer value. However, exercise caution if you use this element to identify problematic drivers. Instead, you should use DeviceIdentifier. See Remarks. 	
        /// </summary>	
        /// <unmanaged>int DriverVersionLowPart</unmanaged>
        public int DriverVersionLowPart;
        
        /// <summary>	
        ///  Identify the version of the Direct3D driver. It is legal to do &lt; and &gt; comparisons on the 64-bit signed integer value. However, exercise caution if you use this element to identify problematic drivers. Instead, you should use DeviceIdentifier. See Remarks. 	
        /// </summary>	
        /// <unmanaged>int DriverVersionHighPart</unmanaged>
        public int DriverVersionHighPart;
        
        /// <summary>	
        ///  Identify the version of the Direct3D driver. It is legal to do &lt; and &gt; comparisons on the 64-bit signed integer value. However, exercise caution if you use this element to identify problematic drivers. Instead, you should use DeviceIdentifier. See Remarks. 	
        /// </summary>	
        /// <unmanaged>int VendorId</unmanaged>
        public int VendorId;
        
        /// <summary>	
        ///  Can be used to help identify a particular chip set. Query this member to identify the manufacturer. The value can be zero if unknown. 	
        /// </summary>	
        /// <unmanaged>int DeviceId</unmanaged>
        public int DeviceId;
        
        /// <summary>	
        ///  Can be used to help identify a particular chip set. Query this member to identify the type of chip set. The value can be zero if unknown. 	
        /// </summary>	
        /// <unmanaged>int SubSysId</unmanaged>
        public int SubSysId;
        
        /// <summary>	
        ///  Can be used to help identify a particular chip set. Query this member to identify the subsystem, typically the particular board. The value can be zero if unknown. 	
        /// </summary>	
        /// <unmanaged>int Revision</unmanaged>
        public int Revision;
        
        /// <summary>	
        ///  Can be used to help identify a particular chip set. Query this member to identify the revision level of the chip set. The value can be zero if unknown. 	
        /// </summary>	
        /// <unmanaged>GUID DeviceIdentifier</unmanaged>
        public Guid DeviceIdentifier;
        
        /// <summary>	
        ///  Can be queried to check changes in the driver and chip set. This GUID is a unique identifier for the driver and chip set pair. Query this member to track changes to the driver and chip set in order to generate a new profile for the graphics subsystem. DeviceIdentifier can also be used to identify particular problematic drivers. 	
        /// </summary>	
        /// <unmanaged>int WHQLLevel</unmanaged>
        public int WHQLLevel;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public fixed byte Driver[512];
            public fixed byte Description[512];
            public fixed byte DeviceName[32];
            public int DriverVersionLowPart;
            public int DriverVersionHighPart;
            public int VendorId;
            public int DeviceId;
            public int SubSysId;
            public int Revision;
            public Guid DeviceIdentifier;
            public int WHQLLevel;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            fixed (void* __ptr = @ref.Driver) this.Driver = new string((sbyte*)__ptr, 0, 512);
            fixed (void* __ptr = @ref.Description) this.Description = new string((sbyte*)__ptr, 0, 512);
            fixed (void* __ptr = @ref.DeviceName) this.DeviceName = new string((sbyte*)__ptr, 0, 32);
            this.DriverVersionLowPart = @ref.DriverVersionLowPart;
            this.DriverVersionHighPart = @ref.DriverVersionHighPart;
            this.VendorId = @ref.VendorId;
            this.DeviceId = @ref.DeviceId;
            this.SubSysId = @ref.SubSysId;
            this.Revision = @ref.Revision;
            this.DeviceIdentifier = @ref.DeviceIdentifier;
            this.WHQLLevel = @ref.WHQLLevel;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            IntPtr Driver_ = Marshal.StringToHGlobalAnsi(this.Driver);
            fixed (void* __ptr = @ref.Driver) Utilities.CopyMemory((IntPtr)__ptr, Driver_, this.Driver.Length);
            Marshal.FreeHGlobal( Driver_);
            IntPtr Description_ = Marshal.StringToHGlobalAnsi(this.Description);
            fixed (void* __ptr = @ref.Description) Utilities.CopyMemory((IntPtr)__ptr, Description_, this.Description.Length);
            Marshal.FreeHGlobal( Description_);
            IntPtr DeviceName_ = Marshal.StringToHGlobalAnsi(this.DeviceName);
            fixed (void* __ptr = @ref.DeviceName) Utilities.CopyMemory((IntPtr)__ptr, DeviceName_, this.DeviceName.Length);
            Marshal.FreeHGlobal( DeviceName_);
            @ref.DriverVersionLowPart = this.DriverVersionLowPart;
            @ref.DriverVersionHighPart = this.DriverVersionHighPart;
            @ref.VendorId = this.VendorId;
            @ref.DeviceId = this.DeviceId;
            @ref.SubSysId = this.SubSysId;
            @ref.Revision = this.Revision;
            @ref.DeviceIdentifier = this.DeviceIdentifier;
            @ref.WHQLLevel = this.WHQLLevel;
		
		}
    }
    
    /// <summary>	
    /// Describes the raster status.	
    /// </summary>	
    /// <unmanaged>D3DRASTER_STATUS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct RasterStatus {	
        
        /// <summary>	
        ///  TRUE if the raster is in the vertical blank period. FALSE if the raster is not in the vertical blank period.  	
        /// </summary>	
        /// <unmanaged>BOOL InVBlank</unmanaged>
        public bool InVBlank { 
            get { 
                return (_InVBlank!=0)?true:false; 
            }
            set { 
                _InVBlank = value?1:0;
            }
        }
        internal int _InVBlank;
        
        /// <summary>	
        ///  If InVBlank is FALSE, then this value is an integer roughly corresponding to the current scan line painted by the raster. Scan lines are numbered in the same way as Direct3D surface coordinates: 0 is the top of the primary surface, extending to the value (height of the surface - 1) at the bottom of the display. If InVBlank is TRUE, then this value is set to zero and can be ignored. 	
        /// </summary>	
        /// <unmanaged>UINT ScanLine</unmanaged>
        public int ScanLine;
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DPRESENTSTATS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct PresentationStatistics {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT PresentCount</unmanaged>
        public int PresentCount;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT PresentRefreshCount</unmanaged>
        public int PresentRefreshCount;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT SyncRefreshCount</unmanaged>
        public int SyncRefreshCount;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>LARGE_INTEGER SyncQPCTime</unmanaged>
        public long SyncQPCTime;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>LARGE_INTEGER SyncGPUTime</unmanaged>
        public long SyncGPUTime;
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DDISPLAYMODEEX</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct DisplayModeEx {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT Size</unmanaged>
        public int Size;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT Width</unmanaged>
        public int Width;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT Height</unmanaged>
        public int Height;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT RefreshRate</unmanaged>
        public int RefreshRate;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>D3DSCANLINEORDERING ScanLineOrdering</unmanaged>
        public SlimDX2.Direct3D9.ScanlineOrdering ScanLineOrdering;
    }
    
    /// <summary>	
    /// Specifies types of display modes to filter out.	
    /// </summary>	
    /// <unmanaged>D3DDISPLAYMODEFILTER</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct DisplayModeFilter {	
        
        /// <summary>	
        ///  The size of this structure. This should always be set to sizeof(D3DDISPLAYMODEFILTER). 	
        /// </summary>	
        /// <unmanaged>UINT Size</unmanaged>
        public int Size;
        
        /// <summary>	
        ///  The display mode format to filter out. See <see cref="SlimDX2.Direct3D9.Format"/>. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        ///  Whether the scanline ordering is interlaced or progressive. See <see cref="SlimDX2.Direct3D9.ScanlineOrdering"/>. 	
        /// </summary>	
        /// <unmanaged>D3DSCANLINEORDERING ScanLineOrdering</unmanaged>
        public SlimDX2.Direct3D9.ScanlineOrdering ScanLineOrdering;
    }
    
    /// <summary>	
    /// Vertex shader caps.	
    /// </summary>	
    /// <unmanaged>D3DVSHADERCAPS2_0</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct VertexShader20Caps {	
        
        /// <summary>	
        ///  Instruction predication is supported if this value is nonzero. See {{setp_comp - vs}}. 	
        /// </summary>	
        /// <unmanaged>int Caps</unmanaged>
        public int Caps;
        
        /// <summary>	
        ///   Either 0 or 24, which represents the depth of the dynamic flow control instruction nesting. See {{D3DVS20CAPS}}. 	
        /// </summary>	
        /// <unmanaged>INT DynamicFlowControlDepth</unmanaged>
        public int DynamicFlowControlDepth;
        
        /// <summary>	
        ///  The number of temporary registers supported. See {{D3DVS20CAPS}}. 	
        /// </summary>	
        /// <unmanaged>INT NumTemps</unmanaged>
        public int NumTemps;
        
        /// <summary>	
        ///  The depth of nesting of the {{loop - vs}}/{{rep - vs}} and {{call - vs}}/{{callnz bool - vs}} instructions. See {{D3DVS20CAPS}}. 	
        /// </summary>	
        /// <unmanaged>INT StaticFlowControlDepth</unmanaged>
        public int StaticFlowControlDepth;
    }
    
    /// <summary>	
    /// Pixel shader driver caps.	
    /// </summary>	
    /// <unmanaged>D3DPSHADERCAPS2_0</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct PixelShader20Caps {	
        
        /// <summary>	
        ///  Instruction predication is supported if this value is nonzero. See {{setp_comp - vs}}. 	
        /// </summary>	
        /// <unmanaged>int Caps</unmanaged>
        public int Caps;
        
        /// <summary>	
        ///  Either 0 or 24, which represents the depth of the dynamic flow control instruction nesting. See D3DPSHADERCAPS2_0. 	
        /// </summary>	
        /// <unmanaged>INT DynamicFlowControlDepth</unmanaged>
        public int DynamicFlowControlDepth;
        
        /// <summary>	
        ///  The number of temporary registers supported. See D3DPSHADERCAPS2_0. 	
        /// </summary>	
        /// <unmanaged>INT NumTemps</unmanaged>
        public int NumTemps;
        
        /// <summary>	
        ///  The depth of nesting of the {{loop - vs}}/{{rep - vs}} and {{call - vs}}/{{callnz bool - vs}} instructions. See D3DPSHADERCAPS2_0. 	
        /// </summary>	
        /// <unmanaged>INT StaticFlowControlDepth</unmanaged>
        public int StaticFlowControlDepth;
        
        /// <summary>	
        ///  The number of instruction slots supported. See D3DPSHADERCAPS2_0. 	
        /// </summary>	
        /// <unmanaged>INT NumInstructionSlots</unmanaged>
        public int NumInstructionSlots;
    }
    
    /// <summary>	
    /// Represents the capabilities of the hardware exposed through the Direct3D object.	
    /// </summary>	
    /// <remarks>	
    ///  The MaxTextureBlendStages and MaxSimultaneousTextures members might seem similar, but they contain different information. The MaxTextureBlendStages member contains the total number of texture-blending stages supported by the current device, and the MaxSimultaneousTextures member describes how many of those stages can have textures bound to them by using the {{SetTexture}} method. When the driver fills this structure, it can set values for execute-buffer capabilities, even when the interface being used to retrieve the capabilities (such as <see cref="SlimDX2.Direct3D9.Device"/>) does not support execute buffers. In general, performance problems may occur if you use a texture and then modify it during a scene. Ensure that no texture used in the current {{BeginScene}} and {{EndScene}} block is evicted unless absolutely necessary. In the case of extremely high texture usage within a scene, the results are undefined. This occurs when you modify a texture that you have used in the scene and there is no spare texture memory available. For such systems, the contents of the z-buffer become invalid at EndScene. Applications should not call {{UpdateSurface}} to or from the back buffer on this type of hardware inside a BeginScene/EndScene pair. In addition, applications should not try to access the z-buffer if the D3DPRASTERCAPS_ZBUFFERLESSHSR capability flag is set. Finally, applications should not lock the back buffer or the z-buffer inside a BeginScene/EndScene pair. The following flags concerning mipmapped textures are not supported in Direct3D 9.   D3DPTFILTERCAPS_LINEAR D3DPTFILTERCAPS_LINEARMIPLINEAR D3DPTFILTERCAPS_LINEARMIPNEAREST D3DPTFILTERCAPS_MIPNEAREST D3DPTFILTERCAPS_NEAREST  	
    /// </remarks>	
    /// <unmanaged>D3DCAPS9</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct Capabilities {	
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.DeviceType"/> enumerated type, which identifies what type of resources are used for processing vertices. 	
        /// </summary>	
        /// <unmanaged>D3DDEVTYPE DeviceType</unmanaged>
        public SlimDX2.Direct3D9.DeviceType DeviceType;
        
        /// <summary>	
        ///  Adapter on which this Direct3D device was created. This ordinal is valid only to pass to methods of the <see cref="SlimDX2.Direct3D9.Direct3D"/> interface that created this Direct3D device. The IDirect3D9 interface can always be retrieved by calling {{GetDirect3D}}.  	
        /// </summary>	
        /// <unmanaged>UINT AdapterOrdinal</unmanaged>
        public int AdapterOrdinal;
        
        /// <summary>	
        ///   The following driver-specific capability.  ValueMeaning  D3DCAPS_READ_SCANLINE   Display hardware is capable of returning the current scan line.   D3DCAPS_OVERLAY   The display driver supports an overlay DDI that allows for verification of overlay capabilities. For more information about the overlay DDI, see {{Overlay DDI}}.  Differences between Direct3D 9 and Direct3D 9Ex:This flag is available in Direct3D 9Ex only. ?   ? 	
        /// </summary>	
        /// <unmanaged>int Caps</unmanaged>
        public int Caps;
        
        /// <summary>	
        ///  Driver-specific capabilities identified in {{D3DCAPS2}}. 	
        /// </summary>	
        /// <unmanaged>int Caps2</unmanaged>
        public int Caps2;
        
        /// <summary>	
        ///  Driver-specific capabilities identified in {{D3DCAPS3}}. 	
        /// </summary>	
        /// <unmanaged>int Caps3</unmanaged>
        public int Caps3;
        
        /// <summary>	
        ///   Bit mask of values representing what presentation swap intervals are available.  ValueMeaning  D3DPRESENT_INTERVAL_IMMEDIATE   The driver supports an immediate presentation swap interval.   D3DPRESENT_INTERVAL_ONE   The driver supports a presentation swap interval of every screen refresh.   D3DPRESENT_INTERVAL_TWO   The driver supports a presentation swap interval of every second screen refresh.   D3DPRESENT_INTERVAL_THREE   The driver supports a presentation swap interval of every third screen refresh.   D3DPRESENT_INTERVAL_FOUR   The driver supports a presentation swap interval of every fourth screen refresh.   ? 	
        /// </summary>	
        /// <unmanaged>int PresentationIntervals</unmanaged>
        public int PresentationIntervals;
        
        /// <summary>	
        ///   Bit mask indicating what hardware support is available for cursors. Direct3D 9 does not define alpha-blending cursor capabilities.  ValueMeaning  D3DCURSORCAPS_COLOR   A full-color cursor is supported in hardware. Specifically, this flag indicates that the driver supports at least a hardware color cursor in high-resolution modes (with scan lines greater than or equal to 400).   D3DCURSORCAPS_LOWRES   A full-color cursor is supported in hardware. Specifically, this flag indicates that the driver supports a hardware color cursor in both high-resolution and low-resolution modes (with scan lines less than 400).   ? 	
        /// </summary>	
        /// <unmanaged>int CursorCaps</unmanaged>
        public int CursorCaps;
        
        /// <summary>	
        ///   Flags identifying the capabilities of the device.  ValueMeaning  D3DDEVCAPS_CANBLTSYSTONONLOCAL   Device supports blits from system-memory textures to nonlocal video-memory textures.   D3DDEVCAPS_CANRENDERAFTERFLIP   Device can queue rendering commands after a page flip. Applications do not change their behavior if this flag is set; this capability means that the device is relatively fast.   D3DDEVCAPS_DRAWPRIMITIVES2   Device can support at least a DirectX 5-compliant driver.   D3DDEVCAPS_DRAWPRIMITIVES2EX   Device can support at least a DirectX 7-compliant driver.   D3DDEVCAPS_DRAWPRIMTLVERTEX   Device exports an <see cref="SlimDX2.Direct3D9.Device.DrawPrimitives"/>-aware hal.   D3DDEVCAPS_EXECUTESYSTEMMEMORY   Device can use execute buffers from system memory.   D3DDEVCAPS_EXECUTEVIDEOMEMORY   Device can use execute buffers from video memory.   D3DDEVCAPS_HWRASTERIZATION   Device has hardware acceleration for scene rasterization.   D3DDEVCAPS_HWTRANSFORMANDLIGHT   Device can support transformation and lighting in hardware.   D3DDEVCAPS_NPATCHES   Device supports N patches.   D3DDEVCAPS_PUREDEVICE   Device can support rasterization, transform, lighting, and shading in hardware.   D3DDEVCAPS_QUINTICRTPATCHES   Device supports quintic B?zier curves and B-splines.   D3DDEVCAPS_RTPATCHES   Device supports rectangular and triangular patches.   D3DDEVCAPS_RTPATCHHANDLEZERO   When this device capability is set, the hardware architecture does not require caching of any information, and uncached patches (handle zero) will be drawn as efficiently as cached ones. Note that setting D3DDEVCAPS_RTPATCHHANDLEZERO does not mean that a patch with handle zero can be drawn. A handle-zero patch can always be drawn whether this cap is set or not.   D3DDEVCAPS_SEPARATETEXTUREMEMORIES   Device is texturing from separate memory pools.   D3DDEVCAPS_TEXTURENONLOCALVIDMEM   Device can retrieve textures from non-local video memory.   D3DDEVCAPS_TEXTURESYSTEMMEMORY   Device can retrieve textures from system memory.   D3DDEVCAPS_TEXTUREVIDEOMEMORY   Device can retrieve textures from device memory.   D3DDEVCAPS_TLVERTEXSYSTEMMEMORY   Device can use buffers from system memory for transformed and lit vertices.   D3DDEVCAPS_TLVERTEXVIDEOMEMORY   Device can use buffers from video memory for transformed and lit vertices.   ? 	
        /// </summary>	
        /// <unmanaged>int DevCaps</unmanaged>
        public int DevCaps;
        
        /// <summary>	
        ///  Miscellaneous driver primitive capabilities. See {{D3DPMISCCAPS}}. 	
        /// </summary>	
        /// <unmanaged>int PrimitiveMiscCaps</unmanaged>
        public int PrimitiveMiscCaps;
        
        /// <summary>	
        ///   Information on raster-drawing capabilities. This member can be one or more of the following flags.  ValueMeaning  D3DPRASTERCAPS_ANISOTROPY   Device supports anisotropic filtering.   D3DPRASTERCAPS_COLORPERSPECTIVE   Device iterates colors perspective correctly.   D3DPRASTERCAPS_DITHER   Device can dither to improve color resolution.   D3DPRASTERCAPS_DEPTHBIAS   Device supports legacy depth bias. For true depth bias, see D3DPRASTERCAPS_SLOPESCALEDEPTHBIAS.   D3DPRASTERCAPS_FOGRANGE   Device supports range-based fog. In range-based fog, the distance of an object from the viewer is used to compute fog effects, not the depth of the object (that is, the z-coordinate) in the scene.   D3DPRASTERCAPS_FOGTABLE   Device calculates the fog value by referring to a lookup table containing fog values that are indexed to the depth of a given pixel.   D3DPRASTERCAPS_FOGVERTEX   Device calculates the fog value during the lighting operation and interpolates the fog value during rasterization.   D3DPRASTERCAPS_MIPMAPLODBIAS   Device supports level-of-detail bias adjustments. These bias adjustments enable an application to make a mipmap appear crisper or less sharp than it normally would. For more information about level-of-detail bias in mipmaps, see D3DSAMP_MIPMAPLODBIAS.   D3DPRASTERCAPS_MULTISAMPLE_TOGGLE   Device supports toggling multisampling on and off between <see cref="SlimDX2.Direct3D9.Device.BeginScene"/> and <see cref="SlimDX2.Direct3D9.Device.EndScene"/> (using D3DRS_MULTISAMPLEANTIALIAS).   D3DPRASTERCAPS_SCISSORTEST   Device supports scissor test. See {{Scissor Test (Direct3D 9)}}.   D3DPRASTERCAPS_SLOPESCALEDEPTHBIAS   Device performs true slope-scale based depth bias. This is in contrast to the legacy style depth bias.   D3DPRASTERCAPS_WBUFFER   Device supports depth buffering using w.   D3DPRASTERCAPS_WFOG   Device supports w-based fog. W-based fog is used when a perspective projection matrix is specified, but affine projections still use z-based fog. The system considers a projection matrix that contains a nonzero value in the [3][4] element to be a perspective projection matrix.   D3DPRASTERCAPS_ZBUFFERLESSHSR   Device can perform hidden-surface removal (HSR) without requiring the application to sort polygons and without requiring the allocation of a depth-buffer. This leaves more video memory for textures. The method used to perform HSR is hardware-dependent and is transparent to the application. Z-bufferless HSR is performed if no depth-buffer surface is associated with the rendering-target surface and the depth-buffer comparison test is enabled (that is, when the state value associated with the <see cref="SlimDX2.Direct3D9.RenderState.ZEnable"/> enumeration constant is set to TRUE).   D3DPRASTERCAPS_ZFOG   Device supports z-based fog.   D3DPRASTERCAPS_ZTEST   Device can perform z-test operations. This effectively renders a primitive and indicates whether any z pixels have been rendered.   ? 	
        /// </summary>	
        /// <unmanaged>int RasterCaps</unmanaged>
        public int RasterCaps;
        
        /// <summary>	
        ///   Z-buffer comparison capabilities. This member can be one or more of the following flags.  ValueMeaning  D3DPCMPCAPS_ALWAYS   Always pass the z-test.   D3DPCMPCAPS_EQUAL   Pass the z-test if the new z equals the current z.   D3DPCMPCAPS_GREATER   Pass the z-test if the new z is greater than the current z.   D3DPCMPCAPS_GREATEREQUAL   Pass the z-test if the new z is greater than or equal to the current z.   D3DPCMPCAPS_LESS   Pass the z-test if the new z is less than the current z.   D3DPCMPCAPS_LESSEQUAL   Pass the z-test if the new z is less than or equal to the current z.   D3DPCMPCAPS_NEVER   Always fail the z-test.   D3DPCMPCAPS_NOTEQUAL   Pass the z-test if the new z does not equal the current z.   ? 	
        /// </summary>	
        /// <unmanaged>int ZCmpCaps</unmanaged>
        public int ZCmpCaps;
        
        /// <summary>	
        ///   Source-blending capabilities. This member can be one or more of the following flags. (The RGBA values of the source and destination are indicated by the subscripts s and d.)  ValueMeaning  D3DPBLENDCAPS_BLENDFACTOR   The driver supports both D3DBLEND_BLENDFACTOR and D3DBLEND_INVBLENDFACTOR. See <see cref="SlimDX2.Direct3D9.Blend"/>.   D3DPBLENDCAPS_BOTHINVSRCALPHA   Source blend factor is (1 - As, 1 - As, 1 - As, 1 - As) and destination blend factor is (As, As, As, As); the destination blend selection is overridden.   D3DPBLENDCAPS_BOTHSRCALPHA   The driver supports the D3DBLEND_BOTHSRCALPHA blend mode. (This blend mode is obsolete. For more information, see D3DBLEND.)   D3DPBLENDCAPS_DESTALPHA   Blend factor is (Ad, Ad, Ad, Ad).   D3DPBLENDCAPS_DESTCOLOR   Blend factor is (Rd, Gd, Bd, Ad).   D3DPBLENDCAPS_INVDESTALPHA   Blend factor is (1 - Ad, 1 - Ad, 1 - Ad, 1 - Ad).   D3DPBLENDCAPS_INVDESTCOLOR   Blend factor is (1 - Rd, 1 - Gd, 1 - Bd, 1 - Ad).   D3DPBLENDCAPS_INVSRCALPHA   Blend factor is (1 - As, 1 - As, 1 - As, 1 - As).   D3DPBLENDCAPS_INVSRCCOLOR   Blend factor is (1 - Rs, 1 - Gs, 1 - Bs, 1 - As).   D3DPBLENDCAPS_INVSRCCOLOR2   Blend factor is (1 - PSOutColor[1]r, 1 - PSOutColor[1]g, 1 - PSOutColor[1]b, not used)). See {{Render Target Blending}}.  Differences between Direct3D 9 and Direct3D 9Ex:This flag is available in Direct3D 9Ex only. ?   D3DPBLENDCAPS_ONE   Blend factor is (1, 1, 1, 1).   D3DPBLENDCAPS_SRCALPHA   Blend factor is (As, As, As, As).   D3DPBLENDCAPS_SRCALPHASAT   Blend factor is (f, f, f, 1); f = min(As, 1 - Ad).   D3DPBLENDCAPS_SRCCOLOR   Blend factor is (Rs, Gs, Bs, As).   D3DPBLENDCAPS_SRCCOLOR2   Blend factor is (PSOutColor[1]r, PSOutColor[1]g, PSOutColor[1]b, not used). See {{Render Target Blending}}.  Differences between Direct3D 9 and Direct3D 9Ex:This flag is available in Direct3D 9Ex only. ?   D3DPBLENDCAPS_ZERO   Blend factor is (0, 0, 0, 0).   ? 	
        /// </summary>	
        /// <unmanaged>int SrcBlendCaps</unmanaged>
        public int SrcBlendCaps;
        
        /// <summary>	
        ///  Destination-blending capabilities. This member can be the same capabilities that are defined for the SrcBlendCaps member.  	
        /// </summary>	
        /// <unmanaged>int DestBlendCaps</unmanaged>
        public int DestBlendCaps;
        
        /// <summary>	
        ///  Alpha-test comparison capabilities. This member can include the same capability flags defined for the ZCmpCaps member. If this member contains only the D3DPCMPCAPS_ALWAYS capability or only the D3DPCMPCAPS_NEVER capability, the driver does not support alpha tests. Otherwise, the flags identify the individual comparisons that are supported for alpha testing.  	
        /// </summary>	
        /// <unmanaged>int AlphaCmpCaps</unmanaged>
        public int AlphaCmpCaps;
        
        /// <summary>	
        ///  Shading operations capabilities. It is assumed, in general, that if a device supports a given command at all, it supports the D3DSHADE_FLAT mode (as specified in the <see cref="SlimDX2.Direct3D9.ShadeMode"/> enumerated type). This flag specifies whether the driver can also support Gouraud shading and whether alpha color components are supported. When alpha components are not supported, the alpha value of colors generated is implicitly 255. This is the maximum possible alpha (that is, the alpha component is at full intensity).  The color, specular highlights, fog, and alpha interpolants of a triangle each have capability flags that an application can use to find out how they are implemented by the device driver.  This member can be one or more of the following flags.  ValueMeaning  D3DPSHADECAPS_ALPHAGOURAUDBLEND   Device can support an alpha component for Gouraud-blended transparency (the D3DSHADE_GOURAUD state for the D3DSHADEMODE enumerated type). In this mode, the alpha color component of a primitive is provided at vertices and interpolated across a face along with the other color components.   D3DPSHADECAPS_COLORGOURAUDRGB   Device can support colored Gouraud shading. In this mode, the per-vertex color components (red, green, and blue) are interpolated across a triangle face.   D3DPSHADECAPS_FOGGOURAUD   Device can support fog in the Gouraud shading mode.   D3DPSHADECAPS_SPECULARGOURAUDRGB   Device supports Gouraud shading of specular highlights.   ? 	
        /// </summary>	
        /// <unmanaged>int ShadeCaps</unmanaged>
        public int ShadeCaps;
        
        /// <summary>	
        ///   Miscellaneous texture-mapping capabilities. This member can be one or more of the following flags.  ValueMeaning  D3DPTEXTURECAPS_ALPHA   Alpha in texture pixels is supported.   D3DPTEXTURECAPS_ALPHAPALETTE   Device can draw alpha from texture palettes.   D3DPTEXTURECAPS_CUBEMAP   Supports cube textures.   D3DPTEXTURECAPS_CUBEMAP_POW2   Device requires that cube texture maps have dimensions specified as powers of two.   D3DPTEXTURECAPS_MIPCUBEMAP   Device supports mipmapped cube textures.   D3DPTEXTURECAPS_MIPMAP   Device supports mipmapped textures.   D3DPTEXTURECAPS_MIPVOLUMEMAP   Device supports mipmapped volume textures.   D3DPTEXTURECAPS_NONPOW2CONDITIONAL   D3DPTEXTURECAPS_POW2 is also set, conditionally supports the use of 2D textures with dimensions that are not powers of two. A device that exposes this capability can use such a texture if all of the following requirements are met.   The texture addressing mode for the texture stage is set to D3DTADDRESS_CLAMP. Texture wrapping for the texture stage is disabled ({{D3DRS_WRAP}} n set to 0). Mipmapping is not in use (use magnification filter only). Texture formats must not be <see cref="SlimDX2.Direct3D9.Format.MtDxt1"/> through D3DFMT_DXT5.  If this flag is not set, and D3DPTEXTURECAPS_POW2 is also not set, then unconditional support is provided for 2D textures with dimensions that are not powers of two. A texture that is not a power of two cannot be set at a stage that will be read based on a shader computation (such as the {{bem - ps}} and {{texm3x3 - ps}} instructions in pixel shaders versions 1_0 to 1_3). For example, these textures can be used to store bumps that will be fed into texture reads, but not the environment maps that are used in {{texbem - ps}}, {{texbeml - ps}}, and {{texm3x3spec - ps}}. This means that a texture with dimensions that are not powers of two cannot be addressed or sampled using texture coordinates computed within the shader. This type of operation is known as a dependent read and cannot be performed on these types of textures.   D3DPTEXTURECAPS_NOPROJECTEDBUMPENV   Device does not support a projected bump-environment loopkup operation in programmable and fixed function shaders.   D3DPTEXTURECAPS_PERSPECTIVE   Perspective correction texturing is supported.   D3DPTEXTURECAPS_POW2   If D3DPTEXTURECAPS_NONPOW2CONDITIONAL is not set, all textures must have widths and heights specified as powers of two. This requirement does not apply to either cube textures or volume textures. If D3DPTEXTURECAPS_NONPOW2CONDITIONAL is also set, conditionally supports the use of 2D textures with dimensions that are not powers of two. See D3DPTEXTURECAPS_NONPOW2CONDITIONAL description. If this flag is not set, and D3DPTEXTURECAPS_NONPOW2CONDITIONAL is also not set, then unconditional support is provided for 2D textures with dimensions that are not powers of two.   D3DPTEXTURECAPS_PROJECTED   Supports the D3DTTFF_PROJECTED texture transformation flag. When applied, the device divides transformed texture coordinates by the last texture coordinate. If this capability is present, then the projective divide occurs per pixel. If this capability is not present, but the projective divide needs to occur anyway, then it is performed on a per-vertex basis by the Direct3D runtime.   D3DPTEXTURECAPS_SQUAREONLY   All textures must be square.   D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE   Texture indices are not scaled by the texture size prior to interpolation.   D3DPTEXTURECAPS_VOLUMEMAP   Device supports volume textures.   D3DPTEXTURECAPS_VOLUMEMAP_POW2   Device requires that volume texture maps have dimensions specified as powers of two.   ? 	
        /// </summary>	
        /// <unmanaged>int TextureCaps</unmanaged>
        public int TextureCaps;
        
        /// <summary>	
        ///  Texture-filtering capabilities for a texture. Per-stage filtering capabilities reflect which filtering modes are supported for texture stages when performing multiple-texture blending. This member can be any combination of the per-stage texture-filtering flags defined in {{D3DPTFILTERCAPS}}. 	
        /// </summary>	
        /// <unmanaged>int TextureFilterCaps</unmanaged>
        public int TextureFilterCaps;
        
        /// <summary>	
        ///  Texture-filtering capabilities for a cube texture. Per-stage filtering capabilities reflect which filtering modes are supported for texture stages when performing multiple-texture blending. This member can be any combination of the per-stage texture-filtering flags defined in {{D3DPTFILTERCAPS}}.  	
        /// </summary>	
        /// <unmanaged>int CubeTextureFilterCaps</unmanaged>
        public int CubeTextureFilterCaps;
        
        /// <summary>	
        ///  Texture-filtering capabilities for a volume texture. Per-stage filtering capabilities reflect which filtering modes are supported for texture stages when performing multiple-texture blending. This member can be any combination of the per-stage texture-filtering flags defined in {{D3DPTFILTERCAPS}}. 	
        /// </summary>	
        /// <unmanaged>int VolumeTextureFilterCaps</unmanaged>
        public int VolumeTextureFilterCaps;
        
        /// <summary>	
        ///   Texture-addressing capabilities for texture objects. This member can be one or more of the following flags.  ValueMeaning  D3DPTADDRESSCAPS_BORDER   Device supports setting coordinates outside the range [0.0, 1.0] to the border color, as specified by the D3DSAMP_BORDERCOLOR texture-stage state.   D3DPTADDRESSCAPS_CLAMP   Device can clamp textures to addresses.   D3DPTADDRESSCAPS_INDEPENDENTUV   Device can separate the texture-addressing modes of the u and v coordinates of the texture. This ability corresponds to the D3DSAMP_ADDRESSU and D3DSAMP_ADDRESSV render-state values.   D3DPTADDRESSCAPS_MIRROR   Device can mirror textures to addresses.   D3DPTADDRESSCAPS_MIRRORONCE   Device can take the absolute value of the texture coordinate (thus, mirroring around 0) and then clamp to the maximum value.   D3DPTADDRESSCAPS_WRAP   Device can wrap textures to addresses.   ? 	
        /// </summary>	
        /// <unmanaged>int TextureAddressCaps</unmanaged>
        public int TextureAddressCaps;
        
        /// <summary>	
        ///  Texture-addressing capabilities for a volume texture. This member can be one or more of the flags defined for the TextureAddressCaps member.  	
        /// </summary>	
        /// <unmanaged>int VolumeTextureAddressCaps</unmanaged>
        public int VolumeTextureAddressCaps;
        
        /// <summary>	
        ///   Defines the capabilities for line-drawing primitives.  ValueMeaning  D3DLINECAPS_ALPHACMP   Supports alpha-test comparisons.   D3DLINECAPS_ANTIALIAS   Antialiased lines are supported.   D3DLINECAPS_BLEND   Supports source-blending.   D3DLINECAPS_FOG   Supports fog.   D3DLINECAPS_TEXTURE   Supports texture-mapping.   D3DLINECAPS_ZTEST   Supports z-buffer comparisons.   ? 	
        /// </summary>	
        /// <unmanaged>int LineCaps</unmanaged>
        public int LineCaps;
        
        /// <summary>	
        ///  Maximum texture width for this device.  	
        /// </summary>	
        /// <unmanaged>int MaxTextureWidth</unmanaged>
        public int MaxTextureWidth;
        
        /// <summary>	
        ///  Maximum texture height for this device.  	
        /// </summary>	
        /// <unmanaged>int MaxVolumeExtent</unmanaged>
        public int MaxVolumeExtent;
        
        /// <summary>	
        ///  Maximum value for any of the three dimensions (width, height, and depth) of a volume texture.  	
        /// </summary>	
        /// <unmanaged>int MaxTextureRepeat</unmanaged>
        public int MaxTextureRepeat;
        
        /// <summary>	
        ///  This number represents the maximum range of the integer bits of the post-normalized texture coordinates. A texture coordinate is stored as a 32-bit signed integer using 27 bits to store the integer part and 5 bits for the floating point fraction. The maximum integer index, 227, is used to determine the maximum texture coordinate, depending on how the hardware does texture-coordinate scaling. Some hardware reports the cap D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE. For this case, the device defers scaling texture coordinates by the texture size until after interpolation and application of the texture address mode, so the number of times a texture can be wrapped is given by the integer value in MaxTextureRepeat. Less desirably, on some hardware D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE is not set and the device scales the texture coordinates by the texture size (using the highest level of detail) prior to interpolation. This limits the number of times a texture can be wrapped to MaxTextureRepeat / texture size. For example, assume that MaxTextureRepeat is equal to 32k and the size of the texture is 4k. If the hardware sets D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE, then the number of times a texture can be wrapped is equal to MaxTextureRepeat, which is 32k in this example. Otherwise, the number of times a texture can be wrapped is equal to MaxTextureRepeat divided by texture size, which is 32k/4k in this example. 	
        /// </summary>	
        /// <unmanaged>int MaxTextureAspectRatio</unmanaged>
        public int MaxTextureAspectRatio;
        
        /// <summary>	
        ///  Maximum texture aspect ratio supported by the hardware, typically a power of 2.  	
        /// </summary>	
        /// <unmanaged>int MaxAnisotropy</unmanaged>
        public int MaxAnisotropy;
        
        /// <summary>	
        ///  Maximum valid value for the D3DSAMP_MAXANISOTROPY texture-stage state.  	
        /// </summary>	
        /// <unmanaged>float MaxVertexW</unmanaged>
        public float MaxVertexW;
        
        /// <summary>	
        ///  Maximum W-based depth value that the device supports.  	
        /// </summary>	
        /// <unmanaged>float GuardBandLeft</unmanaged>
        public float GuardBandLeft;
        
        /// <summary>	
        ///  Screen-space coordinate of the guard-band clipping region. Coordinates inside this rectangle but outside the viewport rectangle are automatically clipped.  	
        /// </summary>	
        /// <unmanaged>float GuardBandTop</unmanaged>
        public float GuardBandTop;
        
        /// <summary>	
        ///  Screen-space coordinate of the guard-band clipping region. Coordinates inside this rectangle but outside the viewport rectangle are automatically clipped.  	
        /// </summary>	
        /// <unmanaged>float GuardBandRight</unmanaged>
        public float GuardBandRight;
        
        /// <summary>	
        ///  Screen-space coordinate of the guard-band clipping region. Coordinates inside this rectangle but outside the viewport rectangle are automatically clipped.  	
        /// </summary>	
        /// <unmanaged>float GuardBandBottom</unmanaged>
        public float GuardBandBottom;
        
        /// <summary>	
        ///  Screen-space coordinate of the guard-band clipping region. Coordinates inside this rectangle but outside the viewport rectangle are automatically clipped.  	
        /// </summary>	
        /// <unmanaged>float ExtentsAdjust</unmanaged>
        public float ExtentsAdjust;
        
        /// <summary>	
        ///  Number of pixels to adjust the extents rectangle outward to accommodate antialiasing kernels. 	
        /// </summary>	
        /// <unmanaged>int StencilCaps</unmanaged>
        public int StencilCaps;
        
        /// <summary>	
        ///  Flags specifying supported stencil-buffer operations. Stencil operations are assumed to be valid for all three stencil-buffer operation render states (D3DRS_STENCILFAIL, D3DRS_STENCILPASS, and D3DRS_STENCILZFAIL). For more information, see {{D3DSTENCILCAPS}}. 	
        /// </summary>	
        /// <unmanaged>int FVFCaps</unmanaged>
        public int FVFCaps;
        
        /// <summary>	
        ///   Flexible vertex format capabilities.  ValueMeaning  D3DFVFCAPS_DONOTSTRIPELEMENTS   It is preferable that vertex elements not be stripped. That is, if the vertex format contains elements that are not used with the current render states, there is no need to regenerate the vertices. If this capability flag is not present, stripping extraneous elements from the vertex format provides better performance.   D3DFVFCAPS_PSIZE   Point size is determined by either the render state or the vertex data. If an FVF is used, point size can come from point size data in the vertex declaration. Otherwise, point size is determined by the render state D3DRS_POINTSIZE. If the application provides point size in both (the render state and the vertex declaration), the vertex data overrides the render-state data.   D3DFVFCAPS_TEXCOORDCOUNTMASK   Masks the low WORD of FVFCaps. These bits, cast to the WORD data type, describe the total number of texture coordinate sets that the device can simultaneously use for multiple texture blending. (You can use up to eight texture coordinate sets for any vertex, but the device can blend using only the specified number of texture coordinate sets.)   ? 	
        /// </summary>	
        /// <unmanaged>int TextureOpCaps</unmanaged>
        public int TextureOpCaps;
        
        /// <summary>	
        ///   Combination of flags describing the texture operations supported by this device. The following flags are defined.  ValueMeaning  D3DTEXOPCAPS_ADD   The D3DTOP_ADD texture-blending operation is supported.   D3DTEXOPCAPS_ADDSIGNED   The D3DTOP_ADDSIGNED texture-blending operation is supported.   D3DTEXOPCAPS_ADDSIGNED2X   The D3DTOP_ADDSIGNED2X texture-blending operation is supported.   D3DTEXOPCAPS_ADDSMOOTH   The D3DTOP_ADDSMOOTH texture-blending operation is supported.   D3DTEXOPCAPS_BLENDCURRENTALPHA   The D3DTOP_BLENDCURRENTALPHA texture-blending operation is supported.   D3DTEXOPCAPS_BLENDDIFFUSEALPHA   The D3DTOP_BLENDDIFFUSEALPHA texture-blending operation is supported.   D3DTEXOPCAPS_BLENDFACTORALPHA   The D3DTOP_BLENDFACTORALPHA texture-blending operation is supported.   D3DTEXOPCAPS_BLENDTEXTUREALPHA   The D3DTOP_BLENDTEXTUREALPHA texture-blending operation is supported.   D3DTEXOPCAPS_BLENDTEXTUREALPHAPM   The D3DTOP_BLENDTEXTUREALPHAPM texture-blending operation is supported.   D3DTEXOPCAPS_BUMPENVMAP   The D3DTOP_BUMPENVMAP texture-blending operation is supported.   D3DTEXOPCAPS_BUMPENVMAPLUMINANCE   The D3DTOP_BUMPENVMAPLUMINANCE texture-blending operation is supported.   D3DTEXOPCAPS_DISABLE   The D3DTOP_DISABLE texture-blending operation is supported.   D3DTEXOPCAPS_DOTPRODUCT3   The D3DTOP_DOTPRODUCT3 texture-blending operation is supported.   D3DTEXOPCAPS_LERP   The D3DTOP_LERP texture-blending operation is supported.   D3DTEXOPCAPS_MODULATE   The D3DTOP_MODULATE texture-blending operation is supported.   D3DTEXOPCAPS_MODULATE2X   The D3DTOP_MODULATE2X texture-blending operation is supported.   D3DTEXOPCAPS_MODULATE4X   The D3DTOP_MODULATE4X texture-blending operation is supported.   D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR   The D3DTOP_MODULATEALPHA_ADDCOLOR texture-blending operation is supported.   D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA   The D3DTOP_MODULATECOLOR_ADDALPHA texture-blending operation is supported.   D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR   The D3DTOP_MODULATEINVALPHA_ADDCOLOR texture-blending operation is supported.   D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA   The D3DTOP_MODULATEINVCOLOR_ADDALPHA texture-blending operation is supported.   D3DTEXOPCAPS_MULTIPLYADD   The D3DTOP_MULTIPLYADD texture-blending operation is supported.   D3DTEXOPCAPS_PREMODULATE   The D3DTOP_PREMODULATE texture-blending operation is supported.   D3DTEXOPCAPS_SELECTARG1   The D3DTOP_SELECTARG1 texture-blending operation is supported.   D3DTEXOPCAPS_SELECTARG2   The D3DTOP_SELECTARG2 texture-blending operation is supported.   D3DTEXOPCAPS_SUBTRACT   The D3DTOP_SUBTRACT texture-blending operation is supported.   ? 	
        /// </summary>	
        /// <unmanaged>int MaxTextureBlendStages</unmanaged>
        public int MaxTextureBlendStages;
        
        /// <summary>	
        ///  Maximum number of texture-blending stages supported in the fixed function pipeline. This value is the number of blenders available. In the programmable pixel pipeline, this corresponds to the number of unique texture registers used by pixel shader instructions.  	
        /// </summary>	
        /// <unmanaged>int MaxSimultaneousTextures</unmanaged>
        public int MaxSimultaneousTextures;
        
        /// <summary>	
        ///  Maximum number of textures that can be simultaneously bound to the fixed-function pipeline sampler stages. If the same texture is bound to two sampler stages, it counts as two textures.  This value has no meaning in the programmable pipeline where the number of sampler stages is determined by each pixel shader version. Each pixel shader version also determines the number of texture declaration instructions. See {{Pixel Shaders}}. 	
        /// </summary>	
        /// <unmanaged>int VertexProcessingCaps</unmanaged>
        public int VertexProcessingCaps;
        
        /// <summary>	
        ///  Vertex processing capabilities. For a given physical device, this capability might vary across Direct3D devices depending on the parameters supplied to {{CreateDevice}}. See {{D3DVTXPCAPS}}. 	
        /// </summary>	
        /// <unmanaged>int MaxActiveLights</unmanaged>
        public int MaxActiveLights;
        
        /// <summary>	
        ///  Maximum number of lights that can be active simultaneously. For a given physical device, this capability might vary across Direct3D devices depending on the parameters supplied to {{CreateDevice}}.  	
        /// </summary>	
        /// <unmanaged>int MaxUserClipPlanes</unmanaged>
        public int MaxUserClipPlanes;
        
        /// <summary>	
        ///  Maximum number of user-defined clipping planes supported. This member can be 0. For a given physical device, this capability may vary across Direct3D devices depending on the parameters supplied to {{CreateDevice}}.  	
        /// </summary>	
        /// <unmanaged>int MaxVertexBlendMatrices</unmanaged>
        public int MaxVertexBlendMatrices;
        
        /// <summary>	
        ///  Maximum number of matrices that this device can apply when performing multimatrix vertex blending. For a given physical device, this capability may vary across Direct3D devices depending on the parameters supplied to {{CreateDevice}}.  	
        /// </summary>	
        /// <unmanaged>int MaxVertexBlendMatrixIndex</unmanaged>
        public int MaxVertexBlendMatrixIndex;
        
        /// <summary>	
        ///  DWORD value that specifies the maximum matrix index that can be indexed into using the per-vertex indices. The number of matrices is MaxVertexBlendMatrixIndex + 1, which is the size of the matrix palette. If normals are present in the vertex data that needs to be blended for lighting, then the number of matrices is half the number specified by this capability flag. If MaxVertexBlendMatrixIndex is set to zero, the driver does not support indexed vertex blending. If this value is not zero then the valid range of indices is zero through MaxVertexBlendMatrixIndex.  A zero value for MaxVertexBlendMatrixIndex indicates that the driver does not support indexed matrices. When software vertex processing is used, 256 matrices could be used for indexed vertex blending, with or without normal blending. For a given physical device, this capability may vary across Direct3D devices depending on the parameters supplied to {{CreateDevice}}. 	
        /// </summary>	
        /// <unmanaged>float MaxPointSize</unmanaged>
        public float MaxPointSize;
        
        /// <summary>	
        ///  Maximum size of a point primitive. If set to 1.0f then device does not support point size control. The range is greater than or equal to 1.0f.  	
        /// </summary>	
        /// <unmanaged>int MaxPrimitiveCount</unmanaged>
        public int MaxPrimitiveCount;
        
        /// <summary>	
        ///  Maximum number of primitives for each {{DrawPrimitive}} call. There are two cases:	
        ///   If MaxPrimitiveCount is not equal to 0xffff, you can draw at most MaxPrimitiveCount primitives with each draw call. However, if MaxPrimitiveCount equals 0xffff, you can still draw at most MaxPrimitiveCount primitive, but you may also use no more than MaxPrimitiveCount unique vertices (since each primitive can potentially use three different vertices).  	
        /// </summary>	
        /// <unmanaged>int MaxVertexIndex</unmanaged>
        public int MaxVertexIndex;
        
        /// <summary>	
        ///  Maximum size of indices supported for hardware vertex processing. It is possible to create 32-bit index buffers; however, you will not be able to render with the index buffer unless this value is greater than 0x0000FFFF.  	
        /// </summary>	
        /// <unmanaged>int MaxStreams</unmanaged>
        public int MaxStreams;
        
        /// <summary>	
        ///  Maximum number of concurrent data streams for {{SetStreamSource}}. The valid range is 1 to 16. Note that if this value is 0, then the driver is not a Direct3D 9 driver.  	
        /// </summary>	
        /// <unmanaged>int MaxStreamStride</unmanaged>
        public int MaxStreamStride;
        
        /// <summary>	
        ///  Maximum stride for {{SetStreamSource}}.  	
        /// </summary>	
        /// <unmanaged>int VertexShaderVersion</unmanaged>
        public int VertexShaderVersion;
        
        /// <summary>	
        ///  Two numbers that represent the vertex shader main and sub versions. For more information about the instructions supported for each vertex shader version, see {{Version 1_x}}, {{Version 2_0}}, {{Version 2_0 Extended}}, or {{Version 3_0}}. 	
        /// </summary>	
        /// <unmanaged>int MaxVertexShaderConst</unmanaged>
        public int MaxVertexShaderConst;
        
        /// <summary>	
        ///  The number of vertex shader {{Vertex Shader Registers}} that are reserved for constants. 	
        /// </summary>	
        /// <unmanaged>int PixelShaderVersion</unmanaged>
        public int PixelShaderVersion;
        
        /// <summary>	
        ///  Two numbers that represent the pixel shader main and sub versions. For more information about the instructions supported for each pixel shader version, see {{Version 1_x}}, {{Version 2_0}}, {{Version 2_0 Extended}}, or {{Version 3_0}}. 	
        /// </summary>	
        /// <unmanaged>float PixelShader1xMaxValue</unmanaged>
        public float PixelShader1xMaxValue;
        
        /// <summary>	
        ///  Maximum value of pixel shader arithmetic component. This value indicates the internal range of values supported for pixel color blending operations. Within the range that they report to, implementations must allow data to pass through pixel processing unmodified (unclamped). Normally, the value of this member is an absolute value. For example, a 1.0 indicates that the range is -1.0 to 1, and an 8.0 indicates that the range is -8.0 to 8.0. The value must be &gt;= 1.0 for any hardware that supports pixel shaders. 	
        /// </summary>	
        /// <unmanaged>int DevCaps2</unmanaged>
        public int DevCaps2;
        
        /// <summary>	
        ///  Device driver capabilities for adaptive tessellation. For more information, see {{D3DDEVCAPS2}}  	
        /// </summary>	
        /// <unmanaged>float MaxNpatchTessellationLevel</unmanaged>
        public float MaxNpatchTessellationLevel;
        
        /// <summary>	
        ///  This number indicates which device is the master for this subordinate. This number is taken from the same space as the adapter values. For multihead support, one head will be denoted the master head, and all other heads on the same card will be denoted subordinate heads. If more than one multihead adapter is present in a system, the master and its subordinates from one multihead adapter are called a group. 	
        /// </summary>	
        /// <unmanaged>int Reserved5</unmanaged>
        public int Reserved5;
        
        /// <summary>	
        ///  This number indicates the order in which heads are referenced by the API. The value for the master adapter is always 0. These values do not correspond to the adapter ordinals. They apply only to heads within a group.  	
        /// </summary>	
        /// <unmanaged>UINT MasterAdapterOrdinal</unmanaged>
        public int MasterAdapterOrdinal;
        
        /// <summary>	
        ///  Number of adapters in this adapter group (only if master). This will be 1 for conventional adapters. The value will be greater than 1 for the master adapter of a  multihead card. The value will be 0 for a subordinate adapter of a multihead card. Each card can have at most one master, but may have many subordinates. 	
        /// </summary>	
        /// <unmanaged>UINT AdapterOrdinalInGroup</unmanaged>
        public int AdapterOrdinalInGroup;
        
        /// <summary>	
        ///  A combination of one or more data types contained in a vertex declaration. See {{D3DDTCAPS}}. 	
        /// </summary>	
        /// <unmanaged>UINT NumberOfAdaptersInGroup</unmanaged>
        public int NumberOfAdaptersInGroup;
        
        /// <summary>	
        ///  Number of simultaneous render targets. This number must be at least one. 	
        /// </summary>	
        /// <unmanaged>int DeclTypes</unmanaged>
        public int DeclTypes;
        
        /// <summary>	
        ///  Combination of constants that describe the operations supported by {{StretchRect}}. The flags that may be set in this field are:  ConstantDescription D3DPTFILTERCAPS_MINFPOINTDevice supports point-sample filtering for minifying rectangles.  This filter type is requested by calling {{StretchRect}} using D3DTEXF_POINT. D3DPTFILTERCAPS_MAGFPOINTDevice supports point-sample filtering for magnifying rectangles.  This filter type is requested by calling {{StretchRect}} using D3DTEXF_POINT. D3DPTFILTERCAPS_MINFLINEARDevice supports bilinear interpolation filtering for minifying rectangles.  This filter type is requested by calling {{StretchRect}} using D3DTEXF_LINEAR. D3DPTFILTERCAPS_MAGFLINEARDevice supports bilinear interpolation filtering for magnifying rectangles.  This filter type is requested by calling {{StretchRect}} using D3DTEXF_LINEAR.  ? For more information, see <see cref="SlimDX2.Direct3D9.TextureFilter"/> and D3DTEXTUREFILTERTYPE. 	
        /// </summary>	
        /// <unmanaged>int NumSimultaneousRTs</unmanaged>
        public int NumSimultaneousRTs;
        
        /// <summary>	
        ///  Device supports vertex shader version 2_0 extended capability. See <see cref="SlimDX2.Direct3D9.VertexShader20Caps"/>. 	
        /// </summary>	
        /// <unmanaged>int StretchRectFilterCaps</unmanaged>
        public int StretchRectFilterCaps;
        
        /// <summary>	
        ///  Device supports pixel shader version 2_0 extended capability. See <see cref="SlimDX2.Direct3D9.PixelShader20Caps"/>. 	
        /// </summary>	
        /// <unmanaged>D3DVSHADERCAPS2_0 VS20Caps</unmanaged>
        public SlimDX2.Direct3D9.VertexShader20Caps VS20Caps;
        
        /// <summary>	
        ///  Device supports vertex shader texture filter capability. See {{D3DPTFILTERCAPS}}. 	
        /// </summary>	
        /// <unmanaged>D3DPSHADERCAPS2_0 PS20Caps</unmanaged>
        public SlimDX2.Direct3D9.PixelShader20Caps PS20Caps;
        
        /// <summary>	
        ///  Maximum number of vertex shader instructions that can be run when using flow control. The maximum number of instructions that can be programmed is MaxVertexShader30InstructionSlots. 	
        /// </summary>	
        /// <unmanaged>int VertexTextureFilterCaps</unmanaged>
        public int VertexTextureFilterCaps;
        
        /// <summary>	
        ///  Maximum number of pixel shader instructions that can be run when using flow control. The maximum number of instructions that can be programmed is MaxPixelShader30InstructionSlots. 	
        /// </summary>	
        /// <unmanaged>int MaxVShaderInstructionsExecuted</unmanaged>
        public int MaxVShaderInstructionsExecuted;
        
        /// <summary>	
        ///  Maximum number of vertex shader instruction slots supported. The maximum value that can be set on this cap is 32768. Devices that support vs_3_0 are required to support at least 512 instruction slots. 	
        /// </summary>	
        /// <unmanaged>int MaxPShaderInstructionsExecuted</unmanaged>
        public int MaxPShaderInstructionsExecuted;
        
        /// <summary>	
        ///  Maximum number of pixel shader instruction slots supported. The maximum value that can be set on this cap is 32768. Devices that support ps_3_0 are required to support at least 512 instruction slots. 	
        /// </summary>	
        /// <unmanaged>int MaxVertexShader30InstructionSlots</unmanaged>
        public int MaxVertexShader30InstructionSlots;
        
        /// <summary>	
        ///  Reserved. 	
        /// </summary>	
        /// <unmanaged>int MaxPixelShader30InstructionSlots</unmanaged>
        public int MaxPixelShader30InstructionSlots;
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DXFONT_DESCW</unmanaged>
    public  partial struct FontDescription {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>INT Height</unmanaged>
        public int Height;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT Width</unmanaged>
        public int Width;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT Weight</unmanaged>
        public int Weight;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT MipLevels</unmanaged>
        public int MipLevels;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>BOOL Italic</unmanaged>
        public bool Italic { 
            get { 
                return (_Italic!=0)?true:false; 
            }
            set { 
                _Italic = value?1:0;
            }
        }
        internal int _Italic;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>byte CharSet</unmanaged>
        public byte CharSet;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>byte OutputPrecision</unmanaged>
        public byte OutputPrecision;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>byte Quality</unmanaged>
        public byte Quality;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>byte PitchAndFamily</unmanaged>
        public byte PitchAndFamily;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>wchar FaceName[32]</unmanaged>
        public string FaceName;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public int Height;
            public int Width;
            public int Weight;
            public int MipLevels;
            public int _Italic;
            public byte CharSet;
            public byte OutputPrecision;
            public byte Quality;
            public byte PitchAndFamily;
            public fixed char FaceName[32];
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Height = @ref.Height;
            this.Width = @ref.Width;
            this.Weight = @ref.Weight;
            this.MipLevels = @ref.MipLevels;
            this._Italic = @ref._Italic;
            this.CharSet = @ref.CharSet;
            this.OutputPrecision = @ref.OutputPrecision;
            this.Quality = @ref.Quality;
            this.PitchAndFamily = @ref.PitchAndFamily;
            fixed (char* __ptr = @ref.FaceName) this.FaceName = new string(__ptr, 0, 32);
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Height = this.Height;
            @ref.Width = this.Width;
            @ref.Weight = this.Weight;
            @ref.MipLevels = this.MipLevels;
            @ref._Italic = this._Italic;
            @ref.CharSet = this.CharSet;
            @ref.OutputPrecision = this.OutputPrecision;
            @ref.Quality = this.Quality;
            @ref.PitchAndFamily = this.PitchAndFamily;
            fixed (char* __psrc = this.FaceName) fixed (char* __ptr = @ref.FaceName) Utilities.CopyMemory((IntPtr)__ptr, (IntPtr)__psrc, FaceName.Length * 2);
		
		}
    }
    
    /// <summary>	
    /// Describes a render surface.	
    /// </summary>	
    /// <unmanaged>D3DXRTS_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct RenderToSurfaceDescription {	
        
        /// <summary>	
        ///  Width of the render surface, in pixels. 	
        /// </summary>	
        /// <unmanaged>UINT Width</unmanaged>
        public int Width;
        
        /// <summary>	
        ///  Height of the render surface, in pixels. 	
        /// </summary>	
        /// <unmanaged>UINT Height</unmanaged>
        public int Height;
        
        /// <summary>	
        ///  Member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type, describing the pixel format of the render surface. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        ///  If TRUE, the render surface supports a depth-stencil surface; otherwise this member is set to FALSE. 	
        /// </summary>	
        /// <unmanaged>BOOL DepthStencil</unmanaged>
        public bool DepthStencil { 
            get { 
                return (_DepthStencil!=0)?true:false; 
            }
            set { 
                _DepthStencil = value?1:0;
            }
        }
        internal int _DepthStencil;
        
        /// <summary>	
        ///  If DepthStencil is set to TRUE, this parameter is a member of the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type,  describing the depth-stencil format of the render surface. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT DepthStencilFormat</unmanaged>
        public SlimDX2.Direct3D9.Format DepthStencilFormat;
    }
    
    /// <summary>	
    /// Describes an off-screen render target used by an instance of <see cref="SlimDX2.Direct3D9.RenderToEnvironmentMap"/>.	
    /// </summary>	
    /// <remarks>	
    ///  This method is used to return the creation parameters used when creating an <see cref="SlimDX2.Direct3D9.RenderToEnvironmentMap"/> object. 	
    /// </remarks>	
    /// <unmanaged>D3DXRTE_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct RenderToEnvironmentMapDescription {	
        
        /// <summary>	
        ///  Width and height in pixels. 	
        /// </summary>	
        /// <unmanaged>UINT Size</unmanaged>
        public int Size;
        
        /// <summary>	
        ///  Maximum level of detail (LOD) number. 	
        /// </summary>	
        /// <unmanaged>UINT MipLevels</unmanaged>
        public int MipLevels;
        
        /// <summary>	
        ///  Color buffer format. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        ///  Indicates if the z-buffer is needed. 	
        /// </summary>	
        /// <unmanaged>BOOL DepthStencil</unmanaged>
        public bool DepthStencil { 
            get { 
                return (_DepthStencil!=0)?true:false; 
            }
            set { 
                _DepthStencil = value?1:0;
            }
        }
        internal int _DepthStencil;
        
        /// <summary>	
        ///  Format of the depth buffer. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT DepthStencilFormat</unmanaged>
        public SlimDX2.Direct3D9.Format DepthStencilFormat;
    }
    
    /// <summary>	
    /// Stores an attribute table entry.	
    /// </summary>	
    /// <remarks>	
    ///  An attribute table is used to identify areas of the mesh that need to be drawn with different textures, render states, materials, and so on.  In addition, the application can use the attribute table to hide portions of a mesh by not drawing a given attribute identifier (AttribId) when drawing the frame. The LPD3DXATTRIBUTERANGE type is defined as a pointer to the D3DXATTRIBUTERANGE structure.  	
    /// <code> typedef D3DXATTRIBUTERANGE* LPD3DXATTRIBUTERANGE; </code>	
    /// 	
    ///  	
    /// </remarks>	
    /// <unmanaged>D3DXATTRIBUTERANGE</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct AttributeRange {	
        
        /// <summary>	
        ///  Attribute table identifier. 	
        /// </summary>	
        /// <unmanaged>int AttribId</unmanaged>
        public int AttribId;
        
        /// <summary>	
        ///  Starting face. 	
        /// </summary>	
        /// <unmanaged>int FaceStart</unmanaged>
        public int FaceStart;
        
        /// <summary>	
        ///  Face count. 	
        /// </summary>	
        /// <unmanaged>int FaceCount</unmanaged>
        public int FaceCount;
        
        /// <summary>	
        ///  Starting vertex. 	
        /// </summary>	
        /// <unmanaged>int VertexStart</unmanaged>
        public int VertexStart;
        
        /// <summary>	
        ///  Vertex count. 	
        /// </summary>	
        /// <unmanaged>int VertexCount</unmanaged>
        public int VertexCount;
    }
    
    /// <summary>	
    /// Returns material information saved in Direct3D (.x) files.	
    /// </summary>	
    /// <remarks>	
    ///  The {{D3DXLoadMeshFromX}} and <see cref="SlimDX2.Direct3D9.D3DX9.LoadMeshFromXof"/> functions return an array of D3DXMATERIAL structures  that specify the material color and name of the texture for each material in the mesh. The application is then required to load the texture. The LPD3DXMATERIAL type is defined as a pointer to the D3DXMATERIAL structure.  	
    /// <code> typedef struct D3DXMATERIAL* LPD3DXMATERIAL; </code>	
    /// 	
    ///  	
    /// </remarks>	
    /// <unmanaged>D3DXMATERIAL</unmanaged>
    public  partial struct ExtendedMaterial {	
        
        /// <summary>	
        ///   <see cref="SlimDX2.Direct3D9.Material"/> structure that describes the material properties. 	
        /// </summary>	
        /// <unmanaged>D3DMATERIAL9 MatD3D</unmanaged>
        public SlimDX2.Direct3D9.Material MatD3D;
        
        /// <summary>	
        ///  Pointer to a string that specifies the file name of the texture. 	
        /// </summary>	
        /// <unmanaged>LPSTR pTextureFilename</unmanaged>
        public string PTextureFilename;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public SlimDX2.Direct3D9.Material MatD3D;
            public IntPtr PTextureFilename;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.PTextureFilename != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.PTextureFilename);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.MatD3D = @ref.MatD3D;
            this.PTextureFilename = ( @ref.PTextureFilename == IntPtr.Zero )?null:new string((sbyte*)@ref.PTextureFilename);
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.MatD3D = this.MatD3D;
            @ref.PTextureFilename = ( this.PTextureFilename == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.PTextureFilename);
		
		}
    }
    
    /// <summary>	
    /// Effect default parameters.	
    /// </summary>	
    /// <unmanaged>D3DXEFFECTDEFAULT</unmanaged>
    public  partial struct EffectDefault {	
        
        /// <summary>	
        ///  Parameter name. 	
        /// </summary>	
        /// <unmanaged>LPSTR pParamName</unmanaged>
        public string PParamName;
        
        /// <summary>	
        ///  Data type in pValue. For more information, see <see cref="SlimDX2.Direct3D9.EffectDefaultType"/>  	
        /// </summary>	
        /// <unmanaged>D3DXEFFECTDEFAULTTYPE Type</unmanaged>
        public SlimDX2.Direct3D9.EffectDefaultType Type;
        
        /// <summary>	
        ///  Size, in bytes, of the data pointed to by pValue. 	
        /// </summary>	
        /// <unmanaged>int NumBytes</unmanaged>
        public int NumBytes;
        
        /// <summary>	
        ///  Pointer to the memory location that contains the data. 	
        /// </summary>	
        /// <unmanaged>void* pValue</unmanaged>
        public IntPtr PValue;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr PParamName;
            public SlimDX2.Direct3D9.EffectDefaultType Type;
            public int NumBytes;
            public IntPtr PValue;
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.PParamName = ( @ref.PParamName == IntPtr.Zero )?null:new string((sbyte*)@ref.PParamName);
            this.Type = @ref.Type;
            this.NumBytes = @ref.NumBytes;
            this.PValue = @ref.PValue;
        }
    }
    
    /// <summary>	
    /// Data type for managing a set of default effect parameters.	
    /// </summary>	
    /// <unmanaged>D3DXEFFECTINSTANCE</unmanaged>
    public  partial struct EffectInstance {	
        
        /// <summary>	
        ///  Name of the effect file. 	
        /// </summary>	
        /// <unmanaged>LPSTR pEffectFilename</unmanaged>
        public string PEffectFilename;
        
        /// <summary>	
        ///  Number of default parameters. 	
        /// </summary>	
        /// <unmanaged>int NumDefaults</unmanaged>
        public int NumDefaults;
        
        /// <summary>	
        ///  Pointer to an array of <see cref="SlimDX2.Direct3D9.EffectDefault"/> elements, each of which contains an  effect parameter. 	
        /// </summary>	
        /// <unmanaged>LPD3DXEFFECTDEFAULT pDefaults</unmanaged>
        public IntPtr PDefaults;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr PEffectFilename;
            public int NumDefaults;
            public IntPtr PDefaults;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.PEffectFilename != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.PEffectFilename);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.PEffectFilename = ( @ref.PEffectFilename == IntPtr.Zero )?null:new string((sbyte*)@ref.PEffectFilename);
            this.NumDefaults = @ref.NumDefaults;
            this.PDefaults = @ref.PDefaults;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.PEffectFilename = ( this.PEffectFilename == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.PEffectFilename);
            @ref.NumDefaults = this.NumDefaults;
            @ref.PDefaults = this.PDefaults;
		
		}
    }
    
    /// <summary>	
    /// Specifies mesh weight attributes.	
    /// </summary>	
    /// <remarks>	
    ///  This structure describes how a simplification operation will consider vertex data when calculating relative costs between collapsing edges.  For example, if the Normal field is 0.0, the simplification operation will ignore the vertex normal component when calculating the error for the collapse.  However, if the Normal field is 1.0, the simplification operation will use the vertex normal component. If the Normal field is 2.0, double the amount of errors;  if the Normal field is 4.0, then quadruple the number of errors, and so on. The LPD3DXATTRIBUTEWEIGHTS type is defined as a pointer to the D3DXATTRIBUTEWEIGHTS structure.  	
    /// <code> typedef D3DXATTRIBUTEWEIGHTS* LPD3DXATTRIBUTEWEIGHTS; </code>	
    /// 	
    ///  	
    /// </remarks>	
    /// <unmanaged>D3DXATTRIBUTEWEIGHTS</unmanaged>
    public  partial struct AttributeWeights {	
        
        /// <summary>	
        ///  Position. 	
        /// </summary>	
        /// <unmanaged>FLOAT Position</unmanaged>
        public float Position;
        
        /// <summary>	
        ///  Blend weight. 	
        /// </summary>	
        /// <unmanaged>FLOAT Boundary</unmanaged>
        public float Boundary;
        
        /// <summary>	
        ///  Normal. 	
        /// </summary>	
        /// <unmanaged>FLOAT Normal</unmanaged>
        public float Normal;
        
        /// <summary>	
        ///  Diffuse lighting value. 	
        /// </summary>	
        /// <unmanaged>FLOAT Diffuse</unmanaged>
        public float Diffuse;
        
        /// <summary>	
        ///  Specular lighting value. 	
        /// </summary>	
        /// <unmanaged>FLOAT Specular</unmanaged>
        public float Specular;
        
        /// <summary>	
        ///  Eight texture coordinates. 	
        /// </summary>	
        /// <unmanaged>FLOAT Texcoord[8]</unmanaged>
        public float[] Texcoord { 
            get { 
                if (_Texcoord == null) {
                    _Texcoord = new float[8];
                }
                return _Texcoord; 
            }
        }
        internal float[] _Texcoord;
        
        /// <summary>	
        ///  Tangent. 	
        /// </summary>	
        /// <unmanaged>FLOAT Tangent</unmanaged>
        public float Tangent;
        
        /// <summary>	
        ///  Binormal. 	
        /// </summary>	
        /// <unmanaged>FLOAT Binormal</unmanaged>
        public float Binormal;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public float Position;
            public float Boundary;
            public float Normal;
            public float Diffuse;
            public float Specular;
            public fixed float Texcoord[8];
            public float Tangent;
            public float Binormal;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Position = @ref.Position;
            this.Boundary = @ref.Boundary;
            this.Normal = @ref.Normal;
            this.Diffuse = @ref.Diffuse;
            this.Specular = @ref.Specular;
            fixed (void* __to = &this.Texcoord[0]) fixed (void* __from = @ref.Texcoord) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 8*sizeof ( float));
            this.Tangent = @ref.Tangent;
            this.Binormal = @ref.Binormal;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Position = this.Position;
            @ref.Boundary = this.Boundary;
            @ref.Normal = this.Normal;
            @ref.Diffuse = this.Diffuse;
            @ref.Specular = this.Specular;
            fixed (void* __to = @ref.Texcoord) fixed (void* __from = &this.Texcoord[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 8*sizeof ( float));
            @ref.Tangent = this.Tangent;
            @ref.Binormal = this.Binormal;
		
		}
    }
    
    /// <summary>	
    /// Specifies tolerance values for each vertex component when comparing vertices to determine if they are similar enough to be welded together.	
    /// </summary>	
    /// <remarks>	
    ///  The LPD3DXWeldEpsilons type is defined as a pointer to the D3DXWeldEpsilons structure. 	
    /// <code> typedef D3DXWELDEPSILONS *LPD3DXWELDEPSILONS; </code>	
    /// 	
    ///  	
    /// </remarks>	
    /// <unmanaged>D3DXWELDEPSILONS</unmanaged>
    public  partial struct WeldEpsilons {	
        
        /// <summary>	
        ///  Position 	
        /// </summary>	
        /// <unmanaged>FLOAT Position</unmanaged>
        public float Position;
        
        /// <summary>	
        ///  Blend weight 	
        /// </summary>	
        /// <unmanaged>FLOAT BlendWeights</unmanaged>
        public float BlendWeights;
        
        /// <summary>	
        ///  Normal 	
        /// </summary>	
        /// <unmanaged>FLOAT Normal</unmanaged>
        public float Normal;
        
        /// <summary>	
        ///  Point size value 	
        /// </summary>	
        /// <unmanaged>FLOAT PSize</unmanaged>
        public float PSize;
        
        /// <summary>	
        ///  Specular lighting value 	
        /// </summary>	
        /// <unmanaged>FLOAT Specular</unmanaged>
        public float Specular;
        
        /// <summary>	
        ///  Diffuse lighting value 	
        /// </summary>	
        /// <unmanaged>FLOAT Diffuse</unmanaged>
        public float Diffuse;
        
        /// <summary>	
        ///  Eight texture coordinates 	
        /// </summary>	
        /// <unmanaged>FLOAT Texcoord[8]</unmanaged>
        public float[] Texcoord { 
            get { 
                if (_Texcoord == null) {
                    _Texcoord = new float[8];
                }
                return _Texcoord; 
            }
        }
        internal float[] _Texcoord;
        
        /// <summary>	
        ///  Tangent 	
        /// </summary>	
        /// <unmanaged>FLOAT Tangent</unmanaged>
        public float Tangent;
        
        /// <summary>	
        ///  Binormal 	
        /// </summary>	
        /// <unmanaged>FLOAT Binormal</unmanaged>
        public float Binormal;
        
        /// <summary>	
        ///  Tessellation factor 	
        /// </summary>	
        /// <unmanaged>FLOAT TessFactor</unmanaged>
        public float TessFactor;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public float Position;
            public float BlendWeights;
            public float Normal;
            public float PSize;
            public float Specular;
            public float Diffuse;
            public fixed float Texcoord[8];
            public float Tangent;
            public float Binormal;
            public float TessFactor;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Position = @ref.Position;
            this.BlendWeights = @ref.BlendWeights;
            this.Normal = @ref.Normal;
            this.PSize = @ref.PSize;
            this.Specular = @ref.Specular;
            this.Diffuse = @ref.Diffuse;
            fixed (void* __to = &this.Texcoord[0]) fixed (void* __from = @ref.Texcoord) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 8*sizeof ( float));
            this.Tangent = @ref.Tangent;
            this.Binormal = @ref.Binormal;
            this.TessFactor = @ref.TessFactor;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Position = this.Position;
            @ref.BlendWeights = this.BlendWeights;
            @ref.Normal = this.Normal;
            @ref.PSize = this.PSize;
            @ref.Specular = this.Specular;
            @ref.Diffuse = this.Diffuse;
            fixed (void* __to = @ref.Texcoord) fixed (void* __from = &this.Texcoord[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 8*sizeof ( float));
            @ref.Tangent = this.Tangent;
            @ref.Binormal = this.Binormal;
            @ref.TessFactor = this.TessFactor;
		
		}
    }
    
    /// <summary>	
    /// Describes a subset of the mesh that has the same attribute and bone combination.	
    /// </summary>	
    /// <remarks>	
    ///  The subset of the mesh described by D3DXBONECOMBINATION can be rendered in a single drawing call. 	
    /// </remarks>	
    /// <unmanaged>D3DXBONECOMBINATION</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct BoneCombination {	
        
        /// <summary>	
        ///  Attribute table identifier. 	
        /// </summary>	
        /// <unmanaged>int AttribId</unmanaged>
        public int AttribId;
        
        /// <summary>	
        ///  Starting face. 	
        /// </summary>	
        /// <unmanaged>int FaceStart</unmanaged>
        public int FaceStart;
        
        /// <summary>	
        ///  Face count. 	
        /// </summary>	
        /// <unmanaged>int FaceCount</unmanaged>
        public int FaceCount;
        
        /// <summary>	
        ///  Starting vertex. 	
        /// </summary>	
        /// <unmanaged>int VertexStart</unmanaged>
        public int VertexStart;
        
        /// <summary>	
        ///  Vertex count. 	
        /// </summary>	
        /// <unmanaged>int VertexCount</unmanaged>
        public int VertexCount;
        
        /// <summary>	
        ///  Pointer to an array of values that identify each of the bones that can be drawn in a single drawing call.  Note that the array can be of variable length to accommodate variable length bone combinations of {{ConvertToIndexedBlendedMesh}}.   The size of the array varies based on the type of mesh generated. A non-indexed mesh array size is equal to the number of weights per  vertex (pMaxVertexInfl in {{ConvertToBlendedMesh}}). An indexed mesh array size is equal to the number of bone matrix  palette entries (paletteSize in {{ConvertToIndexedBlendedMesh}}). 	
        /// </summary>	
        /// <unmanaged>int* BoneId</unmanaged>
        public IntPtr BoneId;
    }
    
    /// <summary>	
    /// Structure that contains the attributes of a patch mesh.	
    /// </summary>	
    /// <remarks>	
    ///  A mesh is a set of faces, each of which is described by a simple polygon. Objects can be created by connecting several meshes together.  A patch mesh is constructed from patches. A patch is a four-sided piece of geometry constructed from curves.  The type of curve used and the order of the curve can be varied so that the patch surface will fit almost any surface shape. The following types of patch combinations are supported:  Patch TypeBasisDegree RectangleBezier2,3,5 RectangleB-Spline2,3,5 RectangleCatmull-Rom3 TriangleBezier2,3,5 N-patchN/A3  ? 	
    /// </remarks>	
    /// <unmanaged>D3DXPATCHINFO</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct PatchInfo {	
        
        /// <summary>	
        ///  The patch type. For information about patch types, see <see cref="SlimDX2.Direct3D9.PatchMeshType"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXPATCHMESHTYPE PatchType</unmanaged>
        public SlimDX2.Direct3D9.PatchMeshType PatchType;
        
        /// <summary>	
        ///  Degree of the curves used to construct the patch. For information about the degrees supported, see <see cref="SlimDX2.Direct3D9.Degree"/>. 	
        /// </summary>	
        /// <unmanaged>D3DDEGREETYPE Degree</unmanaged>
        public SlimDX2.Direct3D9.Degree Degree;
        
        /// <summary>	
        ///  Type of curve used to construct the patch. For information about the basis types supported, see <see cref="SlimDX2.Direct3D9.Basis"/>. 	
        /// </summary>	
        /// <unmanaged>D3DBASISTYPE Basis</unmanaged>
        public SlimDX2.Direct3D9.Basis Basis;
    }
    
    /// <summary>	
    /// Identifies compressed key frame animation data.	
    /// </summary>	
    /// <unmanaged>XFILECOMPRESSEDANIMATIONSET</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 1 )]
    public  partial struct Xfilecompressedanimationset {	
        
        /// <summary>	
        ///  Total size, in bytes, of the compressed data in the compressed key frame animation data buffer. 	
        /// </summary>	
        /// <unmanaged>int CompressedBlockSize</unmanaged>
        public int CompressedBlockSize;
        
        /// <summary>	
        ///  Number of animation key frame ticks that occur per second. 	
        /// </summary>	
        /// <unmanaged>FLOAT TicksPerSec</unmanaged>
        public float TicksPerSec;
        
        /// <summary>	
        ///  Type of the animation set playback loop. See <see cref="SlimDX2.Direct3D9.PlaybackType"/>. 	
        /// </summary>	
        /// <unmanaged>int PlaybackType</unmanaged>
        public int PlaybackType;
        
        /// <summary>	
        ///  Minimum buffer size, in bytes, required to hold compressed key frame animation data. Value is equal to ( ( CompressedBlockSize + 3 ) / 4 ). 	
        /// </summary>	
        /// <unmanaged>int BufferLength</unmanaged>
        public int BufferLength;
    }
    
    /// <summary>	
    /// Describes preprocessor definitions used by an effect object.	
    /// </summary>	
    /// <remarks>	
    ///  To use D3DXMACROs in more than one line, prefix each new line character with a backslash (like a #define in the C language). For example: 	
    /// <code> sample=	
    /// macro.Name = "DO_CODE_BLOCK";	
    /// macro.Definition = "/* here is a block of code */\\\n" "{ do something ... }\\\n"; </code>	
    /// 	
    ///  Notice the 3 backslash characters at the end of the line. The first two are required to output a single '\', followed by the newline character "\n". Optionally, you may also want to terminate your lines using "\\\r\n". 	
    /// </remarks>	
    /// <unmanaged>D3DXMACRO</unmanaged>
    public  partial struct Macro {	
        
        /// <summary>	
        ///  Preprocessor name. 	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        ///  Definition name. 	
        /// </summary>	
        /// <unmanaged>const char* Definition</unmanaged>
        public string Definition;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public IntPtr Definition;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
                if (this.Definition != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Definition);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.Definition = ( @ref.Definition == IntPtr.Zero )?null:new string((sbyte*)@ref.Definition);
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.Definition = ( this.Definition == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Definition);
		
		}
    }
    
    /// <summary>	
    /// Semantics map a parameter to vertex or pixel shader registers. They can also be optional descriptive strings attached to non-register parameters.  	
    /// </summary>	
    /// <remarks>	
    ///  Semantics are required for vertex and pixel shader, input and output registers. 	
    /// </remarks>	
    /// <unmanaged>D3DXSEMANTIC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ShaderSemantic {	
        
        /// <summary>	
        ///  Options that identify how resources are used. See <see cref="SlimDX2.Direct3D9.DeclarationUsage"/>. 	
        /// </summary>	
        /// <unmanaged>UINT Usage</unmanaged>
        public int Usage;
        
        /// <summary>	
        ///  Options that modify how the usage is interpreted. The usage and usage index make up a vertex declaration. See {{Vertex Declaration (Direct3D 9)}}. 	
        /// </summary>	
        /// <unmanaged>UINT UsageIndex</unmanaged>
        public int UsageIndex;
    }
    
    /// <summary>	
    /// A description of the constant table.	
    /// </summary>	
    /// <unmanaged>D3DXCONSTANTTABLE_DESC</unmanaged>
    public  partial struct ConstantTableDescription {	
        
        /// <summary>	
        ///  Name of the constant table creator. 	
        /// </summary>	
        /// <unmanaged>const char* Creator</unmanaged>
        public string Creator;
        
        /// <summary>	
        ///  Shader version. 	
        /// </summary>	
        /// <unmanaged>int Version</unmanaged>
        public int Version;
        
        /// <summary>	
        ///  Number of constants in the constant table. 	
        /// </summary>	
        /// <unmanaged>UINT Constants</unmanaged>
        public int Constants;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Creator;
            public int Version;
            public int Constants;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Creator != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Creator);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Creator = ( @ref.Creator == IntPtr.Zero )?null:new string((sbyte*)@ref.Creator);
            this.Version = @ref.Version;
            this.Constants = @ref.Constants;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Creator = ( this.Creator == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Creator);
            @ref.Version = this.Version;
            @ref.Constants = this.Constants;
		
		}
    }
    
    /// <summary>	
    /// A description of a constant in a constant table.	
    /// </summary>	
    /// <unmanaged>D3DXCONSTANT_DESC</unmanaged>
    public  partial struct ConstantDescription {	
        
        /// <summary>	
        ///  Name of the constant. 	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        ///  Constant data type. See <see cref="SlimDX2.Direct3D9.RegisterSet"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXREGISTER_SET RegisterSet</unmanaged>
        public SlimDX2.Direct3D9.RegisterSet RegisterSet;
        
        /// <summary>	
        ///  Zero-based index of the constant in the table. 	
        /// </summary>	
        /// <unmanaged>UINT RegisterIndex</unmanaged>
        public int RegisterIndex;
        
        /// <summary>	
        ///  Number of registers that contain data. 	
        /// </summary>	
        /// <unmanaged>UINT RegisterCount</unmanaged>
        public int RegisterCount;
        
        /// <summary>	
        ///  Parameter class. See <see cref="SlimDX2.Direct3D9.ParameterClass"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXPARAMETER_CLASS Class</unmanaged>
        public SlimDX2.Direct3D9.ParameterClass Class;
        
        /// <summary>	
        ///  Parameter type. See <see cref="SlimDX2.Direct3D9.ParameterType"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXPARAMETER_TYPE Type</unmanaged>
        public SlimDX2.Direct3D9.ParameterType Type;
        
        /// <summary>	
        ///  Number of rows. 	
        /// </summary>	
        /// <unmanaged>UINT Rows</unmanaged>
        public int Rows;
        
        /// <summary>	
        ///  Number of columns. 	
        /// </summary>	
        /// <unmanaged>UINT Columns</unmanaged>
        public int Columns;
        
        /// <summary>	
        ///  Number of elements in the array. 	
        /// </summary>	
        /// <unmanaged>UINT Elements</unmanaged>
        public int Elements;
        
        /// <summary>	
        ///  Number of structure member sub-parameters. 	
        /// </summary>	
        /// <unmanaged>UINT StructMembers</unmanaged>
        public int StructMembers;
        
        /// <summary>	
        ///  Data size in number of bytes. 	
        /// </summary>	
        /// <unmanaged>UINT Bytes</unmanaged>
        public int Bytes;
        
        /// <summary>	
        ///  Pointer to the default value. 	
        /// </summary>	
        /// <unmanaged>LPCVOID DefaultValue</unmanaged>
        public IntPtr DefaultValue;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public SlimDX2.Direct3D9.RegisterSet RegisterSet;
            public int RegisterIndex;
            public int RegisterCount;
            public SlimDX2.Direct3D9.ParameterClass Class;
            public SlimDX2.Direct3D9.ParameterType Type;
            public int Rows;
            public int Columns;
            public int Elements;
            public int StructMembers;
            public int Bytes;
            public IntPtr DefaultValue;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.RegisterSet = @ref.RegisterSet;
            this.RegisterIndex = @ref.RegisterIndex;
            this.RegisterCount = @ref.RegisterCount;
            this.Class = @ref.Class;
            this.Type = @ref.Type;
            this.Rows = @ref.Rows;
            this.Columns = @ref.Columns;
            this.Elements = @ref.Elements;
            this.StructMembers = @ref.StructMembers;
            this.Bytes = @ref.Bytes;
            this.DefaultValue = @ref.DefaultValue;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.RegisterSet = this.RegisterSet;
            @ref.RegisterIndex = this.RegisterIndex;
            @ref.RegisterCount = this.RegisterCount;
            @ref.Class = this.Class;
            @ref.Type = this.Type;
            @ref.Rows = this.Rows;
            @ref.Columns = this.Columns;
            @ref.Elements = this.Elements;
            @ref.StructMembers = this.StructMembers;
            @ref.Bytes = this.Bytes;
            @ref.DefaultValue = this.DefaultValue;
		
		}
    }
    
    /// <summary>	
    /// Helper structure for managing a shader constant table. This can also be done using <see cref="SlimDX2.Direct3D9.ConstantTable"/>.	
    /// </summary>	
    /// <remarks>	
    ///  Shader constant information is included in a tab-delimited table of comments.  All offsets are measured in bytes from the beginning of the structure.  Entries in the constant table are sorted by Creator in ascending order. A shader constant table can be managed with the <see cref="SlimDX2.Direct3D9.ConstantTable"/> interfaces.  Alternatively, you can manage the constant table with D3DXSHADER_CONSTANTTABLE. This size member is often initialized using the following: 	
    /// <code> D3DXSHADER_CONSTANTTABLE constantTable;	
    /// constantTable.Size = sizeof(D3DXSHADER_CONSTANTTABLE) </code>	
    /// 	
    ///  	
    /// </remarks>	
    /// <unmanaged>D3DXSHADER_CONSTANTTABLE</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ShaderConstanttable {	
        
        /// <summary>	
        ///  Size of the structure. See Remarks. 	
        /// </summary>	
        /// <unmanaged>int Size</unmanaged>
        public int Size;
        
        /// <summary>	
        ///  Offset from the beginning of this structure, in bytes, to the string that contains the name of the creator. 	
        /// </summary>	
        /// <unmanaged>int Creator</unmanaged>
        public int Creator;
        
        /// <summary>	
        ///  Shader version. 	
        /// </summary>	
        /// <unmanaged>int Version</unmanaged>
        public int Version;
        
        /// <summary>	
        ///  Number of constants. 	
        /// </summary>	
        /// <unmanaged>int Constants</unmanaged>
        public int Constants;
        
        /// <summary>	
        ///  Array of constant information, D3DXSHADER_CONSTANTINFO[Constants]. See <see cref="SlimDX2.Direct3D9.ShaderConstantinfo"/>. 	
        /// </summary>	
        /// <unmanaged>int ConstantInfo</unmanaged>
        public int ConstantInfo;
        
        /// <summary>	
        ///  The {{D3DXSHADER Flags}} flags used to compile the shader. 	
        /// </summary>	
        /// <unmanaged>int Flags</unmanaged>
        public int Flags;
        
        /// <summary>	
        ///  Offset into the string that contains the target. 	
        /// </summary>	
        /// <unmanaged>int Target</unmanaged>
        public int Target;
    }
    
    /// <summary>	
    /// 	
    /// <code> typedef struct D3DXSHADER_CONSTANTINFO { DWORD Name; WORD  RegisterSet; WORD  RegisterIndex; WORD  RegisterCount; WORD  Reserved; DWORD TypeInfo; DWORD DefaultValue;	
    /// } D3DXSHADER_CONSTANTINFO, *LPD3DXSHADER_CONSTANTINFO;	
    /// </code>	
    /// 	
    /// </summary>	
    /// <unmanaged>D3DXSHADER_CONSTANTINFO</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ShaderConstantinfo {	
        
        /// <summary>	
        ///  Offset from the beginning of this structure, in bytes, to the string that contains the constant information. 	
        /// </summary>	
        /// <unmanaged>int Name</unmanaged>
        public int Name;
        
        /// <summary>	
        ///  Register set. See <see cref="SlimDX2.Direct3D9.RegisterSet"/>. 	
        /// </summary>	
        /// <unmanaged>WORD RegisterSet</unmanaged>
        public short RegisterSet;
        
        /// <summary>	
        ///  The register index. 	
        /// </summary>	
        /// <unmanaged>WORD RegisterIndex</unmanaged>
        public short RegisterIndex;
        
        /// <summary>	
        ///  Number of registers. 	
        /// </summary>	
        /// <unmanaged>WORD RegisterCount</unmanaged>
        public short RegisterCount;
        
        /// <summary>	
        ///  Reserved. 	
        /// </summary>	
        /// <unmanaged>WORD Reserved</unmanaged>
        public short Reserved;
        
        /// <summary>	
        ///  Offset from the beginning of this structure, in bytes, to the string that contains the {{D3DXSHADER_TYPEINFO}} information. 	
        /// </summary>	
        /// <unmanaged>int TypeInfo</unmanaged>
        public int TypeInfo;
        
        /// <summary>	
        ///  Offset from the beginning of this structure, in bytes, to the string that contains the default value. 	
        /// </summary>	
        /// <unmanaged>int DefaultValue</unmanaged>
        public int DefaultValue;
    }
    
    /// <summary>	
    /// Describes an effect object.	
    /// </summary>	
    /// <remarks>	
    ///  An effect object can contain multiple rendering techniques and parameters for the same effect. 	
    /// </remarks>	
    /// <unmanaged>D3DXEFFECT_DESC</unmanaged>
    public  partial struct EffectDescription {	
        
        /// <summary>	
        ///  String that contains the name of the effect creator. 	
        /// </summary>	
        /// <unmanaged>const char* Creator</unmanaged>
        public string Creator;
        
        /// <summary>	
        ///  Number of parameters used for effect. 	
        /// </summary>	
        /// <unmanaged>UINT Parameters</unmanaged>
        public int Parameters;
        
        /// <summary>	
        ///  Number of techniques that can render the effect. 	
        /// </summary>	
        /// <unmanaged>UINT Techniques</unmanaged>
        public int Techniques;
        
        /// <summary>	
        ///  Number of functions that can render the effect. 	
        /// </summary>	
        /// <unmanaged>UINT Functions</unmanaged>
        public int Functions;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Creator;
            public int Parameters;
            public int Techniques;
            public int Functions;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Creator != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Creator);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Creator = ( @ref.Creator == IntPtr.Zero )?null:new string((sbyte*)@ref.Creator);
            this.Parameters = @ref.Parameters;
            this.Techniques = @ref.Techniques;
            this.Functions = @ref.Functions;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Creator = ( this.Creator == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Creator);
            @ref.Parameters = this.Parameters;
            @ref.Techniques = this.Techniques;
            @ref.Functions = this.Functions;
		
		}
    }
    
    /// <summary>	
    /// Describes a parameter used for an effect object.	
    /// </summary>	
    /// <unmanaged>D3DXPARAMETER_DESC</unmanaged>
    public  partial struct ParameterDescription {	
        
        /// <summary>	
        ///  Name of the parameter. 	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        ///  Semantic meaning, also called the usage. 	
        /// </summary>	
        /// <unmanaged>const char* Semantic</unmanaged>
        public string Semantic;
        
        /// <summary>	
        ///  Parameter class. Set this to one of the values in <see cref="SlimDX2.Direct3D9.ParameterClass"/>.  	
        /// </summary>	
        /// <unmanaged>D3DXPARAMETER_CLASS Class</unmanaged>
        public SlimDX2.Direct3D9.ParameterClass Class;
        
        /// <summary>	
        ///  Parameter type. Set this to one of the values in <see cref="SlimDX2.Direct3D9.ParameterType"/>.  	
        /// </summary>	
        /// <unmanaged>D3DXPARAMETER_TYPE Type</unmanaged>
        public SlimDX2.Direct3D9.ParameterType Type;
        
        /// <summary>	
        ///  Number of rows in the array. 	
        /// </summary>	
        /// <unmanaged>UINT Rows</unmanaged>
        public int Rows;
        
        /// <summary>	
        ///  Number of columns in the array. 	
        /// </summary>	
        /// <unmanaged>UINT Columns</unmanaged>
        public int Columns;
        
        /// <summary>	
        ///  Number of elements in the array. 	
        /// </summary>	
        /// <unmanaged>UINT Elements</unmanaged>
        public int Elements;
        
        /// <summary>	
        ///  Number of annotations. 	
        /// </summary>	
        /// <unmanaged>UINT Annotations</unmanaged>
        public int Annotations;
        
        /// <summary>	
        ///  Number of structure members. 	
        /// </summary>	
        /// <unmanaged>UINT StructMembers</unmanaged>
        public int StructMembers;
        
        /// <summary>	
        ///  Parameter attributes. See {{Effect Constants}}. 	
        /// </summary>	
        /// <unmanaged>int Flags</unmanaged>
        public int Flags;
        
        /// <summary>	
        ///  The size of the parameter, in bytes.  	
        /// </summary>	
        /// <unmanaged>UINT Bytes</unmanaged>
        public int Bytes;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public IntPtr Semantic;
            public SlimDX2.Direct3D9.ParameterClass Class;
            public SlimDX2.Direct3D9.ParameterType Type;
            public int Rows;
            public int Columns;
            public int Elements;
            public int Annotations;
            public int StructMembers;
            public int Flags;
            public int Bytes;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
                if (this.Semantic != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Semantic);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.Semantic = ( @ref.Semantic == IntPtr.Zero )?null:new string((sbyte*)@ref.Semantic);
            this.Class = @ref.Class;
            this.Type = @ref.Type;
            this.Rows = @ref.Rows;
            this.Columns = @ref.Columns;
            this.Elements = @ref.Elements;
            this.Annotations = @ref.Annotations;
            this.StructMembers = @ref.StructMembers;
            this.Flags = @ref.Flags;
            this.Bytes = @ref.Bytes;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.Semantic = ( this.Semantic == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Semantic);
            @ref.Class = this.Class;
            @ref.Type = this.Type;
            @ref.Rows = this.Rows;
            @ref.Columns = this.Columns;
            @ref.Elements = this.Elements;
            @ref.Annotations = this.Annotations;
            @ref.StructMembers = this.StructMembers;
            @ref.Flags = this.Flags;
            @ref.Bytes = this.Bytes;
		
		}
    }
    
    /// <summary>	
    /// Describes a technique used by an effect.	
    /// </summary>	
    /// <remarks>	
    ///  Some video cards can render two textures in a single pass. However, if a card does not have this capability, it is often possible to render the same effect in two passes, using one texture for each pass. 	
    /// </remarks>	
    /// <unmanaged>D3DXTECHNIQUE_DESC</unmanaged>
    public  partial struct TechniqueDescription {	
        
        /// <summary>	
        ///  String that contains the technique name. 	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        ///  Number of rendering passes the technique requires. See Remarks. 	
        /// </summary>	
        /// <unmanaged>UINT Passes</unmanaged>
        public int Passes;
        
        /// <summary>	
        ///  The number of annotations. See {{Add Information to Effect Parameters with_Annotations}}. 	
        /// </summary>	
        /// <unmanaged>UINT Annotations</unmanaged>
        public int Annotations;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public int Passes;
            public int Annotations;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.Passes = @ref.Passes;
            this.Annotations = @ref.Annotations;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.Passes = this.Passes;
            @ref.Annotations = this.Annotations;
		
		}
    }
    
    /// <summary>	
    /// Describes a pass for an effect object.	
    /// </summary>	
    /// <unmanaged>D3DXPASS_DESC</unmanaged>
    public  partial struct PassDescription {	
        
        /// <summary>	
        ///  String value used for the pass. 	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        ///  Annotations are user-specific data that can be attached to any technique, pass, or parameter. See {{Add Information to Effect Parameters with_Annotations}}. 	
        /// </summary>	
        /// <unmanaged>UINT Annotations</unmanaged>
        public int Annotations;
        
        /// <summary>	
        ///  Pointer to the vertex shader function. If an effect is created with {{D3DXFX_NOT_CLONEABLE}}, this structure will return a NULL pointer when called by {{GetPassDesc}}. 	
        /// </summary>	
        /// <unmanaged>const int* pVertexShaderFunction</unmanaged>
        public IntPtr PVertexShaderFunction;
        
        /// <summary>	
        ///  Pointer to the pixel shader function. If an effect is created with {{D3DXFX_NOT_CLONEABLE}}, this structure will return a NULL pointer when called by {{GetPassDesc}}. 	
        /// </summary>	
        /// <unmanaged>const int* pPixelShaderFunction</unmanaged>
        public IntPtr PPixelShaderFunction;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public int Annotations;
            public IntPtr PVertexShaderFunction;
            public IntPtr PPixelShaderFunction;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.Annotations = @ref.Annotations;
            this.PVertexShaderFunction = @ref.PVertexShaderFunction;
            this.PPixelShaderFunction = @ref.PPixelShaderFunction;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.Annotations = this.Annotations;
            @ref.PVertexShaderFunction = this.PVertexShaderFunction;
            @ref.PPixelShaderFunction = this.PPixelShaderFunction;
		
		}
    }
    
    /// <summary>	
    /// Describes a function used by an effect.	
    /// </summary>	
    /// <unmanaged>D3DXFUNCTION_DESC</unmanaged>
    public  partial struct FunctionDescription {	
        
        /// <summary>	
        ///  Function name. 	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        ///  Unused. This member will always be set to zero by {{GetFunctionDesc}}.  	
        /// </summary>	
        /// <unmanaged>UINT Annotations</unmanaged>
        public int Annotations;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public int Annotations;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.Annotations = @ref.Annotations;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.Annotations = this.Annotations;
		
		}
    }
    
    /// <summary>	
    /// Returns a description of the original contents of an image file.	
    /// </summary>	
    /// <unmanaged>D3DXIMAGE_INFO</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ImageInformation {	
        
        /// <summary>	
        ///  Width of original image in pixels. 	
        /// </summary>	
        /// <unmanaged>UINT Width</unmanaged>
        public int Width;
        
        /// <summary>	
        ///  Height of original image in pixels. 	
        /// </summary>	
        /// <unmanaged>UINT Height</unmanaged>
        public int Height;
        
        /// <summary>	
        ///  Depth of original image in pixels. 	
        /// </summary>	
        /// <unmanaged>UINT Depth</unmanaged>
        public int Depth;
        
        /// <summary>	
        ///  Number of mip levels in original image. 	
        /// </summary>	
        /// <unmanaged>UINT MipLevels</unmanaged>
        public int MipLevels;
        
        /// <summary>	
        ///  A value from the <see cref="SlimDX2.Direct3D9.Format"/> enumerated type that most closely describes the data in the original image. 	
        /// </summary>	
        /// <unmanaged>D3DFORMAT Format</unmanaged>
        public SlimDX2.Direct3D9.Format Format;
        
        /// <summary>	
        ///  Represents the type of the texture stored in the file. It is either D3DRTYPE_TEXTURE, D3DRTYPE_VOLUMETEXTURE, or D3DRTYPE_CubeTexture. 	
        /// </summary>	
        /// <unmanaged>D3DRESOURCETYPE ResourceType</unmanaged>
        public SlimDX2.Direct3D9.ResourceType ResourceType;
        
        /// <summary>	
        ///  Represents the format of the image file. 	
        /// </summary>	
        /// <unmanaged>D3DXIMAGE_FILEFORMAT ImageFileFormat</unmanaged>
        public SlimDX2.Direct3D9.ImageFileFormat ImageFileFormat;
    }
    
    /// <summary>	
    /// Mesh data structure.	
    /// </summary>	
    /// <unmanaged>D3DXMESHDATA</unmanaged>
    [StructLayout(LayoutKind.Explicit, Pack = 0 )]
    public  partial struct MeshData {	
        
        /// <summary>	
        ///  Defines the mesh data type. See <see cref="SlimDX2.Direct3D9.MeshDataType"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHDATATYPE Type</unmanaged>
        [FieldOffset(0)]
        public SlimDX2.Direct3D9.MeshDataType Type;
        
        /// <summary>	
        ///  Pointer to a mesh. See <see cref="SlimDX2.Direct3D9.Mesh"/>. 	
        /// </summary>	
        /// <unmanaged>LPD3DXMESH pMesh</unmanaged>
        [FieldOffset(4)]
        public IntPtr PMesh;
        
        /// <summary>	
        ///  Pointer to a patch mesh. See <see cref="SlimDX2.Direct3D9.PatchMesh"/>. 	
        /// </summary>	
        /// <unmanaged>LPD3DXPMESH pPMesh</unmanaged>
        [FieldOffset(4)]
        public IntPtr PPMesh;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>LPD3DXPATCHMESH pPatchMesh</unmanaged>
        [FieldOffset(4)]
        public IntPtr PPatchMesh;
    }
    
    /// <summary>	
    /// Encapsulates a mesh object in a transformation frame hierarchy.	
    /// </summary>	
    /// <remarks>	
    ///  An application can derive from this structure to add other data. 	
    /// </remarks>	
    /// <unmanaged>D3DXMESHCONTAINER</unmanaged>
    public  partial struct MeshContainer {	
        
        /// <summary>	
        ///  Mesh name. 	
        /// </summary>	
        /// <unmanaged>LPSTR Name</unmanaged>
        public string Name;
        
        /// <summary>	
        ///  Type of data in the mesh. See <see cref="SlimDX2.Direct3D9.MeshData"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHDATA MeshData</unmanaged>
        public SlimDX2.Direct3D9.MeshData MeshData;
        
        /// <summary>	
        ///  Array of mesh materials. See <see cref="SlimDX2.Direct3D9.ExtendedMaterial"/>. 	
        /// </summary>	
        /// <unmanaged>LPD3DXMATERIAL pMaterials</unmanaged>
        public IntPtr PMaterials;
        
        /// <summary>	
        ///  Pointer to a set of default effect parameters. See <see cref="SlimDX2.Direct3D9.EffectInstance"/>. 	
        /// </summary>	
        /// <unmanaged>LPD3DXEFFECTINSTANCE pEffects</unmanaged>
        public IntPtr PEffects;
        
        /// <summary>	
        ///  Number of materials in the mesh. 	
        /// </summary>	
        /// <unmanaged>int NumMaterials</unmanaged>
        public int NumMaterials;
        
        /// <summary>	
        ///  Pointer to an array of three DWORDs per triangle of the mesh that contains adjacency information. 	
        /// </summary>	
        /// <unmanaged>int* pAdjacency</unmanaged>
        public IntPtr PAdjacency;
        
        /// <summary>	
        ///  Pointer to the skin information interface. See <see cref="SlimDX2.Direct3D9.SkinInfo"/>. 	
        /// </summary>	
        /// <unmanaged>LPD3DXSKININFO pSkinInfo</unmanaged>
        public IntPtr PSkinInfo;
        
        /// <summary>	
        ///  Pointer to the next mesh container. 	
        /// </summary>	
        /// <unmanaged>D3DXMESHCONTAINER* pNextMeshContainer</unmanaged>
        public IntPtr PNextMeshContainer;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public SlimDX2.Direct3D9.MeshData MeshData;
            public IntPtr PMaterials;
            public IntPtr PEffects;
            public int NumMaterials;
            public IntPtr PAdjacency;
            public IntPtr PSkinInfo;
            public IntPtr PNextMeshContainer;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.MeshData = @ref.MeshData;
            this.PMaterials = @ref.PMaterials;
            this.PEffects = @ref.PEffects;
            this.NumMaterials = @ref.NumMaterials;
            this.PAdjacency = @ref.PAdjacency;
            this.PSkinInfo = @ref.PSkinInfo;
            this.PNextMeshContainer = @ref.PNextMeshContainer;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.MeshData = this.MeshData;
            @ref.PMaterials = this.PMaterials;
            @ref.PEffects = this.PEffects;
            @ref.NumMaterials = this.NumMaterials;
            @ref.PAdjacency = this.PAdjacency;
            @ref.PSkinInfo = this.PSkinInfo;
            @ref.PNextMeshContainer = this.PNextMeshContainer;
		
		}
    }
    
    /// <summary>	
    /// Encapsulates a transform frame in a transformation frame hierarchy.	
    /// </summary>	
    /// <remarks>	
    ///  An application can derive from this structure to add other data. 	
    /// </remarks>	
    /// <unmanaged>D3DXFRAME</unmanaged>
    public  partial struct Frame {	
        
        /// <summary>	
        ///  Name of the frame. 	
        /// </summary>	
        /// <unmanaged>LPSTR Name</unmanaged>
        public string Name;
        
        /// <summary>	
        ///  Transformation matrix. 	
        /// </summary>	
        /// <unmanaged>D3DXMATRIX TransformationMatrix</unmanaged>
        public SlimMath.Matrix TransformationMatrix;
        
        /// <summary>	
        ///  Pointer to the mesh container. 	
        /// </summary>	
        /// <unmanaged>LPD3DXMESHCONTAINER pMeshContainer</unmanaged>
        public IntPtr PMeshContainer;
        
        /// <summary>	
        ///  Pointer to a sibling frame. 	
        /// </summary>	
        /// <unmanaged>D3DXFRAME* pFrameSibling</unmanaged>
        public IntPtr PFrameSibling;
        
        /// <summary>	
        ///  Pointer to a child frame. 	
        /// </summary>	
        /// <unmanaged>D3DXFRAME* pFrameFirstChild</unmanaged>
        public IntPtr PFrameFirstChild;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public SlimMath.Matrix TransformationMatrix;
            public IntPtr PMeshContainer;
            public IntPtr PFrameSibling;
            public IntPtr PFrameFirstChild;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.TransformationMatrix = @ref.TransformationMatrix;
            this.PMeshContainer = @ref.PMeshContainer;
            this.PFrameSibling = @ref.PFrameSibling;
            this.PFrameFirstChild = @ref.PFrameFirstChild;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.TransformationMatrix = this.TransformationMatrix;
            @ref.PMeshContainer = this.PMeshContainer;
            @ref.PFrameSibling = this.PFrameSibling;
            @ref.PFrameFirstChild = this.PFrameFirstChild;
		
		}
    }
    
    /// <summary>	
    /// Describes a vector key for use in key frame animation. It specifies a vector at a given time. This is used for scale and translation keys.	
    /// </summary>	
    /// <unmanaged>D3DXKEY_VECTOR3</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ScaleKey {	
        
        /// <summary>	
        ///  Key frame time stamp. 	
        /// </summary>	
        /// <unmanaged>FLOAT Time</unmanaged>
        public float Time;
        
        /// <summary>	
        ///   <see cref="SlimMath.Vector3"/> 3D vector that supplies scale and/or translation values. 	
        /// </summary>	
        /// <unmanaged>D3DXVECTOR3 Value</unmanaged>
        public SlimMath.Vector3 Value;
    }
    
    /// <summary>	
    /// Describes a quaternion key for use in key frame animation. A quaternion key is a quaternion value at a given time.	
    /// </summary>	
    /// <unmanaged>D3DXKEY_QUATERNION</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct RotationKey {	
        
        /// <summary>	
        ///  Time value. 	
        /// </summary>	
        /// <unmanaged>FLOAT Time</unmanaged>
        public float Time;
        
        /// <summary>	
        ///   <see cref="SlimMath.Quaternion"/> quaternion that supplies rotation values. 	
        /// </summary>	
        /// <unmanaged>D3DXQUATERNION Value</unmanaged>
        public SlimMath.Quaternion Value;
    }
    
    /// <summary>	
    /// Describes a callback key for use in key frame animation.	
    /// </summary>	
    /// <unmanaged>D3DXKEY_CALLBACK</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct CallbackKey {	
        
        /// <summary>	
        ///  Key frame time stamp. 	
        /// </summary>	
        /// <unmanaged>FLOAT Time</unmanaged>
        public float Time;
        
        /// <summary>	
        ///  Pointer to user callback data. 	
        /// </summary>	
        /// <unmanaged>void* pCallbackData</unmanaged>
        public IntPtr PCallbackData;
    }
    
    /// <summary>	
    /// Describes an animation track and specifies blending weight, speed, and position for the track at a given time.	
    /// </summary>	
    /// <remarks>	
    ///  Tracks with the same priority are blended together, and the two resulting values are then blended using the priority blend factor.  A track must have an animation set (stored separately) associated with it. 	
    /// </remarks>	
    /// <unmanaged>D3DXTRACK_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct TrackDescription {	
        
        /// <summary>	
        ///  Priority type, as defined in <see cref="SlimDX2.Direct3D9.TrackPriority"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXPRIORITY_TYPE Priority</unmanaged>
        public SlimDX2.Direct3D9.TrackPriority Priority;
        
        /// <summary>	
        ///  Weight value. The weight determines the proportion of this track to blend with other tracks. 	
        /// </summary>	
        /// <unmanaged>FLOAT Weight</unmanaged>
        public float Weight;
        
        /// <summary>	
        ///  Speed value. This is used similarly to a multiplier to scale the period of the track. 	
        /// </summary>	
        /// <unmanaged>FLOAT Speed</unmanaged>
        public float Speed;
        
        /// <summary>	
        ///  Time position of the track, in the local timeframe of its current animation set. 	
        /// </summary>	
        /// <unmanaged>DOUBLE Position</unmanaged>
        public double Position;
        
        /// <summary>	
        ///  Track enable/disable. To enable, set to TRUE. To disable, set to FALSE. 	
        /// </summary>	
        /// <unmanaged>BOOL Enable</unmanaged>
        public bool Enable { 
            get { 
                return (_Enable!=0)?true:false; 
            }
            set { 
                _Enable = value?1:0;
            }
        }
        internal int _Enable;
    }
    
    /// <summary>	
    /// Describes an animation event.	
    /// </summary>	
    /// <unmanaged>D3DXEVENT_DESC</unmanaged>
    [StructLayout(LayoutKind.Explicit, Pack = 0 )]
    public  partial struct EventDescription {	
        
        /// <summary>	
        ///  Event type, as defined in <see cref="SlimDX2.Direct3D9.EventType"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXEVENT_TYPE Type</unmanaged>
        [FieldOffset(0)]
        public SlimDX2.Direct3D9.EventType Type;
        
        /// <summary>	
        ///  Event track identifier. 	
        /// </summary>	
        /// <unmanaged>UINT Track</unmanaged>
        [FieldOffset(4)]
        public int Track;
        
        /// <summary>	
        ///  Start time of the event in global time. 	
        /// </summary>	
        /// <unmanaged>DOUBLE StartTime</unmanaged>
        [FieldOffset(8)]
        public double StartTime;
        
        /// <summary>	
        ///  Duration of the event in global time. 	
        /// </summary>	
        /// <unmanaged>DOUBLE Duration</unmanaged>
        [FieldOffset(16)]
        public double Duration;
        
        /// <summary>	
        ///  Transition style of the event, as defined in <see cref="SlimDX2.Direct3D9.TransitionType"/>. 	
        /// </summary>	
        /// <unmanaged>D3DXTRANSITION_TYPE Transition</unmanaged>
        [FieldOffset(24)]
        public SlimDX2.Direct3D9.TransitionType Transition;
        
        /// <summary>	
        ///  Track weight for the event. 	
        /// </summary>	
        /// <unmanaged>FLOAT Weight</unmanaged>
        [FieldOffset(28)]
        public float Weight;
        
        /// <summary>	
        ///  Track speed for the event. 	
        /// </summary>	
        /// <unmanaged>FLOAT Speed</unmanaged>
        [FieldOffset(28)]
        public float Speed;
        
        /// <summary>	
        ///  Track position for the event. 	
        /// </summary>	
        /// <unmanaged>DOUBLE Position</unmanaged>
        [FieldOffset(28)]
        public double Position;
        
        /// <summary>	
        ///  Enable flag. 	
        /// </summary>	
        /// <unmanaged>BOOL Enable</unmanaged>
        public bool Enable { 
            get { 
                return (_Enable!=0)?true:false; 
            }
            set { 
                _Enable = value?1:0;
            }
        }
        [FieldOffset(28)]
        internal int _Enable;
    }
}
