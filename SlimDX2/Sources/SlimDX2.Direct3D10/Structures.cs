// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Structs for SlimDX2.Direct3D10 namespace.
//     This code was generated by a tool.
//     Date : 11/08/2010 15:18:18
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace SlimDX2.Direct3D10 {

    
    /// <summary>	
    /// A description of a single element for the {{input-assembler stage}}.	
    /// </summary>	
    /// <remarks>	
    /// An input-layout object contains an array of structures, each structure defines one element being read from an input slot. Create an input-layout object by calling <see cref="SlimDX2.Direct3D10.Device.CreateInputLayout"/>. For an example, see {{Create an input-layout object}}.	
    /// </remarks>	
    /// <unmanaged>D3D10_INPUT_ELEMENT_DESC</unmanaged>
    public  partial struct InputElement {	
        
        /// <summary>	
        /// The {{HLSL semantic}} associated with this element in a {{shader input-signature}}.	
        /// </summary>	
        /// <unmanaged>const char* SemanticName</unmanaged>
        public string SemanticName;
        
        /// <summary>	
        /// The semantic index for the element. A semantic index modifies a semantic, with an integer index number. A semantic index is only needed in a case where there is more than one element with the same semantic. For example, a 4x4 matrix would have four components each with the semantic name matrix, however each of the four component would have different semantic indices (0, 1, 2, and 3).	
        /// </summary>	
        /// <unmanaged>UINT SemanticIndex</unmanaged>
        public int SemanticIndex;
        
        /// <summary>	
        /// The data type of the element data. See <see cref="SlimDX2.DXGI.Format"/>.	
        /// </summary>	
        /// <unmanaged>DXGI_FORMAT Format</unmanaged>
        public SlimDX2.DXGI.Format Format;
        
        /// <summary>	
        /// An integer value that identifies the input-assembler (see {{input slot}}). Valid values are between 0 and 15, defined in D3D10.h.	
        /// </summary>	
        /// <unmanaged>UINT InputSlot</unmanaged>
        public int InputSlot;
        
        /// <summary>	
        /// Optional. Offset (in bytes) between each element. Use D3D10_APPEND_ALIGNED_ELEMENT for convenience to define the current element directly after the previous one, including any packing if necessary.	
        /// </summary>	
        /// <unmanaged>UINT AlignedByteOffset</unmanaged>
        public int AlignedByteOffset;
        
        /// <summary>	
        /// Identifies the input data class for a single input slot (see <see cref="SlimDX2.Direct3D10.InputClassification"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_INPUT_CLASSIFICATION InputSlotClass</unmanaged>
        public SlimDX2.Direct3D10.InputClassification InputSlotClass;
        
        /// <summary>	
        /// The number of instances to draw before stepping one unit forward in a vertex buffer filled with instance data. Can be any unsigned integer value (0 means do not step) when the slot class is D3D10_INPUT_PER_INSTANCE_DATA; must be 0 when the slot class is D3D10_INPUT_PER_VERTEX_DATA.	
        /// </summary>	
        /// <unmanaged>UINT InstanceDataStepRate</unmanaged>
        public int InstanceDataStepRate;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr SemanticName;
            public int SemanticIndex;
            public SlimDX2.DXGI.Format Format;
            public int InputSlot;
            public int AlignedByteOffset;
            public SlimDX2.Direct3D10.InputClassification InputSlotClass;
            public int InstanceDataStepRate;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.SemanticName != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.SemanticName);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.SemanticName = ( @ref.SemanticName == IntPtr.Zero )?null:new string((sbyte*)@ref.SemanticName);
            this.SemanticIndex = @ref.SemanticIndex;
            this.Format = @ref.Format;
            this.InputSlot = @ref.InputSlot;
            this.AlignedByteOffset = @ref.AlignedByteOffset;
            this.InputSlotClass = @ref.InputSlotClass;
            this.InstanceDataStepRate = @ref.InstanceDataStepRate;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.SemanticName = ( this.SemanticName == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.SemanticName);
            @ref.SemanticIndex = this.SemanticIndex;
            @ref.Format = this.Format;
            @ref.InputSlot = this.InputSlot;
            @ref.AlignedByteOffset = this.AlignedByteOffset;
            @ref.InputSlotClass = this.InputSlotClass;
            @ref.InstanceDataStepRate = this.InstanceDataStepRate;
		
		}
    }
    
    /// <summary>	
    /// Description of a vertex element in a vertex buffer in an output slot.	
    /// </summary>	
    /// <unmanaged>D3D10_SO_DECLARATION_ENTRY</unmanaged>
    public  partial struct StreamOutputElement {	
        
        /// <summary>	
        /// Type of output element.  Possible values: "POSITION", "NORMAL", or "TEXCOORD0".	
        /// </summary>	
        /// <unmanaged>const char* SemanticName</unmanaged>
        public string SemanticName;
        
        /// <summary>	
        /// Output element's zero-based index. Should be used if, for example, you have more than one texture coordinate stored in each vertex.	
        /// </summary>	
        /// <unmanaged>UINT SemanticIndex</unmanaged>
        public int SemanticIndex;
        
        /// <summary>	
        /// Which component of the entry to begin writing out to. Valid values are 0 ~ 3. For example, if you only wish to output to the y and z components of a position, then StartComponent should be 1 and ComponentCount should be 2.	
        /// </summary>	
        /// <unmanaged>BYTE StartComponent</unmanaged>
        public byte StartComponent;
        
        /// <summary>	
        /// The number of components of the entry to write out to. Valid values are 1 ~ 4. For example, if you only wish to output to the y and z components of a position, then StartComponent should be 1 and ComponentCount should be 2.	
        /// </summary>	
        /// <unmanaged>BYTE ComponentCount</unmanaged>
        public byte ComponentCount;
        
        /// <summary>	
        /// The output slot that contains the vertex buffer that contains this output entry.	
        /// </summary>	
        /// <unmanaged>BYTE OutputSlot</unmanaged>
        public byte OutputSlot;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr SemanticName;
            public int SemanticIndex;
            public byte StartComponent;
            public byte ComponentCount;
            public byte OutputSlot;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.SemanticName != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.SemanticName);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.SemanticName = ( @ref.SemanticName == IntPtr.Zero )?null:new string((sbyte*)@ref.SemanticName);
            this.SemanticIndex = @ref.SemanticIndex;
            this.StartComponent = @ref.StartComponent;
            this.ComponentCount = @ref.ComponentCount;
            this.OutputSlot = @ref.OutputSlot;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.SemanticName = ( this.SemanticName == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.SemanticName);
            @ref.SemanticIndex = this.SemanticIndex;
            @ref.StartComponent = this.StartComponent;
            @ref.ComponentCount = this.ComponentCount;
            @ref.OutputSlot = this.OutputSlot;
		
		}
    }
    
    /// <summary>	
    /// Defines the dimensions of a {{viewport}}.	
    /// </summary>	
    /// <remarks>	
    /// In all cases, Width and Height must be ? 0 and TopLeftX + Width and TopLeftY + Height must be ? D3D10_VIEWPORT_BOUNDS_MAX.	
    /// </remarks>	
    /// <unmanaged>D3D10_VIEWPORT</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct Viewport {	
        
        /// <summary>	
        /// X position of the left hand side of the viewport. Ranges between D3D10_VIEWPORT_BOUNDS_MIN and D3D10_VIEWPORT_BOUNDS_MAX.	
        /// </summary>	
        /// <unmanaged>INT TopLeftX</unmanaged>
        public int TopLeftX;
        
        /// <summary>	
        /// Y position of the top of the viewport. Ranges between D3D10_VIEWPORT_BOUNDS_MIN and D3D10_VIEWPORT_BOUNDS_MAX.	
        /// </summary>	
        /// <unmanaged>INT TopLeftY</unmanaged>
        public int TopLeftY;
        
        /// <summary>	
        /// Width of the viewport.	
        /// </summary>	
        /// <unmanaged>UINT Width</unmanaged>
        public int Width;
        
        /// <summary>	
        /// Height of the viewport.	
        /// </summary>	
        /// <unmanaged>UINT Height</unmanaged>
        public int Height;
        
        /// <summary>	
        /// Minimum depth of the viewport. Ranges between 0 and 1.	
        /// </summary>	
        /// <unmanaged>FLOAT MinDepth</unmanaged>
        public float MinDepth;
        
        /// <summary>	
        /// Maximum depth of the viewport. Ranges between 0 and 1.	
        /// </summary>	
        /// <unmanaged>FLOAT MaxDepth</unmanaged>
        public float MaxDepth;
    }
    
    /// <summary>	
    /// Defines a 3D box.	
    /// </summary>	
    /// <remarks>	
    /// The following diagram shows a 3D box, where the origin is the left, front, top corner.?Diagram of a 3D box, where the origin is the left, front, top corner?	
    /// </remarks>	
    /// <unmanaged>D3D10_BOX</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ResourceRegion {	
        
        /// <summary>	
        /// The x position of the left hand side of the box.	
        /// </summary>	
        /// <unmanaged>UINT left</unmanaged>
        public int Left;
        
        /// <summary>	
        /// The y position of the top of the box.	
        /// </summary>	
        /// <unmanaged>UINT top</unmanaged>
        public int Top;
        
        /// <summary>	
        /// The z position of the front of the box.	
        /// </summary>	
        /// <unmanaged>UINT front</unmanaged>
        public int Front;
        
        /// <summary>	
        /// The x position of the right hand side of the box.	
        /// </summary>	
        /// <unmanaged>UINT right</unmanaged>
        public int Right;
        
        /// <summary>	
        /// The y position of the bottom of the box.	
        /// </summary>	
        /// <unmanaged>UINT bottom</unmanaged>
        public int Bottom;
        
        /// <summary>	
        /// The z position of the back of the box.	
        /// </summary>	
        /// <unmanaged>UINT back</unmanaged>
        public int Back;
    }
    
    /// <summary>	
    /// Describes the stencil operations that can be performed based on the results of {{stencil test}}.	
    /// </summary>	
    /// <remarks>	
    /// The stencil operation can be set differently based on the outcome of the stencil test by using the StencilFunc member.  This can be done for the {{stencil test}} portion of depth-stencil testing.The D3D10_DEPTH_STENCILOP_DESC structure is a member of the <see cref="SlimDX2.Direct3D10.DepthStencilStateDescription"/> structure. 	
    /// </remarks>	
    /// <unmanaged>D3D10_DEPTH_STENCILOP_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct DepthStencilOperationDescription {	
        
        /// <summary>	
        /// A member of the <see cref="SlimDX2.Direct3D10.StencilOperation"/> enumerated type that describes the stencil operation to perform when stencil testing fails. The default value is D3D10_STENCIL_OP_KEEP.	
        /// </summary>	
        /// <unmanaged>D3D10_STENCIL_OP StencilFailOp</unmanaged>
        public SlimDX2.Direct3D10.StencilOperation StencilFailOp;
        
        /// <summary>	
        /// A member of the <see cref="SlimDX2.Direct3D10.StencilOperation"/> enumerated type that describes the stencil operation to perform when stencil testing passes and depth testing fails. The default value is D3D10_STENCIL_OP_KEEP.	
        /// </summary>	
        /// <unmanaged>D3D10_STENCIL_OP StencilDepthFailOp</unmanaged>
        public SlimDX2.Direct3D10.StencilOperation StencilDepthFailOp;
        
        /// <summary>	
        /// A member of the <see cref="SlimDX2.Direct3D10.StencilOperation"/> enumerated type that describes the stencil operation to perform when stencil testing and depth testing both pass. The default value is D3D10_STENCIL_OP_KEEP.	
        /// </summary>	
        /// <unmanaged>D3D10_STENCIL_OP StencilPassOp</unmanaged>
        public SlimDX2.Direct3D10.StencilOperation StencilPassOp;
        
        /// <summary>	
        /// A member of the <see cref="SlimDX2.Direct3D10.ComparisonFunction"/> enumerated type that describes how stencil data is compared against existing stencil data. The default value is D3D10_COMPARISON_ALWAYS.	
        /// </summary>	
        /// <unmanaged>D3D10_COMPARISON_FUNC StencilFunc</unmanaged>
        public SlimDX2.Direct3D10.ComparisonFunction StencilFunc;
    }
    
    /// <summary>	
    /// Describes depth-stencil state.	
    /// </summary>	
    /// <remarks>	
    /// Depth-stencil state controls how {{depth-stencil}} testing is performed by the {{output-merger}} stage.The formats that support stenciling are DXGI_FORMAT_D24_UNORM_S8_UINT and DXGI_FORMAT_D32_FLOAT_S8X24_UINT.	
    /// </remarks>	
    /// <unmanaged>D3D10_DEPTH_STENCIL_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct DepthStencilStateDescription {	
        
        /// <summary>	
        /// A Boolean value that enables depth testing.  The default value is TRUE.	
        /// </summary>	
        /// <unmanaged>BOOL DepthEnable</unmanaged>
        public bool DepthEnable { 
            get { 
                return (_DepthEnable!=0)?true:false; 
            }
            set { 
                _DepthEnable = value?1:0;
            }
        }
        internal int _DepthEnable;
        
        /// <summary>	
        /// A member of the <see cref="SlimDX2.Direct3D10.DepthWriteMask"/> enumerated type that identifies a portion of the depth-stencil buffer that can be modified by depth data.  The default value is D3D10_DEPTH_WRITE_MASK_ALL.	
        /// </summary>	
        /// <unmanaged>D3D10_DEPTH_WRITE_MASK DepthWriteMask</unmanaged>
        public SlimDX2.Direct3D10.DepthWriteMask DepthWriteMask;
        
        /// <summary>	
        /// A member of the <see cref="SlimDX2.Direct3D10.ComparisonFunction"/> enumerated type that defines how depth data is compared against existing depth data.  The default value is D3D10_COMPARISON_LESS	
        /// </summary>	
        /// <unmanaged>D3D10_COMPARISON_FUNC DepthFunc</unmanaged>
        public SlimDX2.Direct3D10.ComparisonFunction DepthFunc;
        
        /// <summary>	
        /// A Boolean value that enables stencil testing.  The default value is FALSE.	
        /// </summary>	
        /// <unmanaged>BOOL StencilEnable</unmanaged>
        public bool StencilEnable { 
            get { 
                return (_StencilEnable!=0)?true:false; 
            }
            set { 
                _StencilEnable = value?1:0;
            }
        }
        internal int _StencilEnable;
        
        /// <summary>	
        /// A value that identifies a portion of the depth-stencil buffer for reading stencil data.  The default value is D3D10_DEFAULT_STENCIL_READ_MASK.	
        /// </summary>	
        /// <unmanaged>UINT8 StencilReadMask</unmanaged>
        public byte StencilReadMask;
        
        /// <summary>	
        /// A value that identifies a portion of the depth-stencil buffer for writing stencil data. The default value is D3D10_DEFAULT_STENCIL_WRITE_MASK.	
        /// </summary>	
        /// <unmanaged>UINT8 StencilWriteMask</unmanaged>
        public byte StencilWriteMask;
        
        /// <summary>	
        /// A <see cref="SlimDX2.Direct3D10.DepthStencilOperationDescription"/> structure that identifies how to use the results of the depth test and the stencil test for pixels whose surface normal is facing toward the camera.	
        /// </summary>	
        /// <unmanaged>D3D10_DEPTH_STENCILOP_DESC FrontFace</unmanaged>
        public SlimDX2.Direct3D10.DepthStencilOperationDescription FrontFace;
        
        /// <summary>	
        /// A <see cref="SlimDX2.Direct3D10.DepthStencilOperationDescription"/> structure that identifies how to use the results of the depth test and the stencil test for pixels whose surface normal is facing away from the camera.	
        /// </summary>	
        /// <unmanaged>D3D10_DEPTH_STENCILOP_DESC BackFace</unmanaged>
        public SlimDX2.Direct3D10.DepthStencilOperationDescription BackFace;
    }
    
    /// <summary>	
    /// Describes the blend state.	
    /// </summary>	
    /// <remarks>	
    /// To see how blending is done, see {{Output-Merger Stage (Direct3D 10)}}.These are the default values for blend state.StateDefault ValueAlphaToCoverageEnableFALSEBlendEnable[8]FALSE (for all 8)SrcBlendD3D10_BLEND_ONEDestBlendD3D10_BLEND_ZEROBlendOpD3D10_BLEND_OP_ADDSrcBlendAlphaD3D10_BLEND_ONEDestBlendAlphaD3D10_BLEND_ZEROBlendOpAlphaD3D10_BLEND_OP_ADDRenderTargetWriteMask[8]D3D10_COLOR_WRITE_ENABLE_ALL (for all 8)?	
    /// </remarks>	
    /// <unmanaged>D3D10_BLEND_DESC</unmanaged>
    public  partial struct BlendStateDescription {	
        
        /// <summary>	
        /// Determines whether or not to use {{alpha-to-coverage}} as a multisampling technique when setting a pixel to a rendertarget.	
        /// </summary>	
        /// <unmanaged>BOOL AlphaToCoverageEnable</unmanaged>
        public bool AlphaToCoverageEnable { 
            get { 
                return (_AlphaToCoverageEnable!=0)?true:false; 
            }
            set { 
                _AlphaToCoverageEnable = value?1:0;
            }
        }
        internal int _AlphaToCoverageEnable;
        
        /// <summary>	
        /// Enable (or disable) blending. There are eight elements in this array; these correspond to the eight rendertargets that can be set to output-merger stage at one time.	
        /// </summary>	
        /// <unmanaged>BOOL BlendEnable[8]</unmanaged>
        public bool BlendEnable { 
            get { 
                return (_BlendEnable!=0)?true:false; 
            }
            set { 
                _BlendEnable = value?1:0;
            }
        }
        internal int _BlendEnable;
        
        /// <summary>	
        /// This {{blend option}} specifies the first RGB data source and includes an optional pre-blend operation.	
        /// </summary>	
        /// <unmanaged>D3D10_BLEND SrcBlend</unmanaged>
        public SlimDX2.Direct3D10.BlendOption SrcBlend;
        
        /// <summary>	
        /// This {{blend option}} specifies the second RGB data source and includes an optional pre-blend operation.	
        /// </summary>	
        /// <unmanaged>D3D10_BLEND DestBlend</unmanaged>
        public SlimDX2.Direct3D10.BlendOption DestBlend;
        
        /// <summary>	
        /// This {{blend operation}} defines how to combine the RGB data sources.	
        /// </summary>	
        /// <unmanaged>D3D10_BLEND_OP BlendOp</unmanaged>
        public SlimDX2.Direct3D10.BlendOperation BlendOp;
        
        /// <summary>	
        /// This {{blend option}} specifies the first alpha data source and includes an optional pre-blend operation. Blend options that end in _COLOR are not allowed.	
        /// </summary>	
        /// <unmanaged>D3D10_BLEND SrcBlendAlpha</unmanaged>
        public SlimDX2.Direct3D10.BlendOption SrcBlendAlpha;
        
        /// <summary>	
        /// This {{blend option}} specifies the second alpha data source and includes an optional pre-blend operation. Blend options that end in _COLOR are not allowed.	
        /// </summary>	
        /// <unmanaged>D3D10_BLEND DestBlendAlpha</unmanaged>
        public SlimDX2.Direct3D10.BlendOption DestBlendAlpha;
        
        /// <summary>	
        /// This {{blend operation}} defines how to combine the alpha data sources.	
        /// </summary>	
        /// <unmanaged>D3D10_BLEND_OP BlendOpAlpha</unmanaged>
        public SlimDX2.Direct3D10.BlendOperation BlendOpAlpha;
        
        /// <summary>	
        /// A per-pixel write mask that allows control over which components can be written (see <see cref="SlimDX2.Direct3D10.ColorWriteMaskFlags"/>).	
        /// </summary>	
        /// <unmanaged>UINT8 RenderTargetWriteMask[8]</unmanaged>
        public byte[] RenderTargetWriteMask { 
            get { 
                if (_RenderTargetWriteMask == null) {
                    _RenderTargetWriteMask = new byte[8];
                }
                return _RenderTargetWriteMask; 
            }
        }
        internal byte[] _RenderTargetWriteMask;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public int _AlphaToCoverageEnable;
            public int _BlendEnable;
            public SlimDX2.Direct3D10.BlendOption SrcBlend;
            public SlimDX2.Direct3D10.BlendOption DestBlend;
            public SlimDX2.Direct3D10.BlendOperation BlendOp;
            public SlimDX2.Direct3D10.BlendOption SrcBlendAlpha;
            public SlimDX2.Direct3D10.BlendOption DestBlendAlpha;
            public SlimDX2.Direct3D10.BlendOperation BlendOpAlpha;
            public fixed byte RenderTargetWriteMask[8];
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this._AlphaToCoverageEnable = @ref._AlphaToCoverageEnable;
            this._BlendEnable = @ref._BlendEnable;
            this.SrcBlend = @ref.SrcBlend;
            this.DestBlend = @ref.DestBlend;
            this.BlendOp = @ref.BlendOp;
            this.SrcBlendAlpha = @ref.SrcBlendAlpha;
            this.DestBlendAlpha = @ref.DestBlendAlpha;
            this.BlendOpAlpha = @ref.BlendOpAlpha;
            fixed (void* __to = &this.RenderTargetWriteMask[0]) fixed (void* __from = @ref.RenderTargetWriteMask) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 8*sizeof ( byte));
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref._AlphaToCoverageEnable = this._AlphaToCoverageEnable;
            @ref._BlendEnable = this._BlendEnable;
            @ref.SrcBlend = this.SrcBlend;
            @ref.DestBlend = this.DestBlend;
            @ref.BlendOp = this.BlendOp;
            @ref.SrcBlendAlpha = this.SrcBlendAlpha;
            @ref.DestBlendAlpha = this.DestBlendAlpha;
            @ref.BlendOpAlpha = this.BlendOpAlpha;
            fixed (void* __to = @ref.RenderTargetWriteMask) fixed (void* __from = &this.RenderTargetWriteMask[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 8*sizeof ( byte));
		
		}
    }
    
    /// <summary>	
    /// Describes the rasterizer state.	
    /// </summary>	
    /// <remarks>	
    /// Rasterizer state defines the behavior of the {{rasterizer stage}}; to set rasterizer state, call <see cref="SlimDX2.Direct3D10.Device.RasterizerStage.SetState"/>.	
    /// </remarks>	
    /// <unmanaged>D3D10_RASTERIZER_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct RasterizerStateDescription {	
        
        /// <summary>	
        /// A member of the <see cref="SlimDX2.Direct3D10.FillMode"/> enumerated type that determines the fill mode to use when rendering.  The default value is D3D10_FILL_SOLID.	
        /// </summary>	
        /// <unmanaged>D3D10_FILL_MODE FillMode</unmanaged>
        public SlimDX2.Direct3D10.FillMode FillMode;
        
        /// <summary>	
        /// A member of the <see cref="SlimDX2.Direct3D10.CullMode"/> enumerated type that indicates whether triangles facing the specified direction are drawn.  The default value is D3D10_CULL_BACK.	
        /// </summary>	
        /// <unmanaged>D3D10_CULL_MODE CullMode</unmanaged>
        public SlimDX2.Direct3D10.CullMode CullMode;
        
        /// <summary>	
        /// Determines if a triangle is front-facing or back-facing. If this parameter is TRUE, then a triangle is considered front-facing if its vertices are counter-clockwise on the render target, and considered back-facing if they are clockwise. If this parameter is FALSE, then the opposite is true.  The default value is FALSE.	
        /// </summary>	
        /// <unmanaged>BOOL FrontCounterClockwise</unmanaged>
        public bool FrontCounterClockwise { 
            get { 
                return (_FrontCounterClockwise!=0)?true:false; 
            }
            set { 
                _FrontCounterClockwise = value?1:0;
            }
        }
        internal int _FrontCounterClockwise;
        
        /// <summary>	
        /// Specifies the depth value added to a given pixel. The default value is 0. For more information, see {{Depth Bias}}.	
        /// </summary>	
        /// <unmanaged>INT DepthBias</unmanaged>
        public int DepthBias;
        
        /// <summary>	
        /// Specifies the maximum depth bias of a pixel. The default value is 0.0f. For more information, see {{Depth Bias}}.	
        /// </summary>	
        /// <unmanaged>FLOAT DepthBiasClamp</unmanaged>
        public float DepthBiasClamp;
        
        /// <summary>	
        /// Specifies a scalar on a given pixel's slope. The default value is 0.0f. For more information, see {{Depth Bias}}.	
        /// </summary>	
        /// <unmanaged>FLOAT SlopeScaledDepthBias</unmanaged>
        public float SlopeScaledDepthBias;
        
        /// <summary>	
        /// Enables or disables clipping based on distance.  The default value is TRUE.	
        /// </summary>	
        /// <unmanaged>BOOL DepthClipEnable</unmanaged>
        public bool DepthClipEnable { 
            get { 
                return (_DepthClipEnable!=0)?true:false; 
            }
            set { 
                _DepthClipEnable = value?1:0;
            }
        }
        internal int _DepthClipEnable;
        
        /// <summary>	
        /// Enable or disables scissor-rectangle culling. All pixels outside an active scissor rectangle are culled. The default value is FALSE. For more information, see {{Set the Scissor Rectangle}}.	
        /// </summary>	
        /// <unmanaged>BOOL ScissorEnable</unmanaged>
        public bool ScissorEnable { 
            get { 
                return (_ScissorEnable!=0)?true:false; 
            }
            set { 
                _ScissorEnable = value?1:0;
            }
        }
        internal int _ScissorEnable;
        
        /// <summary>	
        /// Enables or disables multisample antialiasing.  The default value is FALSE.	
        /// </summary>	
        /// <unmanaged>BOOL MultisampleEnable</unmanaged>
        public bool MultisampleEnable { 
            get { 
                return (_MultisampleEnable!=0)?true:false; 
            }
            set { 
                _MultisampleEnable = value?1:0;
            }
        }
        internal int _MultisampleEnable;
        
        /// <summary>	
        /// Enable or disables line antialiasing. Note that this option only applies when alpha blending is enabled, you are drawing lines, and the MultisampleEnable member is FALSE.  The default value is FALSE.	
        /// </summary>	
        /// <unmanaged>BOOL AntialiasedLineEnable</unmanaged>
        public bool AntialiasedLineEnable { 
            get { 
                return (_AntialiasedLineEnable!=0)?true:false; 
            }
            set { 
                _AntialiasedLineEnable = value?1:0;
            }
        }
        internal int _AntialiasedLineEnable;
    }
    
    /// <summary>	
    /// Specifies data for initializing a {{subresource}}.	
    /// </summary>	
    /// <remarks>	
    /// This structure is used in calls to create buffers (<see cref="SlimDX2.Direct3D10.Device.CreateBuffer"/>) and textures (<see cref="SlimDX2.Direct3D10.Device.CreateTexture1D"/>,  <see cref="SlimDX2.Direct3D10.Device.CreateTexture2D"/>, and <see cref="SlimDX2.Direct3D10.Device.CreateTexture3D"/>).  If the resource being created does not require a system-memory pitch or a system-memory-pitch slice, then you are free to use those members to  pass size information which may help you when debugging a problem creating a resource.Note that an application should not rely on SysMemPitch being exactly equal to the number of texels in a line times the size of a texel. In some cases SysMemPitch will include padding to skip past additional data in a line.  This could be padding for alignment or  the texture could be a subsection of a larger texture.  For example the D3D10_SUBRESOURCE_DATA structure could represent a 32 by 32 subsection of a 128 by 128 texture.   The value for SysMemSlicePitch will reflect any padding included in SysMemPitch.	
    /// </remarks>	
    /// <unmanaged>D3D10_SUBRESOURCE_DATA</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    internal  partial struct SubResourceData {	
        
        /// <summary>	
        /// Pointer to the initialization data.	
        /// </summary>	
        /// <unmanaged>const void* pSysMem</unmanaged>
        public IntPtr DataPointer;
        
        /// <summary>	
        /// The distance (in bytes) from the beginning of one line of a texture to the next line.   System-memory pitch is used only for 2D and 3D texture data as it is has no meaning for the other resource types.	
        /// </summary>	
        /// <unmanaged>UINT SysMemPitch</unmanaged>
        public int Pitch;
        
        /// <summary>	
        /// The distance (in bytes) from the beginning of one depth level to the next.   System-memory-slice pitch is only used for 3D texture data as it has no meaning for the other resource types.	
        /// </summary>	
        /// <unmanaged>UINT SysMemSlicePitch</unmanaged>
        public int SlicePitch;
    }
    
    /// <summary>	
    /// Describes a {{buffer}} resource.	
    /// </summary>	
    /// <remarks>	
    /// This structure is used by <see cref="SlimDX2.Direct3D10.Device.CreateBuffer"/> to create buffer resources.In addition to this structure, there is also a derived structure in D3D10.h (CD3D10_BUFFER_DESC) which behaves like an inherited class to help create a buffer description.	
    /// </remarks>	
    /// <unmanaged>D3D10_BUFFER_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct BufferDescription {	
        
        /// <summary>	
        /// Size of the buffer in bytes.	
        /// </summary>	
        /// <unmanaged>UINT ByteWidth</unmanaged>
        public int SizeInBytes;
        
        /// <summary>	
        /// Identify how the buffer is expected to be read from and written to. Frequency of update is a key factor. The most common value is typically D3D10_USAGE_DEFAULT; see <see cref="SlimDX2.Direct3D10.ResourceUsage"/> for all possible values.	
        /// </summary>	
        /// <unmanaged>D3D10_USAGE Usage</unmanaged>
        public SlimDX2.Direct3D10.ResourceUsage Usage;
        
        /// <summary>	
        /// Identify how the buffer will be bound to the {{pipeline}}. Applications can logicaly OR flags together (see <see cref="SlimDX2.Direct3D10.BindFlags"/>) to indicate that the buffer can be accessed in different ways.	
        /// </summary>	
        /// <unmanaged>UINT BindFlags</unmanaged>
        public SlimDX2.Direct3D10.BindFlags BindFlags;
        
        /// <summary>	
        /// CPU access flags (see <see cref="SlimDX2.Direct3D10.CpuAccessFlags"/>) or 0 if no CPU access is necessary. Applications can logicaly OR flags together.	
        /// </summary>	
        /// <unmanaged>UINT CPUAccessFlags</unmanaged>
        public SlimDX2.Direct3D10.CpuAccessFlags CpuAccessFlags;
        
        /// <summary>	
        /// Miscellaneous flags (see <see cref="SlimDX2.Direct3D10.ResourceOptionFlags"/>) or 0 if unused. Applications can logically OR flags together.	
        /// </summary>	
        /// <unmanaged>UINT MiscFlags</unmanaged>
        public SlimDX2.Direct3D10.ResourceOptionFlags OptionFlags;
    }
    
    /// <summary>	
    /// Describes a {{1D texture}}.	
    /// </summary>	
    /// <remarks>	
    /// This structure is used in a call to <see cref="SlimDX2.Direct3D10.Device.CreateTexture1D"/>. A helpful derived structure CD3D10_TEXTURE1D_DESC is declared in D3D10.h, to help create a texture description.	
    /// </remarks>	
    /// <unmanaged>D3D10_TEXTURE1D_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct Texture1DDescription {	
        
        /// <summary>	
        /// Texture width (in texels). The range is from 1 to D3D10_REQ_TEXTURE1D_U_DIMENSION (8192).	
        /// </summary>	
        /// <unmanaged>UINT Width</unmanaged>
        public int Width;
        
        /// <summary>	
        /// Number of subtextures (also called mipmap levels). Use 1 for a multisampled texture; or 0 to generate a full set of subtextures.	
        /// </summary>	
        /// <unmanaged>UINT MipLevels</unmanaged>
        public int MipLevels;
        
        /// <summary>	
        /// Number of textures in the array. The range is from 1 to D3D10_REQ_TEXTURE1D_ARRAY_AXIS_DIMENSION (512).	
        /// </summary>	
        /// <unmanaged>UINT ArraySize</unmanaged>
        public int ArraySize;
        
        /// <summary>	
        /// Texture format (see <see cref="SlimDX2.DXGI.Format"/>).	
        /// </summary>	
        /// <unmanaged>DXGI_FORMAT Format</unmanaged>
        public SlimDX2.DXGI.Format Format;
        
        /// <summary>	
        /// Value that identifies how the texture is to be read from and written to. The most common value is D3D10_USAGE-DEFAULT; see <see cref="SlimDX2.Direct3D10.ResourceUsage"/> for all possible values.	
        /// </summary>	
        /// <unmanaged>D3D10_USAGE Usage</unmanaged>
        public SlimDX2.Direct3D10.ResourceUsage Usage;
        
        /// <summary>	
        /// Flags (see <see cref="SlimDX2.Direct3D10.BindFlags"/>) for binding to {{pipeline}} stages. The flags can be combined by a logical OR.	
        /// </summary>	
        /// <unmanaged>UINT BindFlags</unmanaged>
        public SlimDX2.Direct3D10.BindFlags BindFlags;
        
        /// <summary>	
        /// Flags (see <see cref="SlimDX2.Direct3D10.CpuAccessFlags"/>) to specify the types of CPU access allowed. Use 0 if CPU access is not required. These flags can be combined with a logical OR.	
        /// </summary>	
        /// <unmanaged>UINT CPUAccessFlags</unmanaged>
        public SlimDX2.Direct3D10.CpuAccessFlags CpuAccessFlags;
        
        /// <summary>	
        /// Flags (see <see cref="SlimDX2.Direct3D10.ResourceOptionFlags"/>) that identify other, less common resource options. Use 0 if none of these flags apply. These flags can be combined with a logical OR.	
        /// </summary>	
        /// <unmanaged>UINT MiscFlags</unmanaged>
        public SlimDX2.Direct3D10.ResourceOptionFlags OptionFlags;
    }
    
    /// <summary>	
    /// Describes a {{2D texture}}.	
    /// </summary>	
    /// <remarks>	
    /// This structure is used in a call to <see cref="SlimDX2.Direct3D10.Device.CreateTexture2D"/>. A helpful derived structure CD3D10_TEXTURE2D_DESC is declared in D3D10.h, to help create a texture description.The device places some size restrictions (must be multiples of a minimum size) for a subsampled, {{block compressed}}, or bit-format resource.	
    /// </remarks>	
    /// <unmanaged>D3D10_TEXTURE2D_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct Texture2DDescription {	
        
        /// <summary>	
        /// Texture width (in texels). The range is from 1 to D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION (8192). For a texture cube-map, the range is from 1 to D3D10_REQ_TEXTURECUBE_DIMENSION (8192). For more information about restrictions, see Remarks.	
        /// </summary>	
        /// <unmanaged>UINT Width</unmanaged>
        public int Width;
        
        /// <summary>	
        /// Texture height (in texels). The range is from 1 to D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION (8192). For a texture cube-map, the range is from 1 to D3D10_REQ_TEXTURECUBE_DIMENSION (8192). For more information about restrictions, see Remarks.	
        /// </summary>	
        /// <unmanaged>UINT Height</unmanaged>
        public int Height;
        
        /// <summary>	
        /// Number of subtextures (also called mipmap levels). Use 1 for a multisampled texture; or 0 to generate a full set of subtextures.	
        /// </summary>	
        /// <unmanaged>UINT MipLevels</unmanaged>
        public int MipLevels;
        
        /// <summary>	
        /// Number of textures in the texture array. The range is from 1 to D3D10_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION (512). For a texture cube-map, this value is a multiple of 6 (that is, 6 * the value in the NumCubes member of <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription1.TextureCubeArrayResource1"/>), and the range is from 6 to D3D10_REQ_TEXTURECUBE_DIMENSION.	
        /// </summary>	
        /// <unmanaged>UINT ArraySize</unmanaged>
        public int ArraySize;
        
        /// <summary>	
        /// Texture format (see <see cref="SlimDX2.DXGI.Format"/>).	
        /// </summary>	
        /// <unmanaged>DXGI_FORMAT Format</unmanaged>
        public SlimDX2.DXGI.Format Format;
        
        /// <summary>	
        /// Structure that specifies multisampling parameters for the texture. See <see cref="SlimDX2.DXGI.SampleDescription"/>.	
        /// </summary>	
        /// <unmanaged>DXGI_SAMPLE_DESC SampleDesc</unmanaged>
        public SlimDX2.DXGI.SampleDescription SampleDescription;
        
        /// <summary>	
        /// Value that identifies how the texture is to be read from and written to. The most common value is D3D10_USAGE-DEFAULT; see <see cref="SlimDX2.Direct3D10.ResourceUsage"/> for all possible values.	
        /// </summary>	
        /// <unmanaged>D3D10_USAGE Usage</unmanaged>
        public SlimDX2.Direct3D10.ResourceUsage Usage;
        
        /// <summary>	
        /// Flags (see <see cref="SlimDX2.Direct3D10.BindFlags"/>) for binding to {{pipeline}} stages. The flags can be combined by a logical OR.	
        /// </summary>	
        /// <unmanaged>UINT BindFlags</unmanaged>
        public SlimDX2.Direct3D10.BindFlags BindFlags;
        
        /// <summary>	
        /// Flags (see <see cref="SlimDX2.Direct3D10.CpuAccessFlags"/>) to specify the types of CPU access allowed. Use 0 if CPU access is not required. These flags can be combined with a logical OR.	
        /// </summary>	
        /// <unmanaged>UINT CPUAccessFlags</unmanaged>
        public SlimDX2.Direct3D10.CpuAccessFlags CpuAccessFlags;
        
        /// <summary>	
        /// Flags (see <see cref="SlimDX2.Direct3D10.ResourceOptionFlags"/>) that identify other, less common resource options. Use 0 if none of these flags apply. These flags can be combined with a logical OR. For a texture cube-map, set the <see cref="SlimDX2.Direct3D10.ResourceOptionFlags.Texturecube"/> flag. Cube-map arrays (that is, ArraySize &gt; 6) require feature level <see cref="SlimDX2.Direct3D.FeatureLevel.Level_10_1"/>.	
        /// </summary>	
        /// <unmanaged>UINT MiscFlags</unmanaged>
        public SlimDX2.Direct3D10.ResourceOptionFlags OptionFlags;
    }
    
    /// <summary>	
    /// Provides access to {{subresource}} data in a 2D texture.	
    /// </summary>	
    /// <remarks>	
    /// This structure is used in a call to {{Map}}.To illustrate the row pitch, assume an uncompressed 2D texture with mipmap levels, as shown in the following illustration.?Illustration of an uncompressed 2D texture with mipmap levels?Visualize the top-level texture drawn in a single plane like the following illustration.?Illustration of a single plane?However, the actual layout of each element in memory looks more like the following illustration.?Illustration of the row pitch in memory?For this example, the row pitch encompasses 5 elements (one row), whose size would be five times the number of bytes per element.Use row pitch to advance a pointer between rows within a single 2D texture plane.ExampleTo access data in, say, the third mipmap level, you must cast the pData pointer as demonstrated in the following example for a floating-point texture.	
    /// <code> D3D10_MAPPED_TEXTURE2D mappedTexture;	
    /// if( SUCCEEDED( pTexture-&gt;Map( D3D10CalcSubresource(2, 0, 3), D3D10_MAP_WRITE_DISCARD, 0, &amp;mappedTexture )))	
    /// { D3D10_TEXTURE2D_DESC desc; pTexture-&gt;GetDesc( &amp;desc ); // Compute the width and height of the third mipmap level const UINT WIDTH = desc.Width &gt;&gt; 2; const UINT HEIGHT = desc.Height &gt;&gt; 2; FLOAT* pTexels = (FLOAT*)mappedTexture.pData; for( UINT row = 0; row &lt; HEIGHT; row++ ) { UINT rowStart = row * mappedTexture.RowPitch/4; for( UINT col = 0; col &lt; WIDTH; col++ ) { pTexels[rowStart + col*4 + 0]; // Red pTexels[rowStart + col*4 + 1]; // Green pTexels[rowStart + col*4 + 2]; // Blue pTexels[rowStart + col*4 + 3]; // Alpha } } pTexture-&gt;Unmap(D3D10CalcSubresource(2, 0, 3));	
    /// } </code>	
    /// 	
    /// </remarks>	
    /// <unmanaged>D3D10_MAPPED_TEXTURE2D</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct MappedTexture2D {	
        
        /// <summary>	
        /// Pointer to the data.	
        /// </summary>	
        /// <unmanaged>void* pData</unmanaged>
        public IntPtr PData;
        
        /// <summary>	
        /// The pitch, or width, or physical size (in bytes), of one row of an uncompressed texture. A block-compressed texture is encoded in 4x4 blocks (see {{virtual size vs physical size}}) ; therefore, RowPitch is the number of bytes in a block of 4x4 texels.	
        /// </summary>	
        /// <unmanaged>UINT RowPitch</unmanaged>
        public int RowPitch;
    }
    
    /// <summary>	
    /// Describes a {{3D texture}}.	
    /// </summary>	
    /// <remarks>	
    /// This structure is used in a call to <see cref="SlimDX2.Direct3D10.Device.CreateTexture3D"/>. A helpful derived structure CD3D10_TEXTURE3D_DESC is declared in D3D10.h, to help create a texture description.The device restricts the size of subsampled, block compressed (see {{Block Compression (Direct3D 10)}}), and bit format resources to be multiples of sizes specific to each format.	
    /// </remarks>	
    /// <unmanaged>D3D10_TEXTURE3D_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct Texture3DDescription {	
        
        /// <summary>	
        /// Texture width (in texels). The range is from 1 to D3D10_REQ_TEXTURE3D_U_V_OR_W_DIMENSION (2048). For more information about restrictions, see Remarks.	
        /// </summary>	
        /// <unmanaged>UINT Width</unmanaged>
        public int Width;
        
        /// <summary>	
        /// Texture height (in texels). The range is from 1 to D3D10_REQ_TEXTURE3D_U_V_OR_W_DIMENSION (2048). For more information about restrictions, see Remarks.	
        /// </summary>	
        /// <unmanaged>UINT Height</unmanaged>
        public int Height;
        
        /// <summary>	
        /// Texture depth (in texels). The range is from 1 to D3D10_REQ_TEXTURE3D_U_V_OR_W_DIMENSION (2048).	
        /// </summary>	
        /// <unmanaged>UINT Depth</unmanaged>
        public int Depth;
        
        /// <summary>	
        /// Number of subtextures (also called mipmap levels). Use 1 for a multisampled texture; or 0 to generate a full set of subtextures.	
        /// </summary>	
        /// <unmanaged>UINT MipLevels</unmanaged>
        public int MipLevels;
        
        /// <summary>	
        /// Texture format (see <see cref="SlimDX2.DXGI.Format"/>).	
        /// </summary>	
        /// <unmanaged>DXGI_FORMAT Format</unmanaged>
        public SlimDX2.DXGI.Format Format;
        
        /// <summary>	
        /// Value that identifies how the texture is to be read from and written to. The most common value is D3D10_USAGE-DEFAULT; see <see cref="SlimDX2.Direct3D10.ResourceUsage"/> for all possible values.	
        /// </summary>	
        /// <unmanaged>D3D10_USAGE Usage</unmanaged>
        public SlimDX2.Direct3D10.ResourceUsage Usage;
        
        /// <summary>	
        /// Flags (see <see cref="SlimDX2.Direct3D10.BindFlags"/>) for binding to {{pipeline}} stages. The flags can be combined by a logical OR.	
        /// </summary>	
        /// <unmanaged>UINT BindFlags</unmanaged>
        public SlimDX2.Direct3D10.BindFlags BindFlags;
        
        /// <summary>	
        /// Flags (see <see cref="SlimDX2.Direct3D10.CpuAccessFlags"/>) to specify the types of CPU access allowed. Use 0 if CPU access is not required. These flags can be combined with a logical OR.	
        /// </summary>	
        /// <unmanaged>UINT CPUAccessFlags</unmanaged>
        public SlimDX2.Direct3D10.CpuAccessFlags CpuAccessFlags;
        
        /// <summary>	
        /// Flags (see <see cref="SlimDX2.Direct3D10.ResourceOptionFlags"/>) that identify other, less common resource options. Use 0 if none of these flags apply. These flags can be combined with a logical OR.	
        /// </summary>	
        /// <unmanaged>UINT MiscFlags</unmanaged>
        public SlimDX2.Direct3D10.ResourceOptionFlags OptionFlags;
    }
    
    /// <summary>	
    /// Provides access to {{subresource}} data in a {{3D texture}}.	
    /// </summary>	
    /// <remarks>	
    /// This structure is used to access subresource data when calling <see cref="SlimDX2.Direct3D10.Texture3D.Map"/>. To access data, you must cast the pData pointer; see <see cref="SlimDX2.Direct3D10.MappedTexture2D"/> for an example.To illustrate pitch for an uncompressed texture, assume a 3D texture with mipmap levels, as shown in the following illustration.?Illustration of a 3D texture with mipmap levels?It is easiest to consider the top-level texture only, as shown in the following illustration.?Illustration of only the top-level texture?And then visualize the top-level texture redrawn as a series of 2D textures, each one having a different depth value. This yields several texture planes, as shown in the following illustration.?Illustration of top-level texture drawn as 2D texture planes?However, the actual layout of all the elements from all the texture planes looks more like the following illustration.?Illustration of the row pitch and depth pitch in memory?Use row pitch to advance a pointer between rows within a single 2D texture plane; use depth pitch to advance a pointer between 2D texture planes.	
    /// </remarks>	
    /// <unmanaged>D3D10_MAPPED_TEXTURE3D</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct MappedTexture3D {	
        
        /// <summary>	
        /// Pointer to the data.	
        /// </summary>	
        /// <unmanaged>void* pData</unmanaged>
        public IntPtr PData;
        
        /// <summary>	
        /// The pitch, or width, or physical size (in bytes) of one row of an uncompressed texture. Since a block-compressed texture is encoded in 4x4 blocks, the RowPitch for a compressed texture is the number of bytes in a block of 4x4 texels. See {{virtual size vs physical size}} for more information on block compression.	
        /// </summary>	
        /// <unmanaged>UINT RowPitch</unmanaged>
        public int RowPitch;
        
        /// <summary>	
        /// The pitch or number of bytes in all rows for a single depth.	
        /// </summary>	
        /// <unmanaged>UINT DepthPitch</unmanaged>
        public int DepthPitch;
    }
    
    /// <summary>	
    /// Describes a shader-resource view.	
    /// </summary>	
    /// <remarks>	
    /// A view is a format-specific way to look at the data in a resource. The view determines what data to look at, and how it is cast when read. For more information about how views work, see {{Views}}When viewing a resource, the resource-view description must specify a typed format, that is compatible with the resource format. So that means that you cannot create a resource-view description using any format with _TYPELESS in the name. You can however view a typeless resource by specifying a typed format for the view. For example, a DXGI_FORMAT_R32G32B32_TYPELESS resource can be viewed with one of these typed formats: DXGI_FORMAT_R32G32B32_FLOAT, DXGI_FORMAT_R32G32B32_UINT, and DXGI_FORMAT_R32G32B32_SINT, since these typed formats are compatible with the typeless resource.Create a shader-resource-view description by calling <see cref="SlimDX2.Direct3D10.Device.CreateShaderResourceView"/>. To view a shader-resource-view description, call <see cref="SlimDX2.Direct3D10.ShaderResourceView.GetDescription"/>.	
    /// </remarks>	
    /// <unmanaged>D3D10_SHADER_RESOURCE_VIEW_DESC</unmanaged>
    [StructLayout(LayoutKind.Explicit, Pack = 0 )]
    public  partial struct ShaderResourceViewDescription {	
        
        /// <summary>	
        /// Specifies the elements in a {{buffer}} resource to use in a shader-resource view.	
        /// </summary>	
        /// <remarks>	
        /// The D3D10_BUFFER_SRV structure is a member of the  <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription"/> structure, which represents a shader-resource view description. You can create a shader-resource view by calling the <see cref="SlimDX2.Direct3D10.Device.CreateShaderResourceView"/> method.	
        /// </remarks>	
        /// <unmanaged>D3D10_BUFFER_SRV</unmanaged>
        [StructLayout(LayoutKind.Explicit, Pack = 0 )]
        public  partial struct BufferResource {	
            
            /// <summary>	
            /// The offset of the first element in the view to access, relative to element 0.	
            /// </summary>	
            /// <unmanaged>UINT FirstElement</unmanaged>
            [FieldOffset(0)]
            public int FirstElement;
            
            /// <summary>	
            /// The total number of elements in the view.	
            /// </summary>	
            /// <unmanaged>UINT ElementOffset</unmanaged>
            [FieldOffset(0)]
            public int ElementOffset;
            
            /// <summary>	
            /// No documentation.	
            /// </summary>	
            /// <unmanaged>UINT NumElements</unmanaged>
            [FieldOffset(4)]
            public int ElementCount;
            
            /// <summary>	
            /// No documentation.	
            /// </summary>	
            /// <unmanaged>UINT ElementWidth</unmanaged>
            [FieldOffset(4)]
            public int ElementWidth;
        }
        
        /// <summary>	
        /// Specifies the {{subresource}} from a {{1D texture}} to use in a shader-resource view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a shader-resource-view description (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription"/>).	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX1D_SRV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture1DResource {	
            
            /// <summary>	
            /// Index of the most detailed mipmap level to use; this number is between 0 and MipLevels -1.	
            /// </summary>	
            /// <unmanaged>UINT MostDetailedMip</unmanaged>
            public int MostDetailedMip;
            
            /// <summary>	
            /// Number of mipmap levels to use.	
            /// </summary>	
            /// <unmanaged>UINT MipLevels</unmanaged>
            public int MipLevels;
        }
        
        /// <summary>	
        /// Specifies the {{subresource(s)}} from an array of {{1D textures}} to use in a shader-resource view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a shader-resource-view description (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription"/>).	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX1D_ARRAY_SRV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture1DArrayResource {	
            
            /// <summary>	
            /// Index of the most detailed mipmap level to use; this number is between 0 and MipLevels -1.	
            /// </summary>	
            /// <unmanaged>UINT MostDetailedMip</unmanaged>
            public int MostDetailedMip;
            
            /// <summary>	
            /// Number of subtextures to access.	
            /// </summary>	
            /// <unmanaged>UINT MipLevels</unmanaged>
            public int MipLevels;
            
            /// <summary>	
            /// The index of the first texture to use in an array of textures (see {{array slice}})	
            /// </summary>	
            /// <unmanaged>UINT FirstArraySlice</unmanaged>
            public int FirstArraySlice;
            
            /// <summary>	
            /// Number of textures in the array.	
            /// </summary>	
            /// <unmanaged>UINT ArraySize</unmanaged>
            public int ArraySize;
        }
        
        /// <summary>	
        /// Specifies the {{subresource}} from a {{2D texture}} to use in a shader-resource view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a shader-resource-view description (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription"/>).	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX2D_SRV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture2DResource {	
            
            /// <summary>	
            /// Index of the most detailed mipmap level to use; this number is between 0 and MipLevels -1.	
            /// </summary>	
            /// <unmanaged>UINT MostDetailedMip</unmanaged>
            public int MostDetailedMip;
            
            /// <summary>	
            /// Number of mipmap levels to use.	
            /// </summary>	
            /// <unmanaged>UINT MipLevels</unmanaged>
            public int MipLevels;
        }
        
        /// <summary>	
        /// Specifies the {{subresource(s)}} from an array of {{2D textures}} to use in a shader-resource view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a shader-resource-view description (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription"/>).	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX2D_ARRAY_SRV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture2DArrayResource {	
            
            /// <summary>	
            /// Index of the most detailed mipmap level to use; this number is between 0 and MipLevels -1.	
            /// </summary>	
            /// <unmanaged>UINT MostDetailedMip</unmanaged>
            public int MostDetailedMip;
            
            /// <summary>	
            /// Number of subtextures to access.	
            /// </summary>	
            /// <unmanaged>UINT MipLevels</unmanaged>
            public int MipLevels;
            
            /// <summary>	
            /// The index of the first texture to use in an array of textures (see {{array slice}})	
            /// </summary>	
            /// <unmanaged>UINT FirstArraySlice</unmanaged>
            public int FirstArraySlice;
            
            /// <summary>	
            /// Number of textures in the array.	
            /// </summary>	
            /// <unmanaged>UINT ArraySize</unmanaged>
            public int ArraySize;
        }
        
        /// <summary>	
        /// Specifies the {{subresource(s)}} from a {{3D texture}} to use in a shader-resource view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a shader-resource-view description (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription"/>).	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX3D_SRV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture3DResource {	
            
            /// <summary>	
            /// Index of the most detailed mipmap level to use; this number is between 0 and MipLevels -1.	
            /// </summary>	
            /// <unmanaged>UINT MostDetailedMip</unmanaged>
            public int MostDetailedMip;
            
            /// <summary>	
            /// Number of mipmap levels to use.	
            /// </summary>	
            /// <unmanaged>UINT MipLevels</unmanaged>
            public int MipLevels;
        }
        
        /// <summary>	
        /// Specifies the {{subresource}} from a {{cube texture}} to use in a shader-resource view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a shader-resource-view description (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription"/>).	
        /// </remarks>	
        /// <unmanaged>D3D10_TEXCUBE_SRV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct TextureCubeResource {	
            
            /// <summary>	
            /// Index of the most detailed mipmap level to use; this number is between 0 and MipLevels -1.	
            /// </summary>	
            /// <unmanaged>UINT MostDetailedMip</unmanaged>
            public int MostDetailedMip;
            
            /// <summary>	
            /// Number of mipmap levels to use.	
            /// </summary>	
            /// <unmanaged>UINT MipLevels</unmanaged>
            public int MipLevels;
        }
        
        /// <summary>	
        /// Specifies the {{subresource(s)}} from a multisampled {{2D texture}} to use in a shader-resource view.	
        /// </summary>	
        /// <remarks>	
        /// Since a multisampled 2D texture contains a single subresource, there is actually nothing to specify in <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription.Texture2DMultisampledResource"/>. Consequently, UnusedField_NothingToDefine is included so that this structure will compile in C.	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX2DMS_SRV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture2DMultisampledResource {	
            
            /// <summary>	
            /// Integer of any value. See remarks.	
            /// </summary>	
            /// <unmanaged>UINT UnusedField_NothingToDefine</unmanaged>
            public int UnusedFieldNothingToDefine;
        }
        
        /// <summary>	
        /// Specifies the {{subresource(s)}} from an array of multisampled {{2D textures}} to use in a shader-resource view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a shader-resource-view description (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription"/>).	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX2DMS_ARRAY_SRV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture2DMultisampledArrayResource {	
            
            /// <summary>	
            /// The index of the first texture to use in an array of textures (see {{array slice}})	
            /// </summary>	
            /// <unmanaged>UINT FirstArraySlice</unmanaged>
            public int FirstArraySlice;
            
            /// <summary>	
            /// Number of textures to use.	
            /// </summary>	
            /// <unmanaged>UINT ArraySize</unmanaged>
            public int ArraySize;
        }
        
        /// <summary>	
        /// The viewing {{format}}. See remarks.	
        /// </summary>	
        /// <unmanaged>DXGI_FORMAT Format</unmanaged>
        [FieldOffset(0)]
        public SlimDX2.DXGI.Format Format;
        
        /// <summary>	
        /// The resource type of the view. See <see cref="SlimDX2.Direct3D.ShaderResourceViewDimension"/>. This should be the same as the resource type of the underlying resource. This parameter also determines which _SRV to use in the union below.	
        /// </summary>	
        /// <unmanaged>D3D10_SRV_DIMENSION ViewDimension</unmanaged>
        [FieldOffset(4)]
        public SlimDX2.Direct3D.ShaderResourceViewDimension ViewDimension;
        
        /// <summary>	
        /// View the resource as a buffer using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.BufferResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_BUFFER_SRV Buffer</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.BufferResource Buffer;
        
        /// <summary>	
        /// View the resource as a 1D texture using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture1DResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEX1D_SRV Texture1D</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture1DResource Texture1D;
        
        /// <summary>	
        /// View the resource as a 1D-texture array using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture1DArrayResource"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_TEX1D_ARRAY_SRV Texture1DArray</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture1DArrayResource Texture1DArray;
        
        /// <summary>	
        /// View the resource as a 2D-texture using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture2DResource"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_TEX2D_SRV Texture2D</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture2DResource Texture2D;
        
        /// <summary>	
        /// View the resource as a 2D-texture array using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture2DArrayResource"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_TEX2D_ARRAY_SRV Texture2DArray</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture2DArrayResource Texture2DArray;
        
        /// <summary>	
        /// View the resource as a 2D-multisampled texture using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture2DMultisampledResource"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_TEX2DMS_SRV Texture2DMS</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture2DMultisampledResource Texture2DMS;
        
        /// <summary>	
        /// View the resource as a 2D-multisampled-texture array using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture2DMultisampledArrayResource"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_TEX2DMS_ARRAY_SRV Texture2DMSArray</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture2DMultisampledArrayResource Texture2DMSArray;
        
        /// <summary>	
        /// View the resource as a 3D texture using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture3DResource"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_TEX3D_SRV Texture3D</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture3DResource Texture3D;
        
        /// <summary>	
        /// View the resource as a 3D-cube texture using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.TextureCubeResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEXCUBE_SRV TextureCube</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.TextureCubeResource TextureCube;
    }
    
    /// <summary>	
    /// Specifies the {{subresource(s)}} from a resource that are accessible using a render-target view.	
    /// </summary>	
    /// <remarks>	
    /// A render-target-view description is passed into <see cref="SlimDX2.Direct3D10.Device.CreateRenderTargetView"/> to create a render target.A render-target-view cannot use the following formats:Any {{typeless format}}.<see cref="SlimDX2.DXGI.Format"/> if the view will be used to bind a buffer (vertex, index, constant, or stream-output).If the format is set to <see cref="SlimDX2.DXGI.Format"/>, then the format of the resource that the view binds to the pipeline will be used.	
    /// </remarks>	
    /// <unmanaged>D3D10_RENDER_TARGET_VIEW_DESC</unmanaged>
    [StructLayout(LayoutKind.Explicit, Pack = 0 )]
    public  partial struct RenderTargetViewDescription {	
        
        /// <summary>	
        /// Specifies the elements from a {{buffer}} resource to use in a render-target view.	
        /// </summary>	
        /// <remarks>	
        /// A render-target view is a member of a render-target-view description (see <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription"/>). Create a render-target view by calling <see cref="SlimDX2.Direct3D10.Device.CreateRenderTargetView"/>.	
        /// </remarks>	
        /// <unmanaged>D3D10_BUFFER_RTV</unmanaged>
        [StructLayout(LayoutKind.Explicit, Pack = 0 )]
        public  partial struct BufferResource {	
            
            /// <summary>	
            /// The offset (that is, the number of elements) between the beginning of the buffer and the first element that is to be used in the view, starting at 0.	
            /// </summary>	
            /// <unmanaged>UINT FirstElement</unmanaged>
            [FieldOffset(0)]
            public int FirstElement;
            
            /// <summary>	
            /// The number of elements in the view.	
            /// </summary>	
            /// <unmanaged>UINT ElementOffset</unmanaged>
            [FieldOffset(0)]
            public int ElementOffset;
            
            /// <summary>	
            /// No documentation.	
            /// </summary>	
            /// <unmanaged>UINT NumElements</unmanaged>
            [FieldOffset(4)]
            public int ElementCount;
            
            /// <summary>	
            /// No documentation.	
            /// </summary>	
            /// <unmanaged>UINT ElementWidth</unmanaged>
            [FieldOffset(4)]
            public int ElementWidth;
        }
        
        /// <summary>	
        /// Specifies the {{subresource}} from a {{1D texture}} to use in a render-target view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a render-target-view description (see <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription"/>).	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX1D_RTV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture1DResource {	
            
            /// <summary>	
            /// The index of the mipmap level to use (see {{mip slice}}).	
            /// </summary>	
            /// <unmanaged>UINT MipSlice</unmanaged>
            public int MipSlice;
        }
        
        /// <summary>	
        /// Specifies the {{subresource(s)}} from an array of {{1D textures}} to use in a render-target view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a render-target-view description (see <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription"/>).	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX1D_ARRAY_RTV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture1DArrayResource {	
            
            /// <summary>	
            /// The index of the mipmap level to use (see {{mip slice}}).	
            /// </summary>	
            /// <unmanaged>UINT MipSlice</unmanaged>
            public int MipSlice;
            
            /// <summary>	
            /// The index of the first texture to use in an array of textures (see {{array slice}})	
            /// </summary>	
            /// <unmanaged>UINT FirstArraySlice</unmanaged>
            public int FirstArraySlice;
            
            /// <summary>	
            /// Number of textures to use.	
            /// </summary>	
            /// <unmanaged>UINT ArraySize</unmanaged>
            public int ArraySize;
        }
        
        /// <summary>	
        /// Specifies the {{subresource}} from a {{2D texture}} to use in a render-target view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a render-target-view description (see <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription"/>).	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX2D_RTV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture2DResource {	
            
            /// <summary>	
            /// The index of the mipmap level to use (see {{mip slice}}).	
            /// </summary>	
            /// <unmanaged>UINT MipSlice</unmanaged>
            public int MipSlice;
        }
        
        /// <summary>	
        /// Specifies the {{subresource}} from a multisampled {{2D texture}} to use in a render-target view.	
        /// </summary>	
        /// <remarks>	
        /// Since a multisampled 2D texture contains a single subresource, there is actually nothing to specify in D3D10_TEX2DMS_RTV. Consequently, UnusedField_NothingToDefine is included so that this structure will compile in C.	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX2DMS_RTV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture2DMultisampledResource {	
            
            /// <summary>	
            /// Integer of any value. See remarks.	
            /// </summary>	
            /// <unmanaged>UINT UnusedField_NothingToDefine</unmanaged>
            public int UnusedFieldNothingToDefine;
        }
        
        /// <summary>	
        /// Specifies the {{subresource(s)}} from an array of {{2D textures}} to use in a render-target view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a render-target-view description (see <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription"/>).	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX2D_ARRAY_RTV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture2DArrayResource {	
            
            /// <summary>	
            /// The index of the mipmap level to use (see {{mip slice}}).	
            /// </summary>	
            /// <unmanaged>UINT MipSlice</unmanaged>
            public int MipSlice;
            
            /// <summary>	
            /// The index of the first texture to use in an array of textures (see {{array slice}})	
            /// </summary>	
            /// <unmanaged>UINT FirstArraySlice</unmanaged>
            public int FirstArraySlice;
            
            /// <summary>	
            /// Number of textures in the array to use in the render target view, starting from FirstArraySlice.	
            /// </summary>	
            /// <unmanaged>UINT ArraySize</unmanaged>
            public int ArraySize;
        }
        
        /// <summary>	
        /// Specifies the {{subresource(s)}} from a an array of multisampled {{2D textures}} to use in a render-target view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a render-target-view description (see <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription"/>).	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX2DMS_ARRAY_RTV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture2DMultisampledArrayResource {	
            
            /// <summary>	
            /// The index of the first texture to use in an array of textures (see {{array slice}})	
            /// </summary>	
            /// <unmanaged>UINT FirstArraySlice</unmanaged>
            public int FirstArraySlice;
            
            /// <summary>	
            /// Number of textures to use.	
            /// </summary>	
            /// <unmanaged>UINT ArraySize</unmanaged>
            public int ArraySize;
        }
        
        /// <summary>	
        /// Specifies the {{subresource(s)}} from a {{3D texture}} to use in a render-target view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a render target view. See <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription"/>.	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX3D_RTV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture3DResource {	
            
            /// <summary>	
            /// The index of the mipmap level to use (see {{mip slice}}).	
            /// </summary>	
            /// <unmanaged>UINT MipSlice</unmanaged>
            public int MipSlice;
            
            /// <summary>	
            /// First depth level to use.	
            /// </summary>	
            /// <unmanaged>UINT FirstWSlice</unmanaged>
            public int FirstWSlice;
            
            /// <summary>	
            /// Number of depth levels to use in the render-target view, starting from FirstWSlice. A value of -1 indicates all of the slices along the w axis, starting from FirstWSlice.	
            /// </summary>	
            /// <unmanaged>UINT WSize</unmanaged>
            public int WSize;
        }
        
        /// <summary>	
        /// The data format (see <see cref="SlimDX2.DXGI.Format"/>).	
        /// </summary>	
        /// <unmanaged>DXGI_FORMAT Format</unmanaged>
        [FieldOffset(0)]
        public SlimDX2.DXGI.Format Format;
        
        /// <summary>	
        /// The resource type (see <see cref="SlimDX2.Direct3D10.RenderTargetViewDimension"/>), which specifies how the render-target resource will be accessed.	
        /// </summary>	
        /// <unmanaged>D3D10_RTV_DIMENSION ViewDimension</unmanaged>
        [FieldOffset(4)]
        public SlimDX2.Direct3D10.RenderTargetViewDimension ViewDimension;
        
        /// <summary>	
        /// Specifies which buffer elements can be accessed (see <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription.BufferResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_BUFFER_RTV Buffer</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.RenderTargetViewDescription.BufferResource Buffer;
        
        /// <summary>	
        /// Specifies the subresources in a 1D texture that can be accessed (see <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription.Texture1DResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEX1D_RTV Texture1D</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.RenderTargetViewDescription.Texture1DResource Texture1D;
        
        /// <summary>	
        /// Specifies the subresources in a 1D texture array that can be accessed (see <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription.Texture1DArrayResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEX1D_ARRAY_RTV Texture1DArray</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.RenderTargetViewDescription.Texture1DArrayResource Texture1DArray;
        
        /// <summary>	
        /// Specifies the subresources in a 2D texture that can be accessed (see <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription.Texture2DResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEX2D_RTV Texture2D</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.RenderTargetViewDescription.Texture2DResource Texture2D;
        
        /// <summary>	
        /// Specifies the subresources in a 2D texture array that can be accessed (see <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription.Texture2DArrayResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEX2D_ARRAY_RTV Texture2DArray</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.RenderTargetViewDescription.Texture2DArrayResource Texture2DArray;
        
        /// <summary>	
        /// Specifies a single subresource because a multisampled 2D texture only contains one subresource (see <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription.Texture2DMultisampledResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEX2DMS_RTV Texture2DMS</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.RenderTargetViewDescription.Texture2DMultisampledResource Texture2DMS;
        
        /// <summary>	
        /// Specifies the subresources in a multisampled 2D texture array that can be accessed (see <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription.Texture2DMultisampledArrayResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEX2DMS_ARRAY_RTV Texture2DMSArray</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.RenderTargetViewDescription.Texture2DMultisampledArrayResource Texture2DMSArray;
        
        /// <summary>	
        /// Specifies subresources in a 3D texture that can be accessed (see <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription.Texture3DResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEX3D_RTV Texture3D</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.RenderTargetViewDescription.Texture3DResource Texture3D;
    }
    
    /// <summary>	
    /// Specifies the {{subresource(s)}} from a texture that are accessible using a depth-stencil view.	
    /// </summary>	
    /// <remarks>	
    /// These are valid formats for a depth-stencil view:DXGI_FORMAT_D16_UNORMDXGI_FORMAT_D24_UNORM_S8_UINTDXGI_FORMAT_D32_FLOATDXGI_FORMAT_D32_FLOAT_S8X24_UINTDXGI_FORMAT_UNKNOWNA depth-stencil view cannot use a {{typeless format}}.  If the format chosen is DXGI_FORMAT_UNKNOWN, then the format of the parent resource is used.A depth-stencil-view description is needed when calling <see cref="SlimDX2.Direct3D10.Device.CreateDepthStencilView"/>.	
    /// </remarks>	
    /// <unmanaged>D3D10_DEPTH_STENCIL_VIEW_DESC</unmanaged>
    [StructLayout(LayoutKind.Explicit, Pack = 0 )]
    public  partial struct DepthStencilViewDescription {	
        
        /// <summary>	
        /// Specifies the {{subresource}} from a {{1D texture}} that is accessible to a depth-stencil view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a depth-stencil-view description (see <see cref="SlimDX2.Direct3D10.DepthStencilViewDescription"/>).	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX1D_DSV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture1DResource {	
            
            /// <summary>	
            /// The index of the first mipmap level to use (see {{mip slice}}).	
            /// </summary>	
            /// <unmanaged>UINT MipSlice</unmanaged>
            public int MipSlice;
        }
        
        /// <summary>	
        /// Specifies the {{subresource(s)}} from an array of {{1D textures}} to use in a depth-stencil view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a depth-stencil-view description (see <see cref="SlimDX2.Direct3D10.DepthStencilViewDescription"/>).	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX1D_ARRAY_DSV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture1DArrayResource {	
            
            /// <summary>	
            /// The index of the first mipmap level to use (see {{mip slice}}).	
            /// </summary>	
            /// <unmanaged>UINT MipSlice</unmanaged>
            public int MipSlice;
            
            /// <summary>	
            /// The index of the first texture to use in an array of textures (see {{array slice}})	
            /// </summary>	
            /// <unmanaged>UINT FirstArraySlice</unmanaged>
            public int FirstArraySlice;
            
            /// <summary>	
            /// Number of textures to use.	
            /// </summary>	
            /// <unmanaged>UINT ArraySize</unmanaged>
            public int ArraySize;
        }
        
        /// <summary>	
        /// Specifies the {{subresource}} from a {{2D texture}} that is accessible to a depth-stencil view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a depth-stencil-view description (see <see cref="SlimDX2.Direct3D10.DepthStencilViewDescription"/>).	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX2D_DSV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture2DResource {	
            
            /// <summary>	
            /// The index of the first mipmap level to use (see {{mip slice}}).	
            /// </summary>	
            /// <unmanaged>UINT MipSlice</unmanaged>
            public int MipSlice;
        }
        
        /// <summary>	
        /// Specifies the {{subresource(s)}} from an array {{2D textures}} that are accessible to a depth-stencil view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a depth-stencil-view description (see <see cref="SlimDX2.Direct3D10.DepthStencilViewDescription"/>).	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX2D_ARRAY_DSV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture2DArrayResource {	
            
            /// <summary>	
            /// The index of the first mipmap level to use (see {{mip slice}}).	
            /// </summary>	
            /// <unmanaged>UINT MipSlice</unmanaged>
            public int MipSlice;
            
            /// <summary>	
            /// The index of the first texture to use in an array of textures (see {{array slice}})	
            /// </summary>	
            /// <unmanaged>UINT FirstArraySlice</unmanaged>
            public int FirstArraySlice;
            
            /// <summary>	
            /// Number of textures to use.	
            /// </summary>	
            /// <unmanaged>UINT ArraySize</unmanaged>
            public int ArraySize;
        }
        
        /// <summary>	
        /// Specifies the {{subresource}} from a multisampled {{2D texture}} that is accessible to a depth-stencil view.	
        /// </summary>	
        /// <remarks>	
        /// Since a multisampled 2D texture contains a single subtexture, there is nothing to specify; this unused member is included so that this structure will compile in C.	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX2DMS_DSV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture2DMultisampledResource {	
            
            /// <summary>	
            /// Unused.	
            /// </summary>	
            /// <unmanaged>UINT UnusedField_NothingToDefine</unmanaged>
            public int UnusedFieldNothingToDefine;
        }
        
        /// <summary>	
        /// Specifies the {{subresource(s)}} from an array of multisampled {{2D textures}} for a depth-stencil view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a depth-stencil-view description (see <see cref="SlimDX2.Direct3D10.DepthStencilViewDescription"/>).	
        /// </remarks>	
        /// <unmanaged>D3D10_TEX2DMS_ARRAY_DSV</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct Texture2DMultisampledArrayResource {	
            
            /// <summary>	
            /// The index of the first texture to use in an array of textures (see {{array slice}})	
            /// </summary>	
            /// <unmanaged>UINT FirstArraySlice</unmanaged>
            public int FirstArraySlice;
            
            /// <summary>	
            /// Number of textures to use.	
            /// </summary>	
            /// <unmanaged>UINT ArraySize</unmanaged>
            public int ArraySize;
        }
        
        /// <summary>	
        /// Resource data  format (see <see cref="SlimDX2.DXGI.Format"/>). See remarks for allowable formats.	
        /// </summary>	
        /// <unmanaged>DXGI_FORMAT Format</unmanaged>
        [FieldOffset(0)]
        public SlimDX2.DXGI.Format Format;
        
        /// <summary>	
        /// Type of resource (see <see cref="SlimDX2.Direct3D10.Dimension"/>). Specifies how a depth-stencil resource will be accessed; the value is stored in the union in this structure.	
        /// </summary>	
        /// <unmanaged>D3D10_DSV_DIMENSION ViewDimension</unmanaged>
        [FieldOffset(4)]
        public SlimDX2.Direct3D10.Dimension ViewDimension;
        
        /// <summary>	
        /// Specifies a 1D texture subresource (see <see cref="SlimDX2.Direct3D10.DepthStencilViewDescription.Texture1DResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEX1D_DSV Texture1D</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.DepthStencilViewDescription.Texture1DResource Texture1D;
        
        /// <summary>	
        /// Specifies an array of 1D texture subresources (see <see cref="SlimDX2.Direct3D10.DepthStencilViewDescription.Texture1DArrayResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEX1D_ARRAY_DSV Texture1DArray</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.DepthStencilViewDescription.Texture1DArrayResource Texture1DArray;
        
        /// <summary>	
        /// Specifies a 2D texture subresource (see <see cref="SlimDX2.Direct3D10.DepthStencilViewDescription.Texture2DResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEX2D_DSV Texture2D</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.DepthStencilViewDescription.Texture2DResource Texture2D;
        
        /// <summary>	
        /// Specifies an array of 2D texture subresources (see <see cref="SlimDX2.Direct3D10.DepthStencilViewDescription.Texture2DArrayResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEX2D_ARRAY_DSV Texture2DArray</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.DepthStencilViewDescription.Texture2DArrayResource Texture2DArray;
        
        /// <summary>	
        /// Specifies a multisampled 2D texture contains a single subresource (see <see cref="SlimDX2.Direct3D10.DepthStencilViewDescription.Texture2DMultisampledResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEX2DMS_DSV Texture2DMS</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.DepthStencilViewDescription.Texture2DMultisampledResource Texture2DMS;
        
        /// <summary>	
        /// Specifies a multisampled 2D texture contains a single subresource per texture (see <see cref="SlimDX2.Direct3D10.DepthStencilViewDescription.Texture2DMultisampledArrayResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEX2DMS_ARRAY_DSV Texture2DMSArray</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.DepthStencilViewDescription.Texture2DMultisampledArrayResource Texture2DMSArray;
    }
    
    /// <summary>	
    /// Describes a sampler state.	
    /// </summary>	
    /// <remarks>	
    /// These are the default values for sampler state.StateDefault ValueFilterMin_Mag_Mip_PointAddressUClampAddressVClampAddressWClampMinLOD0.0fMaxLOD3.402823466e+38F (FLT_MAX)MipMapLODBias0.0fMaxAnisotropy16ComparisonFuncNeverBorderColorfloat4(0.0f, 0.0f, 0.0f, 0.0f)TextureN/A?	
    /// </remarks>	
    /// <unmanaged>D3D10_SAMPLER_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct SamplerStateDescription {	
        
        /// <summary>	
        /// Filtering method to use when sampling a texture (see <see cref="SlimDX2.Direct3D10.Filter"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_FILTER Filter</unmanaged>
        public SlimDX2.Direct3D10.Filter Filter;
        
        /// <summary>	
        /// Method to use for resolving a u texture coordinate that is outside the 0 to 1 range (see <see cref="SlimDX2.Direct3D10.TextureAddressMode"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEXTURE_ADDRESS_MODE AddressU</unmanaged>
        public SlimDX2.Direct3D10.TextureAddressMode AddressU;
        
        /// <summary>	
        /// Method to use for resolving a v texture coordinate that is outside the 0 to 1 range.	
        /// </summary>	
        /// <unmanaged>D3D10_TEXTURE_ADDRESS_MODE AddressV</unmanaged>
        public SlimDX2.Direct3D10.TextureAddressMode AddressV;
        
        /// <summary>	
        /// Method to use for resolving a w texture coordinate that is outside the 0 to 1 range.	
        /// </summary>	
        /// <unmanaged>D3D10_TEXTURE_ADDRESS_MODE AddressW</unmanaged>
        public SlimDX2.Direct3D10.TextureAddressMode AddressW;
        
        /// <summary>	
        /// Offset from the calculated mipmap level. For example, if Direct3D calculates that a texture should be sampled at mipmap level 3 and MipLODBias is 2, then the texture will be sampled at mipmap level 5.	
        /// </summary>	
        /// <unmanaged>FLOAT MipLODBias</unmanaged>
        public float MipLODBias;
        
        /// <summary>	
        /// Clamping value used if D3D10_FILTER_ANISOTROPIC or D3D10_FILTER_COMPARISON_ANISOTROPIC is specified in Filter. Valid values are between 1 and 16.	
        /// </summary>	
        /// <unmanaged>UINT MaxAnisotropy</unmanaged>
        public int MaxAnisotropy;
        
        /// <summary>	
        /// A function that compares sampled data against existing sampled data. The function options are listed in <see cref="SlimDX2.Direct3D10.ComparisonFunction"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_COMPARISON_FUNC ComparisonFunc</unmanaged>
        public SlimDX2.Direct3D10.ComparisonFunction ComparisonFunc;
        
        /// <summary>	
        /// Border color to use if D3D10_TEXTURE_ADDRESS_BORDER is specified for AddressU, AddressV, or AddressW. Range must be between 0.0 and 1.0 inclusive.	
        /// </summary>	
        /// <unmanaged>FLOAT BorderColor[4]</unmanaged>
        public SlimMath.Vector4 BorderColor;
        
        /// <summary>	
        /// Lower end of the mipmap range to clamp access to, where 0 is the largest and most detailed mipmap level and any level higher than that is less detailed.	
        /// </summary>	
        /// <unmanaged>FLOAT MinLOD</unmanaged>
        public float MinLOD;
        
        /// <summary>	
        /// Upper end of the mipmap range to clamp access to, where 0 is the largest and most detailed mipmap level and any level higher than that is less detailed. This value must be greater than or equal to MinLOD. To have no upper limit on LOD set this to a large value such as D3D10_FLOAT32_MAX.	
        /// </summary>	
        /// <unmanaged>FLOAT MaxLOD</unmanaged>
        public float MaxLOD;
    }
    
    /// <summary>	
    /// Describes a query.	
    /// </summary>	
    /// <unmanaged>D3D10_QUERY_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct QueryDescription {	
        
        /// <summary>	
        /// Type of query (see <see cref="SlimDX2.Direct3D10.QueryType"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_QUERY Query</unmanaged>
        public SlimDX2.Direct3D10.QueryType Query;
        
        /// <summary>	
        /// Miscellaneous flags (see <see cref="SlimDX2.Direct3D10.QueryFlags"/>).	
        /// </summary>	
        /// <unmanaged>UINT MiscFlags</unmanaged>
        public SlimDX2.Direct3D10.QueryFlags QueryFlags;
    }
    
    /// <summary>	
    /// Query information about the reliability of a timestamp query.	
    /// </summary>	
    /// <remarks>	
    /// For a list of query types see <see cref="SlimDX2.Direct3D10.QueryType"/>.	
    /// </remarks>	
    /// <unmanaged>D3D10_QUERY_DATA_TIMESTAMP_DISJOINT</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct QueryDataTimestampDisjoint {	
        
        /// <summary>	
        /// How frequently the GPU counter increments in Hz.	
        /// </summary>	
        /// <unmanaged>UINT64 Frequency</unmanaged>
        public long Frequency;
        
        /// <summary>	
        /// If this is TRUE, something occurred in between the query's <see cref="SlimDX2.Direct3D10.Asynchronous.Begin"/> and <see cref="SlimDX2.Direct3D10.Asynchronous.End"/> calls that caused the timestamp counter to become discontinuous or disjoint, such as unplugging the AC chord on a laptop, overheating, or throttling up/down due to laptop savings events. The timestamp returned by <see cref="SlimDX2.Direct3D10.Asynchronous.GetData"/> for a timestamp query is only reliable if Disjoint is FALSE.	
        /// </summary>	
        /// <unmanaged>BOOL Disjoint</unmanaged>
        public bool Disjoint { 
            get { 
                return (_Disjoint!=0)?true:false; 
            }
            set { 
                _Disjoint = value?1:0;
            }
        }
        internal int _Disjoint;
    }
    
    /// <summary>	
    /// Query information about graphics-pipeline activity in between calls to <see cref="SlimDX2.Direct3D10.Asynchronous.Begin"/> and <see cref="SlimDX2.Direct3D10.Asynchronous.End"/>.	
    /// </summary>	
    /// <unmanaged>D3D10_QUERY_DATA_PIPELINE_STATISTICS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct QueryDataPipelineStatistics {	
        
        /// <summary>	
        /// Number of vertices read by input assembler.	
        /// </summary>	
        /// <unmanaged>UINT64 IAVertices</unmanaged>
        public long IAVerticeCount;
        
        /// <summary>	
        /// Number of primitives read by the input assembler. This number can be different depending on the primitive topology used. For example, a triangle strip with 6 vertices will produce 4 triangles, however a triangle list with 6 vertices will produce 2 triangles. 	
        /// </summary>	
        /// <unmanaged>UINT64 IAPrimitives</unmanaged>
        public long IAPrimitiveCount;
        
        /// <summary>	
        /// Number of times a vertex shader was invoked. Direct3D invokes the vertex shader once per vertex.	
        /// </summary>	
        /// <unmanaged>UINT64 VSInvocations</unmanaged>
        public long VSInvocationCount;
        
        /// <summary>	
        /// Number of times a geometry shader was invoked. When the geometry shader is set to NULL, this statistic may or may not increment depending on the hardware manufacturer.	
        /// </summary>	
        /// <unmanaged>UINT64 GSInvocations</unmanaged>
        public long GSInvocationCount;
        
        /// <summary>	
        /// Number of primitives output by a geometry shader.	
        /// </summary>	
        /// <unmanaged>UINT64 GSPrimitives</unmanaged>
        public long GSPrimitiveCount;
        
        /// <summary>	
        /// Number of primitives that were sent to the rasterizer. When the rasterizer is disabled, this will not increment.	
        /// </summary>	
        /// <unmanaged>UINT64 CInvocations</unmanaged>
        public long CInvocationCount;
        
        /// <summary>	
        /// Number of primitives that were rendered. This may be larger or smaller than CInvocations because after a primitive is clipped sometimes it is either broken up into more than one primitive or completely culled.	
        /// </summary>	
        /// <unmanaged>UINT64 CPrimitives</unmanaged>
        public long CPrimitiveCount;
        
        /// <summary>	
        /// Number of times a pixel shader was invoked.	
        /// </summary>	
        /// <unmanaged>UINT64 PSInvocations</unmanaged>
        public long PSInvocationCount;
    }
    
    /// <summary>	
    /// Query information about the amount of data streamed out to the stream-output buffers in between <see cref="SlimDX2.Direct3D10.Asynchronous.Begin"/> and <see cref="SlimDX2.Direct3D10.Asynchronous.End"/>.	
    /// </summary>	
    /// <unmanaged>D3D10_QUERY_DATA_SO_STATISTICS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct StreamOutputStatistics {	
        
        /// <summary>	
        /// Number of primitives (that is, points, lines, and triangles) written to the stream-output buffers.	
        /// </summary>	
        /// <unmanaged>UINT64 NumPrimitivesWritten</unmanaged>
        public long NumPrimitivesWritten;
        
        /// <summary>	
        /// Number of primitives that would have been written to the stream-output buffers if there had been enough space for them all.	
        /// </summary>	
        /// <unmanaged>UINT64 PrimitivesStorageNeeded</unmanaged>
        public long PrimitivesStorageNeeded;
    }
    
    /// <summary>	
    /// Describes a counter.	
    /// </summary>	
    /// <unmanaged>D3D10_COUNTER_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct CounterDescription {	
        
        /// <summary>	
        /// Type of counter (see <see cref="SlimDX2.Direct3D10.CounterKind"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_COUNTER Counter</unmanaged>
        public SlimDX2.Direct3D10.CounterKind Counter;
        
        /// <summary>	
        /// Reserved.	
        /// </summary>	
        /// <unmanaged>UINT MiscFlags</unmanaged>
        public int MiscFlags;
    }
    
    /// <summary>	
    /// Information about the video card's performance counter capabilities.	
    /// </summary>	
    /// <remarks>	
    /// This structure is returned by <see cref="SlimDX2.Direct3D10.Device.CheckCounterInfo"/>.	
    /// </remarks>	
    /// <unmanaged>D3D10_COUNTER_INFO</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct CounterInformation {	
        
        /// <summary>	
        /// Largest device-dependent counter ID that the device supports. If none are supported, this value will be 0. Otherwise it will be greater than or equal to D3D10_COUNTER_DEVICE_DEPENDENT_0. See <see cref="SlimDX2.Direct3D10.CounterKind"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_COUNTER LastDeviceDependentCounter</unmanaged>
        public SlimDX2.Direct3D10.CounterKind LastDeviceDependentCounter;
        
        /// <summary>	
        /// Number of counters that can be simultaneously supported.	
        /// </summary>	
        /// <unmanaged>UINT NumSimultaneousCounters</unmanaged>
        public int SimultaneousCounterCount;
        
        /// <summary>	
        /// Number of detectable parallel units that the counter is able to discern. Values are 1 ~ 4. Use NumDetectableParallelUnits to interpret the values of the VERTEX_PROCESSING, GEOMETRY_PROCESSING, PIXEL_PROCESSING, and OTHER_GPU_PROCESSING counters. See <see cref="SlimDX2.Direct3D10.Asynchronous.GetData"/> for an equation.	
        /// </summary>	
        /// <unmanaged>UINT8 NumDetectableParallelUnits</unmanaged>
        public byte DetectableParallelUnitCount;
    }
    
    /// <summary>	
    /// A debug message in the Information Queue.	
    /// </summary>	
    /// <remarks>	
    /// This structure is returned from <see cref="SlimDX2.Direct3D10.InfoQueue.GetMessage"/> as part of the Information Queue feature (see <see cref="SlimDX2.Direct3D10.InfoQueue"/>).	
    /// </remarks>	
    /// <unmanaged>D3D10_MESSAGE</unmanaged>
    public  partial struct Message {	
        
        /// <summary>	
        /// The category of the message. See <see cref="SlimDX2.Direct3D10.MessageCategory"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_MESSAGE_CATEGORY Category</unmanaged>
        public SlimDX2.Direct3D10.MessageCategory Category;
        
        /// <summary>	
        /// The severity of the message. See <see cref="SlimDX2.Direct3D10.MessageSeverity"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_MESSAGE_SEVERITY Severity</unmanaged>
        public SlimDX2.Direct3D10.MessageSeverity Severity;
        
        /// <summary>	
        /// The ID of the message. See <see cref="SlimDX2.Direct3D10.MessageId"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_MESSAGE_ID ID</unmanaged>
        public SlimDX2.Direct3D10.MessageId Id;
        
        /// <summary>	
        /// The message string.	
        /// </summary>	
        /// <unmanaged>const char* pDescription</unmanaged>
        public string PDescription;
        
        /// <summary>	
        /// The length of pDescription in bytes.	
        /// </summary>	
        /// <unmanaged>SIZE_T DescriptionByteLength</unmanaged>
        public SlimDX2.Size DescriptionByteLength;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public SlimDX2.Direct3D10.MessageCategory Category;
            public SlimDX2.Direct3D10.MessageSeverity Severity;
            public SlimDX2.Direct3D10.MessageId Id;
            public IntPtr PDescription;
            public SlimDX2.Size DescriptionByteLength;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.PDescription != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.PDescription);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Category = @ref.Category;
            this.Severity = @ref.Severity;
            this.Id = @ref.Id;
            this.PDescription = ( @ref.PDescription == IntPtr.Zero )?null:new string((sbyte*)@ref.PDescription);
            this.DescriptionByteLength = @ref.DescriptionByteLength;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Category = this.Category;
            @ref.Severity = this.Severity;
            @ref.Id = this.Id;
            @ref.PDescription = ( this.PDescription == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.PDescription);
            @ref.DescriptionByteLength = this.DescriptionByteLength;
		
		}
    }
    
    /// <summary>	
    /// Allow or deny certain types of messages to pass through a filter.	
    /// </summary>	
    /// <remarks>	
    /// D3D10_INFO_QUEUE_FILTER_DESC is used to define the allow list and deny list in the <see cref="SlimDX2.Direct3D10.InformationQueueFilter"/> structure.	
    /// </remarks>	
    /// <unmanaged>D3D10_INFO_QUEUE_FILTER_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct InformationQueueFilterDescription {	
        
        /// <summary>	
        /// Number of message categories to allow or deny.	
        /// </summary>	
        /// <unmanaged>UINT NumCategories</unmanaged>
        public int CategorieCount;
        
        /// <summary>	
        /// Array of message categories to allow or deny. Array must have at least NumCategories members (see <see cref="SlimDX2.Direct3D10.MessageCategory"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_MESSAGE_CATEGORY* pCategoryList</unmanaged>
        public IntPtr PCategoryList;
        
        /// <summary>	
        /// Number of message severity levels to allow or deny.	
        /// </summary>	
        /// <unmanaged>UINT NumSeverities</unmanaged>
        public int SeveritieCount;
        
        /// <summary>	
        /// Array of message severity levels to allow or deny. Array must have at least NumSeverities members (see <see cref="SlimDX2.Direct3D10.MessageSeverity"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_MESSAGE_SEVERITY* pSeverityList</unmanaged>
        public IntPtr PSeverityList;
        
        /// <summary>	
        /// Number of message IDs to allow or deny.	
        /// </summary>	
        /// <unmanaged>UINT NumIDs</unmanaged>
        public int IDCount;
        
        /// <summary>	
        /// Array of message IDs to allow or deny. Array must have at least NumIDs members (see <see cref="SlimDX2.Direct3D10.MessageId"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_MESSAGE_ID* pIDList</unmanaged>
        public IntPtr PIDList;
    }
    
    /// <summary>	
    /// Debug message filter; contains a lists of message types to allow or deny.	
    /// </summary>	
    /// <remarks>	
    /// For use with an <see cref="SlimDX2.Direct3D10.InfoQueue"/>.Providing an allow list with non-zero values causes only the specified combination of categories, severities and message IDs to be allowed.   Messages that do not match the specified combination will be rejected.Providing a deny list with non-zero values causes the specified combination of categories, severities and message IDs to be rejected. Messages that do not match the specified combination will be allowed.	
    /// </remarks>	
    /// <unmanaged>D3D10_INFO_QUEUE_FILTER</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct InformationQueueFilter {	
        
        /// <summary>	
        /// A <see cref="SlimDX2.Direct3D10.InformationQueueFilterDescription"/> structure describing the types of messages the info queue should allow.	
        /// </summary>	
        /// <unmanaged>D3D10_INFO_QUEUE_FILTER_DESC AllowList</unmanaged>
        public SlimDX2.Direct3D10.InformationQueueFilterDescription AllowList;
        
        /// <summary>	
        /// A <see cref="SlimDX2.Direct3D10.InformationQueueFilterDescription"/> structure describing the types of messages the info queue should reject.	
        /// </summary>	
        /// <unmanaged>D3D10_INFO_QUEUE_FILTER_DESC DenyList</unmanaged>
        public SlimDX2.Direct3D10.InformationQueueFilterDescription DenyList;
    }
    
    /// <summary>	
    /// Describes a shader.	
    /// </summary>	
    /// <remarks>	
    /// A shader is written in HLSL and compiled into an intermediate language by the HLSL compiler. The shader description returns information about the compiled shader. Get a shader description by calling <see cref="SlimDX2.Direct3D10.ShaderReflection.GetDescription"/>.	
    /// </remarks>	
    /// <unmanaged>D3D10_SHADER_DESC</unmanaged>
    public  partial struct ShaderDescription {	
        
        /// <summary>	
        /// Shader version.	
        /// </summary>	
        /// <unmanaged>UINT Version</unmanaged>
        public int Version;
        
        /// <summary>	
        /// The name of the originator of the shader.	
        /// </summary>	
        /// <unmanaged>const char* Creator</unmanaged>
        public string Creator;
        
        /// <summary>	
        /// Shader compilation/parse flags.	
        /// </summary>	
        /// <unmanaged>UINT Flags</unmanaged>
        public SlimDX2.D3DCompiler.ShaderFlags Flags;
        
        /// <summary>	
        /// The number of shader-constant buffers.	
        /// </summary>	
        /// <unmanaged>UINT ConstantBuffers</unmanaged>
        public int ConstantBufferCount;
        
        /// <summary>	
        /// The number of resource (textures and buffers) bound to a shader.	
        /// </summary>	
        /// <unmanaged>UINT BoundResources</unmanaged>
        public int BoundResourceCount;
        
        /// <summary>	
        /// The number of parameters in the input signature.	
        /// </summary>	
        /// <unmanaged>UINT InputParameters</unmanaged>
        public int InputParameterCount;
        
        /// <summary>	
        /// The number of parameters in the output signature.	
        /// </summary>	
        /// <unmanaged>UINT OutputParameters</unmanaged>
        public int OutputParameterCount;
        
        /// <summary>	
        /// The number of intermediate-language instructions in the compiled shader.	
        /// </summary>	
        /// <unmanaged>UINT InstructionCount</unmanaged>
        public int InstructionCount;
        
        /// <summary>	
        /// The number of temporary registers in the compiled shader.	
        /// </summary>	
        /// <unmanaged>UINT TempRegisterCount</unmanaged>
        public int TempRegisterCount;
        
        /// <summary>	
        /// Number of temporary arrays used.	
        /// </summary>	
        /// <unmanaged>UINT TempArrayCount</unmanaged>
        public int TempArrayCount;
        
        /// <summary>	
        /// Number of constant defines.	
        /// </summary>	
        /// <unmanaged>UINT DefCount</unmanaged>
        public int DefCount;
        
        /// <summary>	
        /// Number of declarations (input + output).	
        /// </summary>	
        /// <unmanaged>UINT DclCount</unmanaged>
        public int DclCount;
        
        /// <summary>	
        /// Number of non-categorized texture instructions.	
        /// </summary>	
        /// <unmanaged>UINT TextureNormalInstructions</unmanaged>
        public int TextureNormalInstructionCount;
        
        /// <summary>	
        /// Number of texture load instructions	
        /// </summary>	
        /// <unmanaged>UINT TextureLoadInstructions</unmanaged>
        public int TextureLoadInstructionCount;
        
        /// <summary>	
        /// Number of texture comparison instructions	
        /// </summary>	
        /// <unmanaged>UINT TextureCompInstructions</unmanaged>
        public int TextureCompInstructionCount;
        
        /// <summary>	
        /// Number of texture bias instructions	
        /// </summary>	
        /// <unmanaged>UINT TextureBiasInstructions</unmanaged>
        public int TextureBiasInstructionCount;
        
        /// <summary>	
        /// Number of texture gradient instructions.	
        /// </summary>	
        /// <unmanaged>UINT TextureGradientInstructions</unmanaged>
        public int TextureGradientInstructionCount;
        
        /// <summary>	
        /// Number of floating point arithmetic instructions used.	
        /// </summary>	
        /// <unmanaged>UINT FloatInstructionCount</unmanaged>
        public int FloatInstructionCount;
        
        /// <summary>	
        /// Number of signed integer arithmetic instructions used.	
        /// </summary>	
        /// <unmanaged>UINT IntInstructionCount</unmanaged>
        public int IntInstructionCount;
        
        /// <summary>	
        /// Number of unsigned integer arithmetic instructions used.	
        /// </summary>	
        /// <unmanaged>UINT UintInstructionCount</unmanaged>
        public int UintInstructionCount;
        
        /// <summary>	
        /// Number of static flow control instructions used.	
        /// </summary>	
        /// <unmanaged>UINT StaticFlowControlCount</unmanaged>
        public int StaticFlowControlCount;
        
        /// <summary>	
        /// Number of dynamic flow control instructions used.	
        /// </summary>	
        /// <unmanaged>UINT DynamicFlowControlCount</unmanaged>
        public int DynamicFlowControlCount;
        
        /// <summary>	
        /// Number of macro instructions used.	
        /// </summary>	
        /// <unmanaged>UINT MacroInstructionCount</unmanaged>
        public int MacroInstructionCount;
        
        /// <summary>	
        /// Number of array instructions used.	
        /// </summary>	
        /// <unmanaged>UINT ArrayInstructionCount</unmanaged>
        public int ArrayInstructionCount;
        
        /// <summary>	
        /// Number of cut instructions used.	
        /// </summary>	
        /// <unmanaged>UINT CutInstructionCount</unmanaged>
        public int CutInstructionCount;
        
        /// <summary>	
        /// Number of emit instructions used.	
        /// </summary>	
        /// <unmanaged>UINT EmitInstructionCount</unmanaged>
        public int EmitInstructionCount;
        
        /// <summary>	
        /// Geometry shader output topology.	
        /// </summary>	
        /// <unmanaged>D3D10_PRIMITIVE_TOPOLOGY GSOutputTopology</unmanaged>
        public SlimDX2.Direct3D.PrimitiveTopology GSOutputTopology;
        
        /// <summary>	
        /// Geometry shader maximum output vertex count.	
        /// </summary>	
        /// <unmanaged>UINT GSMaxOutputVertexCount</unmanaged>
        public int GSMaxOutputVertexCount;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public int Version;
            public IntPtr Creator;
            public SlimDX2.D3DCompiler.ShaderFlags Flags;
            public int ConstantBufferCount;
            public int BoundResourceCount;
            public int InputParameterCount;
            public int OutputParameterCount;
            public int InstructionCount;
            public int TempRegisterCount;
            public int TempArrayCount;
            public int DefCount;
            public int DclCount;
            public int TextureNormalInstructionCount;
            public int TextureLoadInstructionCount;
            public int TextureCompInstructionCount;
            public int TextureBiasInstructionCount;
            public int TextureGradientInstructionCount;
            public int FloatInstructionCount;
            public int IntInstructionCount;
            public int UintInstructionCount;
            public int StaticFlowControlCount;
            public int DynamicFlowControlCount;
            public int MacroInstructionCount;
            public int ArrayInstructionCount;
            public int CutInstructionCount;
            public int EmitInstructionCount;
            public SlimDX2.Direct3D.PrimitiveTopology GSOutputTopology;
            public int GSMaxOutputVertexCount;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Creator != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Creator);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Version = @ref.Version;
            this.Creator = ( @ref.Creator == IntPtr.Zero )?null:new string((sbyte*)@ref.Creator);
            this.Flags = @ref.Flags;
            this.ConstantBufferCount = @ref.ConstantBufferCount;
            this.BoundResourceCount = @ref.BoundResourceCount;
            this.InputParameterCount = @ref.InputParameterCount;
            this.OutputParameterCount = @ref.OutputParameterCount;
            this.InstructionCount = @ref.InstructionCount;
            this.TempRegisterCount = @ref.TempRegisterCount;
            this.TempArrayCount = @ref.TempArrayCount;
            this.DefCount = @ref.DefCount;
            this.DclCount = @ref.DclCount;
            this.TextureNormalInstructionCount = @ref.TextureNormalInstructionCount;
            this.TextureLoadInstructionCount = @ref.TextureLoadInstructionCount;
            this.TextureCompInstructionCount = @ref.TextureCompInstructionCount;
            this.TextureBiasInstructionCount = @ref.TextureBiasInstructionCount;
            this.TextureGradientInstructionCount = @ref.TextureGradientInstructionCount;
            this.FloatInstructionCount = @ref.FloatInstructionCount;
            this.IntInstructionCount = @ref.IntInstructionCount;
            this.UintInstructionCount = @ref.UintInstructionCount;
            this.StaticFlowControlCount = @ref.StaticFlowControlCount;
            this.DynamicFlowControlCount = @ref.DynamicFlowControlCount;
            this.MacroInstructionCount = @ref.MacroInstructionCount;
            this.ArrayInstructionCount = @ref.ArrayInstructionCount;
            this.CutInstructionCount = @ref.CutInstructionCount;
            this.EmitInstructionCount = @ref.EmitInstructionCount;
            this.GSOutputTopology = @ref.GSOutputTopology;
            this.GSMaxOutputVertexCount = @ref.GSMaxOutputVertexCount;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Version = this.Version;
            @ref.Creator = ( this.Creator == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Creator);
            @ref.Flags = this.Flags;
            @ref.ConstantBufferCount = this.ConstantBufferCount;
            @ref.BoundResourceCount = this.BoundResourceCount;
            @ref.InputParameterCount = this.InputParameterCount;
            @ref.OutputParameterCount = this.OutputParameterCount;
            @ref.InstructionCount = this.InstructionCount;
            @ref.TempRegisterCount = this.TempRegisterCount;
            @ref.TempArrayCount = this.TempArrayCount;
            @ref.DefCount = this.DefCount;
            @ref.DclCount = this.DclCount;
            @ref.TextureNormalInstructionCount = this.TextureNormalInstructionCount;
            @ref.TextureLoadInstructionCount = this.TextureLoadInstructionCount;
            @ref.TextureCompInstructionCount = this.TextureCompInstructionCount;
            @ref.TextureBiasInstructionCount = this.TextureBiasInstructionCount;
            @ref.TextureGradientInstructionCount = this.TextureGradientInstructionCount;
            @ref.FloatInstructionCount = this.FloatInstructionCount;
            @ref.IntInstructionCount = this.IntInstructionCount;
            @ref.UintInstructionCount = this.UintInstructionCount;
            @ref.StaticFlowControlCount = this.StaticFlowControlCount;
            @ref.DynamicFlowControlCount = this.DynamicFlowControlCount;
            @ref.MacroInstructionCount = this.MacroInstructionCount;
            @ref.ArrayInstructionCount = this.ArrayInstructionCount;
            @ref.CutInstructionCount = this.CutInstructionCount;
            @ref.EmitInstructionCount = this.EmitInstructionCount;
            @ref.GSOutputTopology = this.GSOutputTopology;
            @ref.GSMaxOutputVertexCount = this.GSMaxOutputVertexCount;
		
		}
    }
    
    /// <summary>	
    /// Describes a shader constant-buffer.	
    /// </summary>	
    /// <remarks>	
    /// Constants are supplied to shaders in a shader-constant buffer. Get the description of a shader-constant-buffer by calling <see cref="SlimDX2.Direct3D10.ShaderReflectionConstantBuffer.GetDescription"/>.	
    /// </remarks>	
    /// <unmanaged>D3D10_SHADER_BUFFER_DESC</unmanaged>
    public  partial struct ShaderBufferDescription {	
        
        /// <summary>	
        /// The name of the buffer.	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        /// The intended use of the constant data. See <see cref="SlimDX2.D3DCompiler.ConstantBufferType"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_CBUFFER_TYPE Type</unmanaged>
        public SlimDX2.D3DCompiler.ConstantBufferType Type;
        
        /// <summary>	
        /// The number of unique variables.	
        /// </summary>	
        /// <unmanaged>UINT Variables</unmanaged>
        public int VariableCount;
        
        /// <summary>	
        /// Buffer size (in bytes).	
        /// </summary>	
        /// <unmanaged>UINT Size</unmanaged>
        public int Size;
        
        /// <summary>	
        /// Shader buffer properties. See <see cref="SlimDX2.D3DCompiler.ShaderConstantBufferFlags"/>.	
        /// </summary>	
        /// <unmanaged>UINT uFlags</unmanaged>
        public SlimDX2.D3DCompiler.ShaderConstantBufferFlags Flags;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public SlimDX2.D3DCompiler.ConstantBufferType Type;
            public int VariableCount;
            public int Size;
            public SlimDX2.D3DCompiler.ShaderConstantBufferFlags Flags;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.Type = @ref.Type;
            this.VariableCount = @ref.VariableCount;
            this.Size = @ref.Size;
            this.Flags = @ref.Flags;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.Type = this.Type;
            @ref.VariableCount = this.VariableCount;
            @ref.Size = this.Size;
            @ref.Flags = this.Flags;
		
		}
    }
    
    /// <summary>	
    /// Describes a shader variable.	
    /// </summary>	
    /// <remarks>	
    /// Get a shader-variable description using reflection, by calling <see cref="SlimDX2.Direct3D10.ShaderReflectionVariable.GetDescription"/>.	
    /// </remarks>	
    /// <unmanaged>D3D10_SHADER_VARIABLE_DESC</unmanaged>
    public  partial struct ShaderVariableDescription {	
        
        /// <summary>	
        /// The variable name.	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        /// Offset from the start of the parent structure, to the beginning of the variable.	
        /// </summary>	
        /// <unmanaged>UINT StartOffset</unmanaged>
        public int StartOffset;
        
        /// <summary>	
        /// Size of the variable (in bytes).	
        /// </summary>	
        /// <unmanaged>UINT Size</unmanaged>
        public int Size;
        
        /// <summary>	
        /// Flags, which identify shader-variable properties (see <see cref="SlimDX2.D3DCompiler.ShaderVariableFlags"/>).	
        /// </summary>	
        /// <unmanaged>UINT uFlags</unmanaged>
        public SlimDX2.D3DCompiler.ShaderVariableFlags Flags;
        
        /// <summary>	
        /// The default value for initializing the variable.	
        /// </summary>	
        /// <unmanaged>void* DefaultValue</unmanaged>
        public IntPtr DefaultValue;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public int StartOffset;
            public int Size;
            public SlimDX2.D3DCompiler.ShaderVariableFlags Flags;
            public IntPtr DefaultValue;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.StartOffset = @ref.StartOffset;
            this.Size = @ref.Size;
            this.Flags = @ref.Flags;
            this.DefaultValue = @ref.DefaultValue;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.StartOffset = this.StartOffset;
            @ref.Size = this.Size;
            @ref.Flags = this.Flags;
            @ref.DefaultValue = this.DefaultValue;
		
		}
    }
    
    /// <summary>	
    /// Describes a shader-variable type.	
    /// </summary>	
    /// <remarks>	
    /// Get a shader-variable-type description by calling <see cref="SlimDX2.Direct3D10.ShaderReflectionType.GetDescription"/>.	
    /// </remarks>	
    /// <unmanaged>D3D10_SHADER_TYPE_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ShaderTypeDescription {	
        
        /// <summary>	
        /// Identifies the variable class as one of scalar, vector, matrix or object. See <see cref="SlimDX2.D3DCompiler.ShaderVariableClass"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_SHADER_VARIABLE_CLASS Class</unmanaged>
        public SlimDX2.D3DCompiler.ShaderVariableClass ClasCount;
        
        /// <summary>	
        /// The variable type. See <see cref="SlimDX2.D3DCompiler.ShaderVariableType"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_SHADER_VARIABLE_TYPE Type</unmanaged>
        public SlimDX2.D3DCompiler.ShaderVariableType Type;
        
        /// <summary>	
        /// Number of rows in a matrix. Otherwise a numeric type returns 1, any other type returns 0.	
        /// </summary>	
        /// <unmanaged>UINT Rows</unmanaged>
        public int RowCount;
        
        /// <summary>	
        /// Number of columns in a matrix. Otherwise a numeric type returns 1, any other type returns 0.	
        /// </summary>	
        /// <unmanaged>UINT Columns</unmanaged>
        public int ColumnCount;
        
        /// <summary>	
        /// Number of elements in an array; otherwise 0.	
        /// </summary>	
        /// <unmanaged>UINT Elements</unmanaged>
        public int ElementCount;
        
        /// <summary>	
        /// Number of members in the structure; otherwise 0.	
        /// </summary>	
        /// <unmanaged>UINT Members</unmanaged>
        public int MemberCount;
        
        /// <summary>	
        /// Offset, in bytes, between the start of the parent structure and this variable.	
        /// </summary>	
        /// <unmanaged>UINT Offset</unmanaged>
        public int Offset;
    }
    
    /// <summary>	
    /// Describes how a shader resource is bound to a shader input.	
    /// </summary>	
    /// <remarks>	
    /// Get a shader-input-signature description by calling <see cref="SlimDX2.Direct3D10.ShaderReflection.GetResourceBindingDescription"/>.	
    /// </remarks>	
    /// <unmanaged>D3D10_SHADER_INPUT_BIND_DESC</unmanaged>
    public  partial struct ShaderInputBindDescription {	
        
        /// <summary>	
        /// Name of the shader resource.	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        /// Identifies the type of data in the resource. See <see cref="SlimDX2.D3DCompiler.ShaderInputType"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_SHADER_INPUT_TYPE Type</unmanaged>
        public SlimDX2.D3DCompiler.ShaderInputType Type;
        
        /// <summary>	
        /// Starting bind point.	
        /// </summary>	
        /// <unmanaged>UINT BindPoint</unmanaged>
        public int BindPoint;
        
        /// <summary>	
        /// Number of contiguous bind points for arrays.	
        /// </summary>	
        /// <unmanaged>UINT BindCount</unmanaged>
        public int BindCount;
        
        /// <summary>	
        /// Shader input-parameter options. See <see cref="SlimDX2.D3DCompiler.ShaderInputFlags"/>.	
        /// </summary>	
        /// <unmanaged>UINT uFlags</unmanaged>
        public SlimDX2.D3DCompiler.ShaderInputFlags Flags;
        
        /// <summary>	
        /// If the input is a texture, the return type. See <see cref="SlimDX2.D3DCompiler.ResourceReturnType"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_RESOURCE_RETURN_TYPE ReturnType</unmanaged>
        public SlimDX2.D3DCompiler.ResourceReturnType ReturnType;
        
        /// <summary>	
        /// Identifies the amount of data in the resource. See <see cref="SlimDX2.Direct3D.ShaderResourceViewDimension"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_SRV_DIMENSION Dimension</unmanaged>
        public SlimDX2.Direct3D.ShaderResourceViewDimension Dimension;
        
        /// <summary>	
        /// The number of samples for a multisampled texture; otherwise 0.	
        /// </summary>	
        /// <unmanaged>UINT NumSamples</unmanaged>
        public int SampleCount;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public SlimDX2.D3DCompiler.ShaderInputType Type;
            public int BindPoint;
            public int BindCount;
            public SlimDX2.D3DCompiler.ShaderInputFlags Flags;
            public SlimDX2.D3DCompiler.ResourceReturnType ReturnType;
            public SlimDX2.Direct3D.ShaderResourceViewDimension Dimension;
            public int SampleCount;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.Type = @ref.Type;
            this.BindPoint = @ref.BindPoint;
            this.BindCount = @ref.BindCount;
            this.Flags = @ref.Flags;
            this.ReturnType = @ref.ReturnType;
            this.Dimension = @ref.Dimension;
            this.SampleCount = @ref.SampleCount;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.Type = this.Type;
            @ref.BindPoint = this.BindPoint;
            @ref.BindCount = this.BindCount;
            @ref.Flags = this.Flags;
            @ref.ReturnType = this.ReturnType;
            @ref.Dimension = this.Dimension;
            @ref.SampleCount = this.SampleCount;
		
		}
    }
    
    /// <summary>	
    /// Describes a shader signature.	
    /// </summary>	
    /// <remarks>	
    /// A shader can take n inputs and can produce m outputs. The order of the input (or output) parameters, their associated types, and any attached semantics make up the shader signature. Each shader has an input and an output signature.When compiling a shader or an effect, some API calls validate shader signatures (such as {{D3D10CompileShader}} and {{D3D10CompileEffectFromMemory}}). That is, they compare the output signature of one shader (like a vertex shader) with the input signature of another shader (like a pixel shader). This ensures that a shader outputs data that is compatible with a downstream shader that is consuming that data. Compatible means that a shader signature is a exact-match subset of the preceding shader stage. Exact match means parameter types and semantics must exactly match. Subset means that a parameter that is not required by a downstream stage, does not need to include that parameter in its shader signature.Get a shader-signature from a shader or an effect by calling APIs such as <see cref="SlimDX2.Direct3D10.ShaderReflection.GetInputParameterDescription"/> or <see cref="SlimDX2.Direct3D10.EffectShaderVariable.GetInputSignatureElementDescription"/>.	
    /// </remarks>	
    /// <unmanaged>D3D10_SIGNATURE_PARAMETER_DESC</unmanaged>
    public  partial struct SignatureParameterDescription {	
        
        /// <summary>	
        /// A per-parameter string that identifies how the data will be used. See {{Semantics (DirectX HLSL)}}.	
        /// </summary>	
        /// <unmanaged>const char* SemanticName</unmanaged>
        public string SemanticName;
        
        /// <summary>	
        /// Semantic index that modifies the semantic. Used to differentiate different parameters that use the same semantic.	
        /// </summary>	
        /// <unmanaged>UINT SemanticIndex</unmanaged>
        public int SemanticIndex;
        
        /// <summary>	
        /// The register that will contain this variable's data.	
        /// </summary>	
        /// <unmanaged>UINT Register</unmanaged>
        public int Register;
        
        /// <summary>	
        /// A predefined string that determines the functionality of certain pipeline stages. See <see cref="SlimDX2.D3DCompiler.ParameterName"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_NAME SystemValueType</unmanaged>
        public SlimDX2.D3DCompiler.ParameterName SystemValueType;
        
        /// <summary>	
        /// The per-component-data type that is stored in a register. See <see cref="SlimDX2.D3DCompiler.RegisterComponentType"/>. Each register can store up to four-components of data.	
        /// </summary>	
        /// <unmanaged>D3D10_REGISTER_COMPONENT_TYPE ComponentType</unmanaged>
        public SlimDX2.D3DCompiler.RegisterComponentType ComponentType;
        
        /// <summary>	
        /// Mask which indicates which components of a register are used.	
        /// </summary>	
        /// <unmanaged>BYTE Mask</unmanaged>
        public byte Mask;
        
        /// <summary>	
        /// Mask which indicates whether a given component is never written (if the signature is an output signature) or always read (if the signature is an input signature). The mask is a combination of <see cref="SlimDX2.D3DCompiler.RegisterComponentType"/> values.	
        /// </summary>	
        /// <unmanaged>BYTE ReadWriteMask</unmanaged>
        public byte ReadWriteMask;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr SemanticName;
            public int SemanticIndex;
            public int Register;
            public SlimDX2.D3DCompiler.ParameterName SystemValueType;
            public SlimDX2.D3DCompiler.RegisterComponentType ComponentType;
            public byte Mask;
            public byte ReadWriteMask;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.SemanticName != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.SemanticName);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.SemanticName = ( @ref.SemanticName == IntPtr.Zero )?null:new string((sbyte*)@ref.SemanticName);
            this.SemanticIndex = @ref.SemanticIndex;
            this.Register = @ref.Register;
            this.SystemValueType = @ref.SystemValueType;
            this.ComponentType = @ref.ComponentType;
            this.Mask = @ref.Mask;
            this.ReadWriteMask = @ref.ReadWriteMask;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.SemanticName = ( this.SemanticName == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.SemanticName);
            @ref.SemanticIndex = this.SemanticIndex;
            @ref.Register = this.Register;
            @ref.SystemValueType = this.SystemValueType;
            @ref.ComponentType = this.ComponentType;
            @ref.Mask = this.Mask;
            @ref.ReadWriteMask = this.ReadWriteMask;
		
		}
    }
    
    /// <summary>	
    /// Indicates the device state.	
    /// </summary>	
    /// <remarks>	
    /// A state-block mask indicates the device states that a pass or a technique changes.  The {{D3D10StateBlockMaskEnableCapture}} function  provides a convenient way of setting a range of bitmasks for the array members of D3D10_STATE_BLOCK_MASK.	
    /// </remarks>	
    /// <unmanaged>D3D10_STATE_BLOCK_MASK</unmanaged>
    public  partial struct StateBlockMask {	
        
        /// <summary>	
        /// Boolean value indicating whether to save the vertex shader state.	
        /// </summary>	
        /// <unmanaged>BYTE VS</unmanaged>
        public byte Vs;
        
        /// <summary>	
        /// Array of vertex-shader samplers.  The array is a multi-byte bitmask where each bit represents one sampler slot.	
        /// </summary>	
        /// <unmanaged>BYTE VSSamplers[2.875]</unmanaged>
        public byte[] VSSamplers { 
            get { 
                if (_VSSamplers == null) {
                    _VSSamplers = new byte[2];
                }
                return _VSSamplers; 
            }
        }
        internal byte[] _VSSamplers;
        
        /// <summary>	
        /// Array of vertex-shader resources. The array is a multi-byte bitmask where each bit represents one resource slot.	
        /// </summary>	
        /// <unmanaged>BYTE VSShaderResources[16.875]</unmanaged>
        public byte[] VSShaderResources { 
            get { 
                if (_VSShaderResources == null) {
                    _VSShaderResources = new byte[16];
                }
                return _VSShaderResources; 
            }
        }
        internal byte[] _VSShaderResources;
        
        /// <summary>	
        /// Array of vertex-shader constant buffers. The array is a multi-byte bitmask where each bit represents one constant buffer slot.	
        /// </summary>	
        /// <unmanaged>BYTE VSConstantBuffers[2.625]</unmanaged>
        public byte[] VSConstantBuffers { 
            get { 
                if (_VSConstantBuffers == null) {
                    _VSConstantBuffers = new byte[2];
                }
                return _VSConstantBuffers; 
            }
        }
        internal byte[] _VSConstantBuffers;
        
        /// <summary>	
        /// Boolean value indicating whether to save the geometry shader state.	
        /// </summary>	
        /// <unmanaged>BYTE GS</unmanaged>
        public byte Gs;
        
        /// <summary>	
        /// Array of geometry-shader samplers. The array is a multi-byte bitmask where each bit represents one sampler slot.	
        /// </summary>	
        /// <unmanaged>BYTE GSSamplers[2.875]</unmanaged>
        public byte[] GSSamplers { 
            get { 
                if (_GSSamplers == null) {
                    _GSSamplers = new byte[2];
                }
                return _GSSamplers; 
            }
        }
        internal byte[] _GSSamplers;
        
        /// <summary>	
        /// Array of geometry-shader resources. The array is a multi-byte bitmask where each bit represents one resource slot.	
        /// </summary>	
        /// <unmanaged>BYTE GSShaderResources[16.875]</unmanaged>
        public byte[] GSShaderResources { 
            get { 
                if (_GSShaderResources == null) {
                    _GSShaderResources = new byte[16];
                }
                return _GSShaderResources; 
            }
        }
        internal byte[] _GSShaderResources;
        
        /// <summary>	
        /// Array of geometry-shader constant buffers. The array is a multi-byte bitmask where each bit represents one buffer slot.	
        /// </summary>	
        /// <unmanaged>BYTE GSConstantBuffers[2.625]</unmanaged>
        public byte[] GSConstantBuffers { 
            get { 
                if (_GSConstantBuffers == null) {
                    _GSConstantBuffers = new byte[2];
                }
                return _GSConstantBuffers; 
            }
        }
        internal byte[] _GSConstantBuffers;
        
        /// <summary>	
        /// Boolean value indicating whether to save the pixel shader state.	
        /// </summary>	
        /// <unmanaged>BYTE PS</unmanaged>
        public byte Ps;
        
        /// <summary>	
        /// Array of pixel-shader samplers. The array is a multi-byte bitmask where each bit represents one sampler slot.	
        /// </summary>	
        /// <unmanaged>BYTE PSSamplers[2.875]</unmanaged>
        public byte[] PSSamplers { 
            get { 
                if (_PSSamplers == null) {
                    _PSSamplers = new byte[2];
                }
                return _PSSamplers; 
            }
        }
        internal byte[] _PSSamplers;
        
        /// <summary>	
        /// Array of pixel-shader resources. The array is a multi-byte bitmask where each bit represents one resource slot.	
        /// </summary>	
        /// <unmanaged>BYTE PSShaderResources[16.875]</unmanaged>
        public byte[] PSShaderResources { 
            get { 
                if (_PSShaderResources == null) {
                    _PSShaderResources = new byte[16];
                }
                return _PSShaderResources; 
            }
        }
        internal byte[] _PSShaderResources;
        
        /// <summary>	
        /// Array of pixel-shader constant buffers. The array is a multi-byte bitmask where each bit represents one constant buffer slot.	
        /// </summary>	
        /// <unmanaged>BYTE PSConstantBuffers[2.625]</unmanaged>
        public byte[] PSConstantBuffers { 
            get { 
                if (_PSConstantBuffers == null) {
                    _PSConstantBuffers = new byte[2];
                }
                return _PSConstantBuffers; 
            }
        }
        internal byte[] _PSConstantBuffers;
        
        /// <summary>	
        /// Array of vertex buffers. The array is a multi-byte bitmask where each bit represents one resource slot.	
        /// </summary>	
        /// <unmanaged>BYTE IAVertexBuffers[2.875]</unmanaged>
        public byte[] IAVertexBuffers { 
            get { 
                if (_IAVertexBuffers == null) {
                    _IAVertexBuffers = new byte[2];
                }
                return _IAVertexBuffers; 
            }
        }
        internal byte[] _IAVertexBuffers;
        
        /// <summary>	
        /// Boolean value indicating whether to save the index buffer state.	
        /// </summary>	
        /// <unmanaged>BYTE IAIndexBuffer</unmanaged>
        public byte IAIndexBuffer;
        
        /// <summary>	
        /// Boolean value indicating whether to save the input layout state.	
        /// </summary>	
        /// <unmanaged>BYTE IAInputLayout</unmanaged>
        public byte IAInputLayout;
        
        /// <summary>	
        /// Boolean value indicating whether to save the primitive topology state.	
        /// </summary>	
        /// <unmanaged>BYTE IAPrimitiveTopology</unmanaged>
        public byte IAPrimitiveTopology;
        
        /// <summary>	
        /// Boolean value indicating whether to save the render targets states.	
        /// </summary>	
        /// <unmanaged>BYTE OMRenderTargets</unmanaged>
        public byte OMRenderTargets;
        
        /// <summary>	
        /// Boolean value indicating whether to save the depth-stencil state.	
        /// </summary>	
        /// <unmanaged>BYTE OMDepthStencilState</unmanaged>
        public byte OMDepthStencilState;
        
        /// <summary>	
        /// Boolean value indicating whether to save the blend state.	
        /// </summary>	
        /// <unmanaged>BYTE OMBlendState</unmanaged>
        public byte OMBlendState;
        
        /// <summary>	
        /// Boolean value indicating whether to save the viewports states.	
        /// </summary>	
        /// <unmanaged>BYTE RSViewports</unmanaged>
        public byte RSViewports;
        
        /// <summary>	
        /// Boolean value indicating whether to save the scissor rectangles states.	
        /// </summary>	
        /// <unmanaged>BYTE RSScissorRects</unmanaged>
        public byte RSScissorRects;
        
        /// <summary>	
        /// Boolean value indicating whether to save the rasterizer state.	
        /// </summary>	
        /// <unmanaged>BYTE RSRasterizerState</unmanaged>
        public byte RSRasterizerState;
        
        /// <summary>	
        /// Boolean value indicating whether to save the stream-out buffers states.	
        /// </summary>	
        /// <unmanaged>BYTE SOBuffers</unmanaged>
        public byte SOBuffers;
        
        /// <summary>	
        /// Boolean value indicating whether to save the predication state.	
        /// </summary>	
        /// <unmanaged>BYTE Predication</unmanaged>
        public byte Predication;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public byte Vs;
            public fixed byte VSSamplers[2];
            public fixed byte VSShaderResources[16];
            public fixed byte VSConstantBuffers[2];
            public byte Gs;
            public fixed byte GSSamplers[2];
            public fixed byte GSShaderResources[16];
            public fixed byte GSConstantBuffers[2];
            public byte Ps;
            public fixed byte PSSamplers[2];
            public fixed byte PSShaderResources[16];
            public fixed byte PSConstantBuffers[2];
            public fixed byte IAVertexBuffers[2];
            public byte IAIndexBuffer;
            public byte IAInputLayout;
            public byte IAPrimitiveTopology;
            public byte OMRenderTargets;
            public byte OMDepthStencilState;
            public byte OMBlendState;
            public byte RSViewports;
            public byte RSScissorRects;
            public byte RSRasterizerState;
            public byte SOBuffers;
            public byte Predication;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Vs = @ref.Vs;
            fixed (void* __to = &this.VSSamplers[0]) fixed (void* __from = @ref.VSSamplers) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &this.VSShaderResources[0]) fixed (void* __from = @ref.VSShaderResources) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = &this.VSConstantBuffers[0]) fixed (void* __from = @ref.VSConstantBuffers) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            this.Gs = @ref.Gs;
            fixed (void* __to = &this.GSSamplers[0]) fixed (void* __from = @ref.GSSamplers) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &this.GSShaderResources[0]) fixed (void* __from = @ref.GSShaderResources) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = &this.GSConstantBuffers[0]) fixed (void* __from = @ref.GSConstantBuffers) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            this.Ps = @ref.Ps;
            fixed (void* __to = &this.PSSamplers[0]) fixed (void* __from = @ref.PSSamplers) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &this.PSShaderResources[0]) fixed (void* __from = @ref.PSShaderResources) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = &this.PSConstantBuffers[0]) fixed (void* __from = @ref.PSConstantBuffers) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &this.IAVertexBuffers[0]) fixed (void* __from = @ref.IAVertexBuffers) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            this.IAIndexBuffer = @ref.IAIndexBuffer;
            this.IAInputLayout = @ref.IAInputLayout;
            this.IAPrimitiveTopology = @ref.IAPrimitiveTopology;
            this.OMRenderTargets = @ref.OMRenderTargets;
            this.OMDepthStencilState = @ref.OMDepthStencilState;
            this.OMBlendState = @ref.OMBlendState;
            this.RSViewports = @ref.RSViewports;
            this.RSScissorRects = @ref.RSScissorRects;
            this.RSRasterizerState = @ref.RSRasterizerState;
            this.SOBuffers = @ref.SOBuffers;
            this.Predication = @ref.Predication;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Vs = this.Vs;
            fixed (void* __to = @ref.VSSamplers) fixed (void* __from = &this.VSSamplers[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = @ref.VSShaderResources) fixed (void* __from = &this.VSShaderResources[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = @ref.VSConstantBuffers) fixed (void* __from = &this.VSConstantBuffers[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            @ref.Gs = this.Gs;
            fixed (void* __to = @ref.GSSamplers) fixed (void* __from = &this.GSSamplers[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = @ref.GSShaderResources) fixed (void* __from = &this.GSShaderResources[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = @ref.GSConstantBuffers) fixed (void* __from = &this.GSConstantBuffers[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            @ref.Ps = this.Ps;
            fixed (void* __to = @ref.PSSamplers) fixed (void* __from = &this.PSSamplers[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = @ref.PSShaderResources) fixed (void* __from = &this.PSShaderResources[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = @ref.PSConstantBuffers) fixed (void* __from = &this.PSConstantBuffers[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = @ref.IAVertexBuffers) fixed (void* __from = &this.IAVertexBuffers[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            @ref.IAIndexBuffer = this.IAIndexBuffer;
            @ref.IAInputLayout = this.IAInputLayout;
            @ref.IAPrimitiveTopology = this.IAPrimitiveTopology;
            @ref.OMRenderTargets = this.OMRenderTargets;
            @ref.OMDepthStencilState = this.OMDepthStencilState;
            @ref.OMBlendState = this.OMBlendState;
            @ref.RSViewports = this.RSViewports;
            @ref.RSScissorRects = this.RSScissorRects;
            @ref.RSRasterizerState = this.RSRasterizerState;
            @ref.SOBuffers = this.SOBuffers;
            @ref.Predication = this.Predication;
		
		}
    }
    
    /// <summary>	
    /// Describes an effect-variable type.	
    /// </summary>	
    /// <remarks>	
    /// To get an effect-variable type, call <see cref="SlimDX2.Direct3D10.EffectType.GetDescription"/>.	
    /// </remarks>	
    /// <unmanaged>D3D10_EFFECT_TYPE_DESC</unmanaged>
    public  partial struct EffectTypeDescription {	
        
        /// <summary>	
        /// A string that contains the variable name.	
        /// </summary>	
        /// <unmanaged>const char* TypeName</unmanaged>
        public string TypeName;
        
        /// <summary>	
        /// The variable class (see <see cref="SlimDX2.D3DCompiler.ShaderVariableClass"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_SHADER_VARIABLE_CLASS Class</unmanaged>
        public SlimDX2.D3DCompiler.ShaderVariableClass Class;
        
        /// <summary>	
        /// The variable type (see <see cref="SlimDX2.D3DCompiler.ShaderVariableType"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_SHADER_VARIABLE_TYPE Type</unmanaged>
        public SlimDX2.D3DCompiler.ShaderVariableType Type;
        
        /// <summary>	
        /// The number of elements if the variable is an array; otherwise 0.	
        /// </summary>	
        /// <unmanaged>UINT Elements</unmanaged>
        public int Elements;
        
        /// <summary>	
        /// The number of members if the variable is a structure; otherwise 0.	
        /// </summary>	
        /// <unmanaged>UINT Members</unmanaged>
        public int Members;
        
        /// <summary>	
        /// The number of rows if the variable is a matrix; otherwise 0.	
        /// </summary>	
        /// <unmanaged>UINT Rows</unmanaged>
        public int Rows;
        
        /// <summary>	
        /// The number of columns if the variable is a matrix; otherwise 0.	
        /// </summary>	
        /// <unmanaged>UINT Columns</unmanaged>
        public int Columns;
        
        /// <summary>	
        /// The number of bytes that the variable consumes when it is packed tightly by the compiler.	
        /// </summary>	
        /// <unmanaged>UINT PackedSize</unmanaged>
        public int PackedSize;
        
        /// <summary>	
        /// The number of bytes that the variable consumes before it is packed by the compiler.	
        /// </summary>	
        /// <unmanaged>UINT UnpackedSize</unmanaged>
        public int UnpackedSize;
        
        /// <summary>	
        /// The number of bytes between elements.	
        /// </summary>	
        /// <unmanaged>UINT Stride</unmanaged>
        public int Stride;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr TypeName;
            public SlimDX2.D3DCompiler.ShaderVariableClass Class;
            public SlimDX2.D3DCompiler.ShaderVariableType Type;
            public int Elements;
            public int Members;
            public int Rows;
            public int Columns;
            public int PackedSize;
            public int UnpackedSize;
            public int Stride;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.TypeName != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.TypeName);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.TypeName = ( @ref.TypeName == IntPtr.Zero )?null:new string((sbyte*)@ref.TypeName);
            this.Class = @ref.Class;
            this.Type = @ref.Type;
            this.Elements = @ref.Elements;
            this.Members = @ref.Members;
            this.Rows = @ref.Rows;
            this.Columns = @ref.Columns;
            this.PackedSize = @ref.PackedSize;
            this.UnpackedSize = @ref.UnpackedSize;
            this.Stride = @ref.Stride;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.TypeName = ( this.TypeName == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.TypeName);
            @ref.Class = this.Class;
            @ref.Type = this.Type;
            @ref.Elements = this.Elements;
            @ref.Members = this.Members;
            @ref.Rows = this.Rows;
            @ref.Columns = this.Columns;
            @ref.PackedSize = this.PackedSize;
            @ref.UnpackedSize = this.UnpackedSize;
            @ref.Stride = this.Stride;
		
		}
    }
    
    /// <summary>	
    /// Describes an effect variable.	
    /// </summary>	
    /// <remarks>	
    /// To get an effect-variable description, call <see cref="SlimDX2.Direct3D10.EffectVariable.GetDescription"/>.	
    /// </remarks>	
    /// <unmanaged>D3D10_EFFECT_VARIABLE_DESC</unmanaged>
    public  partial struct EffectVariableDescription {	
        
        /// <summary>	
        /// A string that contains the variable name.	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        /// The semantic attached to the variable; otherwise NULL.	
        /// </summary>	
        /// <unmanaged>const char* Semantic</unmanaged>
        public string Semantic;
        
        /// <summary>	
        /// Optional {{flags}} for effect variables. 	
        /// </summary>	
        /// <unmanaged>UINT Flags</unmanaged>
        public int Flags;
        
        /// <summary>	
        /// The number of annotations; otherwise 0.	
        /// </summary>	
        /// <unmanaged>UINT Annotations</unmanaged>
        public int Annotations;
        
        /// <summary>	
        /// The offset between the begining of the constant buffer and this variable; otherwise 0.	
        /// </summary>	
        /// <unmanaged>UINT BufferOffset</unmanaged>
        public int BufferOffset;
        
        /// <summary>	
        /// The register that this variable is bound to. To bind a variable explicitly use the D3D10_EFFECT_VARIABLE_EXPLICIT_BIND_POINT flag.	
        /// </summary>	
        /// <unmanaged>UINT ExplicitBindPoint</unmanaged>
        public int ExplicitBindPoint;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public IntPtr Semantic;
            public int Flags;
            public int Annotations;
            public int BufferOffset;
            public int ExplicitBindPoint;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
                if (this.Semantic != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Semantic);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.Semantic = ( @ref.Semantic == IntPtr.Zero )?null:new string((sbyte*)@ref.Semantic);
            this.Flags = @ref.Flags;
            this.Annotations = @ref.Annotations;
            this.BufferOffset = @ref.BufferOffset;
            this.ExplicitBindPoint = @ref.ExplicitBindPoint;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.Semantic = ( this.Semantic == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Semantic);
            @ref.Flags = this.Flags;
            @ref.Annotations = this.Annotations;
            @ref.BufferOffset = this.BufferOffset;
            @ref.ExplicitBindPoint = this.ExplicitBindPoint;
		
		}
    }
    
    /// <summary>	
    /// Describes an effect shader.	
    /// </summary>	
    /// <remarks>	
    /// To get an effect-shader description, call <see cref="SlimDX2.Direct3D10.EffectShaderVariable.GetShaderDescription"/>.	
    /// </remarks>	
    /// <unmanaged>D3D10_EFFECT_SHADER_DESC</unmanaged>
    public  partial struct EffectShaderDescription {	
        
        /// <summary>	
        /// Passed into CreateInputLayout. Only valid on a vertex shader or geometry shader. See {{ID3D10Device_CreateInputLayout}}.	
        /// </summary>	
        /// <unmanaged>const BYTE* pInputSignature</unmanaged>
        public IntPtr PInputSignature;
        
        /// <summary>	
        /// TRUE is the shader is defined inline; otherwise FALSE.	
        /// </summary>	
        /// <unmanaged>BOOL IsInline</unmanaged>
        public bool IsInline { 
            get { 
                return (_IsInline!=0)?true:false; 
            }
            set { 
                _IsInline = value?1:0;
            }
        }
        internal int _IsInline;
        
        /// <summary>	
        /// A pointer to the compiled shader.	
        /// </summary>	
        /// <unmanaged>const BYTE* pBytecode</unmanaged>
        public IntPtr PBytecode;
        
        /// <summary>	
        /// The length of pBytecode.	
        /// </summary>	
        /// <unmanaged>UINT BytecodeLength</unmanaged>
        public int BytecodeLength;
        
        /// <summary>	
        /// A string that constains a declaration of the {{stream output}} from a geometry shader.	
        /// </summary>	
        /// <unmanaged>const char* SODecl</unmanaged>
        public string SODecl;
        
        /// <summary>	
        /// The number of entries in the input signature.	
        /// </summary>	
        /// <unmanaged>UINT NumInputSignatureEntries</unmanaged>
        public int InputSignatureEntrieCount;
        
        /// <summary>	
        /// The number of entries in the output signature.	
        /// </summary>	
        /// <unmanaged>UINT NumOutputSignatureEntries</unmanaged>
        public int OutputSignatureEntrieCount;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr PInputSignature;
            public int _IsInline;
            public IntPtr PBytecode;
            public int BytecodeLength;
            public IntPtr SODecl;
            public int InputSignatureEntrieCount;
            public int OutputSignatureEntrieCount;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.SODecl != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.SODecl);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.PInputSignature = @ref.PInputSignature;
            this._IsInline = @ref._IsInline;
            this.PBytecode = @ref.PBytecode;
            this.BytecodeLength = @ref.BytecodeLength;
            this.SODecl = ( @ref.SODecl == IntPtr.Zero )?null:new string((sbyte*)@ref.SODecl);
            this.InputSignatureEntrieCount = @ref.InputSignatureEntrieCount;
            this.OutputSignatureEntrieCount = @ref.OutputSignatureEntrieCount;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.PInputSignature = this.PInputSignature;
            @ref._IsInline = this._IsInline;
            @ref.PBytecode = this.PBytecode;
            @ref.BytecodeLength = this.BytecodeLength;
            @ref.SODecl = ( this.SODecl == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.SODecl);
            @ref.InputSignatureEntrieCount = this.InputSignatureEntrieCount;
            @ref.OutputSignatureEntrieCount = this.OutputSignatureEntrieCount;
		
		}
    }
    
    /// <summary>	
    /// Describes an effect pass, which contains pipeline state.	
    /// </summary>	
    /// <remarks>	
    /// Get a pass description by calling <see cref="SlimDX2.Direct3D10.EffectPass.GetDescription"/>; an effect technique contains one or more passes.	
    /// </remarks>	
    /// <unmanaged>D3D10_PASS_DESC</unmanaged>
    public  partial struct EffectPassDescription {	
        
        /// <summary>	
        /// A string that contains the name of the pass; otherwise NULL.	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        /// The number of annotations.	
        /// </summary>	
        /// <unmanaged>UINT Annotations</unmanaged>
        public int AnnotationCount;
        
        /// <summary>	
        /// A pointer to the input signature or the vertex shader; otherwise NULL.	
        /// </summary>	
        /// <unmanaged>BYTE* pIAInputSignature</unmanaged>
        internal IntPtr PIAInputSignature;
        
        /// <summary>	
        /// The size of the input signature (in bytes).	
        /// </summary>	
        /// <unmanaged>SIZE_T IAInputSignatureSize</unmanaged>
        internal SlimDX2.Size IAInputSignatureSize;
        
        /// <summary>	
        /// The stencil-reference value used in the depth-stencil state (see {{Configuring Depth-Stencil Functionality (Direct3D 10)}}).	
        /// </summary>	
        /// <unmanaged>UINT StencilRef</unmanaged>
        public int StencilRef;
        
        /// <summary>	
        /// The sample mask for the blend state (see {{Configuring Blending Functionality (Direct3D 10)}}).	
        /// </summary>	
        /// <unmanaged>UINT SampleMask</unmanaged>
        public int SampleMask;
        
        /// <summary>	
        /// The per-component blend factors (RGBA) for the blend state (see {{Configuring Blending Functionality (Direct3D 10)}}).	
        /// </summary>	
        /// <unmanaged>FLOAT BlendFactor[4]</unmanaged>
        public SlimMath.Vector4 BlendFactor;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public int AnnotationCount;
            public IntPtr PIAInputSignature;
            public SlimDX2.Size IAInputSignatureSize;
            public int StencilRef;
            public int SampleMask;
            public SlimMath.Vector4 BlendFactor;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.AnnotationCount = @ref.AnnotationCount;
            this.PIAInputSignature = @ref.PIAInputSignature;
            this.IAInputSignatureSize = @ref.IAInputSignatureSize;
            this.StencilRef = @ref.StencilRef;
            this.SampleMask = @ref.SampleMask;
            this.BlendFactor = @ref.BlendFactor;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.AnnotationCount = this.AnnotationCount;
            @ref.PIAInputSignature = this.PIAInputSignature;
            @ref.IAInputSignatureSize = this.IAInputSignatureSize;
            @ref.StencilRef = this.StencilRef;
            @ref.SampleMask = this.SampleMask;
            @ref.BlendFactor = this.BlendFactor;
		
		}
    }
    
    /// <summary>	
    /// Describes an effect variable that contains a shader.	
    /// </summary>	
    /// <remarks>	
    /// To get a shader description, call a method like <see cref="SlimDX2.Direct3D10.EffectPass.GetVertexShaderDescription"/>.	
    /// </remarks>	
    /// <unmanaged>D3D10_PASS_SHADER_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct EffectPassShaderDescription {	
        
        /// <summary>	
        /// A pointer to the variable that the shader came from. If it is an inline shader assignment, the returned interface will be an anonymous shader variable, which is not retrievable any other way.  Its name in the variable description will be "$Anonymous". If there is no assignment of this type in the pass block, this will point to a shader variable that returns false when IsValid is called.	
        /// </summary>	
        /// <unmanaged>ID3D10EffectShaderVariable* pShaderVariable</unmanaged>
        public IntPtr PShaderVariable;
        
        /// <summary>	
        /// A zero-based array index; otherwise 0.	
        /// </summary>	
        /// <unmanaged>UINT ShaderIndex</unmanaged>
        public int ShaderIndex;
    }
    
    /// <summary>	
    /// Describes an effect technique.	
    /// </summary>	
    /// <remarks>	
    /// To get a technique, call <see cref="SlimDX2.Direct3D10.EffectTechnique.GetDescription"/>.	
    /// </remarks>	
    /// <unmanaged>D3D10_TECHNIQUE_DESC</unmanaged>
    public  partial struct EffectTechniqueDescription {	
        
        /// <summary>	
        /// A string that contains the technique name; otherwise NULL.	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        /// The number of passes in the technique.	
        /// </summary>	
        /// <unmanaged>UINT Passes</unmanaged>
        public int PasseCount;
        
        /// <summary>	
        /// The number of annotations.	
        /// </summary>	
        /// <unmanaged>UINT Annotations</unmanaged>
        public int AnnotationCount;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public int PasseCount;
            public int AnnotationCount;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.PasseCount = @ref.PasseCount;
            this.AnnotationCount = @ref.AnnotationCount;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.PasseCount = this.PasseCount;
            @ref.AnnotationCount = this.AnnotationCount;
		
		}
    }
    
    /// <summary>	
    /// Describes an effect.	
    /// </summary>	
    /// <remarks>	
    /// To get an effect description, call <see cref="SlimDX2.Direct3D10.Effect.GetDescription"/>.	
    /// </remarks>	
    /// <unmanaged>D3D10_EFFECT_DESC</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct EffectDescription {	
        
        /// <summary>	
        /// TRUE if the effect is a {{child effect}}; otherwise FALSE.	
        /// </summary>	
        /// <unmanaged>BOOL IsChildEffect</unmanaged>
        public bool IsChildEffect { 
            get { 
                return (_IsChildEffect!=0)?true:false; 
            }
            set { 
                _IsChildEffect = value?1:0;
            }
        }
        internal int _IsChildEffect;
        
        /// <summary>	
        /// The number of constant buffers.	
        /// </summary>	
        /// <unmanaged>UINT ConstantBuffers</unmanaged>
        public int ConstantBufferCount;
        
        /// <summary>	
        /// The number of constant buffers shared in an effect pool.	
        /// </summary>	
        /// <unmanaged>UINT SharedConstantBuffers</unmanaged>
        public int SharedConstantBufferCount;
        
        /// <summary>	
        /// The number of global variables.	
        /// </summary>	
        /// <unmanaged>UINT GlobalVariables</unmanaged>
        public int GlobalVariableCount;
        
        /// <summary>	
        /// The number of global variables shared in an effect pool.	
        /// </summary>	
        /// <unmanaged>UINT SharedGlobalVariables</unmanaged>
        public int SharedGlobalVariableCount;
        
        /// <summary>	
        /// The number of techniques.	
        /// </summary>	
        /// <unmanaged>UINT Techniques</unmanaged>
        public int TechniqueCount;
    }
    
    /// <summary>	
    /// Describes the blend state for a render target for a Direct3D 10.1 device	
    /// </summary>	
    /// <remarks>	
    /// To see how blending is done, see {{Output-Merger Stage (Direct3D 10)}}.These are the default values for blend state.StateDefault ValueBlendEnableFALSESrcBlendD3D10_BLEND_ONEDestBlendD3D10_BLEND_ZEROBlendOpD3D10_BLEND_OP_ADDSrcBlendAlphaD3D10_BLEND_ONEDestBlendAlphaD3D10_BLEND_ZEROBlendOpAlphaD3D10_BLEND_OP_ADDRenderTargetWriteMask0xFF?	
    /// </remarks>	
    /// <unmanaged>D3D10_RENDER_TARGET_BLEND_DESC1</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct RenderTargetBlendDescription1 {	
        
        /// <summary>	
        /// Enable (or disable) blending.	
        /// </summary>	
        /// <unmanaged>BOOL BlendEnable</unmanaged>
        public bool BlendEnable { 
            get { 
                return (_BlendEnable!=0)?true:false; 
            }
            set { 
                _BlendEnable = value?1:0;
            }
        }
        internal int _BlendEnable;
        
        /// <summary>	
        /// This {{blend option}} specifies the first RGB data source and includes an optional pre-blend operation.	
        /// </summary>	
        /// <unmanaged>D3D10_BLEND SrcBlend</unmanaged>
        public SlimDX2.Direct3D10.BlendOption SrcBlend;
        
        /// <summary>	
        /// This {{blend option}} specifies the second RGB data source and includes an optional pre-blend operation.	
        /// </summary>	
        /// <unmanaged>D3D10_BLEND DestBlend</unmanaged>
        public SlimDX2.Direct3D10.BlendOption DestBlend;
        
        /// <summary>	
        /// This {{blend operation}} defines how to combine the RGB data sources.	
        /// </summary>	
        /// <unmanaged>D3D10_BLEND_OP BlendOp</unmanaged>
        public SlimDX2.Direct3D10.BlendOperation BlendOp;
        
        /// <summary>	
        /// This {{blend option}} specifies the first alpha data source and includes an optional pre-blend operation. Blend options that end in _COLOR are not allowed.	
        /// </summary>	
        /// <unmanaged>D3D10_BLEND SrcBlendAlpha</unmanaged>
        public SlimDX2.Direct3D10.BlendOption SrcBlendAlpha;
        
        /// <summary>	
        /// This {{blend option}} specifies the second alpha data source and includes an optional pre-blend operation. Blend options that end in _COLOR are not allowed.	
        /// </summary>	
        /// <unmanaged>D3D10_BLEND DestBlendAlpha</unmanaged>
        public SlimDX2.Direct3D10.BlendOption DestBlendAlpha;
        
        /// <summary>	
        /// This {{blend operation}} defines how to combine the alpha data sources.	
        /// </summary>	
        /// <unmanaged>D3D10_BLEND_OP BlendOpAlpha</unmanaged>
        public SlimDX2.Direct3D10.BlendOperation BlendOpAlpha;
        
        /// <summary>	
        /// A write mask.	
        /// </summary>	
        /// <unmanaged>UINT8 RenderTargetWriteMask</unmanaged>
        public byte RenderTargetWriteMask;
    }
    
    /// <summary>	
    /// Describes the blend state for a Direct3D 10.1 device.	
    /// </summary>	
    /// <remarks>	
    /// To see how blending is done, see {{Output-Merger Stage (Direct3D 10)}}.These are the default values for the blend description.StateDefault ValueAlphaToCoverageEnableFALSEIndependentBlendEnableFALSERenderTarget[0].BlendEnableFALSERenderTarget[0].SrcBlendD3D10_BLEND_ONERenderTarget[0].DestBlendD3D10_BLEND_ZERORenderTarget[0].BlendOpD3D10_BLEND_OP_ADDRenderTarget[0].SrcBlendAlphaD3D10_BLEND_ONERenderTarget[0].DestBlendAlphaD3D10_BLEND_ZERORenderTarget[0].BlendOpAlphaD3D10_BLEND_OP_ADDRenderTarget[0].RenderTargetWriteMaskD3D10_COLOR_WRITE_ENABLE_ALL?This structure requires Windows Vista Service Pack 1.If the driver type is set to <see cref="SlimDX2.Direct3D.DriverType.Hardware"/>, the feature level is set to less than or equal to <see cref="SlimDX2.Direct3D.FeatureLevel.Level_9_3"/>, and the pixel format of the render target is set to <see cref="SlimDX2.DXGI.Format.R8G8B8A8_UNorm_SRgb"/>, DXGI_FORMAT_B8G8R8A8_UNORM_SRGB, or DXGI_FORMAT_B8G8R8X8_UNORM_SRGB, the device performs the blend in standard RGB (sRGB) space and not in linear space. However, if the feature level is set to greater than D3D_FEATURE_LEVEL_9_3, the device performs the blend in linear space.	
    /// </remarks>	
    /// <unmanaged>D3D10_BLEND_DESC1</unmanaged>
    public  partial struct BlendDescription1 {	
        
        /// <summary>	
        /// Determines whether or not to use the {{alpha-to-coverage}} multisampling technique when setting a render-target pixel.	
        /// </summary>	
        /// <unmanaged>BOOL AlphaToCoverageEnable</unmanaged>
        public bool AlphaToCoverageEnable { 
            get { 
                return (_AlphaToCoverageEnable!=0)?true:false; 
            }
            set { 
                _AlphaToCoverageEnable = value?1:0;
            }
        }
        internal int _AlphaToCoverageEnable;
        
        /// <summary>	
        /// Set to TRUE to enable independent blending in simultaneous render targets. If set to FALSE, only the RenderTarget[0] members are used. RenderTarget[1..7] are ignored.	
        /// </summary>	
        /// <unmanaged>BOOL IndependentBlendEnable</unmanaged>
        public bool IndependentBlendEnable { 
            get { 
                return (_IndependentBlendEnable!=0)?true:false; 
            }
            set { 
                _IndependentBlendEnable = value?1:0;
            }
        }
        internal int _IndependentBlendEnable;
        
        /// <summary>	
        /// An array of render-target-blend descriptions (see <see cref="SlimDX2.Direct3D10.RenderTargetBlendDescription1"/>); these correspond to the eight rendertargets  that can be set to the output-merger stage at one time.	
        /// </summary>	
        /// <unmanaged>D3D10_RENDER_TARGET_BLEND_DESC1 RenderTarget[8]</unmanaged>
        public SlimDX2.Direct3D10.RenderTargetBlendDescription1[] RenderTarget { 
            get { 
                if (_RenderTarget == null) {
                    _RenderTarget = new SlimDX2.Direct3D10.RenderTargetBlendDescription1[8];
                }
                return _RenderTarget; 
            }
        }
        internal SlimDX2.Direct3D10.RenderTargetBlendDescription1[] _RenderTarget;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public int _AlphaToCoverageEnable;
            public int _IndependentBlendEnable;
            public SlimDX2.Direct3D10.RenderTargetBlendDescription1 RenderTarget;
            SlimDX2.Direct3D10.RenderTargetBlendDescription1 __RenderTarget1;
            SlimDX2.Direct3D10.RenderTargetBlendDescription1 __RenderTarget2;
            SlimDX2.Direct3D10.RenderTargetBlendDescription1 __RenderTarget3;
            SlimDX2.Direct3D10.RenderTargetBlendDescription1 __RenderTarget4;
            SlimDX2.Direct3D10.RenderTargetBlendDescription1 __RenderTarget5;
            SlimDX2.Direct3D10.RenderTargetBlendDescription1 __RenderTarget6;
            SlimDX2.Direct3D10.RenderTargetBlendDescription1 __RenderTarget7;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this._AlphaToCoverageEnable = @ref._AlphaToCoverageEnable;
            this._IndependentBlendEnable = @ref._IndependentBlendEnable;
            fixed (void* __to = &this.RenderTarget[0]) fixed (void* __from = &@ref.RenderTarget) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 8*sizeof ( SlimDX2.Direct3D10.RenderTargetBlendDescription1));
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref._AlphaToCoverageEnable = this._AlphaToCoverageEnable;
            @ref._IndependentBlendEnable = this._IndependentBlendEnable;
            fixed (void* __to = &@ref.RenderTarget) fixed (void* __from = &this.RenderTarget[0]) SlimDX2.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 8*sizeof ( SlimDX2.Direct3D10.RenderTargetBlendDescription1));
		
		}
    }
    
    /// <summary>	
    /// Describes a shader-resource view.	
    /// </summary>	
    /// <remarks>	
    /// A view is a format-specific way to look at the data in a resource. The view determines what data to look at, and how it is cast when read. For more information about how views work, see {{Views}}When viewing a resource, the resource-view description must specify a typed format, that is compatible with the resource format. So that means that you cannot create a resource-view description using any format with _TYPELESS in the name. You can however view a typeless resource by specifying a typed format for the view. For example, a DXGI_FORMAT_R32G32B32_TYPELESS resource can be viewed with one of these typed formats: DXGI_FORMAT_R32G32B32_FLOAT, DXGI_FORMAT_R32G32B32_UINT, and DXGI_FORMAT_R32G32B32_SINT, since these typed formats are compatible with the typeless resource.Create a shader-resource-view description by calling <see cref="SlimDX2.Direct3D10.Device1.CreateShaderResourceView1"/>. To view a shader-resource-view description, call <see cref="SlimDX2.Direct3D10.ShaderResourceView.GetDescription"/>.This structure requires Windows Vista Service Pack 1.	
    /// </remarks>	
    /// <unmanaged>D3D10_SHADER_RESOURCE_VIEW_DESC1</unmanaged>
    [StructLayout(LayoutKind.Explicit, Pack = 0 )]
    public  partial struct ShaderResourceViewDescription1 {	
        
        /// <summary>	
        /// Specifies the {{subresource(s)}} from an array of {{cube textures}} to use in a shader-resource view.	
        /// </summary>	
        /// <remarks>	
        /// This structure is one member of a shader-resource-view description (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription1"/>).This structure requires Windows Vista Service Pack 1.	
        /// </remarks>	
        /// <unmanaged>D3D10_TEXCUBE_ARRAY_SRV1</unmanaged>
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        public  partial struct TextureCubeArrayResource1 {	
            
            /// <summary>	
            /// Index of the most detailed mipmap level to use; this number is between 0 and MipLevels.	
            /// </summary>	
            /// <unmanaged>UINT MostDetailedMip</unmanaged>
            public int MostDetailedMip;
            
            /// <summary>	
            /// Number of mipmap levels to use.	
            /// </summary>	
            /// <unmanaged>UINT MipLevels</unmanaged>
            public int MipLevels;
            
            /// <summary>	
            /// Index of the first 2D texture to use.	
            /// </summary>	
            /// <unmanaged>UINT First2DArrayFace</unmanaged>
            public int First2DArrayFace;
            
            /// <summary>	
            /// Number of cube textures in the array.	
            /// </summary>	
            /// <unmanaged>UINT NumCubes</unmanaged>
            public int CubeCount;
        }
        
        /// <summary>	
        /// The viewing {{format}}. See remarks.	
        /// </summary>	
        /// <unmanaged>DXGI_FORMAT Format</unmanaged>
        [FieldOffset(0)]
        public SlimDX2.DXGI.Format Format;
        
        /// <summary>	
        /// The resource type of the view. See <see cref="SlimDX2.Direct3D.ShaderResourceViewDimension"/>. This should be the same as the resource type of the underlying resource. This parameter also determines which _SRV to use in the union below.	
        /// </summary>	
        /// <unmanaged>D3D10_SRV_DIMENSION1 ViewDimension</unmanaged>
        [FieldOffset(4)]
        public SlimDX2.Direct3D.ShaderResourceViewDimension ViewDimension;
        
        /// <summary>	
        /// View the resource as a buffer using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.BufferResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_BUFFER_SRV Buffer</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.BufferResource Buffer;
        
        /// <summary>	
        /// View the resource as a 1D texture using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture1DResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEX1D_SRV Texture1D</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture1DResource Texture1D;
        
        /// <summary>	
        /// View the resource as a 1D-texture array using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture1DArrayResource"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_TEX1D_ARRAY_SRV Texture1DArray</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture1DArrayResource Texture1DArray;
        
        /// <summary>	
        /// View the resource as a 2D-texture using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture2DResource"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_TEX2D_SRV Texture2D</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture2DResource Texture2D;
        
        /// <summary>	
        /// View the resource as a 2D-texture array using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture2DArrayResource"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_TEX2D_ARRAY_SRV Texture2DArray</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture2DArrayResource Texture2DArray;
        
        /// <summary>	
        /// View the resource as a 2D-multisampled texture using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture2DMultisampledResource"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_TEX2DMS_SRV Texture2DMS</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture2DMultisampledResource Texture2DMS;
        
        /// <summary>	
        /// View the resource as a 2D-multisampled-texture array using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture2DMultisampledArrayResource"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_TEX2DMS_ARRAY_SRV Texture2DMSArray</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture2DMultisampledArrayResource Texture2DMSArray;
        
        /// <summary>	
        /// View the resource as a 3D texture using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture3DResource"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_TEX3D_SRV Texture3D</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.Texture3DResource Texture3D;
        
        /// <summary>	
        /// View the resource as a 3D-cube texture using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription.TextureCubeResource"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEXCUBE_SRV TextureCube</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription.TextureCubeResource TextureCube;
        
        /// <summary>	
        /// View the resource as an array of cube textures using information from a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription1.TextureCubeArrayResource1"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_TEXCUBE_ARRAY_SRV1 TextureCubeArray</unmanaged>
        [FieldOffset(8)]
        public SlimDX2.Direct3D10.ShaderResourceViewDescription1.TextureCubeArrayResource1 TextureCubeArray;
    }
    
    /// <summary>	
    /// Defines position, texture, and color information about a sprite.	
    /// </summary>	
    /// <unmanaged>D3DX10_SPRITE</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct SpriteType {	
        
        /// <summary>	
        /// The sprite's model-world transformation. This defines the position and orientation of the sprite in world space.	
        /// </summary>	
        /// <unmanaged>D3DXMATRIX matWorld</unmanaged>
        public SlimMath.Matrix MatWorld;
        
        /// <summary>	
        /// Offset from the upper-left corner of the texture indicating where the sprite image should start in the texture.  TexCoord is in  texture coordinates.	
        /// </summary>	
        /// <unmanaged>D3DXVECTOR2 TexCoord</unmanaged>
        public SlimMath.Vector2 TexCoord;
        
        /// <summary>	
        /// A vector containing the width and height of the sprite in texture coordinates.	
        /// </summary>	
        /// <unmanaged>D3DXVECTOR2 TexSize</unmanaged>
        public SlimMath.Vector2 TexSize;
        
        /// <summary>	
        /// A color that will be multiplied with the pixel color before rendering.	
        /// </summary>	
        /// <unmanaged>D3DXCOLOR ColorModulate</unmanaged>
        public int ColorModulate;
        
        /// <summary>	
        /// Pointer to a shader-resource view representing the sprite's texture. See <see cref="SlimDX2.Direct3D10.ShaderResourceView"/>.	
        /// </summary>	
        /// <unmanaged>ID3D10ShaderResourceView* pTexture</unmanaged>
        public IntPtr PTexture;
        
        /// <summary>	
        /// The index of the texture. If pTexture does not represent a texture array, then this should be 0.	
        /// </summary>	
        /// <unmanaged>UINT TextureIndex</unmanaged>
        public int TextureIndex;
    }
    
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <unmanaged>D3DX10_FONT_DESCW</unmanaged>
    public  partial struct FontDescription {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>INT Height</unmanaged>
        public int Height;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT Width</unmanaged>
        public int Width;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT Weight</unmanaged>
        public int Weight;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT MipLevels</unmanaged>
        public int MipLevels;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>BOOL Italic</unmanaged>
        public bool Italic { 
            get { 
                return (_Italic!=0)?true:false; 
            }
            set { 
                _Italic = value?1:0;
            }
        }
        internal int _Italic;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>BYTE CharSet</unmanaged>
        public byte CharSet;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>BYTE OutputPrecision</unmanaged>
        public byte OutputPrecision;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>BYTE Quality</unmanaged>
        public byte Quality;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>BYTE PitchAndFamily</unmanaged>
        public byte PitchAndFamily;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>wchar FaceName[32]</unmanaged>
        public string FaceName;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public int Height;
            public int Width;
            public int Weight;
            public int MipLevels;
            public int _Italic;
            public byte CharSet;
            public byte OutputPrecision;
            public byte Quality;
            public byte PitchAndFamily;
            public fixed char FaceName[32];
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Height = @ref.Height;
            this.Width = @ref.Width;
            this.Weight = @ref.Weight;
            this.MipLevels = @ref.MipLevels;
            this._Italic = @ref._Italic;
            this.CharSet = @ref.CharSet;
            this.OutputPrecision = @ref.OutputPrecision;
            this.Quality = @ref.Quality;
            this.PitchAndFamily = @ref.PitchAndFamily;
            fixed (char* __ptr = @ref.FaceName) this.FaceName = new string(__ptr, 0, 32);
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Height = this.Height;
            @ref.Width = this.Width;
            @ref.Weight = this.Weight;
            @ref.MipLevels = this.MipLevels;
            @ref._Italic = this._Italic;
            @ref.CharSet = this.CharSet;
            @ref.OutputPrecision = this.OutputPrecision;
            @ref.Quality = this.Quality;
            @ref.PitchAndFamily = this.PitchAndFamily;
            fixed (char* __psrc = this.FaceName) fixed (char* __ptr = @ref.FaceName) Utilities.CopyMemory((IntPtr)__ptr, (IntPtr)__psrc, 32);
		
		}
    }
    
    /// <summary>	
    /// Returns a description of the original contents of an image file.	
    /// </summary>	
    /// <unmanaged>D3DX10_IMAGE_INFO</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ImageInformation {	
        
        /// <summary>	
        /// Width of original image in pixels.	
        /// </summary>	
        /// <unmanaged>UINT Width</unmanaged>
        public int Width;
        
        /// <summary>	
        /// Height of original image in pixels.	
        /// </summary>	
        /// <unmanaged>UINT Height</unmanaged>
        public int Height;
        
        /// <summary>	
        /// Depth of original image in pixels.	
        /// </summary>	
        /// <unmanaged>UINT Depth</unmanaged>
        public int Depth;
        
        /// <summary>	
        /// Size of the texture array. ArraySize will be 1 for a single image.	
        /// </summary>	
        /// <unmanaged>UINT ArraySize</unmanaged>
        public int ArraySize;
        
        /// <summary>	
        /// Number of mipmap levels in original image.	
        /// </summary>	
        /// <unmanaged>UINT MipLevels</unmanaged>
        public int MipLevels;
        
        /// <summary>	
        /// Miscellaneous resource properties (see <see cref="SlimDX2.Direct3D10.ResourceOptionFlags"/>).	
        /// </summary>	
        /// <unmanaged>UINT MiscFlags</unmanaged>
        public SlimDX2.Direct3D10.ResourceOptionFlags OptionFlags;
        
        /// <summary>	
        /// A value from the <see cref="SlimDX2.DXGI.Format"/> enumerated type that most closely describes the data in the original image.	
        /// </summary>	
        /// <unmanaged>DXGI_FORMAT Format</unmanaged>
        public SlimDX2.DXGI.Format Format;
        
        /// <summary>	
        /// Represents the type of the texture stored in the file. See <see cref="SlimDX2.Direct3D10.ResourceDimension"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_RESOURCE_DIMENSION ResourceDimension</unmanaged>
        public SlimDX2.Direct3D10.ResourceDimension ResourceDimension;
        
        /// <summary>	
        /// Represents the format of the image file.  See <see cref="SlimDX2.Direct3D10.ImageFileFormat"/>.	
        /// </summary>	
        /// <unmanaged>D3DX10_IMAGE_FILE_FORMAT ImageFileFormat</unmanaged>
        public SlimDX2.Direct3D10.ImageFileFormat ImageFileFormat;
    }
    
    /// <summary>	
    /// Optionally provide information to texture loader APIs to control how textures get loaded. A value of D3DX10_DEFAULT for any of these parameters will cause D3DX to automatically use the value from the source file.	
    /// </summary>	
    /// <remarks>	
    /// When initializing the structure, you may set any member to D3DX10_DEFAULT and D3DX will initialize it with a default value from the source texture when the texture is loaded.This structure can be used by APIs that:Create resources, such as {{D3DX10CreateTextureFromFile}} and {{D3DX10CreateShaderResourceViewFromFile}}.Create data processors, such as {{D3DX10CreateAsyncTextureInfoProcessor}} or	
    /// {{D3DX10CreateAsyncShaderResourceViewProcessor}}.	
    /// </remarks>	
    /// <unmanaged>D3DX10_IMAGE_LOAD_INFO</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ImageLoadInformation {	
        
        /// <summary>	
        /// The target width of the texture. If the actual width of the texture is larger or smaller than this value then the texture will be scaled up or down to fit this target width.	
        /// </summary>	
        /// <unmanaged>UINT Width</unmanaged>
        public int Width;
        
        /// <summary>	
        /// The target height of the texture. If the actual height of the texture is larger or smaller than this value then the texture will be scaled up or down to fit this target height.	
        /// </summary>	
        /// <unmanaged>UINT Height</unmanaged>
        public int Height;
        
        /// <summary>	
        /// The depth of the texture. This only applies to volume textures.	
        /// </summary>	
        /// <unmanaged>UINT Depth</unmanaged>
        public int Depth;
        
        /// <summary>	
        /// The highest resolution mipmap level of the texture. If this is greater than 0, then after the texture is loaded FirstMipLevel will be mapped to mipmap level 0.	
        /// </summary>	
        /// <unmanaged>UINT FirstMipLevel</unmanaged>
        public int FirstMipLevel;
        
        /// <summary>	
        /// The maximum number of mipmap levels that the texture will have. Using 0 or D3DX10_DEFAULT will cause a full mipmap chain to be created.	
        /// </summary>	
        /// <unmanaged>UINT MipLevels</unmanaged>
        public int MipLevels;
        
        /// <summary>	
        /// The way the texture resource is intended to be used. See <see cref="SlimDX2.Direct3D10.ResourceUsage"/>.	
        /// </summary>	
        /// <unmanaged>D3D10_USAGE Usage</unmanaged>
        public SlimDX2.Direct3D10.ResourceUsage Usage;
        
        /// <summary>	
        /// The pipeline stages that the texture will be allowed to bind to. See <see cref="SlimDX2.Direct3D10.BindFlags"/>.	
        /// </summary>	
        /// <unmanaged>UINT BindFlags</unmanaged>
        public SlimDX2.Direct3D10.BindFlags BindFlags;
        
        /// <summary>	
        /// The access permissions the cpu will have for the texture resource. See <see cref="SlimDX2.Direct3D10.CpuAccessFlags"/>.	
        /// </summary>	
        /// <unmanaged>UINT CpuAccessFlags</unmanaged>
        public SlimDX2.Direct3D10.CpuAccessFlags CpuAccessFlags;
        
        /// <summary>	
        /// Miscellaneous resource properties (see <see cref="SlimDX2.Direct3D10.ResourceOptionFlags"/>).	
        /// </summary>	
        /// <unmanaged>UINT MiscFlags</unmanaged>
        public SlimDX2.Direct3D10.ResourceOptionFlags OptionFlags;
        
        /// <summary>	
        /// The format the texture will be in after it is loaded. See <see cref="SlimDX2.DXGI.Format"/>.	
        /// </summary>	
        /// <unmanaged>DXGI_FORMAT Format</unmanaged>
        public SlimDX2.DXGI.Format Format;
        
        /// <summary>	
        /// Filter the texture using the specified filter (only when resampling). See <see cref="SlimDX2.Direct3D10.FilterFlags"/>.	
        /// </summary>	
        /// <unmanaged>UINT Filter</unmanaged>
        public SlimDX2.Direct3D10.FilterFlags Filter;
        
        /// <summary>	
        /// Filter the texture mip levels using the specified filter (only if generating mipmaps). Valid values are D3DX10_FILTER_NONE, D3DX10_FILTER_POINT, D3DX10_FILTER_LINEAR, or D3DX10_FILTER_TRIANGLE. See <see cref="SlimDX2.Direct3D10.FilterFlags"/>.	
        /// </summary>	
        /// <unmanaged>UINT MipFilter</unmanaged>
        public SlimDX2.Direct3D10.FilterFlags MipFilter;
        
        /// <summary>	
        /// Information about the original image. See <see cref="SlimDX2.Direct3D10.ImageInformation"/>. Can be obtained with {{D3DX10GetImageInfoFromFile}}, <see cref="SlimDX2.Direct3D10.D3DX10.GetImageInfoFromMemory"/>, or {{D3DX10GetImageInfoFromResource}}.	
        /// </summary>	
        /// <unmanaged>D3DX10_IMAGE_INFO* pSrcInfo</unmanaged>
        public IntPtr PSrcInfo;
    }
    
    /// <summary>	
    /// Describes parameters used to load a texture from another texture.	
    /// </summary>	
    /// <remarks>	
    /// This structure is used in a call to <see cref="SlimDX2.Direct3D10.D3DX10.LoadTextureFromTexture"/>.	
    /// </remarks>	
    /// <unmanaged>D3DX10_TEXTURE_LOAD_INFO</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct TextureLoadInformation {	
        
        /// <summary>	
        /// Source texture box (see <see cref="SlimDX2.Direct3D10.ResourceRegion"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_BOX* pSrcBox</unmanaged>
        public IntPtr PSrcBox;
        
        /// <summary>	
        /// Destination texture box (see <see cref="SlimDX2.Direct3D10.ResourceRegion"/>).	
        /// </summary>	
        /// <unmanaged>D3D10_BOX* pDstBox</unmanaged>
        public IntPtr PDstBox;
        
        /// <summary>	
        /// Source texture mipmap level, see {{D3D10CalcSubresource}} for more detail.	
        /// </summary>	
        /// <unmanaged>UINT SrcFirstMip</unmanaged>
        public int SrcFirstMip;
        
        /// <summary>	
        /// Destination texture mipmap level, see {{D3D10CalcSubresource}} for more detail.	
        /// </summary>	
        /// <unmanaged>UINT DstFirstMip</unmanaged>
        public int DstFirstMip;
        
        /// <summary>	
        /// Number of mipmap levels in the source texture.	
        /// </summary>	
        /// <unmanaged>UINT NumMips</unmanaged>
        public int MipCount;
        
        /// <summary>	
        /// First element of the source texture.	
        /// </summary>	
        /// <unmanaged>UINT SrcFirstElement</unmanaged>
        public int SrcFirstElement;
        
        /// <summary>	
        /// First element of the destination texture.	
        /// </summary>	
        /// <unmanaged>UINT DstFirstElement</unmanaged>
        public int DstFirstElement;
        
        /// <summary>	
        /// Number of elements to load.	
        /// </summary>	
        /// <unmanaged>UINT NumElements</unmanaged>
        public int ElementCount;
        
        /// <summary>	
        /// Filtering options during resampling (see <see cref="SlimDX2.Direct3D10.FilterFlags"/>).	
        /// </summary>	
        /// <unmanaged>UINT Filter</unmanaged>
        public SlimDX2.Direct3D10.FilterFlags Filter;
        
        /// <summary>	
        /// Filtering options when generating mip levels (see <see cref="SlimDX2.Direct3D10.FilterFlags"/>).	
        /// </summary>	
        /// <unmanaged>UINT MipFilter</unmanaged>
        public SlimDX2.Direct3D10.FilterFlags MipFilter;
    }
}
