// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Interfaces for SlimDX2.Direct3D10 namespace.
//     This code was generated by a tool.
//     Date : 11/08/2010 15:18:19
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace SlimDX2.Direct3D10 {

    
    /// <summary>	
    /// A device-child interface accesses data used by a device.	
    /// </summary>	
    /// <unmanaged>ID3D10DeviceChild</unmanaged>
    [Guid("9B7E4C00-342C-4106-A19F-4F2704F689F0")]
    public partial class DeviceChild : SlimDX2.ComObject {
        public DeviceChild(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get a pointer to the device that created this interface.	
        /// </summary>	
        /// <remarks>	
        /// Any returned interfaces will have their reference count incremented by one, so be sure to call ::release() on the returned pointer(s) before they are freed or else you will have a memory leak.	
        /// </remarks>	
        /// <unmanaged>void GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>
        public SlimDX2.Direct3D10.Device Device {
                get { SlimDX2.Direct3D10.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a pointer to the device that created this interface.	
        /// </summary>	
        /// <remarks>	
        /// Any returned interfaces will have their reference count incremented by one, so be sure to call ::release() on the returned pointer(s) before they are freed or else you will have a memory leak.	
        /// </remarks>	
        /// <param name="deviceRef">Address of a pointer to a device (see <see cref="SlimDX2.Direct3D10.Device"/>).</param>
        /// <unmanaged>void GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>
        internal void GetDevice(out SlimDX2.Direct3D10.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 3 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Device(deviceRef_);	
            }
        }
        
        /// <summary>	
        /// Get application-defined data from a device child.	
        /// </summary>	
        /// <remarks>	
        /// The data stored in the device child is set with <see cref="SlimDX2.Direct3D10.DeviceChild.SetPrivateData"/>.	
        /// </remarks>	
        /// <param name="guid">Guid associated with the data.</param>
        /// <param name="dataSizeRef">Size of the data.</param>
        /// <param name="dataRef">Pointer to the data stored with the device child. If pData is NULL, DataSize must also be 0, and any data previously associated with the guid will be destroyed.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetPrivateData([In] REFGUID guid,[InOut] UINT* pDataSize,[Out, Buffer, Optional] void* pData)</unmanaged>
        public SlimDX2.Result GetPrivateData(Guid guid, ref int dataSizeRef, IntPtr dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* dataSizeRef_ = &dataSizeRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 4 * 4, &guid, dataSizeRef_, (void*)dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set application-defined data to a device child and associate that data with an application-defined guid.	
        /// </summary>	
        /// <remarks>	
        /// The data stored in the device child with this method can be retrieved with <see cref="SlimDX2.Direct3D10.DeviceChild.GetPrivateData"/>.	
        /// </remarks>	
        /// <param name="guid">Guid associated with the data.</param>
        /// <param name="dataSize">Size of the data.</param>
        /// <param name="dataRef">Pointer to the data to be stored with this device child. If pData is NULL, DataSize must also be 0, and any data previously associated with the specified guid will be destroyed.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetPrivateData([In] REFGUID guid,[In] UINT DataSize,[In, Buffer, Optional] const void* pData)</unmanaged>
        public SlimDX2.Result SetPrivateData(Guid guid, int dataSize, IntPtr dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 5 * 4, &guid, dataSize, (void*)dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Associate an <see cref="SlimDX2.ComObject"/>-derived interface with this device child and associate that interface with an application-defined guid.	
        /// </summary>	
        /// <remarks>	
        /// When this method is called ::addref() will be called on the <see cref="SlimDX2.ComObject"/>-derived interface, and when the device child is detroyed ::release() will be called on the IUnknown-derived interface.	
        /// </remarks>	
        /// <param name="guid">Guid associated with the interface.</param>
        /// <param name="dataRef">Pointer to an <see cref="SlimDX2.ComObject"/>-derived interface to be associated with the device child.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetPrivateDataInterface([In] REFGUID guid,[In, Optional] const IUnknown* pData)</unmanaged>
        public SlimDX2.Result SetPrivateDataInterface(Guid guid, SlimDX2.ComObject dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 6 * 4, &guid, (void*)((dataRef == null)?IntPtr.Zero:dataRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A depth-stencil-state interface accesses depth-stencil state which sets up the {{depth-stencil test}} for the output-merger stage.	
    /// </summary>	
    /// <unmanaged>ID3D10DepthStencilState</unmanaged>
    [Guid("2B4B1CC8-A4AD-41f8-8322-CA86FC3EC675")]
    public partial class DepthStencilState : SlimDX2.Direct3D10.DeviceChild {
        public DepthStencilState(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the depth-stencil state.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D10_DEPTH_STENCIL_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.DepthStencilStateDescription Description {
                get { SlimDX2.Direct3D10.DepthStencilStateDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the depth-stencil state.	
        /// </summary>	
        /// <param name="descRef">A pointer to the depth-stencil state (see <see cref="SlimDX2.Direct3D10.DepthStencilStateDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D10_DEPTH_STENCIL_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D10.DepthStencilStateDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D10.DepthStencilStateDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 7 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// This blend-state interface accesses blending state for a Direct3D 10.0 device for the {{output-merger}} stage.	
    /// </summary>	
    /// <unmanaged>ID3D10BlendState</unmanaged>
    [Guid("EDAD8D19-8A35-4d6d-8566-2EA276CDE161")]
    public partial class BlendState : SlimDX2.Direct3D10.DeviceChild {
        public BlendState(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the blend state.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D10_BLEND_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.BlendStateDescription Description {
                get { SlimDX2.Direct3D10.BlendStateDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the blend state.	
        /// </summary>	
        /// <param name="descRef">A pointer to the blend state (see <see cref="SlimDX2.Direct3D10.BlendStateDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D10_BLEND_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D10.BlendStateDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.BlendStateDescription.__Native descRef_ = new SlimDX2.Direct3D10.BlendStateDescription.__Native();
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 7 * 4, &descRef_);
                descRef = new SlimDX2.Direct3D10.BlendStateDescription();
                descRef.__MarshalFrom(ref descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A rasterizer-state interface accesses rasterizer state for the {{rasterizer stage}}.	
    /// </summary>	
    /// <unmanaged>ID3D10RasterizerState</unmanaged>
    [Guid("A2A07292-89AF-4345-BE2E-C53D9FBB6E9F")]
    public partial class RasterizerState : SlimDX2.Direct3D10.DeviceChild {
        public RasterizerState(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the properties of a rasterizer-state object.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D10_RASTERIZER_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.RasterizerStateDescription Description {
                get { SlimDX2.Direct3D10.RasterizerStateDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the properties of a rasterizer-state object.	
        /// </summary>	
        /// <param name="descRef">Pointer to a rasterizer-state description (see <see cref="SlimDX2.Direct3D10.RasterizerStateDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D10_RASTERIZER_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D10.RasterizerStateDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D10.RasterizerStateDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 7 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A resource interface provides common actions on all {{resources}}.	
    /// </summary>	
    /// <unmanaged>ID3D10Resource</unmanaged>
    [Guid("9B7E4C01-342C-4106-A19F-4F2704F689F0")]
    public partial class Resource : SlimDX2.Direct3D10.DeviceChild {
        public Resource(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the type of the resource.	
        /// </summary>	
        /// <unmanaged>void GetType([Out] D3D10_RESOURCE_DIMENSION* rType)</unmanaged>
        public SlimDX2.Direct3D10.ResourceDimension TypeInfo {
                get { SlimDX2.Direct3D10.ResourceDimension __output__; GetTypeInfo(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the eviction priority of a resource.	
        /// </summary>	
        /// <remarks>	
        /// This method is a wrapper for {{GetEvictionPriority}} and is provided in the <see cref="SlimDX2.Direct3D10.Resource"/> interface for convenience.	
        /// </remarks>	
        /// <unmanaged>UINT GetEvictionPriority()</unmanaged>
        public int EvictionPriority {
                get { return GetEvictionPriority(); }
                set { SetEvictionPriority(value); }
        }
        
        /// <summary>	
        /// Get the type of the resource.	
        /// </summary>	
        /// <param name="rType">Pointer to the resource type (see <see cref="SlimDX2.Direct3D10.ResourceDimension"/>).</param>
        /// <unmanaged>void GetType([Out] D3D10_RESOURCE_DIMENSION* rType)</unmanaged>
        internal void GetTypeInfo(out SlimDX2.Direct3D10.ResourceDimension rType) {
            unsafe {
                fixed (void* rType_ = &rType)
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 7 * 4, rType_);
            }
        }
        
        /// <summary>	
        /// Set the eviction priority of a resource.	
        /// </summary>	
        /// <remarks>	
        /// Resource priorities determine which resource to evict from video memory when the system has run out of video memory. The resource will not be lost; it will be removed from video memory and placed into system memory, or possibly placed onto the hard drive. The resource will be loaded back into video memory when it is required.A resource that is set to the maximum priority, DXGI_RESOURCE_PRIORITY_MAXIMUM, is only evicted if there is no other way of resolving the incoming memory request. The Windows Display Driver Model (WDDM) tries to split an incoming memory request to its minimum size and evict lower-priority resources before evicting a resource with maximum priority.Changing the priorities of resources should be done carefully. The wrong eviction priorities could be a detriment to performance rather than an improvement. See {{QueryResourceResidency}} for additional information.This method is a wrapper for {{SetEvictionPriority}} and is provided in the <see cref="SlimDX2.Direct3D10.Resource"/> interface for convenience.	
        /// </remarks>	
        /// <param name="evictionPriority">Eviction priority for the resource, which is one of the following values:DXGI_RESOURCE_PRIORITY_MINIMUMDXGI_RESOURCE_PRIORITY_LOWDXGI_RESOURCE_PRIORITY_NORMALDXGI_RESOURCE_PRIORITY_HIGHDXGI_RESOURCE_PRIORITY_MAXIMUM</param>
        /// <unmanaged>void SetEvictionPriority([In] UINT EvictionPriority)</unmanaged>
        internal void SetEvictionPriority(int evictionPriority) {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 8 * 4, evictionPriority);
            }
        }
        
        /// <summary>	
        /// Get the eviction priority of a resource.	
        /// </summary>	
        /// <remarks>	
        /// This method is a wrapper for {{GetEvictionPriority}} and is provided in the <see cref="SlimDX2.Direct3D10.Resource"/> interface for convenience.	
        /// </remarks>	
        /// <returns>One of the following values, which specifies the eviction priority for the resource:DXGI_RESOURCE_PRIORITY_MINIMUMDXGI_RESOURCE_PRIORITY_LOWDXGI_RESOURCE_PRIORITY_NORMALDXGI_RESOURCE_PRIORITY_HIGHDXGI_RESOURCE_PRIORITY_MAXIMUM</returns>
        /// <unmanaged>UINT GetEvictionPriority()</unmanaged>
        internal int GetEvictionPriority() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 9 * 4);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A buffer interface accesses a {{buffer resource}}, which is unstructured memory. Buffers typically store vertex or index data.	
    /// </summary>	
    /// <unmanaged>ID3D10Buffer</unmanaged>
    [Guid("9B7E4C02-342C-4106-A19F-4F2704F689F0")]
    public partial class Buffer : SlimDX2.Direct3D10.Resource {
        public Buffer(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the properties of a buffer resource.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D10_BUFFER_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.BufferDescription Description {
                get { SlimDX2.Direct3D10.BufferDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a pointer to the data contained in the resource and deny GPU access to the resource.	
        /// </summary>	
        /// <remarks>	
        /// For the CPU to write the contents of a resource, the resource must be created with the dynamic usage flag, D3D10_USAGE_DYNAMIC.  To both read and write those contents, the resource must be created with the staging usage flag, D3D10_USAGE_STAGING. (For more information about  these flags, see <see cref="SlimDX2.Direct3D10.ResourceUsage"/>.) ID3D10Buffer::Map will retrieve a pointer to the resource data.  For a discussion on how to access resources efficiently, see {{Copying and Accessing Resource Data (Direct3D 10)}}.Call <see cref="SlimDX2.Direct3D10.Buffer.Unmap"/> to signify that the application has finished accessing the resource.ID3D10Buffer::Map has a few other restrictions. For example:The same buffer cannot be mapped multiple times; in other words, do not call ID3D10Buffer::Map on a buffer that is already mapped.Any buffer that is bound to the pipeline must be unmapped before any rendering operation (that is, <see cref="SlimDX2.Direct3D10.Device.Draw"/>)  can be executed.Differences between Direct3D 9 and Direct3D 10:ID3D10Buffer::Map in Direct3D 10 is analogous to resource {{Lock}} in Direct3D 9.?	
        /// </remarks>	
        /// <param name="mapType">Flag that specifies the CPU's permissions for the reading and writing of a resource. For possible values, see <see cref="SlimDX2.Direct3D10.MapMode"/>.</param>
        /// <param name="mapFlags">Flag that specifies what the CPU should do when the GPU is busy (see <see cref="SlimDX2.Direct3D10.MapFlags"/>). This flag is optional.</param>
        /// <param name="dataRef">Pointer to the buffer resource data.</param>
        /// <returns>If this function succeeds, it returns S_OK. The following list contains some of the reasons that Map can fail: If MapFlags specifies D3D10_MAP_FLAG_DO_NOT_WAIT and the GPU is not yet finished with the resource, ID3D10Buffer::Map returns DXGI_ERROR_WAS_STILL_DRAWING.ID3D10Buffer::Map returns DXGI_ERROR_DEVICE_REMOVED if MapType includes any flags that permit reading and the hardware  device (that is, the video card) has been removed.For more information about the preceding return values, see <see cref="SlimDX2.DXGI.DXGIError"/>.</returns>
        /// <unmanaged>HRESULT Map([In] D3D10_MAP MapType,[In] UINT MapFlags,[Out] void** ppData)</unmanaged>
        public SlimDX2.Result Map(SlimDX2.Direct3D10.MapMode mapType, SlimDX2.Direct3D10.MapFlags mapFlags, out IntPtr dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* dataRef_ = &dataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 10 * 4, unchecked((int)mapType), unchecked((int)mapFlags), dataRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Invalidate the pointer to the resource retrieved by <see cref="SlimDX2.Direct3D10.Buffer.Map"/> and reenable GPU access to the resource.	
        /// </summary>	
        /// <remarks>	
        /// Differences between Direct3D 9 and Direct3D 10:Unmap() in Direct3D 10 is analogous to resource Unlock() in Direct3D 9.?	
        /// </remarks>	
        /// <unmanaged>void Unmap()</unmanaged>
        public void Unmap() {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 11 * 4);
            }
        }
        
        /// <summary>	
        /// Get the properties of a buffer resource.	
        /// </summary>	
        /// <param name="descRef">Pointer to a resource description (see <see cref="SlimDX2.Direct3D10.BufferDescription"/>) filled in by the method. This pointer cannot be NULL.</param>
        /// <unmanaged>void GetDesc([Out] D3D10_BUFFER_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D10.BufferDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D10.BufferDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 12 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A {{1D texture}} interface accesses texel data, which is structured memory.	
    /// </summary>	
    /// <unmanaged>ID3D10Texture1D</unmanaged>
    [Guid("9B7E4C03-342C-4106-A19F-4F2704F689F0")]
    public partial class Texture1D : SlimDX2.Direct3D10.Resource {
        public Texture1D(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the properties of the texture resource.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D10_TEXTURE1D_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.Texture1DDescription Description {
                get { SlimDX2.Direct3D10.Texture1DDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a pointer to the data contained in a subresource, and deny the GPU access to that subresource.	
        /// </summary>	
        /// <remarks>	
        /// Mapping a texture enables the CPU to directly access the underlying data in the subresource of a texture. For the method to succeed, the texture being mapped must be created with the appropriate flags (see <see cref="SlimDX2.Direct3D10.CpuAccessFlags"/>), and its specified usage (see <see cref="SlimDX2.Direct3D10.ResourceUsage"/>) must be either D3D10_USAGE_DYNAMIC or D3D10_USAGE_STAGING.Common failures of Map methods are indicated by the following return values:ItemDescriptionDXGI_ERROR_WAS_STILL_DRAWINGIf MapFlags specifies D3D10_MAP_FLAG_DO_NOT_WAIT and the GPU is not yet finished with the resource, Map returns DXGI_ERROR_WAS_STILL_DRAWING.DXGI_ERROR_DEVICE_REMOVEDMap returns DXGI_ERROR_DEVICE_REMOVED if MapType allows any CPU read access and the video card has been removed.?For more information about the preceding return values, see <see cref="SlimDX2.DXGI.DXGIError"/>.Map has the following restrictions:A single subresource cannot be mapped multiple times; in other words, do not call Map on a subresource that is already mapped.Any subresource that is bound to the pipeline must be unmapped before any render operation (that is, before <see cref="SlimDX2.Direct3D10.Device.Draw"/>) can be executed.Applications must cast the void pData pointer to the appropriate type to meaningfully access the underlying subresource data. For example, the following code demonstrates how to read each texel of a 1D subresource. It is assumed that the texture was created using <see cref="SlimDX2.DXGI.Format.R32G32B32A32_Float"/> and that pData is the pointer to the texture resource data output from a successful call to this method.	
        /// <code> FLOAT* pTexels = (FLOAT*)pData;	
        /// for( UINT col = 0; col &lt; width; col++ )	
        /// { pTexels[col*4 + 0]; // Alpha pTexels[col*4 + 1]; // Blue pTexels[col*4 + 2]; // Green pTexels[col*4 + 3]; // Red	
        /// } </code>	
        /// 	
        /// Differences between Direct3D 9 and Direct3D 10:Map in Direct3D 10 is analogous to resource {{Lock}} in Direct3D 9.?	
        /// </remarks>	
        /// <param name="subresource">Index number of the subresource. See {{D3D10CalcSubresource}} for more details.</param>
        /// <param name="mapType">Specifies the CPU's read and write permissions for a resource. For possible values, see <see cref="SlimDX2.Direct3D10.MapMode"/>.</param>
        /// <param name="mapFlags"> that specifies what the CPU should do when the GPU is busy. This flag is optional.</param>
        /// <param name="dataRef">Pointer to the texture resource data.</param>
        /// <returns>If this function succeeds, it returns S_OK. For other restrictions, and a listing of error values that can be returned by any of the Map methods, see Remarks.</returns>
        /// <unmanaged>HRESULT Map([In] UINT Subresource,[In] D3D10_MAP MapType,[In] UINT MapFlags,[Out] void** ppData)</unmanaged>
        public SlimDX2.Result Map(int subresource, SlimDX2.Direct3D10.MapMode mapType, SlimDX2.Direct3D10.MapFlags mapFlags, out IntPtr dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* dataRef_ = &dataRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 10 * 4, subresource, unchecked((int)mapType), unchecked((int)mapFlags), dataRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Invalidate the pointer to a resource that was retrieved by <see cref="SlimDX2.Direct3D10.Texture1D.Map"/>, and re-enable the GPU's access to that resource.	
        /// </summary>	
        /// <remarks>	
        /// A subresource must be mapped before Unmap is called.Differences between Direct3D 9 and Direct3D 10:Unmap in Direct3D 10 is analogous to resource Unlock in Direct3D 9.?	
        /// </remarks>	
        /// <param name="subresource"> to be unmapped. See {{D3D10CalcSubresource}} for more details.</param>
        /// <unmanaged>void Unmap([In] UINT Subresource)</unmanaged>
        public void Unmap(int subresource) {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 11 * 4, subresource);
            }
        }
        
        /// <summary>	
        /// Get the properties of the texture resource.	
        /// </summary>	
        /// <param name="descRef">Pointer to a resource description (see <see cref="SlimDX2.Direct3D10.Texture1DDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D10_TEXTURE1D_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D10.Texture1DDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D10.Texture1DDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 12 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A {{2D texture}} interface manages texel data, which is structured memory.	
    /// </summary>	
    /// <unmanaged>ID3D10Texture2D</unmanaged>
    [Guid("9B7E4C04-342C-4106-A19F-4F2704F689F0")]
    public partial class Texture2D : SlimDX2.Direct3D10.Resource {
        public Texture2D(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the properties of the texture resource.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D10_TEXTURE2D_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.Texture2DDescription Description {
                get { SlimDX2.Direct3D10.Texture2DDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a pointer to the data contained in a subresource, and deny GPU access to that subresource.	
        /// </summary>	
        /// <param name="subresource">Index number of the subresource. See {{D3D10CalcSubresource}} for more details.</param>
        /// <param name="mapType">Integer that specifies the CPU's read and write permissions for a resource. For possible values, see <see cref="SlimDX2.Direct3D10.MapMode"/>.</param>
        /// <param name="mapFlags"> that specifies what the CPU should do when the GPU is busy. This flag is optional.</param>
        /// <param name="mappedTex2DRef">Pointer to a structure (<see cref="SlimDX2.Direct3D10.MappedTexture2D"/>) that is filled in by the function and contains a pointer to the resource data.</param>
        /// <returns>If this function succeeds, it returns S_OK.All of the Map methods have identical return values and operating restrictions. These are listed in the remarks section of <see cref="SlimDX2.Direct3D10.Texture1D.Map"/>.</returns>
        /// <unmanaged>HRESULT Map([In] UINT Subresource,[In] D3D10_MAP MapType,[In] UINT MapFlags,[Out] D3D10_MAPPED_TEXTURE2D* pMappedTex2D)</unmanaged>
        public SlimDX2.Result Map(int subresource, SlimDX2.Direct3D10.MapMode mapType, SlimDX2.Direct3D10.MapFlags mapFlags, out SlimDX2.Direct3D10.MappedTexture2D mappedTex2DRef) {
            unsafe {
                mappedTex2DRef = new SlimDX2.Direct3D10.MappedTexture2D();
                SlimDX2.Result __result__;
                fixed (void* mappedTex2DRef_ = &mappedTex2DRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 10 * 4, subresource, unchecked((int)mapType), unchecked((int)mapFlags), mappedTex2DRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Invalidate the pointer to the resource that was retrieved by <see cref="SlimDX2.Direct3D10.Texture2D.Map"/>, and re-enable GPU access to the resource.	
        /// </summary>	
        /// <remarks>	
        /// A subresource must be mapped before Unmap is called.Differences between Direct3D 9 and Direct3D 10:Unmap in Direct3D 10 is analogous to resource Unlock in Direct3D 9.?	
        /// </remarks>	
        /// <param name="subresource"> to be unmapped. See {{D3D10CalcSubresource}} for more details.</param>
        /// <unmanaged>void Unmap([In] UINT Subresource)</unmanaged>
        public void Unmap(int subresource) {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 11 * 4, subresource);
            }
        }
        
        /// <summary>	
        /// Get the properties of the texture resource.	
        /// </summary>	
        /// <param name="descRef">Pointer to a resource description (see <see cref="SlimDX2.Direct3D10.Texture2DDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D10_TEXTURE2D_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D10.Texture2DDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D10.Texture2DDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 12 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A {{3D texture}} interface accesses texel data, which is structured memory.	
    /// </summary>	
    /// <unmanaged>ID3D10Texture3D</unmanaged>
    [Guid("9B7E4C05-342C-4106-A19F-4F2704F689F0")]
    public partial class Texture3D : SlimDX2.Direct3D10.Resource {
        public Texture3D(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the properties of the texture resource.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D10_TEXTURE3D_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.Texture3DDescription Description {
                get { SlimDX2.Direct3D10.Texture3DDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a pointer to the data contained in a subresource, and deny GPU access to that subresource.	
        /// </summary>	
        /// <param name="subresource">Index number of the subresource. See {{D3D10CalcSubresource}}for more details.</param>
        /// <param name="mapType">Specifies the CPU's read and write permissions for a resource. For possible values, see <see cref="SlimDX2.Direct3D10.MapMode"/>.</param>
        /// <param name="mapFlags"> that specifies what the CPU should do when the GPU is busy. This flag is optional.</param>
        /// <param name="mappedTex3DRef">Pointer to a structure (<see cref="SlimDX2.Direct3D10.MappedTexture3D"/>) that is filled in by the function and contains a pointer to the resource data.</param>
        /// <returns>If this function succeeds, it returns S_OK. All of the Map methods have identical return values and operating restrictions. These are listed in the remarks section of <see cref="SlimDX2.Direct3D10.Texture1D.Map"/>.</returns>
        /// <unmanaged>HRESULT Map([In] UINT Subresource,[In] D3D10_MAP MapType,[In] UINT MapFlags,[Out] D3D10_MAPPED_TEXTURE3D* pMappedTex3D)</unmanaged>
        public SlimDX2.Result Map(int subresource, SlimDX2.Direct3D10.MapMode mapType, SlimDX2.Direct3D10.MapFlags mapFlags, out SlimDX2.Direct3D10.MappedTexture3D mappedTex3DRef) {
            unsafe {
                mappedTex3DRef = new SlimDX2.Direct3D10.MappedTexture3D();
                SlimDX2.Result __result__;
                fixed (void* mappedTex3DRef_ = &mappedTex3DRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 10 * 4, subresource, unchecked((int)mapType), unchecked((int)mapFlags), mappedTex3DRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Invalidate the pointer to the resource retrieved by <see cref="SlimDX2.Direct3D10.Texture3D.Map"/>, and re-enable the GPU's access to the resource.	
        /// </summary>	
        /// <remarks>	
        /// A subresource must be mapped before Unmap is called.Differences between Direct3D 9 and Direct3D 10:Unmap() in Direct3D 10 is analogous to resource Unlock() in Direct3D 9.?	
        /// </remarks>	
        /// <param name="subresource"> to be unmapped. See {{D3D10CalcSubresource}} for more details.</param>
        /// <unmanaged>void Unmap([In] UINT Subresource)</unmanaged>
        public void Unmap(int subresource) {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 11 * 4, subresource);
            }
        }
        
        /// <summary>	
        /// Get the properties of the texture resource.	
        /// </summary>	
        /// <param name="descRef">Pointer to a resource description (see <see cref="SlimDX2.Direct3D10.Texture3DDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D10_TEXTURE3D_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D10.Texture3DDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D10.Texture3DDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 12 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A view interface specifies the parts of a resource the pipeline can access during rendering (see {{view}}).	
    /// </summary>	
    /// <unmanaged>ID3D10View</unmanaged>
    [Guid("C902B03F-60A7-49BA-9936-2A3AB37A7E33")]
    public partial class View : SlimDX2.Direct3D10.DeviceChild {
        public View(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the resource that is accessed through this view.	
        /// </summary>	
        /// <remarks>	
        /// This function increments the reference count of the resource by one, so it is necessary to call Release on the returned pointer when the application is done with it. Destroying (or losing) the returned pointer before Release is called will result in a memory leak.	
        /// </remarks>	
        /// <unmanaged>void GetResource([Out] ID3D10Resource** ppResource)</unmanaged>
        public SlimDX2.Direct3D10.Resource Resource {
                get { SlimDX2.Direct3D10.Resource __output__; GetResource(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the resource that is accessed through this view.	
        /// </summary>	
        /// <remarks>	
        /// This function increments the reference count of the resource by one, so it is necessary to call Release on the returned pointer when the application is done with it. Destroying (or losing) the returned pointer before Release is called will result in a memory leak.	
        /// </remarks>	
        /// <param name="resourceRef">Address of a pointer to the resource that is accessed through this view. (See <see cref="SlimDX2.Direct3D10.Resource"/>.)</param>
        /// <unmanaged>void GetResource([Out] ID3D10Resource** ppResource)</unmanaged>
        internal void GetResource(out SlimDX2.Direct3D10.Resource resourceRef) {
            unsafe {
                IntPtr resourceRef_ = IntPtr.Zero;
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 7 * 4, &resourceRef_);
                resourceRef = (resourceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Resource(resourceRef_);	
            }
        }
    }
    
    /// <summary>	
    /// A shader-resource-view interface specifies the {{subresources}} a shader can access during rendering. Examples of shader resources include a constant buffer, a texture buffer, a texture or a sampler.	
    /// </summary>	
    /// <unmanaged>ID3D10ShaderResourceView</unmanaged>
    [Guid("9B7E4C07-342C-4106-A19F-4F2704F689F0")]
    public partial class ShaderResourceView : SlimDX2.Direct3D10.View {
        public ShaderResourceView(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the shader resource view's description.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D10_SHADER_RESOURCE_VIEW_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.ShaderResourceViewDescription Description {
                get { SlimDX2.Direct3D10.ShaderResourceViewDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the shader resource view's description.	
        /// </summary>	
        /// <param name="descRef">A pointer to a <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription"/> structure to be filled with data about the shader resource view.</param>
        /// <unmanaged>void GetDesc([Out] D3D10_SHADER_RESOURCE_VIEW_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D10.ShaderResourceViewDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D10.ShaderResourceViewDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 8 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A render-target-view interface identifies the render-target {{subresources}} that can be accessed during rendering.	
    /// </summary>	
    /// <unmanaged>ID3D10RenderTargetView</unmanaged>
    [Guid("9B7E4C08-342C-4106-A19F-4F2704F689F0")]
    public partial class RenderTargetView : SlimDX2.Direct3D10.View {
        public RenderTargetView(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the properties of a render target view.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D10_RENDER_TARGET_VIEW_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.RenderTargetViewDescription Description {
                get { SlimDX2.Direct3D10.RenderTargetViewDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the properties of a render target view.	
        /// </summary>	
        /// <param name="descRef">Pointer to the description of a render target view (see <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D10_RENDER_TARGET_VIEW_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D10.RenderTargetViewDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D10.RenderTargetViewDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 8 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A {{depth-stencil-view}} interface accesses a texture resource during  {{depth-stencil testing}}.	
    /// </summary>	
    /// <unmanaged>ID3D10DepthStencilView</unmanaged>
    [Guid("9B7E4C09-342C-4106-A19F-4F2704F689F0")]
    public partial class DepthStencilView : SlimDX2.Direct3D10.View {
        public DepthStencilView(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the depth-stencil {{view}}.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D10_DEPTH_STENCIL_VIEW_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.DepthStencilViewDescription Description {
                get { SlimDX2.Direct3D10.DepthStencilViewDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the depth-stencil {{view}}.	
        /// </summary>	
        /// <param name="descRef">Pointer to a depth-stencil-view description (see <see cref="SlimDX2.Direct3D10.DepthStencilViewDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D10_DEPTH_STENCIL_VIEW_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D10.DepthStencilViewDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D10.DepthStencilViewDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 8 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A vertex-shader interface manages an executable program (a vertex shader) that controls the {{vertex-shader stage}}.	
    /// </summary>	
    /// <unmanaged>ID3D10VertexShader</unmanaged>
    [Guid("9B7E4C0A-342C-4106-A19F-4F2704F689F0")]
    public partial class VertexShader : SlimDX2.Direct3D10.DeviceChild {
        public VertexShader(IntPtr basePtr) : base(basePtr) {
        }
        
    }
    
    /// <summary>	
    /// A geometry-shader interface manages an executable program (a geometry shader) that controls the {{geometry-shader stage}}.	
    /// </summary>	
    /// <unmanaged>ID3D10GeometryShader</unmanaged>
    [Guid("6316BE88-54CD-4040-AB44-20461BC81F68")]
    public partial class GeometryShader : SlimDX2.Direct3D10.DeviceChild {
        public GeometryShader(IntPtr basePtr) : base(basePtr) {
        }
        
    }
    
    /// <summary>	
    /// A pixel-shader interface manages an executable program (a pixel shader) that controls the {{pixel-shader stage}}.	
    /// </summary>	
    /// <unmanaged>ID3D10PixelShader</unmanaged>
    [Guid("4968B601-9D00-4cde-8346-8E7F675819B6")]
    public partial class PixelShader : SlimDX2.Direct3D10.DeviceChild {
        public PixelShader(IntPtr basePtr) : base(basePtr) {
        }
        
    }
    
    /// <summary>	
    /// An input-layout interface accesses the input data for the {{input-assembler stage}}.	
    /// </summary>	
    /// <unmanaged>ID3D10InputLayout</unmanaged>
    [Guid("9B7E4C0B-342C-4106-A19F-4F2704F689F0")]
    public partial class InputLayout : SlimDX2.Direct3D10.DeviceChild {
        public InputLayout(IntPtr basePtr) : base(basePtr) {
        }
        
    }
    
    /// <summary>	
    /// A sampler-state interface accesses sampler state for a {{texture}}.	
    /// </summary>	
    /// <unmanaged>ID3D10SamplerState</unmanaged>
    [Guid("9B7E4C0C-342C-4106-A19F-4F2704F689F0")]
    public partial class SamplerState : SlimDX2.Direct3D10.DeviceChild {
        public SamplerState(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the sampler state.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D10_SAMPLER_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.SamplerStateDescription Description {
                get { SlimDX2.Direct3D10.SamplerStateDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the sampler state.	
        /// </summary>	
        /// <param name="descRef">A pointer to the sampler state (see <see cref="SlimDX2.Direct3D10.SamplerStateDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D10_SAMPLER_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D10.SamplerStateDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D10.SamplerStateDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 7 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// This interface encapsulates methods for retrieving data from the GPU asynchronously.	
    /// </summary>	
    /// <unmanaged>ID3D10Asynchronous</unmanaged>
    [Guid("9B7E4C0D-342C-4106-A19F-4F2704F689F0")]
    public partial class Asynchronous : SlimDX2.Direct3D10.DeviceChild {
        public Asynchronous(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the size of the data (in bytes) that is output when calling <see cref="SlimDX2.Direct3D10.Asynchronous.GetData"/>.	
        /// </summary>	
        /// <unmanaged>UINT GetDataSize()</unmanaged>
        public int DataSize {
                get { return GetDataSize(); }
        }
        
        /// <summary>	
        /// Starts the collection of GPU data.	
        /// </summary>	
        /// <remarks>	
        /// Calling Begin starts the asynchronous collection of GPU data. Calling <see cref="SlimDX2.Direct3D10.Asynchronous.End"/> causes data collection to stop.   See <see cref="SlimDX2.Direct3D10.Asynchronous"/> for additional information.	
        /// </remarks>	
        /// <unmanaged>void Begin()</unmanaged>
        public void Begin() {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 7 * 4);
            }
        }
        
        /// <summary>	
        /// Ends the collection of GPU data.	
        /// </summary>	
        /// <remarks>	
        /// Calling <see cref="SlimDX2.Direct3D10.Asynchronous.Begin"/> starts the asynchronous collection of GPU data. Calling ID3D10Asynchronous::End causes data  collection to stop. See <see cref="SlimDX2.Direct3D10.Asynchronous"/> for additional information.	
        /// </remarks>	
        /// <unmanaged>void End()</unmanaged>
        public void End() {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 8 * 4);
            }
        }
        
        /// <summary>	
        /// Get data from the GPU asynchronously.	
        /// </summary>	
        /// <remarks>	
        /// GetData retrieves the data collected between calls to <see cref="SlimDX2.Direct3D10.Asynchronous.Begin"/> and <see cref="SlimDX2.Direct3D10.Asynchronous.End"/>.  Certain queries only require a call to ID3D10Asynchronous::End in which case the data returned by GetData is accurate up to the last call to ID3D10Asynchronous::End (See <see cref="SlimDX2.Direct3D10.Query"/>).If DataSize is 0, GetData is only used to check status where a return value of S_OK indicates that data is available to give to an application, and a return value of S_FALSE indicates data is not yet available.It is invalid to invoke this function on a predicate created with the flag D3D10_QUERY_MISCFLAG_PREDICATEHINT.If the asynchronous interface that calls this function is <see cref="SlimDX2.Direct3D10.Query"/>, then the following table applies.Query TypeOutput Data TypeSupports Begin MethodEVENTBOOLNOOCCLUSIONUINT64YESTIMESTAMPUINT64NOTIMESTAMP_DISJOINTQUERYDATA_TIMESTAMP_DISJOINTYESPIPELINE_STATISTICSQUERYDATA_PIPELINE_STATISTICSYESOCCLUSION_PREDICATEBOOLYESSO_STATISTICSQUERYDATA_SO_STATISTICSYESSO_OVERFLOW_PREDICATEBOOLYES?If the asynchronous interface that calls this API is <see cref="SlimDX2.Direct3D10.Counter"/>, then the following applies.Counter TypeOutput Data TypeUnitsGPU_IDLEFLOAT32fraction of timeVERTEX_PROCESSINGFLOAT32fraction of timeGEOMETRY_PROCESSINGFLOAT32fraction of timePIXEL_PROCESSINGFLOAT32fraction of timeOTHER_GPU_PROCESSINGFLOAT32fraction of timeHOST_ADAPTER_BANDWIDTH_UTILIZATIONFLOAT32fraction of theoretical maximumLOCAL_VIDMEM_BANDWIDTH_UTILIZATIONFLOAT32fraction of theoretical maximumVERTEX_THROUGHPUT_UTILIZATIONFLOAT32fraction of theoretical maximumTRISETUP_THROUGHPUT_UTILIZATIONFLOAT32fraction of theoretical maximumFILLRATE_THROUGHPUT_UTILIZATIONFLOAT32fraction of theoretical maximumVERTEXSHADER_MEMORY_LIMITEDFLOAT32fraction of timeVERTEXSHADER_COMPUTATION_LIMITEDFLOAT32fraction of timeGEOMETRYSHADER_MEMORY_LIMITEDFLOAT32fraction of timeGEOMETRYSHADER_COMPUTATION_LIMITEDFLOAT32fraction of timePIXELSHADER_MEMORY_LIMITEDFLOAT32fraction of timePIXELSHADER_COMPUTATION_LIMITEDFLOAT32fraction of timePOST_TRANSFORM_CACHE_HIT_RATEFLOAT32fractionTEXTURE_CACHE_HIT_RATEFLOAT32fraction?The value returned by a GPU_IDLE, VERTEX_PROCESSING, GEOMETRY_PROCESSING, PIXEL_PROCESSING, or OTHER_GPU_PROCESSING counter may be different depending on the number of parallel counters that exist on a video card, and those values can be interpreted with the following equation:?Equation to interpret the number of parallel counters?The number of parallel counters that a video card has is available from NumDetectableParallelUnits in <see cref="SlimDX2.Direct3D10.CounterInformation"/>, and it can be retrieved by calling <see cref="SlimDX2.Direct3D10.Device.CheckCounterInfo"/>.	
        /// </remarks>	
        /// <param name="dataRef">Address of memory that will receive the data. If NULL, GetData will be used only to check status. The type of data output depends on the type of asynchronous interface. See Remarks.</param>
        /// <param name="dataSize">Size of the data to retrieve or 0. This value can be obtained with <see cref="SlimDX2.Direct3D10.Asynchronous.GetDataSize"/>. Must be 0 when pData is NULL.</param>
        /// <param name="getDataFlags">Optional flags. Can be 0 or any combination of the flags enumerated by <see cref="SlimDX2.Direct3D10.AsynchronousFlags"/>.</param>
        /// <returns>If this function succeeds, it returns S_OK. Otherwise, possible  return values are the following:S_FALSEDXGI_ERROR_DEVICE_REMOVEDDXGI_ERROR_INVALID_CALL</returns>
        /// <unmanaged>HRESULT GetData([Out, Buffer, Optional] void* pData,[In] UINT DataSize,[In] UINT GetDataFlags)</unmanaged>
        public SlimDX2.Result GetData(IntPtr dataRef, int dataSize, int getDataFlags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 9 * 4, (void*)dataRef, dataSize, getDataFlags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the size of the data (in bytes) that is output when calling <see cref="SlimDX2.Direct3D10.Asynchronous.GetData"/>.	
        /// </summary>	
        /// <returns>Size of the data (in bytes) that is output when calling GetData.</returns>
        /// <unmanaged>UINT GetDataSize()</unmanaged>
        internal int GetDataSize() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 10 * 4);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A query interface queries information from the GPU.	
    /// </summary>	
    /// <unmanaged>ID3D10Query</unmanaged>
    [Guid("9B7E4C0E-342C-4106-A19F-4F2704F689F0")]
    public partial class Query : SlimDX2.Direct3D10.Asynchronous {
        public Query(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get a query description.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D10_QUERY_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.QueryDescription Description {
                get { SlimDX2.Direct3D10.QueryDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a query description.	
        /// </summary>	
        /// <param name="descRef">Pointer to a query description (see <see cref="SlimDX2.Direct3D10.QueryDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D10_QUERY_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D10.QueryDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D10.QueryDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 11 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A predicate interface determines whether geometry should be processed depending on the results of a previous draw call.	
    /// </summary>	
    /// <unmanaged>ID3D10Predicate</unmanaged>
    [Guid("9B7E4C10-342C-4106-A19F-4F2704F689F0")]
    public partial class Predicate : SlimDX2.Direct3D10.Query {
        public Predicate(IntPtr basePtr) : base(basePtr) {
        }
        
    }
    
    /// <summary>	
    /// This interface encapsulates methods for measuring GPU performance.	
    /// </summary>	
    /// <unmanaged>ID3D10Counter</unmanaged>
    [Guid("9B7E4C11-342C-4106-A19F-4F2704F689F0")]
    public partial class Counter : SlimDX2.Direct3D10.Asynchronous {
        public Counter(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get a counter description.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D10_COUNTER_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.CounterDescription Description {
                get { SlimDX2.Direct3D10.CounterDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a counter description.	
        /// </summary>	
        /// <param name="descRef">Pointer to a counter description (see <see cref="SlimDX2.Direct3D10.CounterDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D10_COUNTER_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D10.CounterDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D10.CounterDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 11 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// The device interface represents a virtual adapter for Direct3D 10.0; it is used to perform rendering and create Direct3D resources.	
    /// </summary>	
    /// <unmanaged>ID3D10Device</unmanaged>
    [Guid("9B7E4C0F-342C-4106-A19F-4F2704F689F0")]
    public partial class Device : SlimDX2.ComObject {
        public Device(IntPtr basePtr) : base(basePtr) {
        }
        
				
        /// <summary>Update nested inner interfaces pointer</summary>
        protected override void NativePointerUpdated()
        {            
            InputAssembler = new SlimDX2.Direct3D10.Device.InputAssemblerStage(this.NativePointer);		
            VertexShader = new SlimDX2.Direct3D10.Device.VertexShaderStage(this.NativePointer);		
            PixelShader = new SlimDX2.Direct3D10.Device.PixelShaderStage(this.NativePointer);		
            GeometryShader = new SlimDX2.Direct3D10.Device.GeometryShaderStage(this.NativePointer);		
            StreamOutput = new SlimDX2.Direct3D10.Device.StreamOutputStage(this.NativePointer);		
            Rasterizer = new SlimDX2.Direct3D10.Device.RasterizerStage(this.NativePointer);		
            OutputMerger = new SlimDX2.Direct3D10.Device.OutputMergerStage(this.NativePointer);		
        }
      
		/// <summary>Inner interface giving access to InputAssemblerStage methods. </summary>
        public InputAssemblerStage InputAssembler { get; private set; }		
        
        /// <summary>Inner interface InputAssemblerStage.</summary>
        /// <unmanaged>ID3D10Device</unmanaged>
        [Guid("9B7E4C0F-342C-4106-A19F-4F2704F689F0")]
        public partial class InputAssemblerStage : SlimDX2.CppObject {
            public InputAssemblerStage(IntPtr basePtr) : base(basePtr) {
            }
            
            
            /// <summary>	
            /// Get a pointer to the input-layout object that is bound to the {{input-assembler stage}}.	
            /// </summary>	
            /// <remarks>	
            /// For information about creating an input-layout object, see {{Creating the Input-Layout Object}}.Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <unmanaged>void IAGetInputLayout([Out] ID3D10InputLayout** ppInputLayout)</unmanaged>
            public SlimDX2.Direct3D10.InputLayout InputLayout {
                    get { SlimDX2.Direct3D10.InputLayout __output__; GetInputLayout(out __output__); return __output__; }
                    set { SetInputLayout(value); }
            }
            
            /// <summary>	
            /// Get information about the {{primitive type}}, and data order that describes input data for the {{input assembler}} stage.	
            /// </summary>	
            /// <unmanaged>void IAGetPrimitiveTopology([Out] D3D10_PRIMITIVE_TOPOLOGY* pTopology)</unmanaged>
            public SlimDX2.Direct3D.PrimitiveTopology PrimitiveTopology {
                    get { SlimDX2.Direct3D.PrimitiveTopology __output__; GetPrimitiveTopology(out __output__); return __output__; }
                    set { SetPrimitiveTopology(value); }
            }
            
            /// <summary>	
            /// Bind an input-layout object to the {{input-assembler stage}}.	
            /// </summary>	
            /// <remarks>	
            /// Input-layout objects describe how vertex buffer data is streamed into the IA pipeline stage. To create an input-layout object, call <see cref="SlimDX2.Direct3D10.Device.CreateInputLayout"/>.The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.	
            /// </remarks>	
            /// <param name="inputLayoutRef">A pointer to the input-layout object (see <see cref="SlimDX2.Direct3D10.InputLayout"/>), which describes the input buffers that will be read by the IA stage.</param>
            /// <unmanaged>void IASetInputLayout([In, Optional] ID3D10InputLayout* pInputLayout)</unmanaged>
            internal void SetInputLayout(SlimDX2.Direct3D10.InputLayout inputLayoutRef) {
                unsafe {
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 11 * 4, (void*)((inputLayoutRef == null)?IntPtr.Zero:inputLayoutRef.NativePointer));
                }
            }
            
            /// <summary>	
            /// Bind an array of {{vertex buffers}} to the {{input-assembler}} stage.	
            /// </summary>	
            /// <remarks>	
            /// For information about creating vertex buffers, see {{Create a Vertex Buffer}}.Calling this method using a buffer that is currently bound for writing (i.e. bound to the {{stream output}} pipeline stage) will effectively bind NULL instead because a buffer cannot be bound as both an input and an output at the same time.The {{Debug Layer}} will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will not prevent invalid data from being used by the runtime.The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.	
            /// </remarks>	
            /// <param name="startSlot">The first {{input slot}} for binding. The first vertex buffer is explicitly bound to the start slot; this causes each additional vertex buffer in the array to be implicitly bound to each subsequent input slot. There are 16 input slots.</param>
            /// <param name="numBuffers">The number of vertex buffers in the array. The number of buffers (plus the starting slot) cannot exceed the total number of IA-stage input slots.</param>
            /// <param name="vertexBuffersRef">A pointer to an array of vertex buffers (see <see cref="SlimDX2.Direct3D10.Buffer"/>). The vertex buffers must have been created with the <see cref="SlimDX2.Direct3D10.BindFlags.VertexBuffer"/> flag.</param>
            /// <param name="stridesRef">Pointer to an array of stride values; one stride value for each buffer in the vertex-buffer array. Each stride is the size (in bytes) of the elements that are to be used from that vertex buffer.</param>
            /// <param name="offsetsRef">Pointer to an array of offset values; one offset value for each buffer in the vertex-buffer array. Each offset is the number of bytes between the first element of a vertex buffer and the first element that will be used.</param>
            /// <unmanaged>void IASetVertexBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[In, Buffer] const ID3D10Buffer** ppVertexBuffers,[In, Buffer] const UINT* pStrides,[In, Buffer] const UINT* pOffsets)</unmanaged>
            internal void SetVertexBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D10.Buffer[] vertexBuffersRef, int[] stridesRef, int[] offsetsRef) {
                unsafe {
                    IntPtr* vertexBuffersRef_ = (IntPtr*)0;
                    if ( vertexBuffersRef != null ) {
                        IntPtr* vertexBuffersRef__ = stackalloc IntPtr[vertexBuffersRef.Length];
                        vertexBuffersRef_ = vertexBuffersRef__;
                        for (int i = 0; i < vertexBuffersRef.Length; i++)                        
                            vertexBuffersRef_[i] =  vertexBuffersRef[i].NativePointer;
                    }
                    fixed (void* stridesRef_ = &stridesRef[0])
                        fixed (void* offsetsRef_ = &offsetsRef[0])
                            SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 12 * 4, startSlot, numBuffers, vertexBuffersRef_, stridesRef_, offsetsRef_);
                }
            }
            
            /// <summary>	
            /// Bind an {{index buffer}} to the {{input-assembler}} stage.	
            /// </summary>	
            /// <remarks>	
            /// For information about creating index buffers, see {{Create an Index Buffer}}.Calling this method using a buffer that is currently bound for writing (i.e. bound to the {{stream output}} pipeline stage) will effectively bind NULL instead because a buffer cannot be bound as both an input and an output at the same time.The {{Debug Layer}} will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will not prevent invalid data from being used by the runtime.The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.	
            /// </remarks>	
            /// <param name="indexBufferRef">A pointer to a buffer (see <see cref="SlimDX2.Direct3D10.Buffer"/>) that contains indices. The index buffer must have been created with the <see cref="SlimDX2.Direct3D10.BindFlags.IndexBuffer"/> flag.</param>
            /// <param name="format">Specifies format of the data in the index buffer. The only formats allowed for index buffer data are 16-bit (<see cref="SlimDX2.DXGI.Format.R16_UInt"/>) and 32-bit (DXGI_FORMAT_R32_UINT) integers.</param>
            /// <param name="offset">Offset (in bytes) from the start of the index buffer to the first index to use.</param>
            /// <unmanaged>void IASetIndexBuffer([In, Optional] ID3D10Buffer* pIndexBuffer,[In] DXGI_FORMAT Format,[In] UINT Offset)</unmanaged>
            public void SetIndexBuffer(SlimDX2.Direct3D10.Buffer indexBufferRef, SlimDX2.DXGI.Format format, int offset) {
                unsafe {
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 13 * 4, (void*)((indexBufferRef == null)?IntPtr.Zero:indexBufferRef.NativePointer), unchecked((int)format), offset);
                }
            }
            
            /// <summary>	
            /// Bind information about the {{primitive type}}, and data order that describes input data for the {{input assembler}} stage.	
            /// </summary>	
            /// <param name="topology">The type of primitive and ordering of the primitive data (see <see cref="SlimDX2.Direct3D.PrimitiveTopology"/>).</param>
            /// <unmanaged>void IASetPrimitiveTopology([In] D3D10_PRIMITIVE_TOPOLOGY Topology)</unmanaged>
            internal void SetPrimitiveTopology(SlimDX2.Direct3D.PrimitiveTopology topology) {
                unsafe {
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 18 * 4, unchecked((int)topology));
                }
            }
            
            /// <summary>	
            /// Get a pointer to the input-layout object that is bound to the {{input-assembler stage}}.	
            /// </summary>	
            /// <remarks>	
            /// For information about creating an input-layout object, see {{Creating the Input-Layout Object}}.Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="inputLayoutRef">A pointer to the input-layout object (see <see cref="SlimDX2.Direct3D10.InputLayout"/>), which describes the input buffers that will be read by the IA stage.</param>
            /// <unmanaged>void IAGetInputLayout([Out] ID3D10InputLayout** ppInputLayout)</unmanaged>
            internal void GetInputLayout(out SlimDX2.Direct3D10.InputLayout inputLayoutRef) {
                unsafe {
                    IntPtr inputLayoutRef_ = IntPtr.Zero;
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 45 * 4, &inputLayoutRef_);
                    inputLayoutRef = (inputLayoutRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.InputLayout(inputLayoutRef_);	
                }
            }
            
            /// <summary>	
            /// Get the {{vertex buffers}} bound to the {{input-assembler}} stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">The {{input slot}} of the first vertex buffer to get. The first vertex buffer is explicitly bound to the start slot; this causes each additional vertex buffer in the array to be implicitly bound to each subsequent input slot. There are 16 input slots.</param>
            /// <param name="numBuffers">The number of vertex buffers to get starting at the offset. The number of buffers (plus the starting slot) cannot exceed the total number of IA-stage input slots.</param>
            /// <param name="vertexBuffersRef">A pointer to an array of vertex buffers returned by the method (see <see cref="SlimDX2.Direct3D10.Buffer"/>).</param>
            /// <param name="stridesRef">Pointer to an array of stride values returned by the method; one stride value for each buffer in the vertex-buffer array. Each stride value is the size (in bytes) of the elements that are to be used from that vertex buffer.</param>
            /// <param name="offsetsRef">Pointer to an array of offset values returned by the method; one offset value for each buffer in the vertex-buffer array. Each offset is the number of bytes between the first element of a vertex buffer and the first element that will be used.</param>
            /// <unmanaged>void IAGetVertexBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[Out, Buffer, Optional] ID3D10Buffer** ppVertexBuffers,[Out, Buffer, Optional] UINT* pStrides,[Out, Buffer, Optional] UINT* pOffsets)</unmanaged>
            public void GetVertexBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D10.Buffer[] vertexBuffersRef, int[] stridesRef, int[] offsetsRef) {
                unsafe {
                    IntPtr* vertexBuffersRef_ = stackalloc IntPtr[vertexBuffersRef.Length];
                    int[] stridesRef__ = stridesRef ?? new int[1];
                    int[] offsetsRef__ = offsetsRef ?? new int[1];
                    fixed (void* stridesRef_ = &stridesRef__[0])
                        fixed (void* offsetsRef_ = &offsetsRef__[0])
                            SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 46 * 4, startSlot, numBuffers, &vertexBuffersRef_, stridesRef==null?(void*)IntPtr.Zero:stridesRef_, offsetsRef==null?(void*)IntPtr.Zero:offsetsRef_);
                    for (int i = 0; i < vertexBuffersRef.Length; i++)
                        vertexBuffersRef[i] = (vertexBuffersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Buffer(vertexBuffersRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get a pointer to the {{index buffer}} that is bound to the {{input-assembler}} stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="indexBufferRef">A pointer to an index buffer returned by the method (see <see cref="SlimDX2.Direct3D10.Buffer"/>).</param>
            /// <param name="format">Specifies format of the data in the index buffer (see <see cref="SlimDX2.DXGI.Format"/>). These formats provide the size and type of the data in the buffer. The only formats allowed for index buffer data are 16-bit (DXGI_FORMAT_R16_UINT) and 32-bit (DXGI_FORMAT_R32_UINT) integers.</param>
            /// <param name="offset">Offset (in bytes) from the start of the index buffer, to the first index to use.</param>
            /// <unmanaged>void IAGetIndexBuffer([Out, Optional] ID3D10Buffer** pIndexBuffer,[Out, Optional] DXGI_FORMAT* Format,[Out, Optional] UINT* Offset)</unmanaged>
            public void GetIndexBuffer(out SlimDX2.Direct3D10.Buffer indexBufferRef, out SlimDX2.DXGI.Format format, out int offset) {
                unsafe {
                    IntPtr indexBufferRef_ = IntPtr.Zero;
                    fixed (void* format_ = &format)
                        fixed (void* offset_ = &offset)
                            SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 47 * 4, &indexBufferRef_, format_, offset_);
                    indexBufferRef = (indexBufferRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Buffer(indexBufferRef_);	
                }
            }
            
            /// <summary>	
            /// Get information about the {{primitive type}}, and data order that describes input data for the {{input assembler}} stage.	
            /// </summary>	
            /// <param name="topologyRef">A pointer to the type of primitive, and ordering of the primitive data (see <see cref="SlimDX2.Direct3D.PrimitiveTopology"/>).</param>
            /// <unmanaged>void IAGetPrimitiveTopology([Out] D3D10_PRIMITIVE_TOPOLOGY* pTopology)</unmanaged>
            internal void GetPrimitiveTopology(out SlimDX2.Direct3D.PrimitiveTopology topologyRef) {
                unsafe {
                    fixed (void* topologyRef_ = &topologyRef)
                        SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 50 * 4, topologyRef_);
                }
            }
        }
      
		/// <summary>Inner interface giving access to VertexShaderStage methods. </summary>
        public VertexShaderStage VertexShader { get; private set; }		
        
        /// <summary>Inner interface VertexShaderStage.</summary>
        /// <unmanaged>ID3D10Device</unmanaged>
        [Guid("9B7E4C0F-342C-4106-A19F-4F2704F689F0")]
        public partial class VertexShaderStage : CommonShaderStage<VertexShader> {
            public VertexShaderStage(IntPtr basePtr) : base(basePtr) {
            }
            
            
            /// <summary>	
            /// Set the {{constant buffers}} used by the {{vertex shader}} pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting constant buffers to.</param>
            /// <param name="numBuffers">Number of buffers to set.</param>
            /// <param name="constantBuffersRef">Array of constant buffers (see <see cref="SlimDX2.Direct3D10.Buffer"/>) being given to the device.</param>
            /// <unmanaged>void VSSetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[In, Buffer] const ID3D10Buffer** ppConstantBuffers)</unmanaged>
            public  override void SetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D10.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = (IntPtr*)0;
                    if ( constantBuffersRef != null ) {
                        IntPtr* constantBuffersRef__ = stackalloc IntPtr[constantBuffersRef.Length];
                        constantBuffersRef_ = constantBuffersRef__;
                        for (int i = 0; i < constantBuffersRef.Length; i++)                        
                            constantBuffersRef_[i] =  constantBuffersRef[i].NativePointer;
                    }
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 3 * 4, startSlot, numBuffers, constantBuffersRef_);
                }
            }
            
            /// <summary>	
            /// Set a vertex shader to the device.	
            /// </summary>	
            /// <remarks>	
            /// The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.	
            /// </remarks>	
            /// <param name="vertexShaderRef">Pointer to a vertex shader (see <see cref="SlimDX2.Direct3D10.VertexShader"/>). Passing in NULL disables the shader for this pipeline stage.</param>
            /// <unmanaged>void VSSetShader([In, Optional] ID3D10VertexShader* pVertexShader)</unmanaged>
            public void Set(SlimDX2.Direct3D10.VertexShader vertexShaderRef) {
                unsafe {
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 7 * 4, (void*)((vertexShaderRef == null)?IntPtr.Zero:vertexShaderRef.NativePointer));
                }
            }
            
            /// <summary>	
            /// Bind an array of shader resources to the {{vertex shader stage}}.	
            /// </summary>	
            /// <remarks>	
            /// If you bind a subresource as an input and an output, this API will fill the destination shader resource slot with NULL. The debug layer (when active) will alert you if this is true.For information about creating shader-resource views, see <see cref="SlimDX2.Direct3D10.Device.CreateShaderResourceView"/>.The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting shader resources to.</param>
            /// <param name="numViews">Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources.</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to set to the device.</param>
            /// <unmanaged>void VSSetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[In, Buffer] const ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>
            public  override void SetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D10.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = (IntPtr*)0;
                    if ( shaderResourceViewsRef != null ) {
                        IntPtr* shaderResourceViewsRef__ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                        shaderResourceViewsRef_ = shaderResourceViewsRef__;
                        for (int i = 0; i < shaderResourceViewsRef.Length; i++)                        
                            shaderResourceViewsRef_[i] =  shaderResourceViewsRef[i].NativePointer;
                    }
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 19 * 4, startSlot, numViews, shaderResourceViewsRef_);
                }
            }
            
            /// <summary>	
            /// Set an array of sampler states to the {{vertex shader}} pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// Any sampler may be set to NULL; this invokes the default state, which is defined to be the following.	
            /// <code> //Default sampler state:	
            /// D3D10_SAMPLER_DESC SamplerDesc;	
            /// SamplerDesc.Filter = D3D10_FILTER_MIN_MAG_MIP_LINEAR;	
            /// SamplerDesc.AddressU = D3D10_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.AddressV = D3D10_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.AddressW = D3D10_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.MipLODBias = 0;	
            /// SamplerDesc.MaxAnisotropy = 1;	
            /// SamplerDesc.ComparisonFunc = D3D10_COMPARISON_NEVER;	
            /// SamplerDesc.BorderColor[0] = 1.0f;	
            /// SamplerDesc.BorderColor[1] = 1.0f;	
            /// SamplerDesc.BorderColor[2] = 1.0f;	
            /// SamplerDesc.BorderColor[3] = 1.0f;	
            /// SamplerDesc.MinLOD = -FLT_MAX;	
            /// SamplerDesc.MaxLOD = FLT_MAX; </code>	
            /// 	
            /// The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting samplers to.</param>
            /// <param name="numSamplers">Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available.</param>
            /// <param name="samplersRef">Pointer to an array of sampler-state interfaces (see <see cref="SlimDX2.Direct3D10.SamplerState"/>). See Remarks.</param>
            /// <unmanaged>void VSSetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[In, Buffer] const ID3D10SamplerState** ppSamplers)</unmanaged>
            public  override void SetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D10.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = (IntPtr*)0;
                    if ( samplersRef != null ) {
                        IntPtr* samplersRef__ = stackalloc IntPtr[samplersRef.Length];
                        samplersRef_ = samplersRef__;
                        for (int i = 0; i < samplersRef.Length; i++)                        
                            samplersRef_[i] =  samplersRef[i].NativePointer;
                    }
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 20 * 4, startSlot, numSamplers, samplersRef_);
                }
            }
            
            /// <summary>	
            /// Get the {{constant buffers}} used by the {{vertex shader}} pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin retrieving constant buffers from.</param>
            /// <param name="numBuffers">Number of buffers to retrieve.</param>
            /// <param name="constantBuffersRef">Array of constant buffer interface pointers (see <see cref="SlimDX2.Direct3D10.Buffer"/>) to be returned by the method.</param>
            /// <unmanaged>void VSGetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[Out, Buffer] ID3D10Buffer** ppConstantBuffers)</unmanaged>
            internal  override void GetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D10.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = stackalloc IntPtr[constantBuffersRef.Length];
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 39 * 4, startSlot, numBuffers, &constantBuffersRef_);
                    for (int i = 0; i < constantBuffersRef.Length; i++)
                        constantBuffersRef[i] = (constantBuffersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Buffer(constantBuffersRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get the vertex shader currently set on the device.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="vertexShaderRef">Address of a pointer to a vertex shader (see <see cref="SlimDX2.Direct3D10.VertexShader"/>) to be returned by the method.</param>
            /// <unmanaged>void VSGetShader([Out] ID3D10VertexShader** ppVertexShader)</unmanaged>
            public void Get(out SlimDX2.Direct3D10.VertexShader vertexShaderRef) {
                unsafe {
                    IntPtr vertexShaderRef_ = IntPtr.Zero;
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 43 * 4, &vertexShaderRef_);
                    vertexShaderRef = (vertexShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.VertexShader(vertexShaderRef_);	
                }
            }
            
            /// <summary>	
            /// Get the vertex shader resources.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin getting shader resources from.</param>
            /// <param name="numViews">The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources.</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to be returned by the device.</param>
            /// <unmanaged>void VSGetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[Out, Buffer] ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>
            internal  override void GetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D10.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 51 * 4, startSlot, numViews, &shaderResourceViewsRef_);
                    for (int i = 0; i < shaderResourceViewsRef.Length; i++)
                        shaderResourceViewsRef[i] = (shaderResourceViewsRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D10.ShaderResourceView(shaderResourceViewsRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get an array of sampler states from the {{vertex shader}} pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin getting samplers from.</param>
            /// <param name="numSamplers">Number of samplers to get from the device. Each pipeline stage has a total of 16 sampler slots available.</param>
            /// <param name="samplersRef">Arry of sampler-state interface pointers (see <see cref="SlimDX2.Direct3D10.SamplerState"/>) to be returned by the device.</param>
            /// <unmanaged>void VSGetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[Out, Buffer] ID3D10SamplerState** ppSamplers)</unmanaged>
            internal  override void GetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D10.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = stackalloc IntPtr[samplersRef.Length];
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 52 * 4, startSlot, numSamplers, &samplersRef_);
                    for (int i = 0; i < samplersRef.Length; i++)
                        samplersRef[i] = (samplersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D10.SamplerState(samplersRef_[i]);	
                }
            }
        }
      
		/// <summary>Inner interface giving access to PixelShaderStage methods. </summary>
        public PixelShaderStage PixelShader { get; private set; }		
        
        /// <summary>Inner interface PixelShaderStage.</summary>
        /// <unmanaged>ID3D10Device</unmanaged>
        [Guid("9B7E4C0F-342C-4106-A19F-4F2704F689F0")]
        public partial class PixelShaderStage : CommonShaderStage<PixelShader> {
            public PixelShaderStage(IntPtr basePtr) : base(basePtr) {
            }
            
            
            /// <summary>	
            /// Bind an array of shader resources to the {{pixel shader stage}}.	
            /// </summary>	
            /// <remarks>	
            /// If you bind a subresource as an input and an output, this API will fill the destination shader resource slot with NULL. The debug layer (when active) will alert you if this is true.For information about creating shader-resource views, see <see cref="SlimDX2.Direct3D10.Device.CreateShaderResourceView"/>.The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting shader resources to.</param>
            /// <param name="numViews">Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources.</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to set to the device.</param>
            /// <unmanaged>void PSSetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[In, Buffer] const ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>
            public  override void SetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D10.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = (IntPtr*)0;
                    if ( shaderResourceViewsRef != null ) {
                        IntPtr* shaderResourceViewsRef__ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                        shaderResourceViewsRef_ = shaderResourceViewsRef__;
                        for (int i = 0; i < shaderResourceViewsRef.Length; i++)                        
                            shaderResourceViewsRef_[i] =  shaderResourceViewsRef[i].NativePointer;
                    }
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 4 * 4, startSlot, numViews, shaderResourceViewsRef_);
                }
            }
            
            /// <summary>	
            /// Sets a pixel shader to the device.	
            /// </summary>	
            /// <remarks>	
            /// The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.	
            /// </remarks>	
            /// <param name="pixelShaderRef">Pointer to a pixel shader (see <see cref="SlimDX2.Direct3D10.PixelShader"/>). Passing in NULL disables the shader for this pipeline stage.</param>
            /// <unmanaged>void PSSetShader([In, Optional] ID3D10PixelShader* pPixelShader)</unmanaged>
            public void Set(SlimDX2.Direct3D10.PixelShader pixelShaderRef) {
                unsafe {
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 5 * 4, (void*)((pixelShaderRef == null)?IntPtr.Zero:pixelShaderRef.NativePointer));
                }
            }
            
            /// <summary>	
            /// Set an array of sampler states to the {{pixel shader}} pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// Any sampler may be set to NULL; this invokes the default state, which is defined to be the following.StateDefault ValueFilterD3D10_FILTER_MIN_MAG_MIP_LINEARAddressUD3D10_TEXTURE_ADDRESS_CLAMPAddressVD3D10_TEXTURE_ADDRESS_CLAMPAddressWD3D10_TEXTURE_ADDRESS_CLAMPMipLODBias0MaxAnisotropy1ComparisonFuncD3D10_COMPARISON_NEVERBorderColor[0]1.0fBorderColor[1]1.0fBorderColor[2]1.0fBorderColor[3]1.0fMinLOD-FLT_MAXMaxLODFLT_MAX?The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting samplers to.</param>
            /// <param name="numSamplers">Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available.</param>
            /// <param name="samplersRef">Pointer to an array of sampler-state interfaces (see <see cref="SlimDX2.Direct3D10.SamplerState"/>). See Remarks.</param>
            /// <unmanaged>void PSSetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[In, Buffer] const ID3D10SamplerState** ppSamplers)</unmanaged>
            public  override void SetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D10.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = (IntPtr*)0;
                    if ( samplersRef != null ) {
                        IntPtr* samplersRef__ = stackalloc IntPtr[samplersRef.Length];
                        samplersRef_ = samplersRef__;
                        for (int i = 0; i < samplersRef.Length; i++)                        
                            samplersRef_[i] =  samplersRef[i].NativePointer;
                    }
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 6 * 4, startSlot, numSamplers, samplersRef_);
                }
            }
            
            /// <summary>	
            /// Set the {{constant buffers}} used by the {{pixel shader}} pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting constant buffers to.</param>
            /// <param name="numBuffers">Number of buffers to set.</param>
            /// <param name="constantBuffersRef">Array of constant buffers (see <see cref="SlimDX2.Direct3D10.Buffer"/>) being given to the device.</param>
            /// <unmanaged>void PSSetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[In, Buffer] const ID3D10Buffer** ppConstantBuffers)</unmanaged>
            public  override void SetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D10.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = (IntPtr*)0;
                    if ( constantBuffersRef != null ) {
                        IntPtr* constantBuffersRef__ = stackalloc IntPtr[constantBuffersRef.Length];
                        constantBuffersRef_ = constantBuffersRef__;
                        for (int i = 0; i < constantBuffersRef.Length; i++)                        
                            constantBuffersRef_[i] =  constantBuffersRef[i].NativePointer;
                    }
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 10 * 4, startSlot, numBuffers, constantBuffersRef_);
                }
            }
            
            /// <summary>	
            /// Get the pixel shader resources.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin getting shader resources from.</param>
            /// <param name="numViews">The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources.</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to be returned by the device.</param>
            /// <unmanaged>void PSGetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[Out, Buffer] ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>
            internal  override void GetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D10.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 40 * 4, startSlot, numViews, &shaderResourceViewsRef_);
                    for (int i = 0; i < shaderResourceViewsRef.Length; i++)
                        shaderResourceViewsRef[i] = (shaderResourceViewsRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D10.ShaderResourceView(shaderResourceViewsRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get the pixel shader currently set on the device.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="pixelShaderRef">Address of a pointer to a pixel shader (see <see cref="SlimDX2.Direct3D10.PixelShader"/>) to be returned by the method.</param>
            /// <unmanaged>void PSGetShader([Out] ID3D10PixelShader** ppPixelShader)</unmanaged>
            public void Get(out SlimDX2.Direct3D10.PixelShader pixelShaderRef) {
                unsafe {
                    IntPtr pixelShaderRef_ = IntPtr.Zero;
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 41 * 4, &pixelShaderRef_);
                    pixelShaderRef = (pixelShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.PixelShader(pixelShaderRef_);	
                }
            }
            
            /// <summary>	
            /// Get an array of sampler states from the {{pixel shader}} pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin getting samplers from.</param>
            /// <param name="numSamplers">Number of samplers to get from the device. Each pipeline stage has a total of 16 sampler slots available.</param>
            /// <param name="samplersRef">Arry of sampler-state interface pointers (see <see cref="SlimDX2.Direct3D10.SamplerState"/>) to be returned by the device.</param>
            /// <unmanaged>void PSGetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[Out, Buffer] ID3D10SamplerState** ppSamplers)</unmanaged>
            internal  override void GetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D10.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = stackalloc IntPtr[samplersRef.Length];
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 42 * 4, startSlot, numSamplers, &samplersRef_);
                    for (int i = 0; i < samplersRef.Length; i++)
                        samplersRef[i] = (samplersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D10.SamplerState(samplersRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get the {{constant buffers}} used by the {{pixel shader}} pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin retrieving constant buffers from.</param>
            /// <param name="numBuffers">Number of buffers to retrieve.</param>
            /// <param name="constantBuffersRef">Array of constant buffer interface pointers (see <see cref="SlimDX2.Direct3D10.Buffer"/>) to be returned by the method.</param>
            /// <unmanaged>void PSGetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[Out, Buffer] ID3D10Buffer** ppConstantBuffers)</unmanaged>
            internal  override void GetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D10.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = stackalloc IntPtr[constantBuffersRef.Length];
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 44 * 4, startSlot, numBuffers, &constantBuffersRef_);
                    for (int i = 0; i < constantBuffersRef.Length; i++)
                        constantBuffersRef[i] = (constantBuffersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Buffer(constantBuffersRef_[i]);	
                }
            }
        }
      
		/// <summary>Inner interface giving access to GeometryShaderStage methods. </summary>
        public GeometryShaderStage GeometryShader { get; private set; }		
        
        /// <summary>Inner interface GeometryShaderStage.</summary>
        /// <unmanaged>ID3D10Device</unmanaged>
        [Guid("9B7E4C0F-342C-4106-A19F-4F2704F689F0")]
        public partial class GeometryShaderStage : CommonShaderStage<GeometryShader> {
            public GeometryShaderStage(IntPtr basePtr) : base(basePtr) {
            }
            
            
            /// <summary>	
            /// Set the {{constant buffers}} used by the {{geometry shader}} pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// The method will not hold references to the interfaces passed in. For that reason, applications should be careful not to release interfaces currently in use by the device.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting constant buffers to.</param>
            /// <param name="numBuffers">Number of buffers to set.</param>
            /// <param name="constantBuffersRef">Array of constant buffers (see <see cref="SlimDX2.Direct3D10.Buffer"/>) being given to the device.</param>
            /// <unmanaged>void GSSetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[In, Buffer] const ID3D10Buffer** ppConstantBuffers)</unmanaged>
            public  override void SetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D10.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = (IntPtr*)0;
                    if ( constantBuffersRef != null ) {
                        IntPtr* constantBuffersRef__ = stackalloc IntPtr[constantBuffersRef.Length];
                        constantBuffersRef_ = constantBuffersRef__;
                        for (int i = 0; i < constantBuffersRef.Length; i++)                        
                            constantBuffersRef_[i] =  constantBuffersRef[i].NativePointer;
                    }
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 16 * 4, startSlot, numBuffers, constantBuffersRef_);
                }
            }
            
            /// <summary>	
            /// Set a geometry shader to the device.	
            /// </summary>	
            /// <remarks>	
            /// The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.	
            /// </remarks>	
            /// <param name="shaderRef">Pointer to a geometry shader (see <see cref="SlimDX2.Direct3D10.GeometryShader"/>). Passing in NULL disables the shader for this pipeline stage.</param>
            /// <unmanaged>void GSSetShader([In, Optional] ID3D10GeometryShader* pShader)</unmanaged>
            public void Set(SlimDX2.Direct3D10.GeometryShader shaderRef) {
                unsafe {
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 17 * 4, (void*)((shaderRef == null)?IntPtr.Zero:shaderRef.NativePointer));
                }
            }
            
            /// <summary>	
            /// Bind an array of shader resources to the {{geometry shader stage}}.	
            /// </summary>	
            /// <remarks>	
            /// If you bind a subresource as an input and an output, this API will fill the destination shader resource slot with NULL. The debug layer (when active) will alert you if this is true.For information about creating shader-resource views, see <see cref="SlimDX2.Direct3D10.Device.CreateShaderResourceView"/>.The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting shader resources to.</param>
            /// <param name="numViews">Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources.</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to set to the device.</param>
            /// <unmanaged>void GSSetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[In, Buffer] const ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>
            public  override void SetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D10.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = (IntPtr*)0;
                    if ( shaderResourceViewsRef != null ) {
                        IntPtr* shaderResourceViewsRef__ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                        shaderResourceViewsRef_ = shaderResourceViewsRef__;
                        for (int i = 0; i < shaderResourceViewsRef.Length; i++)                        
                            shaderResourceViewsRef_[i] =  shaderResourceViewsRef[i].NativePointer;
                    }
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 22 * 4, startSlot, numViews, shaderResourceViewsRef_);
                }
            }
            
            /// <summary>	
            /// Set an array of sampler states to the {{geometry shader}} pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// Any sampler may be set to NULL; this invokes the default state, which is defined to be the following.	
            /// <code> //Default sampler state:	
            /// D3D10_SAMPLER_DESC SamplerDesc;	
            /// SamplerDesc.Filter = D3D10_FILTER_MIN_MAG_MIP_LINEAR;	
            /// SamplerDesc.AddressU = D3D10_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.AddressV = D3D10_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.AddressW = D3D10_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.MipLODBias = 0;	
            /// SamplerDesc.MaxAnisotropy = 1;	
            /// SamplerDesc.ComparisonFunc = D3D10_COMPARISON_NEVER;	
            /// SamplerDesc.BorderColor[0] = 1.0f;	
            /// SamplerDesc.BorderColor[1] = 1.0f;	
            /// SamplerDesc.BorderColor[2] = 1.0f;	
            /// SamplerDesc.BorderColor[3] = 1.0f;	
            /// SamplerDesc.MinLOD = -FLT_MAX;	
            /// SamplerDesc.MaxLOD = FLT_MAX; </code>	
            /// 	
            /// The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting samplers to.</param>
            /// <param name="numSamplers">Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available.</param>
            /// <param name="samplersRef">Pointer to an array of sampler-state interfaces (see <see cref="SlimDX2.Direct3D10.SamplerState"/>). See Remarks.</param>
            /// <unmanaged>void GSSetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[In, Buffer] const ID3D10SamplerState** ppSamplers)</unmanaged>
            public  override void SetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D10.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = (IntPtr*)0;
                    if ( samplersRef != null ) {
                        IntPtr* samplersRef__ = stackalloc IntPtr[samplersRef.Length];
                        samplersRef_ = samplersRef__;
                        for (int i = 0; i < samplersRef.Length; i++)                        
                            samplersRef_[i] =  samplersRef[i].NativePointer;
                    }
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 23 * 4, startSlot, numSamplers, samplersRef_);
                }
            }
            
            /// <summary>	
            /// Get the {{constant buffers}} used by the {{geometry shader}} pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin retrieving constant buffers from.</param>
            /// <param name="numBuffers">Number of buffers to retrieve.</param>
            /// <param name="constantBuffersRef">Array of constant buffer interface pointers (see <see cref="SlimDX2.Direct3D10.Buffer"/>) to be returned by the method.</param>
            /// <unmanaged>void GSGetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[Out, Buffer] ID3D10Buffer** ppConstantBuffers)</unmanaged>
            internal  override void GetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D10.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = stackalloc IntPtr[constantBuffersRef.Length];
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 48 * 4, startSlot, numBuffers, &constantBuffersRef_);
                    for (int i = 0; i < constantBuffersRef.Length; i++)
                        constantBuffersRef[i] = (constantBuffersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Buffer(constantBuffersRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get the geometry shader currently set on the device.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="geometryShaderRef">Address of a pointer to a geometry shader (see <see cref="SlimDX2.Direct3D10.GeometryShader"/>) to be returned by the method.</param>
            /// <unmanaged>void GSGetShader([Out] ID3D10GeometryShader** ppGeometryShader)</unmanaged>
            public void Get(out SlimDX2.Direct3D10.GeometryShader geometryShaderRef) {
                unsafe {
                    IntPtr geometryShaderRef_ = IntPtr.Zero;
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 49 * 4, &geometryShaderRef_);
                    geometryShaderRef = (geometryShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.GeometryShader(geometryShaderRef_);	
                }
            }
            
            /// <summary>	
            /// Get the geometry shader resources.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin getting shader resources from.</param>
            /// <param name="numViews">The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources.</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to be returned by the device.</param>
            /// <unmanaged>void GSGetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[Out, Buffer] ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>
            internal  override void GetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D10.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 54 * 4, startSlot, numViews, &shaderResourceViewsRef_);
                    for (int i = 0; i < shaderResourceViewsRef.Length; i++)
                        shaderResourceViewsRef[i] = (shaderResourceViewsRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D10.ShaderResourceView(shaderResourceViewsRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get an array of sampler states from the {{geometry shader}} pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin getting samplers from.</param>
            /// <param name="numSamplers">Number of samplers to get from the device. Each pipeline stage has a total of 16 sampler slots available.</param>
            /// <param name="samplersRef">Arry of sampler-state pointers (see <see cref="SlimDX2.Direct3D10.SamplerState"/>) to be returned by the device.</param>
            /// <unmanaged>void GSGetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[Out, Buffer] ID3D10SamplerState** ppSamplers)</unmanaged>
            internal  override void GetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D10.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = stackalloc IntPtr[samplersRef.Length];
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 55 * 4, startSlot, numSamplers, &samplersRef_);
                    for (int i = 0; i < samplersRef.Length; i++)
                        samplersRef[i] = (samplersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D10.SamplerState(samplersRef_[i]);	
                }
            }
        }
      
		/// <summary>Inner interface giving access to StreamOutputStage methods. </summary>
        public StreamOutputStage StreamOutput { get; private set; }		
        
        /// <summary>Inner interface StreamOutputStage.</summary>
        /// <unmanaged>ID3D10Device</unmanaged>
        [Guid("9B7E4C0F-342C-4106-A19F-4F2704F689F0")]
        public partial class StreamOutputStage : SlimDX2.CppObject {
            public StreamOutputStage(IntPtr basePtr) : base(basePtr) {
            }
            
            
            /// <summary>	
            /// Set the target output {{buffers}} for the {{StreamOutput}} stage, which enables/disables the pipeline to stream-out data.	
            /// </summary>	
            /// <remarks>	
            /// Call ID3D10Device::SOSetTargets (before any draw calls) to stream data out; call SOSetTargets with NULL to stop streaming data out. For an example, see Exercise 01 from the GDC 2007 workshop, which sets the stream output rendertargets before calling draw methods in the RenderInstanceToStream function.An offset of -1 will cause the stream output buffer to be appended, continuing after the last location written to the buffer in a previous stream output pass.Calling this method using a buffer that is currently bound for writing will effectively bind NULL instead because a buffer cannot be bound as both an input and an output at the same time.The {{Debug Layer}} will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will not prevent invalid data from being used by the runtime.The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.	
            /// </remarks>	
            /// <param name="numBuffers">The number of buffer to bind to the device. A maximum of four output buffers can be set. If less than four are defined by the call, the remaining buffer slots are set to NULL. See Remarks.</param>
            /// <param name="sOTargetsRef">The array of output buffers (see <see cref="SlimDX2.Direct3D10.Buffer"/>) to bind to the device. The buffers must have been created with the <see cref="SlimDX2.Direct3D10.BindFlags.StreamOutput"/> flag.</param>
            /// <param name="offsetsRef">Array of offsets to the output buffers from ppSOTargets, one offset for each buffer. The offset values must be in bytes.</param>
            /// <unmanaged>void SOSetTargets([In] UINT NumBuffers,[In, Buffer, Optional] const ID3D10Buffer** ppSOTargets,[In, Buffer, Optional] const UINT* pOffsets)</unmanaged>
            public void SetTargets(int numBuffers, SlimDX2.Direct3D10.Buffer[] sOTargetsRef, int[] offsetsRef) {
                unsafe {
                    IntPtr* sOTargetsRef_ = (IntPtr*)0;
                    if ( sOTargetsRef != null ) {
                        IntPtr* sOTargetsRef__ = stackalloc IntPtr[sOTargetsRef.Length];
                        sOTargetsRef_ = sOTargetsRef__;
                        for (int i = 0; i < sOTargetsRef.Length; i++)                        
                            sOTargetsRef_[i] =  sOTargetsRef[i].NativePointer;
                    }
                    int[] offsetsRef__ = offsetsRef ?? new int[1];
                    fixed (void* offsetsRef_ = &offsetsRef__[0])
                        SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 27 * 4, numBuffers, sOTargetsRef_, offsetsRef==null?(void*)IntPtr.Zero:offsetsRef_);
                }
            }
            
            /// <summary>	
            /// Get the target output {{buffers}} for the {{StreamOutput}} stage of the pipeline.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="numBuffers">Number of buffers to get. A maximum of four output buffers can be retrieved.</param>
            /// <param name="sOTargetsRef">An array of output buffers (see <see cref="SlimDX2.Direct3D10.Buffer"/>) to be retrieved from the device.</param>
            /// <param name="offsetsRef">Array of offsets to the output buffers from ppSOTargets, one offset for each buffer. The offset values are in bytes.</param>
            /// <unmanaged>void SOGetTargets([In] UINT NumBuffers,[Out, Buffer, Optional] ID3D10Buffer** ppSOTargets,[Out, Buffer, Optional] UINT* pOffsets)</unmanaged>
            public void GetTargets(int numBuffers, SlimDX2.Direct3D10.Buffer[] sOTargetsRef, int[] offsetsRef) {
                unsafe {
                    IntPtr* sOTargetsRef_ = stackalloc IntPtr[sOTargetsRef.Length];
                    int[] offsetsRef__ = offsetsRef ?? new int[1];
                    fixed (void* offsetsRef_ = &offsetsRef__[0])
                        SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 59 * 4, numBuffers, &sOTargetsRef_, offsetsRef==null?(void*)IntPtr.Zero:offsetsRef_);
                    for (int i = 0; i < sOTargetsRef.Length; i++)
                        sOTargetsRef[i] = (sOTargetsRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Buffer(sOTargetsRef_[i]);	
                }
            }
        }
      
		/// <summary>Inner interface giving access to RasterizerStage methods. </summary>
        public RasterizerStage Rasterizer { get; private set; }		
        
        /// <summary>Inner interface RasterizerStage.</summary>
        /// <unmanaged>ID3D10Device</unmanaged>
        [Guid("9B7E4C0F-342C-4106-A19F-4F2704F689F0")]
        public partial class RasterizerStage : SlimDX2.CppObject {
            public RasterizerStage(IntPtr basePtr) : base(basePtr) {
            }
            
            
            /// <summary>	
            /// Get the {{rasterizer state}} from the {{rasterizer stage}} of the pipeline.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <unmanaged>void RSGetState([Out] ID3D10RasterizerState** ppRasterizerState)</unmanaged>
            public SlimDX2.Direct3D10.RasterizerState State {
                    get { SlimDX2.Direct3D10.RasterizerState __output__; GetState(out __output__); return __output__; }
                    set { SetState(value); }
            }
            
            /// <summary>	
            /// Set the {{rasterizer state}} for the {{rasterizer stage}} of the pipeline.	
            /// </summary>	
            /// <remarks>	
            /// To create a rasterizer state interface, call <see cref="SlimDX2.Direct3D10.Device.CreateRasterizerState"/>. For more details on setting up the rasterizer state, see {{Set Rasterizer State}}.The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.	
            /// </remarks>	
            /// <param name="rasterizerStateRef">Pointer to a rasterizer-state interface (see <see cref="SlimDX2.Direct3D10.RasterizerState"/>) to bind to the pipeline.</param>
            /// <unmanaged>void RSSetState([In, Optional] ID3D10RasterizerState* pRasterizerState)</unmanaged>
            internal void SetState(SlimDX2.Direct3D10.RasterizerState rasterizerStateRef) {
                unsafe {
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 29 * 4, (void*)((rasterizerStateRef == null)?IntPtr.Zero:rasterizerStateRef.NativePointer));
                }
            }
            
            /// <summary>	
            /// Bind an array of {{viewports}} to the {{rasterizer stage}} of the pipeline.	
            /// </summary>	
            /// <remarks>	
            /// All viewports must be set atomically as one operation. Any viewports not defined by the call are disabled.Which viewport to use is determined by the SV_ViewportArrayIndex semantic output by a geometry shader (see {{shader semantic syntax}}). If a geometry shader does not make use of the SV_ViewportArrayIndex semantic then Direct3D will use the first viewport in the array.	
            /// </remarks>	
            /// <param name="numViewports">Number of viewports to bind.</param>
            /// <param name="viewportsRef">An array of viewports (see <see cref="SlimDX2.Direct3D10.Viewport"/>) to bind to the device. Each viewport must have its extents within the allowed ranges: D3D10_VIEWPORT_BOUNDS_MIN, D3D10_VIEWPORT_BOUNDS_MAX, D3D10_MIN_DEPTH, and D3D10_MAX_DEPTH.</param>
            /// <unmanaged>void RSSetViewports([In] UINT NumViewports,[In, Buffer, Optional] const D3D10_VIEWPORT* pViewports)</unmanaged>
            public void SetViewports(int numViewports, SlimDX2.Direct3D10.Viewport[] viewportsRef) {
                unsafe {
                    SlimDX2.Direct3D10.Viewport[] viewportsRef__ = viewportsRef ?? new SlimDX2.Direct3D10.Viewport[1];
                    fixed (void* viewportsRef_ = &viewportsRef__[0])
                        SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 30 * 4, numViewports, viewportsRef==null?(void*)IntPtr.Zero:viewportsRef_);
                }
            }
            
            /// <summary>	
            /// Bind an array of {{scissor rectangles}} to the {{rasterizer stage}}.	
            /// </summary>	
            /// <remarks>	
            /// The scissor rectangles will only be used if ScissorEnable is set to true in the rasterizer state (see <see cref="SlimDX2.Direct3D10.RasterizerStateDescription"/>).Which scissor rectangle to use is determined by the SV_ViewportArrayIndex semantic output by a geometry shader (see {{shader semantic syntax}}). If a geometry shader does not make use of the SV_ViewportArrayIndex semantic then Direct3D will use the first scissor rectangle in the array.Each scissor rectangle in the array corresponds to a viewport in an array of viewports (see <see cref="SlimDX2.Direct3D10.Device.RasterizerStage.SetViewports"/>).	
            /// </remarks>	
            /// <param name="numRects">Number of scissor rectangles to bind.</param>
            /// <param name="rectsRef">An array of scissor rectangles (see <see cref="SlimDX2.RectangleF"/>).</param>
            /// <unmanaged>void RSSetScissorRects([In] UINT NumRects,[In, Buffer, Optional] const D3D10_RECT* pRects)</unmanaged>
            public void SetScissorRects(int numRects, SlimDX2.RectangleF[] rectsRef) {
                unsafe {
                    SlimDX2.RectangleF[] rectsRef__ = rectsRef ?? new SlimDX2.RectangleF[1];
                    fixed (void* rectsRef_ = &rectsRef__[0])
                        SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 31 * 4, numRects, rectsRef==null?(void*)IntPtr.Zero:rectsRef_);
                }
            }
            
            /// <summary>	
            /// Get the {{rasterizer state}} from the {{rasterizer stage}} of the pipeline.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="rasterizerStateRef">Address of a pointer to a rasterizer-state interface (see <see cref="SlimDX2.Direct3D10.RasterizerState"/>) to fill with information from the device.</param>
            /// <unmanaged>void RSGetState([Out] ID3D10RasterizerState** ppRasterizerState)</unmanaged>
            internal void GetState(out SlimDX2.Direct3D10.RasterizerState rasterizerStateRef) {
                unsafe {
                    IntPtr rasterizerStateRef_ = IntPtr.Zero;
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 60 * 4, &rasterizerStateRef_);
                    rasterizerStateRef = (rasterizerStateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.RasterizerState(rasterizerStateRef_);	
                }
            }
            
            /// <summary>	
            /// Get the array of {{viewports}} bound  to the {{rasterizer stage}}	
            /// </summary>	
            /// <param name="numViewports">Number of viewports in pViewports.   If pViewports is NULL, this will be filled with the number of viewports currently bound.</param>
            /// <param name="viewportsRef">An array of viewports (see <see cref="SlimDX2.Direct3D10.Viewport"/>) to be filled with information from the device. If NumViewports is greater than  the actual number of viewports currently bound, then unused members of the array will contain 0.</param>
            /// <unmanaged>void RSGetViewports([InOut] UINT* NumViewports,[Out, Buffer, Optional] D3D10_VIEWPORT* pViewports)</unmanaged>
            public void GetViewports(ref int numViewports, SlimDX2.Direct3D10.Viewport[] viewportsRef) {
                unsafe {
                    SlimDX2.Direct3D10.Viewport[] viewportsRef__ = viewportsRef ?? new SlimDX2.Direct3D10.Viewport[1];
                    fixed (void* numViewports_ = &numViewports)
                        fixed (void* viewportsRef_ = &viewportsRef__[0])
                            SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 61 * 4, numViewports_, viewportsRef==null?(void*)IntPtr.Zero:viewportsRef_);
                }
            }
            
            /// <summary>	
            /// Get the array of {{scissor rectangles}} bound to the {{rasterizer stage}}.	
            /// </summary>	
            /// <param name="numRects">Number of scissor rectangles to get. If pRects is NULL, this will be filled with the number of scissor rectangles currently bound.</param>
            /// <param name="rectsRef">An array of scissor rectangles (see <see cref="SlimDX2.RectangleF"/>). If NumRects is greater than the number of scissor rects currently bound, then unused members of the array will contain 0.</param>
            /// <unmanaged>void RSGetScissorRects([InOut] UINT* NumRects,[Out, Buffer, Optional] D3D10_RECT* pRects)</unmanaged>
            public void GetScissorRects(ref int numRects, SlimDX2.RectangleF[] rectsRef) {
                unsafe {
                    SlimDX2.RectangleF[] rectsRef__ = rectsRef ?? new SlimDX2.RectangleF[1];
                    fixed (void* numRects_ = &numRects)
                        fixed (void* rectsRef_ = &rectsRef__[0])
                            SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 62 * 4, numRects_, rectsRef==null?(void*)IntPtr.Zero:rectsRef_);
                }
            }
        }
      
		/// <summary>Inner interface giving access to OutputMergerStage methods. </summary>
        public OutputMergerStage OutputMerger { get; private set; }		
        
        /// <summary>Inner interface OutputMergerStage.</summary>
        /// <unmanaged>ID3D10Device</unmanaged>
        [Guid("9B7E4C0F-342C-4106-A19F-4F2704F689F0")]
        public partial class OutputMergerStage : SlimDX2.CppObject {
            public OutputMergerStage(IntPtr basePtr) : base(basePtr) {
            }
            
            
            /// <summary>	
            /// Bind one or more render targets and the depth-stencil buffer to the {{output-merger stage}}.	
            /// </summary>	
            /// <remarks>	
            /// A call to OMSetRenderTargets overrides all bounded render targets and the depth stencil target regardless of the number of render targets in ppRenderTargetViews.The maximum number of render targets a device can have active at any given time is set by a #define in D3D10.h called D3D10_SIMULTANEOUS_RENDER_TARGET_COUNT. It is invalid to try to set the same {{subresource}} to multiple render target slots.If any subresources are also currently bound for reading or writing (perhaps in a different part of the {{pipeline}}), those bind points will be NULL'ed out to prevent the same subresource from being read and written simultaneously in a single rendering operation.The method will not hold references to the interfaces passed in. For that reason, applications should be careful not to release interfaces currently in use by the device.See {{Binding Resources and Pipeline stages}} for more information on binding resources.	
            /// </remarks>	
            /// <param name="numViews">Number of render targets to bind.</param>
            /// <param name="renderTargetViewsRef">Pointer to an array of render targets (see <see cref="SlimDX2.Direct3D10.RenderTargetView"/>) to bind to the device. If this parameter is NULL, no render targets are bound. See Remarks.</param>
            /// <param name="depthStencilViewRef">Pointer to a depth-stencil view (see <see cref="SlimDX2.Direct3D10.DepthStencilView"/>) to bind to the device. If this parameter is NULL, the depth-stencil state is not bound.</param>
            /// <unmanaged>void OMSetRenderTargets([In] UINT NumViews,[In, Buffer, Optional] const ID3D10RenderTargetView** ppRenderTargetViews,[In, Optional] ID3D10DepthStencilView* pDepthStencilView)</unmanaged>
            public void SetRenderTargets(int numViews, SlimDX2.Direct3D10.RenderTargetView[] renderTargetViewsRef, SlimDX2.Direct3D10.DepthStencilView depthStencilViewRef) {
                unsafe {
                    IntPtr* renderTargetViewsRef_ = (IntPtr*)0;
                    if ( renderTargetViewsRef != null ) {
                        IntPtr* renderTargetViewsRef__ = stackalloc IntPtr[renderTargetViewsRef.Length];
                        renderTargetViewsRef_ = renderTargetViewsRef__;
                        for (int i = 0; i < renderTargetViewsRef.Length; i++)                        
                            renderTargetViewsRef_[i] =  renderTargetViewsRef[i].NativePointer;
                    }
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 24 * 4, numViews, renderTargetViewsRef_, (void*)((depthStencilViewRef == null)?IntPtr.Zero:depthStencilViewRef.NativePointer));
                }
            }
            
            /// <summary>	
            /// Set the {{blend state}} of the output-merger stage.	
            /// </summary>	
            /// <remarks>	
            /// Blend state is used by the {{output-merger}} stage to determine how to blend together two pixel values. The two values are commonly the current pixel value and the pixel value already in the output render target. Use the {{blend operation}} to control where the two pixel values come from and how they are mathematically combined.To create a blend-state interface, call <see cref="SlimDX2.Direct3D10.Device.CreateBlendState"/>.Passing in NULL for the blend-state interface indicates to the runtime to set a default blending state.  The following table indicates the default blending parameters.StateDefault ValueAlphaToCoverageEnableFALSEBlendEnableFALSE[8]SrcBlendD3D10_BLEND_ONEDstBlendD3D10_BLEND_ZEROBlendOpD3D10_BLEND_OP_ADDSrcBlendAlphaD3D10_BLEND_ONEDstBlendAlphaD3D10_BLEND_ZEROBlendOpAlphaD3D10_BLEND_OP_ADDRenderTargetWriteMask[8]D3D10_COLOR_WRITE_ENABLE_ALL[8]?A sample mask determines which samples get updated in all the active render targets. The mapping of bits in a sample mask to samples in a multisample render target is the responsibility of an individual application. A sample mask is always applied; it is independent of whether multisampling is enabled, and does not depend on whether an application uses multisample render targets.The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.	
            /// </remarks>	
            /// <param name="blendStateRef">Pointer to a blend-state interface (see <see cref="SlimDX2.Direct3D10.BlendState"/>). Passing in NULL implies a default blend state. See remarks for further details.</param>
            /// <param name="blendFactor">Array of blend factors, one for each RGBA component. This requires a blend state object that specifies the <see cref="SlimDX2.Direct3D10.BlendOption.BlendFactor"/> option.</param>
            /// <param name="sampleMask">32-bit sample coverage. The default value is 0xffffffff. See remarks.</param>
            /// <unmanaged>void OMSetBlendState([In, Optional] ID3D10BlendState* pBlendState,[In] const FLOAT BlendFactor[4],[In] UINT SampleMask)</unmanaged>
            public void SetBlendState(SlimDX2.Direct3D10.BlendState blendStateRef, SlimMath.Vector4 blendFactor, int sampleMask) {
                unsafe {
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 25 * 4, (void*)((blendStateRef == null)?IntPtr.Zero:blendStateRef.NativePointer), &blendFactor, sampleMask);
                }
            }
            
            /// <summary>	
            /// Sets the {{depth-stencil}} state of  the output-merger stage.	
            /// </summary>	
            /// <remarks>	
            /// To create a depth-stencil state interface, call <see cref="SlimDX2.Direct3D10.Device.CreateDepthStencilState"/>.Depth-stencil state is used by the {{output-merger}} stage to  setup depth-stencil testing.  The stencil reference value is the control value used in the depth-stencil test.The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an  interface currently in use by the device.	
            /// </remarks>	
            /// <param name="depthStencilStateRef">Pointer to a depth-stencil state interface (see <see cref="SlimDX2.Direct3D10.DepthStencilState"/>) to bind to the device.</param>
            /// <param name="stencilRef">Reference value to perform against when doing a depth-stencil test. See remarks.</param>
            /// <unmanaged>void OMSetDepthStencilState([In, Optional] ID3D10DepthStencilState* pDepthStencilState,[In] UINT StencilRef)</unmanaged>
            public void SetDepthStencilState(SlimDX2.Direct3D10.DepthStencilState depthStencilStateRef, int stencilRef) {
                unsafe {
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 26 * 4, (void*)((depthStencilStateRef == null)?IntPtr.Zero:depthStencilStateRef.NativePointer), stencilRef);
                }
            }
            
            /// <summary>	
            /// Get pointers to the render targets and the depth-stencil buffer that are available to the {{output-merger stage}}.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="numViews">Number of render targets to retrieve.</param>
            /// <param name="renderTargetViewsRef">Pointer to an array of render targets views (see <see cref="SlimDX2.Direct3D10.RenderTargetView"/>) to be filled with the render targets from the device. Specify NULL for this parameter when retrieval of a render target is not needed. </param>
            /// <param name="depthStencilViewRef">Pointer to a depth-stencil view (see <see cref="SlimDX2.Direct3D10.DepthStencilView"/>) to be filled with the depth-stencil information from the device. Specify NULL for this parameter when retrieval of the depth-stencil view is not needed.</param>
            /// <unmanaged>void OMGetRenderTargets([In] UINT NumViews,[Out, Buffer, Optional] ID3D10RenderTargetView** ppRenderTargetViews,[Out, Optional] ID3D10DepthStencilView** ppDepthStencilView)</unmanaged>
            public void GetRenderTargets(int numViews, SlimDX2.Direct3D10.RenderTargetView[] renderTargetViewsRef, out SlimDX2.Direct3D10.DepthStencilView depthStencilViewRef) {
                unsafe {
                    IntPtr* renderTargetViewsRef_ = stackalloc IntPtr[renderTargetViewsRef.Length];
                    IntPtr depthStencilViewRef_ = IntPtr.Zero;
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 56 * 4, numViews, &renderTargetViewsRef_, &depthStencilViewRef_);
                    for (int i = 0; i < renderTargetViewsRef.Length; i++)
                        renderTargetViewsRef[i] = (renderTargetViewsRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D10.RenderTargetView(renderTargetViewsRef_[i]);	
                    depthStencilViewRef = (depthStencilViewRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.DepthStencilView(depthStencilViewRef_);	
                }
            }
            
            /// <summary>	
            /// Get the {{blend state}} of the output-merger stage.	
            /// </summary>	
            /// <remarks>	
            /// The reference count of the returned interface will be incremented by one when the blend state is retrieved. Applications must release returned pointer(s) when they are no longer needed, or else there will be a memory leak.	
            /// </remarks>	
            /// <param name="blendStateRef">Address of a pointer to a blend-state interface (see <see cref="SlimDX2.Direct3D10.BlendState"/>).</param>
            /// <param name="blendFactor">Array of blend factors, one for each RGBA component.</param>
            /// <param name="sampleMaskRef">Pointer to a {{sample mask}}.</param>
            /// <unmanaged>void OMGetBlendState([Out, Optional] ID3D10BlendState** ppBlendState,[Out, Optional] FLOAT BlendFactor[4],[Out, Optional] UINT* pSampleMask)</unmanaged>
            public void GetBlendState(out SlimDX2.Direct3D10.BlendState blendStateRef, out SlimMath.Vector4 blendFactor, out int sampleMaskRef) {
                unsafe {
                    IntPtr blendStateRef_ = IntPtr.Zero;
                    blendFactor = new SlimMath.Vector4();
                    fixed (void* blendFactor_ = &blendFactor)
                        fixed (void* sampleMaskRef_ = &sampleMaskRef)
                            SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 57 * 4, &blendStateRef_, blendFactor_, sampleMaskRef_);
                    blendStateRef = (blendStateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.BlendState(blendStateRef_);	
                }
            }
            
            /// <summary>	
            /// Gets the {{depth-stencil}} state of the output-merger stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="depthStencilStateRef">Address of a pointer to a depth-stencil state interface (see <see cref="SlimDX2.Direct3D10.DepthStencilState"/>) to be filled with information from the device.</param>
            /// <param name="stencilRefRef">Pointer to the stencil reference value used in the {{depth-stencil}} test.</param>
            /// <unmanaged>void OMGetDepthStencilState([Out, Optional] ID3D10DepthStencilState** ppDepthStencilState,[Out, Optional] UINT* pStencilRef)</unmanaged>
            public void GetDepthStencilState(out SlimDX2.Direct3D10.DepthStencilState depthStencilStateRef, out int stencilRefRef) {
                unsafe {
                    IntPtr depthStencilStateRef_ = IntPtr.Zero;
                    fixed (void* stencilRefRef_ = &stencilRefRef)
                        SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 58 * 4, &depthStencilStateRef_, stencilRefRef_);
                    depthStencilStateRef = (depthStencilStateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.DepthStencilState(depthStencilStateRef_);	
                }
            }
        }
        
        /// <summary>	
        /// Get the reason why the device was removed.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDeviceRemovedReason()</unmanaged>
        public SlimDX2.Result DeviceRemovedReason {
                get { return GetDeviceRemovedReason(); }
        }
        
        /// <summary>	
        /// Get the exception-mode flags.	
        /// </summary>	
        /// <remarks>	
        /// An exception-mode flag is used to elevate an error condition to a non-continuable exception. 	
        /// </remarks>	
        /// <unmanaged>UINT GetExceptionMode()</unmanaged>
        public int ExceptionMode {
                get { return GetExceptionMode(); }
                set { SetExceptionMode(value); }
        }
        
        /// <summary>	
        /// Get the flags used during the call to create the device with <see cref="SlimDX2.Direct3D10.D3D10.CreateDevice"/>.	
        /// </summary>	
        /// <unmanaged>UINT GetCreationFlags()</unmanaged>
        public int CreationFlags {
                get { return GetCreationFlags(); }
        }
        
        /// <summary>	
        /// Draw indexed, non-instanced primitives.	
        /// </summary>	
        /// <remarks>	
        /// A {{draw API}} submits work to the rendering pipeline.If the sum of both indices is negative, the result of the function call is undefined.	
        /// </remarks>	
        /// <param name="indexCount">Number of indices to draw.</param>
        /// <param name="startIndexLocation">Index of the first index to use when accesssing the vertex buffer; begin at StartIndexLocation to index vertices from the vertex buffer.</param>
        /// <param name="baseVertexLocation">Offset from the start of the vertex buffer to the first vertex.</param>
        /// <unmanaged>void DrawIndexed([In] UINT IndexCount,[In] UINT StartIndexLocation,[In] INT BaseVertexLocation)</unmanaged>
        public void DrawIndexed(int indexCount, int startIndexLocation, int baseVertexLocation) {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 8 * 4, indexCount, startIndexLocation, baseVertexLocation);
            }
        }
        
        /// <summary>	
        /// Draw non-indexed, non-instanced primitives.	
        /// </summary>	
        /// <remarks>	
        /// A {{draw API}} submits work to the rendering pipeline.The vertex data for a draw call normally comes from a vertex buffer that is bound to the pipeline. However, you could also provide the vertex data from a shader that has vertex data marked with the SV_VertexId?{{system-value semantic}}.	
        /// </remarks>	
        /// <param name="vertexCount">Number of vertices to draw.</param>
        /// <param name="startVertexLocation">Index of the first vertex, which is usually an offset in a vertex buffer; it could also be used as the first vertex id generated for a shader parameter marked with the SV_TargetId?{{system-value semantic}}.</param>
        /// <unmanaged>void Draw([In] UINT VertexCount,[In] UINT StartVertexLocation)</unmanaged>
        public void Draw(int vertexCount, int startVertexLocation) {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 9 * 4, vertexCount, startVertexLocation);
            }
        }
        
        /// <summary>	
        /// Draw indexed, instanced primitives.	
        /// </summary>	
        /// <remarks>	
        /// A {{draw API}} submits work to the rendering pipeline.Instancing may extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing could be to draw the same object with different positions and colors. Indexing requires multiple vertex buffers: at least one for per-vertex data and a second buffer for per-instance data. For an example of instancing, see the {{Instancing10 Sample}}.	
        /// </remarks>	
        /// <param name="indexCountPerInstance">Size of the index buffer used in each instance.</param>
        /// <param name="instanceCount">Number of instances to draw.</param>
        /// <param name="startIndexLocation">Index of the first index.</param>
        /// <param name="baseVertexLocation">Index of the first vertex. The index is signed, which allows a negative index. If the negative index plus the index value from the index buffer are less than 0, the result is undefined.</param>
        /// <param name="startInstanceLocation">Index of the first instance.</param>
        /// <unmanaged>void DrawIndexedInstanced([In] UINT IndexCountPerInstance,[In] UINT InstanceCount,[In] UINT StartIndexLocation,[In] INT BaseVertexLocation,[In] UINT StartInstanceLocation)</unmanaged>
        public void DrawIndexedInstanced(int indexCountPerInstance, int instanceCount, int startIndexLocation, int baseVertexLocation, int startInstanceLocation) {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 14 * 4, indexCountPerInstance, instanceCount, startIndexLocation, baseVertexLocation, startInstanceLocation);
            }
        }
        
        /// <summary>	
        /// Draw non-indexed, instanced primitives.	
        /// </summary>	
        /// <remarks>	
        /// A {{draw API}} submits work to the rendering pipeline.Instancing may extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing could be to draw the same object with different positions and colors. For an example of instancing, see the {{Instancing10 Sample}}.The vertex data for an instanced draw call normally comes from a vertex buffer that is bound to the pipeline. However, you could also provide the vertex data from a shader that has instanced data identified with a {{system-value semantic}} (SV_InstanceID).	
        /// </remarks>	
        /// <param name="vertexCountPerInstance">Number of vertices to draw.</param>
        /// <param name="instanceCount">Number of instances to draw.</param>
        /// <param name="startVertexLocation">Index of the first vertex.</param>
        /// <param name="startInstanceLocation">Index of the first instance.</param>
        /// <unmanaged>void DrawInstanced([In] UINT VertexCountPerInstance,[In] UINT InstanceCount,[In] UINT StartVertexLocation,[In] UINT StartInstanceLocation)</unmanaged>
        public void DrawInstanced(int vertexCountPerInstance, int instanceCount, int startVertexLocation, int startInstanceLocation) {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 15 * 4, vertexCountPerInstance, instanceCount, startVertexLocation, startInstanceLocation);
            }
        }
        
        /// <summary>	
        /// Set a rendering predicate.	
        /// </summary>	
        /// <remarks>	
        /// The predicate must be in the "issued" or "signaled" state to be used for predication. While the predicate is set for predication, calls to <see cref="SlimDX2.Direct3D10.Asynchronous.Begin"/> and <see cref="SlimDX2.Direct3D10.Asynchronous.End"/> are invalid.This method is used to denote that subsequent rendering and resource manipulation commands are not actually performed if the resulting Predicate data of the Predicate is equal to the PredicateValue. However, some Predicates are only hints, so they may not actually prevent operations from being performed. The primary usefulness of Predication is to allow an application to issue graphics commands without taking the performance hit of spinning, waiting for <see cref="SlimDX2.Direct3D10.Asynchronous.GetData"/> to return. So, Predication can occur while ID3D10Asynchronous::GetData returns S_FALSE. Another way to think of it: an application can also use Predication as a fallback, if it is possible that ID3D10Asynchronous::GetData returns S_FALSE. If ID3D10Asynchronous::GetData returns S_OK, the application can skip calling the graphics commands manually with it's own application logic.	
        /// </remarks>	
        /// <param name="predicateRef">Pointer to a predicate (see <see cref="SlimDX2.Direct3D10.Predicate"/>). A NULL value indicates "no" predication; in this case, the value of PredicateValue is irrelevent but will be preserved for <see cref="SlimDX2.Direct3D10.Device.GetPredication"/>.</param>
        /// <param name="predicateValue">If TRUE, rendering will be affected by when the predicate's conditions are met. If FALSE, rendering will be affected when the conditions are not met.</param>
        /// <unmanaged>void SetPredication([In, Optional] ID3D10Predicate* pPredicate,[In] BOOL PredicateValue)</unmanaged>
        public void SetPredication(SlimDX2.Direct3D10.Predicate predicateRef, bool predicateValue) {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 21 * 4, (void*)((predicateRef == null)?IntPtr.Zero:predicateRef.NativePointer), (predicateValue?1:0));
            }
        }
        
        /// <summary>	
        /// Draw geometry of an unknown size that was created by the geometry shader stage. See remarks.	
        /// </summary>	
        /// <remarks>	
        /// A {{draw API}} submits work to the rendering pipeline.After data has been streamed out to {{SO stage}} buffers, those buffers can be again bound to the Input Assembler stage at input slot 0 and DrawAuto will draw them without the application needing to know the amount of data that was written to the buffers. A measurement of the amount of data written to the SO stage buffers is maintained internally when the data is streamed out. This means that the CPU does not need to fetch the measurement before re-binding the data that was streamed as input data. Although this amount is tracked internally, it is still the responsibility of applications to use input layouts to describe the format of the data in the SO stage buffers so that the layouts are available when the buffers are again bound to the input assembler.The following diagram shows the DrawAuto process.?Diagram of DrawAuto as data moves through several stages to a buffer and then back to the Input Assembler stage?Calling DrawAuto does not change the state of the streaming-output buffers that were bound again as inputs.DrawAuto only works when drawing with one input buffer bound as an input to the IA stage at slot 0. Applications must create the SO buffer resource with both binding flags, <see cref="SlimDX2.Direct3D10.BindFlags.VertexBuffer"/> and D3D10_BIND_STREAM_OUTPUT.This API does not support indexing or instancing.If an application needs to retrieve the size of the streaming-output buffer, it can query for statistics on streaming output by using <see cref="SlimDX2.Direct3D10.QueryType.StreamOutputStatistics"/>.Example of using DrawAuto can be found in the {{ParticlesGS Sample}} and {{PipesGS Sample}}.	
        /// </remarks>	
        /// <unmanaged>void DrawAuto()</unmanaged>
        public void DrawAuto() {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 28 * 4);
            }
        }
        
        /// <summary>	
        /// Copy a region from a source resource to a destination resource.	
        /// </summary>	
        /// <remarks>	
        /// The source box must be within the size of the source resource. The destination location is an absolute value (not a relative value). The destination location can be offset from the source location; however, the size of the region to copy (including the destination location) must fit in the destination resource.If the resources are buffers, all coordinates are in bytes; if the resources are textures, all coordinates are in texels. {{D3D10CalcSubresource}} is a helper function for calculating subresource indexes.CopySubresourceRegion performs the copy on the GPU (similar to a memcpy by the CPU). As a consequence, the source and destination resources must meet the following criteria:Must be different subresources (although they can be from the same resource).Must be the same {{type}}.Must have compatible {{formats}} (the formats must either be identical or be from the same type group). For example, a DXGI_FORMAT_R32G32B32_FLOAT texture can be copied to an DXGI_FORMAT_R32G32B32_UINT texture because both of these formats are in the DXGI_FORMAT_R32G32B32_TYPELESS group.May not be currently {{mapped}}.CopySubresourceRegion supports only copy; it does not support any stretch, color key, blend, or format conversions. An application that needs to copy an entire resource should use <see cref="SlimDX2.Direct3D10.Device.CopyResource"/> instead.CopySubresourceRegion is an asynchronous call that the runtime can add  to the command-buffer queue. This asynchronous behaviorattempts to remove pipeline stalls that may occur when copying data. See {{performance considerations}} for more details.Differences between Direct3D 10 and Direct3D 10.1:Direct3D 10 has the following limitations:You cannot use a depth-stencil resource as a destination.You cannot use an immutable resource as a destination.You cannot use a multisampled texture as either a source or a destinationDirect3D 10.1 has added support for the following features:You can use a depth-stencil buffer as a source or a destination.You can use multisampled resources as  source and destination only if both source and destination have identical multisampled count and quality. If source and destination differ in multisampled count and quality or if the source is multisampled and the destination is not multisampled (or vice versa), the call to ID3D10Device::CopySubresourceRegion fails.You can copy between uncompressed and compressed resources. During copy, the format conversions that are specified in  {{Format Conversion using Direct3D 10.1}} are supported automatically. The uncompressed resource must be at least prestructured, and typed. You must also account for the difference between the virtual and the physical size of the mipmaps levels.?Note??If you use CopySubresourceRegion with a depth-stencil buffer or a multisampled resource, you must copy the whole subresource. You must also pass 0 to the DstX, DstY, and DstZ parameters and NULL to the pSrcBox parameter. In addition, source and destination resources, which are represented by the pSrcResource and pDstResource parameters respectively, must have identical sample count values.ExampleThe following code snippet copies a box (located at (120,100),(200,220)) from a source texture into a reqion (130,120),(210,240) in a destination texture.	
        /// <code> D3D10_BOX sourceRegion;	
        /// sourceRegion.left = 120;	
        /// sourceRegion.right = 200;	
        /// sourceRegion.top = 100;	
        /// sourceRegion.bottom = 220;	
        /// sourceRegion.front = 0;	
        /// sourceRegion.back = 1; pd3dDevice-&gt;CopySubresourceRegion( pDestTexture, 0, 130, 120, 0, pSourceTexture, 0, &amp;sourceRegion ); </code>	
        /// 	
        /// Notice that, for a 2D texture, front and back are always set to 0 and 1 respectively.	
        /// </remarks>	
        /// <param name="dstResourceRef">A pointer to the destination resource (see <see cref="SlimDX2.Direct3D10.Resource"/>).</param>
        /// <param name="dstSubresource"> index of the destination.</param>
        /// <param name="dstX">The x coordinate of the upper left corner of the destination region.</param>
        /// <param name="dstY">The y coordinate of the upper left corner of the destination region.</param>
        /// <param name="dstZ">The z coordinate of the upper left corner of the destination region. For a 1D or 2D subresource, this must be zero.</param>
        /// <param name="srcResourceRef">A pointer to the source resource (see <see cref="SlimDX2.Direct3D10.Resource"/>).</param>
        /// <param name="srcSubresource"> index of the source.</param>
        /// <param name="srcBoxRef">A 3D box (see <see cref="SlimDX2.Direct3D10.ResourceRegion"/>) that defines the source subresources that can be copied. If NULL, the entire source subresource is copied. The box must fit within the source resource.</param>
        /// <unmanaged>void CopySubresourceRegion([In] ID3D10Resource* pDstResource,[In] UINT DstSubresource,[In] UINT DstX,[In] UINT DstY,[In] UINT DstZ,[In] ID3D10Resource* pSrcResource,[In] UINT SrcSubresource,[In, Optional] const D3D10_BOX* pSrcBox)</unmanaged>
        public void CopySubresourceRegion(SlimDX2.Direct3D10.Resource dstResourceRef, int dstSubresource, int dstX, int dstY, int dstZ, SlimDX2.Direct3D10.Resource srcResourceRef, int srcSubresource, SlimDX2.Direct3D10.ResourceRegion? srcBoxRef) {
            unsafe {
                SlimDX2.Direct3D10.ResourceRegion srcBoxRef_;
                if (srcBoxRef.HasValue)
                    srcBoxRef_ = srcBoxRef.Value;				
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 32 * 4, (void*)((dstResourceRef == null)?IntPtr.Zero:dstResourceRef.NativePointer), dstSubresource, dstX, dstY, dstZ, (void*)((srcResourceRef == null)?IntPtr.Zero:srcResourceRef.NativePointer), srcSubresource, (srcBoxRef.HasValue)?&srcBoxRef_:(void*)IntPtr.Zero);
            }
        }
        
        /// <summary>	
        /// Copy the entire contents of the source resource to the destination resource using the GPU. 	
        /// </summary>	
        /// <remarks>	
        /// This method is unusual in that it causes the GPU to perform the copy operation (similar to a memcpy by the CPU). As a result, it has a few restrictions designed for improving performance. For instance, the source and destination resources:Must be different resources.Must be the same {{type}}.Must have identical dimensions (including width, height, depth, and size as appropriate).Will only be copied. CopyResource does not support any stretch, color key, blend, or format conversions.Must have compatible {{formats}}, which means the formats must be identical or at least from the same type group. For example, a DXGI_FORMAT_R32G32B32_FLOAT texture can be copied to an DXGI_FORMAT_R32G32B32_UINT texture since both of these formats are in the DXGI_FORMAT_R32G32B32_TYPELESS group.May not be currently {{mapped}}.{{Immutable}}, and {{depth-stencil}} resources cannot be used as a destination.  Resources created with {{multisampling capability}} cannot be used as either a source or destination.The method is an asynchronous call which may be added to the command-buffer queue. This attempts to remove pipeline stalls that may occur when copying data. See {{performance considerations}} for more details.An application that only needs to copy a portion of the data in a resource should use <see cref="SlimDX2.Direct3D10.Device.CopySubresourceRegion"/> instead.Differences between Direct3D 10 and Direct3D 10.1:Direct3D 10.1 enables depth-stencil resources to be used as either a source or destination. Direct3D 10.1 enables multisampled resources to be used as source and destination only if both source and destination have identical multisampled count and quality. If source and destination differ in multisampled count and quality or if the source is multisampled and the destination is not multisampled (or vice versa), the call to ID3D10Device::CopyResource fails.It is possible to copy between prestructured+typed resources and block-compressed textures. See {{Format Conversion using Direct3D 10.1}}.?	
        /// </remarks>	
        /// <param name="dstResourceRef">A pointer to the destination resource (see <see cref="SlimDX2.Direct3D10.Resource"/>).</param>
        /// <param name="srcResourceRef">A pointer to the source resource (see <see cref="SlimDX2.Direct3D10.Resource"/>).</param>
        /// <unmanaged>void CopyResource([In] ID3D10Resource* pDstResource,[In] ID3D10Resource* pSrcResource)</unmanaged>
        public void CopyResource(SlimDX2.Direct3D10.Resource dstResourceRef, SlimDX2.Direct3D10.Resource srcResourceRef) {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 33 * 4, (void*)((dstResourceRef == null)?IntPtr.Zero:dstResourceRef.NativePointer), (void*)((srcResourceRef == null)?IntPtr.Zero:srcResourceRef.NativePointer));
            }
        }
        
        /// <summary>	
        /// The CPU copies data from memory to a {{subresource}} created in non-mappable memory. See remarks.	
        /// </summary>	
        /// <remarks>	
        /// For a shader-constant buffer; set pDstBox to NULL. It is not possible to use this method to partially update a shader-constant buffer.A resource cannot be used as a destination if:the resource is created with {{immutable}} usage.the resource is created as a {{depth-stencil resource}}.the resource is created with multisampling capability (see <see cref="SlimDX2.DXGI.SampleDescription"/>).When UpdateSubresource returns, the application is free to change or even free the data pointed to by pSrcData because the method has already copied/snapped away the original contents.The performance of UpdateSubresource depends on whether or not there is contention for the destination resource. For example, contention for a vertex buffer resource occurs when the application executes a Draw call and later calls UpdateSubresource on the same vertex buffer before the Draw call is actually executed by the GPU.When there is contention for the resource, UpdateSubresource will perform 2 copies of the source data. First, the data is copied by the CPU to a temporary storage space accessible by the command buffer. This copy happens before the method returns.  A second copy is then performed by the GPU to copy the source data into non-mappable memory. This second copy happens asynchronously because it is executed by GPU when the command buffer is flushed.When there is no resource contention, the behavior of UpdateSubresource is dependent on which is faster (from the CPU's perspective): copying the data to the command buffer and then having a second copy execute when the command buffer is flushed, or having the CPU copy the data to the final resource location. This is dependent on the architecture of the underlying system.To better understand the source row pitch and source depth pitch parameters, consider the following illustration of a 3D volume texture.?Illustration of a 3D volume texture?Each block in this visual represents an element of data, and the size of each element is dependent on the resource's format. For example, if the resource format is DXGI_FORMAT_R32G32B32A32_FLOAT, then the size of each element would be 128 bits, or 16 bytes. This 3D volume texture has a width of two, a height of three, and a depth of four.To calculate the source row pitch and source depth pitch for a given resource, use the following formulas:Source Row Pitch = [size of one element in bytes] * [number of elements in one row]Source Depth Pitch = [Source Row Pitch] * [number of rows (height)]In the case of this example 3D volume texture where the size of each element is 16 bytes, the formulas are as follows:Source Row Pitch = 16 * 2 = 32Source Depth Pitch = 16 * 2 * 3 = 96The following illustration shows the resource as it is laid out in memory.?Illustration of a 3D volume texture in memory?For example, the following code snippet shows how to specify a destination region in a 2D texture. Assume the destination texture is 512x512 and the operation will copy the data pointed to by pData to  [(120,100)..(200,220)] in the destination texture. Also assume that rowPitch has been initialized with the proper value (as explained above). Front and back are set to 0 and 1 respectively, because by having front equal to back, the box is technically empty.	
        /// <code> D3D10_BOX destRegion;	
        /// destRegion.left = 120;	
        /// destRegion.right = 200;	
        /// destRegion.top = 100;	
        /// destRegion.bottom = 220;	
        /// destRegion.front = 0;	
        /// destRegion.back = 1; pd3dDevice-&gt;UpdateSubresource( pDestTexture, 0, &amp;destRegion, pData, rowPitch, 0 ); </code>	
        /// 	
        /// The 1D case is similar. The following snippet shows how to specify a destination region in a 1D texture. Use the same assumptions as above, except that the texture is 512 in length.	
        /// <code> D3D10_BOX destRegion;	
        /// destRegion.left = 120	
        /// destRegion.right = 200;	
        /// destRegion.top = 0;	
        /// destRegion.bottom = 1;	
        /// destRegion.front = 0;	
        /// destRegion.back = 1; pd3dDevice-&gt;UpdateSubresource( pDestTexture, 0, &amp;destRegion, pData, rowPitch, 0 ); </code>	
        /// 	
        /// Differences between Direct3D 10 and Direct3D 10.1:Direct3D 10.1 enables depth-stencil resources to be used as either a source or destination.?	
        /// </remarks>	
        /// <param name="dstResourceRef">A pointer to the destination resource (see <see cref="SlimDX2.Direct3D10.Resource"/>).</param>
        /// <param name="dstSubresource">A zero-based index, that identifies the destination subresource. See {{D3D10CalcSubresource}} for more details.</param>
        /// <param name="dstBoxRef">A box that defines the portion of the destination subresource to copy the resource data into. Coordinates are in bytes for buffers and in texels for textures. If NULL, the data is written to the destination subresource with no offset. The dimensions of the source must fit the destination (see <see cref="SlimDX2.Direct3D10.ResourceRegion"/>).</param>
        /// <param name="srcDataRef">A pointer to the source data in memory.</param>
        /// <param name="srcRowPitch">The size of one row of the source data.</param>
        /// <param name="srcDepthPitch">The size of one depth slice of source data.</param>
        /// <unmanaged>void UpdateSubresource([In] ID3D10Resource* pDstResource,[In] UINT DstSubresource,[In, Optional] const D3D10_BOX* pDstBox,[In] const void* pSrcData,[In] UINT SrcRowPitch,[In] UINT SrcDepthPitch)</unmanaged>
        public void UpdateSubresource(SlimDX2.Direct3D10.Resource dstResourceRef, int dstSubresource, SlimDX2.Direct3D10.ResourceRegion? dstBoxRef, IntPtr srcDataRef, int srcRowPitch, int srcDepthPitch) {
            unsafe {
                SlimDX2.Direct3D10.ResourceRegion dstBoxRef_;
                if (dstBoxRef.HasValue)
                    dstBoxRef_ = dstBoxRef.Value;				
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 34 * 4, (void*)((dstResourceRef == null)?IntPtr.Zero:dstResourceRef.NativePointer), dstSubresource, (dstBoxRef.HasValue)?&dstBoxRef_:(void*)IntPtr.Zero, (void*)srcDataRef, srcRowPitch, srcDepthPitch);
            }
        }
        
        /// <summary>	
        /// Set all the elements in a render target to one value.	
        /// </summary>	
        /// <remarks>	
        /// Applications that wish to clear a render target to a specific integer value bit pattern should render a screen-aligned quad instead of using this method.  The reason for this is because this method accepts as input a floating point value, which may not have the same bit pattern as the original integer.Differences between Direct3D 9 and Direct3D 10:Unlike Direct3D 9, the full extent of the resource view is always cleared. Viewport and scissor settings are not applied.?	
        /// </remarks>	
        /// <param name="renderTargetViewRef">Pointer to the rendertarget.</param>
        /// <param name="colorRGBA">A 4-component array that represents the color to fill the render target with.</param>
        /// <unmanaged>void ClearRenderTargetView([In] ID3D10RenderTargetView* pRenderTargetView,[In] const SLIMDX_COLOR4* ColorRGBA)</unmanaged>
        public void ClearRenderTargetView(SlimDX2.Direct3D10.RenderTargetView renderTargetViewRef, SlimMath.Color4 colorRGBA) {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 35 * 4, (void*)((renderTargetViewRef == null)?IntPtr.Zero:renderTargetViewRef.NativePointer), &colorRGBA);
            }
        }
        
        /// <summary>	
        /// Clears the depth-stencil resource.	
        /// </summary>	
        /// <remarks>	
        /// Differences between Direct3D 9 and Direct3D 10:Unlike Direct3D 9, the full extent of the resource view is always cleared. Viewport and scissor settings are not applied.?	
        /// </remarks>	
        /// <param name="depthStencilViewRef">Pointer to the depth stencil to be cleared.</param>
        /// <param name="clearFlags">Which parts of the buffer to clear. See <see cref="SlimDX2.Direct3D10.DepthStencilClearFlags"/>.</param>
        /// <param name="depth">Clear the depth buffer with this value. This value will be clamped between 0 and 1.</param>
        /// <param name="stencil">Clear the stencil buffer with this value.</param>
        /// <unmanaged>void ClearDepthStencilView([In] ID3D10DepthStencilView* pDepthStencilView,[In] UINT ClearFlags,[In] FLOAT Depth,[In] UINT8 Stencil)</unmanaged>
        public void ClearDepthStencilView(SlimDX2.Direct3D10.DepthStencilView depthStencilViewRef, int clearFlags, float depth, byte stencil) {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 36 * 4, (void*)((depthStencilViewRef == null)?IntPtr.Zero:depthStencilViewRef.NativePointer), clearFlags, depth, (int)stencil);
            }
        }
        
        /// <summary>	
        /// Generate mipmaps for the given shader resource.	
        /// </summary>	
        /// <remarks>	
        /// GenerateMips may be called on any ID3D10ShaderResourceView in order to generate the lower mipmap levels. GenerateMips uses the largest mipmap level of the view to recursively generate the lower levels of the mip, stopping with the smallest level specified by the view. If the base resource was not created with <see cref="SlimDX2.Direct3D10.BindFlags.RenderTarget"/> and <see cref="SlimDX2.Direct3D10.ResourceOptionFlags.GenerateMips"/>, this call has no effect.All video adapters will automatically generate mipmaps if you are using one of the following formats:	
        /// <code> DXGI_FORMAT_A8_UNORM	
        /// DXGI_FORMAT_R10G10B10A2_UNORM	
        /// DXGI_FORMAT_R11G11B10_FLOAT	
        /// DXGI_FORMAT_R16_FLOAT	
        /// DXGI_FORMAT_R16_SNORM	
        /// DXGI_FORMAT_R16_UNORM	
        /// DXGI_FORMAT_R16G16_FLOAT	
        /// DXGI_FORMAT_R16G16_SNORM	
        /// DXGI_FORMAT_R16G16_UNORM	
        /// DXGI_FORMAT_R16G16B16A16_FLOAT	
        /// DXGI_FORMAT_R16G16B16A16_SNORM	
        /// DXGI_FORMAT_R16G16B16A16_UNORM	
        /// DXGI_FORMAT_R32_FLOAT	
        /// DXGI_FORMAT_R32G32_FLOAT	
        /// DXGI_FORMAT_R32G32B32A32_FLOAT	
        /// DXGI_FORMAT_R8_SNORM	
        /// DXGI_FORMAT_R8_UNORM	
        /// DXGI_FORMAT_R8G8_SNORM	
        /// DXGI_FORMAT_R8G8_UNORM	
        /// DXGI_FORMAT_R8G8B8A8_SNORM	
        /// DXGI_FORMAT_R8G8B8A8_UNORM	
        /// DXGI_FORMAT_R8G8B8A8_UNORM_SRGB </code>	
        /// 	
        /// Some video adapters will automatically generate mipmaps for this format.	
        /// <code> DXGI_FORMAT_R32G32B32_FLOAT </code>	
        /// 	
        /// For all other unsupported formats, this method will silently fail.	
        /// </remarks>	
        /// <param name="shaderResourceViewRef">Pointer to an <see cref="SlimDX2.Direct3D10.ShaderResourceView"/>. The mipmaps will be generated for this shader resource.</param>
        /// <unmanaged>void GenerateMips([In] ID3D10ShaderResourceView* pShaderResourceView)</unmanaged>
        public void GenerateMips(SlimDX2.Direct3D10.ShaderResourceView shaderResourceViewRef) {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 37 * 4, (void*)((shaderResourceViewRef == null)?IntPtr.Zero:shaderResourceViewRef.NativePointer));
            }
        }
        
        /// <summary>	
        /// Copy a multisampled resource into a non-multisampled resource. This API is most useful when re-using the resulting rendertarget of one render pass as an input to a second render pass.	
        /// </summary>	
        /// <remarks>	
        /// Both the source and destination resources must be the same {{resource type}} and have the same dimensions.The source and destination must have compatible formats. There are three scenarios for this:ScenarioRequirementsSource and destination are prestructured and typedBoth the source and destination must have identical formats and that format must be specified in the Format parameter.One resource is prestructured and typed and the other is prestructured and typelessThe typed resource must have a format that is compatible with the typeless resource (i.e. the typed resource is DXGI_FORMAT_R32_FLOAT and the typeless resource is DXGI_FORMAT_R32_TYPELESS). The format of the typed resource must be specified in the Format parameter.Source and destination are prestructured and typelessBoth the source and desintation must have the same typeless format (i.e. both must have DXGI_FORMAT_R32_TYPELESS), and the Format parameter must specify a format that is compatible with the source and destination (i.e. if both are DXGI_FORMAT_R32_TYPELESS then DXGI_FORMAT_R32_FLOAT or DXGI_FORMAT_R32_UINT could be specified in the Format parameter).?	
        /// </remarks>	
        /// <param name="dstResourceRef">Destination resource. Must be a created with the <see cref="SlimDX2.Direct3D10.ResourceUsage.Default"/> flag and be single-sampled. See <see cref="SlimDX2.Direct3D10.Resource"/>.</param>
        /// <param name="dstSubresource">A zero-based index, that identifies the destination subresource. See {{D3D10CalcSubresource}} for more details.</param>
        /// <param name="srcResourceRef">Source resource. Must be multisampled.</param>
        /// <param name="srcSubresource">The source subresource of the source resource.</param>
        /// <param name="format"> that indicates how the multisampled resource will be resolved to a single-sampled resource. See remarks.</param>
        /// <unmanaged>void ResolveSubresource([In] ID3D10Resource* pDstResource,[In] UINT DstSubresource,[In] ID3D10Resource* pSrcResource,[In] UINT SrcSubresource,[In] DXGI_FORMAT Format)</unmanaged>
        public void ResolveSubresource(SlimDX2.Direct3D10.Resource dstResourceRef, int dstSubresource, SlimDX2.Direct3D10.Resource srcResourceRef, int srcSubresource, SlimDX2.DXGI.Format format) {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 38 * 4, (void*)((dstResourceRef == null)?IntPtr.Zero:dstResourceRef.NativePointer), dstSubresource, (void*)((srcResourceRef == null)?IntPtr.Zero:srcResourceRef.NativePointer), srcSubresource, unchecked((int)format));
            }
        }
        
        /// <summary>	
        /// Get the rendering predicate state.	
        /// </summary>	
        /// <remarks>	
        /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
        /// </remarks>	
        /// <param name="predicateRef">Address of a pointer to a predicate (see <see cref="SlimDX2.Direct3D10.Predicate"/>). Value stored here will be NULL upon device creation.</param>
        /// <param name="predicateValueRef">Address of a boolean to fill with the predicate comparison value. FALSE upon device creation.</param>
        /// <unmanaged>void GetPredication([Out, Optional] ID3D10Predicate** ppPredicate,[Out, Optional] BOOL* pPredicateValue)</unmanaged>
        public void GetPredication(out SlimDX2.Direct3D10.Predicate predicateRef, out bool predicateValueRef) {
            unsafe {
                IntPtr predicateRef_ = IntPtr.Zero;
                fixed (void* predicateValueRef_ = &predicateValueRef)
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 53 * 4, &predicateRef_, predicateValueRef_);
                predicateRef = (predicateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Predicate(predicateRef_);	
            }
        }
        
        /// <summary>	
        /// Get the reason why the device was removed.	
        /// </summary>	
        /// <returns>Possible return values include:  DXGI_ERROR_DEVICE_HUNGDXGI_ERROR_DEVICE_REMOVEDDXGI_ERROR_DEVICE_RESETDXGI_ERROR_DRIVER_INTERNAL_ERRORDXGI_ERROR_INVALID_CALLS_OKFor more detail on these return codes, see <see cref="SlimDX2.DXGI.DXGIError"/>.</returns>
        /// <unmanaged>HRESULT GetDeviceRemovedReason()</unmanaged>
        internal SlimDX2.Result GetDeviceRemovedReason() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 63 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the exception-mode flags.	
        /// </summary>	
        /// <remarks>	
        /// Set an exception-mode flag to elevate an error condition to a non-continuable exception. Whenever an error occurs, a Direct3D device enters the DEVICEREMOVED state and if the appropriate exception flag has been set, an exception is raised. A raised exception is designed to terminate an application. Before termination, the last chance an application has to persist data is by using an UnhandledExceptionFilter (see {{Structured Exception Handling}}). In general, UnhandledExceptionFilters are leveraged to try to persist data when an application is crashing (to disk, for example). Any code that executes during an UnhandledExceptionFilter is not guaranteed to reliably execute (due to possible process corruption). Any data that the UnhandledExceptionFilter manages to persist, before the UnhandledExceptionFilter crashes again, should be treated as suspect, and therefore inspected by a new, non-corrupted process to see if it is usable.	
        /// </remarks>	
        /// <param name="raiseFlags">A value that contains one or more exception flags; each flag specifies a condition which will cause an exception to be raised. The flags are listed in <see cref="SlimDX2.Direct3D10.RaiseFlags"/>. A default value of 0 means there are no flags.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetExceptionMode([None] UINT RaiseFlags)</unmanaged>
        internal SlimDX2.Result SetExceptionMode(int raiseFlags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 64 * 4, raiseFlags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the exception-mode flags.	
        /// </summary>	
        /// <remarks>	
        /// An exception-mode flag is used to elevate an error condition to a non-continuable exception. 	
        /// </remarks>	
        /// <returns>A value that contains one or more exception flags; each flag specifies a condition which will cause an exception to be raised. The flags are listed in <see cref="SlimDX2.Direct3D10.RaiseFlags"/>. A default value of 0 means there are no flags.</returns>
        /// <unmanaged>UINT GetExceptionMode()</unmanaged>
        internal int GetExceptionMode() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 65 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="guid">No documentation.</param>
        /// <param name="dataSizeRef">No documentation.</param>
        /// <param name="dataRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT GetPrivateData([In] REFGUID guid,[InOut] UINT* pDataSize,[Out, Buffer, Optional] void* pData)</unmanaged>
        public SlimDX2.Result GetPrivateData(Guid guid, ref int dataSizeRef, IntPtr dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* dataSizeRef_ = &dataSizeRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 66 * 4, &guid, dataSizeRef_, (void*)dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set data to a device and associate that data with a guid.	
        /// </summary>	
        /// <remarks>	
        /// The data stored in the device with this method can be retrieved with <see cref="SlimDX2.Direct3D10.DeviceChild.GetPrivateData"/>.The data and guid set with this method will typically be application-defined.If an application uses this method to change the device type using GUID_DeviceType, results are undefined. However, GUID_DeviceType can be used to retrieve the device type using <see cref="SlimDX2.Direct3D10.DeviceChild.GetPrivateData"/>.	
        /// </remarks>	
        /// <param name="guid">Guid associated with the data.</param>
        /// <param name="dataSize">Size of the data.</param>
        /// <param name="dataRef">Pointer to the data to be stored with this device. If pData is NULL, DataSize must also be 0, and any data previously associated with the guid will be destroyed.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetPrivateData([In] REFGUID guid,[In] UINT DataSize,[In, Buffer, Optional] const void* pData)</unmanaged>
        public SlimDX2.Result SetPrivateData(Guid guid, int dataSize, IntPtr dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 67 * 4, &guid, dataSize, (void*)dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="guid">No documentation.</param>
        /// <param name="dataRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT SetPrivateDataInterface([In] REFGUID guid,[In, Optional] const IUnknown* pData)</unmanaged>
        public SlimDX2.Result SetPrivateDataInterface(Guid guid, SlimDX2.ComObject dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 68 * 4, &guid, (void*)((dataRef == null)?IntPtr.Zero:dataRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Restore all default device settings; return the device to the state it was in when it was created. This will set all set all input/output resource slots, shaders, input layouts, predications, scissor rectangles, depth-stencil state, rasterizer state, blend state, sampler state, and viewports to NULL. The primitive topology will be set to UNDEFINED.	
        /// </summary>	
        /// <unmanaged>void ClearState()</unmanaged>
        public void ClearState() {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 69 * 4);
            }
        }
        
        /// <summary>	
        /// Send queued-up commands in the command buffer to the GPU.	
        /// </summary>	
        /// <remarks>	
        /// Most applications will not need to call this method. Calling this method when not necessary will incur a performance penalty. Each call to Flush incurs a significant amount of overhead.When Direct3D state-setting, present, or draw commands are called by an application, those commands are queued into an internal command buffer. Flush sends those commands to the GPU for processing. Normally, these commands are sent to the GPU automatically whenever Direct3D determines that they need to be, such as when the command buffer is full or when mapping a resource. Flush will send the commands manually.Flush should be used when the CPU waits for an arbitrary amount of time (such as when calling {{Sleep}}, {{ID3DX10ThreadPump::WaitForAllItems}}, or {{WaitForVBlank}}.For more information about how flushing works, see {{Accurately Profiling Direct3D API Calls (Direct3D 9)}}.	
        /// </remarks>	
        /// <unmanaged>void Flush()</unmanaged>
        public void Flush() {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 70 * 4);
            }
        }
        
        /// <summary>	
        /// Create a {{buffer}} (vertex buffer, index buffer, or shader-constant buffer).	
        /// </summary>	
        /// <remarks>	
        /// For example code, see:{{Create a Vertex Buffer}}{{Create an Index Buffer}}	
        /// </remarks>	
        /// <param name="descRef">Pointer to a buffer description (see <see cref="SlimDX2.Direct3D10.BufferDescription"/>).</param>
        /// <param name="initialDataRef">Pointer to the initialization data (see <see cref="SlimDX2.Direct3D10.SubResourceData"/>); use NULL to allocate space only.</param>
        /// <param name="bufferRef">Address of a pointer to the buffer created (see <see cref="SlimDX2.Direct3D10.Buffer"/>). Set this parameter to NULL to validate the other input parameters (S_FALSE indicates a pass).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateBuffer([In] const D3D10_BUFFER_DESC* pDesc,[In, Optional] const D3D10_SUBRESOURCE_DATA* pInitialData,[Out, Optional] ID3D10Buffer** ppBuffer)</unmanaged>
        internal SlimDX2.Result CreateBuffer(SlimDX2.Direct3D10.BufferDescription descRef, SlimDX2.Direct3D10.SubResourceData? initialDataRef, out SlimDX2.Direct3D10.Buffer bufferRef) {
            unsafe {
                SlimDX2.Direct3D10.SubResourceData initialDataRef_;
                if (initialDataRef.HasValue)
                    initialDataRef_ = initialDataRef.Value;				
                IntPtr bufferRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 71 * 4, &descRef, (initialDataRef.HasValue)?&initialDataRef_:(void*)IntPtr.Zero, &bufferRef_);
                bufferRef = (bufferRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Buffer(bufferRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create an array of 1D textures (see {{Texture1D}}).	
        /// </summary>	
        /// <remarks>	
        /// CreateTexture1D creates a 1D texture resource, which contains an array of 1D textures. The number of textures is specified in the texture description. All textures in a resource must have the same format, size, and number of mipmap levels.All resources are made up of one or more {{subresources}}. To load data into the texture, applications may supply the data initially as part of <see cref="SlimDX2.Direct3D10.SubResourceData"/> structure pointed to by pInitialData, or it may use one of the {{Texturing Functions}} supplied by the SDK.	
        /// </remarks>	
        /// <param name="descRef">Pointer to a 1D texture description (see <see cref="SlimDX2.Direct3D10.Texture1DDescription"/>). To create a typeless resource that can be interpreted at runtime into different, compatible formats, specify a typeless format in the texture description. To generate mipmap levels automatically, set the number of mipmap levels to 0.</param>
        /// <param name="initialDataRef">Pointer to an array of {{subresource}} descriptions (see <see cref="SlimDX2.Direct3D10.SubResourceData"/>); one for each subresource (ordered by texture array index). Applications may not specify NULL for pInitialData when creating IMMUTABLE resources (see <see cref="SlimDX2.Direct3D10.ResourceUsage"/>). If the resource is multisampled, pInitialData must be NULL because multisampled resources cannot be initialized with data when they are created.</param>
        /// <param name="texture1DRef">Address of a pointer to the created texture (see <see cref="SlimDX2.Direct3D10.Texture1D"/>). Set this parameter to NULL to validate the other input parameters (the method will return S_FALSE if the other input parameters pass validation).</param>
        /// <returns>If the method succeeds, the return code is S_OK. See {{Direct3D 10 Return Codes}} for failing error codes.</returns>
        /// <unmanaged>HRESULT CreateTexture1D([In] const D3D10_TEXTURE1D_DESC* pDesc,[In, Buffer, Optional] const D3D10_SUBRESOURCE_DATA* pInitialData,[Out] ID3D10Texture1D** ppTexture1D)</unmanaged>
        internal SlimDX2.Result CreateTexture1D(ref SlimDX2.Direct3D10.Texture1DDescription descRef, SlimDX2.Direct3D10.SubResourceData[] initialDataRef, out SlimDX2.Direct3D10.Texture1D texture1DRef) {
            unsafe {
                SlimDX2.Direct3D10.SubResourceData[] initialDataRef__ = initialDataRef ?? new SlimDX2.Direct3D10.SubResourceData[1];
                IntPtr texture1DRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    fixed (void* initialDataRef_ = &initialDataRef__[0])
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 72 * 4, descRef_, initialDataRef==null?(void*)IntPtr.Zero:initialDataRef_, &texture1DRef_);
                texture1DRef = (texture1DRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Texture1D(texture1DRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create an array of 2D textures (see {{Texture2D}}).	
        /// </summary>	
        /// <remarks>	
        /// CreateTexture2D creates a 2D texture resource, which contains an array of 1D textures. The number of textures is specified in the texture description. All textures in a resource must have the same format, size, and number of mipmap levels.All resources are made up of one or more {{subresources}}. To load data into the texture, applications may supply the data initially as part of <see cref="SlimDX2.Direct3D10.SubResourceData"/> structure pointed to by pInitialData, or it may use one of the {{Texturing Functions}} supplied by the SDK.	
        /// </remarks>	
        /// <param name="descRef">Pointer to a 2D texture description (see <see cref="SlimDX2.Direct3D10.Texture2DDescription"/>). To create a typeless resource that can be interpreted at runtime into different, compatible formats, specify a typeless format in the texture description. To generate mipmap levels automatically, set the number of mipmap levels to 0.</param>
        /// <param name="initialDataRef">Pointer to an array of {{subresource}} descriptions (see <see cref="SlimDX2.Direct3D10.SubResourceData"/>); one for each subresource (ordered by texture array index, then mip level). Applications may not specify NULL for pInitialData when creating IMMUTABLE resources (see <see cref="SlimDX2.Direct3D10.ResourceUsage"/>). If the resource is multisampled, pInitialData must be NULL because multisampled resources cannot be initialized with data when they are created.</param>
        /// <param name="texture2DRef">Address of a pointer to the created texture (see <see cref="SlimDX2.Direct3D10.Texture2D"/>). Set this parameter to NULL to validate the other input parameters (the method will return S_FALSE if the other input parameters pass validation).</param>
        /// <returns>If the method succeeds, the return code is S_OK. See {{Direct3D 10 Return Codes}} for failing error codes.</returns>
        /// <unmanaged>HRESULT CreateTexture2D([In] const D3D10_TEXTURE2D_DESC* pDesc,[In, Buffer, Optional] const D3D10_SUBRESOURCE_DATA* pInitialData,[Out] ID3D10Texture2D** ppTexture2D)</unmanaged>
        internal SlimDX2.Result CreateTexture2D(ref SlimDX2.Direct3D10.Texture2DDescription descRef, SlimDX2.Direct3D10.SubResourceData[] initialDataRef, out SlimDX2.Direct3D10.Texture2D texture2DRef) {
            unsafe {
                SlimDX2.Direct3D10.SubResourceData[] initialDataRef__ = initialDataRef ?? new SlimDX2.Direct3D10.SubResourceData[1];
                IntPtr texture2DRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    fixed (void* initialDataRef_ = &initialDataRef__[0])
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 73 * 4, descRef_, initialDataRef==null?(void*)IntPtr.Zero:initialDataRef_, &texture2DRef_);
                texture2DRef = (texture2DRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Texture2D(texture2DRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a single 3D texture (see {{Texture3D}}).	
        /// </summary>	
        /// <remarks>	
        /// CreateTexture3D creates a 3D texture resource, which contains an array of 1D textures. The number of textures is specified in the texture description. All textures in a resource must have the same format, size, and number of mipmap levels.All resources are made up of one or more {{subresources}}. To load data into the texture, applications may supply the data initially as part of <see cref="SlimDX2.Direct3D10.SubResourceData"/> structure pointed to by pInitialData, or it may use one of the {{Texturing Functions}} supplied by the SDK.	
        /// </remarks>	
        /// <param name="descRef">Pointer to a 3D texture description (see <see cref="SlimDX2.Direct3D10.Texture3DDescription"/>). To create a typeless resource that can be interpreted at runtime into different, compatible formats, specify a typeless format in the texture description. To generate mipmap levels automatically, set the number of mipmap levels to 0.</param>
        /// <param name="initialDataRef">Pointer to an array of {{subresource}} descriptions (see <see cref="SlimDX2.Direct3D10.SubResourceData"/>); one for each subresource (ordered by texture array index, then slice index, then mip level). Applications may not specify NULL for pInitialData when creating IMMUTABLE resources (see <see cref="SlimDX2.Direct3D10.ResourceUsage"/>). If the resource is multisampled, pInitialData must be NULL because multisampled resources cannot be initialized with data when they are created.</param>
        /// <param name="texture3DRef">Address of a pointer to the created texture (see <see cref="SlimDX2.Direct3D10.Texture3D"/>). Set this parameter to NULL to validate the other input parameters (the method will return S_FALSE if the other input parameters pass validation).</param>
        /// <returns>If the method succeeds, the return code is S_OK. See {{Direct3D 10 Return Codes}} for failing error codes.</returns>
        /// <unmanaged>HRESULT CreateTexture3D([In] const D3D10_TEXTURE3D_DESC* pDesc,[In, Buffer, Optional] const D3D10_SUBRESOURCE_DATA* pInitialData,[Out] ID3D10Texture3D** ppTexture3D)</unmanaged>
        internal SlimDX2.Result CreateTexture3D(ref SlimDX2.Direct3D10.Texture3DDescription descRef, SlimDX2.Direct3D10.SubResourceData[] initialDataRef, out SlimDX2.Direct3D10.Texture3D texture3DRef) {
            unsafe {
                SlimDX2.Direct3D10.SubResourceData[] initialDataRef__ = initialDataRef ?? new SlimDX2.Direct3D10.SubResourceData[1];
                IntPtr texture3DRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    fixed (void* initialDataRef_ = &initialDataRef__[0])
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 74 * 4, descRef_, initialDataRef==null?(void*)IntPtr.Zero:initialDataRef_, &texture3DRef_);
                texture3DRef = (texture3DRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Texture3D(texture3DRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a shader-resource {{view}} for accessing data in a resource.	
        /// </summary>	
        /// <remarks>	
        /// A resource is made up of one or more {{subresources}}, a view identifies which subresources to allow the pipeline to access. In addition, each resource is bound to the pipeline using a view. A shader-resource view is designed to bind any buffer or texture resource to the {{shader stages}} using the following API methods: {{VSSetShaderResources}}, {{GSSetShaderResources}} and {{PSSetShaderResources}}.Since a view is fully typed, this means that typeless resources become fully typed when bound to the pipeline.	
        /// </remarks>	
        /// <param name="resourceRef">Pointer to the {{resource}} that will serve as input to a shader. This resource must have been created with the <see cref="SlimDX2.Direct3D10.BindFlags.ShaderResource"/> flag.</param>
        /// <param name="descRef">Pointer to a shader-resource-view description (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription"/>). Set this parameter to NULL to create a view that accesses the entire resource (using the format the resource was created with).</param>
        /// <param name="sRViewRef">Address of a pointer to an <see cref="SlimDX2.Direct3D10.ShaderResourceView"/>. Set this parameter to NULL to validate the other input parameters (the method will return S_FALSE if the other input parameters pass validation).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateShaderResourceView([In] ID3D10Resource* pResource,[In, Optional] const D3D10_SHADER_RESOURCE_VIEW_DESC* pDesc,[Out, Optional] ID3D10ShaderResourceView** ppSRView)</unmanaged>
        internal SlimDX2.Result CreateShaderResourceView(SlimDX2.Direct3D10.Resource resourceRef, SlimDX2.Direct3D10.ShaderResourceViewDescription? descRef, out SlimDX2.Direct3D10.ShaderResourceView sRViewRef) {
            unsafe {
                SlimDX2.Direct3D10.ShaderResourceViewDescription descRef_;
                if (descRef.HasValue)
                    descRef_ = descRef.Value;				
                IntPtr sRViewRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 75 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), (descRef.HasValue)?&descRef_:(void*)IntPtr.Zero, &sRViewRef_);
                sRViewRef = (sRViewRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.ShaderResourceView(sRViewRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a render-target {{view}} for accessing resource data.	
        /// </summary>	
        /// <remarks>	
        /// A rendertarget view can be bound to the {{output merger stage}} by calling <see cref="SlimDX2.Direct3D10.Device.OutputMergerStage.SetRenderTargets"/>.	
        /// </remarks>	
        /// <param name="resourceRef">Pointer to the {{resource}} that will serve as the render target. This resource must have been created with the <see cref="SlimDX2.Direct3D10.BindFlags.RenderTarget"/> flag.</param>
        /// <param name="descRef">Pointer to a render-target-view description (see <see cref="SlimDX2.Direct3D10.RenderTargetViewDescription"/>). Set this parameter to NULL to create a view that accesses mipmap level 0 of the entire resource (using the format the resource was created with).</param>
        /// <param name="rTViewRef">Address of a pointer to an <see cref="SlimDX2.Direct3D10.RenderTargetView"/>. Set this parameter to NULL to validate the other input parameters (the method will return S_FALSE if the other input parameters pass validation).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateRenderTargetView([In] ID3D10Resource* pResource,[In, Optional] const D3D10_RENDER_TARGET_VIEW_DESC* pDesc,[Out, Optional] ID3D10RenderTargetView** ppRTView)</unmanaged>
        internal SlimDX2.Result CreateRenderTargetView(SlimDX2.Direct3D10.Resource resourceRef, SlimDX2.Direct3D10.RenderTargetViewDescription? descRef, out SlimDX2.Direct3D10.RenderTargetView rTViewRef) {
            unsafe {
                SlimDX2.Direct3D10.RenderTargetViewDescription descRef_;
                if (descRef.HasValue)
                    descRef_ = descRef.Value;				
                IntPtr rTViewRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 76 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), (descRef.HasValue)?&descRef_:(void*)IntPtr.Zero, &rTViewRef_);
                rTViewRef = (rTViewRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.RenderTargetView(rTViewRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a depth-stencil {{view}} for accessing resource data.	
        /// </summary>	
        /// <remarks>	
        /// A depth-stencil view can be bound to the {{output-merger stage}} by calling <see cref="SlimDX2.Direct3D10.Device.OutputMergerStage.SetRenderTargets"/>.For more background information, see the {{programming guide page}} about depth stencils.	
        /// </remarks>	
        /// <param name="resourceRef">Pointer to the {{resource}} that will serve as the depth-stencil surface. This resource must have been created with the <see cref="SlimDX2.Direct3D10.BindFlags.DepthStencil"/> flag.</param>
        /// <param name="descRef">Pointer to a depth-stencil-view description (see <see cref="SlimDX2.Direct3D10.DepthStencilViewDescription"/>). Set this parameter to NULL to create a view that accesses mipmap level 0 of the entire resource (using the format the resource was created with).</param>
        /// <param name="depthStencilViewRef">Address of a pointer to an <see cref="SlimDX2.Direct3D10.DepthStencilView"/>. Set this parameter to NULL to validate the other input parameters (the method will return S_FALSE if the other input parameters pass validation).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateDepthStencilView([In] ID3D10Resource* pResource,[In, Optional] const D3D10_DEPTH_STENCIL_VIEW_DESC* pDesc,[Out, Optional] ID3D10DepthStencilView** ppDepthStencilView)</unmanaged>
        internal SlimDX2.Result CreateDepthStencilView(SlimDX2.Direct3D10.Resource resourceRef, SlimDX2.Direct3D10.DepthStencilViewDescription? descRef, out SlimDX2.Direct3D10.DepthStencilView depthStencilViewRef) {
            unsafe {
                SlimDX2.Direct3D10.DepthStencilViewDescription descRef_;
                if (descRef.HasValue)
                    descRef_ = descRef.Value;				
                IntPtr depthStencilViewRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 77 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), (descRef.HasValue)?&descRef_:(void*)IntPtr.Zero, &depthStencilViewRef_);
                depthStencilViewRef = (depthStencilViewRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.DepthStencilView(depthStencilViewRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create an input-layout object to describe the input-buffer data for the {{input-assembler stage}}.	
        /// </summary>	
        /// <remarks>	
        /// After creating an input layout object, it must be bound to the input-assembler stage before calling a draw API. See {{Getting Started with the Input-Assembler Stage (Direct3D 10)}} for example code.Once an input-layout object is created from a shader signature, the input-layout object can be reused with any other shader that has an identical input signature (semantics included). This can simplify the creation of input-layout objects when you are working with many shaders with identical inputs.If a data type in the input-layout declaration does not match the data type in a shader-input signature, CreateInputLayout will generate a warning during compilation. The warning is simply to call attention to the fact that the data may be reinterpreted when read from a register. You may either disregard this warning (if reinterpretation is intentional) or make the data types match in both declarations to eliminate the warning.  The {{Data Conversion Rules}} overview describes the rules applied for data type conversion.Differences between Direct3D 9 and Direct3D 10:Mapping the vertex data to the shader inputs with an input layout is a new way of doing things in Direct3D 10 that improves performance.In Direct3D 10 the vertex data is mapped to the shader inputs when the input layout object is created, whereas in Direct3D 9 this mapping was done at Draw time based on the currently bound vertex declarations, vertex buffers, and vertex shaders. Doing this mapping when the input layout object is created reduces or eliminates extra linkage work for drivers at Draw time because this re-mapping is no longer necessary.?	
        /// </remarks>	
        /// <param name="inputElementDescsRef">An array of the input-assembler stage input data types; each type is described by an element description (see <see cref="SlimDX2.Direct3D10.InputElement"/>).</param>
        /// <param name="numElements">The number of input-data types in the array of input-elements.</param>
        /// <param name="shaderBytecodeWithInputSignatureRef">A pointer to the compiled shader. To get this pointer see {{Getting a Pointer to a Compiled Shader}}. The compiled shader code contains a {{input signature}} which is validated against the array of elements. See remarks.</param>
        /// <param name="bytecodeLength">Size of the compiled shader.</param>
        /// <param name="inputLayoutRef">A pointer to the input-layout object created (see <see cref="SlimDX2.Direct3D10.InputLayout"/>). To validate the other input parameters, set this pointer to be NULL and verify that the method returns S_FALSE.</param>
        /// <returns>If the method succeeds, the return code is S_OK. See {{Direct3D 10 Return Codes}} for failing error codes.</returns>
        /// <unmanaged>HRESULT CreateInputLayout([In, Buffer] const D3D10_INPUT_ELEMENT_DESC* pInputElementDescs,[In] UINT NumElements,[In] const void* pShaderBytecodeWithInputSignature,[In] SIZE_T BytecodeLength,[Out, Optional] ID3D10InputLayout** ppInputLayout)</unmanaged>
        internal SlimDX2.Result CreateInputLayout(SlimDX2.Direct3D10.InputElement[] inputElementDescsRef, int numElements, IntPtr shaderBytecodeWithInputSignatureRef, SlimDX2.Size bytecodeLength, out SlimDX2.Direct3D10.InputLayout inputLayoutRef) {
            unsafe {
                SlimDX2.Direct3D10.InputElement.__Native[] inputElementDescsRef__ = new SlimDX2.Direct3D10.InputElement.__Native[inputElementDescsRef.Length];
                for (int i = 0; i < inputElementDescsRef.Length; i++)
                    inputElementDescsRef[i].__MarshalTo(ref inputElementDescsRef__[i]);				
                IntPtr inputLayoutRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* inputElementDescsRef_ = &inputElementDescsRef__[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 78 * 4, inputElementDescsRef_, numElements, (void*)shaderBytecodeWithInputSignatureRef, (void*)bytecodeLength, &inputLayoutRef_);
                for (int i = 0; i < inputElementDescsRef.Length; i++)
                    inputElementDescsRef__[i].__MarshalFree();				
                inputLayoutRef = (inputLayoutRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.InputLayout(inputLayoutRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a vertex-shader object from a compiled shader.	
        /// </summary>	
        /// <param name="shaderBytecodeRef">A pointer to the compiled shader. To get this pointer see {{Getting a Pointer to a Compiled Shader}}.</param>
        /// <param name="bytecodeLength">Size of the compiled vertex shader.</param>
        /// <param name="vertexShaderRef">Address of a pointer to an <see cref="SlimDX2.Direct3D10.VertexShader"/>. If this is NULL, all other parameters will be validated, and if all parameters pass validation this API will return S_FALSE instead of S_OK.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateVertexShader([In] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[Out, Optional] ID3D10VertexShader** ppVertexShader)</unmanaged>
        internal SlimDX2.Result CreateVertexShader(IntPtr shaderBytecodeRef, SlimDX2.Size bytecodeLength, out SlimDX2.Direct3D10.VertexShader vertexShaderRef) {
            unsafe {
                IntPtr vertexShaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 79 * 4, (void*)shaderBytecodeRef, (void*)bytecodeLength, &vertexShaderRef_);
                vertexShaderRef = (vertexShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.VertexShader(vertexShaderRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a geometry shader.	
        /// </summary>	
        /// <remarks>	
        /// Once created, the shader can be set to the device by calling <see cref="SlimDX2.Direct3D10.Device.GeometryShaderStage.Set"/>.	
        /// </remarks>	
        /// <param name="shaderBytecodeRef">A pointer to the compiled shader. To get this pointer see {{Getting a Pointer to a Compiled Shader}}.</param>
        /// <param name="bytecodeLength">Size of the compiled geometry shader.</param>
        /// <param name="geometryShaderRef">Address of a pointer to an <see cref="SlimDX2.Direct3D10.GeometryShader"/>.  If this is NULL, all other parameters will be validated, and if all parameters pass validation this API will return S_FALSE instead of S_OK.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateGeometryShader([In] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[Out, Optional] ID3D10GeometryShader** ppGeometryShader)</unmanaged>
        internal SlimDX2.Result CreateGeometryShader(IntPtr shaderBytecodeRef, SlimDX2.Size bytecodeLength, out SlimDX2.Direct3D10.GeometryShader geometryShaderRef) {
            unsafe {
                IntPtr geometryShaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 80 * 4, (void*)shaderBytecodeRef, (void*)bytecodeLength, &geometryShaderRef_);
                geometryShaderRef = (geometryShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.GeometryShader(geometryShaderRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a geometry shader that can write to streaming output buffers.	
        /// </summary>	
        /// <param name="shaderBytecodeRef">A pointer to the compiled shader. To get this pointer see {{Getting a Pointer to a Compiled Shader}}.</param>
        /// <param name="bytecodeLength">Size of the compiled geometry shader.</param>
        /// <param name="sODeclarationRef">Pointer to a <see cref="SlimDX2.Direct3D10.StreamOutputElement"/> array. Cannot be NULL if NumEntries&gt; 0.</param>
        /// <param name="numEntries">The number of entries in the array pointed to by pSODeclaration. Minimum 0, maximum 64.</param>
        /// <param name="outputStreamStride">The size, in bytes, of each element in the array pointed to by pSODeclaration. This parameter is only used when the output slot is 0 for all entries in pSODeclaration.</param>
        /// <param name="geometryShaderRef">Address of a pointer to an <see cref="SlimDX2.Direct3D10.GeometryShader"/>. If this is NULL, all other parameters will be validated, and if all parameters pass validation this API will return S_FALSE instead of S_OK.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateGeometryShaderWithStreamOutput([In] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In, Buffer, Optional] const D3D10_SO_DECLARATION_ENTRY* pSODeclaration,[In] UINT NumEntries,[In] UINT OutputStreamStride,[Out, Optional] ID3D10GeometryShader** ppGeometryShader)</unmanaged>
        internal SlimDX2.Result CreateGeometryShaderWithStreamOutput(IntPtr shaderBytecodeRef, SlimDX2.Size bytecodeLength, SlimDX2.Direct3D10.StreamOutputElement[] sODeclarationRef, int numEntries, int outputStreamStride, out SlimDX2.Direct3D10.GeometryShader geometryShaderRef) {
            unsafe {
                SlimDX2.Direct3D10.StreamOutputElement.__Native[] sODeclarationRef__ = new SlimDX2.Direct3D10.StreamOutputElement.__Native[sODeclarationRef.Length];
                for (int i = 0; i < sODeclarationRef.Length; i++)
                    sODeclarationRef[i].__MarshalTo(ref sODeclarationRef__[i]);				
                IntPtr geometryShaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* sODeclarationRef_ = &sODeclarationRef__[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 81 * 4, (void*)shaderBytecodeRef, (void*)bytecodeLength, sODeclarationRef_, numEntries, outputStreamStride, &geometryShaderRef_);
                for (int i = 0; i < sODeclarationRef.Length; i++)
                    sODeclarationRef__[i].__MarshalFree();				
                geometryShaderRef = (geometryShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.GeometryShader(geometryShaderRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a pixel shader.	
        /// </summary>	
        /// <remarks>	
        /// After creating the pixel shader, you can set it to the device using <see cref="SlimDX2.Direct3D10.Device.PixelShaderStage.Set"/>.	
        /// </remarks>	
        /// <param name="shaderBytecodeRef">A pointer to the compiled shader. To get this pointer see {{Getting a Pointer to a Compiled Shader}}.</param>
        /// <param name="bytecodeLength">Size of the compiled pixel shader.</param>
        /// <param name="pixelShaderRef">Address of a pointer to an <see cref="SlimDX2.Direct3D10.PixelShader"/>. If this is NULL, all other parameters will be validated, and if all parameters pass validation this API will return S_FALSE instead of S_OK.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreatePixelShader([In] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[Out, Optional] ID3D10PixelShader** ppPixelShader)</unmanaged>
        internal SlimDX2.Result CreatePixelShader(IntPtr shaderBytecodeRef, SlimDX2.Size bytecodeLength, out SlimDX2.Direct3D10.PixelShader pixelShaderRef) {
            unsafe {
                IntPtr pixelShaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 82 * 4, (void*)shaderBytecodeRef, (void*)bytecodeLength, &pixelShaderRef_);
                pixelShaderRef = (pixelShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.PixelShader(pixelShaderRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a blend-state object that encapsules blend state for the output-merger stage.	
        /// </summary>	
        /// <remarks>	
        /// An application can create up to 4096 unique blend-state objects. For each object created, the runtime checks to see if a previous object has the same state. If such a previous object exists, the runtime will return a pointer to previous instance instead of creating a duplicate object.	
        /// </remarks>	
        /// <param name="blendStateDescRef">Pointer to a blend-state description (see <see cref="SlimDX2.Direct3D10.BlendStateDescription"/>).</param>
        /// <param name="blendStateRef">Address of a pointer to the blend-state object created (see <see cref="SlimDX2.Direct3D10.BlendState"/>).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateBlendState([In] const D3D10_BLEND_DESC* pBlendStateDesc,[Out, Optional] ID3D10BlendState** ppBlendState)</unmanaged>
        internal SlimDX2.Result CreateBlendState(ref SlimDX2.Direct3D10.BlendStateDescription blendStateDescRef, out SlimDX2.Direct3D10.BlendState blendStateRef) {
            unsafe {
                SlimDX2.Direct3D10.BlendStateDescription.__Native blendStateDescRef_ = new SlimDX2.Direct3D10.BlendStateDescription.__Native();
                blendStateDescRef.__MarshalTo(ref blendStateDescRef_);
                IntPtr blendStateRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 83 * 4, &blendStateDescRef_, &blendStateRef_);
                blendStateDescRef_.__MarshalFree();
                blendStateRef = (blendStateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.BlendState(blendStateRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a depth-stencil state object that encapsulates {{depth-stencil test}} information for the output-merger stage.	
        /// </summary>	
        /// <remarks>	
        /// 4096 unique depth-stencil state objects can be created on a device at a time.If an application attempts to create a depth-stencil state with the same description as an already existing depth-stencil state, then the same interface with an incremented reference count will be returned and the total number of unique depth-stencil state objects will stay the same.	
        /// </remarks>	
        /// <param name="depthStencilDescRef">Pointer to a depth-stencil state description (see <see cref="SlimDX2.Direct3D10.DepthStencilStateDescription"/>).</param>
        /// <param name="depthStencilStateRef">Address of a pointer to the depth-stencil state object created (see <see cref="SlimDX2.Direct3D10.DepthStencilState"/>).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateDepthStencilState([In] const D3D10_DEPTH_STENCIL_DESC* pDepthStencilDesc,[Out, Optional] ID3D10DepthStencilState** ppDepthStencilState)</unmanaged>
        internal SlimDX2.Result CreateDepthStencilState(ref SlimDX2.Direct3D10.DepthStencilStateDescription depthStencilDescRef, out SlimDX2.Direct3D10.DepthStencilState depthStencilStateRef) {
            unsafe {
                IntPtr depthStencilStateRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* depthStencilDescRef_ = &depthStencilDescRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 84 * 4, depthStencilDescRef_, &depthStencilStateRef_);
                depthStencilStateRef = (depthStencilStateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.DepthStencilState(depthStencilStateRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a rasterizer state object that tells the {{rasterizer stage}} how to behave.	
        /// </summary>	
        /// <remarks>	
        /// 4096 unique rasterizer state objects can be created on a device at a time.If an application attempts to create a rasterizer state with the same description as an already existing rasterizer state, then the same interface with an incremented reference count will be returned and the total number of unique rasterizer state objects will stay the same.	
        /// </remarks>	
        /// <param name="rasterizerDescRef">Pointer to a rasterizer state description (see <see cref="SlimDX2.Direct3D10.RasterizerStateDescription"/>).</param>
        /// <param name="rasterizerStateRef">Address of a pointer to the rasterizer state object created (see <see cref="SlimDX2.Direct3D10.RasterizerState"/>).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateRasterizerState([In] const D3D10_RASTERIZER_DESC* pRasterizerDesc,[Out, Optional] ID3D10RasterizerState** ppRasterizerState)</unmanaged>
        internal SlimDX2.Result CreateRasterizerState(ref SlimDX2.Direct3D10.RasterizerStateDescription rasterizerDescRef, out SlimDX2.Direct3D10.RasterizerState rasterizerStateRef) {
            unsafe {
                IntPtr rasterizerStateRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* rasterizerDescRef_ = &rasterizerDescRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 85 * 4, rasterizerDescRef_, &rasterizerStateRef_);
                rasterizerStateRef = (rasterizerStateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.RasterizerState(rasterizerStateRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a sampler-state object that encapsulates sampling information for a {{texture}}.	
        /// </summary>	
        /// <remarks>	
        /// 4096 unique sampler state objects can be created on a device at a time.If an application attempts to create a sampler state with the same description as an already existing sampler state, then the same interface with an incremented reference count will be returned and the total number of unique sampler state objects will stay the same.	
        /// </remarks>	
        /// <param name="samplerDescRef">Pointer to a sampler state description (see <see cref="SlimDX2.Direct3D10.SamplerStateDescription"/>).</param>
        /// <param name="samplerStateRef">Address of a pointer to the sampler state object created (see <see cref="SlimDX2.Direct3D10.SamplerState"/>).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateSamplerState([In] const D3D10_SAMPLER_DESC* pSamplerDesc,[Out, Optional] ID3D10SamplerState** ppSamplerState)</unmanaged>
        internal SlimDX2.Result CreateSamplerState(ref SlimDX2.Direct3D10.SamplerStateDescription samplerDescRef, out SlimDX2.Direct3D10.SamplerState samplerStateRef) {
            unsafe {
                IntPtr samplerStateRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* samplerDescRef_ = &samplerDescRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 86 * 4, samplerDescRef_, &samplerStateRef_);
                samplerStateRef = (samplerStateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.SamplerState(samplerStateRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// This interface encapsulates methods for querying information from the GPU.	
        /// </summary>	
        /// <param name="queryDescRef">Pointer to a query description (see <see cref="SlimDX2.Direct3D10.QueryDescription"/>).</param>
        /// <param name="queryRef">Address of a pointer to the query object created (see <see cref="SlimDX2.Direct3D10.Query"/>).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateQuery([In] const D3D10_QUERY_DESC* pQueryDesc,[Out, Optional] ID3D10Query** ppQuery)</unmanaged>
        internal SlimDX2.Result CreateQuery(SlimDX2.Direct3D10.QueryDescription queryDescRef, out SlimDX2.Direct3D10.Query queryRef) {
            unsafe {
                IntPtr queryRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 87 * 4, &queryDescRef, &queryRef_);
                queryRef = (queryRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Query(queryRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a predicate.	
        /// </summary>	
        /// <param name="predicateDescRef">Pointer to a query description where the type of query must be a D3D10_QUERY_SO_OVERFLOW_PREDICATE or D3D10_QUERY_OCCLUSION_PREDICATE (see <see cref="SlimDX2.Direct3D10.QueryDescription"/>).</param>
        /// <param name="predicateRef">Address of a pointer to a predicate (see <see cref="SlimDX2.Direct3D10.Predicate"/>).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreatePredicate([In] const D3D10_QUERY_DESC* pPredicateDesc,[Out, Optional] ID3D10Predicate** ppPredicate)</unmanaged>
        internal SlimDX2.Result CreatePredicate(SlimDX2.Direct3D10.QueryDescription predicateDescRef, out SlimDX2.Direct3D10.Predicate predicateRef) {
            unsafe {
                IntPtr predicateRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 88 * 4, &predicateDescRef, &predicateRef_);
                predicateRef = (predicateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Predicate(predicateRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a counter object for measuring GPU performance.	
        /// </summary>	
        /// <param name="counterDescRef">Pointer to a counter description (see <see cref="SlimDX2.Direct3D10.CounterDescription"/>).</param>
        /// <param name="counterRef">Address of a pointer to a counter (see <see cref="SlimDX2.Direct3D10.Counter"/>).</param>
        /// <returns>If this function succeeds, it will return S_OK. If it fails, possible return values are: S_FALSE, E_OUTOFMEMORY, DXGI_ERROR_UNSUPPORTED, DXGI_ERROR_NONEXCLUSIVE, or E_INVALIDARG.DXGI_ERROR_UNSUPPORTED is returned whenever the application requests to create a well-known counter, but the current device does not support it.DXGI_ERROR_NONEXCLUSIVE indicates that another device object is currently using the counters, so they cannot be used by this device at the moment.E_INVALIDARG is returned whenever an out-of-range well-known or device-dependent counter is requested, or when the simulataneously active counters have been exhausted.</returns>
        /// <unmanaged>HRESULT CreateCounter([In] const D3D10_COUNTER_DESC* pCounterDesc,[Out, Optional] ID3D10Counter** ppCounter)</unmanaged>
        internal SlimDX2.Result CreateCounter(SlimDX2.Direct3D10.CounterDescription counterDescRef, out SlimDX2.Direct3D10.Counter counterRef) {
            unsafe {
                IntPtr counterRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 89 * 4, &counterDescRef, &counterRef_);
                counterRef = (counterRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Counter(counterRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the support of a given format on the installed video device.	
        /// </summary>	
        /// <remarks>	
        /// Most format support is based on the Direct3D feature level. Only a few specific use cases require checking for support.  See {{Hardware Support for Direct3D 10 Formats}} and {{Hardware Support for Direct3D 10.1 Formats}} for additional information.	
        /// </remarks>	
        /// <param name="format">A <see cref="SlimDX2.DXGI.Format"/> enumeration that describes a format for which to check for support.</param>
        /// <param name="formatSupportRef">A bitfield of <see cref="SlimDX2.Direct3D10.FormatSupport"/> enumeration values describing how the specified format is supported on the installed device.  The values are ORed together.</param>
        /// <returns>Returns S_OK if successful; otherwise, returns E_INVALIDARG if the Format parameter is NULL, or returns E_FAIL if the described  format does not exist.</returns>
        /// <unmanaged>HRESULT CheckFormatSupport([In] DXGI_FORMAT Format,[Out] UINT* pFormatSupport)</unmanaged>
        public SlimDX2.Result CheckFormatSupport(SlimDX2.DXGI.Format format, out int formatSupportRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* formatSupportRef_ = &formatSupportRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 90 * 4, unchecked((int)format), formatSupportRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the number of quality levels available during multisampling.	
        /// </summary>	
        /// <remarks>	
        /// When multisampling a texture, the number of quality levels available for an adapter is dependent on the texture format used and the number of samples requested. The maximum sample count defined by D3D10_MAX_MULTISAMPLE_SAMPLE_COUNT in d3d10.h is 32. If the returned value of pNumQualityLevels is 0, the format and sample count combination is not supported for the installed adapter.Furthermore, the definition of a quality level is up to each hardware vendor to define, however no facility is provided by Direct3D to help discover  this information.Direct3D 10.1 devices are required to support 4x MSAA for all formats except R32G32B32A32 and R32G32B32 formats.	
        /// </remarks>	
        /// <param name="format">The texture format. See <see cref="SlimDX2.DXGI.Format"/>.</param>
        /// <param name="sampleCount">The number of samples during multisampling.</param>
        /// <param name="numQualityLevelsRef">Number of quality levels supported by the adapter. See remarks.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CheckMultisampleQualityLevels([In] DXGI_FORMAT Format,[In] UINT SampleCount,[Out] UINT* pNumQualityLevels)</unmanaged>
        public SlimDX2.Result CheckMultisampleQualityLevels(SlimDX2.DXGI.Format format, int sampleCount, out int numQualityLevelsRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* numQualityLevelsRef_ = &numQualityLevelsRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 91 * 4, unchecked((int)format), sampleCount, numQualityLevelsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a counter's information.	
        /// </summary>	
        /// <param name="counterInfoRef">Pointer to counter information (see <see cref="SlimDX2.Direct3D10.CounterInformation"/>).</param>
        /// <unmanaged>void CheckCounterInfo([Out] D3D10_COUNTER_INFO* pCounterInfo)</unmanaged>
        public void CheckCounterInfo(out SlimDX2.Direct3D10.CounterInformation counterInfoRef) {
            unsafe {
                counterInfoRef = new SlimDX2.Direct3D10.CounterInformation();
                fixed (void* counterInfoRef_ = &counterInfoRef)
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 92 * 4, counterInfoRef_);
            }
        }
        
        /// <summary>	
        /// Get the type, name, units of measure, and a description of an existing counter.	
        /// </summary>	
        /// <remarks>	
        /// Length parameters can be NULL, which indicates the application is not interested in the length nor the corresponding string value. When a length parameter is non-NULL and the corresponding string is NULL, the input value of the length parameter is ignored, and the length of the corresponding string (including terminating NULL) will be returned through the length parameter. When length and the corresponding parameter are both non-NULL, the input value of length is checked to ensure there is enough room, and then the length of the string (including terminating NULL character) is passed out through the length parameter.	
        /// </remarks>	
        /// <param name="descRef">Pointer to a counter description (see <see cref="SlimDX2.Direct3D10.CounterDescription"/>). Specifies which counter information is to be retrieved about.</param>
        /// <param name="typeRef">Pointer to the data type of a counter (see <see cref="SlimDX2.Direct3D10.CounterType"/>). Specifies the data type of the counter being retrieved.</param>
        /// <param name="activeCountersRef">Pointer to the number of hardware counters that are needed for this counter type to be created. All instances of the same counter type use the same hardware counters.</param>
        /// <param name="szName">String to be filled with a brief name for the counter. May be NULL if the application is not interested in the name of the counter.</param>
        /// <param name="nameLengthRef">Length of the string returned to szName. Can be NULL.</param>
        /// <param name="szUnits">Name of the units a counter measures, provided the memory the pointer points to has enough room to hold the string. Can be NULL. The returned string will always be in English.</param>
        /// <param name="unitsLengthRef">Length of the string returned to szUnits. Can be NULL.</param>
        /// <param name="szDescription">A description of the counter, provided the memory the pointer points to has enough room to hold the string. Can be NULL. The returned string will always be in English.</param>
        /// <param name="descriptionLengthRef">Length of the string returned to szDescription. Can be NULL.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CheckCounter([In] const D3D10_COUNTER_DESC* pDesc,[Out] D3D10_COUNTER_TYPE* pType,[Out] UINT* pActiveCounters,[Out, Buffer, Optional] LPSTR szName,[InOut, Optional] UINT* pNameLength,[Out, Buffer, Optional] LPSTR szUnits,[InOut, Optional] UINT* pUnitsLength,[Out, Buffer, Optional] LPSTR szDescription,[InOut, Optional] UINT* pDescriptionLength)</unmanaged>
        public SlimDX2.Result CheckCounter(SlimDX2.Direct3D10.CounterDescription descRef, out SlimDX2.Direct3D10.CounterType typeRef, out int activeCountersRef, IntPtr szName, ref int nameLengthRef, IntPtr szUnits, ref int unitsLengthRef, IntPtr szDescription, ref int descriptionLengthRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* typeRef_ = &typeRef)
                    fixed (void* activeCountersRef_ = &activeCountersRef)
                        fixed (void* nameLengthRef_ = &nameLengthRef)
                            fixed (void* unitsLengthRef_ = &unitsLengthRef)
                                fixed (void* descriptionLengthRef_ = &descriptionLengthRef)
                                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 93 * 4, &descRef, typeRef_, activeCountersRef_, (void*)szName, nameLengthRef_, (void*)szUnits, unitsLengthRef_, (void*)szDescription, descriptionLengthRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the flags used during the call to create the device with <see cref="SlimDX2.Direct3D10.D3D10.CreateDevice"/>.	
        /// </summary>	
        /// <returns>A bitfield containing the flags used to create the device. See <see cref="SlimDX2.Direct3D10.DeviceCreationFlags"/>.</returns>
        /// <unmanaged>UINT GetCreationFlags()</unmanaged>
        internal int GetCreationFlags() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 94 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Give a device access to a shared resource created on a different Direct3d device. 	
        /// </summary>	
        /// <remarks>	
        /// To share a resource between two Direct3D 10 devices the resource must have been created with the  <see cref="SlimDX2.Direct3D10.ResourceOptionFlags.Shared"/> flag, if it was created using the ID3D10Device interface.  If it was created using the IDXGIDevice interface, then the resource is always shared.The REFIID, or GUID, of the interface to the resource can be obtained by using the __uuidof() macro.  For example, __uuidof(ID3D10Buffer) will get the GUID of the interface to a buffer resource.When sharing a resource between two Direct3D 10 devices the unique handle of the resource can be obtained by querying the resource for the <see cref="SlimDX2.DXGI.Resource"/> interface and then calling {{GetSharedHandle}}.	
        /// <code> IDXGIResource* pOtherResource(NULL);	
        /// hr = pOtherDeviceResource-&gt;QueryInterface( __uuidof(IDXGIResource), (void**)&amp;pOtherResource );	
        /// HANDLE sharedHandle;	
        /// pOtherResource-&gt;GetSharedHandle(&amp;sharedHandle); </code>	
        /// 	
        /// The only resources that can be shared are 2D non-mipmapped textures.To share a resource between a Direct3D 9 device and a Direct3D 10 device the texture must have been created using  the pSharedHandle argument of {{CreateTexture}}.   The shared Direct3D 9 handle is then passed to OpenSharedResource in the hResource argument.The following code illustrates the method calls involved.	
        /// <code> sharedHandle = NULL; // must be set to NULL to create, can use a valid handle here to open in D3D9 	
        /// pDevice9-&gt;CreateTexture(..., pTex2D_9, &amp;sharedHandle); 	
        /// ... 	
        /// pDevice10-&gt;OpenSharedResource(sharedHandle, __uuidof(ID3D10Resource), (void**)(&amp;tempResource10)); 	
        /// tempResource10-&gt;QueryInterface(__uuidof(ID3D10Texture2D), (void**)(&amp;pTex2D_10)); 	
        /// tempResource10-&gt;Release(); 	
        /// // now use pTex2D_10 with pDevice10    </code>	
        /// 	
        /// Textures being shared from D3D9 to D3D10 have the following restrictions.Textures must be 2DOnly 1 mip level is allowedTexture must have default usageTexture must be write onlyMSAA textures are not allowedBind flags must have SHADER_RESOURCE and RENDER_TARGET setOnly R10G10B10A2_UNORM, R16G16B16A16_FLOAT and R8G8B8A8_UNORM formats are allowedIf a shared texture is updated on one device <see cref="SlimDX2.Direct3D10.Device.Flush"/> must be called on that device.	
        /// </remarks>	
        /// <param name="hResource">A resource handle. See remarks.</param>
        /// <param name="returnedInterface">The globally unique identifier (GUID) for the resource interface. See remarks.</param>
        /// <param name="resourceRef">Address of a pointer to the resource we are gaining access to.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT OpenSharedResource([In] HANDLE hResource,[In] REFIID ReturnedInterface,[Out, Optional] void** ppResource)</unmanaged>
        public SlimDX2.Result OpenSharedResource(IntPtr hResource, Guid returnedInterface, out IntPtr resourceRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* resourceRef_ = &resourceRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 95 * 4, (void*)hResource, &returnedInterface, resourceRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// This method is not implemented.	
        /// </summary>	
        /// <remarks>	
        /// This method is not implemented, and should not be used.	
        /// </remarks>	
        /// <param name="width">Not applicable</param>
        /// <param name="height">Not applicable</param>
        /// <unmanaged>void SetTextFilterSize([In] UINT Width,[In] UINT Height)</unmanaged>
        public void SetTextFilterSize(int width, int height) {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 96 * 4, width, height);
            }
        }
        
        /// <summary>	
        /// This method is not implemented.	
        /// </summary>	
        /// <remarks>	
        /// This method is not implemented, and should not be used.	
        /// </remarks>	
        /// <param name="widthRef">Not applicable</param>
        /// <param name="heightRef">Not applicable</param>
        /// <unmanaged>void GetTextFilterSize([Out, Optional] UINT* pWidth,[Out, Optional] UINT* pHeight)</unmanaged>
        public void GetTextFilterSize(out int widthRef, out int heightRef) {
            unsafe {
                fixed (void* widthRef_ = &widthRef)
                    fixed (void* heightRef_ = &heightRef)
                        SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 97 * 4, widthRef_, heightRef_);
            }
        }
    }
    
    /// <summary>	
    /// A multithread interface accesses multithread settings and can only be used if the {{thread-safe layer}} is turned on. 	
    /// </summary>	
    /// <unmanaged>ID3D10Multithread</unmanaged>
    [Guid("9B7E4E00-342C-4106-A19F-4F2704F689F0")]
    public partial class Multithread : SlimDX2.ComObject {
        public Multithread(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Find out if multithreading is turned on or not.	
        /// </summary>	
        /// <unmanaged>BOOL GetMultithreadProtected()</unmanaged>
        public bool MultithreadProtected {
                get { return GetMultithreadProtected(); }
        }
        
        /// <summary>	
        /// Enter a device's critical section.	
        /// </summary>	
        /// <remarks>	
        /// Entering a device's critical section prevents other threads from simultaneously calling that device's methods (if {{multithread protection}} is set to true), calling DXGI methods, and calling the methods of all resource, view, shader, state, and asynchronous interfaces.This function should be used in multithreaded applications when there is a series of graphics commands that must happen in order. This function is typically called at the beginning of the series of graphics commands, and <see cref="SlimDX2.Direct3D10.Multithread.Leave"/> is typically called after those graphics commands.	
        /// </remarks>	
        /// <unmanaged>void Enter()</unmanaged>
        public void Enter() {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 3 * 4);
            }
        }
        
        /// <summary>	
        /// Leave a device's critical section.	
        /// </summary>	
        /// <remarks>	
        /// This function is typically used in multithreaded applications when there is a series of graphics commands that must happen in order. <see cref="SlimDX2.Direct3D10.Multithread.Enter"/> is typically called at the beginning of a series of graphics commands, and this function is typically called after those graphics commands.	
        /// </remarks>	
        /// <unmanaged>void Leave()</unmanaged>
        public void Leave() {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 4 * 4);
            }
        }
        
        /// <summary>	
        /// Turn multithreading on or off.	
        /// </summary>	
        /// <param name="bMTProtect">True to turn multithreading on, false to turn it off.</param>
        /// <returns>True if multithreading was turned on prior to calling this method, false otherwise.</returns>
        /// <unmanaged>BOOL SetMultithreadProtected([In] BOOL bMTProtect)</unmanaged>
        public bool SetMultithreadProtected(bool bMTProtect) {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 5 * 4, (bMTProtect?1:0)));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Find out if multithreading is turned on or not.	
        /// </summary>	
        /// <returns>Whether or not multithreading is turned on. True means on, false means off.</returns>
        /// <unmanaged>BOOL GetMultithreadProtected()</unmanaged>
        internal bool GetMultithreadProtected() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 6 * 4));
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A swith-to-reference interface (see the {{switch-to-reference}} layer) enables an application to switch between a hardware and software device.	
    /// </summary>	
    /// <unmanaged>ID3D10SwitchToRef</unmanaged>
    [Guid("9B7E4E02-342C-4106-A19F-4F2704F689F0")]
    public partial class SwitchToRef : SlimDX2.ComObject {
        public SwitchToRef(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get a boolean value that indicates the type of device being used.	
        /// </summary>	
        /// <remarks>	
        /// A hardware device is commonly referred to as a HAL device, which stands for a hardware accelerated device. This means that the pipeline is rendering all of the pipeline commands in hardware, using the GPU. Operating the pipeline with a HAL device gives the best performance generally, but it can be more difficult to debug since resources exist on the GPU instead of the CPU.A software device implements rendering in software using the CPU with no hardware acceleration. A software device is commonly referred to as a reference device or REF device. Because a REF device implements rendering on the CPU, it is generally slower, but is easier to debug since it allows access to resources.	
        /// </remarks>	
        /// <unmanaged>BOOL GetUseRef()</unmanaged>
        public bool UseRef {
                get { return GetUseRef(); }
        }
        
        /// <summary>	
        /// Switch between a hardware and a software device.	
        /// </summary>	
        /// <remarks>	
        /// This API will fail if the device is not switchable; you must have created a device that is switchable by specifying the D3D10_CREATE_DEVICE_SWITCH_TO_REF flag during device creation (when calling <see cref="SlimDX2.Direct3D10.D3D10.CreateDevice"/>).Switching from a software device to a hardware device clears all cached objects from system memory. Switching from a hardware device to a software device causes resources to be downloaded to system memory.	
        /// </remarks>	
        /// <param name="useRef">A boolean value. Set this to TRUE to change to a software device, set this to FALSE to change to a hardware device.</param>
        /// <returns>The previous value of UseRef.</returns>
        /// <unmanaged>BOOL SetUseRef([None] BOOL UseRef)</unmanaged>
        public bool SetUseRef(bool useRef) {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 3 * 4, (useRef?1:0)));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a boolean value that indicates the type of device being used.	
        /// </summary>	
        /// <remarks>	
        /// A hardware device is commonly referred to as a HAL device, which stands for a hardware accelerated device. This means that the pipeline is rendering all of the pipeline commands in hardware, using the GPU. Operating the pipeline with a HAL device gives the best performance generally, but it can be more difficult to debug since resources exist on the GPU instead of the CPU.A software device implements rendering in software using the CPU with no hardware acceleration. A software device is commonly referred to as a reference device or REF device. Because a REF device implements rendering on the CPU, it is generally slower, but is easier to debug since it allows access to resources.	
        /// </remarks>	
        /// <returns>TRUE if the device is a software device, FALSE if the device is a hardware device. See remarks.</returns>
        /// <unmanaged>BOOL GetUseRef()</unmanaged>
        internal bool GetUseRef() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 4 * 4));
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// An information-queue interface stores, retrieves, and filters debug messages. The queue consists of a message queue, an optional storage filter stack, and a optional retrieval filter stack.	
    /// </summary>	
    /// <unmanaged>ID3D10InfoQueue</unmanaged>
    [Guid("1b940b17-2642-4d1f-ab1f-b99bad0c395f")]
    public partial class InfoQueue : SlimDX2.ComObject {
        public InfoQueue(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the maximum number of messages that can be added to the message queue.	
        /// </summary>	
        /// <remarks>	
        /// When the number of messages in the message queue has reached the maximum limit, new messages coming in will push old messages out.	
        /// </remarks>	
        /// <unmanaged>UINT64 GetMessageCountLimit()</unmanaged>
        public long MessageCountLimit {
                get { return GetMessageCountLimit(); }
                set { SetMessageCountLimit(value); }
        }
        
        /// <summary>	
        /// Get the number of messages that were allowed to pass through a storage filter.	
        /// </summary>	
        /// <unmanaged>UINT64 GetNumMessagesAllowedByStorageFilter()</unmanaged>
        public long NumMessagesAllowedByStorageFilter {
                get { return GetNumMessagesAllowedByStorageFilter(); }
        }
        
        /// <summary>	
        /// Get the number of messages that were denied passage through a storage filter.	
        /// </summary>	
        /// <unmanaged>UINT64 GetNumMessagesDeniedByStorageFilter()</unmanaged>
        public long NumMessagesDeniedByStorageFilter {
                get { return GetNumMessagesDeniedByStorageFilter(); }
        }
        
        /// <summary>	
        /// Get the number of messages currently stored in the message queue.	
        /// </summary>	
        /// <unmanaged>UINT64 GetNumStoredMessages()</unmanaged>
        public long NumStoredMessages {
                get { return GetNumStoredMessages(); }
        }
        
        /// <summary>	
        /// Get the number of messages that are able to pass through a retrieval filter.	
        /// </summary>	
        /// <unmanaged>UINT64 GetNumStoredMessagesAllowedByRetrievalFilter()</unmanaged>
        public long NumStoredMessagesAllowedByRetrievalFilter {
                get { return GetNumStoredMessagesAllowedByRetrievalFilter(); }
        }
        
        /// <summary>	
        /// Get the number of messages that were discarded due to the message count limit.	
        /// </summary>	
        /// <remarks>	
        /// Get and set the message count limit with <see cref="SlimDX2.Direct3D10.InfoQueue.GetMessageCountLimit"/> and <see cref="SlimDX2.Direct3D10.InfoQueue.SetMessageCountLimit"/>, respectively.	
        /// </remarks>	
        /// <unmanaged>UINT64 GetNumMessagesDiscardedByMessageCountLimit()</unmanaged>
        public long NumMessagesDiscardedByMessageCountLimit {
                get { return GetNumMessagesDiscardedByMessageCountLimit(); }
        }
        
        /// <summary>	
        /// Get the size of the storage-filter stack in bytes.	
        /// </summary>	
        /// <unmanaged>UINT GetStorageFilterStackSize()</unmanaged>
        public int StorageFilterStackSize {
                get { return GetStorageFilterStackSize(); }
        }
        
        /// <summary>	
        /// Get the size of the retrieval-filter stack in bytes.	
        /// </summary>	
        /// <unmanaged>UINT GetRetrievalFilterStackSize()</unmanaged>
        public int RetrievalFilterStackSize {
                get { return GetRetrievalFilterStackSize(); }
        }
        
        /// <summary>	
        /// Get a boolean that turns the debug output on or off.	
        /// </summary>	
        /// <unmanaged>BOOL GetMuteDebugOutput()</unmanaged>
        public bool MuteDebugOutput {
                get { return GetMuteDebugOutput(); }
                set { SetMuteDebugOutput(value); }
        }
        
        /// <summary>	
        /// Set the maximum number of messages that can be added to the message queue.	
        /// </summary>	
        /// <remarks>	
        /// When the number of messages in the message queue has reached the maximum limit, new messages coming in will push old messages out.	
        /// </remarks>	
        /// <param name="messageCountLimit">Maximum number of messages that can be added to the message queue. -1 means no limit.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetMessageCountLimit([In] UINT64 MessageCountLimit)</unmanaged>
        internal SlimDX2.Result SetMessageCountLimit(long messageCountLimit) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 3 * 4, messageCountLimit);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Clear all messages from the message queue.	
        /// </summary>	
        /// <unmanaged>void ClearStoredMessages()</unmanaged>
        public void ClearStoredMessages() {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 4 * 4);
            }
        }
        
        /// <summary>	
        /// Get a message from the message queue.	
        /// </summary>	
        /// <remarks>	
        /// This method does not remove any messages from the message queue.This method gets messages from the message queue after an optional retrieval filter has been applied.Applications should call this method twice to retrieve a message - first to obtain the size of the message and second to get the message. Here is a typical example:	
        /// <code> // Get the size of the message	
        /// SIZE_T messageLength = 0;	
        /// HRESULT hr = pInfoQueue-&gt;GetMessage(0, NULL, &amp;messageLength); // Allocate space and get the message	
        /// D3D10_MESSAGE * pMessage = (D3D10_MESSAGE*)malloc(messageLength);	
        /// hr = pInfoQueue-&gt;GetMessage(0, pMessage, &amp;messageLength); </code>	
        /// 	
        /// For an overview see {{Information Queue Overview}}.	
        /// </remarks>	
        /// <param name="messageIndex">Index into message queue after an optional retrieval filter has been applied. This can be between 0 and the number of messages in the message queue that pass through the retrieval filter (which can be obtained with <see cref="SlimDX2.Direct3D10.InfoQueue.GetNumStoredMessagesAllowedByRetrievalFilter"/>). 0 is the message at the front of the message queue.</param>
        /// <param name="messageRef">Returned message (see <see cref="SlimDX2.Direct3D10.Message"/>).</param>
        /// <param name="messageByteLengthRef">Size of pMessage in bytes, including the size of the message string that the pMessage points to.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetMessage([In] UINT64 MessageIndex,[Out, Buffer, Optional] D3D10_MESSAGE* pMessage,[InOut] SIZE_T* pMessageByteLength)</unmanaged>
        public SlimDX2.Result GetMessage(long messageIndex, SlimDX2.Direct3D10.Message[] messageRef, ref SlimDX2.Size messageByteLengthRef) {
            unsafe {
                SlimDX2.Direct3D10.Message.__Native[] messageRef__ = new SlimDX2.Direct3D10.Message.__Native[messageRef.Length];
                SlimDX2.Result __result__;
                fixed (void* messageRef_ = &messageRef__[0])
                    fixed (void* messageByteLengthRef_ = &messageByteLengthRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 5 * 4, messageIndex, messageRef==null?(void*)IntPtr.Zero:messageRef_, messageByteLengthRef_);
                for (int i = 0; i < messageRef.Length; i++)
                    messageRef[i].__MarshalFrom(ref messageRef__[i]);				
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the number of messages that were allowed to pass through a storage filter.	
        /// </summary>	
        /// <returns>Number of messages allowed by a storage filter.</returns>
        /// <unmanaged>UINT64 GetNumMessagesAllowedByStorageFilter()</unmanaged>
        internal long GetNumMessagesAllowedByStorageFilter() {
            unsafe {
                long __result__;
                __result__= (long)SlimDX2.Direct3D10.LocalInterop.Callilong(_nativePointer, 6 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the number of messages that were denied passage through a storage filter.	
        /// </summary>	
        /// <returns>Number of messages denied by a storage filter.</returns>
        /// <unmanaged>UINT64 GetNumMessagesDeniedByStorageFilter()</unmanaged>
        internal long GetNumMessagesDeniedByStorageFilter() {
            unsafe {
                long __result__;
                __result__= (long)SlimDX2.Direct3D10.LocalInterop.Callilong(_nativePointer, 7 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the number of messages currently stored in the message queue.	
        /// </summary>	
        /// <returns>Number of messages currently stored in the message queue.</returns>
        /// <unmanaged>UINT64 GetNumStoredMessages()</unmanaged>
        internal long GetNumStoredMessages() {
            unsafe {
                long __result__;
                __result__= (long)SlimDX2.Direct3D10.LocalInterop.Callilong(_nativePointer, 8 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the number of messages that are able to pass through a retrieval filter.	
        /// </summary>	
        /// <returns>Number of messages allowed by a retrieval filter.</returns>
        /// <unmanaged>UINT64 GetNumStoredMessagesAllowedByRetrievalFilter()</unmanaged>
        internal long GetNumStoredMessagesAllowedByRetrievalFilter() {
            unsafe {
                long __result__;
                __result__= (long)SlimDX2.Direct3D10.LocalInterop.Callilong(_nativePointer, 9 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the number of messages that were discarded due to the message count limit.	
        /// </summary>	
        /// <remarks>	
        /// Get and set the message count limit with <see cref="SlimDX2.Direct3D10.InfoQueue.GetMessageCountLimit"/> and <see cref="SlimDX2.Direct3D10.InfoQueue.SetMessageCountLimit"/>, respectively.	
        /// </remarks>	
        /// <returns>Number of messages discarded.</returns>
        /// <unmanaged>UINT64 GetNumMessagesDiscardedByMessageCountLimit()</unmanaged>
        internal long GetNumMessagesDiscardedByMessageCountLimit() {
            unsafe {
                long __result__;
                __result__= (long)SlimDX2.Direct3D10.LocalInterop.Callilong(_nativePointer, 10 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the maximum number of messages that can be added to the message queue.	
        /// </summary>	
        /// <remarks>	
        /// When the number of messages in the message queue has reached the maximum limit, new messages coming in will push old messages out.	
        /// </remarks>	
        /// <returns>Maximum number of messages that can be added to the queue. -1 means no limit.</returns>
        /// <unmanaged>UINT64 GetMessageCountLimit()</unmanaged>
        internal long GetMessageCountLimit() {
            unsafe {
                long __result__;
                __result__= (long)SlimDX2.Direct3D10.LocalInterop.Callilong(_nativePointer, 11 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Add storage filters to the top of the storage-filter stack.	
        /// </summary>	
        /// <remarks>	
        /// A storage filter defines a grouping of debug messages that should be allowed into the info queue.	
        /// </remarks>	
        /// <param name="filterRef">Array of storage filters (see <see cref="SlimDX2.Direct3D10.InformationQueueFilter"/>).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT AddStorageFilterEntries([In] D3D10_INFO_QUEUE_FILTER* pFilter)</unmanaged>
        public SlimDX2.Result AddStorageFilterEntries(SlimDX2.Direct3D10.InformationQueueFilter filterRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 12 * 4, &filterRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the storage filter at the top of the storage-filter stack.	
        /// </summary>	
        /// <param name="filterRef">Storage filter at the top of the storage-filter stack.</param>
        /// <param name="filterByteLengthRef">Size of the storage filter in bytes. If pFilter is NULL, the size of the storage filter will be output to this parameter.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetStorageFilter([Out, Buffer, Optional] D3D10_INFO_QUEUE_FILTER* pFilter,[InOut] SIZE_T* pFilterByteLength)</unmanaged>
        public SlimDX2.Result GetStorageFilter(SlimDX2.Direct3D10.InformationQueueFilter[] filterRef, ref SlimDX2.Size filterByteLengthRef) {
            unsafe {
                SlimDX2.Direct3D10.InformationQueueFilter[] filterRef__ = filterRef ?? new SlimDX2.Direct3D10.InformationQueueFilter[1];
                SlimDX2.Result __result__;
                fixed (void* filterRef_ = &filterRef__[0])
                    fixed (void* filterByteLengthRef_ = &filterByteLengthRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 13 * 4, filterRef==null?(void*)IntPtr.Zero:filterRef_, filterByteLengthRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Remove a storage filter from the top of the storage-filter stack.	
        /// </summary>	
        /// <unmanaged>void ClearStorageFilter()</unmanaged>
        public void ClearStorageFilter() {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 14 * 4);
            }
        }
        
        /// <summary>	
        /// Push an empty storage filter onto the storage-filter stack.	
        /// </summary>	
        /// <remarks>	
        /// An empty storage filter allows all messages to pass through.	
        /// </remarks>	
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT PushEmptyStorageFilter()</unmanaged>
        public SlimDX2.Result PushEmptyStorageFilter() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 15 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Push a copy of storage filter currently on the top of the storage-filter stack onto the storage-filter stack.	
        /// </summary>	
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT PushCopyOfStorageFilter()</unmanaged>
        public SlimDX2.Result PushCopyOfStorageFilter() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 16 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Push a storage filter onto the storage-filter stack.	
        /// </summary>	
        /// <param name="filterRef">Pointer to a storage filter (see <see cref="SlimDX2.Direct3D10.InformationQueueFilter"/>).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT PushStorageFilter([In] D3D10_INFO_QUEUE_FILTER* pFilter)</unmanaged>
        public SlimDX2.Result PushStorageFilter(SlimDX2.Direct3D10.InformationQueueFilter filterRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 17 * 4, &filterRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Pop a storage filter from the top of the storage-filter stack.	
        /// </summary>	
        /// <unmanaged>void PopStorageFilter()</unmanaged>
        public void PopStorageFilter() {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 18 * 4);
            }
        }
        
        /// <summary>	
        /// Get the size of the storage-filter stack in bytes.	
        /// </summary>	
        /// <returns>Size of the storage-filter stack in bytes.</returns>
        /// <unmanaged>UINT GetStorageFilterStackSize()</unmanaged>
        internal int GetStorageFilterStackSize() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 19 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Add storage filters to the top of the retrieval-filter stack.	
        /// </summary>	
        /// <remarks>	
        /// A retrieval filter is used to define a subgroup of the messages that are already in the info queue.   Retrieval filters affect the messages that will be returned by <see cref="SlimDX2.Direct3D10.InfoQueue.GetMessage"/>.The number of messages already in the info queue that will be allowed through the retrieval filter can be determined  by calling <see cref="SlimDX2.Direct3D10.InfoQueue.GetNumStoredMessagesAllowedByRetrievalFilter"/>.	
        /// </remarks>	
        /// <param name="filterRef">Array of retrieval filters (see <see cref="SlimDX2.Direct3D10.InformationQueueFilter"/>).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT AddRetrievalFilterEntries([In] D3D10_INFO_QUEUE_FILTER* pFilter)</unmanaged>
        public SlimDX2.Result AddRetrievalFilterEntries(SlimDX2.Direct3D10.InformationQueueFilter filterRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 20 * 4, &filterRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the retrieval filter at the top of the retrieval-filter stack.	
        /// </summary>	
        /// <param name="filterRef">Retrieval filter at the top of the retrieval-filter stack.</param>
        /// <param name="filterByteLengthRef">Size of the retrieval filter in bytes. If pFilter is NULL, the size of the retrieval filter will be output to this parameter.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetRetrievalFilter([Out, Buffer, Optional] D3D10_INFO_QUEUE_FILTER* pFilter,[InOut] SIZE_T* pFilterByteLength)</unmanaged>
        public SlimDX2.Result GetRetrievalFilter(SlimDX2.Direct3D10.InformationQueueFilter[] filterRef, ref SlimDX2.Size filterByteLengthRef) {
            unsafe {
                SlimDX2.Direct3D10.InformationQueueFilter[] filterRef__ = filterRef ?? new SlimDX2.Direct3D10.InformationQueueFilter[1];
                SlimDX2.Result __result__;
                fixed (void* filterRef_ = &filterRef__[0])
                    fixed (void* filterByteLengthRef_ = &filterByteLengthRef)
                        __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 21 * 4, filterRef==null?(void*)IntPtr.Zero:filterRef_, filterByteLengthRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Remove a retrieval filter from the top of the retrieval-filter stack.	
        /// </summary>	
        /// <unmanaged>void ClearRetrievalFilter()</unmanaged>
        public void ClearRetrievalFilter() {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 22 * 4);
            }
        }
        
        /// <summary>	
        /// Push an empty retrieval filter onto the retrieval-filter stack.	
        /// </summary>	
        /// <remarks>	
        /// An empty retrieval filter allows all messages to pass through.	
        /// </remarks>	
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT PushEmptyRetrievalFilter()</unmanaged>
        public SlimDX2.Result PushEmptyRetrievalFilter() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 23 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Push a copy of retrieval filter currently on the top of the retrieval-filter stack onto the retrieval-filter stack.	
        /// </summary>	
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT PushCopyOfRetrievalFilter()</unmanaged>
        public SlimDX2.Result PushCopyOfRetrievalFilter() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 24 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Push a retrieval filter onto the retrieval-filter stack.	
        /// </summary>	
        /// <param name="filterRef">Pointer to a retrieval filter (see <see cref="SlimDX2.Direct3D10.InformationQueueFilter"/>).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT PushRetrievalFilter([In] D3D10_INFO_QUEUE_FILTER* pFilter)</unmanaged>
        public SlimDX2.Result PushRetrievalFilter(SlimDX2.Direct3D10.InformationQueueFilter filterRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 25 * 4, &filterRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Pop a retrieval filter from the top of the retrieval-filter stack.	
        /// </summary>	
        /// <unmanaged>void PopRetrievalFilter()</unmanaged>
        public void PopRetrievalFilter() {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 26 * 4);
            }
        }
        
        /// <summary>	
        /// Get the size of the retrieval-filter stack in bytes.	
        /// </summary>	
        /// <returns>Size of the retrieval-filter stack in bytes.</returns>
        /// <unmanaged>UINT GetRetrievalFilterStackSize()</unmanaged>
        internal int GetRetrievalFilterStackSize() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 27 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Add a Direct3D 10 debug message to the message queue and send that message to debug output.	
        /// </summary>	
        /// <remarks>	
        /// This method is used by the runtime's internal mechanisms to add Direct3D 10 debug messages to the message queue and send them to debug output. For applications to add their own custom messages to the message queue and send them to debug output, call <see cref="SlimDX2.Direct3D10.InfoQueue.AddApplicationMessage"/>.	
        /// </remarks>	
        /// <param name="category">Category of a message (see <see cref="SlimDX2.Direct3D10.MessageCategory"/>).</param>
        /// <param name="severity">Severity of a message (see <see cref="SlimDX2.Direct3D10.MessageSeverity"/>).</param>
        /// <param name="iD">Unique identifier of a message (see <see cref="SlimDX2.Direct3D10.MessageId"/>).</param>
        /// <param name="descriptionRef">User-defined message.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT AddMessage([In] D3D10_MESSAGE_CATEGORY Category,[In] D3D10_MESSAGE_SEVERITY Severity,[In] D3D10_MESSAGE_ID ID,[In] const char* pDescription)</unmanaged>
        public SlimDX2.Result AddMessage(SlimDX2.Direct3D10.MessageCategory category, SlimDX2.Direct3D10.MessageSeverity severity, SlimDX2.Direct3D10.MessageId iD, string descriptionRef) {
            unsafe {
                IntPtr descriptionRef_ = Marshal.StringToHGlobalAnsi(descriptionRef);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 28 * 4, unchecked((int)category), unchecked((int)severity), unchecked((int)iD), (void*)descriptionRef_);
                Marshal.FreeHGlobal(descriptionRef_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Add a user-defined message to the message queue and send that message to debug output.	
        /// </summary>	
        /// <param name="severity">Severity of a message (see <see cref="SlimDX2.Direct3D10.MessageSeverity"/>).</param>
        /// <param name="descriptionRef">Message string.</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT AddApplicationMessage([In] D3D10_MESSAGE_SEVERITY Severity,[In] const char* pDescription)</unmanaged>
        public SlimDX2.Result AddApplicationMessage(SlimDX2.Direct3D10.MessageSeverity severity, string descriptionRef) {
            unsafe {
                IntPtr descriptionRef_ = Marshal.StringToHGlobalAnsi(descriptionRef);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 29 * 4, unchecked((int)severity), (void*)descriptionRef_);
                Marshal.FreeHGlobal(descriptionRef_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set a message category to break on when a message with that category passes through the storage filter.	
        /// </summary>	
        /// <param name="category">Message category to break on (see <see cref="SlimDX2.Direct3D10.MessageCategory"/>).</param>
        /// <param name="bEnable">Turns this breaking condition on or off (true for on, false for off).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetBreakOnCategory([In] D3D10_MESSAGE_CATEGORY Category,[In] BOOL bEnable)</unmanaged>
        public SlimDX2.Result SetBreakOnCategory(SlimDX2.Direct3D10.MessageCategory category, bool bEnable) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 30 * 4, unchecked((int)category), (bEnable?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set a message severity level to break on when a message with that severity level passes through the storage filter.	
        /// </summary>	
        /// <param name="severity">Message severity level to break on (see <see cref="SlimDX2.Direct3D10.MessageSeverity"/>).</param>
        /// <param name="bEnable">Turns this breaking condition on or off (true for on, false for off).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetBreakOnSeverity([In] D3D10_MESSAGE_SEVERITY Severity,[In] BOOL bEnable)</unmanaged>
        public SlimDX2.Result SetBreakOnSeverity(SlimDX2.Direct3D10.MessageSeverity severity, bool bEnable) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 31 * 4, unchecked((int)severity), (bEnable?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set a message identifier to break on when a message with that identifier passes through the storage filter.	
        /// </summary>	
        /// <param name="iD">Message identifier to break on (see <see cref="SlimDX2.Direct3D10.MessageId"/>).</param>
        /// <param name="bEnable">Turns this breaking condition on or off (true for on, false for off).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetBreakOnID([In] D3D10_MESSAGE_ID ID,[In] BOOL bEnable)</unmanaged>
        public SlimDX2.Result SetBreakOnID(SlimDX2.Direct3D10.MessageId iD, bool bEnable) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 32 * 4, unchecked((int)iD), (bEnable?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a message category to break on when a message with that category passes through the storage filter.	
        /// </summary>	
        /// <param name="category">Message category to break on (see <see cref="SlimDX2.Direct3D10.MessageCategory"/>).</param>
        /// <returns>Whether this breaking condition is turned on or off (true for on, false for off).</returns>
        /// <unmanaged>BOOL GetBreakOnCategory([In] D3D10_MESSAGE_CATEGORY Category)</unmanaged>
        public bool GetBreakOnCategory(SlimDX2.Direct3D10.MessageCategory category) {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 33 * 4, unchecked((int)category)));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a message severity level to break on when a message with that severity level passes through the storage filter.	
        /// </summary>	
        /// <param name="severity">Message severity level to break on (see <see cref="SlimDX2.Direct3D10.MessageSeverity"/>).</param>
        /// <returns>Whether this breaking condition is turned on or off (true for on, false for off).</returns>
        /// <unmanaged>BOOL GetBreakOnSeverity([In] D3D10_MESSAGE_SEVERITY Severity)</unmanaged>
        public bool GetBreakOnSeverity(SlimDX2.Direct3D10.MessageSeverity severity) {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 34 * 4, unchecked((int)severity)));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a message identifier to break on when a message with that identifier passes through the storage filter.	
        /// </summary>	
        /// <param name="iD">Message identifier to break on (see <see cref="SlimDX2.Direct3D10.MessageId"/>).</param>
        /// <returns>Whether this breaking condition is turned on or off (true for on, false for off).</returns>
        /// <unmanaged>BOOL GetBreakOnID([In] D3D10_MESSAGE_ID ID)</unmanaged>
        public bool GetBreakOnID(SlimDX2.Direct3D10.MessageId iD) {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 35 * 4, unchecked((int)iD)));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set a boolean that turns the debug output on or off.	
        /// </summary>	
        /// <remarks>	
        /// This will stop messages that pass the storage filter from being printed out in the debug output, however those messages will still be added to the message queue.	
        /// </remarks>	
        /// <param name="bMute">Disable/Enable the debug output (TRUE to disable or mute the output, FALSE to enable the output).</param>
        /// <unmanaged>void SetMuteDebugOutput([In] BOOL bMute)</unmanaged>
        internal void SetMuteDebugOutput(bool bMute) {
            unsafe {
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 36 * 4, (bMute?1:0));
            }
        }
        
        /// <summary>	
        /// Get a boolean that turns the debug output on or off.	
        /// </summary>	
        /// <returns>Whether the debug output is on or off (true for on, false for off).</returns>
        /// <unmanaged>BOOL GetMuteDebugOutput()</unmanaged>
        internal bool GetMuteDebugOutput() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 37 * 4));
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// This shader-reflection interface provides access to variable type.	
    /// </summary>	
    /// <unmanaged>ID3D10ShaderReflectionType</unmanaged>
    [Guid("c530ad7d-9b16-4395-a979-ba2ecff83add")]
    public partial class ShaderReflectionType : SlimDX2.CppObject {
        public ShaderReflectionType(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the description of a shader-reflection-variable type.	
        /// </summary>	
        /// <param name="descRef">A pointer to a shader-type description (see <see cref="SlimDX2.Direct3D10.ShaderTypeDescription"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetDesc([None] D3D10_SHADER_TYPE_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetDescription(ref SlimDX2.Direct3D10.ShaderTypeDescription descRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 0 * 4, descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a shader-reflection-variable type by index.	
        /// </summary>	
        /// <param name="index">Zero-based index.</param>
        /// <returns>A pointer to a <see cref="SlimDX2.Direct3D10.ShaderReflectionType"/>.</returns>
        /// <unmanaged>ID3D10ShaderReflectionType* GetMemberTypeByIndex([None] UINT Index)</unmanaged>
        public SlimDX2.Direct3D10.ShaderReflectionType GetMemberTypeByIndex(int index) {
            unsafe {
                SlimDX2.Direct3D10.ShaderReflectionType __result__;
                __result__= (SlimDX2.Direct3D10.ShaderReflectionType)new SlimDX2.Direct3D10.ShaderReflectionType((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 1 * 4, index));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a shader-reflection-variable type by name.	
        /// </summary>	
        /// <param name="name">Member name.</param>
        /// <returns>A pointer to a <see cref="SlimDX2.Direct3D10.ShaderReflectionType"/>.</returns>
        /// <unmanaged>ID3D10ShaderReflectionType* GetMemberTypeByName([None] const char* Name)</unmanaged>
        public SlimDX2.Direct3D10.ShaderReflectionType GetMemberTypeByName(string name) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D10.ShaderReflectionType __result__;
                __result__= (SlimDX2.Direct3D10.ShaderReflectionType)new SlimDX2.Direct3D10.ShaderReflectionType((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 2 * 4, (void*)name_));
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a shader-reflection-variable type.	
        /// </summary>	
        /// <param name="index">Zero-based index.</param>
        /// <returns>The variable type.</returns>
        /// <unmanaged>const char* GetMemberTypeName([None] UINT Index)</unmanaged>
        public IntPtr GetMemberTypeName(int index) {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 3 * 4, index);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// This shader-reflection interface provides access to a variable.	
    /// </summary>	
    /// <unmanaged>ID3D10ShaderReflectionVariable</unmanaged>
    [Guid("1bf63c95-2650-405d-99c1-3636bd1da0a1")]
    public partial class ShaderReflectionVariable : SlimDX2.CppObject {
        public ShaderReflectionVariable(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get a shader-variable description.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_SHADER_VARIABLE_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.ShaderVariableDescription Description {
                get { SlimDX2.Direct3D10.ShaderVariableDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a shader-variable type.	
        /// </summary>	
        /// <unmanaged>ID3D10ShaderReflectionType* GetType()</unmanaged>
        public SlimDX2.Direct3D10.ShaderReflectionType TypeInfo {
                get { return GetTypeInfo(); }
        }
        
        /// <summary>	
        /// Get a shader-variable description.	
        /// </summary>	
        /// <param name="descRef">A pointer to a shader-variable description (see <see cref="SlimDX2.Direct3D10.ShaderVariableDescription"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_SHADER_VARIABLE_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D10.ShaderVariableDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.ShaderVariableDescription.__Native descRef_ = new SlimDX2.Direct3D10.ShaderVariableDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 0 * 4, &descRef_);
                descRef = new SlimDX2.Direct3D10.ShaderVariableDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a shader-variable type.	
        /// </summary>	
        /// <returns>A pointer to a <see cref="SlimDX2.Direct3D10.ShaderReflectionType"/>.</returns>
        /// <unmanaged>ID3D10ShaderReflectionType* GetType()</unmanaged>
        internal SlimDX2.Direct3D10.ShaderReflectionType GetTypeInfo() {
            unsafe {
                SlimDX2.Direct3D10.ShaderReflectionType __result__;
                __result__= (SlimDX2.Direct3D10.ShaderReflectionType)new SlimDX2.Direct3D10.ShaderReflectionType((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 1 * 4));
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// This shader-reflection interface provides access to a constant buffer.	
    /// </summary>	
    /// <unmanaged>ID3D10ShaderReflectionConstantBuffer</unmanaged>
    [Guid("66c66a94-dddd-4b62-a66a-f0da33c2b4d0")]
    public partial class ShaderReflectionConstantBuffer : SlimDX2.CppObject {
        public ShaderReflectionConstantBuffer(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get a constant-buffer description.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_SHADER_BUFFER_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.ShaderBufferDescription Description {
                get { SlimDX2.Direct3D10.ShaderBufferDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a constant-buffer description.	
        /// </summary>	
        /// <param name="descRef">A pointer to a shader-buffer description (see <see cref="SlimDX2.Direct3D10.ShaderBufferDescription"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_SHADER_BUFFER_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D10.ShaderBufferDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.ShaderBufferDescription.__Native descRef_ = new SlimDX2.Direct3D10.ShaderBufferDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 0 * 4, &descRef_);
                descRef = new SlimDX2.Direct3D10.ShaderBufferDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a shader-reflection variable by index.	
        /// </summary>	
        /// <param name="index">Zero-based index.</param>
        /// <returns>A pointer to a shader-reflection variable interface (see <see cref="SlimDX2.Direct3D10.ShaderReflectionVariable"/>).</returns>
        /// <unmanaged>ID3D10ShaderReflectionVariable* GetVariableByIndex([None] UINT Index)</unmanaged>
        public SlimDX2.Direct3D10.ShaderReflectionVariable GetVariableByIndex(int index) {
            unsafe {
                SlimDX2.Direct3D10.ShaderReflectionVariable __result__;
                __result__= (SlimDX2.Direct3D10.ShaderReflectionVariable)new SlimDX2.Direct3D10.ShaderReflectionVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 1 * 4, index));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a shader-reflection variable by name.	
        /// </summary>	
        /// <param name="name">Variable name.</param>
        /// <returns>A pointer to a shader-reflection variable interface (see <see cref="SlimDX2.Direct3D10.ShaderReflectionVariable"/>).</returns>
        /// <unmanaged>ID3D10ShaderReflectionVariable* GetVariableByName([None] const char* Name)</unmanaged>
        public SlimDX2.Direct3D10.ShaderReflectionVariable GetVariableByName(string name) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D10.ShaderReflectionVariable __result__;
                __result__= (SlimDX2.Direct3D10.ShaderReflectionVariable)new SlimDX2.Direct3D10.ShaderReflectionVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 2 * 4, (void*)name_));
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A shader-reflection interface accesses shader information.	
    /// </summary>	
    /// <unmanaged>ID3D10ShaderReflection</unmanaged>
    [Guid("d40e20b6-f8f7-42ad-ab20-4baf8f15dfaa")]
    public partial class ShaderReflection : SlimDX2.ComObject {
        public ShaderReflection(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get a shader description.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_SHADER_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.ShaderDescription Description {
                get { SlimDX2.Direct3D10.ShaderDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a shader description.	
        /// </summary>	
        /// <param name="descRef">A pointer to a shader description. See <see cref="SlimDX2.Direct3D10.ShaderDescription"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_SHADER_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D10.ShaderDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.ShaderDescription.__Native descRef_ = new SlimDX2.Direct3D10.ShaderDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 3 * 4, &descRef_);
                descRef = new SlimDX2.Direct3D10.ShaderDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a constant buffer by index.	
        /// </summary>	
        /// <remarks>	
        /// A constant buffer supplies either scalar constants or texture constants to a shader. A shader can use one or more constant buffers. For best performance, separate constants into buffers based on the frequency they are updated.	
        /// </remarks>	
        /// <param name="index">Zero-based index.</param>
        /// <returns>A pointer to a constant buffer (see <see cref="SlimDX2.Direct3D10.ShaderReflectionConstantBuffer"/>).</returns>
        /// <unmanaged>ID3D10ShaderReflectionConstantBuffer* GetConstantBufferByIndex([None] UINT Index)</unmanaged>
        public SlimDX2.Direct3D10.ShaderReflectionConstantBuffer GetConstantBufferByIndex(int index) {
            unsafe {
                SlimDX2.Direct3D10.ShaderReflectionConstantBuffer __result__;
                __result__= (SlimDX2.Direct3D10.ShaderReflectionConstantBuffer)new SlimDX2.Direct3D10.ShaderReflectionConstantBuffer((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 4 * 4, index));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a constant buffer by name.	
        /// </summary>	
        /// <remarks>	
        /// A constant buffer supplies either scalar constants or texture constants to a shader. A shader can use one or more constant buffers. For best performance, separate constants into buffers based on the frequency they are updated.	
        /// </remarks>	
        /// <param name="name">The constant-buffer name.</param>
        /// <returns>A pointer to a constant buffer (see <see cref="SlimDX2.Direct3D10.ShaderReflectionConstantBuffer"/>).</returns>
        /// <unmanaged>ID3D10ShaderReflectionConstantBuffer* GetConstantBufferByName([None] const char* Name)</unmanaged>
        public SlimDX2.Direct3D10.ShaderReflectionConstantBuffer GetConstantBufferByName(string name) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D10.ShaderReflectionConstantBuffer __result__;
                __result__= (SlimDX2.Direct3D10.ShaderReflectionConstantBuffer)new SlimDX2.Direct3D10.ShaderReflectionConstantBuffer((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 5 * 4, (void*)name_));
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a description of the resources bound to a shader.	
        /// </summary>	
        /// <remarks>	
        /// A shader consists of executable code (the compiled HLSL functions) and a set of resources that supply the shader with input data. This API gets a list of the resources that are bound as inputs to the shader.	
        /// </remarks>	
        /// <param name="resourceIndex">A zero-based resource index.</param>
        /// <param name="descRef">A pointer to an input-binding description. See <see cref="SlimDX2.Direct3D10.ShaderInputBindDescription"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetResourceBindingDesc([None] UINT ResourceIndex,[None] D3D10_SHADER_INPUT_BIND_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetResourceBindingDescription(int resourceIndex, ref SlimDX2.Direct3D10.ShaderInputBindDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.ShaderInputBindDescription.__Native descRef_ = new SlimDX2.Direct3D10.ShaderInputBindDescription.__Native();
                descRef.__MarshalTo(ref descRef_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 6 * 4, resourceIndex, &descRef_);
                descRef_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an input-parameter description for a shader.	
        /// </summary>	
        /// <remarks>	
        /// An input-parameter description is also called a shader signature. The shader signature contains information about the input parameters such as the order or parameters, their data type, and a parameter semantic.	
        /// </remarks>	
        /// <param name="parameterIndex">A zero-based parameter index.</param>
        /// <param name="descRef">A pointer to a shader-input-signature description. See <see cref="SlimDX2.Direct3D10.SignatureParameterDescription"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetInputParameterDesc([None] UINT ParameterIndex,[None] D3D10_SIGNATURE_PARAMETER_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetInputParameterDescription(int parameterIndex, ref SlimDX2.Direct3D10.SignatureParameterDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.SignatureParameterDescription.__Native descRef_ = new SlimDX2.Direct3D10.SignatureParameterDescription.__Native();
                descRef.__MarshalTo(ref descRef_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 7 * 4, parameterIndex, &descRef_);
                descRef_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an output-parameter description for a shader.	
        /// </summary>	
        /// <remarks>	
        /// An output-parameter description is also called a shader signature. The shader signature contains information about the output parameters such as the order or parameters, their data type, and a parameter semantic.	
        /// </remarks>	
        /// <param name="parameterIndex">A zero-based parameter index.</param>
        /// <param name="descRef">A pointer to a shader-output-parameter description. See <see cref="SlimDX2.Direct3D10.SignatureParameterDescription"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetOutputParameterDesc([None] UINT ParameterIndex,[None] D3D10_SIGNATURE_PARAMETER_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetOutputParameterDescription(int parameterIndex, ref SlimDX2.Direct3D10.SignatureParameterDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.SignatureParameterDescription.__Native descRef_ = new SlimDX2.Direct3D10.SignatureParameterDescription.__Native();
                descRef.__MarshalTo(ref descRef_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 8 * 4, parameterIndex, &descRef_);
                descRef_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A state-block interface encapsulates render states.	
    /// </summary>	
    /// <unmanaged>ID3D10StateBlock</unmanaged>
    [Guid("0803425a-57f5-4dd6-9465-a87570834a08")]
    public partial class StateBlock : SlimDX2.ComObject {
        public StateBlock(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the device.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>
        public SlimDX2.Direct3D10.Device Device {
                get { SlimDX2.Direct3D10.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Capture the current value of states that are included in a stateblock.	
        /// </summary>	
        /// <remarks>	
        /// Capture captures current values for states within an existing state block. It does not capture the entire state of the device. Creating an empty stateblock and calling Capture does nothing if no states have been set.	
        /// </remarks>	
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT Capture()</unmanaged>
        public SlimDX2.Result Capture() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 3 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Apply the state block to the current device state.	
        /// </summary>	
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT Apply()</unmanaged>
        public SlimDX2.Result Apply() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 4 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Release all references to device objects.	
        /// </summary>	
        /// <remarks>	
        /// Each time you return a pointer to an interface (by calling <see cref="SlimDX2.Direct3D10.StateBlock.GetDevice"/>), the internal reference count is incremented; when you are finished using a stateblock, call this method to release all references and avoid a memory leak.	
        /// </remarks>	
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT ReleaseAllDeviceObjects()</unmanaged>
        public SlimDX2.Result ReleaseAllDeviceObjects() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 5 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the device.	
        /// </summary>	
        /// <param name="deviceRef">Pointer to the ID3D10Device interface that is returned.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D10.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 6 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// The ID3D10EffectType interface accesses effect variables by type.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectType</unmanaged>
    [Guid("4e9e1ddc-cd9d-4772-a837-00180b9b88fd")]
    public partial class EffectType : SlimDX2.CppObject {
        public EffectType(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Tests that the effect type is valid.	
        /// </summary>	
        /// <unmanaged>BOOL IsValid()</unmanaged>
        public bool IsValid {
                get { return IsValid_(); }
        }
        
        /// <summary>	
        /// Get an effect-type description.	
        /// </summary>	
        /// <remarks>	
        /// The effect-variable description contains data about the name, annotations, semantic, flags and buffer offset of the effect type.	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_EFFECT_TYPE_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.EffectTypeDescription Description {
                get { SlimDX2.Direct3D10.EffectTypeDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Tests that the effect type is valid.	
        /// </summary>	
        /// <returns>TRUE if it is valid; otherwise FALSE.</returns>
        /// <unmanaged>BOOL IsValid()</unmanaged>
        internal bool IsValid_() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 0 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an effect-type description.	
        /// </summary>	
        /// <remarks>	
        /// The effect-variable description contains data about the name, annotations, semantic, flags and buffer offset of the effect type.	
        /// </remarks>	
        /// <param name="descRef">A pointer to an effect-type description. See <see cref="SlimDX2.Direct3D10.EffectTypeDescription"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_EFFECT_TYPE_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D10.EffectTypeDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.EffectTypeDescription.__Native descRef_ = new SlimDX2.Direct3D10.EffectTypeDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 1 * 4, &descRef_);
                descRef = new SlimDX2.Direct3D10.EffectTypeDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a member type by index.	
        /// </summary>	
        /// <param name="index">A zero-based index.</param>
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectType"/>.</returns>
        /// <unmanaged>ID3D10EffectType* GetMemberTypeByIndex([None] UINT Index)</unmanaged>
        public SlimDX2.Direct3D10.EffectType GetMemberTypeByIndex(int index) {
            unsafe {
                SlimDX2.Direct3D10.EffectType __result__;
                __result__= (SlimDX2.Direct3D10.EffectType)new SlimDX2.Direct3D10.EffectType((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 2 * 4, index));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an member type by name.	
        /// </summary>	
        /// <param name="name">A member's name.</param>
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectType"/>.</returns>
        /// <unmanaged>ID3D10EffectType* GetMemberTypeByName([None] const char* Name)</unmanaged>
        public SlimDX2.Direct3D10.EffectType GetMemberTypeByName(string name) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D10.EffectType __result__;
                __result__= (SlimDX2.Direct3D10.EffectType)new SlimDX2.Direct3D10.EffectType((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 3 * 4, (void*)name_));
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a member type by semantic.	
        /// </summary>	
        /// <param name="semantic">A semantic.</param>
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectType"/>.</returns>
        /// <unmanaged>ID3D10EffectType* GetMemberTypeBySemantic([None] const char* Semantic)</unmanaged>
        public SlimDX2.Direct3D10.EffectType GetMemberTypeBySemantic(string semantic) {
            unsafe {
                IntPtr semantic_ = Marshal.StringToHGlobalAnsi(semantic);
                SlimDX2.Direct3D10.EffectType __result__;
                __result__= (SlimDX2.Direct3D10.EffectType)new SlimDX2.Direct3D10.EffectType((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 4 * 4, (void*)semantic_));
                Marshal.FreeHGlobal(semantic_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the name of a member.	
        /// </summary>	
        /// <param name="index">A zero-based index.</param>
        /// <returns>The name of the member.</returns>
        /// <unmanaged>const char* GetMemberName([None] UINT Index)</unmanaged>
        public IntPtr GetMemberName(int index) {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 5 * 4, index);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the semantic attached to a member.	
        /// </summary>	
        /// <param name="index">A zero-based index.</param>
        /// <returns>A string that contains the semantic.</returns>
        /// <unmanaged>const char* GetMemberSemantic([None] UINT Index)</unmanaged>
        public IntPtr GetMemberSemantic(int index) {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 6 * 4, index);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// The ID3D10EffectVariable interface is the base class for all effect variables.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectVariable</unmanaged>
    [Guid("ae897105-00e6-45bf-bb8e-281dd6db8e1b")]
    public partial class EffectVariable : SlimDX2.CppObject {
        public EffectVariable(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Compare the data type with the data stored.	
        /// </summary>	
        /// <remarks>	
        /// This method checks that the data type matches the data stored after casting one interface to another (using any of the As methods).	
        /// </remarks>	
        /// <unmanaged>BOOL IsValid()</unmanaged>
        public bool IsValid {
                get { return IsValid_(); }
        }
        
        /// <summary>	
        /// Get type information.	
        /// </summary>	
        /// <unmanaged>ID3D10EffectType* GetType()</unmanaged>
        public SlimDX2.Direct3D10.EffectType TypeInfo {
                get { return GetTypeInfo(); }
        }
        
        /// <summary>	
        /// Get a description.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_EFFECT_VARIABLE_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.EffectVariableDescription Description {
                get { SlimDX2.Direct3D10.EffectVariableDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a constant buffer.	
        /// </summary>	
        /// <remarks>	
        /// Effect variables are read-from or written-to a constant buffer.	
        /// </remarks>	
        /// <unmanaged>ID3D10EffectConstantBuffer* GetParentConstantBuffer()</unmanaged>
        public SlimDX2.Direct3D10.EffectConstantBuffer ParentConstantBuffer {
                get { return GetParentConstantBuffer(); }
        }
        
        /// <summary>	
        /// Compare the data type with the data stored.	
        /// </summary>	
        /// <remarks>	
        /// This method checks that the data type matches the data stored after casting one interface to another (using any of the As methods).	
        /// </remarks>	
        /// <returns>TRUE if the syntax is valid; otherwise FALSE.</returns>
        /// <unmanaged>BOOL IsValid()</unmanaged>
        internal bool IsValid_() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 0 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get type information.	
        /// </summary>	
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectType"/>.</returns>
        /// <unmanaged>ID3D10EffectType* GetType()</unmanaged>
        internal SlimDX2.Direct3D10.EffectType GetTypeInfo() {
            unsafe {
                SlimDX2.Direct3D10.EffectType __result__;
                __result__= (SlimDX2.Direct3D10.EffectType)new SlimDX2.Direct3D10.EffectType((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 1 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a description.	
        /// </summary>	
        /// <param name="descRef">A pointer to an effect-variable description (see <see cref="SlimDX2.Direct3D10.EffectVariableDescription"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_EFFECT_VARIABLE_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D10.EffectVariableDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.EffectVariableDescription.__Native descRef_ = new SlimDX2.Direct3D10.EffectVariableDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 2 * 4, &descRef_);
                descRef = new SlimDX2.Direct3D10.EffectVariableDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an annotation by index.	
        /// </summary>	
        /// <remarks>	
        /// Annonations can be attached to a technique, a pass or a gloval variable. For the syntax, see {{Annotation Syntax (Direct3D 10)}}.	
        /// </remarks>	
        /// <param name="index">A zero-based index.</param>
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectVariable* GetAnnotationByIndex([None] UINT Index)</unmanaged>
        public SlimDX2.Direct3D10.EffectVariable GetAnnotationByIndex(int index) {
            unsafe {
                SlimDX2.Direct3D10.EffectVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectVariable)new SlimDX2.Direct3D10.EffectVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 3 * 4, index));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an annotation by name.	
        /// </summary>	
        /// <remarks>	
        /// Annonations can be attached to a technique, a pass or a gloval variable. For the syntax, see {{Annotation Syntax (Direct3D 10)}}.	
        /// </remarks>	
        /// <param name="name">The annotation name.</param>
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectVariable"/>.  Note that if the annotation is not found the ID3D10EffectVariable Interface returned will be empty. The <see cref="SlimDX2.Direct3D10.EffectVariable.IsValid_"/> method should be called to determine whether the annotation was found.</returns>
        /// <unmanaged>ID3D10EffectVariable* GetAnnotationByName([None] const char* Name)</unmanaged>
        public SlimDX2.Direct3D10.EffectVariable GetAnnotationByName(string name) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D10.EffectVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectVariable)new SlimDX2.Direct3D10.EffectVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 4 * 4, (void*)name_));
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a structure member by index.	
        /// </summary>	
        /// <remarks>	
        /// If the effect variable is an structure, use this method to look up a member by index.	
        /// </remarks>	
        /// <param name="index">A zero-based index.</param>
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectVariable* GetMemberByIndex([None] UINT Index)</unmanaged>
        public SlimDX2.Direct3D10.EffectVariable GetMemberByIndex(int index) {
            unsafe {
                SlimDX2.Direct3D10.EffectVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectVariable)new SlimDX2.Direct3D10.EffectVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 5 * 4, index));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a structure member by name.	
        /// </summary>	
        /// <remarks>	
        /// If the effect variable is an structure, use this method to look up a member by name.	
        /// </remarks>	
        /// <param name="name">Member name.</param>
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectVariable* GetMemberByName([None] const char* Name)</unmanaged>
        public SlimDX2.Direct3D10.EffectVariable GetMemberByName(string name) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D10.EffectVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectVariable)new SlimDX2.Direct3D10.EffectVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 6 * 4, (void*)name_));
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a structure member by semantic.	
        /// </summary>	
        /// <remarks>	
        /// If the effect variable is an structure, use this method to look up a member by attached semantic.	
        /// </remarks>	
        /// <param name="semantic">The semantic.</param>
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectVariable* GetMemberBySemantic([None] const char* Semantic)</unmanaged>
        public SlimDX2.Direct3D10.EffectVariable GetMemberBySemantic(string semantic) {
            unsafe {
                IntPtr semantic_ = Marshal.StringToHGlobalAnsi(semantic);
                SlimDX2.Direct3D10.EffectVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectVariable)new SlimDX2.Direct3D10.EffectVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 7 * 4, (void*)semantic_));
                Marshal.FreeHGlobal(semantic_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an array element.	
        /// </summary>	
        /// <remarks>	
        /// If the effect variable is an array, use this method to return one of the elements.	
        /// </remarks>	
        /// <param name="index">A zero-based index; otherwise 0.</param>
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectVariable* GetElement([None] UINT Index)</unmanaged>
        public SlimDX2.Direct3D10.EffectVariable GetElement(int index) {
            unsafe {
                SlimDX2.Direct3D10.EffectVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectVariable)new SlimDX2.Direct3D10.EffectVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 8 * 4, index));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a constant buffer.	
        /// </summary>	
        /// <remarks>	
        /// Effect variables are read-from or written-to a constant buffer.	
        /// </remarks>	
        /// <returns>A pointer to a <see cref="SlimDX2.Direct3D10.EffectConstantBuffer"/>.</returns>
        /// <unmanaged>ID3D10EffectConstantBuffer* GetParentConstantBuffer()</unmanaged>
        internal SlimDX2.Direct3D10.EffectConstantBuffer GetParentConstantBuffer() {
            unsafe {
                SlimDX2.Direct3D10.EffectConstantBuffer __result__;
                __result__= (SlimDX2.Direct3D10.EffectConstantBuffer)new SlimDX2.Direct3D10.EffectConstantBuffer((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 9 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a scalar variable.	
        /// </summary>	
        /// <remarks>	
        /// AsScalar returns a version of the effect variable that has been specialized to a scalar variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain scalar data.Applications can test the returned object for validity by calling {{IsValid}}.	
        /// </remarks>	
        /// <returns>A pointer to a scalar variable. See <see cref="SlimDX2.Direct3D10.EffectScalarVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectScalarVariable* AsScalar()</unmanaged>
        public SlimDX2.Direct3D10.EffectScalarVariable AsScalar() {
            unsafe {
                SlimDX2.Direct3D10.EffectScalarVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectScalarVariable)new SlimDX2.Direct3D10.EffectScalarVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 10 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a vector variable.	
        /// </summary>	
        /// <remarks>	
        /// AsVector returns a version of the effect variable that has been specialized to a vector variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain vector data.Applications can test the returned object for validity by calling {{IsValid}}.	
        /// </remarks>	
        /// <returns>A pointer to a vector variable. See <see cref="SlimDX2.Direct3D10.EffectVectorVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectVectorVariable* AsVector()</unmanaged>
        public SlimDX2.Direct3D10.EffectVectorVariable AsVector() {
            unsafe {
                SlimDX2.Direct3D10.EffectVectorVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectVectorVariable)new SlimDX2.Direct3D10.EffectVectorVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 11 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a matrix variable.	
        /// </summary>	
        /// <remarks>	
        /// AsMatrix returns a version of the effect variable that has been specialized to a matrix variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain matrix data.Applications can test the returned object for validity by calling {{IsValid}}.	
        /// </remarks>	
        /// <returns>A pointer to a matrix variable. See <see cref="SlimDX2.Direct3D10.EffectMatrixVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectMatrixVariable* AsMatrix()</unmanaged>
        public SlimDX2.Direct3D10.EffectMatrixVariable AsMatrix() {
            unsafe {
                SlimDX2.Direct3D10.EffectMatrixVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectMatrixVariable)new SlimDX2.Direct3D10.EffectMatrixVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 12 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a string variable.	
        /// </summary>	
        /// <remarks>	
        /// AsString returns a version of the effect variable that has been specialized to a string variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain string data.Applications can test the returned object for validity by calling {{IsValid}}.	
        /// </remarks>	
        /// <returns>A pointer to a string variable. See <see cref="SlimDX2.Direct3D10.EffectStringVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectStringVariable* AsString()</unmanaged>
        public SlimDX2.Direct3D10.EffectStringVariable AsString() {
            unsafe {
                SlimDX2.Direct3D10.EffectStringVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectStringVariable)new SlimDX2.Direct3D10.EffectStringVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 13 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a shader-resource variable.	
        /// </summary>	
        /// <remarks>	
        /// AsShaderResource returns a version of the effect variable that has been specialized to a shader-resource variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain shader-resource data.Applications can test the returned object for validity by calling {{IsValid}}.	
        /// </remarks>	
        /// <returns>A pointer to a shader-resource variable. See <see cref="SlimDX2.Direct3D10.EffectShaderResourceVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectShaderResourceVariable* AsShaderResource()</unmanaged>
        public SlimDX2.Direct3D10.EffectShaderResourceVariable AsShaderResource() {
            unsafe {
                SlimDX2.Direct3D10.EffectShaderResourceVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectShaderResourceVariable)new SlimDX2.Direct3D10.EffectShaderResourceVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 14 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a render-target-view variable.	
        /// </summary>	
        /// <remarks>	
        /// This method returns a version of the effect variable that has been specialized to a render-target-view variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain render-target-view data.Applications can test the returned object for validity by calling {{IsValid}}.	
        /// </remarks>	
        /// <returns>A pointer to a render-target-view variable. See <see cref="SlimDX2.Direct3D10.EffectRenderTargetViewVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectRenderTargetViewVariable* AsRenderTargetView()</unmanaged>
        public SlimDX2.Direct3D10.EffectRenderTargetViewVariable AsRenderTargetView() {
            unsafe {
                SlimDX2.Direct3D10.EffectRenderTargetViewVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectRenderTargetViewVariable)new SlimDX2.Direct3D10.EffectRenderTargetViewVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 15 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a depth-stencil-view variable.	
        /// </summary>	
        /// <remarks>	
        /// This method returns a version of the effect variable that has been specialized to a depth-stencil-view variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain depth-stencil-view data.Applications can test the returned object for validity by calling {{IsValid}}.	
        /// </remarks>	
        /// <returns>A pointer to a depth-stencil-view variable. See <see cref="SlimDX2.Direct3D10.EffectDepthStencilViewVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectDepthStencilViewVariable* AsDepthStencilView()</unmanaged>
        public SlimDX2.Direct3D10.EffectDepthStencilViewVariable AsDepthStencilView() {
            unsafe {
                SlimDX2.Direct3D10.EffectDepthStencilViewVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectDepthStencilViewVariable)new SlimDX2.Direct3D10.EffectDepthStencilViewVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 16 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a constant buffer.	
        /// </summary>	
        /// <remarks>	
        /// AsConstantBuffer returns a version of the effect variable that has been specialized to a constant buffer. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain constant buffer data.Applications can test the returned object for validity by calling {{IsValid}}.	
        /// </remarks>	
        /// <returns>A pointer to a constant buffer. See <see cref="SlimDX2.Direct3D10.EffectConstantBuffer"/>.</returns>
        /// <unmanaged>ID3D10EffectConstantBuffer* AsConstantBuffer()</unmanaged>
        public SlimDX2.Direct3D10.EffectConstantBuffer AsConstantBuffer() {
            unsafe {
                SlimDX2.Direct3D10.EffectConstantBuffer __result__;
                __result__= (SlimDX2.Direct3D10.EffectConstantBuffer)new SlimDX2.Direct3D10.EffectConstantBuffer((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 17 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a shader variable.	
        /// </summary>	
        /// <remarks>	
        /// AsShader returns a version of the effect variable that has been specialized to a shader variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain shader data.Applications can test the returned object for validity by calling {{IsValid}}.	
        /// </remarks>	
        /// <returns>A pointer to a shader variable. See <see cref="SlimDX2.Direct3D10.EffectShaderVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectShaderVariable* AsShader()</unmanaged>
        public SlimDX2.Direct3D10.EffectShaderVariable AsShader() {
            unsafe {
                SlimDX2.Direct3D10.EffectShaderVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectShaderVariable)new SlimDX2.Direct3D10.EffectShaderVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 18 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a effect-blend variable.	
        /// </summary>	
        /// <remarks>	
        /// AsBlend returns a version of the effect variable that has been specialized to an effect-blend variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain effect-blend data.Applications can test the returned object for validity by calling {{IsValid}}.	
        /// </remarks>	
        /// <returns>A pointer to an effect blend variable. See <see cref="SlimDX2.Direct3D10.EffectBlendVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectBlendVariable* AsBlend()</unmanaged>
        public SlimDX2.Direct3D10.EffectBlendVariable AsBlend() {
            unsafe {
                SlimDX2.Direct3D10.EffectBlendVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectBlendVariable)new SlimDX2.Direct3D10.EffectBlendVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 19 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a depth-stencil variable.	
        /// </summary>	
        /// <remarks>	
        /// AsDepthStencil returns a version of the effect variable that has been specialized to a depth-stencil variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain depth-stencil data.Applications can test the returned object for validity by calling {{IsValid}}.	
        /// </remarks>	
        /// <returns>A pointer to a depth-stencil variable. See <see cref="SlimDX2.Direct3D10.EffectDepthStencilVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectDepthStencilVariable* AsDepthStencil()</unmanaged>
        public SlimDX2.Direct3D10.EffectDepthStencilVariable AsDepthStencil() {
            unsafe {
                SlimDX2.Direct3D10.EffectDepthStencilVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectDepthStencilVariable)new SlimDX2.Direct3D10.EffectDepthStencilVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 20 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a rasterizer variable.	
        /// </summary>	
        /// <remarks>	
        /// AsRasterizer returns a version of the effect variable that has been specialized to a rasterizer variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain rasterizer data.Applications can test the returned object for validity by calling {{IsValid}}.	
        /// </remarks>	
        /// <returns>A pointer to a rasterizer variable. See <see cref="SlimDX2.Direct3D10.EffectRasterizerVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectRasterizerVariable* AsRasterizer()</unmanaged>
        public SlimDX2.Direct3D10.EffectRasterizerVariable AsRasterizer() {
            unsafe {
                SlimDX2.Direct3D10.EffectRasterizerVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectRasterizerVariable)new SlimDX2.Direct3D10.EffectRasterizerVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 21 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a sampler variable.	
        /// </summary>	
        /// <remarks>	
        /// AsSampler returns a version of the effect variable that has been specialized to a sampler variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain sampler data.Applications can test the returned object for validity by calling {{IsValid}}.	
        /// </remarks>	
        /// <returns>A pointer to a sampler variable. See <see cref="SlimDX2.Direct3D10.EffectSamplerVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectSamplerVariable* AsSampler()</unmanaged>
        public SlimDX2.Direct3D10.EffectSamplerVariable AsSampler() {
            unsafe {
                SlimDX2.Direct3D10.EffectSamplerVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectSamplerVariable)new SlimDX2.Direct3D10.EffectSamplerVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 22 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set data.	
        /// </summary>	
        /// <remarks>	
        /// This method does no conversion or type checking; it is therefore a very quick way to access array items.	
        /// </remarks>	
        /// <param name="dataRef">A pointer to the variable.</param>
        /// <param name="offset">The offset (in bytes) from the beginning of the pointer to the data.</param>
        /// <param name="count">The number of bytes to set.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetRawValue([None] void* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetRawValue(IntPtr dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 23 * 4, (void*)dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get data.	
        /// </summary>	
        /// <remarks>	
        /// This method does no conversion or type checking; it is therefore a very quick way to access array items.	
        /// </remarks>	
        /// <param name="dataRef">A pointer to the variable.</param>
        /// <param name="offset">The offset (in bytes) from the beginning of the pointer to the data.</param>
        /// <param name="count">The number of bytes to get.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetRawValue([None] void* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetRawValue(IntPtr dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 24 * 4, (void*)dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// An effect-scalar-variable interface accesses scalar values.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectScalarVariable</unmanaged>
    [Guid("00e48f7b-d2c8-49e8-a86c-022dee53431f")]
    public partial class EffectScalarVariable : SlimDX2.Direct3D10.EffectVariable {
        public EffectScalarVariable(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Set a floating-point variable.	
        /// </summary>	
        /// <param name="value">A pointer to the variable.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetFloat([None] float Value)</unmanaged>
        public SlimDX2.Result SetFloat(float value) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 25 * 4, value);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a floating-point variable.	
        /// </summary>	
        /// <param name="valueRef">A pointer to the variable.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetFloat([None] float* pValue)</unmanaged>
        public SlimDX2.Result GetFloat(float valueRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 26 * 4, &valueRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set an array of floating-point variables.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the start of the data to set.</param>
        /// <param name="offset">Must be set to 0; this is reserved for future use. </param>
        /// <param name="count">The number of array elements to set.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetFloatArray([None] float* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetFloatArray(float dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 27 * 4, &dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an array of floating-point variables.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the start of the data to set.</param>
        /// <param name="offset">Must be set to 0; this is reserved for future use. </param>
        /// <param name="count">The number of array elements to set.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetFloatArray([None] float* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetFloatArray(float dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 28 * 4, &dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set an integer variable.	
        /// </summary>	
        /// <param name="value">A pointer to the variable.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetInt([None] int Value)</unmanaged>
        public SlimDX2.Result SetInt(int value) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 29 * 4, value);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an integer variable.	
        /// </summary>	
        /// <param name="valueRef">A pointer to the variable.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetInt([None] int* pValue)</unmanaged>
        public SlimDX2.Result GetInt(int valueRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 30 * 4, &valueRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set an array of integer variables.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the start of the data to set.</param>
        /// <param name="offset">Must be set to 0; this is reserved for future use. </param>
        /// <param name="count">The number of array elements to set.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetIntArray([None] int* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetIntArray(int dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 31 * 4, &dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an array of integer variables.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the start of the data to set.</param>
        /// <param name="offset">Must be set to 0; this is reserved for future use. </param>
        /// <param name="count">The number of array elements to set.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetIntArray([None] int* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetIntArray(int dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 32 * 4, &dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set a boolean variable.	
        /// </summary>	
        /// <param name="value">A pointer to the variable.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetBool([None] BOOL Value)</unmanaged>
        public SlimDX2.Result SetBool(bool value) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 33 * 4, (value?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a boolean variable.	
        /// </summary>	
        /// <param name="valueRef">A pointer to the variable.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetBool([None] BOOL* pValue)</unmanaged>
        public SlimDX2.Result GetBool(bool valueRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 34 * 4, &valueRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set an array of boolean variables.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the start of the data to set.</param>
        /// <param name="offset">Must be set to 0; this is reserved for future use. </param>
        /// <param name="count">The number of array elements to set.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetBoolArray([None] BOOL* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetBoolArray(bool dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 35 * 4, &dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an array of boolean variables.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the start of the data to set.</param>
        /// <param name="offset">Must be set to 0; this is reserved for future use. </param>
        /// <param name="count">The number of array elements to set.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetBoolArray([None] BOOL* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetBoolArray(bool dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 36 * 4, &dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A vector-variable interface accesses a four-component vector.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectVectorVariable</unmanaged>
    [Guid("62b98c44-1f82-4c67-bcd0-72cf8f217e81")]
    public partial class EffectVectorVariable : SlimDX2.Direct3D10.EffectVariable {
        public EffectVectorVariable(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Set a four-component vector that contains boolean data.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the first component.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetBoolVector([None] BOOL* pData)</unmanaged>
        public SlimDX2.Result SetBoolVector(bool dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 25 * 4, &dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set a four-component vector that contains integer data.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the first component.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetIntVector([None] int* pData)</unmanaged>
        public SlimDX2.Result SetIntVector(int dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 26 * 4, &dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set a four-component vector that contains floating-point data.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the first component.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetFloatVector([None] float* pData)</unmanaged>
        public SlimDX2.Result SetFloatVector(float dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 27 * 4, &dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a four-component vector that contains boolean data.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the first component.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetBoolVector([None] BOOL* pData)</unmanaged>
        public SlimDX2.Result GetBoolVector(bool dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 28 * 4, &dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a four-component vector that contains integer data.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the first component.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetIntVector([None] int* pData)</unmanaged>
        public SlimDX2.Result GetIntVector(int dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 29 * 4, &dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a four-component vector that contains floating-point data.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the first component.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetFloatVector([None] float* pData)</unmanaged>
        public SlimDX2.Result GetFloatVector(float dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 30 * 4, &dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set an array of four-component vectors that contain boolean data.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the start of the data to set.</param>
        /// <param name="offset">Must be set to 0; this is reserved for future use. </param>
        /// <param name="count">The number of array elements to set.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetBoolVectorArray([None] BOOL* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetBoolVectorArray(bool dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 31 * 4, &dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set an array of four-component vectors that contain integer data.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the start of the data to set.</param>
        /// <param name="offset">Must be set to 0; this is reserved for future use. </param>
        /// <param name="count">The number of array elements to set.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetIntVectorArray([None] int* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetIntVectorArray(int dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 32 * 4, &dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set an array of four-component vectors that contain floating-point data.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the start of the data to set.</param>
        /// <param name="offset">Must be set to 0; this is reserved for future use. </param>
        /// <param name="count">The number of array elements to set.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetFloatVectorArray([None] float* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetFloatVectorArray(float dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 33 * 4, &dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an array of four-component vectors that contain boolean data.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the start of the data to set.</param>
        /// <param name="offset">Must be set to 0; this is reserved for future use. </param>
        /// <param name="count">The number of array elements to set.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetBoolVectorArray([None] BOOL* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetBoolVectorArray(bool dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 34 * 4, &dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an array of four-component vectors that contain integer data.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the start of the data to set.</param>
        /// <param name="offset">Must be set to 0; this is reserved for future use. </param>
        /// <param name="count">The number of array elements to set.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetIntVectorArray([None] int* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetIntVectorArray(int dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 35 * 4, &dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an array of four-component vectors that contain floating-point data.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the start of the data to set.</param>
        /// <param name="offset">Must be set to 0; this is reserved for future use. </param>
        /// <param name="count">The number of array elements to set.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetFloatVectorArray([None] float* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetFloatVectorArray(float dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 36 * 4, &dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A matrix-variable interface accesses a matrix.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectMatrixVariable</unmanaged>
    [Guid("50666c24-b82f-4eed-a172-5b6e7e8522e0")]
    public partial class EffectMatrixVariable : SlimDX2.Direct3D10.EffectVariable {
        public EffectMatrixVariable(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Set a floating-point matrix.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the first element in the matrix.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetMatrix([None] float* pData)</unmanaged>
        public SlimDX2.Result SetMatrix(float dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 25 * 4, &dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a matrix.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the first element in a matrix.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetMatrix([None] float* pData)</unmanaged>
        public SlimDX2.Result GetMatrix(float dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 26 * 4, &dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set an array of floating-point matrices.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the first matrix.</param>
        /// <param name="offset">The number of matrix elements to skip from the start of the array.</param>
        /// <param name="count">The number of elements to set.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetMatrixArray([None] float* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixArray(float dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 27 * 4, &dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an array of matrices.	
        /// </summary>	
        /// <param name="dataRef">A pointer to the first element of the first matrix in an array of matrices.</param>
        /// <param name="offset">The offset (in number of matrices) between the start of the array and the first matrix returned.</param>
        /// <param name="count">The number of matrices in the returned array.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetMatrixArray([None] float* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetMatrixArray(float dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 28 * 4, &dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Transpose and set a floating-point matrix.	
        /// </summary>	
        /// <remarks>	
        /// Transposing a matrix will rearrange the data order from row-column order to column-row order (or vice versa).	
        /// </remarks>	
        /// <param name="dataRef">A pointer to the first element of a matrix.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetMatrixTranspose([None] float* pData)</unmanaged>
        public SlimDX2.Result SetMatrixTranspose(float dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 29 * 4, &dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Transpose and get a floating-point matrix.	
        /// </summary>	
        /// <remarks>	
        /// Transposing a matrix will rearrange the data order from row-column order to column-row order (or vice versa).	
        /// </remarks>	
        /// <param name="dataRef">A pointer to the first element of a transposed matrix.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetMatrixTranspose([None] float* pData)</unmanaged>
        public SlimDX2.Result GetMatrixTranspose(float dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 30 * 4, &dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Transpose and set an array of floating-point matrices.	
        /// </summary>	
        /// <remarks>	
        /// Transposing a matrix will rearrange the data order from row-column order to column-row order (or vice versa).	
        /// </remarks>	
        /// <param name="dataRef">A pointer to an array of matrices.</param>
        /// <param name="offset">The offset (in number of matrices) between the start of the array and the first matrix to set.</param>
        /// <param name="count">The number of matrices in the array to set.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetMatrixTransposeArray([None] float* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetMatrixTransposeArray(float dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 31 * 4, &dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Transpose and get an array of floating-point matrices.	
        /// </summary>	
        /// <remarks>	
        /// Transposing a matrix will rearrange the data order from row-column order to column-row order (or vice versa).	
        /// </remarks>	
        /// <param name="dataRef">A pointer to the first element of an array of tranposed matrices.</param>
        /// <param name="offset">The offset (in number of matrices) between the start of the array and the first matrix to get.</param>
        /// <param name="count">The number of matrices in the array to get.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetMatrixTransposeArray([None] float* pData,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetMatrixTransposeArray(float dataRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 32 * 4, &dataRef, offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A string-variable interface accesses a string variable.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectStringVariable</unmanaged>
    [Guid("71417501-8df9-4e0a-a78a-255f9756baff")]
    public partial class EffectStringVariable : SlimDX2.Direct3D10.EffectVariable {
        public EffectStringVariable(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the string.	
        /// </summary>	
        /// <param name="stringRef">A pointer to the string.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetString([None] const char** ppString)</unmanaged>
        public SlimDX2.Result GetString(string stringRef) {
            unsafe {
                IntPtr stringRef_ = Marshal.StringToHGlobalAnsi(stringRef);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 25 * 4, (void*)stringRef_);
                Marshal.FreeHGlobal(stringRef_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an array of strings.	
        /// </summary>	
        /// <param name="stringsRef">A pointer to the first string in the array.</param>
        /// <param name="offset">The offset (in number of strings) between the start of the array and the first string to get.</param>
        /// <param name="count">The number of strings in the returned array.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetStringArray([None] const char** ppStrings,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetStringArray(string stringsRef, int offset, int count) {
            unsafe {
                IntPtr stringsRef_ = Marshal.StringToHGlobalAnsi(stringsRef);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 26 * 4, (void*)stringsRef_, offset, count);
                Marshal.FreeHGlobal(stringsRef_ );
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A shader-resource interface accesses a shader resource.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectShaderResourceVariable</unmanaged>
    [Guid("c0a7157b-d872-4b1d-8073-efc2acd4b1fc")]
    public partial class EffectShaderResourceVariable : SlimDX2.Direct3D10.EffectVariable {
        public EffectShaderResourceVariable(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Set a shader resource.	
        /// </summary>	
        /// <param name="resourceRef">The address of a pointer to a shader-resource-view interface. See <see cref="SlimDX2.Direct3D10.ShaderResourceView"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetResource([None] ID3D10ShaderResourceView* pResource)</unmanaged>
        public SlimDX2.Result SetResource(SlimDX2.Direct3D10.ShaderResourceView resourceRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 25 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a shader resource.	
        /// </summary>	
        /// <param name="resourceRef">The address of a pointer to a shader-resource-view interface. See <see cref="SlimDX2.Direct3D10.ShaderResourceView"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetResource([None] ID3D10ShaderResourceView** ppResource)</unmanaged>
        public SlimDX2.Result GetResource(SlimDX2.Direct3D10.ShaderResourceView resourceRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 26 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set an array of shader resources.	
        /// </summary>	
        /// <param name="resourcesRef">The address of an array of shader-resource-view interfaces. See <see cref="SlimDX2.Direct3D10.ShaderResourceView"/>.</param>
        /// <param name="offset">The zero-based array index to get the first interface.</param>
        /// <param name="count">The number of elements in the array.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetResourceArray([None] ID3D10ShaderResourceView** ppResources,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetResourceArray(SlimDX2.Direct3D10.ShaderResourceView resourcesRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 27 * 4, (void*)((resourcesRef == null)?IntPtr.Zero:resourcesRef.NativePointer), offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an array of shader resources.	
        /// </summary>	
        /// <param name="resourcesRef">The address of an array of shader-resource-view interfaces. See <see cref="SlimDX2.Direct3D10.ShaderResourceView"/>.</param>
        /// <param name="offset">The zero-based array index to get the first interface.</param>
        /// <param name="count">The number of elements in the array.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetResourceArray([None] ID3D10ShaderResourceView** ppResources,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetResourceArray(SlimDX2.Direct3D10.ShaderResourceView resourcesRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 28 * 4, (void*)((resourcesRef == null)?IntPtr.Zero:resourcesRef.NativePointer), offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A render-target-view interface accesses a render target.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectRenderTargetViewVariable</unmanaged>
    [Guid("28ca0cc3-c2c9-40bb-b57f-67b737122b17")]
    public partial class EffectRenderTargetViewVariable : SlimDX2.Direct3D10.EffectVariable {
        public EffectRenderTargetViewVariable(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Set a render-target.	
        /// </summary>	
        /// <param name="resourceRef">A pointer to a render-target-view interface. See <see cref="SlimDX2.Direct3D10.RenderTargetView"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetRenderTarget([None] ID3D10RenderTargetView* pResource)</unmanaged>
        public SlimDX2.Result SetRenderTarget(SlimDX2.Direct3D10.RenderTargetView resourceRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 25 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a render-target.	
        /// </summary>	
        /// <param name="resourceRef">The address of a pointer to a render-target-view interface. See <see cref="SlimDX2.Direct3D10.RenderTargetView"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetRenderTarget([None] ID3D10RenderTargetView** ppResource)</unmanaged>
        public SlimDX2.Result GetRenderTarget(SlimDX2.Direct3D10.RenderTargetView resourceRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 26 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set an array of render-targets.	
        /// </summary>	
        /// <param name="resourcesRef">Set an array of render-target-view interfaces. See <see cref="SlimDX2.Direct3D10.RenderTargetView"/>.</param>
        /// <param name="offset">The zero-based array index to store the first interface.</param>
        /// <param name="count">The number of elements in the array.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetRenderTargetArray([None] ID3D10RenderTargetView** ppResources,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetRenderTargetArray(SlimDX2.Direct3D10.RenderTargetView resourcesRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 27 * 4, (void*)((resourcesRef == null)?IntPtr.Zero:resourcesRef.NativePointer), offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an array of render-targets.	
        /// </summary>	
        /// <param name="resourcesRef">A pointer to an array of render-target-view interfaces. See <see cref="SlimDX2.Direct3D10.RenderTargetView"/>.</param>
        /// <param name="offset">The zero-based array index to get the first interface.</param>
        /// <param name="count">The number of elements in the array.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetRenderTargetArray([None] ID3D10RenderTargetView** ppResources,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetRenderTargetArray(SlimDX2.Direct3D10.RenderTargetView resourcesRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 28 * 4, (void*)((resourcesRef == null)?IntPtr.Zero:resourcesRef.NativePointer), offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A depth-stencil-view-variable interface accesses a depth-stencil view.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectDepthStencilViewVariable</unmanaged>
    [Guid("3e02c918-cc79-4985-b622-2d92ad701623")]
    public partial class EffectDepthStencilViewVariable : SlimDX2.Direct3D10.EffectVariable {
        public EffectDepthStencilViewVariable(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Set a depth-stencil-view resource.	
        /// </summary>	
        /// <param name="resourceRef">A pointer to a depth-stencil-view interface. See <see cref="SlimDX2.Direct3D10.DepthStencilView"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetDepthStencil([None] ID3D10DepthStencilView* pResource)</unmanaged>
        public SlimDX2.Result SetDepthStencil(SlimDX2.Direct3D10.DepthStencilView resourceRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 25 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a depth-stencil-view resource.	
        /// </summary>	
        /// <param name="resourceRef">The address of a pointer to a depth-stencil-view interface. See <see cref="SlimDX2.Direct3D10.DepthStencilView"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetDepthStencil([None] ID3D10DepthStencilView** ppResource)</unmanaged>
        public SlimDX2.Result GetDepthStencil(SlimDX2.Direct3D10.DepthStencilView resourceRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 26 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set an array of depth-stencil-view resources.	
        /// </summary>	
        /// <param name="resourcesRef">A pointer to an array of depth-stencil-view interfaces. See <see cref="SlimDX2.Direct3D10.DepthStencilView"/>.</param>
        /// <param name="offset">The zero-based array index to set the first interface.</param>
        /// <param name="count">The number of elements in the array.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetDepthStencilArray([None] ID3D10DepthStencilView** ppResources,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result SetDepthStencilArray(SlimDX2.Direct3D10.DepthStencilView resourcesRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 27 * 4, (void*)((resourcesRef == null)?IntPtr.Zero:resourcesRef.NativePointer), offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an array of depth-stencil-view resources.	
        /// </summary>	
        /// <param name="resourcesRef">A pointer to an array of depth-stencil-view interfaces. See <see cref="SlimDX2.Direct3D10.DepthStencilView"/>.</param>
        /// <param name="offset">The zero-based array index to get the first interface.</param>
        /// <param name="count">The number of elements in the array.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetDepthStencilArray([None] ID3D10DepthStencilView** ppResources,[None] UINT Offset,[None] UINT Count)</unmanaged>
        public SlimDX2.Result GetDepthStencilArray(SlimDX2.Direct3D10.DepthStencilView resourcesRef, int offset, int count) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 28 * 4, (void*)((resourcesRef == null)?IntPtr.Zero:resourcesRef.NativePointer), offset, count);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A constant-buffer interface accesses constant buffers or texture buffers.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectConstantBuffer</unmanaged>
    [Guid("56648f4d-cc8b-4444-a5ad-b5a3d76e91b3")]
    public partial class EffectConstantBuffer : SlimDX2.Direct3D10.EffectVariable {
        public EffectConstantBuffer(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Set a constant-buffer.	
        /// </summary>	
        /// <param name="constantBufferRef">A pointer to a constant-buffer interface. See <see cref="SlimDX2.Direct3D10.Buffer"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetConstantBuffer([None] ID3D10Buffer* pConstantBuffer)</unmanaged>
        public SlimDX2.Result SetConstantBuffer(SlimDX2.Direct3D10.Buffer constantBufferRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 25 * 4, (void*)((constantBufferRef == null)?IntPtr.Zero:constantBufferRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a constant-buffer.	
        /// </summary>	
        /// <param name="constantBufferRef">The address of a pointer to a constant-buffer interface. See <see cref="SlimDX2.Direct3D10.Buffer"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetConstantBuffer([None] ID3D10Buffer** ppConstantBuffer)</unmanaged>
        public SlimDX2.Result GetConstantBuffer(SlimDX2.Direct3D10.Buffer constantBufferRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 26 * 4, (void*)((constantBufferRef == null)?IntPtr.Zero:constantBufferRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set a texture-buffer.	
        /// </summary>	
        /// <param name="textureBufferRef">A pointer to a shader-resource-view interface for accessing a texture buffer.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetTextureBuffer([None] ID3D10ShaderResourceView* pTextureBuffer)</unmanaged>
        public SlimDX2.Result SetTextureBuffer(SlimDX2.Direct3D10.ShaderResourceView textureBufferRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 27 * 4, (void*)((textureBufferRef == null)?IntPtr.Zero:textureBufferRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a texture-buffer.	
        /// </summary>	
        /// <param name="textureBufferRef">The address of a pointer to a shader-resource-view interface for accessing a texture buffer. See <see cref="SlimDX2.Direct3D10.ShaderResourceView"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetTextureBuffer([None] ID3D10ShaderResourceView** ppTextureBuffer)</unmanaged>
        public SlimDX2.Result GetTextureBuffer(SlimDX2.Direct3D10.ShaderResourceView textureBufferRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 28 * 4, (void*)((textureBufferRef == null)?IntPtr.Zero:textureBufferRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A shader-variable interface accesses a shader variable.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectShaderVariable</unmanaged>
    [Guid("80849279-c799-4797-8c33-0407a07d9e06")]
    public partial class EffectShaderVariable : SlimDX2.Direct3D10.EffectVariable {
        public EffectShaderVariable(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get a shader description.	
        /// </summary>	
        /// <param name="shaderIndex">A zero-based index.</param>
        /// <param name="descRef">A pointer to a shader description (see <see cref="SlimDX2.Direct3D10.EffectShaderDescription"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetShaderDesc([None] UINT ShaderIndex,[Out] D3D10_EFFECT_SHADER_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetShaderDescription(int shaderIndex, out SlimDX2.Direct3D10.EffectShaderDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.EffectShaderDescription.__Native descRef_ = new SlimDX2.Direct3D10.EffectShaderDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 25 * 4, shaderIndex, &descRef_);
                descRef = new SlimDX2.Direct3D10.EffectShaderDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a vertex shader.	
        /// </summary>	
        /// <param name="shaderIndex">A zero-based index.</param>
        /// <param name="vSRef">A pointer to a <see cref="SlimDX2.Direct3D10.VertexShader"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetVertexShader([None] UINT ShaderIndex,[None] ID3D10VertexShader** ppVS)</unmanaged>
        public SlimDX2.Result GetVertexShader(int shaderIndex, SlimDX2.Direct3D10.VertexShader vSRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 26 * 4, shaderIndex, (void*)((vSRef == null)?IntPtr.Zero:vSRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a geometry shader.	
        /// </summary>	
        /// <param name="shaderIndex">A zero-based index.</param>
        /// <param name="gSRef">A pointer to a <see cref="SlimDX2.Direct3D10.GeometryShader"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetGeometryShader([None] UINT ShaderIndex,[None] ID3D10GeometryShader** ppGS)</unmanaged>
        public SlimDX2.Result GetGeometryShader(int shaderIndex, SlimDX2.Direct3D10.GeometryShader gSRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 27 * 4, shaderIndex, (void*)((gSRef == null)?IntPtr.Zero:gSRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a pixel shader.	
        /// </summary>	
        /// <param name="shaderIndex">A zero-based index.</param>
        /// <param name="pSRef">A pointer to a <see cref="SlimDX2.Direct3D10.PixelShader"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetPixelShader([None] UINT ShaderIndex,[None] ID3D10PixelShader** ppPS)</unmanaged>
        public SlimDX2.Result GetPixelShader(int shaderIndex, SlimDX2.Direct3D10.PixelShader pSRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 28 * 4, shaderIndex, (void*)((pSRef == null)?IntPtr.Zero:pSRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an input-signature description.	
        /// </summary>	
        /// <remarks>	
        /// An effect contains one or more shaders; each shader has an input and output signature; each signature contains one or more elements (or parameters). The shader index identifies the shader and the element index identifies the element (or parameter) in the shader signature.	
        /// </remarks>	
        /// <param name="shaderIndex">A zero-based shader index.</param>
        /// <param name="element">A zero-based shader-element index.</param>
        /// <param name="descRef">A pointer to a parameter description (see <see cref="SlimDX2.Direct3D10.SignatureParameterDescription"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetInputSignatureElementDesc([None] UINT ShaderIndex,[None] UINT Element,[Out] D3D10_SIGNATURE_PARAMETER_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetInputSignatureElementDescription(int shaderIndex, int element, out SlimDX2.Direct3D10.SignatureParameterDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.SignatureParameterDescription.__Native descRef_ = new SlimDX2.Direct3D10.SignatureParameterDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 29 * 4, shaderIndex, element, &descRef_);
                descRef = new SlimDX2.Direct3D10.SignatureParameterDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an output-signature description.	
        /// </summary>	
        /// <remarks>	
        /// An effect contains one or more shaders; each shader has an input and output signature; each signature contains one or more elements (or parameters). The shader index identifies the shader and the element index identifies the element (or parameter) in the shader signature.	
        /// </remarks>	
        /// <param name="shaderIndex">A zero-based shader index.</param>
        /// <param name="element">A zero-based element index.</param>
        /// <param name="descRef">A pointer to a parameter description (see <see cref="SlimDX2.Direct3D10.SignatureParameterDescription"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetOutputSignatureElementDesc([None] UINT ShaderIndex,[None] UINT Element,[Out] D3D10_SIGNATURE_PARAMETER_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetOutputSignatureElementDescription(int shaderIndex, int element, out SlimDX2.Direct3D10.SignatureParameterDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.SignatureParameterDescription.__Native descRef_ = new SlimDX2.Direct3D10.SignatureParameterDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 30 * 4, shaderIndex, element, &descRef_);
                descRef = new SlimDX2.Direct3D10.SignatureParameterDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// The blend-variable interface accesses blend state.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectBlendVariable</unmanaged>
    [Guid("1fcd2294-df6d-4eae-86b3-0e9160cfb07b")]
    public partial class EffectBlendVariable : SlimDX2.Direct3D10.EffectVariable {
        public EffectBlendVariable(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get a pointer to a blend-state interface.	
        /// </summary>	
        /// <param name="index">Index into an array of blend-state interfaces. If there is only one blend-state interface, use 0.</param>
        /// <param name="blendStateRef">The address of a pointer to a blend-state interface (see <see cref="SlimDX2.Direct3D10.BlendState"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetBlendState([None] UINT Index,[None] ID3D10BlendState** ppBlendState)</unmanaged>
        public SlimDX2.Result GetBlendState(int index, SlimDX2.Direct3D10.BlendState blendStateRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 25 * 4, index, (void*)((blendStateRef == null)?IntPtr.Zero:blendStateRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a pointer to a blend-state variable.	
        /// </summary>	
        /// <remarks>	
        /// Effect variables are saved in memory in the backing store; when a technique is applied, the values in the backing store are copied to the device. Backing store data can used to recreate the variable when necessary.	
        /// </remarks>	
        /// <param name="index">Index into an array of blend-state descriptions. If there is only one blend-state variable in the effect, use 0.</param>
        /// <param name="blendDescRef">A pointer to a blend-state description (see <see cref="SlimDX2.Direct3D10.BlendStateDescription"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetBackingStore([None] UINT Index,[None] D3D10_BLEND_DESC* pBlendDesc)</unmanaged>
        public SlimDX2.Result GetBackingStore(int index, ref SlimDX2.Direct3D10.BlendStateDescription blendDescRef) {
            unsafe {
                SlimDX2.Direct3D10.BlendStateDescription.__Native blendDescRef_ = new SlimDX2.Direct3D10.BlendStateDescription.__Native();
                blendDescRef.__MarshalTo(ref blendDescRef_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 26 * 4, index, &blendDescRef_);
                blendDescRef_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A depth-stencil-variable interface accesses depth-stencil state.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectDepthStencilVariable</unmanaged>
    [Guid("af482368-330a-46a5-9a5c-01c71af24c8d")]
    public partial class EffectDepthStencilVariable : SlimDX2.Direct3D10.EffectVariable {
        public EffectDepthStencilVariable(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get a pointer to a depth-stencil interface.	
        /// </summary>	
        /// <param name="index">Index into an array of depth-stencil interfaces. If there is only one depth-stencil interface, use 0.</param>
        /// <param name="depthStencilStateRef">The address of a pointer to a blend-state interface (see <see cref="SlimDX2.Direct3D10.DepthStencilState"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetDepthStencilState([None] UINT Index,[None] ID3D10DepthStencilState** ppDepthStencilState)</unmanaged>
        public SlimDX2.Result GetDepthStencilState(int index, SlimDX2.Direct3D10.DepthStencilState depthStencilStateRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 25 * 4, index, (void*)((depthStencilStateRef == null)?IntPtr.Zero:depthStencilStateRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a pointer to a variable that contains depth-stencil state.	
        /// </summary>	
        /// <remarks>	
        /// Effect variables are saved in memory in the backing store; when a technique is applied, the values in the backing store are copied to the device. Backing store data can used to recreate the variable when necessary.	
        /// </remarks>	
        /// <param name="index">Index into an array of depth-stencil-state descriptions. If there is only one depth-stencil variable in the effect, use 0.</param>
        /// <param name="depthStencilDescRef">A pointer to a depth-stencil-state description (see <see cref="SlimDX2.Direct3D10.DepthStencilStateDescription"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetBackingStore([None] UINT Index,[None] D3D10_DEPTH_STENCIL_DESC* pDepthStencilDesc)</unmanaged>
        public SlimDX2.Result GetBackingStore(int index, ref SlimDX2.Direct3D10.DepthStencilStateDescription depthStencilDescRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* depthStencilDescRef_ = &depthStencilDescRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 26 * 4, index, depthStencilDescRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A rasterizer-variable interface accesses rasterizer state.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectRasterizerVariable</unmanaged>
    [Guid("21af9f0e-4d94-4ea9-9785-2cb76b8c0b34")]
    public partial class EffectRasterizerVariable : SlimDX2.Direct3D10.EffectVariable {
        public EffectRasterizerVariable(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get a pointer to a rasterizer interface.	
        /// </summary>	
        /// <param name="index">Index into an array of rasterizer interfaces. If there is only one rasterizer interface, use 0.</param>
        /// <param name="rasterizerStateRef">The address of a pointer to a rasterizer interface (see <see cref="SlimDX2.Direct3D10.RasterizerState"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetRasterizerState([None] UINT Index,[None] ID3D10RasterizerState** ppRasterizerState)</unmanaged>
        public SlimDX2.Result GetRasterizerState(int index, SlimDX2.Direct3D10.RasterizerState rasterizerStateRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 25 * 4, index, (void*)((rasterizerStateRef == null)?IntPtr.Zero:rasterizerStateRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a pointer to a variable that contains rasteriser state.	
        /// </summary>	
        /// <remarks>	
        /// Effect variables are saved in memory in the backing store; when a technique is applied, the values in the backing store are copied to the device. Backing store data can used to recreate the variable when necessary.	
        /// </remarks>	
        /// <param name="index">Index into an array of rasteriser-state descriptions. If there is only one rasteriser variable in the effect, use 0.</param>
        /// <param name="rasterizerDescRef">A pointer to a rasteriser-state description (see <see cref="SlimDX2.Direct3D10.RasterizerStateDescription"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetBackingStore([None] UINT Index,[None] D3D10_RASTERIZER_DESC* pRasterizerDesc)</unmanaged>
        public SlimDX2.Result GetBackingStore(int index, ref SlimDX2.Direct3D10.RasterizerStateDescription rasterizerDescRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* rasterizerDescRef_ = &rasterizerDescRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 26 * 4, index, rasterizerDescRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A sampler interface accesses sampler state.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectSamplerVariable</unmanaged>
    [Guid("6530d5c7-07e9-4271-a418-e7ce4bd1e480")]
    public partial class EffectSamplerVariable : SlimDX2.Direct3D10.EffectVariable {
        public EffectSamplerVariable(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get a pointer to a sampler interface.	
        /// </summary>	
        /// <param name="index">Index into an array of sampler interfaces. If there is only one sampler interface, use 0.</param>
        /// <param name="samplerRef">The address of a pointer to a sampler interface (see <see cref="SlimDX2.Direct3D10.SamplerState"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetSampler([None] UINT Index,[None] ID3D10SamplerState** ppSampler)</unmanaged>
        public SlimDX2.Result GetSampler(int index, SlimDX2.Direct3D10.SamplerState samplerRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 25 * 4, index, (void*)((samplerRef == null)?IntPtr.Zero:samplerRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a pointer to a variable that contains sampler state.	
        /// </summary>	
        /// <param name="index">Index into an array of sampler descriptions. If there is only one sampler variable in the effect, use 0.</param>
        /// <param name="samplerDescRef">A pointer to a sampler description (see <see cref="SlimDX2.Direct3D10.SamplerStateDescription"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetBackingStore([None] UINT Index,[None] D3D10_SAMPLER_DESC* pSamplerDesc)</unmanaged>
        public SlimDX2.Result GetBackingStore(int index, ref SlimDX2.Direct3D10.SamplerStateDescription samplerDescRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* samplerDescRef_ = &samplerDescRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 26 * 4, index, samplerDescRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A pass interface encapsulates state assignments within a technique.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectPass</unmanaged>
    [Guid("5cfbeb89-1a06-46e0-b282-e3f9bfa36a54")]
    public partial class EffectPass : SlimDX2.CppObject {
        public EffectPass(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Test a pass to see if it contains valid syntax.	
        /// </summary>	
        /// <unmanaged>BOOL IsValid()</unmanaged>
        public bool IsValid {
                get { return IsValid_(); }
        }
        
        /// <summary>	
        /// Get a pass description.	
        /// </summary>	
        /// <remarks>	
        /// A pass is a block of code that sets render state and shaders (which in turn sets constant buffers, samplers and textures). An effect technique contains one or more passes. See {{techniques and passes}}.	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_PASS_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.EffectPassDescription Description {
                get { SlimDX2.Direct3D10.EffectPassDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Test a pass to see if it contains valid syntax.	
        /// </summary>	
        /// <returns>TRUE if the code syntax is valid; otherwise FALSE.</returns>
        /// <unmanaged>BOOL IsValid()</unmanaged>
        internal bool IsValid_() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 0 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a pass description.	
        /// </summary>	
        /// <remarks>	
        /// A pass is a block of code that sets render state and shaders (which in turn sets constant buffers, samplers and textures). An effect technique contains one or more passes. See {{techniques and passes}}.	
        /// </remarks>	
        /// <param name="descRef">A pointer to a pass description (see <see cref="SlimDX2.Direct3D10.EffectPassDescription"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_PASS_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D10.EffectPassDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.EffectPassDescription.__Native descRef_ = new SlimDX2.Direct3D10.EffectPassDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 1 * 4, &descRef_);
                descRef = new SlimDX2.Direct3D10.EffectPassDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a vertex-shader description.	
        /// </summary>	
        /// <remarks>	
        /// An effect pass can contain render state assignments and shader object assignments.	
        /// </remarks>	
        /// <param name="descRef">A pointer to a vertex-shader description (see <see cref="SlimDX2.Direct3D10.EffectPassShaderDescription"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetVertexShaderDesc([None] D3D10_PASS_SHADER_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetVertexShaderDescription(SlimDX2.Direct3D10.EffectPassShaderDescription descRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 2 * 4, &descRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a geometry-shader description.	
        /// </summary>	
        /// <remarks>	
        /// An effect pass can contain render state assignments and shader object assignments.	
        /// </remarks>	
        /// <param name="descRef">A pointer to a geometry-shader description (see <see cref="SlimDX2.Direct3D10.EffectPassShaderDescription"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetGeometryShaderDesc([None] D3D10_PASS_SHADER_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetGeometryShaderDescription(SlimDX2.Direct3D10.EffectPassShaderDescription descRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 3 * 4, &descRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a pixel-shader description.	
        /// </summary>	
        /// <remarks>	
        /// An effect pass can contain render state assignments and shader object assignments.	
        /// </remarks>	
        /// <param name="descRef">A pointer to a pixel-shader description (see <see cref="SlimDX2.Direct3D10.EffectPassShaderDescription"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetPixelShaderDesc([None] D3D10_PASS_SHADER_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetPixelShaderDescription(SlimDX2.Direct3D10.EffectPassShaderDescription descRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 4 * 4, &descRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an annotation by index.	
        /// </summary>	
        /// <param name="index">A zero-based index.</param>
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectVariable* GetAnnotationByIndex([None] UINT Index)</unmanaged>
        public SlimDX2.Direct3D10.EffectVariable GetAnnotationByIndex(int index) {
            unsafe {
                SlimDX2.Direct3D10.EffectVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectVariable)new SlimDX2.Direct3D10.EffectVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 5 * 4, index));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an annotation by name.	
        /// </summary>	
        /// <param name="name">The name of the annotation.</param>
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectVariable* GetAnnotationByName([None] const char* Name)</unmanaged>
        public SlimDX2.Direct3D10.EffectVariable GetAnnotationByName(string name) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D10.EffectVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectVariable)new SlimDX2.Direct3D10.EffectVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 6 * 4, (void*)name_));
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set the state contained in a pass to the device.	
        /// </summary>	
        /// <param name="flags">Unused.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT Apply([None] UINT Flags)</unmanaged>
        internal SlimDX2.Result Apply(int flags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 7 * 4, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Generate a mask for allowing/preventing state changes.	
        /// </summary>	
        /// <param name="stateBlockMaskRef">A pointer to a state-block mask (see <see cref="SlimDX2.Direct3D10.StateBlockMask"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT ComputeStateBlockMask([Out] D3D10_STATE_BLOCK_MASK* pStateBlockMask)</unmanaged>
        public SlimDX2.Result ComputeStateBlockMask(out SlimDX2.Direct3D10.StateBlockMask stateBlockMaskRef) {
            unsafe {
                SlimDX2.Direct3D10.StateBlockMask.__Native stateBlockMaskRef_ = new SlimDX2.Direct3D10.StateBlockMask.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 8 * 4, &stateBlockMaskRef_);
                stateBlockMaskRef = new SlimDX2.Direct3D10.StateBlockMask();
                stateBlockMaskRef.__MarshalFrom(ref stateBlockMaskRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// An ID3D10EffectTechnique interface is a collection of passes.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectTechnique</unmanaged>
    [Guid("db122ce8-d1c9-4292-b237-24ed3de8b175")]
    public partial class EffectTechnique : SlimDX2.CppObject {
        public EffectTechnique(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Test a technique to see if it contains valid syntax.	
        /// </summary>	
        /// <unmanaged>BOOL IsValid()</unmanaged>
        public bool IsValid {
                get { return IsValid_(); }
        }
        
        /// <summary>	
        /// Get a technique description.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_TECHNIQUE_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.EffectTechniqueDescription Description {
                get { SlimDX2.Direct3D10.EffectTechniqueDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Test a technique to see if it contains valid syntax.	
        /// </summary>	
        /// <returns>TRUE if the code syntax is valid; otherwise FALSE.</returns>
        /// <unmanaged>BOOL IsValid()</unmanaged>
        internal bool IsValid_() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 0 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a technique description.	
        /// </summary>	
        /// <param name="descRef">A pointer to a technique description (see <see cref="SlimDX2.Direct3D10.EffectTechniqueDescription"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_TECHNIQUE_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D10.EffectTechniqueDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.EffectTechniqueDescription.__Native descRef_ = new SlimDX2.Direct3D10.EffectTechniqueDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 1 * 4, &descRef_);
                descRef = new SlimDX2.Direct3D10.EffectTechniqueDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an annotation by index.	
        /// </summary>	
        /// <remarks>	
        /// Use an annotation to attach a piece of metadata to a technique.	
        /// </remarks>	
        /// <param name="index">The zero-based index of the interface pointer.</param>
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectVariable* GetAnnotationByIndex([None] UINT Index)</unmanaged>
        public SlimDX2.Direct3D10.EffectVariable GetAnnotationByIndex(int index) {
            unsafe {
                SlimDX2.Direct3D10.EffectVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectVariable)new SlimDX2.Direct3D10.EffectVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 2 * 4, index));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an annotation by name.	
        /// </summary>	
        /// <remarks>	
        /// Use an annotation to attach a piece of metadata to a technique.	
        /// </remarks>	
        /// <param name="name">Name of the annotation.</param>
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectVariable* GetAnnotationByName([None] const char* Name)</unmanaged>
        public SlimDX2.Direct3D10.EffectVariable GetAnnotationByName(string name) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D10.EffectVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectVariable)new SlimDX2.Direct3D10.EffectVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 3 * 4, (void*)name_));
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a pass by index.	
        /// </summary>	
        /// <remarks>	
        /// A technique contains one or more passes; get a pass using a name or an index.	
        /// </remarks>	
        /// <param name="index">A zero-based index.</param>
        /// <returns>A pointer to a <see cref="SlimDX2.Direct3D10.EffectPass"/>.</returns>
        /// <unmanaged>ID3D10EffectPass* GetPassByIndex([None] UINT Index)</unmanaged>
        public SlimDX2.Direct3D10.EffectPass GetPassByIndex(int index) {
            unsafe {
                SlimDX2.Direct3D10.EffectPass __result__;
                __result__= (SlimDX2.Direct3D10.EffectPass)new SlimDX2.Direct3D10.EffectPass((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 4 * 4, index));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a pass by name.	
        /// </summary>	
        /// <remarks>	
        /// A technique contains one or more passes; get a pass using a name or an index.	
        /// </remarks>	
        /// <param name="name">The name of the pass.</param>
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectPass"/>.</returns>
        /// <unmanaged>ID3D10EffectPass* GetPassByName([None] const char* Name)</unmanaged>
        public SlimDX2.Direct3D10.EffectPass GetPassByName(string name) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D10.EffectPass __result__;
                __result__= (SlimDX2.Direct3D10.EffectPass)new SlimDX2.Direct3D10.EffectPass((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 5 * 4, (void*)name_));
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Compute a state-block mask to allow/prevent state changes.	
        /// </summary>	
        /// <param name="stateBlockMaskRef">A pointer to a state-block mask (see <see cref="SlimDX2.Direct3D10.StateBlockMask"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT ComputeStateBlockMask([Out] D3D10_STATE_BLOCK_MASK* pStateBlockMask)</unmanaged>
        public SlimDX2.Result ComputeStateBlockMask(out SlimDX2.Direct3D10.StateBlockMask stateBlockMaskRef) {
            unsafe {
                SlimDX2.Direct3D10.StateBlockMask.__Native stateBlockMaskRef_ = new SlimDX2.Direct3D10.StateBlockMask.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 6 * 4, &stateBlockMaskRef_);
                stateBlockMaskRef = new SlimDX2.Direct3D10.StateBlockMask();
                stateBlockMaskRef.__MarshalFrom(ref stateBlockMaskRef_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// An ID3D10Effect interface manages a set of state objects, resources and shaders for implementing a rendering effect.	
    /// </summary>	
    /// <unmanaged>ID3D10Effect</unmanaged>
    [Guid("51b0ca8b-ec0b-4519-870d-8ee1cb5017c7")]
    public partial class Effect : SlimDX2.ComObject {
        public Effect(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Test an effect to see if it contains valid syntax.	
        /// </summary>	
        /// <unmanaged>BOOL IsValid()</unmanaged>
        public bool IsValid {
                get { return IsValid_(); }
        }
        
        /// <summary>	
        /// Test an effect to see if it is part of a memory pool.	
        /// </summary>	
        /// <unmanaged>BOOL IsPool()</unmanaged>
        public bool IsPool {
                get { return IsPool_(); }
        }
        
        /// <summary>	
        /// Get the device that created the effect.	
        /// </summary>	
        /// <remarks>	
        /// An effect is created for a specific device, by calling a function such as {{D3DX10CreateEffectFromFile}}.	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>
        public SlimDX2.Direct3D10.Device Device {
                get { SlimDX2.Direct3D10.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get an effect description.	
        /// </summary>	
        /// <remarks>	
        /// An effect description contains basic information about an effect such as the techniques it contains and the constant buffer resources it requires.	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_EFFECT_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.EffectDescription Description {
                get { SlimDX2.Direct3D10.EffectDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Test an effect to see if the reflection metadata has been removed from memory.	
        /// </summary>	
        /// <remarks>	
        /// An effect uses memory space two different ways: to store the information required by the runtime to execute an effect, and to store the metadata required to reflect information back to an application using the API. You can minimize the amount of memory required by an effect by calling <see cref="SlimDX2.Direct3D10.Effect.Optimize"/> which removes the reflection metadata from memory. Of course, API methods to read variables will no longer work once reflection data has been removed.	
        /// </remarks>	
        /// <unmanaged>BOOL IsOptimized()</unmanaged>
        public bool IsOptimized {
                get { return IsOptimized_(); }
        }
        
        /// <summary>	
        /// Test an effect to see if it contains valid syntax.	
        /// </summary>	
        /// <returns>TRUE if the code syntax is valid; otherwise FALSE.</returns>
        /// <unmanaged>BOOL IsValid()</unmanaged>
        internal bool IsValid_() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 3 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Test an effect to see if it is part of a memory pool.	
        /// </summary>	
        /// <returns>TRUE if the effect is pooled; otherwise FALSE. See <see cref="SlimDX2.Direct3D10.EffectPool"/>.</returns>
        /// <unmanaged>BOOL IsPool()</unmanaged>
        internal bool IsPool_() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 4 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the device that created the effect.	
        /// </summary>	
        /// <remarks>	
        /// An effect is created for a specific device, by calling a function such as {{D3DX10CreateEffectFromFile}}.	
        /// </remarks>	
        /// <param name="deviceRef">A pointer to an <see cref="SlimDX2.Direct3D10.Device"/>.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D10.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 5 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get an effect description.	
        /// </summary>	
        /// <remarks>	
        /// An effect description contains basic information about an effect such as the techniques it contains and the constant buffer resources it requires.	
        /// </remarks>	
        /// <param name="descRef">A pointer to an effect description (see <see cref="SlimDX2.Direct3D10.EffectDescription"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_EFFECT_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D10.EffectDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D10.EffectDescription();
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 6 * 4, descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a constant buffer by index.	
        /// </summary>	
        /// <remarks>	
        /// An effect that contains a variable that will be read/written by an application requires at least one constant buffer. For best performance, an effect should organize variables into one or more constant buffers based on their frequency of update.	
        /// </remarks>	
        /// <param name="index">A zero-based index.</param>
        /// <returns>A pointer to a <see cref="SlimDX2.Direct3D10.EffectConstantBuffer"/>.</returns>
        /// <unmanaged>ID3D10EffectConstantBuffer* GetConstantBufferByIndex([None] UINT Index)</unmanaged>
        public SlimDX2.Direct3D10.EffectConstantBuffer GetConstantBufferByIndex(int index) {
            unsafe {
                SlimDX2.Direct3D10.EffectConstantBuffer __result__;
                __result__= (SlimDX2.Direct3D10.EffectConstantBuffer)new SlimDX2.Direct3D10.EffectConstantBuffer((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 7 * 4, index));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a constant buffer by name.	
        /// </summary>	
        /// <remarks>	
        /// An effect that contains a variable that will be read/written by an application requires at least one constant buffer. For best performance, an effect should organize variables into one or more constant buffers based on their frequency of update.	
        /// </remarks>	
        /// <param name="name">The constant-buffer name.</param>
        /// <returns>A pointer to the constant buffer indicated by the Name. See <see cref="SlimDX2.Direct3D10.EffectConstantBuffer"/>.</returns>
        /// <unmanaged>ID3D10EffectConstantBuffer* GetConstantBufferByName([None] const char* Name)</unmanaged>
        public SlimDX2.Direct3D10.EffectConstantBuffer GetConstantBufferByName(string name) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D10.EffectConstantBuffer __result__;
                __result__= (SlimDX2.Direct3D10.EffectConstantBuffer)new SlimDX2.Direct3D10.EffectConstantBuffer((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 8 * 4, (void*)name_));
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a variable by index.	
        /// </summary>	
        /// <remarks>	
        /// An effect may contain one or more variables. Variables outside of a technique are considered global to all effects, those located inside of a technique are local to that technique. You can access any local non-static effect variable using its name or with an index.The method returns a pointer to an {{effect-variable interface}} if a variable is not found; you can call <see cref="SlimDX2.Direct3D10.Effect.IsValid_"/> to verify whether or not the index exists.	
        /// </remarks>	
        /// <param name="index">A zero-based index.</param>
        /// <returns>A pointer to a <see cref="SlimDX2.Direct3D10.EffectVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectVariable* GetVariableByIndex([None] UINT Index)</unmanaged>
        public SlimDX2.Direct3D10.EffectVariable GetVariableByIndex(int index) {
            unsafe {
                SlimDX2.Direct3D10.EffectVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectVariable)new SlimDX2.Direct3D10.EffectVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 9 * 4, index));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a variable by name.	
        /// </summary>	
        /// <remarks>	
        /// An effect may contain one or more variables. Variables outside of a technique are considered global to all effects, those located inside of a technique are local to that technique. You can access an effect variable using its name or with an index.The method returns a pointer to an {{effect-variable interface}} if a variable is not found; you can call <see cref="SlimDX2.Direct3D10.Effect.IsValid_"/> to verify whether or not the name exists.	
        /// </remarks>	
        /// <param name="name">The variable name.</param>
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectVariable* GetVariableByName([None] const char* Name)</unmanaged>
        public SlimDX2.Direct3D10.EffectVariable GetVariableByName(string name) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D10.EffectVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectVariable)new SlimDX2.Direct3D10.EffectVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 10 * 4, (void*)name_));
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a variable by semantic.	
        /// </summary>	
        /// <remarks>	
        /// Each effect variable can have a semantic attached, which is a user defined metadata string. Some {{system-value semantics}} are reserved words that trigger built in functionality by pipeline stages.The method returns a pointer to an {{effect-variable interface}} if a variable is not found; you can call <see cref="SlimDX2.Direct3D10.Effect.IsValid_"/> to verify whether or not the semantic exists.	
        /// </remarks>	
        /// <param name="semantic">The semantic name.</param>
        /// <returns>A pointer to the effect variable indicated by the Semantic. See <see cref="SlimDX2.Direct3D10.EffectVariable"/>.</returns>
        /// <unmanaged>ID3D10EffectVariable* GetVariableBySemantic([None] const char* Semantic)</unmanaged>
        public SlimDX2.Direct3D10.EffectVariable GetVariableBySemantic(string semantic) {
            unsafe {
                IntPtr semantic_ = Marshal.StringToHGlobalAnsi(semantic);
                SlimDX2.Direct3D10.EffectVariable __result__;
                __result__= (SlimDX2.Direct3D10.EffectVariable)new SlimDX2.Direct3D10.EffectVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 11 * 4, (void*)semantic_));
                Marshal.FreeHGlobal(semantic_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a technique by index.	
        /// </summary>	
        /// <remarks>	
        /// An effect contains one or more techniques; each technique contains one or more passes. You can access a technique using its name or with an index.  For more about techniques, see {{techniques and passes}}.	
        /// </remarks>	
        /// <param name="index">A zero-based index.</param>
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectTechnique"/>.</returns>
        /// <unmanaged>ID3D10EffectTechnique* GetTechniqueByIndex([None] UINT Index)</unmanaged>
        public SlimDX2.Direct3D10.EffectTechnique GetTechniqueByIndex(int index) {
            unsafe {
                SlimDX2.Direct3D10.EffectTechnique __result__;
                __result__= (SlimDX2.Direct3D10.EffectTechnique)new SlimDX2.Direct3D10.EffectTechnique((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 12 * 4, index));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a technique by name.	
        /// </summary>	
        /// <remarks>	
        /// An effect contains one or more techniques; each technique contains one or more passes. You can access a technique using its name or with an index. For more about techniques, see {{techniques and passes}}.	
        /// </remarks>	
        /// <param name="name">The name of the technique.</param>
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.EffectTechnique"/>, or NULL if the technique is not found.</returns>
        /// <unmanaged>ID3D10EffectTechnique* GetTechniqueByName([None] const char* Name)</unmanaged>
        public SlimDX2.Direct3D10.EffectTechnique GetTechniqueByName(string name) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D10.EffectTechnique __result__;
                __result__= (SlimDX2.Direct3D10.EffectTechnique)new SlimDX2.Direct3D10.EffectTechnique((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 13 * 4, (void*)name_));
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Minimize the amount of memory required for an effect.	
        /// </summary>	
        /// <remarks>	
        /// An effect uses memory space two different ways: to store the information required by the runtime to execute an effect, and to store the metadata  required to reflect information back to an application using the API. You can minimize the amount of memory required by an effect by  calling ID3D10Effect::Optimize which removes the reflection metadata from memory. API methods to read variables will no  longer work once reflection data has been removed.The following methods will fail after Optimize has been called on an effect.<see cref="SlimDX2.Direct3D10.Effect.GetConstantBufferByIndex"/><see cref="SlimDX2.Direct3D10.Effect.GetConstantBufferByName"/><see cref="SlimDX2.Direct3D10.Effect.GetDescription"/><see cref="SlimDX2.Direct3D10.Effect.GetDevice"/><see cref="SlimDX2.Direct3D10.Effect.GetTechniqueByIndex"/><see cref="SlimDX2.Direct3D10.Effect.GetTechniqueByName"/><see cref="SlimDX2.Direct3D10.Effect.GetVariableByIndex"/><see cref="SlimDX2.Direct3D10.Effect.GetVariableByName"/><see cref="SlimDX2.Direct3D10.Effect.GetVariableBySemantic"/>Note that references retrieved with these methods before calling ID3D10Effect::Optimize are still valid  after ID3D10Effect::Optimize is called.  This allows the application to get all the variables, techniques, and passes it will use,  call Optimize, and then use the effect.	
        /// </remarks>	
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT Optimize()</unmanaged>
        public SlimDX2.Result Optimize() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 14 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Test an effect to see if the reflection metadata has been removed from memory.	
        /// </summary>	
        /// <remarks>	
        /// An effect uses memory space two different ways: to store the information required by the runtime to execute an effect, and to store the metadata required to reflect information back to an application using the API. You can minimize the amount of memory required by an effect by calling <see cref="SlimDX2.Direct3D10.Effect.Optimize"/> which removes the reflection metadata from memory. Of course, API methods to read variables will no longer work once reflection data has been removed.	
        /// </remarks>	
        /// <returns>TRUE if the effect is optimized; otherwise FALSE.</returns>
        /// <unmanaged>BOOL IsOptimized()</unmanaged>
        internal bool IsOptimized_() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 15 * 4));
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A pool interface represents a common memory space (or pool) for sharing variables between effects.	
    /// </summary>	
    /// <unmanaged>ID3D10EffectPool</unmanaged>
    [Guid("9537ab04-3250-412e-8213-fcd2f8677933")]
    public partial class EffectPool : SlimDX2.ComObject {
        public EffectPool(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the effect that created the effect pool.	
        /// </summary>	
        /// <returns>A pointer to an <see cref="SlimDX2.Direct3D10.Effect"/> interface.</returns>
        /// <unmanaged>ID3D10Effect* AsEffect()</unmanaged>
        public SlimDX2.Direct3D10.Effect AsEffect() {
            unsafe {
                SlimDX2.Direct3D10.Effect __result__;
                __result__= (SlimDX2.Direct3D10.Effect)new SlimDX2.Direct3D10.Effect((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 3 * 4));
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// This blend-state interface accesses blending state for a Direct3D 10.1 device for the {{output-merger}} stage.	
    /// </summary>	
    /// <unmanaged>ID3D10BlendState1</unmanaged>
    [Guid("EDAD8D99-8A35-4d6d-8566-2EA276CDE161")]
    public partial class BlendState1 : SlimDX2.Direct3D10.BlendState {
        public BlendState1(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>void GetDesc1([Out] D3D10_BLEND_DESC1* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.BlendDescription1 Description1 {
                get { SlimDX2.Direct3D10.BlendDescription1 __output__; GetDescription1(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="descRef">No documentation.</param>
        /// <unmanaged>void GetDesc1([Out] D3D10_BLEND_DESC1* pDesc)</unmanaged>
        internal void GetDescription1(out SlimDX2.Direct3D10.BlendDescription1 descRef) {
            unsafe {
                SlimDX2.Direct3D10.BlendDescription1.__Native descRef_ = new SlimDX2.Direct3D10.BlendDescription1.__Native();
                SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 8 * 4, &descRef_);
                descRef = new SlimDX2.Direct3D10.BlendDescription1();
                descRef.__MarshalFrom(ref descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A shader-resource-view interface specifies the {{subresources}} a shader can access during rendering. Examples of shader resources include a constant buffer, a texture buffer, a texture or a sampler.	
    /// </summary>	
    /// <unmanaged>ID3D10ShaderResourceView1</unmanaged>
    [Guid("9B7E4C87-342C-4106-A19F-4F2704F689F0")]
    public partial class ShaderResourceView1 : SlimDX2.Direct3D10.ShaderResourceView {
        public ShaderResourceView1(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the shader resource view's description.	
        /// </summary>	
        /// <remarks>	
        /// This method requires Windows Vista Service Pack 1.	
        /// </remarks>	
        /// <unmanaged>void GetDesc1([Out] D3D10_SHADER_RESOURCE_VIEW_DESC1* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.ShaderResourceViewDescription1 Description1 {
                get { SlimDX2.Direct3D10.ShaderResourceViewDescription1 __output__; GetDescription1(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the shader resource view's description.	
        /// </summary>	
        /// <remarks>	
        /// This method requires Windows Vista Service Pack 1.	
        /// </remarks>	
        /// <param name="descRef">A pointer to a <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription1"/> structure to be filled with data about the shader resource view.</param>
        /// <unmanaged>void GetDesc1([Out] D3D10_SHADER_RESOURCE_VIEW_DESC1* pDesc)</unmanaged>
        internal void GetDescription1(out SlimDX2.Direct3D10.ShaderResourceViewDescription1 descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D10.ShaderResourceViewDescription1();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Direct3D10.LocalInterop.Callivoid(_nativePointer, 9 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// The device interface represents a virtual adapter for Direct3D 10.1; it is used to perform rendering and create Direct3D resources.	
    /// </summary>	
    /// <unmanaged>ID3D10Device1</unmanaged>
    [Guid("9B7E4C8F-342C-4106-A19F-4F2704F689F0")]
    public partial class Device1 : SlimDX2.Direct3D10.Device {
        public Device1(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the feature level of the hardware device.	
        /// </summary>	
        /// <remarks>	
        /// This method requires Windows Vista Service Pack 1.	
        /// </remarks>	
        /// <unmanaged>D3D_FEATURE_LEVEL GetFeatureLevel()</unmanaged>
        public SlimDX2.Direct3D.FeatureLevel FeatureLevel {
                get { return GetFeatureLevel(); }
        }
        
        /// <summary>	
        /// Create a shader-resource {{view}} for accessing data in a resource.	
        /// </summary>	
        /// <remarks>	
        /// A resource is made up of one or more {{subresources}}, a view identifies which subresources to allow the pipeline to access. In addition, each resource is bound to the pipeline using a view. A shader-resource view is designed to bind any buffer or texture resource to the {{shader stages}} using the following API methods: {{VSSetShaderResources}}, {{GSSetShaderResources}} and {{PSSetShaderResources}}.Since a view is fully typed, this means that typeless resources become fully typed when bound to the pipeline.This method requires Windows Vista Service Pack 1.	
        /// </remarks>	
        /// <param name="resourceRef">Pointer to the {{resource}} that will serve as input to a shader. This resource must have been created with the <see cref="SlimDX2.Direct3D10.BindFlags.ShaderResource"/> flag.</param>
        /// <param name="descRef">Pointer to a shader-resource-view description (see <see cref="SlimDX2.Direct3D10.ShaderResourceViewDescription1"/>). Set this parameter to NULL to create a view that accesses the entire resource (using the format the resource was created with).</param>
        /// <param name="sRViewRef">Address of a pointer to a shader-resource view (see <see cref="SlimDX2.Direct3D10.ShaderResourceView1"/>). Set this parameter to NULL to validate the other input parameters (the method will return S_FALSE if the other input parameters pass validation).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateShaderResourceView1([In] ID3D10Resource* pResource,[In, Optional] const D3D10_SHADER_RESOURCE_VIEW_DESC1* pDesc,[Out, Optional] ID3D10ShaderResourceView1** ppSRView)</unmanaged>
        public SlimDX2.Result CreateShaderResourceView1(SlimDX2.Direct3D10.Resource resourceRef, SlimDX2.Direct3D10.ShaderResourceViewDescription1? descRef, out SlimDX2.Direct3D10.ShaderResourceView1 sRViewRef) {
            unsafe {
                SlimDX2.Direct3D10.ShaderResourceViewDescription1 descRef_;
                if (descRef.HasValue)
                    descRef_ = descRef.Value;				
                IntPtr sRViewRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 98 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), (descRef.HasValue)?&descRef_:(void*)IntPtr.Zero, &sRViewRef_);
                sRViewRef = (sRViewRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.ShaderResourceView1(sRViewRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a blend-state object that encapsules blend state for the output-merger stage.	
        /// </summary>	
        /// <remarks>	
        /// An application can create up to 4096 unique blend-state objects. For each object created, the runtime checks to see if a previous object has the same state. If such a previous object exists, the runtime will return a pointer to previous instance instead of creating a duplicate object.This method requires Windows Vista Service Pack 1.	
        /// </remarks>	
        /// <param name="blendStateDescRef">Pointer to a blend-state description (see <see cref="SlimDX2.Direct3D10.BlendDescription1"/>).</param>
        /// <param name="blendStateRef">Address of a pointer to the blend-state object created (see <see cref="SlimDX2.Direct3D10.BlendState1"/>).</param>
        /// <returns>This method returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateBlendState1([In] const D3D10_BLEND_DESC1* pBlendStateDesc,[Out, Optional] ID3D10BlendState1** ppBlendState)</unmanaged>
        public SlimDX2.Result CreateBlendState1(ref SlimDX2.Direct3D10.BlendDescription1 blendStateDescRef, out SlimDX2.Direct3D10.BlendState1 blendStateRef) {
            unsafe {
                SlimDX2.Direct3D10.BlendDescription1.__Native blendStateDescRef_ = new SlimDX2.Direct3D10.BlendDescription1.__Native();
                blendStateDescRef.__MarshalTo(ref blendStateDescRef_);
                IntPtr blendStateRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 99 * 4, &blendStateDescRef_, &blendStateRef_);
                blendStateDescRef_.__MarshalFree();
                blendStateRef = (blendStateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.BlendState1(blendStateRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the feature level of the hardware device.	
        /// </summary>	
        /// <remarks>	
        /// This method requires Windows Vista Service Pack 1.	
        /// </remarks>	
        /// <returns>The feature level (see {{D3D10_FEATURE_LEVEL1}}).</returns>
        /// <unmanaged>D3D_FEATURE_LEVEL GetFeatureLevel()</unmanaged>
        internal SlimDX2.Direct3D.FeatureLevel GetFeatureLevel() {
            unsafe {
                SlimDX2.Direct3D.FeatureLevel __result__;
                __result__= (SlimDX2.Direct3D.FeatureLevel)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 100 * 4);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A shader-reflection interface accesses shader information.	
    /// </summary>	
    /// <unmanaged>ID3D10ShaderReflection1</unmanaged>
    [Guid("c3457783-a846-47ce-9520-cea6f66e7447")]
    public partial class ShaderReflection1 : SlimDX2.ComObject {
        public ShaderReflection1(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_SHADER_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.ShaderDescription Description {
                get { SlimDX2.Direct3D10.ShaderDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="descRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT GetDesc([Out] D3D10_SHADER_DESC* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D10.ShaderDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.ShaderDescription.__Native descRef_ = new SlimDX2.Direct3D10.ShaderDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 3 * 4, &descRef_);
                descRef = new SlimDX2.Direct3D10.ShaderDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="index">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>ID3D10ShaderReflectionConstantBuffer* GetConstantBufferByIndex([None] UINT Index)</unmanaged>
        public SlimDX2.Direct3D10.ShaderReflectionConstantBuffer GetConstantBufferByIndex(int index) {
            unsafe {
                SlimDX2.Direct3D10.ShaderReflectionConstantBuffer __result__;
                __result__= (SlimDX2.Direct3D10.ShaderReflectionConstantBuffer)new SlimDX2.Direct3D10.ShaderReflectionConstantBuffer((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 4 * 4, index));
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="name">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>ID3D10ShaderReflectionConstantBuffer* GetConstantBufferByName([None] const char* Name)</unmanaged>
        public SlimDX2.Direct3D10.ShaderReflectionConstantBuffer GetConstantBufferByName(string name) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D10.ShaderReflectionConstantBuffer __result__;
                __result__= (SlimDX2.Direct3D10.ShaderReflectionConstantBuffer)new SlimDX2.Direct3D10.ShaderReflectionConstantBuffer((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 5 * 4, (void*)name_));
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="resourceIndex">No documentation.</param>
        /// <param name="descRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT GetResourceBindingDesc([None] UINT ResourceIndex,[None] D3D10_SHADER_INPUT_BIND_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetResourceBindingDescription(int resourceIndex, ref SlimDX2.Direct3D10.ShaderInputBindDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.ShaderInputBindDescription.__Native descRef_ = new SlimDX2.Direct3D10.ShaderInputBindDescription.__Native();
                descRef.__MarshalTo(ref descRef_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 6 * 4, resourceIndex, &descRef_);
                descRef_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="parameterIndex">No documentation.</param>
        /// <param name="descRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT GetInputParameterDesc([None] UINT ParameterIndex,[None] D3D10_SIGNATURE_PARAMETER_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetInputParameterDescription(int parameterIndex, ref SlimDX2.Direct3D10.SignatureParameterDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.SignatureParameterDescription.__Native descRef_ = new SlimDX2.Direct3D10.SignatureParameterDescription.__Native();
                descRef.__MarshalTo(ref descRef_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 7 * 4, parameterIndex, &descRef_);
                descRef_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="parameterIndex">No documentation.</param>
        /// <param name="descRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT GetOutputParameterDesc([None] UINT ParameterIndex,[None] D3D10_SIGNATURE_PARAMETER_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetOutputParameterDescription(int parameterIndex, ref SlimDX2.Direct3D10.SignatureParameterDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.SignatureParameterDescription.__Native descRef_ = new SlimDX2.Direct3D10.SignatureParameterDescription.__Native();
                descRef.__MarshalTo(ref descRef_);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 8 * 4, parameterIndex, &descRef_);
                descRef_.__MarshalFree();
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a variable by name.	
        /// </summary>	
        /// <remarks>	
        /// This method requires Windows Vista Service Pack 1.	
        /// </remarks>	
        /// <param name="name">A pointer to a string containing the variable name.</param>
        /// <returns>Returns a <see cref="SlimDX2.Direct3D10.ShaderReflectionVariable"/> interface.</returns>
        /// <unmanaged>ID3D10ShaderReflectionVariable* GetVariableByName([None] const char* Name)</unmanaged>
        public SlimDX2.Direct3D10.ShaderReflectionVariable GetVariableByName(string name) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D10.ShaderReflectionVariable __result__;
                __result__= (SlimDX2.Direct3D10.ShaderReflectionVariable)new SlimDX2.Direct3D10.ShaderReflectionVariable((IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 9 * 4, (void*)name_));
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a resource binding description by name.	
        /// </summary>	
        /// <remarks>	
        /// This method requires Windows Vista Service Pack 1.	
        /// </remarks>	
        /// <param name="name">A pointer to a string containing the variable name.</param>
        /// <param name="descRef">Pointer to a <see cref="SlimDX2.Direct3D10.ShaderInputBindDescription"/> structure that will be populated with resource binding information.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetResourceBindingDescByName([None] const char* Name,[Out] D3D10_SHADER_INPUT_BIND_DESC* pDesc)</unmanaged>
        public SlimDX2.Result GetResourceBindingDescByName(string name, out SlimDX2.Direct3D10.ShaderInputBindDescription descRef) {
            unsafe {
                IntPtr name_ = Marshal.StringToHGlobalAnsi(name);
                SlimDX2.Direct3D10.ShaderInputBindDescription.__Native descRef_ = new SlimDX2.Direct3D10.ShaderInputBindDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 10 * 4, (void*)name_, &descRef_);
                Marshal.FreeHGlobal(name_ );
                descRef = new SlimDX2.Direct3D10.ShaderInputBindDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of Mov instructions.	
        /// </summary>	
        /// <remarks>	
        /// This method requires Windows Vista Service Pack 1.	
        /// </remarks>	
        /// <param name="countRef">A pointer to the number of Mov instructions.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetMovInstructionCount([None] UINT* pCount)</unmanaged>
        public SlimDX2.Result GetMovInstructionCount(int countRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 11 * 4, &countRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of Movc instructions.	
        /// </summary>	
        /// <remarks>	
        /// This method requires Windows Vista Service Pack 1.	
        /// </remarks>	
        /// <param name="countRef">A pointer to the number of Movc instructions.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetMovcInstructionCount([None] UINT* pCount)</unmanaged>
        public SlimDX2.Result GetMovcInstructionCount(int countRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 12 * 4, &countRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of conversion instructions used in a shader.	
        /// </summary>	
        /// <remarks>	
        /// This method requires Windows Vista Service Pack 1.	
        /// </remarks>	
        /// <param name="countRef">A pointer to a UINT that will contain the conversion instruction count when the method returns.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetConversionInstructionCount([None] UINT* pCount)</unmanaged>
        public SlimDX2.Result GetConversionInstructionCount(int countRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 13 * 4, &countRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of bitwise instructions.	
        /// </summary>	
        /// <remarks>	
        /// This method requires Windows Vista Service Pack 1.	
        /// </remarks>	
        /// <param name="countRef">A pointer to the number of bitwise instructions.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetBitwiseInstructionCount([None] UINT* pCount)</unmanaged>
        public SlimDX2.Result GetBitwiseInstructionCount(int countRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 14 * 4, &countRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the geometry-shader input-primitive description.	
        /// </summary>	
        /// <remarks>	
        /// This method requires Windows Vista Service Pack 1.	
        /// </remarks>	
        /// <param name="primRef">A pointer to the input-primitive type (see <see cref="SlimDX2.D3DCompiler.InputPrimitive"/>).</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetGSInputPrimitive([None] D3D10_PRIMITIVE* pPrim)</unmanaged>
        public SlimDX2.Result GetGSInputPrimitive(SlimDX2.D3DCompiler.InputPrimitive primRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 15 * 4, &primRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Indicates whether a shader was compiled in Direct3D 10 on Direct3D 9 mode.	
        /// </summary>	
        /// <remarks>	
        /// This method requires Windows Vista Service Pack 1.	
        /// </remarks>	
        /// <param name="bLevel9ShaderRef">Pointer to a BOOL variable that will be set true if the shader was compiled in Direct3D 10 on Direct3D 9 mode; otherwise false.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT IsLevel9Shader([None] BOOL* pbLevel9Shader)</unmanaged>
        public SlimDX2.Result IsLevel9Shader(bool bLevel9ShaderRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 16 * 4, &bLevel9ShaderRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Indicates whether a pixel shader is intended to run a pixel frequency or sample frequency.	
        /// </summary>	
        /// <remarks>	
        /// This method requires Windows Vista Service Pack 1.	
        /// </remarks>	
        /// <param name="bSampleFrequencyRef">A pointer to a BOOL variable that will be set to true if the shader is intended to run at sample frequency; false otherwise.</param>
        /// <returns>Returns one of the following {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT IsSampleFrequencyShader([None] BOOL* pbSampleFrequency)</unmanaged>
        public SlimDX2.Result IsSampleFrequencyShader(bool bSampleFrequencyRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 17 * 4, &bSampleFrequencyRef);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// The ID3DX10Sprite interface provides a set of methods that simplify the process of drawing sprites using Microsoft Direct3D. This interface can operate on a set of many sprites.	
    /// </summary>	
    /// <unmanaged>ID3DX10Sprite</unmanaged>
    [Guid("ba0b762d-8d28-43ec-b9dc-2f84443b0614")]
    public partial class Sprite : SlimDX2.ComObject {
        public Sprite(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Set the view transform that applies to all sprites.	
        /// </summary>	
        /// <unmanaged>HRESULT SetViewTransform([None] D3DXMATRIX* pViewTransform)</unmanaged>
        public SlimMath.Matrix ViewTransform {
                set { SetViewTransform(ref value); }
        }
        
        /// <summary>	
        /// Set the projection matrix for all sprites.	
        /// </summary>	
        /// <unmanaged>HRESULT SetProjectionTransform([None] D3DXMATRIX* pProjectionTransform)</unmanaged>
        public SlimMath.Matrix ProjectionTransform {
                set { SetProjectionTransform(ref value); }
        }
        
        /// <summary>	
        /// Retrieve the device associated with the sprite object.	
        /// </summary>	
        /// <remarks>	
        /// Calling this method will increase the internal reference count on the ID3D10Device interface.	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>
        public SlimDX2.Direct3D10.Device Device {
                get { SlimDX2.Direct3D10.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Prepare a device for drawing sprites.	
        /// </summary>	
        /// <remarks>	
        /// Every call to Begin must be matched with a call to <see cref="SlimDX2.Direct3D10.Sprite.End"/>.	
        /// </remarks>	
        /// <param name="flags">Flags that control how the sprites will be drawn. See <see cref="SlimDX2.Direct3D10.SpriteTypeFlags"/>.</param>
        /// <returns>If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</returns>
        /// <unmanaged>HRESULT Begin([None] UINT flags)</unmanaged>
        public SlimDX2.Result Begin(SlimDX2.Direct3D10.SpriteTypeFlags flags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 3 * 4, unchecked((int)flags));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Add an array of sprites to the batch of sprites to be rendered. This must be called in between calls to <see cref="SlimDX2.Direct3D10.Sprite.Begin"/> and <see cref="SlimDX2.Direct3D10.Sprite.End"/>, and <see cref="SlimDX2.Direct3D10.Sprite.Flush"/> must be called before End to send all of the batched sprites to the device for rendering. This draw method is most useful when drawing a small number of sprites that you want buffered into a large batch, such as fonts.	
        /// </summary>	
        /// <param name="spritesRef">The array of sprites to draw. See <see cref="SlimDX2.Direct3D10.SpriteType"/>.</param>
        /// <param name="cSprites">The number of sprites in pSprites.</param>
        /// <returns>If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA.</returns>
        /// <unmanaged>HRESULT DrawSpritesBuffered([None] D3DX10_SPRITE* pSprites,[None] UINT cSprites)</unmanaged>
        public SlimDX2.Result DrawSpritesBuffered(ref SlimDX2.Direct3D10.SpriteType spritesRef, int cSprites) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* spritesRef_ = &spritesRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 4 * 4, spritesRef_, cSprites);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Force all batched sprites to be submitted to the device. Device states remain as they were after the last call to ID3DX10Sprite::Begin. The list of batched sprites is then cleared.	
        /// </summary>	
        /// <returns>If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL.</returns>
        /// <unmanaged>HRESULT Flush()</unmanaged>
        public SlimDX2.Result Flush() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 5 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Draw an array of sprites. This will immediately send the sprites to the device for rendering, which is different from <see cref="SlimDX2.Direct3D10.Sprite.DrawSpritesBuffered"/> which only adds an array of sprites to a batch of sprites to be rendered when <see cref="SlimDX2.Direct3D10.Sprite.Flush"/> is called. This draw method is most useful when drawing a large number of sprites that have already been sorted on the CPU (or do not need to be sorted), such as in a particle system. This must be called in between calls to <see cref="SlimDX2.Direct3D10.Sprite.Begin"/> and <see cref="SlimDX2.Direct3D10.Sprite.End"/>.	
        /// </summary>	
        /// <param name="spritesRef">The array of sprites to draw. See <see cref="SlimDX2.Direct3D10.SpriteType"/>.</param>
        /// <param name="cSprites">The number of sprites in pSprites.</param>
        /// <param name="cbSprite">The size of the sprite structure you are passing into pSprites. Passing in 0 is the equivalent of passing in sizeof(D3DX10_SPRITE).</param>
        /// <param name="flags">Reserved.</param>
        /// <returns>If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA.</returns>
        /// <unmanaged>HRESULT DrawSpritesImmediate([None] D3DX10_SPRITE* pSprites,[None] UINT cSprites,[None] UINT cbSprite,[None] UINT flags)</unmanaged>
        public SlimDX2.Result DrawSpritesImmediate(ref SlimDX2.Direct3D10.SpriteType spritesRef, int cSprites, int cbSprite, int flags) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* spritesRef_ = &spritesRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 6 * 4, spritesRef_, cSprites, cbSprite, flags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Call this after ID3DX10Sprite::Flush. If  D3DX10_SPRITE_SAVE_STATE was specified when ID3DX10Sprite::Begin was called, this API will restore the device state to how it was before ID3DX10Sprite::Begin was called.	
        /// </summary>	
        /// <returns>If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL.</returns>
        /// <unmanaged>HRESULT End()</unmanaged>
        public SlimDX2.Result End() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 7 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the view transform that applies to all sprites.	
        /// </summary>	
        /// <param name="viewTransformRef">Pointer to a {{D3DX10MATRIX}} that will be set to the transform of the sprite from the original world space.</param>
        /// <returns>If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL.</returns>
        /// <unmanaged>HRESULT GetViewTransform([None] D3DXMATRIX* pViewTransform)</unmanaged>
        public SlimDX2.Result GetViewTransform(ref SlimMath.Matrix viewTransformRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* viewTransformRef_ = &viewTransformRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 8 * 4, viewTransformRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set the view transform that applies to all sprites.	
        /// </summary>	
        /// <param name="viewTransformRef">Pointer to a D3DXMATRIX that contains a transform of the sprite from the original world space. Use this transform to scale, rotate, or transform the sprite.</param>
        /// <returns>If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL.</returns>
        /// <unmanaged>HRESULT SetViewTransform([None] D3DXMATRIX* pViewTransform)</unmanaged>
        internal SlimDX2.Result SetViewTransform(ref SlimMath.Matrix viewTransformRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* viewTransformRef_ = &viewTransformRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 9 * 4, viewTransformRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the sprite projection matrix that is applied to all sprites.	
        /// </summary>	
        /// <param name="projectionTransformRef">Pointer to a {{D3DX10MATRIX}} that will be set to the sprite's projection matrix.</param>
        /// <returns>The return value is one of the values listed in {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetProjectionTransform([None] D3DXMATRIX* pProjectionTransform)</unmanaged>
        public SlimDX2.Result GetProjectionTransform(ref SlimMath.Matrix projectionTransformRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* projectionTransformRef_ = &projectionTransformRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 10 * 4, projectionTransformRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set the projection matrix for all sprites.	
        /// </summary>	
        /// <param name="projectionTransformRef">The projection matrix to be used on all sprites.</param>
        /// <returns>The return value is one of the values listed in {{Direct3D 10 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetProjectionTransform([None] D3DXMATRIX* pProjectionTransform)</unmanaged>
        internal SlimDX2.Result SetProjectionTransform(ref SlimMath.Matrix projectionTransformRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* projectionTransformRef_ = &projectionTransformRef)
                    __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 11 * 4, projectionTransformRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieve the device associated with the sprite object.	
        /// </summary>	
        /// <remarks>	
        /// Calling this method will increase the internal reference count on the ID3D10Device interface.	
        /// </remarks>	
        /// <param name="deviceRef">Address of a pointer to an ID3D10Device interface, representing the Direct3D device object associated with the sprite object.</param>
        /// <returns>If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL.</returns>
        /// <unmanaged>HRESULT GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D10.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 12 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// The ID3DX10Font interface encapsulates the textures and resources needed to render a specific font on a specific device.	
    /// </summary>	
    /// <unmanaged>ID3DX10Font</unmanaged>
    [Guid("d79dbb70-5f21-4d36-bbc2-ff525c213cdc")]
    public partial class Font : SlimDX2.ComObject {
        public Font(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieve the Direct3D device associated with the font object.	
        /// </summary>	
        /// <remarks>	
        /// Note??Calling this method will increase the internal reference count on the ID3D10Device interface. Be sure to call IUnknown when you are done using this ID3D10Device interface or you will have a memory leak.	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>
        public SlimDX2.Direct3D10.Device Device {
                get { SlimDX2.Direct3D10.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a description of the current font object.	
        /// </summary>	
        /// <remarks>	
        /// This method describes Unicode font objects if UNICODE is defined. Otherwise GetDescA is called, which returns a pointer to the D3DX10FONT_DESCA structure.	
        /// </remarks>	
        /// <unmanaged>HRESULT GetDescW([Out] D3DX10_FONT_DESCW* pDesc)</unmanaged>
        public SlimDX2.Direct3D10.FontDescription Description {
                get { SlimDX2.Direct3D10.FontDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Return a handle to a display device context (DC) that has the font set onto it.	
        /// </summary>	
        /// <unmanaged>HDC GetDC()</unmanaged>
        public IntPtr DisplayDeviceContext {
                get { return GetDisplayDeviceContext(); }
        }
        
        /// <summary>	
        /// Retrieve the Direct3D device associated with the font object.	
        /// </summary>	
        /// <remarks>	
        /// Note??Calling this method will increase the internal reference count on the ID3D10Device interface. Be sure to call IUnknown when you are done using this ID3D10Device interface or you will have a memory leak.	
        /// </remarks>	
        /// <param name="deviceRef">Address of a pointer to an ID3D10Device interface, representing the Direct3D device object associated with the font object.</param>
        /// <returns>If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA.</returns>
        /// <unmanaged>HRESULT GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>
        internal SlimDX2.Result GetDevice(out SlimDX2.Direct3D10.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 3 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D10.Device(deviceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a description of the current font object.	
        /// </summary>	
        /// <remarks>	
        /// This method describes Unicode font objects if UNICODE is defined. Otherwise GetDescA is called, which returns a pointer to the D3DX10FONT_DESCA structure.	
        /// </remarks>	
        /// <param name="descRef">Pointer to a {{D3DX10_FONT_DESC}} structure that describes the font object. If UNICODE is defined, a pointer to a D3DX10FONT_DESCW is returned; otherwise a pointer to a D3DX10FONT_DESCA is returned.</param>
        /// <returns>If the method succeeds, the return value is S_OK. If the method fails, the following value will be returned: D3DERR_INVALIDCALL.</returns>
        /// <unmanaged>HRESULT GetDescW([Out] D3DX10_FONT_DESCW* pDesc)</unmanaged>
        internal SlimDX2.Result GetDescription(out SlimDX2.Direct3D10.FontDescription descRef) {
            unsafe {
                SlimDX2.Direct3D10.FontDescription.__Native descRef_ = new SlimDX2.Direct3D10.FontDescription.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 5 * 4, &descRef_);
                descRef = new SlimDX2.Direct3D10.FontDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieve font characteristics.	
        /// </summary>	
        /// <param name="textMetricsRef">Pointer to a {{TEXTMETRIC}} structure, which contains font properties. If Unicode is defined, the function returns a TEXTMETRICW structure. Otherwise, the function returns a TEXTMETRICA structure.</param>
        /// <returns>Nonzero if the function is successful; otherwise 0.</returns>
        /// <unmanaged>BOOL GetTextMetricsW([None] TEXTMETRICW* pTextMetrics)</unmanaged>
        internal bool GetTextMetrics(ref SlimDX2.Windows.Win32.Textmetricw textMetricsRef) {
            unsafe {
                bool __result__;
                fixed (void* textMetricsRef_ = &textMetricsRef)
                    __result__= (bool)(0!=SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 7 * 4, textMetricsRef_));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Return a handle to a display device context (DC) that has the font set onto it.	
        /// </summary>	
        /// <returns>Handle to a display DC.</returns>
        /// <unmanaged>HDC GetDC()</unmanaged>
        internal IntPtr GetDisplayDeviceContext() {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer, 8 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Return information about the placement and orientation of a glyph in a character cell.	
        /// </summary>	
        /// <param name="glyph">Glyph identifier.</param>
        /// <param name="textureRef">Address of a pointer to a ID3D10Texture object that contains the glyph.</param>
        /// <param name="blackBoxRef">Pointer to the smallest rectangle object that completely encloses the glyph. See <see cref="SlimDX2.RectangleF"/>.</param>
        /// <param name="cellIncRef">Pointer to the two-dimensional vector that connects the origin of the current character cell to the origin of the next character cell. See <see cref="System.Drawing.Point"/>.</param>
        /// <returns>If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA.</returns>
        /// <unmanaged>HRESULT GetGlyphData([None] UINT Glyph,[None] ID3D10ShaderResourceView** ppTexture,[None] RECT* pBlackBox,[None] POINT* pCellInc)</unmanaged>
        public SlimDX2.Result GetGlyphData(int glyph, SlimDX2.Direct3D10.ShaderResourceView textureRef, SlimDX2.RectangleF blackBoxRef, System.Drawing.Point cellIncRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 9 * 4, glyph, (void*)((textureRef == null)?IntPtr.Zero:textureRef.NativePointer), &blackBoxRef, &cellIncRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Load a series of characters into video memory to improve the efficiency of rendering to the device.	
        /// </summary>	
        /// <remarks>	
        /// This method generates textures containing glyphs that represent the input characters. The glyphs are drawn as a series of triangles.Characters will not be rendered to the device; ID3DX10Font::DrawText must still be called to render the characters. However, by pre-loading characters into video memory, ID3DX10Font::DrawText will use substantially fewer CPU resources.This method internally converts characters to glyphs using the GDI function {{GetCharacterPlacement}}.	
        /// </remarks>	
        /// <param name="first">ID of the first character to be loaded into video memory.</param>
        /// <param name="last">ID of the last character to be loaded into video memory.</param>
        /// <returns>If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA.</returns>
        /// <unmanaged>HRESULT PreloadCharacters([None] UINT First,[None] UINT Last)</unmanaged>
        public SlimDX2.Result PreloadCharacters(int first, int last) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 10 * 4, first, last);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Load a series of glyphs into video memory to improve the efficiency of rendering to the device.	
        /// </summary>	
        /// <remarks>	
        /// This method generates textures that contain the input glyphs. The glyphs are drawn as a series of triangles.Glyphs will not be rendered to the device; ID3DX10Font::DrawText must still be called to render the glyphs. However, by pre-loading glyphs into video memory, ID3DX10Font::DrawText will use substantially fewer CPU resources.	
        /// </remarks>	
        /// <param name="first">ID of the first glyph to be loaded into video memory.</param>
        /// <param name="last">ID of the last glyph to be loaded into video memory.</param>
        /// <returns>If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA.</returns>
        /// <unmanaged>HRESULT PreloadGlyphs([None] UINT First,[None] UINT Last)</unmanaged>
        public SlimDX2.Result PreloadGlyphs(int first, int last) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 11 * 4, first, last);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Load formatted text into video memory to improve the efficiency of rendering to the device. This method supports ANSI and Unicode strings.	
        /// </summary>	
        /// <remarks>	
        /// The compiler setting also determines the function version. If Unicode is defined, the function call resolves to PreloadTextW. Otherwise, the function call resolves to PreloadTextA because ANSI strings are being used.This method generates textures that contain glyphs that represent the input text. The glyphs are drawn as a series of triangles.Text will not be rendered to the device; ID3DX10Font::DrawText must still be called to render the text. However, by preloading text into video memory, ID3DX10Font::DrawText will use substantially fewer CPU resources.This method internally converts characters to glyphs using the GDI function {{GetCharacterPlacement}}.	
        /// </remarks>	
        /// <param name="stringRef">Pointer to a string of characters to be loaded into video memory. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR; otherwise, the data type resolves to LPCSTR. See Remarks.</param>
        /// <param name="count">Number of characters in the text string.</param>
        /// <returns>If the method succeeds, the return value is S_OK. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA.</returns>
        /// <unmanaged>HRESULT PreloadTextW([None] const wchar* pString,[None] INT Count)</unmanaged>
        public SlimDX2.Result PreloadText(string stringRef, int count) {
            unsafe {
                IntPtr stringRef_ = Marshal.StringToHGlobalUni(stringRef);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 13 * 4, (void*)stringRef_, count);
                Marshal.FreeHGlobal(stringRef_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Draw formatted text. This method supports ANSI and Unicode strings.	
        /// </summary>	
        /// <remarks>	
        /// The parameters of this method are very similar to those of the {{GDI DrawText}} function.This method supports both ANSI and Unicode strings.Unless the DT_NOCLIP format is used, this method clips the text so that it does not appear outside the specified rectangle. All formatting is assumed to have multiple lines unless the DT_SINGLELINE format is specified.If the selected font is too large for the rectangle, this method does not attempt to substitute a smaller font.This method supports only fonts whose escapement and orientation are both zero.	
        /// </remarks>	
        /// <param name="pSprite">Pointer to an ID3DX10Sprite object that contains the string you wish to draw. Can be NULL, in which case Direct3D will render the string with its own sprite object. To improve efficiency, a sprite object should be specified if ID3DX10Font::DrawText is to be called more than once in a row.</param>
        /// <param name="stringRef">Pointer to a string to draw. If UNICODE is defined, this parameter type resolves to an LPCWSTR, otherwise, the type resolves to an LPCSTR. If the Count parameter is -1, the string must be NULL terminated.</param>
        /// <param name="count">The number of characters in the string. If Count is -1, then the pString parameter is assumed to be a pointer to a sprite containing a NULL-terminated string and ID3DX10Font::DrawText computes the character count automatically.</param>
        /// <param name="rectRef">Pointer to a <see cref="SlimDX2.RectangleF"/> structure that contains the rectangle, in logical coordinates, in which the text is to be formatted. As with any RECT object, the coordinate value of the rectangle's right side must be greater than that of its left side. Likewise, the coordinate value of the bottom must be greater than that of the top.</param>
        /// <param name="format">Specify the method of formatting the text. It can be any combination of the following values: ItemDescriptionDT_BOTTOMJustify the text to the bottom of the rectangle. This value must be combined with DT_SINGLELINE.DT_CALCRECTTell DrawText to automatically calculate the width and height of the rectangle based on the length of the string you tell it to draw. If there are multiple lines of text, ID3DX10Font::DrawText uses the width of the rectangle pointed to by the pRect parameter and extends the base of the rectangle to bound the last line of text. If there is only one line of text, ID3DX10Font::DrawText modifies the right side of the rectangle so that it bounds the last character in the line. In either case, ID3DX10Font::DrawText returns the height of the formatted text but does not draw the text.DT_CENTERCenter text horizontally in the rectangle.DT_EXPANDTABSExpand tab characters. The default number of characters per tab is eight.DT_LEFTAlign text to the left.DT_NOCLIPDraw without clipping. ID3DX10Font::DrawText is somewhat faster when DT_NOCLIP is used.DT_RIGHTAlign text to the right.DT_RTLREADINGDisplay text in right-to-left reading order for bidirectional text when a Hebrew or Arabic font is selected. The default reading order for all text is left-to-right.DT_SINGLELINEDisplay text on a single line only. Carriage returns and line feeds do not break the line.DT_TOPTop-justify text.DT_VCENTERCenter text vertically (single line only).DT_WORDBREAKBreak words. Lines are automatically broken between words if a word would extend past the edge of the rectangle specified by the pRect parameter. A carriage return/line feed sequence also breaks the line.?</param>
        /// <param name="color">Color of the text. See <see cref="int"/>.</param>
        /// <returns>If the function succeeds, the return value is the height of the text in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from pRect (top to the bottom) of the drawn text. If the function fails, the return value is zero.</returns>
        /// <unmanaged>INT DrawTextW([None] LPD3DX10SPRITE pSprite,[None] const wchar* pString,[None] INT Count,[None] RECT* pRect,[None] UINT Format,[None] D3DXCOLOR Color)</unmanaged>
        public int DrawText(SlimDX2.Direct3D10.Sprite pSprite, string stringRef, int count, SlimDX2.RectangleF rectRef, int format, int color) {
            unsafe {
                IntPtr stringRef_ = Marshal.StringToHGlobalUni(stringRef);
                int __result__;
                __result__= (int)SlimDX2.Direct3D10.LocalInterop.Calliint(_nativePointer, 15 * 4, (void*)((pSprite == null)?IntPtr.Zero:pSprite.NativePointer), (void*)stringRef_, count, &rectRef, format, color);
                Marshal.FreeHGlobal(stringRef_ );
                return __result__;
            }
        }
    }
}
