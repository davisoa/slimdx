// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Structs for SlimDX2.D3DCompiler namespace.
//     This code was generated by a tool.
//     Date : 10/23/2010 10:28:26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace SlimDX2.D3DCompiler {

    
    /// <summary>	
    /// Describes a shader signature.	
    /// </summary>	
    /// <remarks>	
    /// A shader can take n inputs and can produce m outputs. The order of the input (or output) parameters, their associated types, and any attached semantics make up the shader signature. Each shader has an input and an output signature.When compiling a shader or an effect, some API calls validate shader signatures  That is, they compare the output signature of one shader (like a vertex shader) with the input signature of another shader (like a pixel shader). This ensures that a shader outputs data that is compatible with a downstream shader that is consuming that data. Compatible means that a shader signature is a exact-match subset of the preceding shader stage. Exact match means parameter types and semantics must exactly match. Subset means that a parameter that is not required by a downstream stage, does not need to include that parameter in its shader signature.Get a shader-signature from a shader or an effect by calling APIs such as <see cref="SlimDX2.D3DCompiler.ShaderReflection.GetInputParameterDescription"/>. 	
    /// </remarks>	
    /// <unmanaged>D3D11_SIGNATURE_PARAMETER_DESC</unmanaged>
    public  partial struct SignatureParameterDescription {	
        
        /// <summary>	
        /// A per-parameter string that identifies how the data will be used. 	
        /// </summary>	
        /// <unmanaged>const char* SemanticName</unmanaged>
        public string SemanticName;
        
        /// <summary>	
        /// Semantic index that modifies the semantic. Used to differentiate different parameters that use the same semantic.	
        /// </summary>	
        /// <unmanaged>UINT SemanticIndex</unmanaged>
        public int SemanticIndex;
        
        /// <summary>	
        /// The register that will contain this variable's data.	
        /// </summary>	
        /// <unmanaged>UINT Register</unmanaged>
        public int Register;
        
        /// <summary>	
        /// A predefined string that determines the functionality of certain pipeline stages. See {{D3D10_NAME}}.	
        /// </summary>	
        /// <unmanaged>D3D_NAME SystemValueType</unmanaged>
        public SlimDX2.D3DCompiler.ParameterName SystemValueType;
        
        /// <summary>	
        /// The per-component-data type that is stored in a register.  See {{D3D10_REGISTER_COMPONENT_TYPE}}. Each register can store up to four-components of data.	
        /// </summary>	
        /// <unmanaged>D3D_REGISTER_COMPONENT_TYPE ComponentType</unmanaged>
        public SlimDX2.D3DCompiler.RegisterComponentType ComponentType;
        
        /// <summary>	
        /// Mask which indicates which components of a register are used.	
        /// </summary>	
        /// <unmanaged>BYTE Mask</unmanaged>
        public byte Mask;
        
        /// <summary>	
        /// Mask which indicates whether a given component is never written (if the signature is an output signature) or always read (if the signature is an input signature). 	
        /// </summary>	
        /// <unmanaged>BYTE ReadWriteMask</unmanaged>
        public byte ReadWriteMask;
        
        /// <summary>	
        /// Indicates which stream the geometry shader is using for the signature parameter.	
        /// </summary>	
        /// <unmanaged>UINT Stream</unmanaged>
        public int Stream;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr SemanticName;
            public int SemanticIndex;
            public int Register;
            public SlimDX2.D3DCompiler.ParameterName SystemValueType;
            public SlimDX2.D3DCompiler.RegisterComponentType ComponentType;
            public byte Mask;
            public byte ReadWriteMask;
            public int Stream;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.SemanticName != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.SemanticName);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.SemanticName = ( @ref.SemanticName == IntPtr.Zero )?null:new string((sbyte*)@ref.SemanticName);
            this.SemanticIndex = @ref.SemanticIndex;
            this.Register = @ref.Register;
            this.SystemValueType = @ref.SystemValueType;
            this.ComponentType = @ref.ComponentType;
            this.Mask = @ref.Mask;
            this.ReadWriteMask = @ref.ReadWriteMask;
            this.Stream = @ref.Stream;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.SemanticName = ( this.SemanticName == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.SemanticName);
            @ref.SemanticIndex = this.SemanticIndex;
            @ref.Register = this.Register;
            @ref.SystemValueType = this.SystemValueType;
            @ref.ComponentType = this.ComponentType;
            @ref.Mask = this.Mask;
            @ref.ReadWriteMask = this.ReadWriteMask;
            @ref.Stream = this.Stream;
		
		}
    }
    
    /// <summary>	
    /// Describes a shader constant-buffer.	
    /// </summary>	
    /// <remarks>	
    /// Constants are supplied to shaders in a shader-constant buffer. Get the description of a shader-constant-buffer by calling <see cref="SlimDX2.D3DCompiler.ShaderReflectionConstantBuffer.GetDescription"/>.	
    /// </remarks>	
    /// <unmanaged>D3D11_SHADER_BUFFER_DESC</unmanaged>
    public  partial struct ConstantBufferDescription {	
        
        /// <summary>	
        /// The name of the buffer.	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        /// The intended use of the constant data.	
        /// </summary>	
        /// <unmanaged>D3D_CBUFFER_TYPE Type</unmanaged>
        public SlimDX2.D3DCompiler.ConstantBufferType Type;
        
        /// <summary>	
        /// The number of unique variables.	
        /// </summary>	
        /// <unmanaged>UINT Variables</unmanaged>
        public int Variables;
        
        /// <summary>	
        /// Buffer size (in bytes).	
        /// </summary>	
        /// <unmanaged>UINT Size</unmanaged>
        public int Size;
        
        /// <summary>	
        /// Shader buffer properties.	
        /// </summary>	
        /// <unmanaged>UINT uFlags</unmanaged>
        public int UFlags;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public SlimDX2.D3DCompiler.ConstantBufferType Type;
            public int Variables;
            public int Size;
            public int UFlags;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.Type = @ref.Type;
            this.Variables = @ref.Variables;
            this.Size = @ref.Size;
            this.UFlags = @ref.UFlags;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.Type = this.Type;
            @ref.Variables = this.Variables;
            @ref.Size = this.Size;
            @ref.UFlags = this.UFlags;
		
		}
    }
    
    /// <summary>	
    /// Describes a shader variable.	
    /// </summary>	
    /// <remarks>	
    /// Get a shader-variable description using reflection, by calling <see cref="SlimDX2.D3DCompiler.ShaderReflectionVariable.GetDescription"/>.As of the June 2010 update, DefaultValue emits default values for reflection. 	
    /// </remarks>	
    /// <unmanaged>D3D11_SHADER_VARIABLE_DESC</unmanaged>
    public  partial struct ShaderVariableDescription {	
        
        /// <summary>	
        /// The variable name.	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        /// Offset from the start of the parent structure, to the beginning of the variable.	
        /// </summary>	
        /// <unmanaged>UINT StartOffset</unmanaged>
        public int StartOffset;
        
        /// <summary>	
        /// Size of the variable (in bytes).	
        /// </summary>	
        /// <unmanaged>UINT Size</unmanaged>
        public int Size;
        
        /// <summary>	
        /// Flags, which identify shader-variable properties. 	
        /// </summary>	
        /// <unmanaged>UINT uFlags</unmanaged>
        public SlimDX2.D3DCompiler.ShaderVariableFlags Flags;
        
        /// <summary>	
        /// The default value for initializing the variable.	
        /// </summary>	
        /// <unmanaged>void* DefaultValue</unmanaged>
        public IntPtr DefaultValue;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT StartTexture</unmanaged>
        public int StartTexture;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT TextureSize</unmanaged>
        public int TextureSize;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT StartSampler</unmanaged>
        public int StartSampler;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT SamplerSize</unmanaged>
        public int SamplerSize;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public int StartOffset;
            public int Size;
            public SlimDX2.D3DCompiler.ShaderVariableFlags Flags;
            public IntPtr DefaultValue;
            public int StartTexture;
            public int TextureSize;
            public int StartSampler;
            public int SamplerSize;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.StartOffset = @ref.StartOffset;
            this.Size = @ref.Size;
            this.Flags = @ref.Flags;
            this.DefaultValue = @ref.DefaultValue;
            this.StartTexture = @ref.StartTexture;
            this.TextureSize = @ref.TextureSize;
            this.StartSampler = @ref.StartSampler;
            this.SamplerSize = @ref.SamplerSize;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.StartOffset = this.StartOffset;
            @ref.Size = this.Size;
            @ref.Flags = this.Flags;
            @ref.DefaultValue = this.DefaultValue;
            @ref.StartTexture = this.StartTexture;
            @ref.TextureSize = this.TextureSize;
            @ref.StartSampler = this.StartSampler;
            @ref.SamplerSize = this.SamplerSize;
		
		}
    }
    
    /// <summary>	
    /// Describes a shader-variable type.	
    /// </summary>	
    /// <remarks>	
    /// Get a shader-variable-type description by calling <see cref="SlimDX2.D3DCompiler.ShaderReflectionType.GetDescription"/>.	
    /// </remarks>	
    /// <unmanaged>D3D11_SHADER_TYPE_DESC</unmanaged>
    public  partial struct ShaderTypeDescription {	
        
        /// <summary>	
        /// Identifies the variable class as one of scalar, vector, matrix or object.  See {{D3D10_SHADER_VARIABLE_CLASS}}.	
        /// </summary>	
        /// <unmanaged>D3D_SHADER_VARIABLE_CLASS Class</unmanaged>
        public SlimDX2.D3DCompiler.ShaderVariableClass Class;
        
        /// <summary>	
        /// The variable type. See {{D3D10_SHADER_VARIABLE_TYPE}}.	
        /// </summary>	
        /// <unmanaged>D3D_SHADER_VARIABLE_TYPE Type</unmanaged>
        public SlimDX2.D3DCompiler.ShaderVariableType Type;
        
        /// <summary>	
        /// Number of rows in a matrix. Otherwise a numeric type returns 1, any other type returns 0.	
        /// </summary>	
        /// <unmanaged>UINT Rows</unmanaged>
        public int Rows;
        
        /// <summary>	
        /// Number of columns in a matrix. Otherwise a numeric type returns 1, any other type returns 0.	
        /// </summary>	
        /// <unmanaged>UINT Columns</unmanaged>
        public int Columns;
        
        /// <summary>	
        /// Number of elements in an array; otherwise 0.	
        /// </summary>	
        /// <unmanaged>UINT Elements</unmanaged>
        public int Elements;
        
        /// <summary>	
        /// Number of members in the structure; otherwise 0.	
        /// </summary>	
        /// <unmanaged>UINT Members</unmanaged>
        public int Members;
        
        /// <summary>	
        /// Offset, in bytes, between the start of the parent structure and this variable.	
        /// </summary>	
        /// <unmanaged>UINT Offset</unmanaged>
        public int Offset;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public SlimDX2.D3DCompiler.ShaderVariableClass Class;
            public SlimDX2.D3DCompiler.ShaderVariableType Type;
            public int Rows;
            public int Columns;
            public int Elements;
            public int Members;
            public int Offset;
            public IntPtr Name;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Class = @ref.Class;
            this.Type = @ref.Type;
            this.Rows = @ref.Rows;
            this.Columns = @ref.Columns;
            this.Elements = @ref.Elements;
            this.Members = @ref.Members;
            this.Offset = @ref.Offset;
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Class = this.Class;
            @ref.Type = this.Type;
            @ref.Rows = this.Rows;
            @ref.Columns = this.Columns;
            @ref.Elements = this.Elements;
            @ref.Members = this.Members;
            @ref.Offset = this.Offset;
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
		
		}
    }
    
    /// <summary>	
    /// Describes a shader.	
    /// </summary>	
    /// <remarks>	
    /// A shader is written in HLSL and compiled into an intermediate language by the HLSL compiler. The shader description returns information about the compiled shader. Get a shader description by calling <see cref="SlimDX2.D3DCompiler.ShaderReflection.GetDescription"/>.	
    /// </remarks>	
    /// <unmanaged>D3D11_SHADER_DESC</unmanaged>
    public  partial struct ShaderDescription {	
        
        /// <summary>	
        /// Shader version.	
        /// </summary>	
        /// <unmanaged>UINT Version</unmanaged>
        public SlimDX2.D3DCompiler.ShaderVersionType Version;
        
        /// <summary>	
        /// The name of the originator of the shader.	
        /// </summary>	
        /// <unmanaged>const char* Creator</unmanaged>
        public string Creator;
        
        /// <summary>	
        /// Shader compilation/parse flags.	
        /// </summary>	
        /// <unmanaged>UINT Flags</unmanaged>
        public SlimDX2.D3DCompiler.ShaderFlags Flags;
        
        /// <summary>	
        /// The number of shader-constant buffers.	
        /// </summary>	
        /// <unmanaged>UINT ConstantBuffers</unmanaged>
        public int ConstantBuffers;
        
        /// <summary>	
        /// The number of resource (textures and buffers) bound to a shader.	
        /// </summary>	
        /// <unmanaged>UINT BoundResources</unmanaged>
        public int BoundResources;
        
        /// <summary>	
        /// The number of parameters in the input signature.	
        /// </summary>	
        /// <unmanaged>UINT InputParameters</unmanaged>
        public int InputParameters;
        
        /// <summary>	
        /// The number of parameters in the output signature.	
        /// </summary>	
        /// <unmanaged>UINT OutputParameters</unmanaged>
        public int OutputParameters;
        
        /// <summary>	
        /// The number of intermediate-language instructions in the compiled shader.	
        /// </summary>	
        /// <unmanaged>UINT InstructionCount</unmanaged>
        public int InstructionCount;
        
        /// <summary>	
        /// The number of temporary registers in the compiled shader.	
        /// </summary>	
        /// <unmanaged>UINT TempRegisterCount</unmanaged>
        public int TempRegisterCount;
        
        /// <summary>	
        /// Number of temporary arrays used.	
        /// </summary>	
        /// <unmanaged>UINT TempArrayCount</unmanaged>
        public int TempArrayCount;
        
        /// <summary>	
        /// Number of constant defines.	
        /// </summary>	
        /// <unmanaged>UINT DefCount</unmanaged>
        public int DefCount;
        
        /// <summary>	
        /// Number of declarations (input + output).	
        /// </summary>	
        /// <unmanaged>UINT DclCount</unmanaged>
        public int DclCount;
        
        /// <summary>	
        /// Number of non-categorized texture instructions.	
        /// </summary>	
        /// <unmanaged>UINT TextureNormalInstructions</unmanaged>
        public int TextureNormalInstructions;
        
        /// <summary>	
        /// Number of texture load instructions	
        /// </summary>	
        /// <unmanaged>UINT TextureLoadInstructions</unmanaged>
        public int TextureLoadInstructions;
        
        /// <summary>	
        /// Number of texture comparison instructions	
        /// </summary>	
        /// <unmanaged>UINT TextureCompInstructions</unmanaged>
        public int TextureCompInstructions;
        
        /// <summary>	
        /// Number of texture bias instructions	
        /// </summary>	
        /// <unmanaged>UINT TextureBiasInstructions</unmanaged>
        public int TextureBiasInstructions;
        
        /// <summary>	
        /// Number of texture gradient instructions.	
        /// </summary>	
        /// <unmanaged>UINT TextureGradientInstructions</unmanaged>
        public int TextureGradientInstructions;
        
        /// <summary>	
        /// Number of floating point arithmetic instructions used.	
        /// </summary>	
        /// <unmanaged>UINT FloatInstructionCount</unmanaged>
        public int FloatInstructionCount;
        
        /// <summary>	
        /// Number of signed integer arithmetic instructions used.	
        /// </summary>	
        /// <unmanaged>UINT IntInstructionCount</unmanaged>
        public int IntInstructionCount;
        
        /// <summary>	
        /// Number of unsigned integer arithmetic instructions used.	
        /// </summary>	
        /// <unmanaged>UINT UintInstructionCount</unmanaged>
        public int UintInstructionCount;
        
        /// <summary>	
        /// Number of static flow control instructions used.	
        /// </summary>	
        /// <unmanaged>UINT StaticFlowControlCount</unmanaged>
        public int StaticFlowControlCount;
        
        /// <summary>	
        /// Number of dynamic flow control instructions used.	
        /// </summary>	
        /// <unmanaged>UINT DynamicFlowControlCount</unmanaged>
        public int DynamicFlowControlCount;
        
        /// <summary>	
        /// Number of macro instructions used.	
        /// </summary>	
        /// <unmanaged>UINT MacroInstructionCount</unmanaged>
        public int MacroInstructionCount;
        
        /// <summary>	
        /// Number of array instructions used.	
        /// </summary>	
        /// <unmanaged>UINT ArrayInstructionCount</unmanaged>
        public int ArrayInstructionCount;
        
        /// <summary>	
        /// Number of cut instructions used.	
        /// </summary>	
        /// <unmanaged>UINT CutInstructionCount</unmanaged>
        public int CutInstructionCount;
        
        /// <summary>	
        /// Number of emit instructions used.	
        /// </summary>	
        /// <unmanaged>UINT EmitInstructionCount</unmanaged>
        public int EmitInstructionCount;
        
        /// <summary>	
        /// The {{D3D10_PRIMITIVE_TOPOLOGY}}, which represents the shader output topology.	
        /// </summary>	
        /// <unmanaged>D3D_PRIMITIVE_TOPOLOGY GSOutputTopology</unmanaged>
        public SlimDX2.Direct3D.PrimitiveTopology GSOutputTopology;
        
        /// <summary>	
        /// Geometry shader maximum output vertex count.	
        /// </summary>	
        /// <unmanaged>UINT GSMaxOutputVertexCount</unmanaged>
        public int GSMaxOutputVertexCount;
        
        /// <summary>	
        /// The <see cref="SlimDX2.D3DCompiler.InputPrimitive"/>-typed value that represents the input primitive for a  geometry shader or hull shader.	
        /// </summary>	
        /// <unmanaged>D3D_PRIMITIVE InputPrimitive</unmanaged>
        public SlimDX2.D3DCompiler.InputPrimitive InputPrimitive;
        
        /// <summary>	
        /// Number of parameters in the patch-constant signature.	
        /// </summary>	
        /// <unmanaged>UINT PatchConstantParameters</unmanaged>
        public int PatchConstantParameters;
        
        /// <summary>	
        /// Number of geometry shader instances.	
        /// </summary>	
        /// <unmanaged>UINT cGSInstanceCount</unmanaged>
        public int CGSInstanceCount;
        
        /// <summary>	
        /// Number of control points in the hull shader and domain shader.	
        /// </summary>	
        /// <unmanaged>UINT cControlPoints</unmanaged>
        public int CControlPoints;
        
        /// <summary>	
        /// The <see cref="SlimDX2.D3DCompiler.Primitive"/>, which represents the tessellator output-primitive type.	
        /// </summary>	
        /// <unmanaged>D3D_TESSELLATOR_OUTPUT_PRIMITIVE HSOutputPrimitive</unmanaged>
        public SlimDX2.D3DCompiler.Primitive HSOutputPrimitive;
        
        /// <summary>	
        /// The <see cref="SlimDX2.D3DCompiler.TessellatorPartitioning"/>, which represents the tessellator partitioning mode.	
        /// </summary>	
        /// <unmanaged>D3D_TESSELLATOR_PARTITIONING HSPartitioning</unmanaged>
        public SlimDX2.D3DCompiler.TessellatorPartitioning HSPartitioning;
        
        /// <summary>	
        /// The <see cref="SlimDX2.D3DCompiler.TessellatorDomain"/>, which represents the tessellator domain.	
        /// </summary>	
        /// <unmanaged>D3D_TESSELLATOR_DOMAIN TessellatorDomain</unmanaged>
        public SlimDX2.D3DCompiler.TessellatorDomain TessellatorDomain;
        
        /// <summary>	
        /// Number of barrier instructions in a compute shader.	
        /// </summary>	
        /// <unmanaged>UINT cBarrierInstructions</unmanaged>
        public int CBarrierInstructions;
        
        /// <summary>	
        /// Number of interlocked instructions in a compute shader.	
        /// </summary>	
        /// <unmanaged>UINT cInterlockedInstructions</unmanaged>
        public int CInterlockedInstructions;
        
        /// <summary>	
        /// Number of texture writes in a compute shader.	
        /// </summary>	
        /// <unmanaged>UINT cTextureStoreInstructions</unmanaged>
        public int CTextureStoreInstructions;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public SlimDX2.D3DCompiler.ShaderVersionType Version;
            public IntPtr Creator;
            public SlimDX2.D3DCompiler.ShaderFlags Flags;
            public int ConstantBuffers;
            public int BoundResources;
            public int InputParameters;
            public int OutputParameters;
            public int InstructionCount;
            public int TempRegisterCount;
            public int TempArrayCount;
            public int DefCount;
            public int DclCount;
            public int TextureNormalInstructions;
            public int TextureLoadInstructions;
            public int TextureCompInstructions;
            public int TextureBiasInstructions;
            public int TextureGradientInstructions;
            public int FloatInstructionCount;
            public int IntInstructionCount;
            public int UintInstructionCount;
            public int StaticFlowControlCount;
            public int DynamicFlowControlCount;
            public int MacroInstructionCount;
            public int ArrayInstructionCount;
            public int CutInstructionCount;
            public int EmitInstructionCount;
            public SlimDX2.Direct3D.PrimitiveTopology GSOutputTopology;
            public int GSMaxOutputVertexCount;
            public SlimDX2.D3DCompiler.InputPrimitive InputPrimitive;
            public int PatchConstantParameters;
            public int CGSInstanceCount;
            public int CControlPoints;
            public SlimDX2.D3DCompiler.Primitive HSOutputPrimitive;
            public SlimDX2.D3DCompiler.TessellatorPartitioning HSPartitioning;
            public SlimDX2.D3DCompiler.TessellatorDomain TessellatorDomain;
            public int CBarrierInstructions;
            public int CInterlockedInstructions;
            public int CTextureStoreInstructions;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Creator != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Creator);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Version = @ref.Version;
            this.Creator = ( @ref.Creator == IntPtr.Zero )?null:new string((sbyte*)@ref.Creator);
            this.Flags = @ref.Flags;
            this.ConstantBuffers = @ref.ConstantBuffers;
            this.BoundResources = @ref.BoundResources;
            this.InputParameters = @ref.InputParameters;
            this.OutputParameters = @ref.OutputParameters;
            this.InstructionCount = @ref.InstructionCount;
            this.TempRegisterCount = @ref.TempRegisterCount;
            this.TempArrayCount = @ref.TempArrayCount;
            this.DefCount = @ref.DefCount;
            this.DclCount = @ref.DclCount;
            this.TextureNormalInstructions = @ref.TextureNormalInstructions;
            this.TextureLoadInstructions = @ref.TextureLoadInstructions;
            this.TextureCompInstructions = @ref.TextureCompInstructions;
            this.TextureBiasInstructions = @ref.TextureBiasInstructions;
            this.TextureGradientInstructions = @ref.TextureGradientInstructions;
            this.FloatInstructionCount = @ref.FloatInstructionCount;
            this.IntInstructionCount = @ref.IntInstructionCount;
            this.UintInstructionCount = @ref.UintInstructionCount;
            this.StaticFlowControlCount = @ref.StaticFlowControlCount;
            this.DynamicFlowControlCount = @ref.DynamicFlowControlCount;
            this.MacroInstructionCount = @ref.MacroInstructionCount;
            this.ArrayInstructionCount = @ref.ArrayInstructionCount;
            this.CutInstructionCount = @ref.CutInstructionCount;
            this.EmitInstructionCount = @ref.EmitInstructionCount;
            this.GSOutputTopology = @ref.GSOutputTopology;
            this.GSMaxOutputVertexCount = @ref.GSMaxOutputVertexCount;
            this.InputPrimitive = @ref.InputPrimitive;
            this.PatchConstantParameters = @ref.PatchConstantParameters;
            this.CGSInstanceCount = @ref.CGSInstanceCount;
            this.CControlPoints = @ref.CControlPoints;
            this.HSOutputPrimitive = @ref.HSOutputPrimitive;
            this.HSPartitioning = @ref.HSPartitioning;
            this.TessellatorDomain = @ref.TessellatorDomain;
            this.CBarrierInstructions = @ref.CBarrierInstructions;
            this.CInterlockedInstructions = @ref.CInterlockedInstructions;
            this.CTextureStoreInstructions = @ref.CTextureStoreInstructions;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Version = this.Version;
            @ref.Creator = ( this.Creator == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Creator);
            @ref.Flags = this.Flags;
            @ref.ConstantBuffers = this.ConstantBuffers;
            @ref.BoundResources = this.BoundResources;
            @ref.InputParameters = this.InputParameters;
            @ref.OutputParameters = this.OutputParameters;
            @ref.InstructionCount = this.InstructionCount;
            @ref.TempRegisterCount = this.TempRegisterCount;
            @ref.TempArrayCount = this.TempArrayCount;
            @ref.DefCount = this.DefCount;
            @ref.DclCount = this.DclCount;
            @ref.TextureNormalInstructions = this.TextureNormalInstructions;
            @ref.TextureLoadInstructions = this.TextureLoadInstructions;
            @ref.TextureCompInstructions = this.TextureCompInstructions;
            @ref.TextureBiasInstructions = this.TextureBiasInstructions;
            @ref.TextureGradientInstructions = this.TextureGradientInstructions;
            @ref.FloatInstructionCount = this.FloatInstructionCount;
            @ref.IntInstructionCount = this.IntInstructionCount;
            @ref.UintInstructionCount = this.UintInstructionCount;
            @ref.StaticFlowControlCount = this.StaticFlowControlCount;
            @ref.DynamicFlowControlCount = this.DynamicFlowControlCount;
            @ref.MacroInstructionCount = this.MacroInstructionCount;
            @ref.ArrayInstructionCount = this.ArrayInstructionCount;
            @ref.CutInstructionCount = this.CutInstructionCount;
            @ref.EmitInstructionCount = this.EmitInstructionCount;
            @ref.GSOutputTopology = this.GSOutputTopology;
            @ref.GSMaxOutputVertexCount = this.GSMaxOutputVertexCount;
            @ref.InputPrimitive = this.InputPrimitive;
            @ref.PatchConstantParameters = this.PatchConstantParameters;
            @ref.CGSInstanceCount = this.CGSInstanceCount;
            @ref.CControlPoints = this.CControlPoints;
            @ref.HSOutputPrimitive = this.HSOutputPrimitive;
            @ref.HSPartitioning = this.HSPartitioning;
            @ref.TessellatorDomain = this.TessellatorDomain;
            @ref.CBarrierInstructions = this.CBarrierInstructions;
            @ref.CInterlockedInstructions = this.CInterlockedInstructions;
            @ref.CTextureStoreInstructions = this.CTextureStoreInstructions;
		
		}
    }
    
    /// <summary>	
    /// Describes how a shader resource is bound to a shader input.	
    /// </summary>	
    /// <remarks>	
    /// Get a shader-input-signature description by calling <see cref="SlimDX2.D3DCompiler.ShaderReflection.GetResourceBindingDescription"/> or <see cref="SlimDX2.D3DCompiler.ShaderReflection.GetResourceBindingDescByName"/>.	
    /// </remarks>	
    /// <unmanaged>D3D11_SHADER_INPUT_BIND_DESC</unmanaged>
    public  partial struct ShaderInputBindDescription {	
        
        /// <summary>	
        /// Name of the shader resource.	
        /// </summary>	
        /// <unmanaged>const char* Name</unmanaged>
        public string Name;
        
        /// <summary>	
        /// Identifies the type of data in the resource. See {{D3D10_SHADER_INPUT_TYPE}}.	
        /// </summary>	
        /// <unmanaged>D3D_SHADER_INPUT_TYPE Type</unmanaged>
        public SlimDX2.D3DCompiler.ShaderInputType Type;
        
        /// <summary>	
        /// Starting bind point.	
        /// </summary>	
        /// <unmanaged>UINT BindPoint</unmanaged>
        public int BindPoint;
        
        /// <summary>	
        /// Number of contiguous bind points for arrays.	
        /// </summary>	
        /// <unmanaged>UINT BindCount</unmanaged>
        public int BindCount;
        
        /// <summary>	
        /// Shader input-parameter options.  See {{D3D10_SHADER_INPUT_FLAGS}}.	
        /// </summary>	
        /// <unmanaged>UINT uFlags</unmanaged>
        public SlimDX2.D3DCompiler.ShaderInputFlags Flags;
        
        /// <summary>	
        /// If the input is a texture, the return type. See <see cref="SlimDX2.D3DCompiler.ResourceReturnType"/>.	
        /// </summary>	
        /// <unmanaged>D3D_RESOURCE_RETURN_TYPE ReturnType</unmanaged>
        public SlimDX2.D3DCompiler.ResourceReturnType ReturnType;
        
        /// <summary>	
        /// Identifies the dimensions of the bound resource. For a list of values that <see cref="SlimDX2.D3DCompiler.ShaderReflection.GetResourceBindingDescription"/> or <see cref="SlimDX2.D3DCompiler.ShaderReflection.GetResourceBindingDescByName"/> can return, see <see cref="SlimDX2.Direct3D.ShaderResourceViewDimension"/>.	
        /// </summary>	
        /// <unmanaged>D3D_SRV_DIMENSION Dimension</unmanaged>
        public SlimDX2.Direct3D.ShaderResourceViewDimension Dimension;
        
        /// <summary>	
        /// The number of samples for a multisampled texture; otherwise 0.	
        /// </summary>	
        /// <unmanaged>UINT NumSamples</unmanaged>
        public int NumSamples;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr Name;
            public SlimDX2.D3DCompiler.ShaderInputType Type;
            public int BindPoint;
            public int BindCount;
            public SlimDX2.D3DCompiler.ShaderInputFlags Flags;
            public SlimDX2.D3DCompiler.ResourceReturnType ReturnType;
            public SlimDX2.Direct3D.ShaderResourceViewDimension Dimension;
            public int NumSamples;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:new string((sbyte*)@ref.Name);
            this.Type = @ref.Type;
            this.BindPoint = @ref.BindPoint;
            this.BindCount = @ref.BindCount;
            this.Flags = @ref.Flags;
            this.ReturnType = @ref.ReturnType;
            this.Dimension = @ref.Dimension;
            this.NumSamples = @ref.NumSamples;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.Name);
            @ref.Type = this.Type;
            @ref.BindPoint = this.BindPoint;
            @ref.BindCount = this.BindCount;
            @ref.Flags = this.Flags;
            @ref.ReturnType = this.ReturnType;
            @ref.Dimension = this.Dimension;
            @ref.NumSamples = this.NumSamples;
		
		}
    }
    
    /// <summary>	
    /// Describes shader data.	
    /// </summary>	
    /// <remarks>	
    /// An array of D3D_SHADER_DATA structures is passed to <see cref="SlimDX2.D3DCompiler.D3D.CompressShaders"/> to compress the shader data into a more compact form.	
    /// </remarks>	
    /// <unmanaged>D3D_SHADER_DATA</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ShaderData {	
        
        /// <summary>	
        /// A pointer to shader data.	
        /// </summary>	
        /// <unmanaged>LPCVOID pBytecode</unmanaged>
        public IntPtr BytecodePtr;
        
        /// <summary>	
        /// Length of shader data that pBytecode points to.	
        /// </summary>	
        /// <unmanaged>SIZE_T BytecodeLength</unmanaged>
        public SlimDX2.Size BytecodeLength;
    }
}
