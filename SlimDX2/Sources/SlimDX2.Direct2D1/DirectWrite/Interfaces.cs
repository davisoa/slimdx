// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Interfaces for SlimDX2.DirectWrite namespace.
//     This code was generated by a tool.
//     Date : 11/08/2010 15:18:19
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace SlimDX2.DirectWrite {

    
    /// <summary>	
    ///  Handles loading font file resources of a particular type from a font file reference key into a font file stream object. 	
    /// </summary>	
    /// <unmanaged>IDWriteFontFileLoader</unmanaged>
    [Guid("727cad4e-d6af-4c9e-8a08-d695b11caa49")]
    public partial class FontFileLoader : SlimDX2.ComObject {
        public FontFileLoader(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Creates a font file stream object that encapsulates an open file resource. 	
        /// </summary>	
        /// <remarks>	
        /// The resource is closed when the last reference to fontFileStream is released. 	
        /// </remarks>	
        /// <param name="fontFileReferenceKey">A pointer to a font file reference key that uniquely identifies the font file resource within the scope of the font loader being used. The buffer allocated for this key must at least be the size, in bytes, specified by  fontFileReferenceKeySize.</param>
        /// <param name="fontFileReferenceKeySize">The size of font file reference key, in bytes.</param>
        /// <param name="fontFileStream">When this method returns, contains the address of a pointer to the newly created <see cref="SlimDX2.DirectWrite.FontFileStream"/> object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateStreamFromKey([In, Buffer] const void* fontFileReferenceKey,[None] UINT32 fontFileReferenceKeySize,[Out] IDWriteFontFileStream** fontFileStream)</unmanaged>
        public SlimDX2.Result CreateStreamFromKey(IntPtr fontFileReferenceKey, int fontFileReferenceKeySize, out SlimDX2.DirectWrite.FontFileStream fontFileStream) {
            unsafe {
                IntPtr fontFileStream_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4, (void*)fontFileReferenceKey, fontFileReferenceKeySize, &fontFileStream_);
                fontFileStream = (fontFileStream_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontFileStream(fontFileStream_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A built-in implementation of the <see cref="SlimDX2.DirectWrite.FontFileLoader"/> interface, that operates on local font files	
    /// and exposes local font file information from the font file reference key. Font file references created using {{CreateFontFileReference}} use this font file loader.	
    /// </summary>	
    /// <unmanaged>IDWriteLocalFontFileLoader</unmanaged>
    [Guid("b2d9f3ec-c9fe-4a11-a2ec-d86208f7c0a2")]
    public partial class LocalFontFileLoader : SlimDX2.DirectWrite.FontFileLoader {
        public LocalFontFileLoader(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Obtains the length of the absolute file path from the font file reference key.	
        /// </summary>	
        /// <param name="fontFileReferenceKey">Font file reference key that uniquely identifies the local font file within the scope of the font loader being used.</param>
        /// <param name="fontFileReferenceKeySize">Size of font file reference key in bytes.</param>
        /// <param name="filePathLength">Length of the file path string, not including the terminated NULL character.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFilePathLengthFromKey([In, Buffer] const void* fontFileReferenceKey,[None] UINT32 fontFileReferenceKeySize,[Out] UINT32* filePathLength)</unmanaged>
        public SlimDX2.Result GetFilePathLengthFromKey(IntPtr fontFileReferenceKey, int fontFileReferenceKeySize, out int filePathLength) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* filePathLength_ = &filePathLength)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)fontFileReferenceKey, fontFileReferenceKeySize, filePathLength_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Obtains the absolute font file path from the font file reference key.	
        /// </summary>	
        /// <param name="fontFileReferenceKey">The font file reference key that uniquely identifies the local font file within the scope of the font loader being used.</param>
        /// <param name="fontFileReferenceKeySize">The size of font file reference key in bytes.</param>
        /// <param name="filePath">The character array that receives the local file path.</param>
        /// <param name="filePathSize">The length of the file path character array.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFilePathFromKey([In, Buffer] const void* fontFileReferenceKey,[None] UINT32 fontFileReferenceKeySize,[Out, Buffer] wchar* filePath,[None] UINT32 filePathSize)</unmanaged>
        public SlimDX2.Result GetFilePathFromKey(IntPtr fontFileReferenceKey, int fontFileReferenceKeySize, IntPtr filePath, int filePathSize) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)fontFileReferenceKey, fontFileReferenceKeySize, (void*)filePath, filePathSize);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Obtains the last write time of the file from the font file reference key.	
        /// </summary>	
        /// <param name="fontFileReferenceKey">The font file reference key that uniquely identifies the local font file within the scope of the font loader being used.</param>
        /// <param name="fontFileReferenceKeySize">The size of font file reference key in bytes.</param>
        /// <param name="lastWriteTime">The time of the last font file modification.</param>
        /// <returns>TBD</returns>
        /// <unmanaged>HRESULT GetLastWriteTimeFromKey([In, Buffer] const void* fontFileReferenceKey,[None] UINT32 fontFileReferenceKeySize,[Out] FILETIME* lastWriteTime)</unmanaged>
        public SlimDX2.Result GetLastWriteTimeFromKey(IntPtr fontFileReferenceKey, int fontFileReferenceKeySize, out long lastWriteTime) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* lastWriteTime_ = &lastWriteTime)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)fontFileReferenceKey, fontFileReferenceKeySize, lastWriteTime_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    ///  Loads font file data from a custom font file loader. 	
    /// </summary>	
    /// <unmanaged>IDWriteFontFileStream</unmanaged>
    [Guid("6d4865fe-0ab8-4d91-8f62-5dd6be34a3e0")]
    public partial class FontFileStream : SlimDX2.ComObject {
        public FontFileStream(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Obtains the total size of a file. 	
        /// </summary>	
        /// <remarks>	
        ///  Implementing GetFileSize() for asynchronously loaded font files may require downloading the complete file contents. Therefore, this method should be used only for operations that either require a complete font file to be loaded (for example, copying a font file) or that need to make decisions based on the value of the file size (for example, validation against a persisted file size). 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetFileSize([Out] UINT64* fileSize)</unmanaged>
        public long FileSize {
                get { long __output__; GetFileSize(out __output__); return __output__; }
        }
        
        /// <summary>	
        ///  Obtains the last modified time of the file.  	
        /// </summary>	
        /// <remarks>	
        /// The "last modified time" is used by DirectWrite font selection algorithms to determine whether one font resource is more up to date than another one.	
        /// </remarks>	
        /// <unmanaged>HRESULT GetLastWriteTime([Out] UINT64* lastWriteTime)</unmanaged>
        public long LastWriteTime {
                get { long __output__; GetLastWriteTime(out __output__); return __output__; }
        }
        
        /// <summary>	
        ///  Reads a fragment from a font file. 	
        /// </summary>	
        /// <remarks>	
        ///  Note that ReadFileFragment implementations must check whether the requested font file fragment is within the file bounds. Otherwise, an error should be returned from ReadFileFragment. {{DirectWrite}} may invoke <see cref="SlimDX2.DirectWrite.FontFileStream"/> methods on the same object from multiple threads simultaneously. Therefore, ReadFileFragment implementations that rely on internal mutable state must serialize access to such state across multiple threads. For example, an implementation that uses separate Seek and Read operations to read a file fragment must place the code block containing Seek and Read calls under a lock or a critical section.	
        /// </remarks>	
        /// <param name="fragmentStart">When this method returns, contains an address of a  pointer to the start of the font file fragment.  This parameter is passed uninitialized.</param>
        /// <param name="fileOffset">The offset of the fragment, in bytes, from the beginning of the font file.</param>
        /// <param name="fragmentSize">The size of the file fragment, in bytes.</param>
        /// <param name="fragmentContext">When this method returns, contains the address of a pointer to a pointer to the client-defined context to be passed to {{ReleaseFileFragment}}.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ReadFileFragment([Out, Buffer] const void** fragmentStart,[None] UINT64 fileOffset,[None] UINT64 fragmentSize,[Out] void** fragmentContext)</unmanaged>
        public SlimDX2.Result ReadFileFragment(IntPtr fragmentStart, long fileOffset, long fragmentSize, out IntPtr fragmentContext) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* fragmentContext_ = &fragmentContext)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4, (void*)fragmentStart, fileOffset, fragmentSize, fragmentContext_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Releases a fragment from a file. 	
        /// </summary>	
        /// <param name="fragmentContext">A pointer to the client-defined context of a font fragment returned from {{ReadFileFragment}}.</param>
        /// <unmanaged>void ReleaseFileFragment([None] void* fragmentContext)</unmanaged>
        public void ReleaseFileFragment(IntPtr fragmentContext) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 4 * 4, (void*)fragmentContext);
            }
        }
        
        /// <summary>	
        ///  Obtains the total size of a file. 	
        /// </summary>	
        /// <remarks>	
        ///  Implementing GetFileSize() for asynchronously loaded font files may require downloading the complete file contents. Therefore, this method should be used only for operations that either require a complete font file to be loaded (for example, copying a font file) or that need to make decisions based on the value of the file size (for example, validation against a persisted file size). 	
        /// </remarks>	
        /// <param name="fileSize">When this method returns, contains the total size of the file.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFileSize([Out] UINT64* fileSize)</unmanaged>
        internal SlimDX2.Result GetFileSize(out long fileSize) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* fileSize_ = &fileSize)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4, fileSize_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Obtains the last modified time of the file.  	
        /// </summary>	
        /// <remarks>	
        /// The "last modified time" is used by DirectWrite font selection algorithms to determine whether one font resource is more up to date than another one.	
        /// </remarks>	
        /// <param name="lastWriteTime">When this method returns, contains  the last modified time of the file in the format that represents the number of 100-nanosecond intervals since January 1, 1601 (UTC).</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetLastWriteTime([Out] UINT64* lastWriteTime)</unmanaged>
        internal SlimDX2.Result GetLastWriteTime(out long lastWriteTime) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* lastWriteTime_ = &lastWriteTime)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4, lastWriteTime_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    ///  Represents a font file. Applications  such as font managers or font viewers can call <see cref="SlimDX2.DirectWrite.FontFile.Analyze"/> to find out if a particular file is a font file, and whether it is a font type that is supported by the font system.	
    /// </summary>	
    /// <unmanaged>IDWriteFontFile</unmanaged>
    [Guid("739d886a-cef5-47dc-8769-1a8b41bebbb0")]
    public partial class FontFile : SlimDX2.ComObject {
        public FontFile(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Obtains the file loader associated with a font file object. 	
        /// </summary>	
        /// <unmanaged>HRESULT GetLoader([Out] IDWriteFontFileLoader** fontFileLoader)</unmanaged>
        public SlimDX2.DirectWrite.FontFileLoader Loader {
                get { SlimDX2.DirectWrite.FontFileLoader __output__; GetLoader(out __output__); return __output__; }
        }
        
        /// <summary>	
        ///  Obtains the pointer to the reference key of a font file. The returned pointer is valid until the font file object is released.  	
        /// </summary>	
        /// <param name="fontFileReferenceKey">When this method returns, contains an address of  a pointer to the font file reference key. Note that the pointer value is only valid until the font file object it is obtained from is released. This parameter is passed uninitialized.</param>
        /// <param name="fontFileReferenceKeySize">When this method returns, contains the size of the font file reference key in bytes. This parameter is passed uninitialized.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetReferenceKey([Out, Buffer] const void** fontFileReferenceKey,[Out] UINT32* fontFileReferenceKeySize)</unmanaged>
        public SlimDX2.Result GetReferenceKey(IntPtr fontFileReferenceKey, out int fontFileReferenceKeySize) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* fontFileReferenceKeySize_ = &fontFileReferenceKeySize)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4, (void*)fontFileReferenceKey, fontFileReferenceKeySize_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Obtains the file loader associated with a font file object. 	
        /// </summary>	
        /// <param name="fontFileLoader">When this method returns, contains the address of  a pointer to the font file loader associated with the font file object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetLoader([Out] IDWriteFontFileLoader** fontFileLoader)</unmanaged>
        internal SlimDX2.Result GetLoader(out SlimDX2.DirectWrite.FontFileLoader fontFileLoader) {
            unsafe {
                IntPtr fontFileLoader_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, &fontFileLoader_);
                fontFileLoader = (fontFileLoader_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontFileLoader(fontFileLoader_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Analyzes a file and returns whether it represents a font, and whether the font type is supported by the font system. 	
        /// </summary>	
        /// <remarks>	
        ///  IMPORTANT: Certain font file types are recognized, but not supported by the font system. For example, the font system will recognize a file as a Type 1 font file but will not be able to construct a font face object from it. In such situations, Analyze will set isSupportedFontType output parameter to FALSE. 	
        /// </remarks>	
        /// <param name="isSupportedFontType">TRUE if the font type is supported by the font system; otherwise, FALSE.</param>
        /// <param name="fontFileType">When this method returns, contains a value that indicates the type of the font file. Note that even if  isSupportedFontType is FALSE, the fontFileType value may be different from DWRITE_FONT_FILE_TYPE_UNKNOWN.</param>
        /// <param name="fontFaceType">When this method returns, contains a value that indicates the type of the font face. If fontFileType is not equal to DWRITE_FONT_FILE_TYPE_UNKNOWN, then that can be constructed from the font file. </param>
        /// <param name="numberOfFaces">When this method returns, contains the number of font faces contained in the font file.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT Analyze([Out] BOOL* isSupportedFontType,[Out] DWRITE_FONT_FILE_TYPE* fontFileType,[Out, Optional] DWRITE_FONT_FACE_TYPE* fontFaceType,[Out] UINT32* numberOfFaces)</unmanaged>
        public SlimDX2.Result Analyze(out bool isSupportedFontType, out SlimDX2.DirectWrite.FontFileType fontFileType, out SlimDX2.DirectWrite.FontFaceType fontFaceType, out int numberOfFaces) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* isSupportedFontType_ = &isSupportedFontType)
                    fixed (void* fontFileType_ = &fontFileType)
                        fixed (void* fontFaceType_ = &fontFaceType)
                            fixed (void* numberOfFaces_ = &numberOfFaces)
                                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4, isSupportedFontType_, fontFileType_, fontFaceType_, numberOfFaces_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    ///  Represents text rendering settings such as ClearType level, enhanced contrast, and gamma correction for glyph rasterization and filtering.	
    /// </summary>	
    /// <unmanaged>IDWriteRenderingParams</unmanaged>
    [Guid("2f0da53a-2add-47cd-82ee-d9ec34688e75")]
    public partial class RenderingParams : SlimDX2.ComObject {
        public RenderingParams(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the gamma value used for gamma correction. Valid values must be greater than zero and cannot exceed 256.	
        /// </summary>	
        /// <remarks>	
        /// The gamma value is used for gamma correction, which compensates for the non-linear luminosity response of most monitors.	
        /// </remarks>	
        /// <unmanaged>FLOAT GetGamma()</unmanaged>
        public float Gamma {
                get { return GetGamma(); }
        }
        
        /// <summary>	
        /// Gets the enhanced contrast property of the rendering parameters object. Valid values are greater than or equal to zero.	
        /// </summary>	
        /// <remarks>	
        /// Enhanced contrast is the amount to increase the darkness of text, and typically ranges from 0 to 1. Zero means no contrast enhancement.	
        /// </remarks>	
        /// <unmanaged>FLOAT GetEnhancedContrast()</unmanaged>
        public float EnhancedContrast {
                get { return GetEnhancedContrast(); }
        }
        
        /// <summary>	
        /// Gets the ClearType level of the rendering parameters object. 	
        /// </summary>	
        /// <remarks>	
        /// The ClearType level represents the amount of ClearType ? that is, the degree to which the red, green, and blue subpixels of each pixel are treated differently. Valid values range from zero (meaning no ClearType, which is equivalent to grayscale anti-aliasing) to one (meaning full ClearType)	
        /// </remarks>	
        /// <unmanaged>FLOAT GetClearTypeLevel()</unmanaged>
        public float ClearTypeLevel {
                get { return GetClearTypeLevel(); }
        }
        
        /// <summary>	
        /// Gets the pixel geometry of the rendering parameters object.	
        /// </summary>	
        /// <unmanaged>DWRITE_PIXEL_GEOMETRY GetPixelGeometry()</unmanaged>
        public SlimDX2.DirectWrite.PixelGeometry PixelGeometry {
                get { return GetPixelGeometry(); }
        }
        
        /// <summary>	
        /// Gets the rendering mode of the rendering parameters object.	
        /// </summary>	
        /// <remarks>	
        /// By default, the rendering mode is initialized to DWRITE_RENDERING_MODE_DEFAULT, which means the rendering mode is determined automatically based on the font and size. To determine the recommended rendering mode to use for a given font and size and rendering parameters object, use the <see cref="SlimDX2.DirectWrite.FontFace.GetRecommendedRenderingMode"/> method.	
        /// </remarks>	
        /// <unmanaged>DWRITE_RENDERING_MODE GetRenderingMode()</unmanaged>
        public SlimDX2.DirectWrite.RenderingMode RenderingMode {
                get { return GetRenderingMode(); }
        }
        
        /// <summary>	
        /// Gets the gamma value used for gamma correction. Valid values must be greater than zero and cannot exceed 256.	
        /// </summary>	
        /// <remarks>	
        /// The gamma value is used for gamma correction, which compensates for the non-linear luminosity response of most monitors.	
        /// </remarks>	
        /// <returns>Returns the gamma value used for gamma correction. Valid values must be greater than zero and cannot exceed 256.</returns>
        /// <unmanaged>FLOAT GetGamma()</unmanaged>
        internal float GetGamma() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct2D1.LocalInterop.Callifloat(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the enhanced contrast property of the rendering parameters object. Valid values are greater than or equal to zero.	
        /// </summary>	
        /// <remarks>	
        /// Enhanced contrast is the amount to increase the darkness of text, and typically ranges from 0 to 1. Zero means no contrast enhancement.	
        /// </remarks>	
        /// <returns>Returns the amount of contrast enhancement. Valid values are greater than or equal to zero.</returns>
        /// <unmanaged>FLOAT GetEnhancedContrast()</unmanaged>
        internal float GetEnhancedContrast() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct2D1.LocalInterop.Callifloat(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the ClearType level of the rendering parameters object. 	
        /// </summary>	
        /// <remarks>	
        /// The ClearType level represents the amount of ClearType ? that is, the degree to which the red, green, and blue subpixels of each pixel are treated differently. Valid values range from zero (meaning no ClearType, which is equivalent to grayscale anti-aliasing) to one (meaning full ClearType)	
        /// </remarks>	
        /// <returns>The ClearType level of the rendering parameters object.</returns>
        /// <unmanaged>FLOAT GetClearTypeLevel()</unmanaged>
        internal float GetClearTypeLevel() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct2D1.LocalInterop.Callifloat(_nativePointer, 5 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the pixel geometry of the rendering parameters object.	
        /// </summary>	
        /// <returns> A value that indicates the type of  pixel geometry used in the rendering parameters object.</returns>
        /// <unmanaged>DWRITE_PIXEL_GEOMETRY GetPixelGeometry()</unmanaged>
        internal SlimDX2.DirectWrite.PixelGeometry GetPixelGeometry() {
            unsafe {
                SlimDX2.DirectWrite.PixelGeometry __result__;
                __result__= (SlimDX2.DirectWrite.PixelGeometry)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the rendering mode of the rendering parameters object.	
        /// </summary>	
        /// <remarks>	
        /// By default, the rendering mode is initialized to DWRITE_RENDERING_MODE_DEFAULT, which means the rendering mode is determined automatically based on the font and size. To determine the recommended rendering mode to use for a given font and size and rendering parameters object, use the <see cref="SlimDX2.DirectWrite.FontFace.GetRecommendedRenderingMode"/> method.	
        /// </remarks>	
        /// <returns>A value that indicates the rendering mode of the rendering parameters object.</returns>
        /// <unmanaged>DWRITE_RENDERING_MODE GetRenderingMode()</unmanaged>
        internal SlimDX2.DirectWrite.RenderingMode GetRenderingMode() {
            unsafe {
                SlimDX2.DirectWrite.RenderingMode __result__;
                __result__= (SlimDX2.DirectWrite.RenderingMode)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 7 * 4);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Represents an absolute reference to a font face which contains font face type, appropriate file references,  face identification data and various font data such as metrics, names and glyph outlines. 	
    /// </summary>	
    /// <unmanaged>IDWriteFontFace</unmanaged>
    [Guid("5f49804d-7024-4d43-bfa9-d25984f53849")]
    public partial class FontFace : SlimDX2.ComObject {
        public FontFace(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Obtains the file format type of a font face. 	
        /// </summary>	
        /// <unmanaged>DWRITE_FONT_FACE_TYPE GetType()</unmanaged>
        public SlimDX2.DirectWrite.FontFaceType TypeInfo {
                get { return GetTypeInfo(); }
        }
        
        /// <summary>	
        ///  Obtains the index of a font face in the context of its font files. 	
        /// </summary>	
        /// <unmanaged>UINT32 GetIndex()</unmanaged>
        public int Index {
                get { return GetIndex(); }
        }
        
        /// <summary>	
        ///  Obtains the algorithmic style simulation flags of a font face. 	
        /// </summary>	
        /// <unmanaged>DWRITE_FONT_SIMULATIONS GetSimulations()</unmanaged>
        public SlimDX2.DirectWrite.FontSimulations Simulations {
                get { return GetSimulations(); }
        }
        
        /// <summary>	
        ///  Determines whether the font is a symbol font. 	
        /// </summary>	
        /// <unmanaged>BOOL IsSymbolFont()</unmanaged>
        public bool IsSymbolFont {
                get { return IsSymbolFont_(); }
        }
        
        /// <summary>	
        ///  Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. 	
        /// </summary>	
        /// <unmanaged>void GetMetrics([Out] DWRITE_FONT_METRICS* fontFaceMetrics)</unmanaged>
        public SlimDX2.DirectWrite.FontMetrics Metrics {
                get { SlimDX2.DirectWrite.FontMetrics __output__; GetMetrics(out __output__); return __output__; }
        }
        
        /// <summary>	
        ///  Obtains the number of glyphs in the font face. 	
        /// </summary>	
        /// <unmanaged>UINT16 GetGlyphCount()</unmanaged>
        public short GlyphCount {
                get { return GetGlyphCount(); }
        }
        
        /// <summary>	
        ///  Obtains the file format type of a font face. 	
        /// </summary>	
        /// <returns>A value that indicates the type of format for the font face (such as Type 1, TrueType, vector, or bitmap).</returns>
        /// <unmanaged>DWRITE_FONT_FACE_TYPE GetType()</unmanaged>
        internal SlimDX2.DirectWrite.FontFaceType GetTypeInfo() {
            unsafe {
                SlimDX2.DirectWrite.FontFaceType __result__;
                __result__= (SlimDX2.DirectWrite.FontFaceType)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Obtains the font files representing a font face. 	
        /// </summary>	
        /// <remarks>	
        /// The IDWriteFontFace::GetFiles method should be called twice.  The first time you call GetFilesfontFiles should be NULL. When the method returns, numberOfFiles receives the number of font files that represent the font face.Then, call the method a second time, passing the numberOfFiles value that was output the first call, and a non-null buffer of the correct size to store the <see cref="SlimDX2.DirectWrite.FontFile"/> pointers.	
        /// </remarks>	
        /// <param name="numberOfFiles">If fontFiles is NULL, receives the number of files representing the font face.  Otherwise, the number of font files being requested should be passed.  See the Remarks section below for more information.</param>
        /// <param name="fontFiles">When this method returns, contains a pointer to a user-provided array that stores pointers to font files representing the font face. This parameter can be NULL if the user wants only the number of files representing the font face. This API increments reference count of the font file pointers returned according to COM conventions, and the client should release them when finished.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFiles([InOut] UINT32* numberOfFiles,[Out, Buffer, Optional] IDWriteFontFile** fontFiles)</unmanaged>
        public SlimDX2.Result GetFiles(ref int numberOfFiles, SlimDX2.DirectWrite.FontFile[] fontFiles) {
            unsafe {
                IntPtr* fontFiles_ = stackalloc IntPtr[fontFiles.Length];
                SlimDX2.Result __result__;
                fixed (void* numberOfFiles_ = &numberOfFiles)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, numberOfFiles_, &fontFiles_);
                for (int i = 0; i < fontFiles.Length; i++)
                    fontFiles[i] = (fontFiles_[i] == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontFile(fontFiles_[i]);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Obtains the index of a font face in the context of its font files. 	
        /// </summary>	
        /// <returns>The zero-based index of a font face in cases when the font files contain a collection of font faces. If the font files contain a single face, this value is zero.</returns>
        /// <unmanaged>UINT32 GetIndex()</unmanaged>
        internal int GetIndex() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Obtains the algorithmic style simulation flags of a font face. 	
        /// </summary>	
        /// <returns>Font face simulation flags for algorithmic means of making text bold or italic.</returns>
        /// <unmanaged>DWRITE_FONT_SIMULATIONS GetSimulations()</unmanaged>
        internal SlimDX2.DirectWrite.FontSimulations GetSimulations() {
            unsafe {
                SlimDX2.DirectWrite.FontSimulations __result__;
                __result__= (SlimDX2.DirectWrite.FontSimulations)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Determines whether the font is a symbol font. 	
        /// </summary>	
        /// <returns>Returns TRUE if the font is a symbol font, otherwise FALSE.</returns>
        /// <unmanaged>BOOL IsSymbolFont()</unmanaged>
        internal bool IsSymbolFont_() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 7 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. 	
        /// </summary>	
        /// <param name="fontFaceMetrics">When this method returns, a?<see cref="SlimDX2.DirectWrite.FontMetrics"/> structure that holds metrics (such as ascent, descent, or cap height) for the current font face element. The metrics returned by this function are in font design units.</param>
        /// <unmanaged>void GetMetrics([Out] DWRITE_FONT_METRICS* fontFaceMetrics)</unmanaged>
        internal void GetMetrics(out SlimDX2.DirectWrite.FontMetrics fontFaceMetrics) {
            unsafe {
                fontFaceMetrics = new SlimDX2.DirectWrite.FontMetrics();
                fixed (void* fontFaceMetrics_ = &fontFaceMetrics)
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 8 * 4, fontFaceMetrics_);
            }
        }
        
        /// <summary>	
        ///  Obtains the number of glyphs in the font face. 	
        /// </summary>	
        /// <returns>The number of glyphs in the font face.</returns>
        /// <unmanaged>UINT16 GetGlyphCount()</unmanaged>
        internal short GetGlyphCount() {
            unsafe {
                short __result__;
                __result__= (short)SlimDX2.Direct2D1.LocalInterop.Callishort(_nativePointer, 9 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Obtains ideal (resolution-independent) glyph metrics in font design units.  	
        /// </summary>	
        /// <remarks>	
        /// Design glyph metrics are used for glyph positioning.	
        /// </remarks>	
        /// <param name="glyphIndices"> An array of glyph indices for which to compute  metrics. The array must contain at least as many elements as specified by glyphCount.</param>
        /// <param name="glyphCount">The number of elements in the glyphIndices array.</param>
        /// <param name="glyphMetrics">When this method returns, contains an array of DWRITE_GLYPH_METRICS structures.  glyphMetrics must be initialized with an empty buffer that contains at least as many elements as glyphCount. The metrics returned by this function are in font design units.</param>
        /// <param name="isSideways">Indicates whether the font is being used in a sideways run. This can affect the glyph metrics if the font has oblique simulation because sideways oblique simulation differs from non-sideways oblique simulation</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetDesignGlyphMetrics([In, Buffer] const UINT16* glyphIndices,[None] UINT32 glyphCount,[Out, Buffer] DWRITE_GLYPH_METRICS* glyphMetrics,[None] BOOL isSideways)</unmanaged>
        public SlimDX2.Result GetDesignGlyphMetrics(short[] glyphIndices, int glyphCount, SlimDX2.DirectWrite.GlyphMetrics[] glyphMetrics, bool isSideways) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* glyphIndices_ = &glyphIndices[0])
                    fixed (void* glyphMetrics_ = &glyphMetrics[0])
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 10 * 4, glyphIndices_, glyphCount, glyphMetrics_, (isSideways?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Returns the nominal mapping of UCS4 Unicode code points to glyph indices as defined by the font 'CMAP' table. 	
        /// </summary>	
        /// <remarks>	
        /// Note that this mapping is primarily provided for line layout engines built on top of the physical font API. Because of OpenType glyph substitution and line layout character substitution, the nominal conversion does not always correspond to how a Unicode string will map to glyph indices when rendering using a particular font face. Also, note that Unicode variant selectors provide for alternate mappings for character to glyph. This call will always return the default variant. 	
        /// </remarks>	
        /// <param name="codePoints">An array of USC4 code points from which to obtain nominal glyph indices. The array must be allocated and be able to contain the number of elements specified by codePointCount.</param>
        /// <param name="codePointCount">The number of elements in the codePoints array.</param>
        /// <param name="glyphIndices">When this method returns, contains a pointer to an array of nominal glyph indices filled by this function.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetGlyphIndices([In, Buffer] const UINT32* codePoints,[None] UINT32 codePointCount,[Out, Buffer] UINT16* glyphIndices)</unmanaged>
        public SlimDX2.Result GetGlyphIndices(int[] codePoints, int codePointCount, short[] glyphIndices) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* codePoints_ = &codePoints[0])
                    fixed (void* glyphIndices_ = &glyphIndices[0])
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 11 * 4, codePoints_, codePointCount, glyphIndices_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Finds the specified OpenType font table if it exists and returns a pointer to it. The function accesses the underlying font data through the <see cref="SlimDX2.DirectWrite.FontFileStream"/> interface implemented by the font file loader. 	
        /// </summary>	
        /// <remarks>	
        ///  The context for the same tag may be different for each call, so each one must be held and released separately. 	
        /// </remarks>	
        /// <param name="openTypeTableTag">The four-character tag of a OpenType font table to find. Use the DWRITE_MAKE_OPENTYPE_TAG macro to create it as an UINT32. Unlike GDI, it does not support the special TTCF and null tags to access the whole font.</param>
        /// <param name="tableData">When this method returns, contains the address of  a pointer to the base of the table in memory. The pointer is valid only as long as the font face used to get the font table still exists; (not any other font face, even if it actually refers to the same physical font). This parameter is passed uninitialized.</param>
        /// <param name="tableSize">When this method returns, contains a pointer to the size, in bytes, of the font table.</param>
        /// <param name="tableContext">When this method returns, the address of a pointer to  the opaque context, which must be freed by calling {{ReleaseFontTable}}. The context actually comes from the lower-level <see cref="SlimDX2.DirectWrite.FontFileStream"/>, which may be implemented by the application or DWrite itself. It is possible for a NULL tableContext to be returned, especially if the implementation performs direct memory mapping on the whole file. Nevertheless, always release it later, and do not use it as a test for function success. The same table can be queried multiple times, but because each returned context can be different, you must release each context separately. </param>
        /// <param name="exists">When this method returns, TRUE if the font table exists; otherwise, FALSE.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT TryGetFontTable([In] UINT32 openTypeTableTag,[Out, Buffer] const void** tableData,[Out] UINT32* tableSize,[Out] void** tableContext,[Out] BOOL* exists)</unmanaged>
        public SlimDX2.Result TryGetFontTable(int openTypeTableTag, IntPtr tableData, out int tableSize, out IntPtr tableContext, out bool exists) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* tableSize_ = &tableSize)
                    fixed (void* tableContext_ = &tableContext)
                        fixed (void* exists_ = &exists)
                            __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 12 * 4, openTypeTableTag, (void*)tableData, tableSize_, tableContext_, exists_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Releases the table obtained earlier from {{TryGetFontTable}}. 	
        /// </summary>	
        /// <param name="tableContext">A pointer to the opaque context from {{TryGetFontTable}}.</param>
        /// <unmanaged>void ReleaseFontTable([In] void* tableContext)</unmanaged>
        public void ReleaseFontTable(IntPtr tableContext) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 13 * 4, (void*)tableContext);
            }
        }
        
        /// <summary>	
        ///  Computes the outline of a run of glyphs by calling back to the outline sink interface. 	
        /// </summary>	
        /// <param name="emSize">The logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</param>
        /// <param name="glyphIndices">An array of glyph indices. The glyphs are in logical order and the advance direction depends on the isRightToLeft parameter. The array must be allocated and be able to contain the number of elements specified by glyphCount.</param>
        /// <param name="glyphAdvances">An optional array of glyph advances in DIPs. The advance of a glyph is the amount to advance the position (in the direction of the baseline) after drawing the glyph. glyphAdvances contains the number of elements specified by glyphCount.</param>
        /// <param name="glyphOffsets">An optional array of glyph offsets, each of which specifies the offset along the baseline and offset perpendicular to the baseline of a glyph relative to the current pen position.   glyphOffsets contains the number of elements specified by glyphCount.</param>
        /// <param name="glyphCount">The number of glyphs in the run.</param>
        /// <param name="isSideways">If TRUE, the ascender of the glyph runs alongside the baseline. If FALSE, the glyph ascender runs perpendicular to the baseline. For example, an English alphabet on a vertical baseline would have isSideways set to FALSE.A client can render a vertical run by setting isSideways to TRUE and rotating the resulting geometry 90 degrees to the right using a transform. The isSideways and isRightToLeft parameters cannot both be true.</param>
        /// <param name="isRightToLeft">The visual order of the glyphs. If this parameter is FALSE, then glyph advances are from left to right. If TRUE, the advance direction is right to left. By default, the advance direction is left to right.</param>
        /// <param name="geometrySink">A pointer to the interface that is called back to perform outline drawing operations.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetGlyphRunOutline([None] FLOAT emSize,[In, Buffer] const UINT16* glyphIndices,[In, Buffer, Optional] const FLOAT* glyphAdvances,[In, Buffer, Optional] const DWRITE_GLYPH_OFFSET* glyphOffsets,[None] UINT32 glyphCount,[None] BOOL isSideways,[None] BOOL isRightToLeft,[None] IDWriteGeometrySink* geometrySink)</unmanaged>
        internal SlimDX2.Result GetGlyphRunOutline_(float emSize, short[] glyphIndices, float[] glyphAdvances, SlimDX2.DirectWrite.GlyphOffset[] glyphOffsets, int glyphCount, bool isSideways, bool isRightToLeft, IntPtr geometrySink) {
            unsafe {
                float[] glyphAdvances__ = glyphAdvances ?? new float[1];
                SlimDX2.DirectWrite.GlyphOffset[] glyphOffsets__ = glyphOffsets ?? new SlimDX2.DirectWrite.GlyphOffset[1];
                SlimDX2.Result __result__;
                fixed (void* glyphIndices_ = &glyphIndices[0])
                    fixed (void* glyphAdvances_ = &glyphAdvances__[0])
                        fixed (void* glyphOffsets_ = &glyphOffsets__[0])
                            __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 14 * 4, emSize, glyphIndices_, glyphAdvances==null?(void*)IntPtr.Zero:glyphAdvances_, glyphOffsets==null?(void*)IntPtr.Zero:glyphOffsets_, glyphCount, (isSideways?1:0), (isRightToLeft?1:0), (void*)geometrySink);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Determines the recommended rendering mode for the font, using the specified size and rendering parameters. 	
        /// </summary>	
        /// <param name="emSize">The logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</param>
        /// <param name="pixelsPerDip">The number of physical pixels per DIP. For example, if the DPI of the rendering surface is 96, this  value is 1.0f. If the DPI is 120, this value is 120.0f/96.</param>
        /// <param name="measuringMode">The measuring method that will be used for glyphs in the font. Renderer implementations may choose different rendering modes for different measuring methods, for example: DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL for DWRITE_MEASURING_MODE_NATURAL DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC for DWRITE_MEASURING_MODE_GDI_CLASSIC DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL for DWRITE_MEASURING_MODE_GDI_NATURAL</param>
        /// <param name="renderingParams">A pointer to an object that contains rendering settings such as gamma level, enhanced contrast, and ClearType level. This parameter is necessary in case the rendering parameters  object overrides the rendering mode.</param>
        /// <param name="renderingMode">When this method returns, contains a value that indicates the recommended rendering mode to use.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetRecommendedRenderingMode([None] FLOAT emSize,[None] FLOAT pixelsPerDip,[None] DWRITE_MEASURING_MODE measuringMode,[None] IDWriteRenderingParams* renderingParams,[Out] DWRITE_RENDERING_MODE* renderingMode)</unmanaged>
        public SlimDX2.Result GetRecommendedRenderingMode(float emSize, float pixelsPerDip, SlimDX2.DirectWrite.MeasuringMode measuringMode, SlimDX2.DirectWrite.RenderingParams renderingParams, out SlimDX2.DirectWrite.RenderingMode renderingMode) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* renderingMode_ = &renderingMode)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 15 * 4, emSize, pixelsPerDip, unchecked((int)measuringMode), (void*)((renderingParams == null)?IntPtr.Zero:renderingParams.NativePointer), renderingMode_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a fontface and are used by applications for layout calculations.	
        /// </summary>	
        /// <param name="emSize">The logical size of the font in DIP units.</param>
        /// <param name="pixelsPerDip">The number of physical pixels per DIP.</param>
        /// <param name="transform">An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the font size and pixelsPerDip.</param>
        /// <param name="fontFaceMetrics">A pointer to a {{DWRITE_FONT_METRIC}}S structure to fill in. The metrics returned by this function are in font design units.</param>
        /// <returns>Standard HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetGdiCompatibleMetrics([None] FLOAT emSize,[None] FLOAT pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[Out] DWRITE_FONT_METRICS* fontFaceMetrics)</unmanaged>
        public SlimDX2.Result GetGdiCompatibleMetrics(float emSize, float pixelsPerDip, SlimDX2.DirectWrite.Matrix? transform, out SlimDX2.DirectWrite.FontMetrics fontFaceMetrics) {
            unsafe {
                SlimDX2.DirectWrite.Matrix transform_;
                if (transform.HasValue)
                    transform_ = transform.Value;				
                fontFaceMetrics = new SlimDX2.DirectWrite.FontMetrics();
                SlimDX2.Result __result__;
                fixed (void* fontFaceMetrics_ = &fontFaceMetrics)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 16 * 4, emSize, pixelsPerDip, (transform.HasValue)?&transform_:(void*)IntPtr.Zero, fontFaceMetrics_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Obtains glyph metrics in font design units with the return values compatible with what GDI would produce.	
        /// </summary>	
        /// <param name="emSize">The ogical size of the font in DIP units.</param>
        /// <param name="pixelsPerDip">The number of physical pixels per DIP.</param>
        /// <param name="transform">An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the font size and pixelsPerDip.</param>
        /// <param name="useGdiNatural">When set to FALSE, the metrics are the same as the metrics of GDI aliased text.  When set to TRUE, the metrics are the same as the metrics of text measured by GDI using a font created with CLEARTYPE_NATURAL_QUALITY.</param>
        /// <param name="glyphIndices">An array of glyph indices for which to compute the metrics.</param>
        /// <param name="glyphCount">The number of elements in the glyphIndices array.</param>
        /// <param name="glyphMetrics">An array of <see cref="SlimDX2.DirectWrite.GlyphMetrics"/> structures filled by this function. The metrics are in font design units.</param>
        /// <param name="isSideways">A BOOL value that indicates whether the font is being used in a sideways run.  This can affect the glyph metrics if the font has oblique simulation because sideways oblique simulation differs from non-sideways oblique simulation.</param>
        /// <returns>Standard HRESULT error code. If any of the input glyph indices are outside of the valid glyph index range for the current font face, E_INVALIDARG will be returned.</returns>
        /// <unmanaged>HRESULT GetGdiCompatibleGlyphMetrics([None] FLOAT emSize,[None] FLOAT pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[None] BOOL useGdiNatural,[In, Buffer] const UINT16* glyphIndices,[None] UINT32 glyphCount,[Out, Buffer] DWRITE_GLYPH_METRICS* glyphMetrics,[None] BOOL isSideways)</unmanaged>
        public SlimDX2.Result GetGdiCompatibleGlyphMetrics(float emSize, float pixelsPerDip, SlimDX2.DirectWrite.Matrix? transform, bool useGdiNatural, short[] glyphIndices, int glyphCount, SlimDX2.DirectWrite.GlyphMetrics[] glyphMetrics, bool isSideways) {
            unsafe {
                SlimDX2.DirectWrite.Matrix transform_;
                if (transform.HasValue)
                    transform_ = transform.Value;				
                SlimDX2.Result __result__;
                fixed (void* glyphIndices_ = &glyphIndices[0])
                    fixed (void* glyphMetrics_ = &glyphMetrics[0])
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 17 * 4, emSize, pixelsPerDip, (transform.HasValue)?&transform_:(void*)IntPtr.Zero, (useGdiNatural?1:0), glyphIndices_, glyphCount, glyphMetrics_, (isSideways?1:0));
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    ///  Used to construct a collection of fonts given a particular type of key. 	
    /// </summary>	
    /// <unmanaged>IDWriteFontCollectionLoader</unmanaged>
    [Guid("cca920e4-52f0-492b-bfa8-29c72ee0a468")]
    public partial class FontCollectionLoader : SlimDX2.ComObject {
        public FontCollectionLoader(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Creates a font file enumerator object that encapsulates a collection of font files. The font system calls back to this interface to create a font collection. 	
        /// </summary>	
        /// <param name="factory">Pointer to the <see cref="SlimDX2.DirectWrite.Factory"/> object that was used to create the current font collection.</param>
        /// <param name="collectionKey">A font collection key that uniquely identifies the collection of font files within the scope of the font collection loader being used. The buffer allocated for this key must be at least  the size, in bytes, specified by collectionKeySize.</param>
        /// <param name="collectionKeySize">The size of the font collection key, in bytes.</param>
        /// <param name="fontFileEnumerator">When this method returns, contains the address of  a pointer to the newly created font file enumerator.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateEnumeratorFromKey([None] IDWriteFactory* factory,[In, Buffer] const void* collectionKey,[None] UINT32 collectionKeySize,[Out] IDWriteFontFileEnumerator** fontFileEnumerator)</unmanaged>
        public SlimDX2.Result CreateEnumeratorFromKey(SlimDX2.DirectWrite.Factory factory, IntPtr collectionKey, int collectionKeySize, out SlimDX2.DirectWrite.FontFileEnumerator fontFileEnumerator) {
            unsafe {
                IntPtr fontFileEnumerator_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4, (void*)((factory == null)?IntPtr.Zero:factory.NativePointer), (void*)collectionKey, collectionKeySize, &fontFileEnumerator_);
                fontFileEnumerator = (fontFileEnumerator_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontFileEnumerator(fontFileEnumerator_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    ///  Encapsulates a collection of font files. The font system uses this interface to enumerate font files when building a font collection.	
    /// </summary>	
    /// <unmanaged>IDWriteFontFileEnumerator</unmanaged>
    [Guid("72755049-5ff7-435d-8348-4be97cfa6c7c")]
    public partial class FontFileEnumerator : SlimDX2.ComObject {
        public FontFileEnumerator(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Gets a reference to the current font file. 	
        /// </summary>	
        /// <unmanaged>HRESULT GetCurrentFontFile([Out] IDWriteFontFile** fontFile)</unmanaged>
        public SlimDX2.DirectWrite.FontFile CurrentFontFile {
                get { SlimDX2.DirectWrite.FontFile __output__; GetCurrentFontFile(out __output__); return __output__; }
        }
        
        /// <summary>	
        ///  Advances to the next font file in the collection. When it is first created, the enumerator is positioned before the first element of the collection and the first call to MoveNext advances to the first file. 	
        /// </summary>	
        /// <param name="hasCurrentFile">When the method returns, contains  the value TRUE if the enumerator advances to a file; otherwise, FALSE if the enumerator advances past the last file in the collection.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT MoveNext([Out] BOOL* hasCurrentFile)</unmanaged>
        public SlimDX2.Result MoveNext(out bool hasCurrentFile) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* hasCurrentFile_ = &hasCurrentFile)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4, hasCurrentFile_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets a reference to the current font file. 	
        /// </summary>	
        /// <param name="fontFile">When this method returns, the address of a pointer to the newly created <see cref="SlimDX2.DirectWrite.FontFile"/> object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetCurrentFontFile([Out] IDWriteFontFile** fontFile)</unmanaged>
        internal SlimDX2.Result GetCurrentFontFile(out SlimDX2.DirectWrite.FontFile fontFile) {
            unsafe {
                IntPtr fontFile_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, &fontFile_);
                fontFile = (fontFile_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontFile(fontFile_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    ///  Represents a collection of strings indexed by locale name.	
    /// </summary>	
    /// <unmanaged>IDWriteLocalizedStrings</unmanaged>
    [Guid("08256209-099a-4b34-b86d-c22b110e7771")]
    public partial class LocalizedStrings : SlimDX2.ComObject {
        public LocalizedStrings(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Gets the number of language/string pairs. 	
        /// </summary>	
        /// <unmanaged>UINT32 GetCount()</unmanaged>
        public int Count {
                get { return GetCount(); }
        }
        
        /// <summary>	
        ///  Gets the number of language/string pairs. 	
        /// </summary>	
        /// <returns>The number of language/string pairs.</returns>
        /// <unmanaged>UINT32 GetCount()</unmanaged>
        internal int GetCount() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the zero-based index of the locale name/string pair with the specified locale name. 	
        /// </summary>	
        /// <remarks>	
        /// Note that if the locale name does not exist, the return value is a success and the exists parameter is FALSE. If you are getting the font family name for a font and the specified locale name does not exist, one option is to set the index to 0 as shown below.  There is always at least one locale for a font family.	
        /// <code> UINT32 index = 0;	
        /// BOOL exists = false; wchar_t localeName[LOCALE_NAME_MAX_LENGTH]; if (SUCCEEDED(hr))	
        /// { // Get the default locale for this user. int defaultLocaleSuccess = GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH); // If the default locale is returned, find that locale name, otherwise use "en-us". if (defaultLocaleSuccess) { hr = pFamilyNames-&gt;FindLocaleName(localeName, &amp;index, &amp;exists); } if (SUCCEEDED(hr) &amp;&amp; !exists) // if the above find did not find a match, retry with US English { hr = pFamilyNames-&gt;FindLocaleName(L"en-us", &amp;index, &amp;exists); }	
        /// } // If the specified locale doesn't exist, select the first on the list.	
        /// if (!exists) index = 0; </code>	
        /// 	
        /// </remarks>	
        /// <param name="localeName">A null-terminated array of characters containing the locale name to look for.</param>
        /// <param name="index">The zero-based index of the locale name/string pair. This method initializes index to UINT_MAX.</param>
        /// <param name="exists">When this method returns, contains TRUE if the locale name exists; otherwise, FALSE. This method initializes exists to FALSE.</param>
        /// <returns>If the specified locale name does not exist, the return value is S_OK,  but index is UINT_MAX and exists is FALSE.</returns>
        /// <unmanaged>HRESULT FindLocaleName([In] const wchar* localeName,[Out] UINT32* index,[Out] BOOL* exists)</unmanaged>
        public SlimDX2.Result FindLocaleName(string localeName, out int index, out bool exists) {
            unsafe {
                IntPtr localeName_ = Marshal.StringToHGlobalUni(localeName);
                SlimDX2.Result __result__;
                fixed (void* index_ = &index)
                    fixed (void* exists_ = &exists)
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)localeName_, index_, exists_);
                Marshal.FreeHGlobal(localeName_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the length in characters (not including the null terminator) of the locale name with the specified index. 	
        /// </summary>	
        /// <param name="index">Zero-based index of the locale name to be retrieved.</param>
        /// <param name="length">When this method returns, contains the length in characters of the locale name, not including the null terminator.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetLocaleNameLength([None] UINT32 index,[Out] UINT32* length)</unmanaged>
        public SlimDX2.Result GetLocaleNameLength(int index, out int length) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* length_ = &length)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4, index, length_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Copies the locale name with the specified index to the specified array. 	
        /// </summary>	
        /// <param name="index">Zero-based index of the locale name to be retrieved.</param>
        /// <param name="localeName">When this method returns, contains a character array, which is null-terminated, that receives the locale name from the language/string pair.  The buffer allocated for this array must be at least the size of size, in element count.</param>
        /// <param name="size">The size of the array in characters. The size must include space for the terminating null character.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetLocaleName([None] UINT32 index,[Out, Buffer] wchar* localeName,[None] UINT32 size)</unmanaged>
        public SlimDX2.Result GetLocaleName(int index, IntPtr localeName, int size) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4, index, (void*)localeName, size);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the length in characters (not including the null terminator) of the string with the specified index. 	
        /// </summary>	
        /// <remarks>	
        /// Use GetStringLength to get the string length before calling the <see cref="SlimDX2.DirectWrite.LocalizedStrings.GetString"/> method, as shown in the following code.	
        /// <code> UINT32 length = 0; // Get the string length.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);	
        /// } // Allocate a string big enough to hold the name.	
        /// wchar_t* name = new (std::nothrow) wchar_t[length+1];	
        /// if (name == NULL)	
        /// { hr = E_OUTOFMEMORY;	
        /// } // Get the family name.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFamilyNames-&gt;GetString(index, name, length+1);	
        /// } </code>	
        /// 	
        /// </remarks>	
        /// <param name="index">A zero-based index of the language/string pair.</param>
        /// <param name="length">The length in characters of the string, not including the null terminator, from the language/string pair.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetStringLength([None] UINT32 index,[Out] UINT32* length)</unmanaged>
        public SlimDX2.Result GetStringLength(int index, out int length) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* length_ = &length)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 7 * 4, index, length_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Copies the string with the specified index to the specified array. 	
        /// </summary>	
        /// <remarks>	
        /// The string returned must be allocated by the caller.  You can get the size of the string by using the {{GetStringLength}} method prior to calling GetString, as shown in the following example.	
        /// <code> UINT32 length = 0; // Get the string length.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);	
        /// } // Allocate a string big enough to hold the name.	
        /// wchar_t* name = new (std::nothrow) wchar_t[length+1];	
        /// if (name == NULL)	
        /// { hr = E_OUTOFMEMORY;	
        /// } // Get the family name.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFamilyNames-&gt;GetString(index, name, length+1);	
        /// } </code>	
        /// 	
        /// </remarks>	
        /// <param name="index">The zero-based index of the language/string pair to be examined.</param>
        /// <param name="stringBuffer">The null terminated array of characters that receives the string from the language/string pair.  The buffer allocated for this array should be at least the size of size. {{GetStringLength}} can be used to get the size of the array before using this method.</param>
        /// <param name="size">The size of the array in characters. The size must include space for the terminating null character. {{GetStringLength}} can be used to get the size of the array before using this method.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetString([None] UINT32 index,[Out, Buffer] wchar* stringBuffer,[None] UINT32 size)</unmanaged>
        public SlimDX2.Result GetString(int index, IntPtr stringBuffer, int size) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 8 * 4, index, (void*)stringBuffer, size);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    ///  An object that encapsulates a set of fonts, such as the set of fonts installed on the system, or the set of fonts in a particular directory. The font collection API can be used to discover what font families and fonts are available, and to obtain some metadata about the fonts.	
    /// </summary>	
    /// <unmanaged>IDWriteFontCollection</unmanaged>
    [Guid("a84cee02-3eea-4eee-a827-87c1a02a0fcc")]
    public partial class FontCollection : SlimDX2.ComObject {
        public FontCollection(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Gets the number of font families in the collection. 	
        /// </summary>	
        /// <unmanaged>UINT32 GetFontFamilyCount()</unmanaged>
        public int FontFamilyCount {
                get { return GetFontFamilyCount(); }
        }
        
        /// <summary>	
        ///  Gets the number of font families in the collection. 	
        /// </summary>	
        /// <returns>The number of font families in the collection.</returns>
        /// <unmanaged>UINT32 GetFontFamilyCount()</unmanaged>
        internal int GetFontFamilyCount() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates a font family object given a zero-based font family index. 	
        /// </summary>	
        /// <param name="index">Zero-based index of the font family.</param>
        /// <param name="fontFamily">When this method returns, contains the address of   a pointer to the newly created font family object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFontFamily([None] UINT32 index,[Out] IDWriteFontFamily** fontFamily)</unmanaged>
        public SlimDX2.Result GetFontFamily(int index, out SlimDX2.DirectWrite.FontFamily fontFamily) {
            unsafe {
                IntPtr fontFamily_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, index, &fontFamily_);
                fontFamily = (fontFamily_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontFamily(fontFamily_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Finds the font family with the specified family name. 	
        /// </summary>	
        /// <param name="familyName">An array of characters, which is null-terminated, containing the name of the font family. The name is not case-sensitive but must otherwise exactly match a family name in the collection.</param>
        /// <param name="index">When this method returns, contains the zero-based index of the matching font family if the family name was found; otherwise, UINT_MAX.</param>
        /// <param name="exists">When this method returns, TRUE if the family name exists; otherwise, FALSE.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT FindFamilyName([In] const wchar* familyName,[Out] UINT32* index,[Out] BOOL* exists)</unmanaged>
        public SlimDX2.Result FindFamilyName(string familyName, out int index, out bool exists) {
            unsafe {
                IntPtr familyName_ = Marshal.StringToHGlobalUni(familyName);
                SlimDX2.Result __result__;
                fixed (void* index_ = &index)
                    fixed (void* exists_ = &exists)
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)familyName_, index_, exists_);
                Marshal.FreeHGlobal(familyName_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the font object that corresponds to the same physical font as the specified font face object. The specified physical font must belong  to the font collection. 	
        /// </summary>	
        /// <param name="fontFace">A font face object that specifies the physical font.</param>
        /// <param name="font">When this method returns, contains the address of a pointer to the newly created font object if successful; otherwise, NULL.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFontFromFontFace([None] IDWriteFontFace* fontFace,[Out] IDWriteFont** font)</unmanaged>
        public SlimDX2.Result GetFontFromFontFace(SlimDX2.DirectWrite.FontFace fontFace, out SlimDX2.DirectWrite.Font font) {
            unsafe {
                IntPtr font_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)((fontFace == null)?IntPtr.Zero:fontFace.NativePointer), &font_);
                font = (font_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.Font(font_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    ///  Represents a list of fonts.	
    /// </summary>	
    /// <unmanaged>IDWriteFontList</unmanaged>
    [Guid("1a0d8438-1d97-4ec1-aef9-a2fb86ed6acb")]
    public partial class FontList : SlimDX2.ComObject {
        public FontList(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Gets the font collection that contains the fonts in the font list.	
        /// </summary>	
        /// <unmanaged>HRESULT GetFontCollection([Out] IDWriteFontCollection** fontCollection)</unmanaged>
        public SlimDX2.DirectWrite.FontCollection FontCollection {
                get { SlimDX2.DirectWrite.FontCollection __output__; GetFontCollection(out __output__); return __output__; }
        }
        
        /// <summary>	
        ///  Gets the number of fonts in the font list. 	
        /// </summary>	
        /// <unmanaged>UINT32 GetFontCount()</unmanaged>
        public int FontCount {
                get { return GetFontCount(); }
        }
        
        /// <summary>	
        ///  Gets the font collection that contains the fonts in the font list.	
        /// </summary>	
        /// <param name="fontCollection">When this method returns, contains the address of a pointer to the current <see cref="SlimDX2.DirectWrite.FontCollection"/> object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFontCollection([Out] IDWriteFontCollection** fontCollection)</unmanaged>
        internal SlimDX2.Result GetFontCollection(out SlimDX2.DirectWrite.FontCollection fontCollection) {
            unsafe {
                IntPtr fontCollection_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4, &fontCollection_);
                fontCollection = (fontCollection_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontCollection(fontCollection_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the number of fonts in the font list. 	
        /// </summary>	
        /// <returns>The number of fonts in the font list.</returns>
        /// <unmanaged>UINT32 GetFontCount()</unmanaged>
        internal int GetFontCount() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets a font given its zero-based index. 	
        /// </summary>	
        /// <param name="index">Zero-based index of the font in the font list.</param>
        /// <param name="font">When this method returns, contains the address of a pointer to the newly created <see cref="SlimDX2.DirectWrite.Font"/> object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFont([None] UINT32 index,[Out] IDWriteFont** font)</unmanaged>
        public SlimDX2.Result GetFont(int index, out SlimDX2.DirectWrite.Font font) {
            unsafe {
                IntPtr font_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4, index, &font_);
                font = (font_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.Font(font_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Represents a family of related fonts.	
    /// </summary>	
    /// <unmanaged>IDWriteFontFamily</unmanaged>
    [Guid("da20d8ef-812a-4c43-9802-62ec4abd7add")]
    public partial class FontFamily : SlimDX2.DirectWrite.FontList {
        public FontFamily(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Creates a localized strings object that contains the family names for the font family, indexed by locale name. 	
        /// </summary>	
        /// <remarks>	
        /// The following example shows how to get the font family name from a <see cref="SlimDX2.DirectWrite.FontFamily"/> object.	
        /// <code> IDWriteLocalizedStrings* pFamilyNames = NULL; // Get a list of localized strings for the family name.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFontFamily-&gt;GetFamilyNames(&amp;pFamilyNames);	
        /// } UINT32 index = 0;	
        /// BOOL exists = false; wchar_t localeName[LOCALE_NAME_MAX_LENGTH]; if (SUCCEEDED(hr))	
        /// { // Get the default locale for this user. int defaultLocaleSuccess = GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH); // If the default locale is returned, find that locale name, otherwise use "en-us". if (defaultLocaleSuccess) { hr = pFamilyNames-&gt;FindLocaleName(localeName, &amp;index, &amp;exists); } if (SUCCEEDED(hr) &amp;&amp; !exists) // if the above find did not find a match, retry with US English { hr = pFamilyNames-&gt;FindLocaleName(L"en-us", &amp;index, &amp;exists); }	
        /// } // If the specified locale doesn't exist, select the first on the list.	
        /// if (!exists) index = 0; UINT32 length = 0; // Get the string length.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);	
        /// } // Allocate a string big enough to hold the name.	
        /// wchar_t* name = new (std::nothrow) wchar_t[length+1];	
        /// if (name == NULL)	
        /// { hr = E_OUTOFMEMORY;	
        /// } // Get the family name.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFamilyNames-&gt;GetString(index, name, length+1);	
        /// } </code>	
        /// 	
        /// </remarks>	
        /// <unmanaged>HRESULT GetFamilyNames([Out] IDWriteLocalizedStrings** names)</unmanaged>
        public SlimDX2.DirectWrite.LocalizedStrings FamilyNames {
                get { SlimDX2.DirectWrite.LocalizedStrings __output__; GetFamilyNames(out __output__); return __output__; }
        }
        
        /// <summary>	
        ///  Creates a localized strings object that contains the family names for the font family, indexed by locale name. 	
        /// </summary>	
        /// <remarks>	
        /// The following example shows how to get the font family name from a <see cref="SlimDX2.DirectWrite.FontFamily"/> object.	
        /// <code> IDWriteLocalizedStrings* pFamilyNames = NULL; // Get a list of localized strings for the family name.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFontFamily-&gt;GetFamilyNames(&amp;pFamilyNames);	
        /// } UINT32 index = 0;	
        /// BOOL exists = false; wchar_t localeName[LOCALE_NAME_MAX_LENGTH]; if (SUCCEEDED(hr))	
        /// { // Get the default locale for this user. int defaultLocaleSuccess = GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH); // If the default locale is returned, find that locale name, otherwise use "en-us". if (defaultLocaleSuccess) { hr = pFamilyNames-&gt;FindLocaleName(localeName, &amp;index, &amp;exists); } if (SUCCEEDED(hr) &amp;&amp; !exists) // if the above find did not find a match, retry with US English { hr = pFamilyNames-&gt;FindLocaleName(L"en-us", &amp;index, &amp;exists); }	
        /// } // If the specified locale doesn't exist, select the first on the list.	
        /// if (!exists) index = 0; UINT32 length = 0; // Get the string length.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);	
        /// } // Allocate a string big enough to hold the name.	
        /// wchar_t* name = new (std::nothrow) wchar_t[length+1];	
        /// if (name == NULL)	
        /// { hr = E_OUTOFMEMORY;	
        /// } // Get the family name.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFamilyNames-&gt;GetString(index, name, length+1);	
        /// } </code>	
        /// 	
        /// </remarks>	
        /// <param name="names">The address of a pointer to the newly created <see cref="SlimDX2.DirectWrite.LocalizedStrings"/> object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFamilyNames([Out] IDWriteLocalizedStrings** names)</unmanaged>
        internal SlimDX2.Result GetFamilyNames(out SlimDX2.DirectWrite.LocalizedStrings names) {
            unsafe {
                IntPtr names_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4, &names_);
                names = (names_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.LocalizedStrings(names_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the font that best matches the specified properties. 	
        /// </summary>	
        /// <param name="weight">A value that is used to match a requested font weight.</param>
        /// <param name="stretch">A value that is used to match a requested font stretch.</param>
        /// <param name="style">A value that is used to match a requested font style.</param>
        /// <param name="matchingFont">When this method returns, contains the address of a pointer to the newly created <see cref="SlimDX2.DirectWrite.Font"/> object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFirstMatchingFont([None] DWRITE_FONT_WEIGHT weight,[None] DWRITE_FONT_STRETCH stretch,[None] DWRITE_FONT_STYLE style,[Out] IDWriteFont** matchingFont)</unmanaged>
        public SlimDX2.Result GetFirstMatchingFont(SlimDX2.DirectWrite.FontWeight weight, SlimDX2.DirectWrite.FontStretch stretch, SlimDX2.DirectWrite.FontStyle style, out SlimDX2.DirectWrite.Font matchingFont) {
            unsafe {
                IntPtr matchingFont_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 7 * 4, unchecked((int)weight), unchecked((int)stretch), unchecked((int)style), &matchingFont_);
                matchingFont = (matchingFont_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.Font(matchingFont_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets a list of fonts in the font family ranked in order of how well they match the specified properties. 	
        /// </summary>	
        /// <param name="weight">A value that is used to match a requested font weight.</param>
        /// <param name="stretch">A value that is used to match a requested font stretch.</param>
        /// <param name="style">A value that is used to match a requested font style.</param>
        /// <param name="matchingFonts">An address of a pointer to the newly created <see cref="SlimDX2.DirectWrite.FontList"/> object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetMatchingFonts([None] DWRITE_FONT_WEIGHT weight,[None] DWRITE_FONT_STRETCH stretch,[None] DWRITE_FONT_STYLE style,[Out] IDWriteFontList** matchingFonts)</unmanaged>
        public SlimDX2.Result GetMatchingFonts(SlimDX2.DirectWrite.FontWeight weight, SlimDX2.DirectWrite.FontStretch stretch, SlimDX2.DirectWrite.FontStyle style, out SlimDX2.DirectWrite.FontList matchingFonts) {
            unsafe {
                IntPtr matchingFonts_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 8 * 4, unchecked((int)weight), unchecked((int)stretch), unchecked((int)style), &matchingFonts_);
                matchingFonts = (matchingFonts_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontList(matchingFonts_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    ///  Represents a physical font in a font collection. This interface is used to create font faces from  physical fonts, or  to retrieve information such as  font face metrics or face names from existing font faces.	
    /// </summary>	
    /// <unmanaged>IDWriteFont</unmanaged>
    [Guid("acd16696-8c14-4f5d-877e-fe3fc1d32737")]
    public partial class Font : SlimDX2.ComObject {
        public Font(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Gets the font family to which the specified font belongs. 	
        /// </summary>	
        /// <unmanaged>HRESULT GetFontFamily([Out] IDWriteFontFamily** fontFamily)</unmanaged>
        public SlimDX2.DirectWrite.FontFamily FontFamily {
                get { SlimDX2.DirectWrite.FontFamily __output__; GetFontFamily(out __output__); return __output__; }
        }
        
        /// <summary>	
        ///  Gets the weight, or stroke thickness, of the specified font. 	
        /// </summary>	
        /// <unmanaged>DWRITE_FONT_WEIGHT GetWeight()</unmanaged>
        public SlimDX2.DirectWrite.FontWeight Weight {
                get { return GetWeight(); }
        }
        
        /// <summary>	
        ///  Gets the stretch, or width, of the specified font. 	
        /// </summary>	
        /// <unmanaged>DWRITE_FONT_STRETCH GetStretch()</unmanaged>
        public SlimDX2.DirectWrite.FontStretch Stretch {
                get { return GetStretch(); }
        }
        
        /// <summary>	
        ///  Gets the style, or slope, of the specified font. 	
        /// </summary>	
        /// <unmanaged>DWRITE_FONT_STYLE GetStyle()</unmanaged>
        public SlimDX2.DirectWrite.FontStyle Style {
                get { return GetStyle(); }
        }
        
        /// <summary>	
        ///  Determines whether the font is a symbol font. 	
        /// </summary>	
        /// <unmanaged>BOOL IsSymbolFont()</unmanaged>
        public bool IsSymbolFont {
                get { return IsSymbolFont_(); }
        }
        
        /// <summary>	
        ///  Gets a localized strings collection containing the face names for the font (such as Regular or Bold), indexed by locale name. 	
        /// </summary>	
        /// <unmanaged>HRESULT GetFaceNames([Out] IDWriteLocalizedStrings** names)</unmanaged>
        public SlimDX2.DirectWrite.LocalizedStrings FaceNames {
                get { SlimDX2.DirectWrite.LocalizedStrings __output__; GetFaceNames(out __output__); return __output__; }
        }
        
        /// <summary>	
        ///  Gets a value that indicates what simulations are applied to the specified font. 	
        /// </summary>	
        /// <unmanaged>DWRITE_FONT_SIMULATIONS GetSimulations()</unmanaged>
        public SlimDX2.DirectWrite.FontSimulations Simulations {
                get { return GetSimulations(); }
        }
        
        /// <summary>	
        ///  Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. 	
        /// </summary>	
        /// <unmanaged>void GetMetrics([Out] DWRITE_FONT_METRICS* fontMetrics)</unmanaged>
        public SlimDX2.DirectWrite.FontMetrics Metrics {
                get { SlimDX2.DirectWrite.FontMetrics __output__; GetMetrics(out __output__); return __output__; }
        }
        
        /// <summary>	
        ///  Gets the font family to which the specified font belongs. 	
        /// </summary>	
        /// <param name="fontFamily">When this method returns, contains an address of a pointer to the font family object to which the specified font belongs.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFontFamily([Out] IDWriteFontFamily** fontFamily)</unmanaged>
        internal SlimDX2.Result GetFontFamily(out SlimDX2.DirectWrite.FontFamily fontFamily) {
            unsafe {
                IntPtr fontFamily_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4, &fontFamily_);
                fontFamily = (fontFamily_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontFamily(fontFamily_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the weight, or stroke thickness, of the specified font. 	
        /// </summary>	
        /// <returns>A value that indicates the weight for the specified font.</returns>
        /// <unmanaged>DWRITE_FONT_WEIGHT GetWeight()</unmanaged>
        internal SlimDX2.DirectWrite.FontWeight GetWeight() {
            unsafe {
                SlimDX2.DirectWrite.FontWeight __result__;
                __result__= (SlimDX2.DirectWrite.FontWeight)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the stretch, or width, of the specified font. 	
        /// </summary>	
        /// <returns>A value that indicates the type of stretch, or width, applied to the specified font.</returns>
        /// <unmanaged>DWRITE_FONT_STRETCH GetStretch()</unmanaged>
        internal SlimDX2.DirectWrite.FontStretch GetStretch() {
            unsafe {
                SlimDX2.DirectWrite.FontStretch __result__;
                __result__= (SlimDX2.DirectWrite.FontStretch)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the style, or slope, of the specified font. 	
        /// </summary>	
        /// <returns>A value that indicates the type of style, or slope, of the specified font.</returns>
        /// <unmanaged>DWRITE_FONT_STYLE GetStyle()</unmanaged>
        internal SlimDX2.DirectWrite.FontStyle GetStyle() {
            unsafe {
                SlimDX2.DirectWrite.FontStyle __result__;
                __result__= (SlimDX2.DirectWrite.FontStyle)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Determines whether the font is a symbol font. 	
        /// </summary>	
        /// <returns>TRUE if the font is a symbol font; otherwise, FALSE.</returns>
        /// <unmanaged>BOOL IsSymbolFont()</unmanaged>
        internal bool IsSymbolFont_() {
            unsafe {
                bool __result__;
                __result__= (bool)(0!=SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 7 * 4));
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets a localized strings collection containing the face names for the font (such as Regular or Bold), indexed by locale name. 	
        /// </summary>	
        /// <param name="names">When this method returns, contains an address to a  pointer to the newly created localized strings object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFaceNames([Out] IDWriteLocalizedStrings** names)</unmanaged>
        internal SlimDX2.Result GetFaceNames(out SlimDX2.DirectWrite.LocalizedStrings names) {
            unsafe {
                IntPtr names_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 8 * 4, &names_);
                names = (names_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.LocalizedStrings(names_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets a localized strings collection containing the specified informational strings, indexed by locale name. 	
        /// </summary>	
        /// <remarks>	
        ///  If the font does not contain the string specified by informationalStringID, the return value is S_OK but  informationalStrings receives a NULL pointer and exists receives the value FALSE.	
        /// </remarks>	
        /// <param name="informationalStringID">A value that identifies the  informational string to get. For example, <see cref="SlimDX2.DirectWrite.InformationalStringId.Description"/> specifies a string that contains a description of the font. </param>
        /// <param name="informationalStrings">When this method returns, contains an address of a pointer to the newly created localized strings object.</param>
        /// <param name="exists">When this method returns, TRUE if the font contains the specified string ID; otherwise, FALSE.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetInformationalStrings([None] DWRITE_INFORMATIONAL_STRING_ID informationalStringID,[Out] IDWriteLocalizedStrings** informationalStrings,[Out] BOOL* exists)</unmanaged>
        public SlimDX2.Result GetInformationalStrings(SlimDX2.DirectWrite.InformationalStringId informationalStringID, out SlimDX2.DirectWrite.LocalizedStrings informationalStrings, out bool exists) {
            unsafe {
                IntPtr informationalStrings_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* exists_ = &exists)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 9 * 4, unchecked((int)informationalStringID), &informationalStrings_, exists_);
                informationalStrings = (informationalStrings_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.LocalizedStrings(informationalStrings_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets a value that indicates what simulations are applied to the specified font. 	
        /// </summary>	
        /// <returns> A value that indicates one or more of the  types of simulations (none, bold, or oblique)  applied to the specified font.</returns>
        /// <unmanaged>DWRITE_FONT_SIMULATIONS GetSimulations()</unmanaged>
        internal SlimDX2.DirectWrite.FontSimulations GetSimulations() {
            unsafe {
                SlimDX2.DirectWrite.FontSimulations __result__;
                __result__= (SlimDX2.DirectWrite.FontSimulations)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 10 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. 	
        /// </summary>	
        /// <param name="fontMetrics">When this method returns, contains a structure that has font metrics for the current font face. The metrics returned by this function are in font design units.</param>
        /// <unmanaged>void GetMetrics([Out] DWRITE_FONT_METRICS* fontMetrics)</unmanaged>
        internal void GetMetrics(out SlimDX2.DirectWrite.FontMetrics fontMetrics) {
            unsafe {
                fontMetrics = new SlimDX2.DirectWrite.FontMetrics();
                fixed (void* fontMetrics_ = &fontMetrics)
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 11 * 4, fontMetrics_);
            }
        }
        
        /// <summary>	
        ///  Determines whether the font supports a specified character. 	
        /// </summary>	
        /// <param name="unicodeValue">A Unicode (UCS-4) character value for the method to inspect.</param>
        /// <param name="exists">When this method returns, TRUE if the font supports the specified character; otherwise, FALSE.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT HasCharacter([None] UINT32 unicodeValue,[Out] BOOL* exists)</unmanaged>
        public SlimDX2.Result HasCharacter(int unicodeValue, out bool exists) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* exists_ = &exists)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 12 * 4, unicodeValue, exists_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates a font face object for the font. 	
        /// </summary>	
        /// <param name="fontFace">When this method returns, contains an address of a pointer to the newly created font face object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateFontFace([Out] IDWriteFontFace** fontFace)</unmanaged>
        public SlimDX2.Result CreateFontFace(out SlimDX2.DirectWrite.FontFace fontFace) {
            unsafe {
                IntPtr fontFace_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 13 * 4, &fontFace_);
                fontFace = (fontFace_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontFace(fontFace_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    ///  The IDWriteTextFormat interface describes the font and paragraph properties used to format text, and it describes locale information. 	
    /// </summary>	
    /// <unmanaged>IDWriteTextFormat</unmanaged>
    [Guid("9c906818-31d7-4fd3-a151-7c5e225db55a")]
    public partial class TextFormat : SlimDX2.ComObject {
        public TextFormat(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Gets the alignment option of text relative to the layout box's leading and trailing edge. 	
        /// </summary>	
        /// <unmanaged>DWRITE_TEXT_ALIGNMENT GetTextAlignment()</unmanaged>
        public SlimDX2.DirectWrite.TextAlignment TextAlignment {
                get { return GetTextAlignment(); }
                set { SetTextAlignment(value); }
        }
        
        /// <summary>	
        ///  Gets the alignment option of a paragraph which is  relative to the top and bottom edges of a layout box. 	
        /// </summary>	
        /// <unmanaged>DWRITE_PARAGRAPH_ALIGNMENT GetParagraphAlignment()</unmanaged>
        public SlimDX2.DirectWrite.ParagraphAlignment ParagraphAlignment {
                get { return GetParagraphAlignment(); }
                set { SetParagraphAlignment(value); }
        }
        
        /// <summary>	
        ///  Gets the word wrapping option. 	
        /// </summary>	
        /// <unmanaged>DWRITE_WORD_WRAPPING GetWordWrapping()</unmanaged>
        public SlimDX2.DirectWrite.WordWrapping WordWrapping {
                get { return GetWordWrapping(); }
                set { SetWordWrapping(value); }
        }
        
        /// <summary>	
        ///  Gets the  current reading direction for text in a paragraph. 	
        /// </summary>	
        /// <unmanaged>DWRITE_READING_DIRECTION GetReadingDirection()</unmanaged>
        public SlimDX2.DirectWrite.ReadingDirection ReadingDirection {
                get { return GetReadingDirection(); }
                set { SetReadingDirection(value); }
        }
        
        /// <summary>	
        ///  Gets the direction that text lines flow. 	
        /// </summary>	
        /// <unmanaged>DWRITE_FLOW_DIRECTION GetFlowDirection()</unmanaged>
        public SlimDX2.DirectWrite.FlowDirection FlowDirection {
                get { return GetFlowDirection(); }
                set { SetFlowDirection(value); }
        }
        
        /// <summary>	
        ///  Gets the  incremental tab stop position. 	
        /// </summary>	
        /// <unmanaged>FLOAT GetIncrementalTabStop()</unmanaged>
        public float IncrementalTabStop {
                get { return GetIncrementalTabStop(); }
                set { SetIncrementalTabStop(value); }
        }
        
        /// <summary>	
        ///  Gets the current font collection. 	
        /// </summary>	
        /// <unmanaged>HRESULT GetFontCollection([Out] IDWriteFontCollection** fontCollection)</unmanaged>
        public SlimDX2.DirectWrite.FontCollection FontCollection {
                get { SlimDX2.DirectWrite.FontCollection __output__; GetFontCollection(out __output__); return __output__; }
        }
        
        /// <summary>	
        ///  Gets the length of the font family name. 	
        /// </summary>	
        /// <unmanaged>UINT32 GetFontFamilyNameLength()</unmanaged>
        public int FontFamilyNameLength {
                get { return GetFontFamilyNameLength(); }
        }
        
        /// <summary>	
        ///  Gets the font weight of the text. 	
        /// </summary>	
        /// <unmanaged>DWRITE_FONT_WEIGHT GetFontWeight()</unmanaged>
        public SlimDX2.DirectWrite.FontWeight FontWeight {
                get { return GetFontWeight(); }
        }
        
        /// <summary>	
        ///  Gets the font style of the text.	
        /// </summary>	
        /// <unmanaged>DWRITE_FONT_STYLE GetFontStyle()</unmanaged>
        public SlimDX2.DirectWrite.FontStyle FontStyle {
                get { return GetFontStyle(); }
        }
        
        /// <summary>	
        ///  Gets the font stretch of the text. 	
        /// </summary>	
        /// <unmanaged>DWRITE_FONT_STRETCH GetFontStretch()</unmanaged>
        public SlimDX2.DirectWrite.FontStretch FontStretch {
                get { return GetFontStretch(); }
        }
        
        /// <summary>	
        ///  Gets the font  size in DIP unites. 	
        /// </summary>	
        /// <unmanaged>FLOAT GetFontSize()</unmanaged>
        public float FontSize {
                get { return GetFontSize(); }
        }
        
        /// <summary>	
        ///  Gets the length of the locale name. 	
        /// </summary>	
        /// <unmanaged>UINT32 GetLocaleNameLength()</unmanaged>
        public int LocaleNameLength {
                get { return GetLocaleNameLength(); }
        }
        
        /// <summary>	
        /// Sets the alignment of text in a paragraph, relative to the leading and trailing edge of a layout box for a IDWriteTextFormat interface.	
        /// </summary>	
        /// <remarks>	
        ///  The text can be aligned to the leading or trailing edge of the layout box, or it can be centered.  The following illustration shows text with the alignment set to DWRITE_TEXT_ALIGNMENT_LEADING, DWRITE_TEXT_ALIGNMENT_CENTER, and DWRITE_TEXT_ALIGNMENT_TRAILING, respectively.  ?Illustration of text paragraphs with leading, centered, and trailing alignment?Note??The alignment is dependent on reading direction, the above is for left-to-right reading direction.  For right-to-left reading direction it would be the opposite.See <see cref="SlimDX2.DirectWrite.TextAlignment"/> for more information. 	
        /// </remarks>	
        /// <param name="textAlignment"> The text alignment option being set for the paragraph of type DWRITE_TEXT_ALIGNMENT.  For more information, see Remarks. </param>
        /// <returns>The method can return one of the following values.Return codeDescriptionS_OKThe method succeeded.E_INVALIDARGThe textAlignment argument is invalid.?</returns>
        /// <unmanaged>HRESULT SetTextAlignment([None] DWRITE_TEXT_ALIGNMENT textAlignment)</unmanaged>
        internal SlimDX2.Result SetTextAlignment(SlimDX2.DirectWrite.TextAlignment textAlignment) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4, unchecked((int)textAlignment));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets the alignment option of a paragraph relative to the layout box's top and bottom edge. 	
        /// </summary>	
        /// <param name="paragraphAlignment">The paragraph alignment option being set for a paragraph; see DWRITE_PARAGRAPH_ALIGNMENT for more information.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetParagraphAlignment([None] DWRITE_PARAGRAPH_ALIGNMENT paragraphAlignment)</unmanaged>
        internal SlimDX2.Result SetParagraphAlignment(SlimDX2.DirectWrite.ParagraphAlignment paragraphAlignment) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, unchecked((int)paragraphAlignment));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets the word wrapping option. 	
        /// </summary>	
        /// <param name="wordWrapping">The word wrapping option being set for a paragraph; see <see cref="SlimDX2.DirectWrite.WordWrapping"/> for more information.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetWordWrapping([None] DWRITE_WORD_WRAPPING wordWrapping)</unmanaged>
        internal SlimDX2.Result SetWordWrapping(SlimDX2.DirectWrite.WordWrapping wordWrapping) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4, unchecked((int)wordWrapping));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets the paragraph reading direction. 	
        /// </summary>	
        /// <param name="readingDirection">The text reading direction (for example, <see cref="SlimDX2.DirectWrite.ReadingDirection.RightToLeft"/> for languages, such as  Arabic, that read from right to left) for a paragraph.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetReadingDirection([None] DWRITE_READING_DIRECTION readingDirection)</unmanaged>
        internal SlimDX2.Result SetReadingDirection(SlimDX2.DirectWrite.ReadingDirection readingDirection) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4, unchecked((int)readingDirection));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets the  paragraph flow direction. 	
        /// </summary>	
        /// <param name="flowDirection">The paragraph flow direction; see <see cref="SlimDX2.DirectWrite.FlowDirection"/> for more information.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetFlowDirection([None] DWRITE_FLOW_DIRECTION flowDirection)</unmanaged>
        internal SlimDX2.Result SetFlowDirection(SlimDX2.DirectWrite.FlowDirection flowDirection) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 7 * 4, unchecked((int)flowDirection));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets a fixed distance between two adjacent tab stops. 	
        /// </summary>	
        /// <param name="incrementalTabStop">The fixed distance between two adjacent tab stops.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetIncrementalTabStop([None] FLOAT incrementalTabStop)</unmanaged>
        internal SlimDX2.Result SetIncrementalTabStop(float incrementalTabStop) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 8 * 4, incrementalTabStop);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets trimming options for text overflowing the layout width. 	
        /// </summary>	
        /// <param name="trimmingOptions">Text trimming options.</param>
        /// <param name="trimmingSign">Application-defined omission sign. This parameter may be NULL. See <see cref="SlimDX2.DirectWrite.InlineObject"/> for more information.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetTrimming([In] const DWRITE_TRIMMING* trimmingOptions,[None] IDWriteInlineObject* trimmingSign)</unmanaged>
        public SlimDX2.Result SetTrimming(SlimDX2.DirectWrite.Trimming trimmingOptions, SlimDX2.DirectWrite.InlineObject trimmingSign) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 9 * 4, &trimmingOptions, (void*)((trimmingSign == null)?IntPtr.Zero:trimmingSign.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets the  line spacing. 	
        /// </summary>	
        /// <remarks>	
        ///  For the default method, spacing depends solely on the content. For uniform spacing, the specified line height overrides the content. 	
        /// </remarks>	
        /// <param name="lineSpacingMethod">Specifies how line height is being determined; see <see cref="SlimDX2.DirectWrite.LineSpacingMethod"/> for more information.</param>
        /// <param name="lineSpacing">The line height, or distance between one baseline to another.</param>
        /// <param name="baseline">The distance from top of line to baseline. A reasonable ratio to lineSpacing is 80 percent.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetLineSpacing([None] DWRITE_LINE_SPACING_METHOD lineSpacingMethod,[None] FLOAT lineSpacing,[None] FLOAT baseline)</unmanaged>
        public SlimDX2.Result SetLineSpacing(SlimDX2.DirectWrite.LineSpacingMethod lineSpacingMethod, float lineSpacing, float baseline) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 10 * 4, unchecked((int)lineSpacingMethod), lineSpacing, baseline);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the alignment option of text relative to the layout box's leading and trailing edge. 	
        /// </summary>	
        /// <returns>Returns the text alignment option of the current paragraph.</returns>
        /// <unmanaged>DWRITE_TEXT_ALIGNMENT GetTextAlignment()</unmanaged>
        internal SlimDX2.DirectWrite.TextAlignment GetTextAlignment() {
            unsafe {
                SlimDX2.DirectWrite.TextAlignment __result__;
                __result__= (SlimDX2.DirectWrite.TextAlignment)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 11 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the alignment option of a paragraph which is  relative to the top and bottom edges of a layout box. 	
        /// </summary>	
        /// <returns>A value that indicates the current paragraph alignment option.</returns>
        /// <unmanaged>DWRITE_PARAGRAPH_ALIGNMENT GetParagraphAlignment()</unmanaged>
        internal SlimDX2.DirectWrite.ParagraphAlignment GetParagraphAlignment() {
            unsafe {
                SlimDX2.DirectWrite.ParagraphAlignment __result__;
                __result__= (SlimDX2.DirectWrite.ParagraphAlignment)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 12 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the word wrapping option. 	
        /// </summary>	
        /// <returns>Returns the word wrapping option; see <see cref="SlimDX2.DirectWrite.WordWrapping"/> for more information.</returns>
        /// <unmanaged>DWRITE_WORD_WRAPPING GetWordWrapping()</unmanaged>
        internal SlimDX2.DirectWrite.WordWrapping GetWordWrapping() {
            unsafe {
                SlimDX2.DirectWrite.WordWrapping __result__;
                __result__= (SlimDX2.DirectWrite.WordWrapping)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 13 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the  current reading direction for text in a paragraph. 	
        /// </summary>	
        /// <returns>A value that indicates the current reading direction for text in a  paragraph.</returns>
        /// <unmanaged>DWRITE_READING_DIRECTION GetReadingDirection()</unmanaged>
        internal SlimDX2.DirectWrite.ReadingDirection GetReadingDirection() {
            unsafe {
                SlimDX2.DirectWrite.ReadingDirection __result__;
                __result__= (SlimDX2.DirectWrite.ReadingDirection)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 14 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the direction that text lines flow. 	
        /// </summary>	
        /// <returns>The direction that text lines flow within their parent container.  For example, DWRITE_FLOW_DIRECTION_TOP_TO_BOTTOM indicates that text lines are placed from top to bottom.</returns>
        /// <unmanaged>DWRITE_FLOW_DIRECTION GetFlowDirection()</unmanaged>
        internal SlimDX2.DirectWrite.FlowDirection GetFlowDirection() {
            unsafe {
                SlimDX2.DirectWrite.FlowDirection __result__;
                __result__= (SlimDX2.DirectWrite.FlowDirection)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 15 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the  incremental tab stop position. 	
        /// </summary>	
        /// <returns>The incremental tab stop value.</returns>
        /// <unmanaged>FLOAT GetIncrementalTabStop()</unmanaged>
        internal float GetIncrementalTabStop() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct2D1.LocalInterop.Callifloat(_nativePointer, 16 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the trimming options for text that overflows the layout box. 	
        /// </summary>	
        /// <param name="trimmingOptions">When this method returns, it contains a pointer to a <see cref="SlimDX2.DirectWrite.Trimming"/> structure that holds the text trimming options for the overflowing text.</param>
        /// <param name="trimmingSign">When this method returns, contains an address of a pointer to a trimming omission sign. This parameter may be NULL.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetTrimming([Out] DWRITE_TRIMMING* trimmingOptions,[Out] IDWriteInlineObject** trimmingSign)</unmanaged>
        public SlimDX2.Result GetTrimming(out SlimDX2.DirectWrite.Trimming trimmingOptions, out SlimDX2.DirectWrite.InlineObject trimmingSign) {
            unsafe {
                trimmingOptions = new SlimDX2.DirectWrite.Trimming();
                IntPtr trimmingSign_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* trimmingOptions_ = &trimmingOptions)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 17 * 4, trimmingOptions_, &trimmingSign_);
                trimmingSign = (trimmingSign_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.InlineObject(trimmingSign_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the line spacing adjustment set for a multiline text paragraph. 	
        /// </summary>	
        /// <param name="lineSpacingMethod">A value that indicates how line height is determined.</param>
        /// <param name="lineSpacing">When this method returns, contains the line height, or  distance between one baseline to another.</param>
        /// <param name="baseline">When this method returns, contains the distance from top of line to baseline. A reasonable ratio to lineSpacing is 80 percent.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetLineSpacing([Out] DWRITE_LINE_SPACING_METHOD* lineSpacingMethod,[Out] FLOAT* lineSpacing,[Out] FLOAT* baseline)</unmanaged>
        public SlimDX2.Result GetLineSpacing(out SlimDX2.DirectWrite.LineSpacingMethod lineSpacingMethod, out float lineSpacing, out float baseline) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* lineSpacingMethod_ = &lineSpacingMethod)
                    fixed (void* lineSpacing_ = &lineSpacing)
                        fixed (void* baseline_ = &baseline)
                            __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 18 * 4, lineSpacingMethod_, lineSpacing_, baseline_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the current font collection. 	
        /// </summary>	
        /// <param name="fontCollection">When this method returns, contains an address of a pointer to the font collection being used for the current text.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFontCollection([Out] IDWriteFontCollection** fontCollection)</unmanaged>
        internal SlimDX2.Result GetFontCollection(out SlimDX2.DirectWrite.FontCollection fontCollection) {
            unsafe {
                IntPtr fontCollection_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 19 * 4, &fontCollection_);
                fontCollection = (fontCollection_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontCollection(fontCollection_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the length of the font family name. 	
        /// </summary>	
        /// <returns>The size of the character array, in character count, not including the terminated NULL character.</returns>
        /// <unmanaged>UINT32 GetFontFamilyNameLength()</unmanaged>
        internal int GetFontFamilyNameLength() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 20 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets a copy of the font family name. 	
        /// </summary>	
        /// <param name="fontFamilyName">When this method returns, contains a pointer to a character array, which is null-terminated, that receives the current font family name. The buffer allocated for this array should be at least the size, in elements, of nameSize.</param>
        /// <param name="nameSize">The size of the fontFamilyName character array, in character count, including the terminated NULL character.  To find the size of fontFamilyName, use {{GetFontFamilyNameLength}}.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFontFamilyName([Out, Buffer] wchar* fontFamilyName,[None] UINT32 nameSize)</unmanaged>
        public SlimDX2.Result GetFontFamilyName(IntPtr fontFamilyName, int nameSize) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 21 * 4, (void*)fontFamilyName, nameSize);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the font weight of the text. 	
        /// </summary>	
        /// <returns>A value that indicates the type of weight (such as normal, bold, or black). </returns>
        /// <unmanaged>DWRITE_FONT_WEIGHT GetFontWeight()</unmanaged>
        internal SlimDX2.DirectWrite.FontWeight GetFontWeight() {
            unsafe {
                SlimDX2.DirectWrite.FontWeight __result__;
                __result__= (SlimDX2.DirectWrite.FontWeight)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 22 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the font style of the text.	
        /// </summary>	
        /// <returns>A value which indicates the type of font style (such as  slope or incline).</returns>
        /// <unmanaged>DWRITE_FONT_STYLE GetFontStyle()</unmanaged>
        internal SlimDX2.DirectWrite.FontStyle GetFontStyle() {
            unsafe {
                SlimDX2.DirectWrite.FontStyle __result__;
                __result__= (SlimDX2.DirectWrite.FontStyle)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 23 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the font stretch of the text. 	
        /// </summary>	
        /// <returns>A value which indicates the type of font stretch (such as  normal or condensed).</returns>
        /// <unmanaged>DWRITE_FONT_STRETCH GetFontStretch()</unmanaged>
        internal SlimDX2.DirectWrite.FontStretch GetFontStretch() {
            unsafe {
                SlimDX2.DirectWrite.FontStretch __result__;
                __result__= (SlimDX2.DirectWrite.FontStretch)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 24 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the font  size in DIP unites. 	
        /// </summary>	
        /// <returns>The current font size in DIP units.</returns>
        /// <unmanaged>FLOAT GetFontSize()</unmanaged>
        internal float GetFontSize() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct2D1.LocalInterop.Callifloat(_nativePointer, 25 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the length of the locale name. 	
        /// </summary>	
        /// <returns>The size of the character array in character count, not including the terminated NULL character.</returns>
        /// <unmanaged>UINT32 GetLocaleNameLength()</unmanaged>
        internal int GetLocaleNameLength() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 26 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets a copy of the locale name. 	
        /// </summary>	
        /// <param name="localeName">Contains a character array that receives the current locale name.</param>
        /// <param name="nameSize">The size of the character array, in character count, including the terminated NULL character. Use {{GetLocaleNameLength}} to get the size of the locale name character array.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetLocaleName([Out, Buffer] wchar* localeName,[None] UINT32 nameSize)</unmanaged>
        public SlimDX2.Result GetLocaleName(IntPtr localeName, int nameSize) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 27 * 4, (void*)localeName, nameSize);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    ///  Represents a font typography setting.	
    /// </summary>	
    /// <unmanaged>IDWriteTypography</unmanaged>
    [Guid("55f1112b-1dc2-4b3c-9541-f46894ed85b6")]
    public partial class Typography : SlimDX2.ComObject {
        public Typography(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Gets the number of OpenType font features for the current font. 	
        /// </summary>	
        /// <remarks>	
        /// A single run of text can be associated with more than one typographic feature. The <see cref="SlimDX2.DirectWrite.Typography"/> object holds a list of these font features.	
        /// </remarks>	
        /// <unmanaged>UINT32 GetFontFeatureCount()</unmanaged>
        public int FontFeatureCount {
                get { return GetFontFeatureCount(); }
        }
        
        /// <summary>	
        ///  Adds an OpenType font feature. 	
        /// </summary>	
        /// <param name="fontFeature">A structure that contains the OpenType name identifier and the execution parameter for the font feature being added.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT AddFontFeature([None] DWRITE_FONT_FEATURE fontFeature)</unmanaged>
        public SlimDX2.Result AddFontFeature(SlimDX2.DirectWrite.FontFeature fontFeature) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint0(_nativePointer, 3 * 4, fontFeature);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the number of OpenType font features for the current font. 	
        /// </summary>	
        /// <remarks>	
        /// A single run of text can be associated with more than one typographic feature. The <see cref="SlimDX2.DirectWrite.Typography"/> object holds a list of these font features.	
        /// </remarks>	
        /// <returns>The number of font features for the current text format.</returns>
        /// <unmanaged>UINT32 GetFontFeatureCount()</unmanaged>
        internal int GetFontFeatureCount() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the font feature at the specified index. 	
        /// </summary>	
        /// <remarks>	
        /// A single run of text can be associated with more than one typographic feature. The <see cref="SlimDX2.DirectWrite.Typography"/> object holds a list of these font features.	
        /// </remarks>	
        /// <param name="fontFeatureIndex">The zero-based index of the font feature to retrieve.</param>
        /// <param name="fontFeature">When this method returns, contains the font feature which is at the specified index.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFontFeature([None] UINT32 fontFeatureIndex,[Out] DWRITE_FONT_FEATURE* fontFeature)</unmanaged>
        public SlimDX2.Result GetFontFeature(int fontFeatureIndex, out SlimDX2.DirectWrite.FontFeature fontFeature) {
            unsafe {
                fontFeature = new SlimDX2.DirectWrite.FontFeature();
                SlimDX2.Result __result__;
                fixed (void* fontFeature_ = &fontFeature)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4, fontFeatureIndex, fontFeature_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Holds the appropriate digits and numeric punctuation for a specified locale.	
    /// </summary>	
    /// <unmanaged>IDWriteNumberSubstitution</unmanaged>
    [Guid("14885CC9-BAB0-4f90-B6ED-5C366A2CD03D")]
    public partial class NumberSubstitution : SlimDX2.ComObject {
        public NumberSubstitution(IntPtr basePtr) : base(basePtr) {
        }
        
    }
    
    /// <summary>	
    /// Implemented by the text analyzer's client to provide text to the analyzer. It allows the separation between the logical view of text as a continuous stream of characters identifiable by unique text positions, and the actual memory layout of potentially discrete blocks of text in the client's backing store. 	
    /// </summary>	
    /// <unmanaged>IDWriteTextAnalysisSource</unmanaged>
    [Guid("688e1a58-5094-47c8-adc8-fbcea60ae92b")]
    public partial class TextAnalysisSource : SlimDX2.ComObject {
        public TextAnalysisSource(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the paragraph reading direction.	
        /// </summary>	
        /// <unmanaged>DWRITE_READING_DIRECTION GetParagraphReadingDirection()</unmanaged>
        public SlimDX2.DirectWrite.ReadingDirection ParagraphReadingDirection {
                get { return GetParagraphReadingDirection(); }
        }
        
        /// <summary>	
        /// Gets a block of text starting at the specified text position. 	
        /// </summary>	
        /// <remarks>	
        /// Returning NULL indicates the end of text, which is the position after the last character. This function is called iteratively for each consecutive block, tying together several fragmented blocks in the backing store into a virtual contiguous string.Although applications can implement sparse textual content that  maps only part of the backing store, the application must map any text that is in the range passed to any analysis functions.	
        /// </remarks>	
        /// <param name="textPosition">The first position of the piece to obtain. All positions are in UTF16 code units, not whole characters, which matters when supplementary characters are used.</param>
        /// <param name="textString">When this method returns, contains an address of  the block of text as an array of characters to be retrieved from the text analysis.</param>
        /// <param name="textLength">When this method returns, contains the number of UTF16 units of the retrieved chunk. The returned length is not the length of the block, but the length     remaining in the block, from the specified position until its end. For example, querying for a position that is 75 positions into a 100-position block would return 25.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetTextAtPosition([None] UINT32 textPosition,[Out] const wchar** textString,[Out] UINT32* textLength)</unmanaged>
        public SlimDX2.Result GetTextAtPosition(int textPosition, IntPtr textString, out int textLength) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* textLength_ = &textLength)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4, textPosition, (void*)textString, textLength_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a block of text immediately preceding the specified position.	
        /// </summary>	
        /// <remarks>	
        /// NULL indicates no chunk available at the specified position, either because textPosition equals 0,  textPosition is greater than the entire text content length, or the queried position is not mapped into the application's backing store.Although applications can implement sparse textual content that  maps only part of the backing store, the application must map any text that is in the range passed to any analysis functions.	
        /// </remarks>	
        /// <param name="textPosition">The position immediately after the last position of the block of text to obtain.</param>
        /// <param name="textString">When this method returns, contains an address of a pointer to the block of text, as an array of characters from the specified range.  The text range will be from textPosition to the front of the block.</param>
        /// <param name="textLength">Number of UTF16 units of the retrieved block. The length returned is from the specified position to the front of the block.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetTextBeforePosition([None] UINT32 textPosition,[Out] const wchar** textString,[Out] UINT32* textLength)</unmanaged>
        public SlimDX2.Result GetTextBeforePosition(int textPosition, IntPtr textString, out int textLength) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* textLength_ = &textLength)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, textPosition, (void*)textString, textLength_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the paragraph reading direction.	
        /// </summary>	
        /// <returns>The reading direction of the current paragraph.</returns>
        /// <unmanaged>DWRITE_READING_DIRECTION GetParagraphReadingDirection()</unmanaged>
        internal SlimDX2.DirectWrite.ReadingDirection GetParagraphReadingDirection() {
            unsafe {
                SlimDX2.DirectWrite.ReadingDirection __result__;
                __result__= (SlimDX2.DirectWrite.ReadingDirection)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the locale name on the range affected by the text analysis.	
        /// </summary>	
        /// <remarks>	
        /// The localeName pointer must remain valid until the next call or until the analysis returns.	
        /// </remarks>	
        /// <param name="textPosition">The text position to examine.</param>
        /// <param name="textLength">Contains the length of the text being affected by the text analysis up to the next differing locale.</param>
        /// <param name="localeName">Contains an address of a  pointer to an array of characters which receives the locale name from the text affected by the text analysis. The array of characters is null-terminated.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetLocaleName([None] UINT32 textPosition,[Out] UINT32* textLength,[Out] const wchar** localeName)</unmanaged>
        public SlimDX2.Result GetLocaleName(int textPosition, out int textLength, IntPtr localeName) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* textLength_ = &textLength)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4, textPosition, textLength_, (void*)localeName);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number substitution from the text range affected by the text analysis.	
        /// </summary>	
        /// <remarks>	
        /// Any implementation should return the number substitution with an incremented reference count, and the analysis will release when finished with it (either before the next call or before it returns). However, the sink callback may hold onto it after that.	
        /// </remarks>	
        /// <param name="textPosition">The starting position from which to report.</param>
        /// <param name="textLength">Contains  the length of the text, in characters, remaining in the text range up to the next differing number substitution.</param>
        /// <param name="numberSubstitution">Contains an address of a pointer to an object, which was created with <see cref="SlimDX2.DirectWrite.Factory.CreateNumberSubstitution"/>, that holds the appropriate digits and numeric punctuation for a given locale.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetNumberSubstitution([None] UINT32 textPosition,[Out] UINT32* textLength,[Out] IDWriteNumberSubstitution** numberSubstitution)</unmanaged>
        public SlimDX2.Result GetNumberSubstitution(int textPosition, out int textLength, out SlimDX2.DirectWrite.NumberSubstitution numberSubstitution) {
            unsafe {
                IntPtr numberSubstitution_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* textLength_ = &textLength)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 7 * 4, textPosition, textLength_, &numberSubstitution_);
                numberSubstitution = (numberSubstitution_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.NumberSubstitution(numberSubstitution_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// This interface is implemented by the text analyzer's client to receive the output of a given text analysis. 	
    /// </summary>	
    /// <unmanaged>IDWriteTextAnalysisSink</unmanaged>
    [Guid("5810cd44-0ca0-4701-b3fa-bec5182ae4f6")]
    public partial class TextAnalysisSink : SlimDX2.ComObject {
        public TextAnalysisSink(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Reports script analysis for the specified text range.	
        /// </summary>	
        /// <param name="textPosition">The starting position from which to report.</param>
        /// <param name="textLength">The number of UTF16 units of the reported range.</param>
        /// <param name="scriptAnalysis">A pointer to a structure that contains a zero-based index representation of a writing system script and a value indicating whether additional shaping of text is required.</param>
        /// <returns>A successful code or error code to stop analysis.</returns>
        /// <unmanaged>HRESULT SetScriptAnalysis([None] UINT32 textPosition,[None] UINT32 textLength,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis)</unmanaged>
        public SlimDX2.Result SetScriptAnalysis(int textPosition, int textLength, SlimDX2.DirectWrite.ScriptAnalysis scriptAnalysis) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4, textPosition, textLength, &scriptAnalysis);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets line-break opportunities for each character, starting from the specified position.	
        /// </summary>	
        /// <param name="textPosition">The starting text position from which to report.</param>
        /// <param name="textLength">The number of UTF16 units of the reported range.</param>
        /// <param name="lineBreakpoints">A pointer to a structure that contains breaking conditions set for each character from the starting position to the end of the specified range.</param>
        /// <returns>A successful code or error code to stop analysis.</returns>
        /// <unmanaged>HRESULT SetLineBreakpoints([None] UINT32 textPosition,[None] UINT32 textLength,[In, Buffer] const DWRITE_LINE_BREAKPOINT* lineBreakpoints)</unmanaged>
        public SlimDX2.Result SetLineBreakpoints(int textPosition, int textLength, SlimDX2.DirectWrite.LineBreakpoint[] lineBreakpoints) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* lineBreakpoints_ = &lineBreakpoints[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, textPosition, textLength, lineBreakpoints_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets a bidirectional level on the range, which is  called once per  run change (either explicit or resolved implicit).	
        /// </summary>	
        /// <param name="textPosition">The starting position from which to report.</param>
        /// <param name="textLength">The number of UTF16 units of the reported range.</param>
        /// <param name="explicitLevel">The explicit level from the paragraph reading direction and any embedded control codes RLE/RLO/LRE/LRO/PDF, which is determined before any additional rules.</param>
        /// <param name="resolvedLevel">The final implicit level considering the explicit level and characters' natural directionality, after all Bidi rules have been applied.</param>
        /// <returns>A successful code or error code to stop analysis.</returns>
        /// <unmanaged>HRESULT SetBidiLevel([None] UINT32 textPosition,[None] UINT32 textLength,[None] UINT8 explicitLevel,[None] UINT8 resolvedLevel)</unmanaged>
        public SlimDX2.Result SetBidiLevel(int textPosition, int textLength, byte explicitLevel, byte resolvedLevel) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4, textPosition, textLength, (int)explicitLevel, (int)resolvedLevel);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the number substitution on the text range affected by the text analysis.	
        /// </summary>	
        /// <param name="textPosition">The starting position from which to report.</param>
        /// <param name="textLength">The number of UTF16 units of the reported range.</param>
        /// <param name="numberSubstitution">An object that holds the appropriate digits and numeric punctuation for a given locale. Use <see cref="SlimDX2.DirectWrite.Factory.CreateNumberSubstitution"/> to create this object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetNumberSubstitution([None] UINT32 textPosition,[None] UINT32 textLength,[None] IDWriteNumberSubstitution* numberSubstitution)</unmanaged>
        public SlimDX2.Result SetNumberSubstitution(int textPosition, int textLength, SlimDX2.DirectWrite.NumberSubstitution numberSubstitution) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4, textPosition, textLength, (void*)((numberSubstitution == null)?IntPtr.Zero:numberSubstitution.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    ///  Analyzes various text properties for complex script processing such as bidirectional (bidi) support for languages like Arabic, determination of line break opportunities, glyph placement, and number substitution.	
    /// </summary>	
    /// <unmanaged>IDWriteTextAnalyzer</unmanaged>
    [Guid("b7e6163e-7f46-43b4-84b3-e4e6249c365d")]
    public partial class TextAnalyzer : SlimDX2.ComObject {
        public TextAnalyzer(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Analyzes a text range for script boundaries, reading text attributes from the source and reporting the Unicode script ID to the sink  callback {{SetScript}}. 	
        /// </summary>	
        /// <param name="analysisSource">A pointer to the source object to analyze.</param>
        /// <param name="textPosition">The starting text position within the source object.</param>
        /// <param name="textLength">The text length to analyze.</param>
        /// <param name="analysisSink">A pointer to the sink callback object that receives the text analysis.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT AnalyzeScript([None] IDWriteTextAnalysisSource* analysisSource,[None] UINT32 textPosition,[None] UINT32 textLength,[None] IDWriteTextAnalysisSink* analysisSink)</unmanaged>
        public SlimDX2.Result AnalyzeScript(SlimDX2.DirectWrite.TextAnalysisSource analysisSource, int textPosition, int textLength, SlimDX2.DirectWrite.TextAnalysisSink analysisSink) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4, (void*)((analysisSource == null)?IntPtr.Zero:analysisSource.NativePointer), textPosition, textLength, (void*)((analysisSink == null)?IntPtr.Zero:analysisSink.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Analyzes a text range for script directionality, reading attributes from the source and reporting levels to the sink callback {{SetBidiLevel}}. 	
        /// </summary>	
        /// <remarks>	
        ///  While the function can handle multiple paragraphs, the text range should not arbitrarily split the middle of paragraphs. Otherwise, the returned levels may be wrong, because the Bidi algorithm is meant to apply to the paragraph as a whole. 	
        /// </remarks>	
        /// <param name="analysisSource">A pointer to a source object to analyze.</param>
        /// <param name="textPosition">The starting text position within the source object.</param>
        /// <param name="textLength">The text length to analyze.</param>
        /// <param name="analysisSink">A pointer to the sink callback object that receives the text analysis.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT AnalyzeBidi([None] IDWriteTextAnalysisSource* analysisSource,[None] UINT32 textPosition,[None] UINT32 textLength,[None] IDWriteTextAnalysisSink* analysisSink)</unmanaged>
        public SlimDX2.Result AnalyzeBidi(SlimDX2.DirectWrite.TextAnalysisSource analysisSource, int textPosition, int textLength, SlimDX2.DirectWrite.TextAnalysisSink analysisSink) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)((analysisSource == null)?IntPtr.Zero:analysisSource.NativePointer), textPosition, textLength, (void*)((analysisSink == null)?IntPtr.Zero:analysisSink.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Analyzes a text range for spans where number substitution is applicable, reading attributes from the source and reporting substitutable ranges to the sink callback {{SetNumberSubstitution}}. 	
        /// </summary>	
        /// <remarks>	
        ///  Although the function can handle multiple ranges of differing number substitutions, the text ranges should not arbitrarily split the middle of numbers. Otherwise, it will treat the numbers separately and will not translate any intervening punctuation. 	
        /// </remarks>	
        /// <param name="analysisSource">The source object to analyze.</param>
        /// <param name="textPosition">The starting position within the source object.</param>
        /// <param name="textLength">The length to analyze.</param>
        /// <param name="analysisSink">A pointer to the sink callback object that receives the text analysis.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT AnalyzeNumberSubstitution([None] IDWriteTextAnalysisSource* analysisSource,[None] UINT32 textPosition,[None] UINT32 textLength,[None] IDWriteTextAnalysisSink* analysisSink)</unmanaged>
        public SlimDX2.Result AnalyzeNumberSubstitution(SlimDX2.DirectWrite.TextAnalysisSource analysisSource, int textPosition, int textLength, SlimDX2.DirectWrite.TextAnalysisSink analysisSink) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)((analysisSource == null)?IntPtr.Zero:analysisSource.NativePointer), textPosition, textLength, (void*)((analysisSink == null)?IntPtr.Zero:analysisSink.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Analyzes a text range for potential breakpoint opportunities, reading attributes from the source and reporting breakpoint opportunities to the sink callback {{SetLineBreakpoints}}. 	
        /// </summary>	
        /// <remarks>	
        ///  Although the function can handle multiple paragraphs, the text range should not arbitrarily split the middle of paragraphs, unless the specified text span is considered a whole unit. Otherwise, the returned properties for the first and last characters will inappropriately allow breaks. 	
        /// </remarks>	
        /// <param name="analysisSource">A pointer to the source object to analyze.</param>
        /// <param name="textPosition">The starting text position within the source object.</param>
        /// <param name="textLength">The text length to analyze.</param>
        /// <param name="analysisSink">A pointer to the  sink callback object that receives the text analysis.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT AnalyzeLineBreakpoints([None] IDWriteTextAnalysisSource* analysisSource,[None] UINT32 textPosition,[None] UINT32 textLength,[None] IDWriteTextAnalysisSink* analysisSink)</unmanaged>
        public SlimDX2.Result AnalyzeLineBreakpoints(SlimDX2.DirectWrite.TextAnalysisSource analysisSource, int textPosition, int textLength, SlimDX2.DirectWrite.TextAnalysisSink analysisSink) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)((analysisSource == null)?IntPtr.Zero:analysisSource.NativePointer), textPosition, textLength, (void*)((analysisSink == null)?IntPtr.Zero:analysisSink.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Parses the input text string and maps it to the set of glyphs and associated glyph data according to the font and the writing system's rendering rules. 	
        /// </summary>	
        /// <remarks>	
        ///  Note that the mapping from characters to glyphs is, in general, many-to-many.  The recommended estimate for the per-glyph output buffers is (3 * textLength / 2 + 16).  This is not guaranteed to be sufficient. The value of the actualGlyphCount parameter is only valid if the call succeeds.  In the event that maxGlyphCount is not big enough, HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) will be returned.  The application should  allocate a larger buffer and try again. 	
        /// </remarks>	
        /// <param name="textString">An array of characters to convert to glyphs.</param>
        /// <param name="textLength">The length of textString.</param>
        /// <param name="fontFace">The font face that is the source of the output glyphs.</param>
        /// <param name="isSideways">A Boolean flag set to true if the text is intended to be drawn vertically.</param>
        /// <param name="isRightToLeft">A Boolean flag set to TRUE for right-to-left text.</param>
        /// <param name="scriptAnalysis">A pointer to a Script analysis result from an {{AnalyzeScript}} call.</param>
        /// <param name="localeName">The locale to use when selecting glyphs. For example the same character may map to different glyphs for ja-jp versus zh-chs. If this is NULL, then the default mapping based on the script is used.</param>
        /// <param name="numberSubstitution">A pointer to an optional number substitution which selects the appropriate glyphs for digits and related numeric characters, depending on the results obtained from AnalyzeNumberSubstitution. Passing NULL indicates that no substitution is needed and that the digits should receive nominal glyphs.</param>
        /// <param name="features">An array of pointers to the sets of typographic  features to use in each feature range.</param>
        /// <param name="featureRangeLengths">The length of each feature range, in characters.   The sum of all lengths should be equal to textLength.</param>
        /// <param name="featureRanges">The number of feature ranges.</param>
        /// <param name="maxGlyphCount">The maximum number of glyphs that can be returned.</param>
        /// <param name="clusterMap">When this method returns, contains the mapping from character ranges to glyph  ranges.</param>
        /// <param name="textProps">When this method returns, contains a pointer to an array of structures that contains  shaping properties for each character.</param>
        /// <param name="glyphIndices">The output glyph indices.</param>
        /// <param name="glyphProps">When this method returns, contains a pointer to an array of structures that contain  shaping properties for each output glyph.</param>
        /// <param name="actualGlyphCount">When this method returns, contains the actual number of glyphs returned if the call succeeds.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetGlyphs([In, Buffer] const wchar* textString,[None] UINT32 textLength,[None] IDWriteFontFace* fontFace,[None] BOOL isSideways,[None] BOOL isRightToLeft,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,[In, Optional] const wchar* localeName,[None] IDWriteNumberSubstitution* numberSubstitution,[In, Buffer, Optional] const DWRITE_TYPOGRAPHIC_FEATURES** features,[In, Buffer, Optional] const UINT32* featureRangeLengths,[None] UINT32 featureRanges,[None] UINT32 maxGlyphCount,[Out, Buffer] UINT16* clusterMap,[Out, Buffer] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,[Out, Buffer] UINT16* glyphIndices,[Out, Buffer] DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,[Out] UINT32* actualGlyphCount)</unmanaged>
        public SlimDX2.Result GetGlyphs(string textString, int textLength, SlimDX2.DirectWrite.FontFace fontFace, bool isSideways, bool isRightToLeft, SlimDX2.DirectWrite.ScriptAnalysis scriptAnalysis, string localeName, SlimDX2.DirectWrite.NumberSubstitution numberSubstitution, SlimDX2.DirectWrite.TypographicFeatures[] features, int[] featureRangeLengths, int featureRanges, int maxGlyphCount, short[] clusterMap, SlimDX2.DirectWrite.ShapingTextProperties[] textProps, short[] glyphIndices, SlimDX2.DirectWrite.ShapingGlyphProperties[] glyphProps, out int actualGlyphCount) {
            unsafe {
                IntPtr textString_ = Marshal.StringToHGlobalUni(textString);
                IntPtr localeName_ = Marshal.StringToHGlobalUni(localeName);
                SlimDX2.DirectWrite.TypographicFeatures[] features__ = features ?? new SlimDX2.DirectWrite.TypographicFeatures[1];
                int[] featureRangeLengths__ = featureRangeLengths ?? new int[1];
                SlimDX2.Result __result__;
                fixed (void* features_ = &features__[0])
                    fixed (void* featureRangeLengths_ = &featureRangeLengths__[0])
                        fixed (void* clusterMap_ = &clusterMap[0])
                            fixed (void* textProps_ = &textProps[0])
                                fixed (void* glyphIndices_ = &glyphIndices[0])
                                    fixed (void* glyphProps_ = &glyphProps[0])
                                        fixed (void* actualGlyphCount_ = &actualGlyphCount)
                                            __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)textString_, textLength, (void*)((fontFace == null)?IntPtr.Zero:fontFace.NativePointer), (isSideways?1:0), (isRightToLeft?1:0), &scriptAnalysis, (void*)localeName_, (void*)((numberSubstitution == null)?IntPtr.Zero:numberSubstitution.NativePointer), features==null?(void*)IntPtr.Zero:features_, featureRangeLengths==null?(void*)IntPtr.Zero:featureRangeLengths_, featureRanges, maxGlyphCount, clusterMap_, textProps_, glyphIndices_, glyphProps_, actualGlyphCount_);
                Marshal.FreeHGlobal(textString_ );
                Marshal.FreeHGlobal(localeName_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Places glyphs output from the {{GetGlyphs}} method according to the font  and the writing system's rendering rules. 	
        /// </summary>	
        /// <param name="textString">An array of characters containing the original string from which the glyphs came.</param>
        /// <param name="clusterMap">A pointer to the mapping from character ranges to glyph  ranges. This is returned by {{GetGlyphs}}.</param>
        /// <param name="textProps">A pointer to an array of structures that contains  shaping properties for each character. This structure is returned by  {{GetGlyphs}}.</param>
        /// <param name="textLength">The text length of textString.</param>
        /// <param name="glyphIndices">An array of glyph indices returned by {{GetGlyphs}}.</param>
        /// <param name="glyphProps">A pointer to an array of structures that contain  shaping properties for each glyph returned by {{GetGlyphs}}.</param>
        /// <param name="glyphCount">The number of glyphs returned from {{GetGlyphs}}.</param>
        /// <param name="fontFace">A pointer to the font face that is the source for the output glyphs.</param>
        /// <param name="fontEmSize">The logical font size in DIPs.</param>
        /// <param name="isSideways">A Boolean flag set to TRUE if the text is intended to be drawn vertically.</param>
        /// <param name="isRightToLeft">A Boolean flag set to TRUE for right-to-left text.</param>
        /// <param name="scriptAnalysis">A pointer to a Script analysis result from an{{AnalyzeScript}} call.</param>
        /// <param name="localeName">An array of characters containing the locale to use when selecting glyphs. For example, the same character may map to different glyphs for ja-jp versus zh-chs. If this is NULL, then the default mapping based on the script is used.</param>
        /// <param name="features">An array of pointers to the sets of typographic  features to use in each feature range.</param>
        /// <param name="featureRangeLengths">The length of each feature range, in characters.   The sum of all lengths should be equal to textLength.</param>
        /// <param name="featureRanges">The number of feature ranges.</param>
        /// <param name="glyphAdvances">When this method returns, contains the advance width of each glyph.</param>
        /// <param name="glyphOffsets">When this method returns, contains the offset of the origin of each glyph.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetGlyphPlacements([In, Buffer] const wchar* textString,[In, Buffer] const UINT16* clusterMap,[In, Buffer] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,[None] UINT32 textLength,[In, Buffer] const UINT16* glyphIndices,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,[None] UINT32 glyphCount,[None] IDWriteFontFace* fontFace,[None] FLOAT fontEmSize,[None] BOOL isSideways,[None] BOOL isRightToLeft,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,[In, Optional] const wchar* localeName,[In, Buffer, Optional] const DWRITE_TYPOGRAPHIC_FEATURES** features,[In, Buffer, Optional] const UINT32* featureRangeLengths,[None] UINT32 featureRanges,[Out, Buffer] FLOAT* glyphAdvances,[Out, Buffer] DWRITE_GLYPH_OFFSET* glyphOffsets)</unmanaged>
        public SlimDX2.Result GetGlyphPlacements(string textString, short[] clusterMap, SlimDX2.DirectWrite.ShapingTextProperties[] textProps, int textLength, short[] glyphIndices, SlimDX2.DirectWrite.ShapingGlyphProperties[] glyphProps, int glyphCount, SlimDX2.DirectWrite.FontFace fontFace, float fontEmSize, bool isSideways, bool isRightToLeft, SlimDX2.DirectWrite.ScriptAnalysis scriptAnalysis, string localeName, SlimDX2.DirectWrite.TypographicFeatures[] features, int[] featureRangeLengths, int featureRanges, float[] glyphAdvances, SlimDX2.DirectWrite.GlyphOffset[] glyphOffsets) {
            unsafe {
                IntPtr textString_ = Marshal.StringToHGlobalUni(textString);
                IntPtr localeName_ = Marshal.StringToHGlobalUni(localeName);
                SlimDX2.DirectWrite.TypographicFeatures[] features__ = features ?? new SlimDX2.DirectWrite.TypographicFeatures[1];
                int[] featureRangeLengths__ = featureRangeLengths ?? new int[1];
                SlimDX2.Result __result__;
                fixed (void* clusterMap_ = &clusterMap[0])
                    fixed (void* textProps_ = &textProps[0])
                        fixed (void* glyphIndices_ = &glyphIndices[0])
                            fixed (void* glyphProps_ = &glyphProps[0])
                                fixed (void* features_ = &features__[0])
                                    fixed (void* featureRangeLengths_ = &featureRangeLengths__[0])
                                        fixed (void* glyphAdvances_ = &glyphAdvances[0])
                                            fixed (void* glyphOffsets_ = &glyphOffsets[0])
                                                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 8 * 4, (void*)textString_, clusterMap_, textProps_, textLength, glyphIndices_, glyphProps_, glyphCount, (void*)((fontFace == null)?IntPtr.Zero:fontFace.NativePointer), fontEmSize, (isSideways?1:0), (isRightToLeft?1:0), &scriptAnalysis, (void*)localeName_, features==null?(void*)IntPtr.Zero:features_, featureRangeLengths==null?(void*)IntPtr.Zero:featureRangeLengths_, featureRanges, glyphAdvances_, glyphOffsets_);
                Marshal.FreeHGlobal(textString_ );
                Marshal.FreeHGlobal(localeName_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Place glyphs output from the GetGlyphs method according to the font  and the writing system's rendering rules.	
        /// </summary>	
        /// <param name="textString">An array of characters containing the original string from which the glyphs came.</param>
        /// <param name="clusterMap">A pointer to the mapping from character ranges to glyph  ranges. This is returned by {{GetGlyphs}}.</param>
        /// <param name="textProps">A pointer to an array of structures that contains  shaping properties for each character. This structure is returned by  {{GetGlyphs}}.</param>
        /// <param name="textLength">The text length of textString.</param>
        /// <param name="glyphIndices">An array of glyph indices returned by {{GetGlyphs}}.</param>
        /// <param name="glyphProps">A pointer to an array of structures that contain  shaping properties for each glyph returned by {{GetGlyphs}}.</param>
        /// <param name="glyphCount">The number of glyphs returned from {{GetGlyphs}}.</param>
        /// <param name="fontFace">A pointer to the font face that is the source for the output glyphs.</param>
        /// <param name="fontEmSize">The logical font size in DIPs.</param>
        /// <param name="pixelsPerDip">The number of physical pixels per DIP.</param>
        /// <param name="transform">An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the font size and pixelsPerDip.</param>
        /// <param name="useGdiNatural">When set to FALSE, the metrics are the same as the metrics of GDI aliased text.  When set to TRUE, the metrics are the same as the metrics of text measured by GDI using a font created with CLEARTYPE_NATURAL_QUALITY.</param>
        /// <param name="isSideways">A Boolean flag set to TRUE if the text is intended to be drawn vertically.</param>
        /// <param name="isRightToLeft">A Boolean flag set to TRUE for right-to-left text.</param>
        /// <param name="scriptAnalysis">A pointer to a Script analysis result from an{{AnalyzeScript}} call.</param>
        /// <param name="localeName">An array of characters containing the locale to use when selecting glyphs. For example, the same character may map to different glyphs for ja-jp versus zh-chs. If this is NULL, then the default mapping based on the script is used.</param>
        /// <param name="features">An array of pointers to the sets of typographic  features to use in each feature range.</param>
        /// <param name="featureRangeLengths">The length of each feature range, in characters.   The sum of all lengths should be equal to textLength.</param>
        /// <param name="featureRanges">The number of feature ranges.</param>
        /// <param name="glyphAdvances">When this method returns, contains the advance width of each glyph.</param>
        /// <param name="glyphOffsets">When this method returns, contains the offset of the origin of each glyph.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetGdiCompatibleGlyphPlacements([In, Buffer] const wchar* textString,[In, Buffer] const UINT16* clusterMap,[In, Buffer] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,[None] UINT32 textLength,[In, Buffer] const UINT16* glyphIndices,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,[None] UINT32 glyphCount,[None] IDWriteFontFace* fontFace,[None] FLOAT fontEmSize,[None] FLOAT pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[None] BOOL useGdiNatural,[None] BOOL isSideways,[None] BOOL isRightToLeft,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,[In, Optional] const wchar* localeName,[In, Buffer, Optional] const DWRITE_TYPOGRAPHIC_FEATURES** features,[In, Buffer, Optional] const UINT32* featureRangeLengths,[None] UINT32 featureRanges,[Out, Buffer] FLOAT* glyphAdvances,[Out, Buffer] DWRITE_GLYPH_OFFSET* glyphOffsets)</unmanaged>
        public SlimDX2.Result GetGdiCompatibleGlyphPlacements(string textString, short[] clusterMap, SlimDX2.DirectWrite.ShapingTextProperties[] textProps, int textLength, short[] glyphIndices, SlimDX2.DirectWrite.ShapingGlyphProperties[] glyphProps, int glyphCount, SlimDX2.DirectWrite.FontFace fontFace, float fontEmSize, float pixelsPerDip, SlimDX2.DirectWrite.Matrix? transform, bool useGdiNatural, bool isSideways, bool isRightToLeft, SlimDX2.DirectWrite.ScriptAnalysis scriptAnalysis, string localeName, SlimDX2.DirectWrite.TypographicFeatures[] features, int[] featureRangeLengths, int featureRanges, float[] glyphAdvances, SlimDX2.DirectWrite.GlyphOffset[] glyphOffsets) {
            unsafe {
                IntPtr textString_ = Marshal.StringToHGlobalUni(textString);
                SlimDX2.DirectWrite.Matrix transform_;
                if (transform.HasValue)
                    transform_ = transform.Value;				
                IntPtr localeName_ = Marshal.StringToHGlobalUni(localeName);
                SlimDX2.DirectWrite.TypographicFeatures[] features__ = features ?? new SlimDX2.DirectWrite.TypographicFeatures[1];
                int[] featureRangeLengths__ = featureRangeLengths ?? new int[1];
                SlimDX2.Result __result__;
                fixed (void* clusterMap_ = &clusterMap[0])
                    fixed (void* textProps_ = &textProps[0])
                        fixed (void* glyphIndices_ = &glyphIndices[0])
                            fixed (void* glyphProps_ = &glyphProps[0])
                                fixed (void* features_ = &features__[0])
                                    fixed (void* featureRangeLengths_ = &featureRangeLengths__[0])
                                        fixed (void* glyphAdvances_ = &glyphAdvances[0])
                                            fixed (void* glyphOffsets_ = &glyphOffsets[0])
                                                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 9 * 4, (void*)textString_, clusterMap_, textProps_, textLength, glyphIndices_, glyphProps_, glyphCount, (void*)((fontFace == null)?IntPtr.Zero:fontFace.NativePointer), fontEmSize, pixelsPerDip, (transform.HasValue)?&transform_:(void*)IntPtr.Zero, (useGdiNatural?1:0), (isSideways?1:0), (isRightToLeft?1:0), &scriptAnalysis, (void*)localeName_, features==null?(void*)IntPtr.Zero:features_, featureRangeLengths==null?(void*)IntPtr.Zero:featureRangeLengths_, featureRanges, glyphAdvances_, glyphOffsets_);
                Marshal.FreeHGlobal(textString_ );
                Marshal.FreeHGlobal(localeName_ );
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    ///  Wraps an application-defined inline graphic, allowing DWrite to query metrics as if the graphic were a glyph inline with the text.	
    /// </summary>	
    /// <unmanaged>IDWriteInlineObject</unmanaged>
    [Guid("8339FDE3-106F-47ab-8373-1C6295EB10B3")]
    public partial class InlineObject : SlimDX2.ComObject {
        public InlineObject(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// <see cref="SlimDX2.DirectWrite.TextLayout"/> calls this callback function to get the measurement of the inline object. 	
        /// </summary>	
        /// <unmanaged>HRESULT GetMetrics([Out] DWRITE_INLINE_OBJECT_METRICS* metrics)</unmanaged>
        public SlimDX2.DirectWrite.InlineObjectMetrics Metrics {
                get { SlimDX2.DirectWrite.InlineObjectMetrics __output__; GetMetrics(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// TextLayout calls this callback function to get the visible extents (in DIPs) of the inline object. In the case of a simple bitmap, with no padding and no overhang, all the overhangs will simply be zeroes.	
        /// </summary>	
        /// <unmanaged>HRESULT GetOverhangMetrics([Out] DWRITE_OVERHANG_METRICS* overhangs)</unmanaged>
        public SlimDX2.DirectWrite.OverhangMetrics OverhangMetrics {
                get { SlimDX2.DirectWrite.OverhangMetrics __output__; GetOverhangMetrics(out __output__); return __output__; }
        }
        
        /// <summary>	
        ///  The application implemented rendering callback (<see cref="SlimDX2.DirectWrite.TextRenderer.DrawInlineObject"/>) can use this to draw the inline object without needing to cast or query the object type. The text layout does not call this method directly. 	
        /// </summary>	
        /// <param name="clientDrawingContext">The drawing context passed to <see cref="SlimDX2.DirectWrite.TextLayout.Draw_"/>.  This parameter may be NULL.</param>
        /// <param name="renderer">The same renderer passed to <see cref="SlimDX2.DirectWrite.TextLayout.Draw_"/> as the object's containing parent.  This is useful if the inline object is recursive such as a nested layout.</param>
        /// <param name="originX">The x-coordinate at the upper-left corner of the inline object.</param>
        /// <param name="originY">The y-coordinate at the upper-left corner of the inline object.</param>
        /// <param name="isSideways">A Boolean flag that indicates whether the object's baseline runs alongside the baseline axis of the line.</param>
        /// <param name="isRightToLeft">A Boolean flag that indicates whether the object is in a right-to-left context and should be drawn flipped.</param>
        /// <param name="clientDrawingEffect">The drawing effect set in <see cref="SlimDX2.DirectWrite.TextLayout.SetDrawingEffect"/>.  Usually this effect is a foreground brush that  is used in glyph drawing.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT Draw([None] void* clientDrawingContext,[None] IDWriteTextRenderer* renderer,[None] FLOAT originX,[None] FLOAT originY,[None] BOOL isSideways,[None] BOOL isRightToLeft,[None] IUnknown* clientDrawingEffect)</unmanaged>
        internal SlimDX2.Result Draw_(IntPtr clientDrawingContext, IntPtr renderer, float originX, float originY, bool isSideways, bool isRightToLeft, SlimDX2.ComObject clientDrawingEffect) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4, (void*)clientDrawingContext, (void*)renderer, originX, originY, (isSideways?1:0), (isRightToLeft?1:0), (void*)((clientDrawingEffect == null)?IntPtr.Zero:clientDrawingEffect.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// <see cref="SlimDX2.DirectWrite.TextLayout"/> calls this callback function to get the measurement of the inline object. 	
        /// </summary>	
        /// <param name="metrics">When this method returns, contains a structure describing the geometric measurement of anapplication-defined inline object.  These metrics are in relation to the baseline of the adjacent text. </param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetMetrics([Out] DWRITE_INLINE_OBJECT_METRICS* metrics)</unmanaged>
        internal SlimDX2.Result GetMetrics(out SlimDX2.DirectWrite.InlineObjectMetrics metrics) {
            unsafe {
                metrics = new SlimDX2.DirectWrite.InlineObjectMetrics();
                SlimDX2.Result __result__;
                fixed (void* metrics_ = &metrics)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, metrics_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// TextLayout calls this callback function to get the visible extents (in DIPs) of the inline object. In the case of a simple bitmap, with no padding and no overhang, all the overhangs will simply be zeroes.	
        /// </summary>	
        /// <param name="overhangs">Overshoot of visible extents (in DIPs) outside the object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetOverhangMetrics([Out] DWRITE_OVERHANG_METRICS* overhangs)</unmanaged>
        internal SlimDX2.Result GetOverhangMetrics(out SlimDX2.DirectWrite.OverhangMetrics overhangs) {
            unsafe {
                overhangs = new SlimDX2.DirectWrite.OverhangMetrics();
                SlimDX2.Result __result__;
                fixed (void* overhangs_ = &overhangs)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4, overhangs_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Layout uses this to determine the line-breaking behavior of the inline object among the text. 	
        /// </summary>	
        /// <param name="breakConditionBefore">When this method returns, contains a value which indicates the line-breaking condition between the object and the content immediately preceding it.</param>
        /// <param name="breakConditionAfter">When this method returns, contains a value which indicates the line-breaking condition between the object and the content immediately following it.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetBreakConditions([Out] DWRITE_BREAK_CONDITION* breakConditionBefore,[Out] DWRITE_BREAK_CONDITION* breakConditionAfter)</unmanaged>
        public SlimDX2.Result GetBreakConditions(out SlimDX2.DirectWrite.BreakCondition breakConditionBefore, out SlimDX2.DirectWrite.BreakCondition breakConditionAfter) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* breakConditionBefore_ = &breakConditionBefore)
                    fixed (void* breakConditionAfter_ = &breakConditionAfter)
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4, breakConditionBefore_, breakConditionAfter_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Defines the pixel snapping properties such as pixels per DIP(device-independent pixel) and the current transform matrix of a text renderer.	
    /// </summary>	
    /// <unmanaged>IDWritePixelSnapping</unmanaged>
    [Guid("eaf3a2da-ecf4-4d24-b644-b34f6842024b")]
    public partial interface PixelSnapping {
        
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="clientDrawingContext">No documentation.</param>
        /// <param name="isDisabled">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT IsPixelSnappingDisabled([None] void* clientDrawingContext,[Out] BOOL* isDisabled)</unmanaged>
        /* public SlimDX2.Result IsPixelSnappingDisabled(IntPtr clientDrawingContext, out bool isDisabled) */

        
        /// <summary>	
        ///  Gets a transform that maps abstract coordinates to DIPs. 	
        /// </summary>	
        /// <param name="clientDrawingContext">The drawing context passed to <see cref="SlimDX2.DirectWrite.TextLayout.Draw_"/>.</param>
        /// <param name="transform">When this method returns, contains a structure which has transform information for  pixel snapping.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetCurrentTransform([None] void* clientDrawingContext,[Out] DWRITE_MATRIX* transform)</unmanaged>
        /* public SlimDX2.Result GetCurrentTransform(IntPtr clientDrawingContext, out SlimDX2.DirectWrite.Matrix transform) */

        
        /// <summary>	
        ///  Gets the number of physical pixels per DIP. 	
        /// </summary>	
        /// <remarks>	
        ///  Because a DIP (device-independent pixel) is 1/96 inch,  the pixelsPerDip value is the number of logical pixels per inch divided by 96.	
        /// </remarks>	
        /// <param name="clientDrawingContext">The drawing context passed to <see cref="SlimDX2.DirectWrite.TextLayout.Draw_"/>.</param>
        /// <param name="ixelsPerDipRef">When this method returns, contains the number of physical pixels per DIP.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetPixelsPerDip([None] void* clientDrawingContext,[Out] FLOAT* pixelsPerDip)</unmanaged>
        /* public SlimDX2.Result GetPixelsPerDip(IntPtr clientDrawingContext, out float ixelsPerDipRef) */

    }
    
    /// <summary>	
    ///  Represents a set of application-defined callbacks that perform rendering of text, inline objects, and decorations such as underlines.	
    /// </summary>	
    /// <unmanaged>IDWriteTextRenderer</unmanaged>
    [Guid("ef8a8135-5cc6-45fe-8825-c5a0724eb819")]
    public partial interface TextRenderer : SlimDX2.DirectWrite.PixelSnapping {
        
        
        /// <summary>	
        ///  IDWriteTextLayout::Draw calls this function to instruct the client to render a run of glyphs. 	
        /// </summary>	
        /// <remarks>	
        /// The <see cref="SlimDX2.DirectWrite.TextLayout.Draw_"/> function calls this callback function with all the information about glyphs to render. The application implements this callback by mostly delegating the call to the underlying platform's graphics API such as {{Direct2D}} to draw glyphs on the drawing context. An application that uses GDI can implement this callback in terms of the <see cref="SlimDX2.DirectWrite.BitmapRenderTarget.DrawGlyphRun"/> method.	
        /// </remarks>	
        /// <param name="clientDrawingContext">The application-defined drawing context passed to  <see cref="SlimDX2.DirectWrite.TextLayout.Draw_"/>.</param>
        /// <param name="baselineOriginX">The pixel location (X-coordinate) at the baseline origin of the glyph run.</param>
        /// <param name="baselineOriginY">The pixel location (Y-coordinate) at the baseline origin of the glyph run.</param>
        /// <param name="measuringMode"> The measuring method for glyphs in the run, used with the other properties to determine the rendering mode.</param>
        /// <param name="glyphRun">Pointer to the glyph run instance to render. </param>
        /// <param name="glyphRunDescription">A pointer to the optional glyph run description instance which contains properties of the characters  associated with this run.</param>
        /// <param name="clientDrawingEffect">Application-defined drawing effects for the glyphs to render. Usually this argument represents effects such as the foreground brush filling the interior of text.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT DrawGlyphRun([None] void* clientDrawingContext,[None] FLOAT baselineOriginX,[None] FLOAT baselineOriginY,[None] DWRITE_MEASURING_MODE measuringMode,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[None] IUnknown* clientDrawingEffect)</unmanaged>
        /* public SlimDX2.Result DrawGlyphRun(IntPtr clientDrawingContext, float baselineOriginX, float baselineOriginY, SlimDX2.DirectWrite.MeasuringMode measuringMode, SlimDX2.DirectWrite.GlyphRun glyphRun, ref SlimDX2.DirectWrite.GlyphRunDescription glyphRunDescription, SlimDX2.ComObject clientDrawingEffect) */

        
        /// <summary>	
        ///  IDWriteTextLayout::Draw calls this function to instruct the client to draw an underline. 	
        /// </summary>	
        /// <remarks>	
        ///  A single underline can be broken into multiple calls, depending on how the formatting changes attributes. If font sizes/styles change within an underline, the thickness and offset will be averaged weighted according to characters. To get an appropriate starting pixel position, add underline::offset to the baseline. Otherwise there will be no spacing between the text. The x coordinate will always be passed as the left side, regardless of text directionality. This simplifies drawing and reduces the problem of round-off that could potentially cause gaps or a double stamped alpha blend. To avoid alpha overlap, round the end points to the nearest device pixel. 	
        /// </remarks>	
        /// <param name="clientDrawingContext">The application-defined drawing context passed to  IDWriteTextLayout::Draw.</param>
        /// <param name="baselineOriginX">The pixel location (X-coordinate) at the baseline origin of the run where underline applies.</param>
        /// <param name="baselineOriginY">The pixel location (Y-coordinate) at the baseline origin of the run where underline applies.</param>
        /// <param name="underline">Pointer to  a structure containing underline logical information.</param>
        /// <param name="clientDrawingEffect"> Application-defined effect to apply to the underline. Usually this argument represents effects such as the foreground brush filling the interior of a line.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT DrawUnderline([None] void* clientDrawingContext,[None] FLOAT baselineOriginX,[None] FLOAT baselineOriginY,[In] const DWRITE_UNDERLINE* underline,[None] IUnknown* clientDrawingEffect)</unmanaged>
        /* public SlimDX2.Result DrawUnderline(IntPtr clientDrawingContext, float baselineOriginX, float baselineOriginY, ref SlimDX2.DirectWrite.Underline underline, SlimDX2.ComObject clientDrawingEffect) */

        
        /// <summary>	
        ///  IDWriteTextLayout::Draw calls this function to instruct the client to draw a strikethrough. 	
        /// </summary>	
        /// <remarks>	
        ///  A single strikethrough can be broken into multiple calls, depending on how the formatting changes attributes. Strikethrough is not averaged across font sizes/styles changes. To get an appropriate starting pixel position, add strikethrough::offset to the baseline. Like underlines, the x coordinate will always be passed as the left side, regardless of text directionality. 	
        /// </remarks>	
        /// <param name="clientDrawingContext">The application-defined drawing context passed to  IDWriteTextLayout::Draw.</param>
        /// <param name="baselineOriginX">The pixel location (X-coordinate) at the baseline origin of the run where strikethrough applies.</param>
        /// <param name="baselineOriginY">The pixel location (Y-coordinate) at the baseline origin of the run where strikethrough applies.</param>
        /// <param name="strikethrough">Pointer to  a structure containing strikethrough logical information.</param>
        /// <param name="clientDrawingEffect">Application-defined effect to apply to the strikethrough.  Usually this argument represents effects such as the foreground brush filling the interior of a line.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT DrawStrikethrough([None] void* clientDrawingContext,[None] FLOAT baselineOriginX,[None] FLOAT baselineOriginY,[In] const DWRITE_STRIKETHROUGH* strikethrough,[None] IUnknown* clientDrawingEffect)</unmanaged>
        /* public SlimDX2.Result DrawStrikethrough(IntPtr clientDrawingContext, float baselineOriginX, float baselineOriginY, ref SlimDX2.DirectWrite.Strikethrough strikethrough, SlimDX2.ComObject clientDrawingEffect) */

        
        /// <summary>	
        ///  IDWriteTextLayout::Draw calls this application callback when it needs to draw an inline object. 	
        /// </summary>	
        /// <param name="clientDrawingContext">The application-defined drawing context passed to IDWriteTextLayout::Draw.</param>
        /// <param name="originX">X-coordinate at the top-left corner of the inline object.</param>
        /// <param name="originY">Y-coordinate at the top-left corner of the inline object.</param>
        /// <param name="inlineObject">The application-defined inline object set using IDWriteTextFormat::SetInlineObject.</param>
        /// <param name="isSideways">A Boolean flag that indicates whether the object's baseline runs alongside the baseline axis of the line.</param>
        /// <param name="isRightToLeft">A Boolean flag that indicates whether the object is in a right-to-left context, hinting that the drawing may want to mirror the normal image.</param>
        /// <param name="clientDrawingEffect">Application-defined drawing effects for the glyphs to render. Usually this argument represents effects such as the foreground brush filling the interior of a line.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT DrawInlineObject([None] void* clientDrawingContext,[None] FLOAT originX,[None] FLOAT originY,[None] IDWriteInlineObject* inlineObject,[None] BOOL isSideways,[None] BOOL isRightToLeft,[None] IUnknown* clientDrawingEffect)</unmanaged>
        /* public SlimDX2.Result DrawInlineObject(IntPtr clientDrawingContext, float originX, float originY, SlimDX2.DirectWrite.InlineObject inlineObject, bool isSideways, bool isRightToLeft, SlimDX2.ComObject clientDrawingEffect) */

    }
    
    /// <summary>	
    /// The IDWriteTextLayout interface represents a block of text after it has been fully analyzed and formatted.	
    /// </summary>	
    /// <unmanaged>IDWriteTextLayout</unmanaged>
    [Guid("53737037-6d14-410b-9bfe-0b182bb70961")]
    public partial class TextLayout : SlimDX2.DirectWrite.TextFormat {
        public TextLayout(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Gets the layout maximum width. 	
        /// </summary>	
        /// <unmanaged>FLOAT GetMaxWidth()</unmanaged>
        public float MaxWidth {
                get { return GetMaxWidth(); }
                set { SetMaxWidth(value); }
        }
        
        /// <summary>	
        ///  Gets the layout maximum height. 	
        /// </summary>	
        /// <unmanaged>FLOAT GetMaxHeight()</unmanaged>
        public float MaxHeight {
                get { return GetMaxHeight(); }
                set { SetMaxHeight(value); }
        }
        
        /// <summary>	
        ///  Retrieves overall metrics for the formatted string. 	
        /// </summary>	
        /// <unmanaged>HRESULT GetMetrics([Out] DWRITE_TEXT_METRICS* textMetrics)</unmanaged>
        public SlimDX2.DirectWrite.TextMetrics Metrics {
                get { SlimDX2.DirectWrite.TextMetrics __output__; GetMetrics(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Returns the overhangs (in DIPs) of the layout and all objects contained in it, including text glyphs and inline objects.	
        /// </summary>	
        /// <remarks>	
        /// Underlines and strikethroughs do not contribute to the black box determination, since these are actually drawn by the renderer, which is allowed to draw them in any variety of styles.	
        /// </remarks>	
        /// <unmanaged>HRESULT GetOverhangMetrics([Out] DWRITE_OVERHANG_METRICS* overhangs)</unmanaged>
        public SlimDX2.DirectWrite.OverhangMetrics OverhangMetrics {
                get { SlimDX2.DirectWrite.OverhangMetrics __output__; GetOverhangMetrics(out __output__); return __output__; }
        }
        
        /// <summary>	
        ///  Sets the layout maximum width.	
        /// </summary>	
        /// <param name="maxWidth">A value that indicates the maximum width of the layout box.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetMaxWidth([None] FLOAT maxWidth)</unmanaged>
        internal SlimDX2.Result SetMaxWidth(float maxWidth) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 28 * 4, maxWidth);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets the layout maximum height. 	
        /// </summary>	
        /// <param name="maxHeight">A value that indicates the maximum height of the layout box. </param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetMaxHeight([None] FLOAT maxHeight)</unmanaged>
        internal SlimDX2.Result SetMaxHeight(float maxHeight) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 29 * 4, maxHeight);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets the font collection. 	
        /// </summary>	
        /// <param name="fontCollection">The font collection to set.</param>
        /// <param name="textRange">Text range to which this change applies.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetFontCollection([None] IDWriteFontCollection* fontCollection,[None] DWRITE_TEXT_RANGE textRange)</unmanaged>
        public SlimDX2.Result SetFontCollection(SlimDX2.DirectWrite.FontCollection fontCollection, SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint1(_nativePointer, 30 * 4, (void*)((fontCollection == null)?IntPtr.Zero:fontCollection.NativePointer), textRange);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets null-terminated font family name for text within a specified  text range. 	
        /// </summary>	
        /// <param name="fontFamilyName">The font family name that applies to the entire text string within the range specified by textRange.</param>
        /// <param name="textRange">Text range to which this change applies.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetFontFamilyName([In] const wchar* fontFamilyName,[None] DWRITE_TEXT_RANGE textRange)</unmanaged>
        public SlimDX2.Result SetFontFamilyName(string fontFamilyName, SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                IntPtr fontFamilyName_ = Marshal.StringToHGlobalUni(fontFamilyName);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint1(_nativePointer, 31 * 4, (void*)fontFamilyName_, textRange);
                Marshal.FreeHGlobal(fontFamilyName_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets the font weight for text within a text range specified by a <see cref="SlimDX2.DirectWrite.TextRange"/> structure. 	
        /// </summary>	
        /// <remarks>	
        /// The font weight can be set to one of the predefined font weight values provided in the <see cref="SlimDX2.DirectWrite.FontWeight"/> enumeration or an integer from 1 to 999.  Values outside this range will cause the method to fail with an E_INVALIDARG return value.The following illustration shows an example of Normal and UltraBold weights for the Palatino Linotype typeface.?Illustration of the letter "W" in Normal and UltraBold weights?	
        /// </remarks>	
        /// <param name="fontWeight">The font weight to be set for text within the range specified by textRange.</param>
        /// <param name="textRange">Text range to which this change applies.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetFontWeight([None] DWRITE_FONT_WEIGHT fontWeight,[None] DWRITE_TEXT_RANGE textRange)</unmanaged>
        public SlimDX2.Result SetFontWeight(SlimDX2.DirectWrite.FontWeight fontWeight, SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint2(_nativePointer, 32 * 4, unchecked((int)fontWeight), textRange);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets the font style for  text within a text range specified by a <see cref="SlimDX2.DirectWrite.TextRange"/> structure.	
        /// </summary>	
        /// <remarks>	
        /// The font style can be set to Normal, Italic or Oblique. The following illustration shows  three styles for the Palatino font.  For more information, see <see cref="SlimDX2.DirectWrite.FontStyle"/>.?Illustration of normal, italic, and oblique font styles for the Palatino font?	
        /// </remarks>	
        /// <param name="fontStyle">The  font style to be set   for text within a range specified by textRange.</param>
        /// <param name="textRange">The text range to which this change applies.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetFontStyle([None] DWRITE_FONT_STYLE fontStyle,[None] DWRITE_TEXT_RANGE textRange)</unmanaged>
        public SlimDX2.Result SetFontStyle(SlimDX2.DirectWrite.FontStyle fontStyle, SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint2(_nativePointer, 33 * 4, unchecked((int)fontStyle), textRange);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets the  font stretch for text within a specified text range. 	
        /// </summary>	
        /// <param name="fontStretch">A value which indicates the type of font stretch for text within the range specified by textRange.</param>
        /// <param name="textRange">Text range to which this change applies.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetFontStretch([None] DWRITE_FONT_STRETCH fontStretch,[None] DWRITE_TEXT_RANGE textRange)</unmanaged>
        public SlimDX2.Result SetFontStretch(SlimDX2.DirectWrite.FontStretch fontStretch, SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint2(_nativePointer, 34 * 4, unchecked((int)fontStretch), textRange);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the font size in DIP units for text within a specified text range. 	
        /// </summary>	
        /// <param name="fontSize">The  font size in DIP units to be set for   text in the range specified by textRange. </param>
        /// <param name="textRange">Text range to which this change applies.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetFontSize([None] FLOAT fontSize,[None] DWRITE_TEXT_RANGE textRange)</unmanaged>
        public SlimDX2.Result SetFontSize(float fontSize, SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint3(_nativePointer, 35 * 4, fontSize, textRange);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets underlining for text within a specified text range. 	
        /// </summary>	
        /// <param name="hasUnderline">A Boolean flag that indicates whether underline takes place within a specified text range.</param>
        /// <param name="textRange">Text range to which this change applies.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetUnderline([None] BOOL hasUnderline,[None] DWRITE_TEXT_RANGE textRange)</unmanaged>
        public SlimDX2.Result SetUnderline(bool hasUnderline, SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint2(_nativePointer, 36 * 4, (hasUnderline?1:0), textRange);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets strikethrough for text within a specified text range. 	
        /// </summary>	
        /// <param name="hasStrikethrough">A Boolean flag that indicates whether strikethrough takes place in the range specified by textRange.</param>
        /// <param name="textRange">Text range to which this change applies.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetStrikethrough([None] BOOL hasStrikethrough,[None] DWRITE_TEXT_RANGE textRange)</unmanaged>
        public SlimDX2.Result SetStrikethrough(bool hasStrikethrough, SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint2(_nativePointer, 37 * 4, (hasStrikethrough?1:0), textRange);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets the application-defined drawing effect. 	
        /// </summary>	
        /// <remarks>	
        /// An <see cref="SlimDX2.Direct2D1.Brush"/>, such as a color or gradient brush, can be set as a drawing effect if you are using the <see cref="SlimDX2.Direct2D1.RenderTarget.DrawTextLayout"/> to draw text and that brush will be used to draw the specified range of text. This drawing effect is associated with the specified range and will be passed back to the application by way of the callback when the range is drawn at drawing time. 	
        /// </remarks>	
        /// <param name="drawingEffect">Application-defined drawing effects that apply to the range. This data object will be passed back to the application's drawing callbacks for final rendering.</param>
        /// <param name="textRange">The text range to which this change applies.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetDrawingEffect([None] IUnknown* drawingEffect,[None] DWRITE_TEXT_RANGE textRange)</unmanaged>
        public SlimDX2.Result SetDrawingEffect(SlimDX2.ComObject drawingEffect, SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint1(_nativePointer, 38 * 4, (void*)((drawingEffect == null)?IntPtr.Zero:drawingEffect.NativePointer), textRange);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets the inline object. 	
        /// </summary>	
        /// <remarks>	
        /// The application may call this function to specify the set of properties describing an application-defined inline object for specific range. This inline object applies to the specified range and will be passed back to the application by way of the DrawInlineObject callback when the range is drawn. Any text in that range will be suppressed. 	
        /// </remarks>	
        /// <param name="inlineObject">An application-defined inline object. </param>
        /// <param name="textRange">Text range to which this change applies.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetInlineObject([None] IDWriteInlineObject* inlineObject,[None] DWRITE_TEXT_RANGE textRange)</unmanaged>
        public SlimDX2.Result SetInlineObject(SlimDX2.DirectWrite.InlineObject inlineObject, SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint1(_nativePointer, 39 * 4, (void*)((inlineObject == null)?IntPtr.Zero:inlineObject.NativePointer), textRange);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets  font typography features for text within a specified text range. 	
        /// </summary>	
        /// <param name="typography">Pointer to font typography settings. </param>
        /// <param name="textRange">Text range to which this change applies.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetTypography([None] IDWriteTypography* typography,[None] DWRITE_TEXT_RANGE textRange)</unmanaged>
        public SlimDX2.Result SetTypography(SlimDX2.DirectWrite.Typography typography, SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint1(_nativePointer, 40 * 4, (void*)((typography == null)?IntPtr.Zero:typography.NativePointer), textRange);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets the locale name for text within a specified text range.	
        /// </summary>	
        /// <param name="localeName">A null-terminated locale name string.</param>
        /// <param name="textRange">Text range to which this change applies.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetLocaleName([In] const wchar* localeName,[None] DWRITE_TEXT_RANGE textRange)</unmanaged>
        public SlimDX2.Result SetLocaleName(string localeName, SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                IntPtr localeName_ = Marshal.StringToHGlobalUni(localeName);
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint1(_nativePointer, 41 * 4, (void*)localeName_, textRange);
                Marshal.FreeHGlobal(localeName_ );
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the layout maximum width. 	
        /// </summary>	
        /// <returns>Returns the layout maximum width.</returns>
        /// <unmanaged>FLOAT GetMaxWidth()</unmanaged>
        internal float GetMaxWidth() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct2D1.LocalInterop.Callifloat(_nativePointer, 42 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the layout maximum height. 	
        /// </summary>	
        /// <returns>The layout maximum height.</returns>
        /// <unmanaged>FLOAT GetMaxHeight()</unmanaged>
        internal float GetMaxHeight() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct2D1.LocalInterop.Callifloat(_nativePointer, 43 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the font collection associated with the text at the specified position. 	
        /// </summary>	
        /// <param name="currentPosition">The position of the text to inspect.</param>
        /// <param name="fontCollection">Contains an address of a  pointer to the current font collection.</param>
        /// <param name="textRange">The range of text that has the same  formatting as the text at the position specified by currentPosition.  This means the run has the exact  formatting as the position specified, including but not limited to the underline.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFontCollection([None] UINT32 currentPosition,[Out] IDWriteFontCollection** fontCollection,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        public SlimDX2.Result GetFontCollection(int currentPosition, out SlimDX2.DirectWrite.FontCollection fontCollection, out SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                IntPtr fontCollection_ = IntPtr.Zero;
                textRange = new SlimDX2.DirectWrite.TextRange();
                SlimDX2.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 44 * 4, currentPosition, &fontCollection_, textRange_);
                fontCollection = (fontCollection_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontCollection(fontCollection_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Get the length of the font family name at the current position. 	
        /// </summary>	
        /// <param name="currentPosition">The current text position.</param>
        /// <param name="nameLength">When this method returns, contains the size of the character array containing the font family name, in character count, not including the terminated NULL character.</param>
        /// <param name="textRange">The range of text that has the same  formatting as the text at the position specified by currentPosition.  This means the run has the exact  formatting as the position specified, including but not limited to the font family.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFontFamilyNameLength([None] UINT32 currentPosition,[Out] UINT32* nameLength,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        public SlimDX2.Result GetFontFamilyNameLength(int currentPosition, out int nameLength, out SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                textRange = new SlimDX2.DirectWrite.TextRange();
                SlimDX2.Result __result__;
                fixed (void* nameLength_ = &nameLength)
                    fixed (void* textRange_ = &textRange)
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 45 * 4, currentPosition, nameLength_, textRange_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Copies the font family name of the text at the specified position. 	
        /// </summary>	
        /// <param name="currentPosition">The position of the text to examine.</param>
        /// <param name="fontFamilyName">When this method returns, contains an array of characters that receives the current font family name. You must allocate storage for this parameter.</param>
        /// <param name="nameSize">The size of the character array in character count including the terminated NULL character.</param>
        /// <param name="textRange">The range of text that has the same  formatting as the text at the position specified by currentPosition.  This means the run has the exact  formatting as the position specified, including but not limited to the font family name.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFontFamilyName([None] UINT32 currentPosition,[Out, Buffer] wchar* fontFamilyName,[None] UINT32 nameSize,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        public SlimDX2.Result GetFontFamilyName(int currentPosition, IntPtr fontFamilyName, int nameSize, out SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                textRange = new SlimDX2.DirectWrite.TextRange();
                SlimDX2.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 46 * 4, currentPosition, (void*)fontFamilyName, nameSize, textRange_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the font weight of the text at the specified position. 	
        /// </summary>	
        /// <param name="currentPosition">The position of the text to inspect.</param>
        /// <param name="fontWeight">When this method returns, contains a value which indicates the type of font weight being applied at the specified position.</param>
        /// <param name="textRange">The range of text that has the same  formatting as the text at the position specified by currentPosition.  This means the run has the exact  formatting as the position specified, including but not limited to the font weight.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFontWeight([None] UINT32 currentPosition,[Out] DWRITE_FONT_WEIGHT* fontWeight,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        public SlimDX2.Result GetFontWeight(int currentPosition, out SlimDX2.DirectWrite.FontWeight fontWeight, out SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                textRange = new SlimDX2.DirectWrite.TextRange();
                SlimDX2.Result __result__;
                fixed (void* fontWeight_ = &fontWeight)
                    fixed (void* textRange_ = &textRange)
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 47 * 4, currentPosition, fontWeight_, textRange_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the font style (also known as slope) of the text at the specified position. 	
        /// </summary>	
        /// <param name="currentPosition">The position of the text to inspect.</param>
        /// <param name="fontStyle">When this method returns, contains a value which indicates the type of font style (also known as slope or incline) being applied at the specified position.</param>
        /// <param name="textRange">The range of text that has the same  formatting as the text at the position specified by currentPosition.  This means the run has the exact  formatting as the position specified, including but not limited to the font style.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFontStyle([None] UINT32 currentPosition,[Out] DWRITE_FONT_STYLE* fontStyle,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        public SlimDX2.Result GetFontStyle(int currentPosition, out SlimDX2.DirectWrite.FontStyle fontStyle, out SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                textRange = new SlimDX2.DirectWrite.TextRange();
                SlimDX2.Result __result__;
                fixed (void* fontStyle_ = &fontStyle)
                    fixed (void* textRange_ = &textRange)
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 48 * 4, currentPosition, fontStyle_, textRange_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the font stretch of the text at the specified position. 	
        /// </summary>	
        /// <param name="currentPosition">The position of the text to inspect.</param>
        /// <param name="fontStretch">When this method returns, contains a value which indicates the type of font stretch (also known as width) being applied at the specified position.</param>
        /// <param name="textRange">The range of text that has the same  formatting as the text at the position specified by currentPosition.  This means the run has the exact  formatting as the position specified, including but not limited to the font stretch.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFontStretch([None] UINT32 currentPosition,[Out] DWRITE_FONT_STRETCH* fontStretch,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        public SlimDX2.Result GetFontStretch(int currentPosition, out SlimDX2.DirectWrite.FontStretch fontStretch, out SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                textRange = new SlimDX2.DirectWrite.TextRange();
                SlimDX2.Result __result__;
                fixed (void* fontStretch_ = &fontStretch)
                    fixed (void* textRange_ = &textRange)
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 49 * 4, currentPosition, fontStretch_, textRange_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the font em height of the text at the specified position. 	
        /// </summary>	
        /// <param name="currentPosition">The position of the text to inspect.</param>
        /// <param name="fontSize">When this method returns, contains the size of the font in ems  of the text at the specified position.</param>
        /// <param name="textRange">The range of text that has the same  formatting as the text at the position specified by currentPosition.  This means the run has the exact  formatting as the position specified, including but not limited to the font size.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetFontSize([None] UINT32 currentPosition,[Out] FLOAT* fontSize,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        public SlimDX2.Result GetFontSize(int currentPosition, out float fontSize, out SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                textRange = new SlimDX2.DirectWrite.TextRange();
                SlimDX2.Result __result__;
                fixed (void* fontSize_ = &fontSize)
                    fixed (void* textRange_ = &textRange)
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 50 * 4, currentPosition, fontSize_, textRange_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the underline presence of the text at the specified position. 	
        /// </summary>	
        /// <param name="currentPosition">The current text position.</param>
        /// <param name="hasUnderline">A Boolean  flag that indicates whether underline is present at the position indicated by currentPosition.</param>
        /// <param name="textRange">The range of text that has the same  formatting as the text at the position specified by currentPosition.  This means the run has the exact  formatting as the position specified, including but not limited to the underline.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetUnderline([None] UINT32 currentPosition,[Out] BOOL* hasUnderline,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        public SlimDX2.Result GetUnderline(int currentPosition, out bool hasUnderline, out SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                textRange = new SlimDX2.DirectWrite.TextRange();
                SlimDX2.Result __result__;
                fixed (void* hasUnderline_ = &hasUnderline)
                    fixed (void* textRange_ = &textRange)
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 51 * 4, currentPosition, hasUnderline_, textRange_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Get the strikethrough presence of the text at the specified position. 	
        /// </summary>	
        /// <param name="currentPosition">The position of the text to inspect.</param>
        /// <param name="hasStrikethrough">A Boolean  flag that indicates whether strikethrough is present at the position indicated by currentPosition.</param>
        /// <param name="textRange">Contains the range of text that has the same  formatting as the text at the position specified by currentPosition.  This means the run has the exact  formatting as the position specified, including but not limited to strikethrough.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetStrikethrough([None] UINT32 currentPosition,[Out] BOOL* hasStrikethrough,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        public SlimDX2.Result GetStrikethrough(int currentPosition, out bool hasStrikethrough, out SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                textRange = new SlimDX2.DirectWrite.TextRange();
                SlimDX2.Result __result__;
                fixed (void* hasStrikethrough_ = &hasStrikethrough)
                    fixed (void* textRange_ = &textRange)
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 52 * 4, currentPosition, hasStrikethrough_, textRange_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the application-defined drawing effect at the specified text position. 	
        /// </summary>	
        /// <param name="currentPosition">The position of the text whose drawing effect is to be retrieved.</param>
        /// <param name="drawingEffect">When this method returns, contains an address of a pointer to  the current application-defined drawing effect. Usually this effect is a foreground brush that  is used in glyph drawing.</param>
        /// <param name="textRange">Contains the range of text that has the same  formatting as the text at the position specified by currentPosition.  This means the run has the exact  formatting as the position specified, including but not limited to the drawing effect.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetDrawingEffect([None] UINT32 currentPosition,[Out] IUnknown** drawingEffect,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        public SlimDX2.Result GetDrawingEffect(int currentPosition, out SlimDX2.ComObject drawingEffect, out SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                IntPtr drawingEffect_ = IntPtr.Zero;
                textRange = new SlimDX2.DirectWrite.TextRange();
                SlimDX2.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 53 * 4, currentPosition, &drawingEffect_, textRange_);
                drawingEffect = (drawingEffect_ == IntPtr.Zero)?null:new SlimDX2.ComObject(drawingEffect_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the inline object at the specified position. 	
        /// </summary>	
        /// <param name="currentPosition">The specified text position.</param>
        /// <param name="inlineObject">Contains the application-defined inline object.</param>
        /// <param name="textRange">The range of text that has the same  formatting as the text at the position specified by currentPosition.  This means the run has the exact  formatting as the position specified, including but not limited to the inline object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetInlineObject([None] UINT32 currentPosition,[Out] IDWriteInlineObject** inlineObject,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        public SlimDX2.Result GetInlineObject(int currentPosition, out SlimDX2.DirectWrite.InlineObject inlineObject, out SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                IntPtr inlineObject_ = IntPtr.Zero;
                textRange = new SlimDX2.DirectWrite.TextRange();
                SlimDX2.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 54 * 4, currentPosition, &inlineObject_, textRange_);
                inlineObject = (inlineObject_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.InlineObject(inlineObject_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the typography setting of the text at the specified position. 	
        /// </summary>	
        /// <param name="currentPosition">The position of the text to inspect.</param>
        /// <param name="typography">When this method returns, contains an address of a  pointer to the current typography setting.</param>
        /// <param name="textRange">The range of text that has the same  formatting as the text at the position specified by currentPosition.  This means the run has the exact  formatting as the position specified, including but not limited to the typography.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetTypography([None] UINT32 currentPosition,[Out] IDWriteTypography** typography,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        public SlimDX2.Result GetTypography(int currentPosition, out SlimDX2.DirectWrite.Typography typography, out SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                IntPtr typography_ = IntPtr.Zero;
                textRange = new SlimDX2.DirectWrite.TextRange();
                SlimDX2.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 55 * 4, currentPosition, &typography_, textRange_);
                typography = (typography_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.Typography(typography_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the length of the locale name of the text at the specified position. 	
        /// </summary>	
        /// <param name="currentPosition">The position of the text to inspect.</param>
        /// <param name="nameLength">Size of the character array, in character count, not including the terminated NULL character.</param>
        /// <param name="textRange">The range of text that has the same  formatting as the text at the position specified by currentPosition.  This means the run has the exact  formatting as the position specified, including but not limited to the locale name.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetLocaleNameLength([None] UINT32 currentPosition,[Out] UINT32* nameLength,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        public SlimDX2.Result GetLocaleNameLength(int currentPosition, out int nameLength, out SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                textRange = new SlimDX2.DirectWrite.TextRange();
                SlimDX2.Result __result__;
                fixed (void* nameLength_ = &nameLength)
                    fixed (void* textRange_ = &textRange)
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 56 * 4, currentPosition, nameLength_, textRange_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the locale name of the text at the specified position. 	
        /// </summary>	
        /// <param name="currentPosition">The position of the text to inspect.</param>
        /// <param name="localeName">When this method returns, contains the character array receiving the current locale name.</param>
        /// <param name="nameSize">Size of the character array, in character count, including the terminated NULL character.</param>
        /// <param name="textRange">The range of text that has the same  formatting as the text at the position specified by currentPosition.  This means the run has the exact  formatting as the position specified, including but not limited to the locale name.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetLocaleName([None] UINT32 currentPosition,[Out, Buffer] wchar* localeName,[None] UINT32 nameSize,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        public SlimDX2.Result GetLocaleName(int currentPosition, IntPtr localeName, int nameSize, out SlimDX2.DirectWrite.TextRange textRange) {
            unsafe {
                textRange = new SlimDX2.DirectWrite.TextRange();
                SlimDX2.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 57 * 4, currentPosition, (void*)localeName, nameSize, textRange_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Draws text using the specified client drawing context.	
        /// </summary>	
        /// <remarks>	
        /// To draw text with this method, a textLayout object needs to be created by the application using <see cref="SlimDX2.DirectWrite.Factory.CreateTextLayout"/>. After the textLayout object is obtained, the application calls the  IDWriteTextLayout::Draw method  to draw the text, decorations, and inline objects. The actual drawing is done through the callback interface passed in as the textRenderer argument; there, the corresponding DrawGlyphRun API is called. 	
        /// </remarks>	
        /// <param name="clientDrawingContext">An application-defined drawing context. </param>
        /// <param name="renderer">Pointer to the set of callback functions used to draw parts of a text string.</param>
        /// <param name="originX">The x-coordinate of the layout's left side.</param>
        /// <param name="originY">The y-coordinate of the layout's top side.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT Draw([None] void* clientDrawingContext,[None] IDWriteTextRenderer* renderer,[None] FLOAT originX,[None] FLOAT originY)</unmanaged>
        internal SlimDX2.Result Draw_(IntPtr clientDrawingContext, IntPtr renderer, float originX, float originY) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 58 * 4, (void*)clientDrawingContext, (void*)renderer, originX, originY);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the information about each individual text line of the  text string. 	
        /// </summary>	
        /// <remarks>	
        ///  If maxLineCount is not large enough E_NOT_SUFFICIENT_BUFFER, which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), is returned and *actualLineCount is set to the number of lines needed. 	
        /// </remarks>	
        /// <param name="lineMetrics">When this method returns, contains a pointer to an array of structures containing various calculated length values of individual text lines.</param>
        /// <param name="maxLineCount">The maximum size of the lineMetrics array.</param>
        /// <param name="actualLineCount">When this method returns, contains the actual size of the lineMetrics array that is needed.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetLineMetrics([Out, Buffer, Optional] DWRITE_LINE_METRICS* lineMetrics,[None] UINT32 maxLineCount,[Out] UINT32* actualLineCount)</unmanaged>
        public SlimDX2.Result GetLineMetrics(SlimDX2.DirectWrite.LineMetrics[] lineMetrics, int maxLineCount, out int actualLineCount) {
            unsafe {
                SlimDX2.DirectWrite.LineMetrics[] lineMetrics__ = lineMetrics ?? new SlimDX2.DirectWrite.LineMetrics[1];
                SlimDX2.Result __result__;
                fixed (void* lineMetrics_ = &lineMetrics__[0])
                    fixed (void* actualLineCount_ = &actualLineCount)
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 59 * 4, lineMetrics==null?(void*)IntPtr.Zero:lineMetrics_, maxLineCount, actualLineCount_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Retrieves overall metrics for the formatted string. 	
        /// </summary>	
        /// <param name="textMetrics">When this method returns, contains the measured distances of text and associated content after being formatted.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetMetrics([Out] DWRITE_TEXT_METRICS* textMetrics)</unmanaged>
        internal SlimDX2.Result GetMetrics(out SlimDX2.DirectWrite.TextMetrics textMetrics) {
            unsafe {
                textMetrics = new SlimDX2.DirectWrite.TextMetrics();
                SlimDX2.Result __result__;
                fixed (void* textMetrics_ = &textMetrics)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 60 * 4, textMetrics_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns the overhangs (in DIPs) of the layout and all objects contained in it, including text glyphs and inline objects.	
        /// </summary>	
        /// <remarks>	
        /// Underlines and strikethroughs do not contribute to the black box determination, since these are actually drawn by the renderer, which is allowed to draw them in any variety of styles.	
        /// </remarks>	
        /// <param name="overhangs">Overshoots of visible extents (in DIPs) outside the layout.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetOverhangMetrics([Out] DWRITE_OVERHANG_METRICS* overhangs)</unmanaged>
        internal SlimDX2.Result GetOverhangMetrics(out SlimDX2.DirectWrite.OverhangMetrics overhangs) {
            unsafe {
                overhangs = new SlimDX2.DirectWrite.OverhangMetrics();
                SlimDX2.Result __result__;
                fixed (void* overhangs_ = &overhangs)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 61 * 4, overhangs_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Retrieves logical properties and measurements of each glyph cluster. 	
        /// </summary>	
        /// <remarks>	
        ///  If maxClusterCount is not large enough, then E_NOT_SUFFICIENT_BUFFER, which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), is returned and actualClusterCount is set to the number of clusters needed. 	
        /// </remarks>	
        /// <param name="clusterMetrics">When this method returns, contains metrics, such as line-break or total advance width, for a glyph cluster.</param>
        /// <param name="maxClusterCount">The maximum size of the clusterMetrics array.</param>
        /// <param name="actualClusterCount">When this method returns, contains the actual size of the clusterMetrics array that is needed.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetClusterMetrics([Out, Buffer, Optional] DWRITE_CLUSTER_METRICS* clusterMetrics,[None] UINT32 maxClusterCount,[Out] UINT32* actualClusterCount)</unmanaged>
        public SlimDX2.Result GetClusterMetrics(SlimDX2.DirectWrite.ClusterMetrics[] clusterMetrics, int maxClusterCount, out int actualClusterCount) {
            unsafe {
                SlimDX2.DirectWrite.ClusterMetrics[] clusterMetrics__ = clusterMetrics ?? new SlimDX2.DirectWrite.ClusterMetrics[1];
                SlimDX2.Result __result__;
                fixed (void* clusterMetrics_ = &clusterMetrics__[0])
                    fixed (void* actualClusterCount_ = &actualClusterCount)
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 62 * 4, clusterMetrics==null?(void*)IntPtr.Zero:clusterMetrics_, maxClusterCount, actualClusterCount_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Determines the minimum possible width the layout can be set to without emergency breaking between the characters of whole words occurring.	
        /// </summary>	
        /// <param name="minWidth">Minimum width.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT DetermineMinWidth([Out] FLOAT* minWidth)</unmanaged>
        public SlimDX2.Result DetermineMinWidth(out float minWidth) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* minWidth_ = &minWidth)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 63 * 4, minWidth_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  The application calls this function passing in a specific pixel location relative to the top-left location of the layout box and obtains the information about the correspondent hit-test metrics of the text string where the hit-test has occurred. When the specified pixel location is outside the text string, the function sets the output value *isInside to FALSE. 	
        /// </summary>	
        /// <param name="pointX">The pixel location X to hit-test, relative to the top-left location of the layout box.</param>
        /// <param name="pointY">The pixel location Y to hit-test, relative to the top-left location of the layout box.</param>
        /// <param name="isTrailingHit">An output flag that indicates whether the hit-test location is at the leading or the trailing side of the character. When the output *isInside value is set to FALSE, this value is set according to the output hitTestMetrics-&gt;textPosition value to represent the edge closest to the hit-test location.</param>
        /// <param name="isInside">An output flag that indicates whether the hit-test location is inside the text string. When FALSE, the position nearest the text's edge is returned.</param>
        /// <param name="hitTestMetrics">The output geometry fully enclosing the hit-test location. When the output *isInside value is set to FALSE, this structure represents the geometry enclosing the edge closest to the hit-test location.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT HitTestPoint([None] FLOAT pointX,[None] FLOAT pointY,[Out] BOOL* isTrailingHit,[Out] BOOL* isInside,[Out] DWRITE_HIT_TEST_METRICS* hitTestMetrics)</unmanaged>
        public SlimDX2.Result HitTestPoint(float pointX, float pointY, out bool isTrailingHit, out bool isInside, out SlimDX2.DirectWrite.HitTestMetrics hitTestMetrics) {
            unsafe {
                hitTestMetrics = new SlimDX2.DirectWrite.HitTestMetrics();
                SlimDX2.Result __result__;
                fixed (void* isTrailingHit_ = &isTrailingHit)
                    fixed (void* isInside_ = &isInside)
                        fixed (void* hitTestMetrics_ = &hitTestMetrics)
                            __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 64 * 4, pointX, pointY, isTrailingHit_, isInside_, hitTestMetrics_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  The application calls this function to get the pixel location relative to the top-left of the layout box given the text position and the logical side of the position. This function is normally used as part of caret positioning of text where the caret is drawn at the location corresponding to the current text editing position. It may also be used as a way to programmatically obtain the geometry of a particular text position in UI automation. 	
        /// </summary>	
        /// <param name="textPosition">The text position used to get the pixel location.</param>
        /// <param name="isTrailingHit">A Boolean flag that indicates whether the pixel location is of the leading or the trailing side of the specified text position.</param>
        /// <param name="ointXRef">When this method returns, contains the output pixel location X, relative to the top-left location of the layout box.</param>
        /// <param name="ointYRef">When this method returns, contains the output pixel location Y, relative to the top-left location of the layout box.</param>
        /// <param name="hitTestMetrics">When this method returns, contains the output geometry fully enclosing the specified text position.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT HitTestTextPosition([None] UINT32 textPosition,[None] BOOL isTrailingHit,[Out] FLOAT* pointX,[Out] FLOAT* pointY,[Out] DWRITE_HIT_TEST_METRICS* hitTestMetrics)</unmanaged>
        public SlimDX2.Result HitTestTextPosition(int textPosition, bool isTrailingHit, out float ointXRef, out float ointYRef, out SlimDX2.DirectWrite.HitTestMetrics hitTestMetrics) {
            unsafe {
                hitTestMetrics = new SlimDX2.DirectWrite.HitTestMetrics();
                SlimDX2.Result __result__;
                fixed (void* ointXRef_ = &ointXRef)
                    fixed (void* ointYRef_ = &ointYRef)
                        fixed (void* hitTestMetrics_ = &hitTestMetrics)
                            __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 65 * 4, textPosition, (isTrailingHit?1:0), ointXRef_, ointYRef_, hitTestMetrics_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  The application calls this function to get a set of hit-test metrics corresponding to a range of text positions. One of the main usages is to implement highlight selection of the text string. The function returns E_NOT_SUFFICIENT_BUFFER, which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), when the buffer size of hitTestMetrics is too small to hold all the regions calculated by the function. In this situation, the function sets the output value *actualHitTestMetricsCount to the number of geometries calculated. The application is responsible for allocating a new buffer of greater size and calling the function again. A good value to use as an initial value for maxHitTestMetricsCount may be calculated from the following equation: maxHitTestMetricsCount = lineCount * maxBidiReorderingDepth where lineCount is obtained from the value of the output argument *actualLineCount (from the function IDWriteTextLayout::GetLineLengths), and the maxBidiReorderingDepth value from the DWRITE_TEXT_METRICS structure of the output argument *textMetrics (from the function IDWriteFactory::CreateTextLayout). 	
        /// </summary>	
        /// <param name="textPosition">The first text position of the specified range.</param>
        /// <param name="textLength">The number of positions of the specified range.</param>
        /// <param name="originX">The origin pixel location X at the left of the layout box. This offset is added to the hit-test metrics returned.</param>
        /// <param name="originY">The origin pixel location Y at the top of the layout box. This offset is added to the hit-test metrics returned.</param>
        /// <param name="hitTestMetrics">When this method returns, contains a pointer to a buffer of the output geometry fully enclosing the specified position range.  The buffer must be at least as large as maxHitTestMetricsCount.</param>
        /// <param name="maxHitTestMetricsCount">Maximum number of boxes hitTestMetrics could hold in its buffer memory.</param>
        /// <param name="actualHitTestMetricsCount">Actual number of geometries hitTestMetrics holds in its buffer memory.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT HitTestTextRange([None] UINT32 textPosition,[None] UINT32 textLength,[None] FLOAT originX,[None] FLOAT originY,[Out, Buffer, Optional] DWRITE_HIT_TEST_METRICS* hitTestMetrics,[None] UINT32 maxHitTestMetricsCount,[Out] UINT32* actualHitTestMetricsCount)</unmanaged>
        public SlimDX2.Result HitTestTextRange(int textPosition, int textLength, float originX, float originY, SlimDX2.DirectWrite.HitTestMetrics[] hitTestMetrics, int maxHitTestMetricsCount, out int actualHitTestMetricsCount) {
            unsafe {
                SlimDX2.DirectWrite.HitTestMetrics[] hitTestMetrics__ = hitTestMetrics ?? new SlimDX2.DirectWrite.HitTestMetrics[1];
                SlimDX2.Result __result__;
                fixed (void* hitTestMetrics_ = &hitTestMetrics__[0])
                    fixed (void* actualHitTestMetricsCount_ = &actualHitTestMetricsCount)
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 66 * 4, textPosition, textLength, originX, originY, hitTestMetrics==null?(void*)IntPtr.Zero:hitTestMetrics_, maxHitTestMetricsCount, actualHitTestMetricsCount_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    ///  Encapsulates a 32-bit device independent bitmap and device context, which can be used for rendering glyphs.	
    /// </summary>	
    /// <unmanaged>IDWriteBitmapRenderTarget</unmanaged>
    [Guid("5e5a32a3-8dff-4773-9ff6-0696eab77267")]
    public partial class BitmapRenderTarget : SlimDX2.ComObject {
        public BitmapRenderTarget(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Gets a handle to the memory device context. 	
        /// </summary>	
        /// <remarks>	
        ///  An application can use the device context to draw using GDI functions. An application can obtain the bitmap handle (HBITMAP) by calling {{GetCurrentObject}}. An application that wants information about the underlying bitmap, including a pointer to the pixel data, can call {{GetObject}} to fill in a {{DIBSECTION}} structure. The bitmap is always a 32-bit  top-down DIB. Note that this method takes no parameters and returns an HDC variable, not an HRESULT.	
        /// <code> memoryHdc = g_pBitmapRenderTarget-&gt;GetMemoryDC(); </code>	
        /// 	
        /// The HDC returned here is still owned by the bitmap render targer object and should not be released or deleted by the client.	
        /// </remarks>	
        /// <unmanaged>HDC GetMemoryDC()</unmanaged>
        public IntPtr MemoryDC {
                get { return GetMemoryDC(); }
        }
        
        /// <summary>	
        ///  Gets the number of bitmap pixels per DIP.  	
        /// </summary>	
        /// <remarks>	
        /// A DIP (device-independent pixel) is 1/96 inch. Therefore, this value is the number if pixels per inch divided by 96.	
        /// </remarks>	
        /// <unmanaged>FLOAT GetPixelsPerDip()</unmanaged>
        public float PixelsPerDip {
                get { return GetPixelsPerDip(); }
                set { SetPixelsPerDip(value); }
        }
        
        /// <summary>	
        ///  Gets the transform that maps abstract coordinates to DIPs. By default this is the identity  transform. Note that this is unrelated to the world transform of the underlying device context. 	
        /// </summary>	
        /// <unmanaged>HRESULT GetCurrentTransform([Out] DWRITE_MATRIX* transform)</unmanaged>
        public SlimDX2.DirectWrite.Matrix CurrentTransform {
                get { SlimDX2.DirectWrite.Matrix __output__; GetCurrentTransform(out __output__); return __output__; }
                set { SetCurrentTransform(value); }
        }
        
        /// <summary>	
        ///  Gets the dimensions of the target bitmap. 	
        /// </summary>	
        /// <unmanaged>HRESULT GetSize([Out] SIZE* size)</unmanaged>
        public System.Drawing.Size Size {
                get { System.Drawing.Size __output__; GetSize(out __output__); return __output__; }
        }
        
        /// <summary>	
        ///  Draws a run of glyphs to a bitmap target at the specified position.	
        /// </summary>	
        /// <remarks>	
        /// You can use the IDWriteBitmapRenderTarget::DrawGlyphRun to render to a bitmap from a custom text renderer that you implement.  The custom text renderer should call this method from within the <see cref="SlimDX2.DirectWrite.TextRenderer.DrawGlyphRun"/> callback method as shown in the following code.	
        /// <code> STDMETHODIMP GdiTextRenderer::DrawGlyphRun( __maybenull void* clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, DWRITE_MEASURING_MODE measuringMode, __in DWRITE_GLYPH_RUN const* glyphRun, __in DWRITE_GLYPH_RUN_DESCRIPTION const* glyphRunDescription, IUnknown* clientDrawingEffect )	
        /// { HRESULT hr = S_OK; // Pass on the drawing call to the render target to do the real work. RECT dirtyRect = {0}; hr = pRenderTarget_-&gt;DrawGlyphRun( baselineOriginX, baselineOriginY, measuringMode, glyphRun, pRenderingParams_, RGB(0,200,255), &amp;dirtyRect ); return hr;	
        /// } </code>	
        /// 	
        /// The baselineOriginX, baslineOriginY, measuringMethod, and glyphRun parameters are provided (as arguments) when the callback method is invoked.  The renderingParams, textColor and blackBoxRect are not.Default rendering params can be retrieved by using the <see cref="SlimDX2.DirectWrite.Factory.CreateMonitorRenderingParams"/> method.	
        /// </remarks>	
        /// <param name="baselineOriginX"> The horizontal position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</param>
        /// <param name="baselineOriginY"> The vertical position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</param>
        /// <param name="measuringMode"> The measuring method for glyphs in the run, used with the other properties to determine the rendering mode.</param>
        /// <param name="glyphRun"> The structure containing the properties of the glyph run.</param>
        /// <param name="renderingParams"> The object that controls rendering behavior.</param>
        /// <param name="textColor"> The foreground color of the text.</param>
        /// <param name="blackBoxRect"> The optional rectangle that receives the bounding box (in pixels not DIPs) of all the pixels affected by  drawing the glyph run. The black box rectangle may extend beyond the dimensions of the bitmap.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT DrawGlyphRun([None] FLOAT baselineOriginX,[None] FLOAT baselineOriginY,[None] DWRITE_MEASURING_MODE measuringMode,[In] const DWRITE_GLYPH_RUN* glyphRun,[None] IDWriteRenderingParams* renderingParams,[None] COLORREF textColor,[Out, Optional] RECT* blackBoxRect)</unmanaged>
        public SlimDX2.Result DrawGlyphRun(float baselineOriginX, float baselineOriginY, SlimDX2.DirectWrite.MeasuringMode measuringMode, SlimDX2.DirectWrite.GlyphRun glyphRun, SlimDX2.DirectWrite.RenderingParams renderingParams, int textColor, out SlimDX2.RectangleF blackBoxRect) {
            unsafe {
                blackBoxRect = new SlimDX2.RectangleF();
                SlimDX2.Result __result__;
                fixed (void* blackBoxRect_ = &blackBoxRect)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4, baselineOriginX, baselineOriginY, unchecked((int)measuringMode), &glyphRun, (void*)((renderingParams == null)?IntPtr.Zero:renderingParams.NativePointer), textColor, blackBoxRect_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets a handle to the memory device context. 	
        /// </summary>	
        /// <remarks>	
        ///  An application can use the device context to draw using GDI functions. An application can obtain the bitmap handle (HBITMAP) by calling {{GetCurrentObject}}. An application that wants information about the underlying bitmap, including a pointer to the pixel data, can call {{GetObject}} to fill in a {{DIBSECTION}} structure. The bitmap is always a 32-bit  top-down DIB. Note that this method takes no parameters and returns an HDC variable, not an HRESULT.	
        /// <code> memoryHdc = g_pBitmapRenderTarget-&gt;GetMemoryDC(); </code>	
        /// 	
        /// The HDC returned here is still owned by the bitmap render targer object and should not be released or deleted by the client.	
        /// </remarks>	
        /// <returns>Returns a device context handle to the memory device context.</returns>
        /// <unmanaged>HDC GetMemoryDC()</unmanaged>
        internal IntPtr GetMemoryDC() {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the number of bitmap pixels per DIP.  	
        /// </summary>	
        /// <remarks>	
        /// A DIP (device-independent pixel) is 1/96 inch. Therefore, this value is the number if pixels per inch divided by 96.	
        /// </remarks>	
        /// <returns>The number of bitmap pixels per DIP.</returns>
        /// <unmanaged>FLOAT GetPixelsPerDip()</unmanaged>
        internal float GetPixelsPerDip() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct2D1.LocalInterop.Callifloat(_nativePointer, 5 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets the number of bitmap pixels per DIP (device-independent pixel). A DIP is 1/96 inch, so this value is the number if pixels per inch divided by 96. 	
        /// </summary>	
        /// <param name="pixelsPerDip">A value that specifies the number of pixels per DIP.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetPixelsPerDip([None] FLOAT pixelsPerDip)</unmanaged>
        internal SlimDX2.Result SetPixelsPerDip(float pixelsPerDip) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4, pixelsPerDip);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the transform that maps abstract coordinates to DIPs. By default this is the identity  transform. Note that this is unrelated to the world transform of the underlying device context. 	
        /// </summary>	
        /// <param name="transform">When this method returns, contains a transform matrix.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetCurrentTransform([Out] DWRITE_MATRIX* transform)</unmanaged>
        internal SlimDX2.Result GetCurrentTransform(out SlimDX2.DirectWrite.Matrix transform) {
            unsafe {
                transform = new SlimDX2.DirectWrite.Matrix();
                SlimDX2.Result __result__;
                fixed (void* transform_ = &transform)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 7 * 4, transform_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Sets the transform that maps abstract coordinate to DIPs (device-independent pixel). This does not affect the world transform of the underlying device context. 	
        /// </summary>	
        /// <param name="transform"> Specifies the new transform. This parameter can be NULL, in which case the identity transform is implied.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT SetCurrentTransform([In, Optional] const DWRITE_MATRIX* transform)</unmanaged>
        internal SlimDX2.Result SetCurrentTransform(SlimDX2.DirectWrite.Matrix? transform) {
            unsafe {
                SlimDX2.DirectWrite.Matrix transform_;
                if (transform.HasValue)
                    transform_ = transform.Value;				
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 8 * 4, (transform.HasValue)?&transform_:(void*)IntPtr.Zero);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the dimensions of the target bitmap. 	
        /// </summary>	
        /// <param name="size">Returns  the width and height of the bitmap in pixels.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetSize([Out] SIZE* size)</unmanaged>
        internal SlimDX2.Result GetSize(out System.Drawing.Size size) {
            unsafe {
                size = new System.Drawing.Size();
                SlimDX2.Result __result__;
                fixed (void* size_ = &size)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 9 * 4, size_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Resizes the bitmap. 	
        /// </summary>	
        /// <param name="width">The new bitmap width, in pixels.</param>
        /// <param name="height">The new bitmap height, in pixels.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT Resize([None] UINT32 width,[None] UINT32 height)</unmanaged>
        public SlimDX2.Result Resize(int width, int height) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 10 * 4, width, height);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Provides interoperability with GDI, such as methods to convert a font face to a LOGFONT structure, or to convert a GDI font description into a font face. It is also used to create bitmap render target objects.	
    /// </summary>	
    /// <unmanaged>IDWriteGdiInterop</unmanaged>
    [Guid("1edd9491-9853-4299-898f-6432983b6f3a")]
    public partial class GdiInterop : SlimDX2.ComObject {
        public GdiInterop(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Creates a font object that matches the properties specified by the LOGFONT structure. 	
        /// </summary>	
        /// <param name="logFont">A structure containing a GDI-compatible font description.</param>
        /// <param name="font">When this method returns, contains an address of a  pointer to a newly created <see cref="SlimDX2.DirectWrite.Font"/> object if successful; otherwise, NULL.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateFontFromLOGFONT([In] const LOGFONTW* logFont,[Out] IDWriteFont** font)</unmanaged>
        internal SlimDX2.Result CreateFontFromLOGFONT(ref SlimDX2.Windows.Win32.Logfontw logFont, out SlimDX2.DirectWrite.Font font) {
            unsafe {
                SlimDX2.Windows.Win32.Logfontw.__Native logFont_ = new SlimDX2.Windows.Win32.Logfontw.__Native();
                logFont.__MarshalTo(ref logFont_);
                IntPtr font_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4, &logFont_, &font_);
                logFont_.__MarshalFree();
                font = (font_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.Font(font_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Initializes a LOGFONT structure based on the GDI-compatible properties of the specified font. 	
        /// </summary>	
        /// <remarks>	
        /// The conversion to a  LOGFONT by using ConvertFontToLOGFONT operates at the logical font level and does not guarantee that it will map to a specific physical font. It is not guaranteed that GDI will select the same physical font for displaying  text formatted by a LOGFONT as the <see cref="SlimDX2.DirectWrite.Font"/> object that was converted.	
        /// </remarks>	
        /// <param name="font">An <see cref="SlimDX2.DirectWrite.Font"/> object to be converted into a GDI-compatible LOGFONT structure.</param>
        /// <param name="logFont">When this method returns, contains a structure that receives a GDI-compatible font description.</param>
        /// <param name="isSystemFont">When this method returns, contains TRUE if the specified font object is part of the system font collection; otherwise, FALSE.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ConvertFontToLOGFONT([None] IDWriteFont* font,[Out] LOGFONTW* logFont,[Out] BOOL* isSystemFont)</unmanaged>
        internal SlimDX2.Result ConvertFontToLOGFONT(SlimDX2.DirectWrite.Font font, out SlimDX2.Windows.Win32.Logfontw logFont, out bool isSystemFont) {
            unsafe {
                SlimDX2.Windows.Win32.Logfontw.__Native logFont_ = new SlimDX2.Windows.Win32.Logfontw.__Native();
                SlimDX2.Result __result__;
                fixed (void* isSystemFont_ = &isSystemFont)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)((font == null)?IntPtr.Zero:font.NativePointer), &logFont_, isSystemFont_);
                logFont = new SlimDX2.Windows.Win32.Logfontw();
                logFont.__MarshalFrom(ref logFont_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Initializes a LOGFONT structure based on the GDI-compatible properties of the specified font. 	
        /// </summary>	
        /// <remarks>	
        /// The conversion to a  LOGFONT by using ConvertFontFaceToLOGFONT operates at the logical font level and does not guarantee that it will map to a specific physical font. It is not guaranteed that GDI will select the same physical font for displaying  text formatted by a LOGFONT as the <see cref="SlimDX2.DirectWrite.Font"/> object that was converted.	
        /// </remarks>	
        /// <param name="font">An <see cref="SlimDX2.DirectWrite.FontFace"/> object to be converted into a GDI-compatible LOGFONT structure.</param>
        /// <param name="logFont">When this method returns, contains a pointer to a structure that receives a GDI-compatible font description.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ConvertFontFaceToLOGFONT([None] IDWriteFontFace* font,[Out] LOGFONTW* logFont)</unmanaged>
        internal SlimDX2.Result ConvertFontFaceToLOGFONT(SlimDX2.DirectWrite.FontFace font, out SlimDX2.Windows.Win32.Logfontw logFont) {
            unsafe {
                SlimDX2.Windows.Win32.Logfontw.__Native logFont_ = new SlimDX2.Windows.Win32.Logfontw.__Native();
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)((font == null)?IntPtr.Zero:font.NativePointer), &logFont_);
                logFont = new SlimDX2.Windows.Win32.Logfontw();
                logFont.__MarshalFrom(ref logFont_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates an IDWriteFontFace object that corresponds to the currently selected HFONT of the specified HDC. 	
        /// </summary>	
        /// <remarks>	
        /// This function is intended for scenarios in which an application wants to use GDI and Uniscribe 1.x for text layout and shaping, but  DirectWrite for final rendering. This function assumes the client is performing text output using glyph indexes.	
        /// </remarks>	
        /// <param name="hdc">A handle to a device context into which a font has been selected. It is assumed that the client has already performed font mapping and that the font selected into the device context is the actual font to be used  for rendering glyphs.</param>
        /// <param name="fontFace">Contains an address of a pointer to  the newly created font face object, or NULL in case of failure. The font face returned is guaranteed to reference the same physical typeface that would be used for drawing glyphs (but not necessarily characters) using ExtTextOut.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateFontFaceFromHdc([None] HDC hdc,[Out] IDWriteFontFace** fontFace)</unmanaged>
        public SlimDX2.Result CreateFontFaceFromHdc(IntPtr hdc, out SlimDX2.DirectWrite.FontFace fontFace) {
            unsafe {
                IntPtr fontFace_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)hdc, &fontFace_);
                fontFace = (fontFace_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontFace(fontFace_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates an object that encapsulates a bitmap and memory DC (device context) which can be used for rendering glyphs. 	
        /// </summary>	
        /// <param name="hdc">A handle to the optional device context used to create a compatible memory DC (device context).</param>
        /// <param name="width">The width of the bitmap render target.</param>
        /// <param name="height">The height of the bitmap render target.</param>
        /// <param name="renderTarget">When this method returns, contains an address of a pointer to the newly created <see cref="SlimDX2.DirectWrite.BitmapRenderTarget"/> object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateBitmapRenderTarget([In, Optional] HDC hdc,[None] UINT32 width,[None] UINT32 height,[Out] IDWriteBitmapRenderTarget** renderTarget)</unmanaged>
        public SlimDX2.Result CreateBitmapRenderTarget(IntPtr hdc, int width, int height, out SlimDX2.DirectWrite.BitmapRenderTarget renderTarget) {
            unsafe {
                IntPtr renderTarget_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)hdc, width, height, &renderTarget_);
                renderTarget = (renderTarget_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.BitmapRenderTarget(renderTarget_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    ///  Contains low-level information used to render a glyph run.	
    /// </summary>	
    /// <unmanaged>IDWriteGlyphRunAnalysis</unmanaged>
    [Guid("7d97dbf7-e085-42d4-81e3-6a883bded118")]
    public partial class GlyphRunAnalysis : SlimDX2.ComObject {
        public GlyphRunAnalysis(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Gets the bounding rectangle of the physical pixels affected by the glyph run. 	
        /// </summary>	
        /// <param name="textureType">Specifies the type of texture requested. If a bi-level texture is requested, the bounding rectangle includes only bi-level glyphs. Otherwise, the bounding rectangle includes only antialiased glyphs.</param>
        /// <param name="textureBounds">When this method returns, contains the bounding rectangle of the physical pixels affected by the glyph run, or an empty rectangle if there are no glyphs of the specified texture type.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetAlphaTextureBounds([None] DWRITE_TEXTURE_TYPE textureType,[Out] RECT* textureBounds)</unmanaged>
        public SlimDX2.Result GetAlphaTextureBounds(SlimDX2.DirectWrite.TextureType textureType, out SlimDX2.RectangleF textureBounds) {
            unsafe {
                textureBounds = new SlimDX2.RectangleF();
                SlimDX2.Result __result__;
                fixed (void* textureBounds_ = &textureBounds)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4, unchecked((int)textureType), textureBounds_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates an alpha texture of the specified type for glyphs within a specified bounding rectangle. 	
        /// </summary>	
        /// <param name="textureType">A value that specifies the type of texture requested. This can be {{DWRITE_TEXTURE_BILEVEL_1x1}} or DWRITE_TEXTURE_CLEARTYPE_3x1. If a bi-level texture is requested, the texture contains only bi-level glyphs. Otherwise, the texture contains only antialiased glyphs.</param>
        /// <param name="textureBounds">The bounding rectangle of the texture, which can be different than the bounding rectangle returned by {{GetAlphaTextureBounds}}.</param>
        /// <param name="alphaValues">When this method returns, contains  the array of alpha values from the texture. The buffer allocated for this array must be at least the size of bufferSize.</param>
        /// <param name="bufferSize">The size of the alphaValues array, in bytes. The minimum size depends on the dimensions of the rectangle and the type of texture requested.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateAlphaTexture([None] DWRITE_TEXTURE_TYPE textureType,[In] const RECT* textureBounds,[Out, Buffer] BYTE* alphaValues,[None] UINT32 bufferSize)</unmanaged>
        public SlimDX2.Result CreateAlphaTexture(SlimDX2.DirectWrite.TextureType textureType, SlimDX2.RectangleF textureBounds, byte[] alphaValues, int bufferSize) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* alphaValues_ = &alphaValues[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, unchecked((int)textureType), &textureBounds, alphaValues_, bufferSize);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets alpha blending properties required for ClearType blending. 	
        /// </summary>	
        /// <param name="renderingParams">An object that specifies the ClearType level and enhanced contrast, gamma, pixel geometry, and rendering mode. In most cases, the values returned by the output parameters of this method are based on the properties of this object, unless a GDI-compatible rendering mode was specified.</param>
        /// <param name="blendGamma">When this method returns, contains  the gamma value to use for gamma correction.</param>
        /// <param name="blendEnhancedContrast">When this method returns, contains the enhanced contrast value to be used for blending.</param>
        /// <param name="blendClearTypeLevel">When this method returns, contains  the ClearType level used in the alpha blending.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetAlphaBlendParams([None] IDWriteRenderingParams* renderingParams,[Out] FLOAT* blendGamma,[Out] FLOAT* blendEnhancedContrast,[Out] FLOAT* blendClearTypeLevel)</unmanaged>
        public SlimDX2.Result GetAlphaBlendParams(SlimDX2.DirectWrite.RenderingParams renderingParams, out float blendGamma, out float blendEnhancedContrast, out float blendClearTypeLevel) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* blendGamma_ = &blendGamma)
                    fixed (void* blendEnhancedContrast_ = &blendEnhancedContrast)
                        fixed (void* blendClearTypeLevel_ = &blendClearTypeLevel)
                            __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)((renderingParams == null)?IntPtr.Zero:renderingParams.NativePointer), blendGamma_, blendEnhancedContrast_, blendClearTypeLevel_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Used to create all subsequent DirectWrite objects. This interface is the root factory interface for all DirectWrite objects.	
    /// </summary>	
    /// <unmanaged>IDWriteFactory</unmanaged>
    [Guid("b859ee5a-d838-4b5b-a2e8-1adc7d93db48")]
    public partial class Factory : SlimDX2.ComObject {
        public Factory(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Creates an object that is used for interoperability with GDI. 	
        /// </summary>	
        /// <unmanaged>HRESULT GetGdiInterop([Out] IDWriteGdiInterop** gdiInterop)</unmanaged>
        public SlimDX2.DirectWrite.GdiInterop GdiInterop {
                get { SlimDX2.DirectWrite.GdiInterop __output__; GetGdiInterop(out __output__); return __output__; }
        }
        
        /// <summary>	
        ///  Gets an object which represents the set of installed fonts. 	
        /// </summary>	
        /// <param name="fontCollection">When this method returns, contains the address of a pointer to the system font collection object, or NULL in case of failure.</param>
        /// <param name="checkForUpdates">If this parameter is nonzero, the function performs an immediate check for changes to the set of installed fonts. If this parameter is FALSE, the function will still detect changes if the font cache service is running, but there may be some latency. For example, an application might specify TRUE if it has itself just installed a font and wants to  be sure the font collection contains that font.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetSystemFontCollection([Out] IDWriteFontCollection** fontCollection,[None] BOOL checkForUpdates)</unmanaged>
        public SlimDX2.Result GetSystemFontCollection(out SlimDX2.DirectWrite.FontCollection fontCollection, bool checkForUpdates) {
            unsafe {
                IntPtr fontCollection_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4, &fontCollection_, (checkForUpdates?1:0));
                fontCollection = (fontCollection_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontCollection(fontCollection_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates a font collection using a custom font collection loader. 	
        /// </summary>	
        /// <param name="collectionLoader">An application-defined font collection loader, which must have been previously registered using {{RegisterFontCollectionLoader}}.</param>
        /// <param name="collectionKey">The key used by the loader to identify a collection of font files.  The buffer allocated for this key should at least be the size of collectionKeySize.</param>
        /// <param name="collectionKeySize">The size, in bytes, of the collection key.</param>
        /// <param name="fontCollection">Contains  an address of a pointer to the system font collection object if the method succeeds, or NULL in case of failure.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateCustomFontCollection([None] IDWriteFontCollectionLoader* collectionLoader,[In, Buffer] const void* collectionKey,[None] UINT32 collectionKeySize,[Out] IDWriteFontCollection** fontCollection)</unmanaged>
        public SlimDX2.Result CreateCustomFontCollection(SlimDX2.DirectWrite.FontCollectionLoader collectionLoader, IntPtr collectionKey, int collectionKeySize, out SlimDX2.DirectWrite.FontCollection fontCollection) {
            unsafe {
                IntPtr fontCollection_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, (void*)((collectionLoader == null)?IntPtr.Zero:collectionLoader.NativePointer), (void*)collectionKey, collectionKeySize, &fontCollection_);
                fontCollection = (fontCollection_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontCollection(fontCollection_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Registers a custom font collection loader with the factory object. 	
        /// </summary>	
        /// <remarks>	
        /// This function registers a font collection loader with DirectWrite. The font collection loader interface, which should be implemented by a singleton object, handles enumerating font files in a font collection given a particular type of key. A given instance can only be registered once. Succeeding attempts will return an error, indicating that it has already been registered. Note that font file loader implementations must not register themselves with DirectWrite inside their constructors, and must not unregister themselves inside their destructors, because registration and unregistraton operations increment and decrement the object reference count respectively. Instead, registration and unregistration with DirectWrite of font file loaders should be performed outside of the font file loader implementation.	
        /// </remarks>	
        /// <param name="fontCollectionLoader">Pointer to a <see cref="SlimDX2.DirectWrite.FontCollectionLoader"/> object to be registered.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT RegisterFontCollectionLoader([None] IDWriteFontCollectionLoader* fontCollectionLoader)</unmanaged>
        public SlimDX2.Result RegisterFontCollectionLoader(SlimDX2.DirectWrite.FontCollectionLoader fontCollectionLoader) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4, (void*)((fontCollectionLoader == null)?IntPtr.Zero:fontCollectionLoader.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Unregisters a custom font collection loader that was previously registered using {{RegisterFontCollectionLoader}}. 	
        /// </summary>	
        /// <param name="fontCollectionLoader">Pointer to a <see cref="SlimDX2.DirectWrite.FontCollectionLoader"/> object to be unregistered.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT UnregisterFontCollectionLoader([None] IDWriteFontCollectionLoader* fontCollectionLoader)</unmanaged>
        public SlimDX2.Result UnregisterFontCollectionLoader(SlimDX2.DirectWrite.FontCollectionLoader fontCollectionLoader) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4, (void*)((fontCollectionLoader == null)?IntPtr.Zero:fontCollectionLoader.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates a font file reference object from a local font file. 	
        /// </summary>	
        /// <param name="filePath">An array of characters that contains the absolute file path for the font file. Subsequent operations on the constructed object may fail if the user provided filePath doesn't correspond to a valid file on the disk.</param>
        /// <param name="lastWriteTime">The last modified time of the input file path. If the parameter is omitted, the function will access the font file to obtain its last write time. You should specify this value to avoid extra disk access. Subsequent operations on the constructed object may fail if the user provided lastWriteTime doesn't match the file on the disk.</param>
        /// <param name="fontFile">When this method returns, contains an address of a pointer to the newly created font file reference object, or NULL in case of failure.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateFontFileReference([In] const wchar* filePath,[In, Optional] const FILETIME* lastWriteTime,[Out] IDWriteFontFile** fontFile)</unmanaged>
        public SlimDX2.Result CreateFontFileReference(string filePath, long? lastWriteTime, out SlimDX2.DirectWrite.FontFile fontFile) {
            unsafe {
                IntPtr filePath_ = Marshal.StringToHGlobalUni(filePath);
                long lastWriteTime_;
                if (lastWriteTime.HasValue)
                    lastWriteTime_ = lastWriteTime.Value;				
                IntPtr fontFile_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)filePath_, (lastWriteTime.HasValue)?&lastWriteTime_:(void*)IntPtr.Zero, &fontFile_);
                Marshal.FreeHGlobal(filePath_ );
                fontFile = (fontFile_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontFile(fontFile_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates a reference to an application-specific font file resource. 	
        /// </summary>	
        /// <remarks>	
        ///  This function is provided for cases when an application or a document needs to use a private font without having to install it on the system. fontFileReferenceKey has to be unique only in the scope of the fontFileLoader used in this call. 	
        /// </remarks>	
        /// <param name="fontFileReferenceKey">A font file reference key that uniquely identifies the font file resource during the lifetime of fontFileLoader.</param>
        /// <param name="fontFileReferenceKeySize">The size of the font file reference key in bytes.</param>
        /// <param name="fontFileLoader">The font file loader that will be used by the font system to load data from the file identified by fontFileReferenceKey.</param>
        /// <param name="fontFile">Contains an address of a pointer to the newly created font file object when this method succeeds, or NULL in case of failure.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateCustomFontFileReference([In, Buffer] const void* fontFileReferenceKey,[None] UINT32 fontFileReferenceKeySize,[None] IDWriteFontFileLoader* fontFileLoader,[Out] IDWriteFontFile** fontFile)</unmanaged>
        public SlimDX2.Result CreateCustomFontFileReference(IntPtr fontFileReferenceKey, int fontFileReferenceKeySize, SlimDX2.DirectWrite.FontFileLoader fontFileLoader, out SlimDX2.DirectWrite.FontFile fontFile) {
            unsafe {
                IntPtr fontFile_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 8 * 4, (void*)fontFileReferenceKey, fontFileReferenceKeySize, (void*)((fontFileLoader == null)?IntPtr.Zero:fontFileLoader.NativePointer), &fontFile_);
                fontFile = (fontFile_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontFile(fontFile_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates an object that represents a font face. 	
        /// </summary>	
        /// <param name="fontFaceType">A value that indicates the type of file format of the font face.</param>
        /// <param name="numberOfFiles">The number of font files, in element count, required to represent the font face.</param>
        /// <param name="fontFiles">A font file object representing the font face. Because<see cref="SlimDX2.DirectWrite.FontFace"/> maintains its own references to the input font file objects, you may release them after this call.</param>
        /// <param name="faceIndex">The zero-based index of a font face, in cases when the font files contain a collection of font faces. If the font files contain a single face, this value should be zero.</param>
        /// <param name="fontFaceSimulationFlags">A value that indicates which, if any, font face simulation flags for algorithmic means of making text bold or italic are applied to the current font face.</param>
        /// <param name="fontFace">When this method returns, contains an address of a pointer to the newly created font face object, or NULL in case of failure.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateFontFace([None] DWRITE_FONT_FACE_TYPE fontFaceType,[None] UINT32 numberOfFiles,[In, Buffer] const IDWriteFontFile** fontFiles,[None] UINT32 faceIndex,[None] DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,[Out] IDWriteFontFace** fontFace)</unmanaged>
        public SlimDX2.Result CreateFontFace(SlimDX2.DirectWrite.FontFaceType fontFaceType, int numberOfFiles, SlimDX2.DirectWrite.FontFile[] fontFiles, int faceIndex, SlimDX2.DirectWrite.FontSimulations fontFaceSimulationFlags, out SlimDX2.DirectWrite.FontFace fontFace) {
            unsafe {
                IntPtr* fontFiles_ = (IntPtr*)0;
                if ( fontFiles != null ) {
                    IntPtr* fontFiles__ = stackalloc IntPtr[fontFiles.Length];
                    fontFiles_ = fontFiles__;
                    for (int i = 0; i < fontFiles.Length; i++)                        
                        fontFiles_[i] =  fontFiles[i].NativePointer;
                }
                IntPtr fontFace_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 9 * 4, unchecked((int)fontFaceType), numberOfFiles, fontFiles_, faceIndex, unchecked((int)fontFaceSimulationFlags), &fontFace_);
                fontFace = (fontFace_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.FontFace(fontFace_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates a rendering parameters object with default settings for the primary monitor. Different monitors may have different rendering parameters, for more information see the {{How to Add Support for Multiple Monitors}} topic.	
        /// </summary>	
        /// <param name="renderingParams">When this method returns, contains an address of a pointer to the newly created  rendering parameters object.</param>
        /// <returns>Standard HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateRenderingParams([Out] IDWriteRenderingParams** renderingParams)</unmanaged>
        public SlimDX2.Result CreateRenderingParams(out SlimDX2.DirectWrite.RenderingParams renderingParams) {
            unsafe {
                IntPtr renderingParams_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 10 * 4, &renderingParams_);
                renderingParams = (renderingParams_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.RenderingParams(renderingParams_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates a rendering parameters object with default settings for the specified monitor. In most cases, this is the preferred way to create a rendering parameters object.	
        /// </summary>	
        /// <param name="monitor">A handle for the specified monitor.</param>
        /// <param name="renderingParams">When this method returns, contains an address of a pointer to the rendering parameters object created by this method.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateMonitorRenderingParams([None] HMONITOR monitor,[Out] IDWriteRenderingParams** renderingParams)</unmanaged>
        public SlimDX2.Result CreateMonitorRenderingParams(IntPtr monitor, out SlimDX2.DirectWrite.RenderingParams renderingParams) {
            unsafe {
                IntPtr renderingParams_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 11 * 4, (void*)monitor, &renderingParams_);
                renderingParams = (renderingParams_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.RenderingParams(renderingParams_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates a rendering parameters object with the specified properties. 	
        /// </summary>	
        /// <param name="gamma">The gamma level to be set for the new rendering parameters object.</param>
        /// <param name="enhancedContrast">The enhanced contrast level to be set for the new rendering parameters object.</param>
        /// <param name="clearTypeLevel">The ClearType level to be set for the new rendering parameters object.</param>
        /// <param name="pixelGeometry">Represents the internal structure of a device pixel (that is, the physical arrangement of red, green, and blue color components) that is assumed for purposes of rendering text.</param>
        /// <param name="renderingMode">A value that represents the method (for example, ClearType natural quality) for rendering glyphs.</param>
        /// <param name="renderingParams">When this method returns, contains an address of a pointer to the newly created rendering parameters object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateCustomRenderingParams([None] FLOAT gamma,[None] FLOAT enhancedContrast,[None] FLOAT clearTypeLevel,[None] DWRITE_PIXEL_GEOMETRY pixelGeometry,[None] DWRITE_RENDERING_MODE renderingMode,[Out] IDWriteRenderingParams** renderingParams)</unmanaged>
        public SlimDX2.Result CreateCustomRenderingParams(float gamma, float enhancedContrast, float clearTypeLevel, SlimDX2.DirectWrite.PixelGeometry pixelGeometry, SlimDX2.DirectWrite.RenderingMode renderingMode, out SlimDX2.DirectWrite.RenderingParams renderingParams) {
            unsafe {
                IntPtr renderingParams_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 12 * 4, gamma, enhancedContrast, clearTypeLevel, unchecked((int)pixelGeometry), unchecked((int)renderingMode), &renderingParams_);
                renderingParams = (renderingParams_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.RenderingParams(renderingParams_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Registers a font file loader with DirectWrite. 	
        /// </summary>	
        /// <remarks>	
        ///  This function registers a font file loader with DirectWrite. The font file loader interface, which should be implemented   by a singleton object, handles loading font file resources of a particular type from a key. A given instance can only be registered once. Succeeding attempts will return an error, indicating that it has already been registered. Note that font file loader implementations must not register themselves with DirectWrite inside their constructors, and must not unregister themselves inside their destructors, because registration and unregistraton operations increment and decrement the object reference count respectively. Instead, registration and unregistration with DirectWrite of font file loaders should be performed outside of the font file loader implementation. 	
        /// </remarks>	
        /// <param name="fontFileLoader">Pointer to a <see cref="SlimDX2.DirectWrite.FontFileLoader"/> object for a particular file resource type.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT RegisterFontFileLoader([None] IDWriteFontFileLoader* fontFileLoader)</unmanaged>
        public SlimDX2.Result RegisterFontFileLoader(SlimDX2.DirectWrite.FontFileLoader fontFileLoader) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 13 * 4, (void*)((fontFileLoader == null)?IntPtr.Zero:fontFileLoader.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Unregisters a font file loader that was previously registered with the DirectWrite font system using {{RegisterFontFileLoader}}. 	
        /// </summary>	
        /// <remarks>	
        ///  This function unregisters font file loader callbacks with the DirectWrite font system. You should implement the font file loader interface by a singleton object. Note that font file loader implementations must not register themselves with DirectWrite inside their constructors and must not unregister themselves in their destructors, because registration and unregistraton operations increment and decrement the object reference count respectively. Instead, registration and unregistration of font file loaders with DirectWrite should be performed outside of the font file loader implementation. 	
        /// </remarks>	
        /// <param name="fontFileLoader">Pointer to the file loader that was previously registered with the DirectWrite font system using {{RegisterFontFileLoader}}.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT UnregisterFontFileLoader([None] IDWriteFontFileLoader* fontFileLoader)</unmanaged>
        public SlimDX2.Result UnregisterFontFileLoader(SlimDX2.DirectWrite.FontFileLoader fontFileLoader) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 14 * 4, (void*)((fontFileLoader == null)?IntPtr.Zero:fontFileLoader.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates a text format object used for text layout. 	
        /// </summary>	
        /// <param name="fontFamilyName">An array of characters that contains the name of the font family</param>
        /// <param name="fontCollection">A pointer to a font collection object. When this is NULL, indicates the system font collection.</param>
        /// <param name="fontWeight">A value that indicates the font weight for the text object created by this method.</param>
        /// <param name="fontStyle">A value that indicates the font style for the text object created by this method.</param>
        /// <param name="fontStretch">A value that indicates the font stretch for the text object created by this method.</param>
        /// <param name="fontSize">The logical size of the font in DIP ("device-independent pixel") units. A DIP equals 1/96 inch.</param>
        /// <param name="localeName">An array of characters that contains the locale name.</param>
        /// <param name="textFormat">When this method returns, contains an address of a pointer to a  newly created text format object, or NULL in case of failure.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateTextFormat([In] const wchar* fontFamilyName,[None] IDWriteFontCollection* fontCollection,[None] DWRITE_FONT_WEIGHT fontWeight,[None] DWRITE_FONT_STYLE fontStyle,[None] DWRITE_FONT_STRETCH fontStretch,[None] FLOAT fontSize,[In] const wchar* localeName,[Out] IDWriteTextFormat** textFormat)</unmanaged>
        public SlimDX2.Result CreateTextFormat(string fontFamilyName, SlimDX2.DirectWrite.FontCollection fontCollection, SlimDX2.DirectWrite.FontWeight fontWeight, SlimDX2.DirectWrite.FontStyle fontStyle, SlimDX2.DirectWrite.FontStretch fontStretch, float fontSize, string localeName, out SlimDX2.DirectWrite.TextFormat textFormat) {
            unsafe {
                IntPtr fontFamilyName_ = Marshal.StringToHGlobalUni(fontFamilyName);
                IntPtr localeName_ = Marshal.StringToHGlobalUni(localeName);
                IntPtr textFormat_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 15 * 4, (void*)fontFamilyName_, (void*)((fontCollection == null)?IntPtr.Zero:fontCollection.NativePointer), unchecked((int)fontWeight), unchecked((int)fontStyle), unchecked((int)fontStretch), fontSize, (void*)localeName_, &textFormat_);
                Marshal.FreeHGlobal(fontFamilyName_ );
                Marshal.FreeHGlobal(localeName_ );
                textFormat = (textFormat_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.TextFormat(textFormat_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates a typography object for use in a text layout. 	
        /// </summary>	
        /// <param name="typography">When this method returns, contains the address of  a pointer to a newly created typography object, or NULL in case of failure.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateTypography([Out] IDWriteTypography** typography)</unmanaged>
        public SlimDX2.Result CreateTypography(out SlimDX2.DirectWrite.Typography typography) {
            unsafe {
                IntPtr typography_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 16 * 4, &typography_);
                typography = (typography_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.Typography(typography_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates an object that is used for interoperability with GDI. 	
        /// </summary>	
        /// <param name="gdiInterop">When this method returns, contains an address of a pointer to a GDI interop object if successful, or NULL in case of failure.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT GetGdiInterop([Out] IDWriteGdiInterop** gdiInterop)</unmanaged>
        internal SlimDX2.Result GetGdiInterop(out SlimDX2.DirectWrite.GdiInterop gdiInterop) {
            unsafe {
                IntPtr gdiInterop_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 17 * 4, &gdiInterop_);
                gdiInterop = (gdiInterop_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.GdiInterop(gdiInterop_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Takes a string, text format, and associated constraints, and produces an object that represents the fully analyzed and formatted result. 	
        /// </summary>	
        /// <param name="@string">An array of characters that contains the string to create a new <see cref="SlimDX2.DirectWrite.TextLayout"/> object from. This array must be of length stringLength and can contain embedded NULL characters.</param>
        /// <param name="stringLength">The number of characters in  the string.</param>
        /// <param name="textFormat">A pointer to an object that indicates the format to apply to the string.</param>
        /// <param name="maxWidth">The width of the layout box.</param>
        /// <param name="maxHeight">The height of the layout box.</param>
        /// <param name="textLayout">When this method returns, contains an address of a pointer to the resultant text layout object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateTextLayout([In, Buffer] const wchar* string,[None] UINT32 stringLength,[None] IDWriteTextFormat* textFormat,[None] FLOAT maxWidth,[None] FLOAT maxHeight,[Out] IDWriteTextLayout** textLayout)</unmanaged>
        public SlimDX2.Result CreateTextLayout(string @string, int stringLength, SlimDX2.DirectWrite.TextFormat textFormat, float maxWidth, float maxHeight, out SlimDX2.DirectWrite.TextLayout textLayout) {
            unsafe {
                IntPtr @string_ = Marshal.StringToHGlobalUni(@string);
                IntPtr textLayout_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 18 * 4, (void*)@string_, stringLength, (void*)((textFormat == null)?IntPtr.Zero:textFormat.NativePointer), maxWidth, maxHeight, &textLayout_);
                Marshal.FreeHGlobal(@string_ );
                textLayout = (textLayout_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.TextLayout(textLayout_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Takes a string, format, and associated constraints, and produces an object representing the result, formatted for a particular display resolution and measuring mode.  	
        /// </summary>	
        /// <remarks>	
        /// The resulting text layout should only be used for the intended resolution, and for cases where text scalability is desired {{CreateTextLayout}} should be used instead.	
        /// </remarks>	
        /// <param name="@string">An array of characters that contains the string to create a new <see cref="SlimDX2.DirectWrite.TextLayout"/> object from. This array must be of length stringLength and can contain embedded NULL characters.</param>
        /// <param name="stringLength">The length of the string, in character count.</param>
        /// <param name="textFormat">The text formatting object to apply to the string.</param>
        /// <param name="layoutWidth">The width of the layout box.</param>
        /// <param name="layoutHeight">The height of the layout box.</param>
        /// <param name="pixelsPerDip">The number of physical pixels per DIP (device independent pixel). For example, if rendering onto a 96 DPI device pixelsPerDip is 1. If rendering onto a 120 DPI device pixelsPerDip is 1.25 (120/96).</param>
        /// <param name="transform">An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specifies the font size and pixels per DIP.</param>
        /// <param name="useGdiNatural"> Instructs the text layout to use the same metrics as GDI bi-level text when set to FALSE. When set to TRUE, instructs the text layout to use the same metrics as text measured by GDI using a font created with CLEARTYPE_NATURAL_QUALITY. </param>
        /// <param name="textLayout">When this method returns, contains an address to the pointer of the resultant text layout object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateGdiCompatibleTextLayout([In, Buffer] const wchar* string,[None] UINT32 stringLength,[None] IDWriteTextFormat* textFormat,[None] FLOAT layoutWidth,[None] FLOAT layoutHeight,[None] FLOAT pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[None] BOOL useGdiNatural,[Out] IDWriteTextLayout** textLayout)</unmanaged>
        public SlimDX2.Result CreateGdiCompatibleTextLayout(string @string, int stringLength, SlimDX2.DirectWrite.TextFormat textFormat, float layoutWidth, float layoutHeight, float pixelsPerDip, SlimDX2.DirectWrite.Matrix? transform, bool useGdiNatural, out SlimDX2.DirectWrite.TextLayout textLayout) {
            unsafe {
                IntPtr @string_ = Marshal.StringToHGlobalUni(@string);
                SlimDX2.DirectWrite.Matrix transform_;
                if (transform.HasValue)
                    transform_ = transform.Value;				
                IntPtr textLayout_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 19 * 4, (void*)@string_, stringLength, (void*)((textFormat == null)?IntPtr.Zero:textFormat.NativePointer), layoutWidth, layoutHeight, pixelsPerDip, (transform.HasValue)?&transform_:(void*)IntPtr.Zero, (useGdiNatural?1:0), &textLayout_);
                Marshal.FreeHGlobal(@string_ );
                textLayout = (textLayout_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.TextLayout(textLayout_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates an inline object for trimming, using an ellipsis as the omission sign. 	
        /// </summary>	
        /// <remarks>	
        /// The ellipsis will be created using the current settings of the format, including base font, style, and any effects. Alternate omission signs can be created by the application by implementing <see cref="SlimDX2.DirectWrite.InlineObject"/>. 	
        /// </remarks>	
        /// <param name="textFormat">A text format object, created with {{CreateTextFormat}}, used for text layout.</param>
        /// <param name="trimmingSign">When this method returns, contains an address of a pointer to the omission (that is, ellipsis trimming) sign created by this method.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateEllipsisTrimmingSign([None] IDWriteTextFormat* textFormat,[Out] IDWriteInlineObject** trimmingSign)</unmanaged>
        public SlimDX2.Result CreateEllipsisTrimmingSign(SlimDX2.DirectWrite.TextFormat textFormat, out SlimDX2.DirectWrite.InlineObject trimmingSign) {
            unsafe {
                IntPtr trimmingSign_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 20 * 4, (void*)((textFormat == null)?IntPtr.Zero:textFormat.NativePointer), &trimmingSign_);
                trimmingSign = (trimmingSign_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.InlineObject(trimmingSign_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Returns an interface for performing text analysis. 	
        /// </summary>	
        /// <param name="textAnalyzer">When this method returns, contains an address of  a pointer to the newly created text analyzer object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateTextAnalyzer([Out] IDWriteTextAnalyzer** textAnalyzer)</unmanaged>
        public SlimDX2.Result CreateTextAnalyzer(out SlimDX2.DirectWrite.TextAnalyzer textAnalyzer) {
            unsafe {
                IntPtr textAnalyzer_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 21 * 4, &textAnalyzer_);
                textAnalyzer = (textAnalyzer_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.TextAnalyzer(textAnalyzer_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates a number substitution object using a locale name, substitution method, and an indicator  whether to ignore user overrides (use NLS defaults for the given culture instead). 	
        /// </summary>	
        /// <param name="substitutionMethod">A value that specifies how to apply number substitution on digits and related punctuation.</param>
        /// <param name="localeName">The name of the locale to be used in the numberSubstitution object.</param>
        /// <param name="ignoreUserOverride">A Boolean flag that indicates whether to ignore user overrides.</param>
        /// <param name="numberSubstitution">When this method returns, contains an address to  a pointer to the number substitution object created by this method.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateNumberSubstitution([In] DWRITE_NUMBER_SUBSTITUTION_METHOD substitutionMethod,[In] const wchar* localeName,[In] BOOL ignoreUserOverride,[Out] IDWriteNumberSubstitution** numberSubstitution)</unmanaged>
        public SlimDX2.Result CreateNumberSubstitution(SlimDX2.DirectWrite.NumberSubstitutionMethod substitutionMethod, string localeName, bool ignoreUserOverride, out SlimDX2.DirectWrite.NumberSubstitution numberSubstitution) {
            unsafe {
                IntPtr localeName_ = Marshal.StringToHGlobalUni(localeName);
                IntPtr numberSubstitution_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 22 * 4, unchecked((int)substitutionMethod), (void*)localeName_, (ignoreUserOverride?1:0), &numberSubstitution_);
                Marshal.FreeHGlobal(localeName_ );
                numberSubstitution = (numberSubstitution_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.NumberSubstitution(numberSubstitution_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates a glyph run analysis object, which encapsulates information used to render a glyph run. 	
        /// </summary>	
        /// <remarks>	
        /// The glyph run analysis object contains the results of analyzing the glyph run, including the positions of all the glyphs and references to all of the rasterized glyphs in the font cache. 	
        /// </remarks>	
        /// <param name="glyphRun">A structure that contains the properties of the glyph run (font face, advances, and so on).</param>
        /// <param name="pixelsPerDip">Number of physical pixels per DIP (device independent pixel). For example, if rendering onto a 96 DPI bitmap then pixelsPerDip is 1. If rendering onto a 120 DPI bitmap then pixelsPerDip is 1.25.</param>
        /// <param name="transform">Optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified the emSize and pixelsPerDip.</param>
        /// <param name="renderingMode">A value that specifies the rendering mode, which must be one of the raster rendering modes (that is, not default and not outline).</param>
        /// <param name="measuringMode">Specifies the measuring mode to use with glyphs.</param>
        /// <param name="baselineOriginX">The horizontal position (X-coordinate) of the baseline origin, in DIPs.</param>
        /// <param name="baselineOriginY">Vertical position (Y-coordinate) of the baseline origin, in DIPs.</param>
        /// <param name="glyphRunAnalysis">When this method returns, contains an address of a pointer to the newly created glyph run analysis object.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT CreateGlyphRunAnalysis([In] const DWRITE_GLYPH_RUN* glyphRun,[None] FLOAT pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[None] DWRITE_RENDERING_MODE renderingMode,[None] DWRITE_MEASURING_MODE measuringMode,[None] FLOAT baselineOriginX,[None] FLOAT baselineOriginY,[Out] IDWriteGlyphRunAnalysis** glyphRunAnalysis)</unmanaged>
        public SlimDX2.Result CreateGlyphRunAnalysis(SlimDX2.DirectWrite.GlyphRun glyphRun, float pixelsPerDip, SlimDX2.DirectWrite.Matrix? transform, SlimDX2.DirectWrite.RenderingMode renderingMode, SlimDX2.DirectWrite.MeasuringMode measuringMode, float baselineOriginX, float baselineOriginY, out SlimDX2.DirectWrite.GlyphRunAnalysis glyphRunAnalysis) {
            unsafe {
                SlimDX2.DirectWrite.Matrix transform_;
                if (transform.HasValue)
                    transform_ = transform.Value;				
                IntPtr glyphRunAnalysis_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 23 * 4, &glyphRun, pixelsPerDip, (transform.HasValue)?&transform_:(void*)IntPtr.Zero, unchecked((int)renderingMode), unchecked((int)measuringMode), baselineOriginX, baselineOriginY, &glyphRunAnalysis_);
                glyphRunAnalysis = (glyphRunAnalysis_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.GlyphRunAnalysis(glyphRunAnalysis_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
}
