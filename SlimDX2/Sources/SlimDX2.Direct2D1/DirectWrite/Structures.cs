// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Structs for SlimDX2.DirectWrite namespace.
//     This code was generated by a tool.
//     Date : 11/09/2010 12:36:29
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace SlimDX2.DirectWrite {

    
    /// <summary>	
    /// The DWRITE_FONT_METRICS structure specifies the metrics that are applicable to all glyphs within the font face.	
    /// </summary>	
    /// <unmanaged>DWRITE_FONT_METRICS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct FontMetrics {	
        
        /// <summary>	
        /// The number of font design units per em unit. Font files use their own coordinate system of font design units. A font design unit is the smallest measurable unit in the em square, an imaginary square that is used to size and align glyphs. The concept of em square is used as a reference scale factor when defining font size and device transformation semantics. The size of one em square is also commonly used to compute the paragraph identation value.	
        /// </summary>	
        /// <unmanaged>UINT16 designUnitsPerEm</unmanaged>
        public short DesignUnitsPerEm;
        
        /// <summary>	
        /// The ascent value of the font face in font design units. Ascent is the distance from the top of font character alignment box to the English baseline.	
        /// </summary>	
        /// <unmanaged>UINT16 ascent</unmanaged>
        public short Ascent;
        
        /// <summary>	
        /// The descent value of the font face in font design units. Descent is the distance from the bottom of font character alignment box to the English baseline.	
        /// </summary>	
        /// <unmanaged>UINT16 descent</unmanaged>
        public short Descent;
        
        /// <summary>	
        /// The line gap in font design units. Recommended additional white space to add between lines to improve legibility. The recommended line spacing (baseline-to-baseline distance) is  the sum of ascent, descent, and lineGap. The line gap is usually positive or zero but can be negative, in which case the recommended line spacing is less than the height of the character alignment box.	
        /// </summary>	
        /// <unmanaged>INT16 lineGap</unmanaged>
        public short LineGap;
        
        /// <summary>	
        /// The cap height value of the font face in font design units. Cap height is the distance from the English baseline to the top of a typical English capital. Capital "H" is often used as a reference character for the purpose of calculating the cap height value.	
        /// </summary>	
        /// <unmanaged>UINT16 capHeight</unmanaged>
        public short CapHeight;
        
        /// <summary>	
        /// The x-height value of the font face in font design units. x-height is the distance from the English baseline to the top of lowercase letter "x", or a similar lowercase character.	
        /// </summary>	
        /// <unmanaged>UINT16 xHeight</unmanaged>
        public short XHeight;
        
        /// <summary>	
        /// The underline position value of the font face in font design units. Underline position is the position of underline relative to the English baseline. The value is usually made negative in order to place the underline below the baseline.	
        /// </summary>	
        /// <unmanaged>INT16 underlinePosition</unmanaged>
        public short UnderlinePosition;
        
        /// <summary>	
        /// The suggested underline thickness value of the font face in font design units.	
        /// </summary>	
        /// <unmanaged>UINT16 underlineThickness</unmanaged>
        public short UnderlineThickness;
        
        /// <summary>	
        /// The strikethrough position value of the font face in font design units. Strikethrough position is the position of strikethrough relative to the English baseline. The value is usually made positive in order to place the strikethrough above the baseline.	
        /// </summary>	
        /// <unmanaged>INT16 strikethroughPosition</unmanaged>
        public short StrikethroughPosition;
        
        /// <summary>	
        /// The suggested strikethrough thickness value of the font face in font design units.	
        /// </summary>	
        /// <unmanaged>UINT16 strikethroughThickness</unmanaged>
        public short StrikethroughThickness;
    }
    
    /// <summary>	
    /// Specifies the metrics of an individual glyph. The units depend on how the metrics are obtained.	
    /// </summary>	
    /// <unmanaged>DWRITE_GLYPH_METRICS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct GlyphMetrics {	
        
        /// <summary>	
        /// Specifies the X offset from the glyph origin to the left edge of the black box. The glyph origin is the current horizontal writing position. A negative value means the black box extends to the left of the origin (often true for lowercase italic 'f').	
        /// </summary>	
        /// <unmanaged>INT32 leftSideBearing</unmanaged>
        public int LeftSideBearing;
        
        /// <summary>	
        /// Specifies the X offset from the origin of the current glyph to the origin of the next glyph when writing horizontally.	
        /// </summary>	
        /// <unmanaged>UINT32 advanceWidth</unmanaged>
        public int AdvanceWidth;
        
        /// <summary>	
        /// Specifies the X offset from the right edge of the black box to the origin of the next glyph when writing horizontally. The value is negative when the right edge of the black box overhangs the layout box.	
        /// </summary>	
        /// <unmanaged>INT32 rightSideBearing</unmanaged>
        public int RightSideBearing;
        
        /// <summary>	
        /// Specifies the vertical offset from the vertical origin to the top of the black box. Thus, a positive value adds whitespace whereas a negative value means the glyph overhangs the top of the layout box.	
        /// </summary>	
        /// <unmanaged>INT32 topSideBearing</unmanaged>
        public int TopSideBearing;
        
        /// <summary>	
        /// Specifies the Y offset from the vertical origin of the current glyph to the vertical origin of the next glyph when writing vertically. Note that the term "origin" by itself denotes the horizontal origin. The vertical origin is different. Its Y coordinate is specified by verticalOriginY value, and its X coordinate is half the advanceWidth to the right of the horizontal origin.	
        /// </summary>	
        /// <unmanaged>UINT32 advanceHeight</unmanaged>
        public int AdvanceHeight;
        
        /// <summary>	
        /// Specifies the vertical distance from the bottom edge of the black box to the advance height. This is positive when the bottom edge of the black box is within the layout box, or negative when the bottom edge of black box overhangs the layout box.	
        /// </summary>	
        /// <unmanaged>INT32 bottomSideBearing</unmanaged>
        public int BottomSideBearing;
        
        /// <summary>	
        /// Specifies the Y coordinate of a glyph's vertical origin, in the font's design coordinate system. The y coordinate of a glyph's vertical origin is the sum of the glyph's top side bearing and the top (that is, yMax) of the glyph's bounding box.	
        /// </summary>	
        /// <unmanaged>INT32 verticalOriginY</unmanaged>
        public int VerticalOriginY;
    }
    
    /// <summary>	
    /// The optional adjustment to a glyph's position.	
    /// </summary>	
    /// <remarks>	
    /// An glyph offset changes the position of a glyph without affecting the pen position. Offsets are in logical, pre-transform units.	
    /// </remarks>	
    /// <unmanaged>DWRITE_GLYPH_OFFSET</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct GlyphOffset {	
        
        /// <summary>	
        /// The offset in the advance direction of the run. A positive advance offset moves the glyph to the right (in pre-transform coordinates) if the run is left-to-right or to the left if the run is right-to-left.	
        /// </summary>	
        /// <unmanaged>FLOAT advanceOffset</unmanaged>
        public float AdvanceOffset;
        
        /// <summary>	
        /// The offset in the ascent direction, that is, the direction ascenders point. A positive ascender offset moves the glyph up (in pre-transform coordinates).  A negative ascender offset moves the glyph down.	
        /// </summary>	
        /// <unmanaged>FLOAT ascenderOffset</unmanaged>
        public float AscenderOffset;
    }
    
    /// <summary>	
    /// The DWRITE_MATRIX structure specifies the graphics transform to be applied to rendered glyphs.	
    /// </summary>	
    /// <unmanaged>DWRITE_MATRIX</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct Matrix {	
        
        /// <summary>	
        /// A value indicating the horizontal scaling / cosine of rotation.	
        /// </summary>	
        /// <unmanaged>FLOAT m11</unmanaged>
        public float M11;
        
        /// <summary>	
        /// A value indicating the vertical shear / sine of rotation.	
        /// </summary>	
        /// <unmanaged>FLOAT m12</unmanaged>
        public float M12;
        
        /// <summary>	
        /// A value indicating the horizontal shear / negative sine of rotation.	
        /// </summary>	
        /// <unmanaged>FLOAT m21</unmanaged>
        public float M21;
        
        /// <summary>	
        /// A value indicating the vertical scaling / cosine of rotation.	
        /// </summary>	
        /// <unmanaged>FLOAT m22</unmanaged>
        public float M22;
        
        /// <summary>	
        /// A value indicating the horizontal shift (always orthogonal regardless of rotation).	
        /// </summary>	
        /// <unmanaged>FLOAT dx</unmanaged>
        public float Dx;
        
        /// <summary>	
        /// A value indicating the vertical shift (always orthogonal regardless of rotation.)	
        /// </summary>	
        /// <unmanaged>FLOAT dy</unmanaged>
        public float Dy;
    }
    
    /// <summary>	
    /// Specifies a range of text positions where format is applied in the text represented by an <see cref="SlimDX2.DirectWrite.TextLayout"/> object.	
    /// </summary>	
    /// <unmanaged>DWRITE_TEXT_RANGE</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct TextRange {	
        
        /// <summary>	
        /// The start position of the text range.	
        /// </summary>	
        /// <unmanaged>UINT32 startPosition</unmanaged>
        public int StartPosition;
        
        /// <summary>	
        /// The number positions in the text range.	
        /// </summary>	
        /// <unmanaged>UINT32 length</unmanaged>
        public int Length;
    }
    
    /// <summary>	
    /// Specifies properties used to identify and execute typographic features in the current font face.	
    /// </summary>	
    /// <remarks>	
    /// A non-zero value generally enables the feature execution, while the zero value disables it. A feature requiring a selector uses this value to indicate the selector index.The OpenType standard provides access to typographic features available in the font by means of a feature tag with the associated parameters. The OpenType feature tag is a 4-byte identifier of the registered name of a feature. For example, the 'kern' feature name tag is used to identify the 'Kerning' feature in OpenType font. Similarly, the OpenType feature tag for 'Standard Ligatures' and 'Fractions' is 'liga' and 'frac' respectively. Since a single run can be associated with more than one typographic features, the Text String API accepts typographic settings for a run as a list of features and are executed in the order they are specified.The value of the tag member represents the OpenType name tag of the feature, while the param value represents additional parameter for the execution of the feature referred by the tag member. Both nameTag and parameter are stored as little endian, the same convention followed by GDI.  Most features treat the Param value as a binary value that indicates whether to turn the execution of the feature on or off, with it being off by default in the majority of cases. Some features, however, treat this value as an integral value representing the integer index to the list of alternate results it may produce during the execution; for instance, the feature 'Stylistic Alternates' or 'salt' uses the parameter value as an index to the list of alternate substituting glyphs it could produce for a specified glyph. 	
    /// </remarks>	
    /// <unmanaged>DWRITE_FONT_FEATURE</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct FontFeature {	
        
        /// <summary>	
        /// The feature OpenType name identifier.	
        /// </summary>	
        /// <unmanaged>DWRITE_FONT_FEATURE_TAG nameTag</unmanaged>
        public SlimDX2.DirectWrite.FontFeatureTag NameTag;
        
        /// <summary>	
        /// The execution parameter of the feature.	
        /// </summary>	
        /// <unmanaged>UINT32 parameter</unmanaged>
        public int Parameter;
    }
    
    /// <summary>	
    /// Contains a set of typographic features to be applied during text shaping.	
    /// </summary>	
    /// <unmanaged>DWRITE_TYPOGRAPHIC_FEATURES</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct TypographicFeatures {	
        
        /// <summary>	
        /// A pointer to a structure that specifies properties used to identify and execute typographic features in the font.	
        /// </summary>	
        /// <unmanaged>DWRITE_FONT_FEATURE* features</unmanaged>
        public IntPtr Features;
        
        /// <summary>	
        /// A value that indicates the number of features being applied to a font face.	
        /// </summary>	
        /// <unmanaged>UINT32 featureCount</unmanaged>
        public int FeatureCount;
    }
    
    /// <summary>	
    /// Specifies the trimming option for text overflowing the layout box. 	
    /// </summary>	
    /// <unmanaged>DWRITE_TRIMMING</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct Trimming {	
        
        /// <summary>	
        /// A value that specifies  the text granularity used to trim text overflowing the layout box.	
        /// </summary>	
        /// <unmanaged>DWRITE_TRIMMING_GRANULARITY granularity</unmanaged>
        public SlimDX2.DirectWrite.TrimmingGranularity Granularity;
        
        /// <summary>	
        /// A character code used as the delimiter that signals the beginning of the portion of text to be preserved. Most useful for path ellipsis, where the delimiter would be a slash.	
        /// </summary>	
        /// <unmanaged>UINT32 delimiter</unmanaged>
        public int Delimiter;
        
        /// <summary>	
        /// A value that indicates how many occurrences of the delimiter to step back.	
        /// </summary>	
        /// <unmanaged>UINT32 delimiterCount</unmanaged>
        public int DelimiterCount;
    }
    
    /// <summary>	
    /// Stores the association of text and its writing system script, as well as some display attributes.	
    /// </summary>	
    /// <unmanaged>DWRITE_SCRIPT_ANALYSIS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct ScriptAnalysis {	
        
        /// <summary>	
        /// The zero-based index representation of writing system script.	
        /// </summary>	
        /// <unmanaged>UINT16 script</unmanaged>
        public short Script;
        
        /// <summary>	
        /// A value that indicates additional shaping requirement of text.	
        /// </summary>	
        /// <unmanaged>DWRITE_SCRIPT_SHAPES shapes</unmanaged>
        public SlimDX2.DirectWrite.ScriptShapes Shapes;
    }
    
    /// <summary>	
    /// Line breakpoint characteristics of a character.	
    /// </summary>	
    /// <unmanaged>DWRITE_LINE_BREAKPOINT</unmanaged>
    [StructLayout(LayoutKind.Explicit, Pack = 0 )]
    public  partial struct LineBreakpoint {	
        
        /// <summary>	
        /// Indicates a breaking condition before the character.	
        /// </summary>	
        /// <unmanaged>UINT8 breakConditionBefore</unmanaged>
        [FieldOffset(0)]
        public byte BreakConditionBefore;
        
        /// <summary>	
        /// Indicates a breaking condition after the character.	
        /// </summary>	
        /// <unmanaged>UINT8 breakConditionAfter</unmanaged>
        [FieldOffset(1)]
        public byte BreakConditionAfter;
        
        /// <summary>	
        /// Indicates that the character is some form of whitespace, which may be meaningful for justification.	
        /// </summary>	
        /// <unmanaged>UINT8 isWhitespace</unmanaged>
        [FieldOffset(1)]
        public byte IsWhitespace;
        
        /// <summary>	
        /// Indicates that the character is a soft hyphen, often used to indicate hyphenation points inside words.	
        /// </summary>	
        /// <unmanaged>UINT8 isSoftHyphen</unmanaged>
        [FieldOffset(1)]
        public byte IsSoftHyphen;
        
        /// <summary>	
        /// Reserved for future use.	
        /// </summary>	
        /// <unmanaged>UINT8 padding</unmanaged>
        [FieldOffset(1)]
        public byte Padding;
    }
    
    /// <summary>	
    /// Shaping output properties for an output glyph.	
    /// </summary>	
    /// <unmanaged>DWRITE_SHAPING_TEXT_PROPERTIES</unmanaged>
    [StructLayout(LayoutKind.Explicit, Pack = 0 )]
    public  partial struct ShapingTextProperties {	
        
        /// <summary>	
        /// Indicates that the glyph is shaped alone.	
        /// </summary>	
        /// <unmanaged>UINT16 isShapedAlone</unmanaged>
        [FieldOffset(0)]
        public short IsShapedAlone;
        
        /// <summary>	
        /// Reserved for future use.	
        /// </summary>	
        /// <unmanaged>UINT16 reserved</unmanaged>
        [FieldOffset(2)]
        public short Reserved;
    }
    
    /// <summary>	
    /// Contains shaping output properties for an output glyph.	
    /// </summary>	
    /// <unmanaged>DWRITE_SHAPING_GLYPH_PROPERTIES</unmanaged>
    [StructLayout(LayoutKind.Explicit, Pack = 0 )]
    public  partial struct ShapingGlyphProperties {	
        
        /// <summary>	
        /// Indicates that the glyph has justification applied.	
        /// </summary>	
        /// <unmanaged>UINT16 justification</unmanaged>
        [FieldOffset(0)]
        public short Justification;
        
        /// <summary>	
        /// Indicates that the glyph is the start of a cluster.	
        /// </summary>	
        /// <unmanaged>UINT16 isClusterStart</unmanaged>
        [FieldOffset(2)]
        public short IsClusterStart;
        
        /// <summary>	
        /// Indicates that the glyph is a diacritic mark.	
        /// </summary>	
        /// <unmanaged>UINT16 isDiacritic</unmanaged>
        [FieldOffset(2)]
        public short IsDiacritic;
        
        /// <summary>	
        /// Indicates that the glyph is a word boundary with no visible space.	
        /// </summary>	
        /// <unmanaged>UINT16 isZeroWidthSpace</unmanaged>
        [FieldOffset(2)]
        public short IsZeroWidthSpace;
        
        /// <summary>	
        /// Reserved for future use.	
        /// </summary>	
        /// <unmanaged>UINT16 reserved</unmanaged>
        [FieldOffset(2)]
        public short Reserved;
    }
    
    /// <summary>	
    /// Contains the information needed by renderers to draw glyph runs.  All coordinates are in device independent pixels (DIPs). 	
    /// </summary>	
    /// <unmanaged>DWRITE_GLYPH_RUN</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct GlyphRun {	
        
        /// <summary>	
        /// The physical font face object to draw with.	
        /// </summary>	
        /// <unmanaged>IDWriteFontFace* fontFace</unmanaged>
        public IntPtr FontFace;
        
        /// <summary>	
        /// The logical size of the font in DIPs (equals 1/96 inch), not points.	
        /// </summary>	
        /// <unmanaged>FLOAT fontEmSize</unmanaged>
        public float FontEmSize;
        
        /// <summary>	
        /// The number of glyphs in the glyph run.	
        /// </summary>	
        /// <unmanaged>UINT32 glyphCount</unmanaged>
        public int GlyphCount;
        
        /// <summary>	
        /// A pointer to an array of indices to render for the glyph run.	
        /// </summary>	
        /// <unmanaged>const UINT16* glyphIndices</unmanaged>
        public IntPtr GlyphIndices;
        
        /// <summary>	
        /// A pointer to an array containing glyph advance widths for the glyph run.	
        /// </summary>	
        /// <unmanaged>const FLOAT* glyphAdvances</unmanaged>
        public IntPtr GlyphAdvances;
        
        /// <summary>	
        /// A pointer to an array containing glyph offsets for the glyph run.	
        /// </summary>	
        /// <unmanaged>const DWRITE_GLYPH_OFFSET* glyphOffsets</unmanaged>
        public IntPtr GlyphOffsets;
        
        /// <summary>	
        /// If true, specifies that glyphs are rotated 90 degrees to the left and vertical metrics are used. Vertical writing is achieved by specifying isSideways = true and rotating the entire run 90 degrees to the right via a rotate transform.	
        /// </summary>	
        /// <unmanaged>BOOL isSideways</unmanaged>
        public bool IsSideways { 
            get { 
                return (_IsSideways!=0)?true:false; 
            }
            set { 
                _IsSideways = value?1:0;
            }
        }
        internal int _IsSideways;
        
        /// <summary>	
        /// The implicit resolved bidi level of the run. Odd levels indicate right-to-left languages like Hebrew and Arabic, while even levels indicate left-to-right languages like English and Japanese (when written horizontally). For right-to-left languages, the text origin is on the right, and text should be drawn to the left.	
        /// </summary>	
        /// <unmanaged>UINT32 bidiLevel</unmanaged>
        public int BidiLevel;
    }
    
    /// <summary>	
    /// Contains additional properties related to those in DWRITE_GLYPH_RUN.	
    /// </summary>	
    /// <unmanaged>DWRITE_GLYPH_RUN_DESCRIPTION</unmanaged>
    public  partial struct GlyphRunDescription {	
        
        /// <summary>	
        /// An array of characters containing the locale name associated with this run.	
        /// </summary>	
        /// <unmanaged>const wchar* localeName</unmanaged>
        public string LocaleName;
        
        /// <summary>	
        /// An array of characters containing the text associated with the glyphs.	
        /// </summary>	
        /// <unmanaged>const wchar* string</unmanaged>
        public string String;
        
        /// <summary>	
        /// The number of characters in UTF16 code-units. Note that this may be different than the number of glyphs.	
        /// </summary>	
        /// <unmanaged>UINT32 stringLength</unmanaged>
        public int StringLength;
        
        /// <summary>	
        /// An array of indices to the glyph indices array, of the first glyphs of all the glyph clusters of the glyphs to render.	
        /// </summary>	
        /// <unmanaged>const UINT16* clusterMap</unmanaged>
        public IntPtr ClusterMap;
        
        /// <summary>	
        /// Corresponding text position in the string this glyph run came from.  This is relative to the beginning of the string represented by the IDWriteTextLayout object.	
        /// </summary>	
        /// <unmanaged>UINT32 textPosition</unmanaged>
        public int TextPosition;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public IntPtr LocaleName;
            public IntPtr String;
            public int StringLength;
            public IntPtr ClusterMap;
            public int TextPosition;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.LocaleName != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.LocaleName);		
                if (this.String != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.String);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.LocaleName = ( @ref.LocaleName == IntPtr.Zero )?null:new string((sbyte*)@ref.LocaleName);
            this.String = ( @ref.String == IntPtr.Zero )?null:new string((sbyte*)@ref.String);
            this.StringLength = @ref.StringLength;
            this.ClusterMap = @ref.ClusterMap;
            this.TextPosition = @ref.TextPosition;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.LocaleName = ( this.LocaleName == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.LocaleName);
            @ref.String = ( this.String == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.String);
            @ref.StringLength = this.StringLength;
            @ref.ClusterMap = this.ClusterMap;
            @ref.TextPosition = this.TextPosition;
		
		}
    }
    
    /// <summary>	
    /// Contains information about the width, thickness, offset, run height, reading direction, and flow direction of an underline. 	
    /// </summary>	
    /// <remarks>	
    /// All coordinates are in device independent pixels (DIPs).	
    /// </remarks>	
    /// <unmanaged>DWRITE_UNDERLINE</unmanaged>
    public  partial struct Underline {	
        
        /// <summary>	
        /// A value that indicates the width of the underline, measured parallel to the baseline.	
        /// </summary>	
        /// <unmanaged>FLOAT width</unmanaged>
        public float Width;
        
        /// <summary>	
        /// A value that indicates the thickness of the underline, measured perpendicular to the baseline.	
        /// </summary>	
        /// <unmanaged>FLOAT thickness</unmanaged>
        public float Thickness;
        
        /// <summary>	
        /// A value that indicates the offset of the underline from the baseline. A positive offset represents a position below the baseline (away from the text) and a negative offset is above (toward the text).	
        /// </summary>	
        /// <unmanaged>FLOAT offset</unmanaged>
        public float Offset;
        
        /// <summary>	
        /// A value that indicates the height of the tallest run where the underline is applied.	
        /// </summary>	
        /// <unmanaged>FLOAT runHeight</unmanaged>
        public float RunHeight;
        
        /// <summary>	
        /// A value that indicates the reading direction of the text associated with the underline. This value is used to interpret whether the width value runs horizontally or vertically.	
        /// </summary>	
        /// <unmanaged>DWRITE_READING_DIRECTION readingDirection</unmanaged>
        public SlimDX2.DirectWrite.ReadingDirection ReadingDirection;
        
        /// <summary>	
        /// A value that indicates the flow direction of the text associated with the underline. This value is used to interpret whether the thickness value advances top to bottom, left to right, or right to left.	
        /// </summary>	
        /// <unmanaged>DWRITE_FLOW_DIRECTION flowDirection</unmanaged>
        public SlimDX2.DirectWrite.FlowDirection FlowDirection;
        
        /// <summary>	
        /// An array of characters which contains the locale of the text that the underline is being drawn under.  For example, in vertical text, the underline belongs on the left for Chinese but on the right for Japanese. 	
        /// </summary>	
        /// <unmanaged>const wchar* localeName</unmanaged>
        public string LocaleName;
        
        /// <summary>	
        /// The measuring mode can be useful to the renderer to determine how underlines are rendered, such as rounding the thickness to a whole pixel in GDI-compatible modes.	
        /// </summary>	
        /// <unmanaged>DWRITE_MEASURING_MODE measuringMode</unmanaged>
        public SlimDX2.DirectWrite.MeasuringMode MeasuringMode;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public float Width;
            public float Thickness;
            public float Offset;
            public float RunHeight;
            public SlimDX2.DirectWrite.ReadingDirection ReadingDirection;
            public SlimDX2.DirectWrite.FlowDirection FlowDirection;
            public IntPtr LocaleName;
            public SlimDX2.DirectWrite.MeasuringMode MeasuringMode;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.LocaleName != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.LocaleName);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Width = @ref.Width;
            this.Thickness = @ref.Thickness;
            this.Offset = @ref.Offset;
            this.RunHeight = @ref.RunHeight;
            this.ReadingDirection = @ref.ReadingDirection;
            this.FlowDirection = @ref.FlowDirection;
            this.LocaleName = ( @ref.LocaleName == IntPtr.Zero )?null:new string((sbyte*)@ref.LocaleName);
            this.MeasuringMode = @ref.MeasuringMode;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Width = this.Width;
            @ref.Thickness = this.Thickness;
            @ref.Offset = this.Offset;
            @ref.RunHeight = this.RunHeight;
            @ref.ReadingDirection = this.ReadingDirection;
            @ref.FlowDirection = this.FlowDirection;
            @ref.LocaleName = ( this.LocaleName == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.LocaleName);
            @ref.MeasuringMode = this.MeasuringMode;
		
		}
    }
    
    /// <summary>	
    /// Contains information regarding the size and placement of strikethroughs. All coordinates are in device independent pixels (DIPs).	
    /// </summary>	
    /// <unmanaged>DWRITE_STRIKETHROUGH</unmanaged>
    public  partial struct Strikethrough {	
        
        /// <summary>	
        /// A value that indicates the width of the strikethrough, measured parallel to the baseline.	
        /// </summary>	
        /// <unmanaged>FLOAT width</unmanaged>
        public float Width;
        
        /// <summary>	
        /// A value that indicates the thickness of the strikethrough, measured perpendicular to the baseline.	
        /// </summary>	
        /// <unmanaged>FLOAT thickness</unmanaged>
        public float Thickness;
        
        /// <summary>	
        /// A value that indicates the offset of the strikethrough from the baseline.  A positive offset represents a position below the baseline and  a negative offset is above.  Typically, the offset will be negative.	
        /// </summary>	
        /// <unmanaged>FLOAT offset</unmanaged>
        public float Offset;
        
        /// <summary>	
        /// Reading direction of the text associated with the strikethrough.  This value is used to interpret whether the width value runs horizontally  or vertically.	
        /// </summary>	
        /// <unmanaged>DWRITE_READING_DIRECTION readingDirection</unmanaged>
        public SlimDX2.DirectWrite.ReadingDirection ReadingDirection;
        
        /// <summary>	
        /// Flow direction of the text associated with the strikethrough.  This value is used to interpret whether the thickness value advances top to  bottom, left to right, or right to left.	
        /// </summary>	
        /// <unmanaged>DWRITE_FLOW_DIRECTION flowDirection</unmanaged>
        public SlimDX2.DirectWrite.FlowDirection FlowDirection;
        
        /// <summary>	
        /// An array of characters containing the locale of the  text that is the strikethrough is being drawn over. 	
        /// </summary>	
        /// <unmanaged>const wchar* localeName</unmanaged>
        public string LocaleName;
        
        /// <summary>	
        /// The measuring mode can be useful to the renderer to determine how underlines are rendered, such as rounding the thickness to a whole pixel in GDI-compatible modes.	
        /// </summary>	
        /// <unmanaged>DWRITE_MEASURING_MODE measuringMode</unmanaged>
        public SlimDX2.DirectWrite.MeasuringMode MeasuringMode;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential, Pack = 0 )]
        internal unsafe partial struct __Native {	
            public float Width;
            public float Thickness;
            public float Offset;
            public SlimDX2.DirectWrite.ReadingDirection ReadingDirection;
            public SlimDX2.DirectWrite.FlowDirection FlowDirection;
            public IntPtr LocaleName;
            public SlimDX2.DirectWrite.MeasuringMode MeasuringMode;
		    // Method to free native struct
            internal unsafe void __MarshalFree()
            {
                if (this.LocaleName != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.LocaleName);		
            }
        }

        // Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Width = @ref.Width;
            this.Thickness = @ref.Thickness;
            this.Offset = @ref.Offset;
            this.ReadingDirection = @ref.ReadingDirection;
            this.FlowDirection = @ref.FlowDirection;
            this.LocaleName = ( @ref.LocaleName == IntPtr.Zero )?null:new string((sbyte*)@ref.LocaleName);
            this.MeasuringMode = @ref.MeasuringMode;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Width = this.Width;
            @ref.Thickness = this.Thickness;
            @ref.Offset = this.Offset;
            @ref.ReadingDirection = this.ReadingDirection;
            @ref.FlowDirection = this.FlowDirection;
            @ref.LocaleName = ( this.LocaleName == null )?IntPtr.Zero : Marshal.StringToHGlobalAnsi(this.LocaleName);
            @ref.MeasuringMode = this.MeasuringMode;
		
		}
    }
    
    /// <summary>	
    /// Contains information about a formatted line of text.	
    /// </summary>	
    /// <unmanaged>DWRITE_LINE_METRICS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct LineMetrics {	
        
        /// <summary>	
        /// The number of text positions in the text line.  This includes any trailing whitespace and newline characters.	
        /// </summary>	
        /// <unmanaged>UINT32 length</unmanaged>
        public int Length;
        
        /// <summary>	
        /// The number of whitespace positions at the end of the text line.  Newline sequences are considered whitespace.	
        /// </summary>	
        /// <unmanaged>UINT32 trailingWhitespaceLength</unmanaged>
        public int TrailingWhitespaceLength;
        
        /// <summary>	
        /// The number of characters in the newline sequence at the end of the text line.  If the count is zero, then the text line was either wrapped or it is the end of the text.	
        /// </summary>	
        /// <unmanaged>UINT32 newlineLength</unmanaged>
        public int NewlineLength;
        
        /// <summary>	
        /// The height of the text line.	
        /// </summary>	
        /// <unmanaged>FLOAT height</unmanaged>
        public float Height;
        
        /// <summary>	
        /// The distance from the top of the text line to its baseline.	
        /// </summary>	
        /// <unmanaged>FLOAT baseline</unmanaged>
        public float Baseline;
        
        /// <summary>	
        /// The line is trimmed.	
        /// </summary>	
        /// <unmanaged>BOOL isTrimmed</unmanaged>
        public bool IsTrimmed { 
            get { 
                return (_IsTrimmed!=0)?true:false; 
            }
            set { 
                _IsTrimmed = value?1:0;
            }
        }
        internal int _IsTrimmed;
    }
    
    /// <summary>	
    /// Contains information about a glyph cluster.	
    /// </summary>	
    /// <unmanaged>DWRITE_CLUSTER_METRICS</unmanaged>
    [StructLayout(LayoutKind.Explicit, Pack = 0 )]
    public  partial struct ClusterMetrics {	
        
        /// <summary>	
        /// The total advance width of all glyphs in the cluster.	
        /// </summary>	
        /// <unmanaged>FLOAT width</unmanaged>
        [FieldOffset(0)]
        public float Width;
        
        /// <summary>	
        /// The number of text positions in the cluster.	
        /// </summary>	
        /// <unmanaged>UINT16 length</unmanaged>
        [FieldOffset(4)]
        public short Length;
        
        /// <summary>	
        /// Indicates whether a line can be broken right after the cluster.	
        /// </summary>	
        /// <unmanaged>UINT16 canWrapLineAfter</unmanaged>
        [FieldOffset(4)]
        public short CanWrapLineAfter;
        
        /// <summary>	
        /// Indicates whether the cluster corresponds to a whitespace character.	
        /// </summary>	
        /// <unmanaged>UINT16 isWhitespace</unmanaged>
        [FieldOffset(4)]
        public short IsWhitespace;
        
        /// <summary>	
        /// Indicates whether the cluster corresponds to a newline character.	
        /// </summary>	
        /// <unmanaged>UINT16 isNewline</unmanaged>
        [FieldOffset(4)]
        public short IsNewline;
        
        /// <summary>	
        /// Indicates whether the cluster corresponds to a soft hyphen character.	
        /// </summary>	
        /// <unmanaged>UINT16 isSoftHyphen</unmanaged>
        [FieldOffset(4)]
        public short IsSoftHyphen;
        
        /// <summary>	
        /// Indicates whether the cluster is read from right to left.	
        /// </summary>	
        /// <unmanaged>UINT16 isRightToLeft</unmanaged>
        [FieldOffset(4)]
        public short IsRightToLeft;
        
        /// <summary>	
        /// Reserved for future use.	
        /// </summary>	
        /// <unmanaged>UINT16 padding</unmanaged>
        [FieldOffset(4)]
        public short Padding;
    }
    
    /// <summary>	
    /// Contains the metrics associated with text after layout.  All coordinates are in device independent pixels (DIPs).	
    /// </summary>	
    /// <unmanaged>DWRITE_TEXT_METRICS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct TextMetrics {	
        
        /// <summary>	
        /// A value that indicates the left-most point of formatted text relative to the layout box,  while excluding any glyph overhang.	
        /// </summary>	
        /// <unmanaged>FLOAT left</unmanaged>
        public float Left;
        
        /// <summary>	
        /// A value that indicates the top-most point of formatted text relative to the layout box, while excluding any glyph overhang.	
        /// </summary>	
        /// <unmanaged>FLOAT top</unmanaged>
        public float Top;
        
        /// <summary>	
        /// A value that indicates the width of the formatted text, while ignoring trailing whitespace  at the end of each line.	
        /// </summary>	
        /// <unmanaged>FLOAT width</unmanaged>
        public float Width;
        
        /// <summary>	
        /// The width of the formatted text, taking into account the  trailing whitespace at the end of each line.	
        /// </summary>	
        /// <unmanaged>FLOAT widthIncludingTrailingWhitespace</unmanaged>
        public float WidthIncludingTrailingWhitespace;
        
        /// <summary>	
        /// The height of the formatted text. The height of an empty string  is set to the same value as that of the default font.	
        /// </summary>	
        /// <unmanaged>FLOAT height</unmanaged>
        public float Height;
        
        /// <summary>	
        /// The initial width given to the layout. It can be either larger or smaller than the  text content width, depending on whether the text  was wrapped.	
        /// </summary>	
        /// <unmanaged>FLOAT layoutWidth</unmanaged>
        public float LayoutWidth;
        
        /// <summary>	
        /// Initial height given to the layout. Depending on the length of the text, it may be larger or smaller than the text content height.	
        /// </summary>	
        /// <unmanaged>FLOAT layoutHeight</unmanaged>
        public float LayoutHeight;
        
        /// <summary>	
        /// The maximum reordering count of any line of text, used  to calculate the most number of hit-testing boxes needed.  If the layout has no bidirectional text, or no text at all,  the minimum level is 1.	
        /// </summary>	
        /// <unmanaged>UINT32 maxBidiReorderingDepth</unmanaged>
        public int MaxBidiReorderingDepth;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>UINT32 lineCount</unmanaged>
        public int LineCount;
    }
    
    /// <summary>	
    /// Contains properties describing the geometric measurement of an	
    /// application-defined inline object.	
    /// </summary>	
    /// <unmanaged>DWRITE_INLINE_OBJECT_METRICS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct InlineObjectMetrics {	
        
        /// <summary>	
        /// The width of the inline object.	
        /// </summary>	
        /// <unmanaged>FLOAT width</unmanaged>
        public float Width;
        
        /// <summary>	
        /// The height of the inline object.	
        /// </summary>	
        /// <unmanaged>FLOAT height</unmanaged>
        public float Height;
        
        /// <summary>	
        /// The distance from the top of the object to the point where it is lined up with the adjacent text.  If the baseline is at the bottom, then baseline simply equals height.	
        /// </summary>	
        /// <unmanaged>FLOAT baseline</unmanaged>
        public float Baseline;
        
        /// <summary>	
        /// A Boolean flag that indicates whether the object is to be placed upright or alongside the text baseline for vertical text.	
        /// </summary>	
        /// <unmanaged>BOOL supportsSideways</unmanaged>
        public bool SupportsSideways { 
            get { 
                return (_SupportsSideways!=0)?true:false; 
            }
            set { 
                _SupportsSideways = value?1:0;
            }
        }
        internal int _SupportsSideways;
    }
    
    /// <summary>	
    /// Indicates how much any visible DIPs (device independent pixels) overshoot each side of the layout or inline objects.	
    /// </summary>	
    /// <unmanaged>DWRITE_OVERHANG_METRICS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct OverhangMetrics {	
        
        /// <summary>	
        /// The distance from the left-most visible DIP to its  left alignment edge.	
        /// </summary>	
        /// <unmanaged>FLOAT left</unmanaged>
        public float Left;
        
        /// <summary>	
        /// The distance from the top-most visible DIP to its  top alignment edge.	
        /// </summary>	
        /// <unmanaged>FLOAT top</unmanaged>
        public float Top;
        
        /// <summary>	
        /// The distance from the right-most visible DIP to its  right alignment edge.	
        /// </summary>	
        /// <unmanaged>FLOAT right</unmanaged>
        public float Right;
        
        /// <summary>	
        /// The distance from the bottom-most visible DIP to its lower  alignment edge.	
        /// </summary>	
        /// <unmanaged>FLOAT bottom</unmanaged>
        public float Bottom;
    }
    
    /// <summary>	
    /// Describes the region obtained by a hit test.	
    /// </summary>	
    /// <unmanaged>DWRITE_HIT_TEST_METRICS</unmanaged>
    [StructLayout(LayoutKind.Sequential, Pack = 0 )]
    public  partial struct HitTestMetrics {	
        
        /// <summary>	
        /// The first text position within the hit region. 	
        /// </summary>	
        /// <unmanaged>UINT32 textPosition</unmanaged>
        public int TextPosition;
        
        /// <summary>	
        /// The number of text positions within the hit region. 	
        /// </summary>	
        /// <unmanaged>UINT32 length</unmanaged>
        public int Length;
        
        /// <summary>	
        /// The x-coordinate of the upper-left corner of the hit region.	
        /// </summary>	
        /// <unmanaged>FLOAT left</unmanaged>
        public float Left;
        
        /// <summary>	
        /// The y-coordinate of the upper-left corner of the hit region.	
        /// </summary>	
        /// <unmanaged>FLOAT top</unmanaged>
        public float Top;
        
        /// <summary>	
        /// The width of the hit region.	
        /// </summary>	
        /// <unmanaged>FLOAT width</unmanaged>
        public float Width;
        
        /// <summary>	
        /// The height of the hit region.	
        /// </summary>	
        /// <unmanaged>FLOAT height</unmanaged>
        public float Height;
        
        /// <summary>	
        /// The {{BIDI level}} of the text positions within the hit region.	
        /// </summary>	
        /// <unmanaged>UINT32 bidiLevel</unmanaged>
        public int BidiLevel;
        
        /// <summary>	
        /// true if the hit region contains text; otherwise, false.	
        /// </summary>	
        /// <unmanaged>BOOL isText</unmanaged>
        public bool IsText { 
            get { 
                return (_IsText!=0)?true:false; 
            }
            set { 
                _IsText = value?1:0;
            }
        }
        internal int _IsText;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>BOOL isTrimmed</unmanaged>
        public bool IsTrimmed { 
            get { 
                return (_IsTrimmed!=0)?true:false; 
            }
            set { 
                _IsTrimmed = value?1:0;
            }
        }
        internal int _IsTrimmed;
    }
}
