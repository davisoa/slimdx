// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Interfaces for SlimDX2.Direct2D1 namespace.
//     This code was generated by a tool.
//     Date : 11/10/2010 17:02:17
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace SlimDX2.Direct2D1 {

    
    /// <summary>	
    /// Represents a Direct2D drawing resource.	
    /// </summary>	
    /// <unmanaged>ID2D1Resource</unmanaged>
    [Guid("2cd90691-12e2-11dc-9fed-001143a055f9")]
    public partial class Resource : SlimDX2.ComObject {
        public Resource(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the factory associated with this resource.	
        /// </summary>	
        /// <unmanaged>void ID2D1Resource::GetFactory([Out] ID2D1Factory** factory)</unmanaged>
        public SlimDX2.Direct2D1.Factory Factory {
                get { SlimDX2.Direct2D1.Factory __output__; GetFactory(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the factory associated with this resource.	
        /// </summary>	
        /// <param name="factory">When this method returns, contains a pointer to a pointer to the factory that created this resource. This parameter is passed uninitialized.</param>
        /// <unmanaged>void ID2D1Resource::GetFactory([Out] ID2D1Factory** factory)</unmanaged>
        internal void GetFactory(out SlimDX2.Direct2D1.Factory factory) {
            unsafe {
                IntPtr factory_ = IntPtr.Zero;
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 3 * 4, &factory_);
                factory = (factory_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.Factory(factory_);	
            }
        }
    }
    
    /// <summary>	
    /// Represents a bitmap that has been bound to an <see cref="SlimDX2.Direct2D1.RenderTarget"/>.	
    /// </summary>	
    /// <unmanaged>ID2D1Bitmap</unmanaged>
    [Guid("a2296057-ea42-4099-983b-539fb6505426")]
    public partial class Bitmap : SlimDX2.Direct2D1.Resource {
        public Bitmap(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Returns the size, in device-independent pixels (DIPs), of the bitmap.	
        /// </summary>	
        /// <remarks>	
        /// A DIP is 1/96?of an inch. To retrieve the size in device pixels, use the <see cref="SlimDX2.Direct2D1.Bitmap.GetPixelSize"/> method.	
        /// </remarks>	
        /// <unmanaged>D2D1_SIZE_F ID2D1Bitmap::GetSize()</unmanaged>
        public System.Drawing.SizeF Size {
                get { return GetSize(); }
        }
        
        /// <summary>	
        /// Returns the size, in device-dependent units (pixels), of the bitmap.	
        /// </summary>	
        /// <unmanaged>D2D1_SIZE_U ID2D1Bitmap::GetPixelSize()</unmanaged>
        public System.Drawing.Size PixelSize {
                get { return GetPixelSize(); }
        }
        
        /// <summary>	
        /// Retrieves the pixel format and alpha mode of the bitmap.	
        /// </summary>	
        /// <unmanaged>D2D1_PIXEL_FORMAT ID2D1Bitmap::GetPixelFormat()</unmanaged>
        public SlimDX2.Direct2D1.PixelFormat PixelFormat {
                get { return GetPixelFormat(); }
        }
        
        /// <summary>	
        /// Returns the size, in device-independent pixels (DIPs), of the bitmap.	
        /// </summary>	
        /// <remarks>	
        /// A DIP is 1/96?of an inch. To retrieve the size in device pixels, use the <see cref="SlimDX2.Direct2D1.Bitmap.GetPixelSize"/> method.	
        /// </remarks>	
        /// <returns>The size, in DIPs, of the bitmap.</returns>
        /// <unmanaged>D2D1_SIZE_F ID2D1Bitmap::GetSize()</unmanaged>
        internal System.Drawing.SizeF GetSize() {
            unsafe {
                System.Drawing.SizeF __result__;
                SlimDX2.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, 4 * 4,(void*)&__result__);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns the size, in device-dependent units (pixels), of the bitmap.	
        /// </summary>	
        /// <returns>The size, in pixels, of the bitmap.</returns>
        /// <unmanaged>D2D1_SIZE_U ID2D1Bitmap::GetPixelSize()</unmanaged>
        internal System.Drawing.Size GetPixelSize() {
            unsafe {
                System.Drawing.Size __result__;
                SlimDX2.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, 5 * 4,(void*)&__result__);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the pixel format and alpha mode of the bitmap.	
        /// </summary>	
        /// <returns>The pixel format and alpha mode of the bitmap.</returns>
        /// <unmanaged>D2D1_PIXEL_FORMAT ID2D1Bitmap::GetPixelFormat()</unmanaged>
        internal SlimDX2.Direct2D1.PixelFormat GetPixelFormat() {
            unsafe {
                SlimDX2.Direct2D1.PixelFormat __result__;
                SlimDX2.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, 6 * 4,(void*)&__result__);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Return the dots per inch (DPI) of the bitmap.	
        /// </summary>	
        /// <param name="dpiX">The horizontal DPI of the image. You must allocate storage for this parameter.</param>
        /// <param name="dpiY">The vertical DPI of the image.  You must allocate storage for this parameter.</param>
        /// <unmanaged>void ID2D1Bitmap::GetDpi([Out] FLOAT* dpiX,[Out] FLOAT* dpiY)</unmanaged>
        public void GetDpi(out float dpiX, out float dpiY) {
            unsafe {
                fixed (void* dpiX_ = &dpiX)
                    fixed (void* dpiY_ = &dpiY)
                        SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 7 * 4, dpiX_, dpiY_);
            }
        }
        
        /// <summary>	
        /// Copies the specified region from the specified bitmap into the current bitmap. 	
        /// </summary>	
        /// <remarks>	
        /// This method does not update the size of the  current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion, and will fail if the bitmap formats do not match.Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <see cref="int"/> and tag state will be returned at the next call to {{EndDraw}} or {{Flush}}. 	
        /// </remarks>	
        /// <param name="destPoint">In the current bitmap, the upper-left corner of the area to which the region specified by srcRect is copied.</param>
        /// <param name="bitmap">The bitmap to copy from.</param>
        /// <param name="srcRect">The area of bitmap to copy.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Bitmap::CopyFromBitmap([In, Optional] const D2D1_POINT_2U* destPoint,[In] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_RECT_U* srcRect)</unmanaged>
        public SlimDX2.Result CopyFromBitmap(System.Drawing.Point? destPoint, SlimDX2.Direct2D1.Bitmap bitmap, SlimDX2.Rectangle? srcRect) {
            unsafe {
                System.Drawing.Point destPoint_;
                if (destPoint.HasValue)
                    destPoint_ = destPoint.Value;				
                SlimDX2.Rectangle srcRect_;
                if (srcRect.HasValue)
                    srcRect_ = srcRect.Value;				
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 8 * 4, (destPoint.HasValue)?&destPoint_:(void*)IntPtr.Zero, (void*)((bitmap == null)?IntPtr.Zero:bitmap.NativePointer), (srcRect.HasValue)?&srcRect_:(void*)IntPtr.Zero);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copies the specified region from the specified render target into the current bitmap. 	
        /// </summary>	
        /// <remarks>	
        /// This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion, and will fail if the bitmap formats do not match.Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <see cref="int"/> and tag state will be returned at the next call to {{EndDraw}} or {{Flush}}. All clips and layers must be popped off of the render target before calling this method.  The method returns {{D2DERR_RENDER_TARGET_HAS_LAYER_OR_CLIPRECT}} if any clips or layers are currently applied to the render target.	
        /// </remarks>	
        /// <param name="destPoint">In the current bitmap, the upper-left corner of the area to which the region specified by srcRect is copied.</param>
        /// <param name="renderTarget">The render target that contains the region to copy.</param>
        /// <param name="srcRect">The area of renderTarget to copy.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Bitmap::CopyFromRenderTarget([In, Optional] const D2D1_POINT_2U* destPoint,[In] ID2D1RenderTarget* renderTarget,[In, Optional] const D2D1_RECT_U* srcRect)</unmanaged>
        public SlimDX2.Result CopyFromRenderTarget(System.Drawing.Point? destPoint, SlimDX2.Direct2D1.RenderTarget renderTarget, SlimDX2.Rectangle? srcRect) {
            unsafe {
                System.Drawing.Point destPoint_;
                if (destPoint.HasValue)
                    destPoint_ = destPoint.Value;				
                SlimDX2.Rectangle srcRect_;
                if (srcRect.HasValue)
                    srcRect_ = srcRect.Value;				
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 9 * 4, (destPoint.HasValue)?&destPoint_:(void*)IntPtr.Zero, (void*)((renderTarget == null)?IntPtr.Zero:renderTarget.NativePointer), (srcRect.HasValue)?&srcRect_:(void*)IntPtr.Zero);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copies the specified region from memory into the current bitmap. 	
        /// </summary>	
        /// <remarks>	
        /// This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion; the two bitmap formats should match. Passing this method invalid input, such as an invalid destination rectangle, can produce unpredictable results, such as a distorted image or device failure.Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <see cref="int"/> and tag state will be returned at the next call to {{EndDraw}} or {{Flush}}. 	
        /// </remarks>	
        /// <param name="dstRect">In the current bitmap, the upper-left corner of the area to which the region specified by srcRect is copied.</param>
        /// <param name="srcData">The data to copy.</param>
        /// <param name="pitch">The stride, or pitch, of the source bitmap stored in srcData. The stride is the byte count of a scanline (one row of pixels in memory). The stride can be computed from the following formula: pixel width * bytes per pixel + memory padding.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Bitmap::CopyFromMemory([In, Optional] const D2D1_RECT_U* dstRect,[In] const void* srcData,[None] UINT32 pitch)</unmanaged>
        public SlimDX2.Result CopyFromMemory(SlimDX2.Rectangle? dstRect, IntPtr srcData, int pitch) {
            unsafe {
                SlimDX2.Rectangle dstRect_;
                if (dstRect.HasValue)
                    dstRect_ = dstRect.Value;				
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 10 * 4, (dstRect.HasValue)?&dstRect_:(void*)IntPtr.Zero, (void*)srcData, pitch);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Represents an collection of <see cref="SlimDX2.Direct2D1.GradientStop"/> objects for linear and radial gradient brushes.	
    /// </summary>	
    /// <unmanaged>ID2D1GradientStopCollection</unmanaged>
    [Guid("2cd906a7-12e2-11dc-9fed-001143a055f9")]
    public partial class GradientStopCollection : SlimDX2.Direct2D1.Resource {
        public GradientStopCollection(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the number of gradient stops in the collection.	
        /// </summary>	
        /// <unmanaged>UINT32 ID2D1GradientStopCollection::GetGradientStopCount()</unmanaged>
        public int GradientStopCount {
                get { return GetGradientStopCount(); }
        }
        
        /// <summary>	
        /// Indicates the gamma space in which the gradient stops are interpolated. 	
        /// </summary>	
        /// <unmanaged>D2D1_GAMMA ID2D1GradientStopCollection::GetColorInterpolationGamma()</unmanaged>
        public SlimDX2.Direct2D1.Gamma ColorInterpolationGamma {
                get { return GetColorInterpolationGamma(); }
        }
        
        /// <summary>	
        /// Indicates the behavior of the gradient outside the normalized gradient range. 	
        /// </summary>	
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1GradientStopCollection::GetExtendMode()</unmanaged>
        public SlimDX2.Direct2D1.ExtendMode ExtendMode {
                get { return GetExtendMode(); }
        }
        
        /// <summary>	
        /// Retrieves the number of gradient stops in the collection.	
        /// </summary>	
        /// <returns>UINT32The number of gradient stops in the collection.</returns>
        /// <unmanaged>UINT32 ID2D1GradientStopCollection::GetGradientStopCount()</unmanaged>
        internal int GetGradientStopCount() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copies the gradient stops from the collection into an array of <see cref="SlimDX2.Direct2D1.GradientStop"/> structures.	
        /// </summary>	
        /// <remarks>	
        /// Gradient stops are copied in order of position, starting with the gradient stop with the smallest position value and progressing to the gradient stop with the largest position value.	
        /// </remarks>	
        /// <param name="gradientStops">A pointer to a one-dimensional array of <see cref="SlimDX2.Direct2D1.GradientStop"/> structures. When this method returns, the array contains copies of the collection's gradient stops. You must allocate the memory for this array.</param>
        /// <param name="gradientStopsCount">A value indicating the number of gradient stops to copy. If the value is less than the number of gradient stops in the collection, the remaining gradient stops are omitted. If the value is larger than the number of gradient stops in the collection, the extra gradient stops are set to NULL. To obtain the number of gradient stops in the collection, use the {{GetGradientStopCount}} method.</param>
        /// <unmanaged>void ID2D1GradientStopCollection::GetGradientStops([Out, Buffer] D2D1_GRADIENT_STOP* gradientStops,[None] UINT gradientStopsCount)</unmanaged>
        public void GetGradientStops(SlimDX2.Direct2D1.GradientStop[] gradientStops, int gradientStopsCount) {
            unsafe {
                fixed (void* gradientStops_ = &gradientStops[0])
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 5 * 4, gradientStops_, gradientStopsCount);
            }
        }
        
        /// <summary>	
        /// Indicates the gamma space in which the gradient stops are interpolated. 	
        /// </summary>	
        /// <returns>D2D1_GAMMAThe gamma space in which the gradient stops are interpolated. </returns>
        /// <unmanaged>D2D1_GAMMA ID2D1GradientStopCollection::GetColorInterpolationGamma()</unmanaged>
        internal SlimDX2.Direct2D1.Gamma GetColorInterpolationGamma() {
            unsafe {
                SlimDX2.Direct2D1.Gamma __result__;
                __result__= (SlimDX2.Direct2D1.Gamma)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Indicates the behavior of the gradient outside the normalized gradient range. 	
        /// </summary>	
        /// <returns>D2D1_EXTEND_MODEThe behavior of the gradient outside the [0,1] normalized gradient range.</returns>
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1GradientStopCollection::GetExtendMode()</unmanaged>
        internal SlimDX2.Direct2D1.ExtendMode GetExtendMode() {
            unsafe {
                SlimDX2.Direct2D1.ExtendMode __result__;
                __result__= (SlimDX2.Direct2D1.ExtendMode)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 7 * 4);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Defines an object that paints an area. Interfaces that derive from ID2D1Brush describe how the area is painted. 	
    /// </summary>	
    /// <unmanaged>ID2D1Brush</unmanaged>
    [Guid("2cd906a8-12e2-11dc-9fed-001143a055f9")]
    public partial class Brush : SlimDX2.Direct2D1.Resource {
        public Brush(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the degree of opacity of this brush.   	
        /// </summary>	
        /// <unmanaged>FLOAT ID2D1Brush::GetOpacity()</unmanaged>
        public float Opacity {
                get { return GetOpacity(); }
                set { SetOpacity(value); }
        }
        
        /// <summary>	
        /// Gets the transform applied to this brush. 	
        /// </summary>	
        /// <remarks>	
        /// When the brush transform is the identity matrix, the brush appears in the same coordinate space as the render target in which it is drawn.	
        /// </remarks>	
        /// <unmanaged>void ID2D1Brush::GetTransform([Out] D2D1_MATRIX_3X2_F* transform)</unmanaged>
        public SlimDX2.Direct2D1.Matrix3x2 Transform {
                get { SlimDX2.Direct2D1.Matrix3x2 __output__; GetTransform(out __output__); return __output__; }
                set { SetTransform(ref value); }
        }
        
        /// <summary>	
        /// Sets the degree of opacity of this brush.	
        /// </summary>	
        /// <param name="opacity">A value between zero and 1 that indicates the opacity of the brush. This value is a constant multiplier that linearly scales the alpha value of all pixels filled by the brush. The opacity values are clamped in the range 0?1 before they are multipled together. </param>
        /// <unmanaged>void ID2D1Brush::SetOpacity([None] FLOAT opacity)</unmanaged>
        internal void SetOpacity(float opacity) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 4 * 4, opacity);
            }
        }
        
        /// <summary>	
        /// Sets the transformation applied to the brush.	
        /// </summary>	
        /// <param name="transform">The transformation to apply to this brush. </param>
        /// <unmanaged>void ID2D1Brush::SetTransform([In] const D2D1_MATRIX_3X2_F* transform)</unmanaged>
        internal void SetTransform(ref SlimDX2.Direct2D1.Matrix3x2 transform) {
            unsafe {
                fixed (void* transform_ = &transform)
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 5 * 4, transform_);
            }
        }
        
        /// <summary>	
        /// Gets the degree of opacity of this brush.   	
        /// </summary>	
        /// <returns>FLOATA value between zero and 1 that indicates the opacity of the brush. This value is a constant multiplier that linearly scales the alpha value of all pixels filled by the brush. The opacity values are clamped in the range 0?1 before they are multipled together. </returns>
        /// <unmanaged>FLOAT ID2D1Brush::GetOpacity()</unmanaged>
        internal float GetOpacity() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct2D1.LocalInterop.Callifloat(_nativePointer, 6 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the transform applied to this brush. 	
        /// </summary>	
        /// <remarks>	
        /// When the brush transform is the identity matrix, the brush appears in the same coordinate space as the render target in which it is drawn.	
        /// </remarks>	
        /// <param name="transform">The transform applied to this brush.</param>
        /// <unmanaged>void ID2D1Brush::GetTransform([Out] D2D1_MATRIX_3X2_F* transform)</unmanaged>
        internal void GetTransform(out SlimDX2.Direct2D1.Matrix3x2 transform) {
            unsafe {
                transform = new SlimDX2.Direct2D1.Matrix3x2();
                fixed (void* transform_ = &transform)
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 7 * 4, transform_);
            }
        }
    }
    
    /// <summary>	
    /// Paints an area with a bitmap.	
    /// </summary>	
    /// <unmanaged>ID2D1BitmapBrush</unmanaged>
    [Guid("2cd906aa-12e2-11dc-9fed-001143a055f9")]
    public partial class BitmapBrush : SlimDX2.Direct2D1.Brush {
        public BitmapBrush(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Gets the method by which the brush horizontally tiles those areas that extend past its bitmap. 	
        /// </summary>	
        /// <remarks>	
        /// Like all brushes, <see cref="SlimDX2.Direct2D1.BitmapBrush"/> defines an infinite plane of content. Because bitmaps are finite, it relies on an extend mode to determine how the plane is filled horizontally and vertically.	
        /// </remarks>	
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1BitmapBrush::GetExtendModeX()</unmanaged>
        public SlimDX2.Direct2D1.ExtendMode ExtendModeX {
                get { return GetExtendModeX(); }
                set { SetExtendModeX(value); }
        }
        
        /// <summary>	
        ///  Gets the method by which the brush vertically tiles those areas that extend past its bitmap. 	
        /// </summary>	
        /// <remarks>	
        /// Like all brushes, <see cref="SlimDX2.Direct2D1.BitmapBrush"/> defines an infinite plane of content.  Because bitmaps are finite, it relies on an extend mode to determine how the plane is filled horizontally and vertically.	
        /// </remarks>	
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1BitmapBrush::GetExtendModeY()</unmanaged>
        public SlimDX2.Direct2D1.ExtendMode ExtendModeY {
                get { return GetExtendModeY(); }
                set { SetExtendModeY(value); }
        }
        
        /// <summary>	
        /// Gets the interpolation method used when the brush bitmap is scaled or rotated. 	
        /// </summary>	
        /// <remarks>	
        /// This method gets the interpolation mode of a bitmap, which is specified by the <see cref="SlimDX2.Direct2D1.BitmapInterpolationMode"/> enumeration type.   D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR represents nearest neighbor filtering. It looks up the bitmap pixel nearest to the current rendering pixel and chooses its exact color. D2D1_BITMAP_INTERPOLATION_MODE_LINEAR represents linear filtering, and  interpolates a color from the four nearest bitmap pixels.The interpolation mode of a bitmap also affects subpixel translations. In a subpixel translation, linear interpolation positions the bitmap more precisely to the application request, but blurs the bitmap in the process. 	
        /// </remarks>	
        /// <unmanaged>D2D1_BITMAP_INTERPOLATION_MODE ID2D1BitmapBrush::GetInterpolationMode()</unmanaged>
        public SlimDX2.Direct2D1.BitmapInterpolationMode InterpolationMode {
                get { return GetInterpolationMode(); }
                set { SetInterpolationMode(value); }
        }
        
        /// <summary>	
        ///  Gets the bitmap source that this brush uses to paint.	
        /// </summary>	
        /// <unmanaged>void ID2D1BitmapBrush::GetBitmap([Out] ID2D1Bitmap** bitmap)</unmanaged>
        public SlimDX2.Direct2D1.Bitmap Bitmap {
                get { SlimDX2.Direct2D1.Bitmap __output__; GetBitmap(out __output__); return __output__; }
                set { SetBitmap(value); }
        }
        
        /// <summary>	
        /// Specifies how the brush horizontally tiles those areas that extend past its bitmap. 	
        /// </summary>	
        /// <remarks>	
        /// Sometimes, the  bitmap for a bitmap brush doesn't completely fill the area being painted. When this happens, Direct2D uses the brush's horizontal (SetExtendModeX) and vertical ({{SetExtendModeY}}) extend mode settings to determine how to fill the remaining area.The following illustration shows the results from  every  possible combination of the extend modes for an <see cref="SlimDX2.Direct2D1.BitmapBrush"/>: <see cref="SlimDX2.Direct2D1.ExtendMode.Clamp"/> (CLAMP), D2D1_EXTEND_MODE_WRAP (WRAP), and D2D1_EXTEND_MIRROR (MIRROR).?Illustration of a bitmap and the resulting images from various extend modes?	
        /// </remarks>	
        /// <param name="extendModeX">A value that specifies how the brush horizontally tiles those areas that extend past its bitmap. </param>
        /// <unmanaged>void ID2D1BitmapBrush::SetExtendModeX([None] D2D1_EXTEND_MODE extendModeX)</unmanaged>
        internal void SetExtendModeX(SlimDX2.Direct2D1.ExtendMode extendModeX) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 8 * 4, unchecked((int)extendModeX));
            }
        }
        
        /// <summary>	
        /// Specifies how the brush vertically tiles those areas that extend past its bitmap.	
        /// </summary>	
        /// <remarks>	
        /// Sometimes, the  bitmap for a bitmap brush doesn't completely fill the area being painted. When this happens, Direct2D uses the brush's horizontal ({{SetExtendModeX}}) and vertical (SetExtendModeY) extend mode settings to determine how to fill the remaining area.The following illustration shows the results from  every  possible combination of the extend modes for an <see cref="SlimDX2.Direct2D1.BitmapBrush"/>: <see cref="SlimDX2.Direct2D1.ExtendMode.Clamp"/> (CLAMP), D2D1_EXTEND_MODE_WRAP (WRAP), and D2D1_EXTEND_MIRROR (MIRROR).?Illustration of a bitmap and the resulting images from various extend modes?	
        /// </remarks>	
        /// <param name="extendModeY">A value that specifies how the brush vertically tiles those areas that extend past its bitmap.</param>
        /// <unmanaged>void ID2D1BitmapBrush::SetExtendModeY([None] D2D1_EXTEND_MODE extendModeY)</unmanaged>
        internal void SetExtendModeY(SlimDX2.Direct2D1.ExtendMode extendModeY) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 9 * 4, unchecked((int)extendModeY));
            }
        }
        
        /// <summary>	
        /// Specifies the interpolation mode used when the brush bitmap is scaled or rotated.	
        /// </summary>	
        /// <remarks>	
        /// This method sets the interpolation mode for a bitmap, which is an enum value that is specified in the <see cref="SlimDX2.Direct2D1.BitmapInterpolationMode"/> enumeration type.   D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR represents nearest neighbor filtering. It looks up the nearest bitmap pixel to the current rendering pixel and chooses its exact color. D2D1_BITMAP_INTERPOLATION_MODE_LINEAR represents linear filtering, and  interpolates a color from the four nearest bitmap pixels.The interpolation mode of a bitmap also affects subpixel translations. In a subpixel translation, bilinear interpolation positions the bitmap more precisely to the application requests, but blurs the bitmap in the process. 	
        /// </remarks>	
        /// <param name="interpolationMode">The interpolation mode used when the brush bitmap is scaled or rotated.</param>
        /// <unmanaged>void ID2D1BitmapBrush::SetInterpolationMode([None] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode)</unmanaged>
        internal void SetInterpolationMode(SlimDX2.Direct2D1.BitmapInterpolationMode interpolationMode) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 10 * 4, unchecked((int)interpolationMode));
            }
        }
        
        /// <summary>	
        /// Specifies the bitmap source that this brush uses to paint. 	
        /// </summary>	
        /// <remarks>	
        /// This method specifies the bitmap source that this brush uses to paint. The bitmap is not resized or rescaled automatically to fit the geometry that it fills. The bitmap stays at its native size. To resize or translate the bitmap, use the {{SetTransform}} method to apply  a transform to the brush. The native size of a bitmap is the width and height in bitmap pixels, divided by the bitmap DPI. This native size forms the base tile of the brush. To tile a subregion of the bitmap, you must generate a new bitmap containing this subregion and use SetBitmap to apply it to the brush. 	
        /// </remarks>	
        /// <param name="bitmap">The bitmap source used by the brush.</param>
        /// <unmanaged>void ID2D1BitmapBrush::SetBitmap([In] ID2D1Bitmap* bitmap)</unmanaged>
        internal void SetBitmap(SlimDX2.Direct2D1.Bitmap bitmap) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 11 * 4, (void*)((bitmap == null)?IntPtr.Zero:bitmap.NativePointer));
            }
        }
        
        /// <summary>	
        ///  Gets the method by which the brush horizontally tiles those areas that extend past its bitmap. 	
        /// </summary>	
        /// <remarks>	
        /// Like all brushes, <see cref="SlimDX2.Direct2D1.BitmapBrush"/> defines an infinite plane of content. Because bitmaps are finite, it relies on an extend mode to determine how the plane is filled horizontally and vertically.	
        /// </remarks>	
        /// <returns>A value that specifies how the brush horizontally tiles those areas that extend past its bitmap.</returns>
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1BitmapBrush::GetExtendModeX()</unmanaged>
        internal SlimDX2.Direct2D1.ExtendMode GetExtendModeX() {
            unsafe {
                SlimDX2.Direct2D1.ExtendMode __result__;
                __result__= (SlimDX2.Direct2D1.ExtendMode)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 12 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the method by which the brush vertically tiles those areas that extend past its bitmap. 	
        /// </summary>	
        /// <remarks>	
        /// Like all brushes, <see cref="SlimDX2.Direct2D1.BitmapBrush"/> defines an infinite plane of content.  Because bitmaps are finite, it relies on an extend mode to determine how the plane is filled horizontally and vertically.	
        /// </remarks>	
        /// <returns>A value that specifies how the brush vertically tiles those areas that extend past its bitmap.</returns>
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1BitmapBrush::GetExtendModeY()</unmanaged>
        internal SlimDX2.Direct2D1.ExtendMode GetExtendModeY() {
            unsafe {
                SlimDX2.Direct2D1.ExtendMode __result__;
                __result__= (SlimDX2.Direct2D1.ExtendMode)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 13 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the interpolation method used when the brush bitmap is scaled or rotated. 	
        /// </summary>	
        /// <remarks>	
        /// This method gets the interpolation mode of a bitmap, which is specified by the <see cref="SlimDX2.Direct2D1.BitmapInterpolationMode"/> enumeration type.   D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR represents nearest neighbor filtering. It looks up the bitmap pixel nearest to the current rendering pixel and chooses its exact color. D2D1_BITMAP_INTERPOLATION_MODE_LINEAR represents linear filtering, and  interpolates a color from the four nearest bitmap pixels.The interpolation mode of a bitmap also affects subpixel translations. In a subpixel translation, linear interpolation positions the bitmap more precisely to the application request, but blurs the bitmap in the process. 	
        /// </remarks>	
        /// <returns>The interpolation method used when the brush bitmap is scaled or rotated.</returns>
        /// <unmanaged>D2D1_BITMAP_INTERPOLATION_MODE ID2D1BitmapBrush::GetInterpolationMode()</unmanaged>
        internal SlimDX2.Direct2D1.BitmapInterpolationMode GetInterpolationMode() {
            unsafe {
                SlimDX2.Direct2D1.BitmapInterpolationMode __result__;
                __result__= (SlimDX2.Direct2D1.BitmapInterpolationMode)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 14 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Gets the bitmap source that this brush uses to paint.	
        /// </summary>	
        /// <param name="bitmap">When this method returns, contains the address to a pointer to the bitmap with which this brush paints.</param>
        /// <unmanaged>void ID2D1BitmapBrush::GetBitmap([Out] ID2D1Bitmap** bitmap)</unmanaged>
        internal void GetBitmap(out SlimDX2.Direct2D1.Bitmap bitmap) {
            unsafe {
                IntPtr bitmap_ = IntPtr.Zero;
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 15 * 4, &bitmap_);
                bitmap = (bitmap_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.Bitmap(bitmap_);	
            }
        }
    }
    
    /// <summary>	
    /// Paints an area with a solid color. 	
    /// </summary>	
    /// <unmanaged>ID2D1SolidColorBrush</unmanaged>
    [Guid("2cd906a9-12e2-11dc-9fed-001143a055f9")]
    public partial class SolidColorBrush : SlimDX2.Direct2D1.Brush {
        public SolidColorBrush(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Retrieves the color of the solid color brush.	
        /// </summary>	
        /// <unmanaged>D2D1_COLOR_F ID2D1SolidColorBrush::GetColor()</unmanaged>
        public SlimMath.Color4 Color {
                get { return GetColor(); }
                set { SetColor(value); }
        }
        
        /// <summary>	
        ///  Specifies the color of this solid-color brush. 	
        /// </summary>	
        /// <remarks>	
        /// To help create colors, Direct2D provides the {{ColorF}} class. It offers several helper methods for creating colors and provides a set or predefined colors. 	
        /// </remarks>	
        /// <param name="color">The color of this solid-color brush.</param>
        /// <unmanaged>void ID2D1SolidColorBrush::SetColor([In] const D2D1_COLOR_F* color)</unmanaged>
        internal void SetColor(SlimMath.Color4 color) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 8 * 4, &color);
            }
        }
        
        /// <summary>	
        ///  Retrieves the color of the solid color brush.	
        /// </summary>	
        /// <returns>The color of this solid color brush.</returns>
        /// <unmanaged>D2D1_COLOR_F ID2D1SolidColorBrush::GetColor()</unmanaged>
        internal SlimMath.Color4 GetColor() {
            unsafe {
                SlimMath.Color4 __result__;
                SlimDX2.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, 9 * 4,(void*)&__result__);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Paints an area with a linear gradient.  	
    /// </summary>	
    /// <unmanaged>ID2D1LinearGradientBrush</unmanaged>
    [Guid("2cd906ab-12e2-11dc-9fed-001143a055f9")]
    public partial class LinearGradientBrush : SlimDX2.Direct2D1.Brush {
        public LinearGradientBrush(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the starting coordinates of the linear gradient. 	
        /// </summary>	
        /// <remarks>	
        /// The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.	
        /// </remarks>	
        /// <unmanaged>D2D1_POINT_2F ID2D1LinearGradientBrush::GetStartPoint()</unmanaged>
        public System.Drawing.PointF StartPoint {
                get { return GetStartPoint(); }
                set { SetStartPoint(value); }
        }
        
        /// <summary>	
        /// Retrieves the ending coordinates of the linear gradient. 	
        /// </summary>	
        /// <remarks>	
        /// The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.	
        /// </remarks>	
        /// <unmanaged>D2D1_POINT_2F ID2D1LinearGradientBrush::GetEndPoint()</unmanaged>
        public System.Drawing.PointF EndPoint {
                get { return GetEndPoint(); }
                set { SetEndPoint(value); }
        }
        
        /// <summary>	
        ///  Retrieves the <see cref="SlimDX2.Direct2D1.GradientStopCollection"/> associated with this linear gradient brush.	
        /// </summary>	
        /// <remarks>	
        /// <see cref="SlimDX2.Direct2D1.GradientStopCollection"/> contains an array of <see cref="SlimDX2.Direct2D1.GradientStop"/> structures and information, such as the extend mode and the color interpolation mode.	
        /// </remarks>	
        /// <unmanaged>void ID2D1LinearGradientBrush::GetGradientStopCollection([Out] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>
        public SlimDX2.Direct2D1.GradientStopCollection GradientStopCollection {
                get { SlimDX2.Direct2D1.GradientStopCollection __output__; GetGradientStopCollection(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Sets the starting coordinates of the linear gradient in the brush's coordinate space.  	
        /// </summary>	
        /// <remarks>	
        /// The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.	
        /// </remarks>	
        /// <param name="startPoint">The starting two-dimensional coordinates of the linear gradient, in the brush's coordinate space.</param>
        /// <unmanaged>void ID2D1LinearGradientBrush::SetStartPoint([None] D2D1_POINT_2F startPoint)</unmanaged>
        internal void SetStartPoint(System.Drawing.PointF startPoint) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 8 * 4, startPoint);
            }
        }
        
        /// <summary>	
        /// Sets the ending coordinates of the linear gradient in the brush's coordinate space.	
        /// </summary>	
        /// <remarks>	
        /// The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.	
        /// </remarks>	
        /// <param name="endPoint">The ending two-dimensional coordinates of the linear gradient, in the brush's coordinate space.</param>
        /// <unmanaged>void ID2D1LinearGradientBrush::SetEndPoint([None] D2D1_POINT_2F endPoint)</unmanaged>
        internal void SetEndPoint(System.Drawing.PointF endPoint) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 9 * 4, endPoint);
            }
        }
        
        /// <summary>	
        /// Retrieves the starting coordinates of the linear gradient. 	
        /// </summary>	
        /// <remarks>	
        /// The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.	
        /// </remarks>	
        /// <returns>The starting two-dimensional coordinates of the linear gradient, in the brush's coordinate space.</returns>
        /// <unmanaged>D2D1_POINT_2F ID2D1LinearGradientBrush::GetStartPoint()</unmanaged>
        internal System.Drawing.PointF GetStartPoint() {
            unsafe {
                System.Drawing.PointF __result__;
                SlimDX2.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, 10 * 4,(void*)&__result__);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the ending coordinates of the linear gradient. 	
        /// </summary>	
        /// <remarks>	
        /// The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.	
        /// </remarks>	
        /// <returns>The ending two-dimensional coordinates of the linear gradient, in the brush's coordinate space.</returns>
        /// <unmanaged>D2D1_POINT_2F ID2D1LinearGradientBrush::GetEndPoint()</unmanaged>
        internal System.Drawing.PointF GetEndPoint() {
            unsafe {
                System.Drawing.PointF __result__;
                SlimDX2.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, 11 * 4,(void*)&__result__);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Retrieves the <see cref="SlimDX2.Direct2D1.GradientStopCollection"/> associated with this linear gradient brush.	
        /// </summary>	
        /// <remarks>	
        /// <see cref="SlimDX2.Direct2D1.GradientStopCollection"/> contains an array of <see cref="SlimDX2.Direct2D1.GradientStop"/> structures and information, such as the extend mode and the color interpolation mode.	
        /// </remarks>	
        /// <param name="gradientStopCollection">The  <see cref="SlimDX2.Direct2D1.GradientStopCollection"/> object associated with this linear gradient brush object. This parameter is passed uninitialized. </param>
        /// <unmanaged>void ID2D1LinearGradientBrush::GetGradientStopCollection([Out] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>
        internal void GetGradientStopCollection(out SlimDX2.Direct2D1.GradientStopCollection gradientStopCollection) {
            unsafe {
                IntPtr gradientStopCollection_ = IntPtr.Zero;
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 12 * 4, &gradientStopCollection_);
                gradientStopCollection = (gradientStopCollection_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.GradientStopCollection(gradientStopCollection_);	
            }
        }
    }
    
    /// <summary>	
    ///  Paints an area with a radial gradient.	
    /// </summary>	
    /// <unmanaged>ID2D1RadialGradientBrush</unmanaged>
    [Guid("2cd906ac-12e2-11dc-9fed-001143a055f9")]
    public partial class RadialGradientBrush : SlimDX2.Direct2D1.Brush {
        public RadialGradientBrush(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the center of the gradient ellipse.  	
        /// </summary>	
        /// <unmanaged>D2D1_POINT_2F ID2D1RadialGradientBrush::GetCenter()</unmanaged>
        public System.Drawing.PointF Center {
                get { return GetCenter(); }
                set { SetCenter(value); }
        }
        
        /// <summary>	
        /// Retrieves the offset of the gradient origin relative to the gradient ellipse's center. 	
        /// </summary>	
        /// <unmanaged>D2D1_POINT_2F ID2D1RadialGradientBrush::GetGradientOriginOffset()</unmanaged>
        public System.Drawing.PointF GradientOriginOffset {
                get { return GetGradientOriginOffset(); }
                set { SetGradientOriginOffset(value); }
        }
        
        /// <summary>	
        /// Retrieves the x-radius of the gradient ellipse. 	
        /// </summary>	
        /// <unmanaged>FLOAT ID2D1RadialGradientBrush::GetRadiusX()</unmanaged>
        public float RadiusX {
                get { return GetRadiusX(); }
                set { SetRadiusX(value); }
        }
        
        /// <summary>	
        /// Retrieves the y-radius of the gradient ellipse. 	
        /// </summary>	
        /// <unmanaged>FLOAT ID2D1RadialGradientBrush::GetRadiusY()</unmanaged>
        public float RadiusY {
                get { return GetRadiusY(); }
                set { SetRadiusY(value); }
        }
        
        /// <summary>	
        /// Retrieves the <see cref="SlimDX2.Direct2D1.GradientStopCollection"/> associated with this radial gradient brush object.	
        /// </summary>	
        /// <remarks>	
        /// <see cref="SlimDX2.Direct2D1.GradientStopCollection"/> contains an array of <see cref="SlimDX2.Direct2D1.GradientStop"/> structures and additional information, such as the extend mode and the color interpolation mode.	
        /// </remarks>	
        /// <unmanaged>void ID2D1RadialGradientBrush::GetGradientStopCollection([Out] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>
        public SlimDX2.Direct2D1.GradientStopCollection GradientStopCollection {
                get { SlimDX2.Direct2D1.GradientStopCollection __output__; GetGradientStopCollection(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Specifies the center of the gradient ellipse in the brush's coordinate space. 	
        /// </summary>	
        /// <param name="center">The center of the gradient ellipse, in the brush's coordinate space.</param>
        /// <unmanaged>void ID2D1RadialGradientBrush::SetCenter([None] D2D1_POINT_2F center)</unmanaged>
        internal void SetCenter(System.Drawing.PointF center) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 8 * 4, center);
            }
        }
        
        /// <summary>	
        /// Specifies the offset of the gradient origin relative to the gradient ellipse's center.	
        /// </summary>	
        /// <param name="gradientOriginOffset">The offset of the gradient origin from the center of the gradient ellipse.</param>
        /// <unmanaged>void ID2D1RadialGradientBrush::SetGradientOriginOffset([None] D2D1_POINT_2F gradientOriginOffset)</unmanaged>
        internal void SetGradientOriginOffset(System.Drawing.PointF gradientOriginOffset) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 9 * 4, gradientOriginOffset);
            }
        }
        
        /// <summary>	
        ///  Specifies the x-radius of the gradient ellipse, in the brush's coordinate space.	
        /// </summary>	
        /// <param name="radiusX">The x-radius of the gradient ellipse. This value is in the brush's coordinate space.</param>
        /// <unmanaged>void ID2D1RadialGradientBrush::SetRadiusX([None] FLOAT radiusX)</unmanaged>
        internal void SetRadiusX(float radiusX) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 10 * 4, radiusX);
            }
        }
        
        /// <summary>	
        /// Specifies the y-radius of the gradient ellipse, in the brush's coordinate space. 	
        /// </summary>	
        /// <param name="radiusY">The y-radius of the gradient ellipse. This value is in the brush's coordinate space.</param>
        /// <unmanaged>void ID2D1RadialGradientBrush::SetRadiusY([None] FLOAT radiusY)</unmanaged>
        internal void SetRadiusY(float radiusY) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 11 * 4, radiusY);
            }
        }
        
        /// <summary>	
        /// Retrieves the center of the gradient ellipse.  	
        /// </summary>	
        /// <returns>The center of the gradient ellipse. This value is expressed in the brush's coordinate space.</returns>
        /// <unmanaged>D2D1_POINT_2F ID2D1RadialGradientBrush::GetCenter()</unmanaged>
        internal System.Drawing.PointF GetCenter() {
            unsafe {
                System.Drawing.PointF __result__;
                SlimDX2.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, 12 * 4,(void*)&__result__);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the offset of the gradient origin relative to the gradient ellipse's center. 	
        /// </summary>	
        /// <returns>The offset of the gradient origin from the center of the gradient ellipse. This value is expressed in the brush's coordinate space.</returns>
        /// <unmanaged>D2D1_POINT_2F ID2D1RadialGradientBrush::GetGradientOriginOffset()</unmanaged>
        internal System.Drawing.PointF GetGradientOriginOffset() {
            unsafe {
                System.Drawing.PointF __result__;
                SlimDX2.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, 13 * 4,(void*)&__result__);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the x-radius of the gradient ellipse. 	
        /// </summary>	
        /// <returns>FLOATThe x-radius of the gradient ellipse. This value is expressed in the brush's coordinate space.</returns>
        /// <unmanaged>FLOAT ID2D1RadialGradientBrush::GetRadiusX()</unmanaged>
        internal float GetRadiusX() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct2D1.LocalInterop.Callifloat(_nativePointer, 14 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the y-radius of the gradient ellipse. 	
        /// </summary>	
        /// <returns>FLOATThe y-radius of the gradient ellipse. This value is expressed in the brush's coordinate space.</returns>
        /// <unmanaged>FLOAT ID2D1RadialGradientBrush::GetRadiusY()</unmanaged>
        internal float GetRadiusY() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct2D1.LocalInterop.Callifloat(_nativePointer, 15 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the <see cref="SlimDX2.Direct2D1.GradientStopCollection"/> associated with this radial gradient brush object.	
        /// </summary>	
        /// <remarks>	
        /// <see cref="SlimDX2.Direct2D1.GradientStopCollection"/> contains an array of <see cref="SlimDX2.Direct2D1.GradientStop"/> structures and additional information, such as the extend mode and the color interpolation mode.	
        /// </remarks>	
        /// <param name="gradientStopCollection">The  <see cref="SlimDX2.Direct2D1.GradientStopCollection"/> object associated with this linear gradient brush object. This parameter is passed uninitialized.</param>
        /// <unmanaged>void ID2D1RadialGradientBrush::GetGradientStopCollection([Out] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>
        internal void GetGradientStopCollection(out SlimDX2.Direct2D1.GradientStopCollection gradientStopCollection) {
            unsafe {
                IntPtr gradientStopCollection_ = IntPtr.Zero;
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 16 * 4, &gradientStopCollection_);
                gradientStopCollection = (gradientStopCollection_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.GradientStopCollection(gradientStopCollection_);	
            }
        }
    }
    
    /// <summary>	
    /// Describes the caps, miter limit, line join, and dash information for a stroke.	
    /// </summary>	
    /// <unmanaged>ID2D1StrokeStyle</unmanaged>
    [Guid("2cd9069d-12e2-11dc-9fed-001143a055f9")]
    public partial class StrokeStyle : SlimDX2.Direct2D1.Resource {
        public StrokeStyle(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Retrieves the type of shape used at the beginning of a stroke.  	
        /// </summary>	
        /// <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetStartCap()</unmanaged>
        public SlimDX2.Direct2D1.CapStyle StartCap {
                get { return GetStartCap(); }
        }
        
        /// <summary>	
        /// Retrieves the type of shape used at the end of a stroke. 	
        /// </summary>	
        /// <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetEndCap()</unmanaged>
        public SlimDX2.Direct2D1.CapStyle EndCap {
                get { return GetEndCap(); }
        }
        
        /// <summary>	
        /// Gets a value that specifies how the ends of each dash are drawn. 	
        /// </summary>	
        /// <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetDashCap()</unmanaged>
        public SlimDX2.Direct2D1.CapStyle DashCap {
                get { return GetDashCap(); }
        }
        
        /// <summary>	
        /// Retrieves the limit on the ratio of the miter length to half the stroke's thickness. 	
        /// </summary>	
        /// <unmanaged>FLOAT ID2D1StrokeStyle::GetMiterLimit()</unmanaged>
        public float MiterLimit {
                get { return GetMiterLimit(); }
        }
        
        /// <summary>	
        /// Retrieves the type of joint used at the vertices of a shape's outline.  	
        /// </summary>	
        /// <unmanaged>D2D1_LINE_JOIN ID2D1StrokeStyle::GetLineJoin()</unmanaged>
        public SlimDX2.Direct2D1.LineJoin LineJoin {
                get { return GetLineJoin(); }
        }
        
        /// <summary>	
        /// Retrieves a value that specifies how far in the dash sequence the stroke will start.  	
        /// </summary>	
        /// <unmanaged>FLOAT ID2D1StrokeStyle::GetDashOffset()</unmanaged>
        public float DashOffset {
                get { return GetDashOffset(); }
        }
        
        /// <summary>	
        /// Gets a value that describes the stroke's dash pattern. 	
        /// </summary>	
        /// <remarks>	
        /// If a custom dash style is specified, the dash pattern is described by the dashes array, which can be retrieved by calling the {{GetDashes}} method.	
        /// </remarks>	
        /// <unmanaged>D2D1_DASH_STYLE ID2D1StrokeStyle::GetDashStyle()</unmanaged>
        public SlimDX2.Direct2D1.DashStyle DashStyle {
                get { return GetDashStyle(); }
        }
        
        /// <summary>	
        /// Retrieves the number of entries in the dashes array. 	
        /// </summary>	
        /// <unmanaged>UINT32 ID2D1StrokeStyle::GetDashesCount()</unmanaged>
        public int DashesCount {
                get { return GetDashesCount(); }
        }
        
        /// <summary>	
        ///  Retrieves the type of shape used at the beginning of a stroke.  	
        /// </summary>	
        /// <returns>The type of shape used at the beginning of a stroke.</returns>
        /// <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetStartCap()</unmanaged>
        internal SlimDX2.Direct2D1.CapStyle GetStartCap() {
            unsafe {
                SlimDX2.Direct2D1.CapStyle __result__;
                __result__= (SlimDX2.Direct2D1.CapStyle)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the type of shape used at the end of a stroke. 	
        /// </summary>	
        /// <returns>The type of shape used at the end of a stroke.</returns>
        /// <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetEndCap()</unmanaged>
        internal SlimDX2.Direct2D1.CapStyle GetEndCap() {
            unsafe {
                SlimDX2.Direct2D1.CapStyle __result__;
                __result__= (SlimDX2.Direct2D1.CapStyle)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a value that specifies how the ends of each dash are drawn. 	
        /// </summary>	
        /// <returns>A value that specifies how the ends of each dash are drawn.</returns>
        /// <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetDashCap()</unmanaged>
        internal SlimDX2.Direct2D1.CapStyle GetDashCap() {
            unsafe {
                SlimDX2.Direct2D1.CapStyle __result__;
                __result__= (SlimDX2.Direct2D1.CapStyle)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the limit on the ratio of the miter length to half the stroke's thickness. 	
        /// </summary>	
        /// <returns>FLOATA positive number greater than or equal to 1.0f that describes the limit on the ratio of the miter length to half the stroke's thickness.</returns>
        /// <unmanaged>FLOAT ID2D1StrokeStyle::GetMiterLimit()</unmanaged>
        internal float GetMiterLimit() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct2D1.LocalInterop.Callifloat(_nativePointer, 7 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the type of joint used at the vertices of a shape's outline.  	
        /// </summary>	
        /// <returns>A value that specifies the type of joint used at the vertices of a shape's outline.</returns>
        /// <unmanaged>D2D1_LINE_JOIN ID2D1StrokeStyle::GetLineJoin()</unmanaged>
        internal SlimDX2.Direct2D1.LineJoin GetLineJoin() {
            unsafe {
                SlimDX2.Direct2D1.LineJoin __result__;
                __result__= (SlimDX2.Direct2D1.LineJoin)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 8 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves a value that specifies how far in the dash sequence the stroke will start.  	
        /// </summary>	
        /// <returns>FLOATA value that specifies how far in the dash sequence the stroke will start. </returns>
        /// <unmanaged>FLOAT ID2D1StrokeStyle::GetDashOffset()</unmanaged>
        internal float GetDashOffset() {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Direct2D1.LocalInterop.Callifloat(_nativePointer, 9 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets a value that describes the stroke's dash pattern. 	
        /// </summary>	
        /// <remarks>	
        /// If a custom dash style is specified, the dash pattern is described by the dashes array, which can be retrieved by calling the {{GetDashes}} method.	
        /// </remarks>	
        /// <returns>A value that describes the predefined dash pattern used, or <see cref="SlimDX2.Direct2D1.DashStyle.Custom"/> if a custom dash style is used.</returns>
        /// <unmanaged>D2D1_DASH_STYLE ID2D1StrokeStyle::GetDashStyle()</unmanaged>
        internal SlimDX2.Direct2D1.DashStyle GetDashStyle() {
            unsafe {
                SlimDX2.Direct2D1.DashStyle __result__;
                __result__= (SlimDX2.Direct2D1.DashStyle)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 10 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of entries in the dashes array. 	
        /// </summary>	
        /// <returns>UINT32The number of entries in the dashes array if the stroke is dashed; otherwise, 0.</returns>
        /// <unmanaged>UINT32 ID2D1StrokeStyle::GetDashesCount()</unmanaged>
        internal int GetDashesCount() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 11 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copies the dash pattern to the specified array. 	
        /// </summary>	
        /// <remarks>	
        /// The dashes are specified in units that are a multiple of the stroke width, with subsequent members of the array indicating the dashes and gaps between dashes: the first entry indicates a filled dash, the second a gap, and so on. 	
        /// </remarks>	
        /// <param name="dashes">A pointer to an array that will receive the dash pattern. The array must be able to contain at least as many elements as specified by dashesCount. You must allocate storage for this array.</param>
        /// <param name="dashesCount">The number of dashes to copy. If this value is less than the number of dashes in the stroke style's dashes array, the returned dashes are truncated to dashesCount. If this value is greater than the number of dashes in the stroke style's dashes array, the extra dashes are set to 0.0f. To obtain the actual number of dashes in the stroke style's dashes array, use the {{GetDashesCount}} method. </param>
        /// <unmanaged>void ID2D1StrokeStyle::GetDashes([Out, Buffer] FLOAT* dashes,[None] UINT dashesCount)</unmanaged>
        public void GetDashes(float[] dashes, int dashesCount) {
            unsafe {
                fixed (void* dashes_ = &dashes[0])
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 12 * 4, dashes_, dashesCount);
            }
        }
    }
    
    /// <summary>	
    /// Represents a geometry resource and defines a set of helper methods for manipulating and measuring geometric shapes.  Interfaces that inherit from ID2D1Geometry define specific shapes.	
    /// </summary>	
    /// <unmanaged>ID2D1Geometry</unmanaged>
    [Guid("2cd906a1-12e2-11dc-9fed-001143a055f9")]
    public partial class Geometry : SlimDX2.Direct2D1.Resource {
        public Geometry(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the bounds of the geometry.	
        /// </summary>	
        /// <param name="worldTransform">The transform to apply to this geometry before calculating its bounds, or NULL.</param>
        /// <param name="bounds">When this method returns, contains the bounds of this geometry. If the bounds are empty, this will be a rect where bounds.left &gt; bounds.right. You must allocate storage for this parameter.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Geometry::GetBounds([In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[Out] D2D1_RECT_F* bounds)</unmanaged>
        public SlimDX2.Result GetBounds(SlimDX2.Direct2D1.Matrix3x2? worldTransform, out SlimDX2.RectangleF bounds) {
            unsafe {
                SlimDX2.Direct2D1.Matrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;				
                bounds = new SlimDX2.RectangleF();
                SlimDX2.Result __result__;
                fixed (void* bounds_ = &bounds)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, (worldTransform.HasValue)?&worldTransform_:(void*)IntPtr.Zero, bounds_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the bounds of the geometry after it has been widened by the specified stroke width and style and transformed by the specified matrix.	
        /// </summary>	
        /// <param name="strokeWidth">The amount by which to widen the geometry by stroking its outline.</param>
        /// <param name="strokeStyle">The style of the stroke that widens the geometry.</param>
        /// <param name="worldTransform">A transform to apply to the geometry after the geometry is transformed and after the geometry has been stroked, or NULL.</param>
        /// <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution. </param>
        /// <param name="bounds">When this method returns, contains the bounds of the widened geometry. You must allocate storage for this parameter.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Geometry::GetWidenedBounds([None] FLOAT strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[Out] D2D1_RECT_F* bounds)</unmanaged>
        public SlimDX2.Result GetWidenedBounds(float strokeWidth, SlimDX2.Direct2D1.StrokeStyle strokeStyle, SlimDX2.Direct2D1.Matrix3x2? worldTransform, float flatteningTolerance, out SlimDX2.RectangleF bounds) {
            unsafe {
                SlimDX2.Direct2D1.Matrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;				
                bounds = new SlimDX2.RectangleF();
                SlimDX2.Result __result__;
                fixed (void* bounds_ = &bounds)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4, strokeWidth, (void*)((strokeStyle == null)?IntPtr.Zero:strokeStyle.NativePointer), (worldTransform.HasValue)?&worldTransform_:(void*)IntPtr.Zero, flatteningTolerance, bounds_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Determines whether the geometry's stroke contains the specified point given the specified stroke thickness, style, and transform. 	
        /// </summary>	
        /// <param name="point">The point to test for containment.</param>
        /// <param name="strokeWidth">The thickness of the stroke to apply.</param>
        /// <param name="strokeStyle">The style of stroke to apply.</param>
        /// <param name="worldTransform">The transform to apply to the stroked geometry. </param>
        /// <param name="flatteningTolerance">The numeric accuracy with which the precise geometric path and path intersection is calculated. Points missing the stroke by less than the tolerance are still considered inside.  Smaller values produce more accurate results but cause slower execution.</param>
        /// <param name="contains">When this method returns, contains a boolean value set to true if the geometry's stroke contains the specified point; otherwise, false. You must allocate storage for this parameter.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Geometry::StrokeContainsPoint([None] D2D1_POINT_2F point,[None] FLOAT strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[Out] BOOL* contains)</unmanaged>
        public SlimDX2.Result StrokeContainsPoint(System.Drawing.PointF point, float strokeWidth, SlimDX2.Direct2D1.StrokeStyle strokeStyle, SlimDX2.Direct2D1.Matrix3x2? worldTransform, float flatteningTolerance, out bool contains) {
            unsafe {
                SlimDX2.Direct2D1.Matrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;				
                SlimDX2.Result __result__;
                fixed (void* contains_ = &contains)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4, point, strokeWidth, (void*)((strokeStyle == null)?IntPtr.Zero:strokeStyle.NativePointer), (worldTransform.HasValue)?&worldTransform_:(void*)IntPtr.Zero, flatteningTolerance, contains_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Indicates whether the area filled by the geometry would contain the specified point given the specified flattening tolerance. 	
        /// </summary>	
        /// <param name="point">The point to test.</param>
        /// <param name="worldTransform">The transform to apply to the geometry prior to testing for containment, or NULL.</param>
        /// <param name="flatteningTolerance">The numeric accuracy with which the precise geometric path and path intersection is calculated. Points missing the fill by less than the tolerance are still considered inside.  Smaller values produce more accurate results but cause slower execution. </param>
        /// <param name="contains">When this method returns, contains a bool value that is true if the area filled by the geometry contains point; otherwise, false.You must allocate storage for this parameter.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Geometry::FillContainsPoint([None] D2D1_POINT_2F point,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[Out] BOOL* contains)</unmanaged>
        public SlimDX2.Result FillContainsPoint(System.Drawing.PointF point, SlimDX2.Direct2D1.Matrix3x2? worldTransform, float flatteningTolerance, out bool contains) {
            unsafe {
                SlimDX2.Direct2D1.Matrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;				
                SlimDX2.Result __result__;
                fixed (void* contains_ = &contains)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 7 * 4, point, (worldTransform.HasValue)?&worldTransform_:(void*)IntPtr.Zero, flatteningTolerance, contains_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Describes the intersection between this geometry and the specified geometry. The comparison is performed by using the specified flattening tolerance.	
        /// </summary>	
        /// <remarks>	
        /// When interpreting the returned relation value, it is important to remember that the member <see cref="SlimDX2.Direct2D1.GeometryRelation.IsContained"/> of the  D2D1_GEOMETRY_RELATION enumeration type means that this geometry is contained  inside inputGeometry, not that this geometry contains inputGeometry. For  more information about how to interpret other possible return values, see <see cref="SlimDX2.Direct2D1.GeometryRelation"/>.	
        /// </remarks>	
        /// <param name="inputGeometry">The geometry to test. </param>
        /// <param name="inputGeometryTransform">The transform to apply to inputGeometry, or NULL.</param>
        /// <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometries. Smaller values produce more accurate results but cause slower execution. </param>
        /// <param name="relation">When this method returns, contains a pointer to a value that describes how this geometry is related to inputGeometry. You must allocate storage for this parameter.  </param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Geometry::CompareWithGeometry([In] ID2D1Geometry* inputGeometry,[In, Optional] const D2D1_MATRIX_3X2_F* inputGeometryTransform,[None] FLOAT flatteningTolerance,[Out] D2D1_GEOMETRY_RELATION* relation)</unmanaged>
        public SlimDX2.Result CompareWithGeometry(SlimDX2.Direct2D1.Geometry inputGeometry, SlimDX2.Direct2D1.Matrix3x2? inputGeometryTransform, float flatteningTolerance, out SlimDX2.Direct2D1.GeometryRelation relation) {
            unsafe {
                SlimDX2.Direct2D1.Matrix3x2 inputGeometryTransform_;
                if (inputGeometryTransform.HasValue)
                    inputGeometryTransform_ = inputGeometryTransform.Value;				
                SlimDX2.Result __result__;
                fixed (void* relation_ = &relation)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 8 * 4, (void*)((inputGeometry == null)?IntPtr.Zero:inputGeometry.NativePointer), (inputGeometryTransform.HasValue)?&inputGeometryTransform_:(void*)IntPtr.Zero, flatteningTolerance, relation_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a simplified version of the geometry that contains only lines and (optionally) cubic Bezier curves and writes the result to an <see cref="SlimDX2.Direct2D1.SimplifiedGeometrySink"/>.	
        /// </summary>	
        /// <param name="simplificationOption">A value that specifies whether the simplified geometry should contain curves.</param>
        /// <param name="worldTransform">The transform to apply to the simplified geometry, or NULL.</param>
        /// <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution. </param>
        /// <param name="geometrySink"> The <see cref="SlimDX2.Direct2D1.SimplifiedGeometrySink"/> to which the simplified geometry is appended. </param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Geometry::Simplify([None] D2D1_GEOMETRY_SIMPLIFICATION_OPTION simplificationOption,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        internal SlimDX2.Result Simplify_(SlimDX2.Direct2D1.GeometrySimplificationOption simplificationOption, SlimDX2.Direct2D1.Matrix3x2? worldTransform, float flatteningTolerance, IntPtr geometrySink) {
            unsafe {
                SlimDX2.Direct2D1.Matrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;				
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 9 * 4, unchecked((int)simplificationOption), (worldTransform.HasValue)?&worldTransform_:(void*)IntPtr.Zero, flatteningTolerance, (void*)geometrySink);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a set of clockwise-wound triangles that cover the geometry after it has been transformed using the specified matrix and flattened using the specified tolerance. 	
        /// </summary>	
        /// <param name="worldTransform">The transform to apply to this geometry, or NULL.</param>
        /// <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution. </param>
        /// <param name="tessellationSink">The <see cref="SlimDX2.Direct2D1.TessellationSink"/> to which the tessellated is appended.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Geometry::Tessellate([In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[In] ID2D1TessellationSink* tessellationSink)</unmanaged>
        internal SlimDX2.Result Tessellate_(SlimDX2.Direct2D1.Matrix3x2? worldTransform, float flatteningTolerance, IntPtr tessellationSink) {
            unsafe {
                SlimDX2.Direct2D1.Matrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;				
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 10 * 4, (worldTransform.HasValue)?&worldTransform_:(void*)IntPtr.Zero, flatteningTolerance, (void*)tessellationSink);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Combines this geometry with the specified geometry and stores the result in an <see cref="SlimDX2.Direct2D1.SimplifiedGeometrySink"/>.  	
        /// </summary>	
        /// <param name="inputGeometry">The geometry to combine with this instance.</param>
        /// <param name="combineMode">The type of combine operation to perform.</param>
        /// <param name="inputGeometryTransform">The transform to apply to inputGeometry before combining, or NULL.</param>
        /// <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometries. Smaller values produce more accurate results but cause slower execution. </param>
        /// <param name="geometrySink">The result of the combine operation.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Geometry::CombineWithGeometry([In] ID2D1Geometry* inputGeometry,[None] D2D1_COMBINE_MODE combineMode,[In, Optional] const D2D1_MATRIX_3X2_F* inputGeometryTransform,[None] FLOAT flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        internal SlimDX2.Result CombineWithGeometry_(SlimDX2.Direct2D1.Geometry inputGeometry, SlimDX2.Direct2D1.CombineMode combineMode, SlimDX2.Direct2D1.Matrix3x2? inputGeometryTransform, float flatteningTolerance, IntPtr geometrySink) {
            unsafe {
                SlimDX2.Direct2D1.Matrix3x2 inputGeometryTransform_;
                if (inputGeometryTransform.HasValue)
                    inputGeometryTransform_ = inputGeometryTransform.Value;				
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 11 * 4, (void*)((inputGeometry == null)?IntPtr.Zero:inputGeometry.NativePointer), unchecked((int)combineMode), (inputGeometryTransform.HasValue)?&inputGeometryTransform_:(void*)IntPtr.Zero, flatteningTolerance, (void*)geometrySink);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Computes the outline of the geometry and writes the result to an <see cref="SlimDX2.Direct2D1.SimplifiedGeometrySink"/>.	
        /// </summary>	
        /// <remarks>	
        /// The {{Outline}} method allows the caller to produce a geometry with an equivalent fill to the input geometry, with the following additional properties: The output geometry contains no transverse intersections; that is, segments may touch, but they never cross.The outermost figures in the output geometry are all oriented counterclockwise. The output geometry is fill-mode invariant; that is, the fill of the geometry does not depend on the choice of the fill mode. For more information about the fill mode, see <see cref="SlimDX2.Direct2D1.FillMode"/>.Additionally, the  {{Outline}} method can be useful in removing redundant portions of said geometries to simplify complex geometries. It can also be useful in combination with <see cref="SlimDX2.Direct2D1.GeometryGroup"/> to create unions among several geometries simultaneously.	
        /// </remarks>	
        /// <param name="worldTransform">The transform to apply to the geometry outline, or NULL.</param>
        /// <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution. </param>
        /// <param name="geometrySink">The <see cref="SlimDX2.Direct2D1.SimplifiedGeometrySink"/> to which the geometry's transformed outline is appended. </param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Geometry::Outline([In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        internal SlimDX2.Result Outline_(SlimDX2.Direct2D1.Matrix3x2? worldTransform, float flatteningTolerance, IntPtr geometrySink) {
            unsafe {
                SlimDX2.Direct2D1.Matrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;				
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 12 * 4, (worldTransform.HasValue)?&worldTransform_:(void*)IntPtr.Zero, flatteningTolerance, (void*)geometrySink);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Computes the area of the geometry after it has been transformed by the specified matrix and flattened using the specified tolerance.	
        /// </summary>	
        /// <param name="worldTransform">The transform to apply to this geometry before computing its area, or NULL.</param>
        /// <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution. </param>
        /// <param name="area">When this this method returns, contains a pointer to the area of the transformed, flattened version of this geometry. You must allocate storage for this parameter.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Geometry::ComputeArea([In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[Out] FLOAT* area)</unmanaged>
        public SlimDX2.Result ComputeArea(SlimDX2.Direct2D1.Matrix3x2? worldTransform, float flatteningTolerance, out float area) {
            unsafe {
                SlimDX2.Direct2D1.Matrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;				
                SlimDX2.Result __result__;
                fixed (void* area_ = &area)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 13 * 4, (worldTransform.HasValue)?&worldTransform_:(void*)IntPtr.Zero, flatteningTolerance, area_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Calculates the length of the geometry as though each segment were unrolled into a line. 	
        /// </summary>	
        /// <param name="worldTransform">The transform to apply to the geometry before calculating its length, or NULL.</param>
        /// <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution. </param>
        /// <param name="length">When this method returns, contains a pointer to the length of the geometry. For closed geometries, the length includes an implicit closing segment. You must allocate storage for this parameter.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Geometry::ComputeLength([In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[Out] FLOAT* length)</unmanaged>
        public SlimDX2.Result ComputeLength(SlimDX2.Direct2D1.Matrix3x2? worldTransform, float flatteningTolerance, out float length) {
            unsafe {
                SlimDX2.Direct2D1.Matrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;				
                SlimDX2.Result __result__;
                fixed (void* length_ = &length)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 14 * 4, (worldTransform.HasValue)?&worldTransform_:(void*)IntPtr.Zero, flatteningTolerance, length_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Calculates the point and tangent vector at the specified distance along the geometry after it has been transformed by the specified matrix and flattened using the specified tolerance.	
        /// </summary>	
        /// <param name="length">The distance along the geometry of the point and tangent to find. If this distance is less then 0, this method calculates the first point in the geometry. If this distance is greater than the length of the geometry, this method calculates the last point in the geometry.</param>
        /// <param name="worldTransform">The transform to apply to the geometry before calculating the specified point and tangent, or NULL.</param>
        /// <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
        /// <param name="ointRef">The location at the specified distance along the geometry. If the geometry is empty,  this point contains NaN as its x and y values.</param>
        /// <param name="unitTangentVector">Whenthis method returns, contains a pointer to the tangent vector at the specified distance along the geometry. If the geometry is empty,  this vector contains NaN as its x and y values. You must allocate storage for this parameter.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Geometry::ComputePointAtLength([None] FLOAT length,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[Out, Optional] D2D1_POINT_2F* point,[Out, Optional] D2D1_POINT_2F* unitTangentVector)</unmanaged>
        public SlimDX2.Result ComputePointAtLength(float length, SlimDX2.Direct2D1.Matrix3x2? worldTransform, float flatteningTolerance, out System.Drawing.PointF ointRef, out System.Drawing.PointF unitTangentVector) {
            unsafe {
                SlimDX2.Direct2D1.Matrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;				
                ointRef = new System.Drawing.PointF();
                unitTangentVector = new System.Drawing.PointF();
                SlimDX2.Result __result__;
                fixed (void* ointRef_ = &ointRef)
                    fixed (void* unitTangentVector_ = &unitTangentVector)
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 15 * 4, length, (worldTransform.HasValue)?&worldTransform_:(void*)IntPtr.Zero, flatteningTolerance, ointRef_, unitTangentVector_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Widens the geometry by the specified stroke and writes the result to an <see cref="SlimDX2.Direct2D1.SimplifiedGeometrySink"/> after it has been transformed by the specified matrix and flattened using the specified tolerance.	
        /// </summary>	
        /// <param name="strokeWidth">The amount by which to widen the geometry.</param>
        /// <param name="strokeStyle">The style of stroke to apply to the geometry, or NULL.</param>
        /// <param name="worldTransform">The transform to apply to the geometry after widening it, or NULL.</param>
        /// <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
        /// <param name="geometrySink">The <see cref="SlimDX2.Direct2D1.SimplifiedGeometrySink"/> to which the widened geometry is appended.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Geometry::Widen([None] FLOAT strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        internal SlimDX2.Result Widen_(float strokeWidth, SlimDX2.Direct2D1.StrokeStyle strokeStyle, SlimDX2.Direct2D1.Matrix3x2? worldTransform, float flatteningTolerance, IntPtr geometrySink) {
            unsafe {
                SlimDX2.Direct2D1.Matrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;				
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 16 * 4, strokeWidth, (void*)((strokeStyle == null)?IntPtr.Zero:strokeStyle.NativePointer), (worldTransform.HasValue)?&worldTransform_:(void*)IntPtr.Zero, flatteningTolerance, (void*)geometrySink);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Describes a two-dimensional rectangle.  	
    /// </summary>	
    /// <unmanaged>ID2D1RectangleGeometry</unmanaged>
    [Guid("2cd906a2-12e2-11dc-9fed-001143a055f9")]
    public partial class RectangleGeometry : SlimDX2.Direct2D1.Geometry {
        public RectangleGeometry(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Retrieves the rectangle that describes the rectangle geometry's dimensions.	
        /// </summary>	
        /// <unmanaged>void ID2D1RectangleGeometry::GetRect([Out] D2D1_RECT_F* rect)</unmanaged>
        public SlimDX2.RectangleF Rect {
                get { SlimDX2.RectangleF __output__; GetRect(out __output__); return __output__; }
        }
        
        /// <summary>	
        ///  Retrieves the rectangle that describes the rectangle geometry's dimensions.	
        /// </summary>	
        /// <param name="rect">Contains a pointer to a rectangle that describes the rectangle geometry's dimensions when this method returns. You must allocate storage for this parameter. </param>
        /// <unmanaged>void ID2D1RectangleGeometry::GetRect([Out] D2D1_RECT_F* rect)</unmanaged>
        internal void GetRect(out SlimDX2.RectangleF rect) {
            unsafe {
                rect = new SlimDX2.RectangleF();
                fixed (void* rect_ = &rect)
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 17 * 4, rect_);
            }
        }
    }
    
    /// <summary>	
    /// Describes a rounded rectangle. 	
    /// </summary>	
    /// <unmanaged>ID2D1RoundedRectangleGeometry</unmanaged>
    [Guid("2cd906a3-12e2-11dc-9fed-001143a055f9")]
    public partial class RoundedRectangleGeometry : SlimDX2.Direct2D1.Geometry {
        public RoundedRectangleGeometry(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves a rounded rectangle that describes this rounded rectangle geometry. 	
        /// </summary>	
        /// <unmanaged>void ID2D1RoundedRectangleGeometry::GetRoundedRect([Out] D2D1_ROUNDED_RECT* roundedRect)</unmanaged>
        public SlimDX2.Direct2D1.RoundedRect RoundedRect {
                get { SlimDX2.Direct2D1.RoundedRect __output__; GetRoundedRect(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves a rounded rectangle that describes this rounded rectangle geometry. 	
        /// </summary>	
        /// <param name="roundedRect">A pointer that receives a rounded rectangle that describes this rounded rectangle geometry. You must allocate storage for this parameter. </param>
        /// <unmanaged>void ID2D1RoundedRectangleGeometry::GetRoundedRect([Out] D2D1_ROUNDED_RECT* roundedRect)</unmanaged>
        internal void GetRoundedRect(out SlimDX2.Direct2D1.RoundedRect roundedRect) {
            unsafe {
                roundedRect = new SlimDX2.Direct2D1.RoundedRect();
                fixed (void* roundedRect_ = &roundedRect)
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 17 * 4, roundedRect_);
            }
        }
    }
    
    /// <summary>	
    /// Represents an ellipse. 	
    /// </summary>	
    /// <unmanaged>ID2D1EllipseGeometry</unmanaged>
    [Guid("2cd906a4-12e2-11dc-9fed-001143a055f9")]
    public partial class EllipseGeometry : SlimDX2.Direct2D1.Geometry {
        public EllipseGeometry(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the <see cref="SlimDX2.Direct2D1.Ellipse"/> structure that describes this ellipse geometry. 	
        /// </summary>	
        /// <unmanaged>void ID2D1EllipseGeometry::GetEllipse([Out] D2D1_ELLIPSE* ellipse)</unmanaged>
        public SlimDX2.Direct2D1.Ellipse Ellipse {
                get { SlimDX2.Direct2D1.Ellipse __output__; GetEllipse(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the <see cref="SlimDX2.Direct2D1.Ellipse"/> structure that describes this ellipse geometry. 	
        /// </summary>	
        /// <param name="ellipse">When this method returns, contains the <see cref="SlimDX2.Direct2D1.Ellipse"/> that describes the size and position of the ellipse. You must allocate storage for this parameter.</param>
        /// <unmanaged>void ID2D1EllipseGeometry::GetEllipse([Out] D2D1_ELLIPSE* ellipse)</unmanaged>
        internal void GetEllipse(out SlimDX2.Direct2D1.Ellipse ellipse) {
            unsafe {
                ellipse = new SlimDX2.Direct2D1.Ellipse();
                fixed (void* ellipse_ = &ellipse)
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 17 * 4, ellipse_);
            }
        }
    }
    
    /// <summary>	
    /// Represents a composite geometry, composed of other <see cref="SlimDX2.Direct2D1.Geometry"/> objects. 	
    /// </summary>	
    /// <unmanaged>ID2D1GeometryGroup</unmanaged>
    [Guid("2cd906a6-12e2-11dc-9fed-001143a055f9")]
    public partial class GeometryGroup : SlimDX2.Direct2D1.Geometry {
        public GeometryGroup(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Indicates how the intersecting areas of the geometries contained in this geometry group are combined.	
        /// </summary>	
        /// <unmanaged>D2D1_FILL_MODE ID2D1GeometryGroup::GetFillMode()</unmanaged>
        public SlimDX2.Direct2D1.FillMode FillMode {
                get { return GetFillMode(); }
        }
        
        /// <summary>	
        /// Indicates the number of geometry objects in the geometry group. 	
        /// </summary>	
        /// <unmanaged>UINT32 ID2D1GeometryGroup::GetSourceGeometryCount()</unmanaged>
        public int SourceGeometryCount {
                get { return GetSourceGeometryCount(); }
        }
        
        /// <summary>	
        /// Indicates how the intersecting areas of the geometries contained in this geometry group are combined.	
        /// </summary>	
        /// <returns> A value that indicates how the intersecting areas of the geometries contained in this geometry group are combined.  </returns>
        /// <unmanaged>D2D1_FILL_MODE ID2D1GeometryGroup::GetFillMode()</unmanaged>
        internal SlimDX2.Direct2D1.FillMode GetFillMode() {
            unsafe {
                SlimDX2.Direct2D1.FillMode __result__;
                __result__= (SlimDX2.Direct2D1.FillMode)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 17 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Indicates the number of geometry objects in the geometry group. 	
        /// </summary>	
        /// <returns>UINT32The number of geometries in the <see cref="SlimDX2.Direct2D1.GeometryGroup"/>.</returns>
        /// <unmanaged>UINT32 ID2D1GeometryGroup::GetSourceGeometryCount()</unmanaged>
        internal int GetSourceGeometryCount() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 18 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the geometries in the geometry group. 	
        /// </summary>	
        /// <remarks>	
        /// The returned geometries are referenced and  counted, and the caller must release them.	
        /// </remarks>	
        /// <param name="geometries">When this method returns, contains the address of a pointer to an array of geometries to be filled by this method. The length of the array is specified by the geometryCount parameter. If the array is NULL, then this method performs no operation. You must allocate the memory for this array.</param>
        /// <param name="geometriesCount">A value indicating the number of geometries to return in the geometries array. If this value is less than the number of geometries in the geometry group, the remaining geometries are omitted. If this value is larger than the number of geometries in the geometry group, the extra geometries are set to NULL. To obtain the number of geometries currently in the geometry group, use the {{GetSourceGeometryCount}} method.</param>
        /// <unmanaged>void ID2D1GeometryGroup::GetSourceGeometries([Out, Buffer] ID2D1Geometry** geometries,[None] UINT geometriesCount)</unmanaged>
        public void GetSourceGeometries(SlimDX2.Direct2D1.Geometry[] geometries, int geometriesCount) {
            unsafe {
                IntPtr* geometries_ = stackalloc IntPtr[geometries.Length];
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 19 * 4, &geometries_, geometriesCount);
                for (int i = 0; i < geometries.Length; i++)
                    geometries[i] = (geometries_[i] == IntPtr.Zero)?null:new SlimDX2.Direct2D1.Geometry(geometries_[i]);	
            }
        }
    }
    
    /// <summary>	
    /// Represents a geometry that has been transformed. 	
    /// </summary>	
    /// <unmanaged>ID2D1TransformedGeometry</unmanaged>
    [Guid("2cd906bb-12e2-11dc-9fed-001143a055f9")]
    public partial class TransformedGeometry : SlimDX2.Direct2D1.Geometry {
        public TransformedGeometry(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the source geometry of this transformed geometry object. 	
        /// </summary>	
        /// <unmanaged>void ID2D1TransformedGeometry::GetSourceGeometry([Out] ID2D1Geometry** sourceGeometry)</unmanaged>
        public SlimDX2.Direct2D1.Geometry SourceGeometry {
                get { SlimDX2.Direct2D1.Geometry __output__; GetSourceGeometry(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the matrix used to transform the <see cref="SlimDX2.Direct2D1.TransformedGeometry"/> object's source geometry. 	
        /// </summary>	
        /// <unmanaged>void ID2D1TransformedGeometry::GetTransform([Out] D2D1_MATRIX_3X2_F* transform)</unmanaged>
        public SlimDX2.Direct2D1.Matrix3x2 Transform {
                get { SlimDX2.Direct2D1.Matrix3x2 __output__; GetTransform(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the source geometry of this transformed geometry object. 	
        /// </summary>	
        /// <param name="sourceGeometry">When this method returns, contains a pointer to a pointer to the source geometry for this transformed geometry object. This parameter is passed uninitialized.</param>
        /// <unmanaged>void ID2D1TransformedGeometry::GetSourceGeometry([Out] ID2D1Geometry** sourceGeometry)</unmanaged>
        internal void GetSourceGeometry(out SlimDX2.Direct2D1.Geometry sourceGeometry) {
            unsafe {
                IntPtr sourceGeometry_ = IntPtr.Zero;
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 17 * 4, &sourceGeometry_);
                sourceGeometry = (sourceGeometry_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.Geometry(sourceGeometry_);	
            }
        }
        
        /// <summary>	
        /// Retrieves the matrix used to transform the <see cref="SlimDX2.Direct2D1.TransformedGeometry"/> object's source geometry. 	
        /// </summary>	
        /// <param name="transform">A pointer that receives the matrix used to transform the <see cref="SlimDX2.Direct2D1.TransformedGeometry"/> object's source geometry. You must allocate storage for this parameter.  </param>
        /// <unmanaged>void ID2D1TransformedGeometry::GetTransform([Out] D2D1_MATRIX_3X2_F* transform)</unmanaged>
        internal void GetTransform(out SlimDX2.Direct2D1.Matrix3x2 transform) {
            unsafe {
                transform = new SlimDX2.Direct2D1.Matrix3x2();
                fixed (void* transform_ = &transform)
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 18 * 4, transform_);
            }
        }
    }
    
    /// <summary>	
    ///  Describes a geometric path that does not contain quadratic bezier curves or arcs. 	
    /// </summary>	
    /// <unmanaged>ID2D1SimplifiedGeometrySink</unmanaged>
    [Guid("2cd9069e-12e2-11dc-9fed-001143a055f9")]
    public partial interface SimplifiedGeometrySink {
        
        
        /// <summary>	
        /// Specifies the method used to determine which points are inside the geometry described by this geometry sink  and which points are outside.  	
        /// </summary>	
        /// <remarks>	
        /// The fill mode defaults to D2D1_FILL_MODE_ALTERNATE. To set the fill mode, call SetFillMode before the first call to {{BeginFigure}}. Not doing will put the geometry sink in an error state. 	
        /// </remarks>	
        /// <param name="fillMode">The method used to determine whether a given point is part of the geometry.</param>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::SetFillMode([None] D2D1_FILL_MODE fillMode)</unmanaged>
        /* public void SetFillMode(SlimDX2.Direct2D1.FillMode fillMode) */

        
        /// <summary>	
        /// Specifies stroke and join options to be applied to new segments added to the geometry sink. 	
        /// </summary>	
        /// <remarks>	
        /// After this method is called, the specified segment flags are applied to each segment subsequently added to the sink. The segment flags are applied to every additional segment until this method is called again and a different set of segment flags is specified.     	
        /// </remarks>	
        /// <param name="vertexFlags">Stroke and join options to be applied to new segments added to the geometry sink.</param>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::SetSegmentFlags([None] D2D1_PATH_SEGMENT vertexFlags)</unmanaged>
        /* public void SetSegmentFlags(SlimDX2.Direct2D1.PathSegment vertexFlags) */

        
        /// <summary>	
        /// Starts a new figure at the specified point. 	
        /// </summary>	
        /// <remarks>	
        /// If this method is called while a figure is currently in progress, the interface is invalidated and all future methods will fail.	
        /// </remarks>	
        /// <param name="startPoint">The point at which to begin the new figure.</param>
        /// <param name="figureBegin">Whether the new figure should be hollow or filled.</param>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::BeginFigure([None] D2D1_POINT_2F startPoint,[None] D2D1_FIGURE_BEGIN figureBegin)</unmanaged>
        /* public void BeginFigure(System.Drawing.PointF startPoint, SlimDX2.Direct2D1.FigureBegin figureBegin) */

        
        /// <summary>	
        ///  Creates a sequence of lines using the specified points and adds them to the geometry sink.	
        /// </summary>	
        /// <param name="ointsRef">A pointer to an array of one or more points that describe the lines to draw. A line is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by {{BeginFigure}}) to the first point in the array. if the array contains additional points, a line is drawn from the first point to the second point in the array, from the second point to the third point, and so on.   </param>
        /// <param name="pointsCount">The number of points in the points array.</param>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::AddLines([In, Buffer] const D2D1_POINT_2F* points,[None] UINT pointsCount)</unmanaged>
        /* public void AddLines(System.Drawing.PointF[] ointsRef, int pointsCount) */

        
        /// <summary>	
        /// Creates a sequence of cubic Bezier curves and adds them to the geometry sink. 	
        /// </summary>	
        /// <param name="beziers">A pointer to an array of Bezier segments that describes the Bezier curves to create. A curve is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by {{BeginFigure}}) to the end point of the first Bezier segment in the array. if the array contains additional Bezier segments, each subsequent Bezier segment uses the end point of the preceding Bezier segment as its start point.</param>
        /// <param name="beziersCount">The number of Bezier segments in the beziers array.</param>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::AddBeziers([In, Buffer] const D2D1_BEZIER_SEGMENT* beziers,[None] UINT beziersCount)</unmanaged>
        /* public void AddBeziers(SlimDX2.Direct2D1.BezierSegment[] beziers, int beziersCount) */

        
        /// <summary>	
        ///  Ends the current figure; optionally, closes it.	
        /// </summary>	
        /// <remarks>	
        /// Calling this method without a matching call to {{BeginFigure}} places the geometry sink in an error state; subsequent calls are ignored, and the overall failure will be returned when the {{Close}} method is called.	
        /// </remarks>	
        /// <param name="figureEnd">A value that indicates whether the current figure is closed. If the figure is closed, a line is drawn between the current point and the start point specified by {{BeginFigure}}.</param>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::EndFigure([None] D2D1_FIGURE_END figureEnd)</unmanaged>
        /* public void EndFigure(SlimDX2.Direct2D1.FigureEnd figureEnd) */

        
        /// <summary>	
        /// Closes the geometry sink, indicates whether it is in an error state, and resets the sink's error state. 	
        /// </summary>	
        /// <remarks>	
        /// Do not close the geometry sink while a figure is still in progress; doing so puts the geometry sink in an error state. For the close operation to be successful, there must be one {{EndFigure}} call for each call to {{BeginFigure}}.After calling this method, the geometry sink might not be usable. Direct2D implementations of this interface do not allow the geometry sink to be modified after it is closed, but other implementations might not impose this restriction.	
        /// </remarks>	
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1SimplifiedGeometrySink::Close()</unmanaged>
        /* public SlimDX2.Result Close() */

    }
    
    /// <summary>	
    /// Describes a geometric path that can contain lines, arcs, cubic Bezier curves, and quadratic Bezier curves. 	
    /// </summary>	
    /// <unmanaged>ID2D1GeometrySink</unmanaged>
    [Guid("2cd9069f-12e2-11dc-9fed-001143a055f9")]
    public partial interface GeometrySink : SlimDX2.Direct2D1.SimplifiedGeometrySink {
        
        
        /// <summary>	
        /// Creates a line segment between the current point and the specified end point and adds it to the geometry sink. 	
        /// </summary>	
        /// <param name="point">The end point of the line to draw.</param>
        /// <unmanaged>void ID2D1GeometrySink::AddLine([None] D2D1_POINT_2F point)</unmanaged>
        /* public void AddLine(System.Drawing.PointF point) */

        
        /// <summary>	
        ///  Creates  a cubic Bezier curve between the current point and the specified endpoint.	
        /// </summary>	
        /// <param name="bezier">A structure that describes the control points and endpoint of the Bezier curve to add. </param>
        /// <unmanaged>void ID2D1GeometrySink::AddBezier([In] const D2D1_BEZIER_SEGMENT* bezier)</unmanaged>
        /* public void AddBezier(SlimDX2.Direct2D1.BezierSegment bezier) */

        
        /// <summary>	
        /// Creates  a quadratic Bezier curve between the current point and the specified endpoint.	
        /// </summary>	
        /// <param name="bezier">A structure that describes the control point and the endpoint of the quadratic Bezier curve to add.</param>
        /// <unmanaged>void ID2D1GeometrySink::AddQuadraticBezier([In] const D2D1_QUADRATIC_BEZIER_SEGMENT* bezier)</unmanaged>
        /* public void AddQuadraticBezier(SlimDX2.Direct2D1.QuadraticBezierSegment bezier) */

        
        /// <summary>	
        /// Adds a sequence of quadratic Bezier segments as an array in a single call.	
        /// </summary>	
        /// <param name="beziers">An array of a sequence of quadratic Bezier segments.</param>
        /// <param name="beziersCount">A value indicating the number of quadratic Bezier segments in beziers. </param>
        /// <unmanaged>void ID2D1GeometrySink::AddQuadraticBeziers([In, Buffer] const D2D1_QUADRATIC_BEZIER_SEGMENT* beziers,[None] UINT beziersCount)</unmanaged>
        /* public void AddQuadraticBeziers(SlimDX2.Direct2D1.QuadraticBezierSegment[] beziers, int beziersCount) */

        
        /// <summary>	
        /// Adds a single arc to the path geometry.	
        /// </summary>	
        /// <param name="arc">The arc segment to add to the figure.</param>
        /// <unmanaged>void ID2D1GeometrySink::AddArc([In] const D2D1_ARC_SEGMENT* arc)</unmanaged>
        /* public void AddArc(ref SlimDX2.Direct2D1.ArcSegment arc) */

    }
    
    /// <summary>	
    /// Populates an <see cref="SlimDX2.Direct2D1.Mesh"/> object with triangles. 	
    /// </summary>	
    /// <unmanaged>ID2D1TessellationSink</unmanaged>
    [Guid("2cd906c1-12e2-11dc-9fed-001143a055f9")]
    public partial interface TessellationSink {
        
        
        /// <summary>	
        /// Copies the specified triangles to the sink.  	
        /// </summary>	
        /// <param name="triangles">An array of <see cref="SlimDX2.Direct2D1.Triangle"/> structures that describe the triangles to add to the sink.</param>
        /// <param name="trianglesCount">The number of triangles to copy from the triangles array.</param>
        /// <unmanaged>void ID2D1TessellationSink::AddTriangles([In, Buffer] const D2D1_TRIANGLE* triangles,[None] UINT trianglesCount)</unmanaged>
        /* public void AddTriangles(SlimDX2.Direct2D1.Triangle[] triangles, int trianglesCount) */

        
        /// <summary>	
        ///  Closes the sink and returns its error status.	
        /// </summary>	
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1TessellationSink::Close()</unmanaged>
        /* public SlimDX2.Result Close() */

    }
    
    /// <summary>	
    /// Represents a complex shape that may be composed of arcs, curves, and lines.  	
    /// </summary>	
    /// <unmanaged>ID2D1PathGeometry</unmanaged>
    [Guid("2cd906a5-12e2-11dc-9fed-001143a055f9")]
    public partial class PathGeometry : SlimDX2.Direct2D1.Geometry {
        public PathGeometry(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the number of segments in the path geometry. 	
        /// </summary>	
        /// <unmanaged>HRESULT ID2D1PathGeometry::GetSegmentCount([Out] UINT32* count)</unmanaged>
        public int SegmentCount {
                get { int __output__; GetSegmentCount(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the number of figures in the path geometry. 	
        /// </summary>	
        /// <unmanaged>HRESULT ID2D1PathGeometry::GetFigureCount([Out] UINT32* count)</unmanaged>
        public int FigureCount {
                get { int __output__; GetFigureCount(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the geometry sink that is used to populate the path geometry with figures and segments. 	
        /// </summary>	
        /// <remarks>	
        /// Because path geometries are immutable and can only be populated once, it is an error to call Open on a path geometry more than once.Note that the fill mode defaults to <see cref="SlimDX2.Direct2D1.FillMode.Alternate"/>. To set the fill mode, call {{SetFillMode}} before the first call to {{BeginFigure}}. Failure to do so will put the geometry sink in an error state. 	
        /// </remarks>	
        /// <param name="geometrySink">When this method returns, geometrySink contains the address of a pointer to the geometry sink that is used to populate the path geometry with figures and segments. This parameter is passed uninitialized.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1PathGeometry::Open([Out] ID2D1GeometrySink** geometrySink)</unmanaged>
        public SlimDX2.Result Open(out SlimDX2.Direct2D1.GeometrySink geometrySink) {
            unsafe {
                IntPtr geometrySink_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 17 * 4, &geometrySink_);
                geometrySink = (geometrySink_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.DefaultGeometrySink(geometrySink_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copies the contents of the path geometry to the specified <see cref="SlimDX2.Direct2D1.GeometrySink"/>.	
        /// </summary>	
        /// <param name="geometrySink">The sink to which the path geometry's contents are copied. Modifying this sink does not change the contents of this path geometry.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1PathGeometry::Stream([In] ID2D1GeometrySink* geometrySink)</unmanaged>
        internal SlimDX2.Result Stream_(IntPtr geometrySink) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 18 * 4, (void*)geometrySink);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of segments in the path geometry. 	
        /// </summary>	
        /// <param name="count">A pointer that receives the number of segments in the path geometry when this method returns. You must allocate storage for this parameter.   </param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1PathGeometry::GetSegmentCount([Out] UINT32* count)</unmanaged>
        internal SlimDX2.Result GetSegmentCount(out int count) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* count_ = &count)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 19 * 4, count_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the number of figures in the path geometry. 	
        /// </summary>	
        /// <param name="count">A pointer that receives the number of figures in the path geometry when this method returns. You must allocate storage for this parameter.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1PathGeometry::GetFigureCount([Out] UINT32* count)</unmanaged>
        internal SlimDX2.Result GetFigureCount(out int count) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* count_ = &count)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 20 * 4, count_);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Represents a set of vertices that form a list of triangles.  	
    /// </summary>	
    /// <unmanaged>ID2D1Mesh</unmanaged>
    [Guid("2cd906c2-12e2-11dc-9fed-001143a055f9")]
    public partial class Mesh : SlimDX2.Direct2D1.Resource {
        public Mesh(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Opens the mesh for population.	
        /// </summary>	
        /// <param name="tessellationSink">When this method returns, contains a pointer to a pointer to an <see cref="SlimDX2.Direct2D1.TessellationSink"/> that is used to populate the mesh. This parameter is passed uninitialized.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Mesh::Open([Out] ID2D1TessellationSink** tessellationSink)</unmanaged>
        internal SlimDX2.Result Open_(out SlimDX2.Direct2D1.TessellationSink tessellationSink) {
            unsafe {
                IntPtr tessellationSink_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, &tessellationSink_);
                tessellationSink = (tessellationSink_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.DefaultTessellationSink(tessellationSink_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Represents the backing store required to render a layer. 	
    /// </summary>	
    /// <unmanaged>ID2D1Layer</unmanaged>
    [Guid("2cd9069b-12e2-11dc-9fed-001143a055f9")]
    public partial class Layer : SlimDX2.Direct2D1.Resource {
        public Layer(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the size of the layer in device-independent pixels. 	
        /// </summary>	
        /// <unmanaged>D2D1_SIZE_F ID2D1Layer::GetSize()</unmanaged>
        public System.Drawing.SizeF Size {
                get { return GetSize(); }
        }
        
        /// <summary>	
        /// Gets the size of the layer in device-independent pixels. 	
        /// </summary>	
        /// <returns>The size of the layer in device-independent pixels.</returns>
        /// <unmanaged>D2D1_SIZE_F ID2D1Layer::GetSize()</unmanaged>
        internal System.Drawing.SizeF GetSize() {
            unsafe {
                System.Drawing.SizeF __result__;
                SlimDX2.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, 4 * 4,(void*)&__result__);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Represents the drawing state of a render target: the antialiasing mode, transform, tags, and text-rendering options. 	
    /// </summary>	
    /// <unmanaged>ID2D1DrawingStateBlock</unmanaged>
    [Guid("28506e39-ebf6-46a1-bb47-fd85565ab957")]
    public partial class DrawingStateBlock : SlimDX2.Direct2D1.Resource {
        public DrawingStateBlock(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the antialiasing mode, transform, and tags portion of the drawing state.	
        /// </summary>	
        /// <unmanaged>void ID2D1DrawingStateBlock::GetDescription([Out] D2D1_DRAWING_STATE_DESCRIPTION* stateDescription)</unmanaged>
        public SlimDX2.Direct2D1.DrawingStateDescription Description {
                get { SlimDX2.Direct2D1.DrawingStateDescription __output__; GetDescription(out __output__); return __output__; }
                set { SetDescription(ref value); }
        }
        
        /// <summary>	
        /// Retrieves the text-rendering configuration of the drawing state.	
        /// </summary>	
        /// <unmanaged>void ID2D1DrawingStateBlock::GetTextRenderingParams([Out, Optional] IDWriteRenderingParams** textRenderingParams)</unmanaged>
        public SlimDX2.DirectWrite.RenderingParams TextRenderingParams {
                get { SlimDX2.DirectWrite.RenderingParams __output__; GetTextRenderingParams(out __output__); return __output__; }
                set { SetTextRenderingParams(value); }
        }
        
        /// <summary>	
        /// Retrieves the antialiasing mode, transform, and tags portion of the drawing state.	
        /// </summary>	
        /// <param name="stateDescription">When this method returns, contains the antialiasing mode, transform, and tags portion of the drawing state. You must allocate storage for this parameter.</param>
        /// <unmanaged>void ID2D1DrawingStateBlock::GetDescription([Out] D2D1_DRAWING_STATE_DESCRIPTION* stateDescription)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct2D1.DrawingStateDescription stateDescription) {
            unsafe {
                stateDescription = new SlimDX2.Direct2D1.DrawingStateDescription();
                fixed (void* stateDescription_ = &stateDescription)
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 4 * 4, stateDescription_);
            }
        }
        
        /// <summary>	
        /// Specifies the antialiasing mode, transform, and tags portion of the drawing state.	
        /// </summary>	
        /// <param name="stateDescription">The antialiasing mode, transform, and tags portion of the drawing state.</param>
        /// <unmanaged>void ID2D1DrawingStateBlock::SetDescription([In] const D2D1_DRAWING_STATE_DESCRIPTION* stateDescription)</unmanaged>
        internal void SetDescription(ref SlimDX2.Direct2D1.DrawingStateDescription stateDescription) {
            unsafe {
                fixed (void* stateDescription_ = &stateDescription)
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 5 * 4, stateDescription_);
            }
        }
        
        /// <summary>	
        /// Specifies the text-rendering configuration of the drawing state.	
        /// </summary>	
        /// <param name="textRenderingParams">The text-rendering configuration of the drawing state, or NULL to use default settings.</param>
        /// <unmanaged>void ID2D1DrawingStateBlock::SetTextRenderingParams([In, Optional] IDWriteRenderingParams* textRenderingParams)</unmanaged>
        internal void SetTextRenderingParams(SlimDX2.DirectWrite.RenderingParams textRenderingParams) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 6 * 4, (void*)((textRenderingParams == null)?IntPtr.Zero:textRenderingParams.NativePointer));
            }
        }
        
        /// <summary>	
        /// Retrieves the text-rendering configuration of the drawing state.	
        /// </summary>	
        /// <param name="textRenderingParams">When this method returns, contains the address of a pointer to an <see cref="SlimDX2.DirectWrite.RenderingParams"/> object that describes the text-rendering configuration of the drawing state.</param>
        /// <unmanaged>void ID2D1DrawingStateBlock::GetTextRenderingParams([Out, Optional] IDWriteRenderingParams** textRenderingParams)</unmanaged>
        internal void GetTextRenderingParams(out SlimDX2.DirectWrite.RenderingParams textRenderingParams) {
            unsafe {
                IntPtr textRenderingParams_ = IntPtr.Zero;
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 7 * 4, &textRenderingParams_);
                textRenderingParams = (textRenderingParams_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.RenderingParams(textRenderingParams_);	
            }
        }
    }
    
    /// <summary>	
    /// Represents an object that can receive drawing commands. Interfaces that inherit from ID2D1RenderTarget render the drawing commands they receive in different ways. 	
    /// </summary>	
    /// <unmanaged>ID2D1RenderTarget</unmanaged>
    [Guid("2cd90694-12e2-11dc-9fed-001143a055f9")]
    public partial class RenderTarget : SlimDX2.Direct2D1.Resource {
        public RenderTarget(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the current transform of the render target. 	
        /// </summary>	
        /// <unmanaged>void ID2D1RenderTarget::GetTransform([Out] D2D1_MATRIX_3X2_F* transform)</unmanaged>
        public SlimDX2.Direct2D1.Matrix3x2 Transform {
                get { SlimDX2.Direct2D1.Matrix3x2 __output__; GetTransform(out __output__); return __output__; }
                set { SetTransform(ref value); }
        }
        
        /// <summary>	
        ///  Retrieves the current antialiasing mode for nontext drawing operations.	
        /// </summary>	
        /// <unmanaged>D2D1_ANTIALIAS_MODE ID2D1RenderTarget::GetAntialiasMode()</unmanaged>
        public SlimDX2.Direct2D1.AntialiasMode AntialiasMode {
                get { return GetAntialiasMode(); }
                set { SetAntialiasMode(value); }
        }
        
        /// <summary>	
        /// Gets the current antialiasing mode for text and glyph drawing operations. 	
        /// </summary>	
        /// <unmanaged>D2D1_TEXT_ANTIALIAS_MODE ID2D1RenderTarget::GetTextAntialiasMode()</unmanaged>
        public SlimDX2.Direct2D1.TextAntialiasMode TextAntialiasMode {
                get { return GetTextAntialiasMode(); }
                set { SetTextAntialiasMode(value); }
        }
        
        /// <summary>	
        /// Retrieves the render target's current text rendering options. 	
        /// </summary>	
        /// <remarks>	
        /// If the settings specified by  textRenderingParams are incompatible with the render target's text antialiasing mode (specified by {{SetTextAntialiasMode}}), subsequent text and glyph drawing operations will fail and put the render target into an error state.	
        /// </remarks>	
        /// <unmanaged>void ID2D1RenderTarget::GetTextRenderingParams([Out, Optional] IDWriteRenderingParams** textRenderingParams)</unmanaged>
        public SlimDX2.DirectWrite.RenderingParams TextRenderingParams {
                get { SlimDX2.DirectWrite.RenderingParams __output__; GetTextRenderingParams(out __output__); return __output__; }
                set { SetTextRenderingParams(value); }
        }
        
        /// <summary>	
        /// Retrieves the pixel format and alpha mode of the render target. 	
        /// </summary>	
        /// <unmanaged>D2D1_PIXEL_FORMAT ID2D1RenderTarget::GetPixelFormat()</unmanaged>
        public SlimDX2.Direct2D1.PixelFormat PixelFormat {
                get { return GetPixelFormat(); }
        }
        
        /// <summary>	
        /// Returns the size of the render target in device-independent pixels.	
        /// </summary>	
        /// <unmanaged>D2D1_SIZE_F ID2D1RenderTarget::GetSize()</unmanaged>
        public System.Drawing.SizeF Size {
                get { return GetSize(); }
        }
        
        /// <summary>	
        /// Returns the size of the render target in device pixels.	
        /// </summary>	
        /// <unmanaged>D2D1_SIZE_U ID2D1RenderTarget::GetPixelSize()</unmanaged>
        public System.Drawing.Size PixelSize {
                get { return GetPixelSize(); }
        }
        
        /// <summary>	
        /// Gets the maximum size, in device-dependent units (pixels), of  any one bitmap dimension supported by the render target.	
        /// </summary>	
        /// <unmanaged>UINT32 ID2D1RenderTarget::GetMaximumBitmapSize()</unmanaged>
        public int MaximumBitmapSize {
                get { return GetMaximumBitmapSize(); }
        }
        
        /// <summary>	
        /// Creates a Direct2D bitmap from a pointer to in-memory source data.	
        /// </summary>	
        /// <param name="size">The dimension of the bitmap to create in pixels.</param>
        /// <param name="srcData">A pointer to the memory location of the image data, or NULL to create an uninitialized bitmap.</param>
        /// <param name="pitch">The byte count of each scanline, which is equal to (the image width in pixels * the number of bytes per pixel) + memory padding. If srcData is NULL, this value is ignored. (Note that pitch is also sometimes called stride.)</param>
        /// <param name="bitmapProperties">The pixel format and dots per inch (DPI) of the bitmap to create.</param>
        /// <param name="bitmap">When this method returns, contains a pointer to a pointer to the new bitmap. This parameter is passed uninitialized.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmap([None] D2D1_SIZE_U size,[In, Optional] const void* srcData,[None] UINT32 pitch,[In] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out] ID2D1Bitmap** bitmap)</unmanaged>
        internal SlimDX2.Result CreateBitmap(System.Drawing.Size size, IntPtr srcData, int pitch, SlimDX2.Direct2D1.BitmapProperties bitmapProperties, out SlimDX2.Direct2D1.Bitmap bitmap) {
            unsafe {
                IntPtr bitmap_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, size, (void*)srcData, pitch, &bitmapProperties, &bitmap_);
                bitmap = (bitmap_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.Bitmap(bitmap_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct2D1.Bitmap"/> whose data is shared with another resource.	
        /// </summary>	
        /// <remarks>	
        /// The CreateSharedBitmap method is useful for efficiently reusing bitmap data and can also be used to provide interoperability with Direct3D. Sharing an ID2D1BitmapBy passing an <see cref="SlimDX2.Direct2D1.Bitmap"/> created by a render target that is resource-compatible, you can share a bitmap with that render target; both the original ID2D1Bitmap and the new ID2D1Bitmap created by this method will point to the same bitmap data. For more information about when render target resources can be shared, see the Sharing Render Target Resources section of the {{Resources Overview}}.You may also use this method to reinterpret the data of an existing bitmap and specify a new DPI or alpha mode. For example, in the case of a bitmap atlas, an <see cref="SlimDX2.Direct2D1.Bitmap"/> may contain multiple sub-images, each of which should be rendered with a different <see cref="SlimDX2.Direct2D1.AlphaMode"/> (D2D1_ALPHA_MODE_PREMULTIPLIED or D2D1_ALPHA_MODE_IGNORE). You could use the CreateSharedBitmap method to reinterpret the bitmap using the desired alpha mode  without having to load a separate copy of the bitmap into memory.Sharing an IDXGISurfaceWhen using a DXGI surface render target (an <see cref="SlimDX2.Direct2D1.RenderTarget"/> object created by the {{CreateDxgiSurfaceRenderTarget}} method), you can pass an  <see cref="SlimDX2.DXGI.Surface"/> surface to the CreateSharedBitmap method to share video memory with Direct3D and manipulate Direct3D content as an <see cref="SlimDX2.Direct2D1.Bitmap"/>. As described in  the {{Resources Overview}}, the render target and the <see cref="SlimDX2.DXGI.Surface"/> must be using the same Direct3D device. Note also that the <see cref="SlimDX2.DXGI.Surface"/> must use one of the supported pixel formats and alpha modes described in {{Supported Pixel Formats and Alpha Modes}}.For more information about interoperability with Direct3D, see the {{Direct2D and Direct3D Interoperability Overview}}.Sharing an IWICBitmapLockAn {{IWICBitmapLock}} stores the content of a WIC bitmap and shields it from simultaneous accesses. By passing an IWICBitmapLock to the CreateSharedBitmap method, you can create an <see cref="SlimDX2.Direct2D1.Bitmap"/> that points to the bitmap data already stored in the  IWICBitmapLock. To use an {{IWICBitmapLock}} with the CreateSharedBitmap method, the render target must use software rendering. To force a render target to use software rendering, set to <see cref="SlimDX2.Direct2D1.RenderTargetType.Software"/> the type field of the  <see cref="SlimDX2.Direct2D1.RenderTargetProperties"/> structure that you use to create the render target. To check whether an existing render target uses software rendering, use the {{IsSupported}} method.	
        /// </remarks>	
        /// <param name="riid">The interface ID of the object supplying the source data.</param>
        /// <param name="data">An <see cref="SlimDX2.Direct2D1.Bitmap"/>, <see cref="SlimDX2.DXGI.Surface"/>, or an {{IWICBitmapLock}} that contains the data to share with the new ID2D1Bitmap. For more information, see the Remarks section.</param>
        /// <param name="bitmapProperties">The pixel format  and DPI of the bitmap to create . The <see cref="SlimDX2.DXGI.Format"/> portion of the pixel format  must match the <see cref="SlimDX2.DXGI.Format"/> of data or the method will fail, but the alpha modes don't have to match. To prevent a  mismatch, you can pass NULL or the value obtained from the {{D2D1::PixelFormat}} helper function. The DPI settings do not have to match those of data. If both dpiX and dpiY are  0.0f, the default DPI, 96, is used.</param>
        /// <param name="bitmap">When this method returns, contains the address of a pointer to the new bitmap. This parameter is passed uninitialized. </param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateSharedBitmap([In] REFIID riid,[In] void* data,[In, Optional] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out] ID2D1Bitmap** bitmap)</unmanaged>
        internal SlimDX2.Result CreateSharedBitmap(Guid riid, IntPtr data, SlimDX2.Direct2D1.BitmapProperties? bitmapProperties, out SlimDX2.Direct2D1.Bitmap bitmap) {
            unsafe {
                SlimDX2.Direct2D1.BitmapProperties bitmapProperties_;
                if (bitmapProperties.HasValue)
                    bitmapProperties_ = bitmapProperties.Value;				
                IntPtr bitmap_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4, &riid, (void*)data, (bitmapProperties.HasValue)?&bitmapProperties_:(void*)IntPtr.Zero, &bitmap_);
                bitmap = (bitmap_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.Bitmap(bitmap_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct2D1.BitmapBrush"/> from the specified bitmap.	
        /// </summary>	
        /// <param name="bitmap">The bitmap contents of the new brush.</param>
        /// <param name="bitmapBrushProperties">The extend modes and interpolation mode of the new brush, or NULL. If this parameter is NULL, the brush defaults to the <see cref="SlimDX2.Direct2D1.ExtendMode.Clamp"/> horizontal and vertical extend modes and the <see cref="SlimDX2.Direct2D1.BitmapInterpolationMode.Linear"/> interpolation mode. </param>
        /// <param name="brushProperties">The opacity and transform of the new brush, or NULL. If this parameter is NULL, the brush defaults to an opacity of 1.0f and its transform is the identity matrix.</param>
        /// <param name="bitmapBrush">When this method returns, contains a pointer to a pointer to the new brush. This parameter is passed uninitialized.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmapBrush([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_BITMAP_BRUSH_PROPERTIES* bitmapBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out] ID2D1BitmapBrush** bitmapBrush)</unmanaged>
        internal SlimDX2.Result CreateBitmapBrush(SlimDX2.Direct2D1.Bitmap bitmap, SlimDX2.Direct2D1.BitmapBrushProperties? bitmapBrushProperties, SlimDX2.Direct2D1.BrushProperties? brushProperties, out SlimDX2.Direct2D1.BitmapBrush bitmapBrush) {
            unsafe {
                SlimDX2.Direct2D1.BitmapBrushProperties bitmapBrushProperties_;
                if (bitmapBrushProperties.HasValue)
                    bitmapBrushProperties_ = bitmapBrushProperties.Value;				
                SlimDX2.Direct2D1.BrushProperties brushProperties_;
                if (brushProperties.HasValue)
                    brushProperties_ = brushProperties.Value;				
                IntPtr bitmapBrush_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 7 * 4, (void*)((bitmap == null)?IntPtr.Zero:bitmap.NativePointer), (bitmapBrushProperties.HasValue)?&bitmapBrushProperties_:(void*)IntPtr.Zero, (brushProperties.HasValue)?&brushProperties_:(void*)IntPtr.Zero, &bitmapBrush_);
                bitmapBrush = (bitmapBrush_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.BitmapBrush(bitmapBrush_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a new <see cref="SlimDX2.Direct2D1.SolidColorBrush"/> that has the specified color and opacity. 	
        /// </summary>	
        /// <param name="color">The red, green, blue, and alpha values of the brush's color.</param>
        /// <param name="brushProperties">The base opacity of the brush.</param>
        /// <param name="solidColorBrush">When this method returns, contains the address of a pointer to the new brush. This parameter is passed uninitialized.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateSolidColorBrush([In] const D2D1_COLOR_F* color,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out] ID2D1SolidColorBrush** solidColorBrush)</unmanaged>
        internal SlimDX2.Result CreateSolidColorBrush(SlimMath.Color4 color, SlimDX2.Direct2D1.BrushProperties? brushProperties, out SlimDX2.Direct2D1.SolidColorBrush solidColorBrush) {
            unsafe {
                SlimDX2.Direct2D1.BrushProperties brushProperties_;
                if (brushProperties.HasValue)
                    brushProperties_ = brushProperties.Value;				
                IntPtr solidColorBrush_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 8 * 4, &color, (brushProperties.HasValue)?&brushProperties_:(void*)IntPtr.Zero, &solidColorBrush_);
                solidColorBrush = (solidColorBrush_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.SolidColorBrush(solidColorBrush_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct2D1.GradientStopCollection"/> from the specified gradient stops, color interpolation gamma, and extend mode.  	
        /// </summary>	
        /// <param name="gradientStops">A pointer to an array of D2D1_GRADIENT_STOP structures.</param>
        /// <param name="gradientStopsCount">A value greater than or equal to 1 that specifies the number of gradient stops in the gradientStops array.</param>
        /// <param name="colorInterpolationGamma">The space in which color interpolation between the gradient stops is performed.</param>
        /// <param name="extendMode">The behavior of the gradient outside the [0,1] normalized range.</param>
        /// <param name="gradientStopCollection">When this method returns, contains a pointer to a pointer to the new gradient stop collection.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateGradientStopCollection([In, Buffer] const D2D1_GRADIENT_STOP* gradientStops,[None] UINT gradientStopsCount,[None] D2D1_GAMMA colorInterpolationGamma,[None] D2D1_EXTEND_MODE extendMode,[Out] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>
        internal SlimDX2.Result CreateGradientStopCollection(SlimDX2.Direct2D1.GradientStop[] gradientStops, int gradientStopsCount, SlimDX2.Direct2D1.Gamma colorInterpolationGamma, SlimDX2.Direct2D1.ExtendMode extendMode, out SlimDX2.Direct2D1.GradientStopCollection gradientStopCollection) {
            unsafe {
                IntPtr gradientStopCollection_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* gradientStops_ = &gradientStops[0])
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 9 * 4, gradientStops_, gradientStopsCount, unchecked((int)colorInterpolationGamma), unchecked((int)extendMode), &gradientStopCollection_);
                gradientStopCollection = (gradientStopCollection_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.GradientStopCollection(gradientStopCollection_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct2D1.LinearGradientBrush"/> that contains the specified gradient stops and has the specified transform and base opacity. 	
        /// </summary>	
        /// <param name="linearGradientBrushProperties">The start and end points of the gradient.</param>
        /// <param name="brushProperties">The transform and base opacity of the new brush, or NULL. If this value is NULL, the brush defaults to a base opacity of 1.0f and the identity matrix as its transformation.</param>
        /// <param name="gradientStopCollection">A collection of <see cref="SlimDX2.Direct2D1.GradientStop"/> structures that describe the colors in the brush's gradient and their locations along the gradient line.</param>
        /// <param name="linearGradientBrush">When this method returns, contains the address of a pointer to the new brush. This paramater is passed uninitialized.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateLinearGradientBrush([In] const D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES* linearGradientBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[In] ID2D1GradientStopCollection* gradientStopCollection,[Out] ID2D1LinearGradientBrush** linearGradientBrush)</unmanaged>
        internal SlimDX2.Result CreateLinearGradientBrush(SlimDX2.Direct2D1.LinearGradientBrushProperties linearGradientBrushProperties, SlimDX2.Direct2D1.BrushProperties? brushProperties, SlimDX2.Direct2D1.GradientStopCollection gradientStopCollection, out SlimDX2.Direct2D1.LinearGradientBrush linearGradientBrush) {
            unsafe {
                SlimDX2.Direct2D1.BrushProperties brushProperties_;
                if (brushProperties.HasValue)
                    brushProperties_ = brushProperties.Value;				
                IntPtr linearGradientBrush_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 10 * 4, &linearGradientBrushProperties, (brushProperties.HasValue)?&brushProperties_:(void*)IntPtr.Zero, (void*)((gradientStopCollection == null)?IntPtr.Zero:gradientStopCollection.NativePointer), &linearGradientBrush_);
                linearGradientBrush = (linearGradientBrush_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.LinearGradientBrush(linearGradientBrush_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct2D1.RadialGradientBrush"/> that contains the specified gradient stops and has the specified transform and base opacity. 	
        /// </summary>	
        /// <param name="radialGradientBrushProperties">The center, gradient origin offset, and x-radius and y-radius of the brush's gradient.</param>
        /// <param name="brushProperties">The transform and base opacity of the new brush, or NULL. If this value is NULL, the brush defaults to a base opacity of 1.0f and the identity matrix as its transformation.</param>
        /// <param name="gradientStopCollection">A collection of <see cref="SlimDX2.Direct2D1.GradientStop"/> structures that describe the colors in the brush's gradient and their locations along the gradient.</param>
        /// <param name="radialGradientBrush">When this method returns, contains a pointer to a pointer to the new brush. This paramater is passed uninitialized.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateRadialGradientBrush([In] const D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES* radialGradientBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[In] ID2D1GradientStopCollection* gradientStopCollection,[Out] ID2D1RadialGradientBrush** radialGradientBrush)</unmanaged>
        internal SlimDX2.Result CreateRadialGradientBrush(ref SlimDX2.Direct2D1.RadialGradientBrushProperties radialGradientBrushProperties, SlimDX2.Direct2D1.BrushProperties? brushProperties, SlimDX2.Direct2D1.GradientStopCollection gradientStopCollection, out SlimDX2.Direct2D1.RadialGradientBrush radialGradientBrush) {
            unsafe {
                SlimDX2.Direct2D1.BrushProperties brushProperties_;
                if (brushProperties.HasValue)
                    brushProperties_ = brushProperties.Value;				
                IntPtr radialGradientBrush_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* radialGradientBrushProperties_ = &radialGradientBrushProperties)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 11 * 4, radialGradientBrushProperties_, (brushProperties.HasValue)?&brushProperties_:(void*)IntPtr.Zero, (void*)((gradientStopCollection == null)?IntPtr.Zero:gradientStopCollection.NativePointer), &radialGradientBrush_);
                radialGradientBrush = (radialGradientBrush_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.RadialGradientBrush(radialGradientBrush_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates a bitmap render target for use during intermediate offscreen drawing that is compatible with the current render target.	
        /// </summary>	
        /// <remarks>	
        /// The pixel size and DPI of the new render target can be altered by specifying values for desiredSize or desiredPixelSize:  If desiredSize is specified but desiredPixelSize is not, the pixel size is computed from the desired size using the parent target DPI. If the desiredSize maps to a integer-pixel size, the DPI of the compatible render target is the same as the DPI of the parent target.  If desiredSize maps to a fractional-pixel size, the pixel size is rounded up to the nearest integer and the DPI for the compatible render target is slightly higher than the DPI of the parent render target. In all cases, the coordinate (desiredSize.width, desiredSize.height) maps to the lower-right corner of the compatible render target.If the desiredPixelSize is specified and desiredSize is not, the DPI of the new render target is the same as the original render target.If both desiredSize and desiredPixelSize are specified, the DPI of the new render target is computed to account for the difference in scale.If neither desiredSize nor desiredPixelSize is specified, the new render target size and DPI match the original render target. 	
        /// </remarks>	
        /// <param name="desiredSize">The desired size of the new render target in device-independent pixels if it should be different from the original render target. For more information, see the Remarks section.</param>
        /// <param name="desiredPixelSize">The desired size of the new render target in pixels if it should be different from the original render target. For more information, see the Remarks section.</param>
        /// <param name="desiredFormat">The desired pixel format and alpha mode of the new render target. If the pixel format is set to DXGI_FORMAT_UNKNOWN, the new render target uses the same pixel format as the original render target. If the alpha mode is <see cref="SlimDX2.Direct2D1.AlphaMode.Unknown"/>, the alpha mode of the new render target defaults to D2D1_ALPHA_MODE_PREMULTIPLIED. For information about supported pixel formats, see  {{Supported Pixel  Formats and Alpha Modes}}.</param>
        /// <param name="options">A value that specifies whether the new render target must be compatible with GDI.</param>
        /// <param name="bitmapRenderTarget">When this method returns, contains a pointer to a pointer to a new bitmap render target. This parameter is passed uninitialized.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateCompatibleRenderTarget([In, Optional] const D2D1_SIZE_F* desiredSize,[In, Optional] const D2D1_SIZE_U* desiredPixelSize,[In, Optional] const D2D1_PIXEL_FORMAT* desiredFormat,[None] D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options,[Out] ID2D1BitmapRenderTarget** bitmapRenderTarget)</unmanaged>
        internal SlimDX2.Result CreateCompatibleRenderTarget(System.Drawing.SizeF? desiredSize, System.Drawing.Size? desiredPixelSize, SlimDX2.Direct2D1.PixelFormat? desiredFormat, SlimDX2.Direct2D1.CompatibleRenderTargetOptions options, out SlimDX2.Direct2D1.BitmapRenderTarget bitmapRenderTarget) {
            unsafe {
                System.Drawing.SizeF desiredSize_;
                if (desiredSize.HasValue)
                    desiredSize_ = desiredSize.Value;				
                System.Drawing.Size desiredPixelSize_;
                if (desiredPixelSize.HasValue)
                    desiredPixelSize_ = desiredPixelSize.Value;				
                SlimDX2.Direct2D1.PixelFormat desiredFormat_;
                if (desiredFormat.HasValue)
                    desiredFormat_ = desiredFormat.Value;				
                IntPtr bitmapRenderTarget_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 12 * 4, (desiredSize.HasValue)?&desiredSize_:(void*)IntPtr.Zero, (desiredPixelSize.HasValue)?&desiredPixelSize_:(void*)IntPtr.Zero, (desiredFormat.HasValue)?&desiredFormat_:(void*)IntPtr.Zero, unchecked((int)options), &bitmapRenderTarget_);
                bitmapRenderTarget = (bitmapRenderTarget_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.BitmapRenderTarget(bitmapRenderTarget_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a layer resource that can be used with this render target and its compatible render targets. The new layer has the specified initial size.  	
        /// </summary>	
        /// <remarks>	
        /// Regardless of whether a size is initially specified, the layer automatically resizes as needed.	
        /// </remarks>	
        /// <param name="size">If (0, 0) is specified, no backing store is created behind the layer resource. The layer resource is allocated to the minimum size when {{PushLayer}} is called.</param>
        /// <param name="layer">When the method returns, contains a pointer to a pointer to the new layer. This parameter is passed uninitialized.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateLayer([In, Optional] const D2D1_SIZE_F* size,[Out] ID2D1Layer** layer)</unmanaged>
        internal SlimDX2.Result CreateLayer(System.Drawing.SizeF? size, out SlimDX2.Direct2D1.Layer layer) {
            unsafe {
                System.Drawing.SizeF size_;
                if (size.HasValue)
                    size_ = size.Value;				
                IntPtr layer_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 13 * 4, (size.HasValue)?&size_:(void*)IntPtr.Zero, &layer_);
                layer = (layer_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.Layer(layer_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a mesh that uses triangles to describe a shape.	
        /// </summary>	
        /// <remarks>	
        /// To populate a mesh, use its {{Open}} method to obtain an <see cref="SlimDX2.Direct2D1.TessellationSink"/>. To draw the mesh, use the render target's {{FillMesh}} method.	
        /// </remarks>	
        /// <param name="mesh">When this method returns, contains a pointer to a pointer to the new mesh.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateMesh([Out] ID2D1Mesh** mesh)</unmanaged>
        internal SlimDX2.Result CreateMesh(out SlimDX2.Direct2D1.Mesh mesh) {
            unsafe {
                IntPtr mesh_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 14 * 4, &mesh_);
                mesh = (mesh_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.Mesh(mesh_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Draws a line between the specified points using the specified stroke style. 	
        /// </summary>	
        /// <remarks>	
        /// This method doesn't return an error code if it fails. To determine whether a drawing operation (such as DrawLine) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> methods. 	
        /// </remarks>	
        /// <param name="point0">The start point of the line, in device-independent pixels.</param>
        /// <param name="point1">The end point of the line, in device-independent pixels.</param>
        /// <param name="brush">The brush used to paint the line's stroke.</param>
        /// <param name="strokeWidth">A value greater than or equal to 0.0f that specifies the width of the stroke. If this parameter isn't specified, it defaults to 1.0f.  The stroke is centered on the line.</param>
        /// <param name="strokeStyle">The style of stroke to paint, or NULL to paint a solid line.</param>
        /// <unmanaged>void ID2D1RenderTarget::DrawLine([None] D2D1_POINT_2F point0,[None] D2D1_POINT_2F point1,[In] ID2D1Brush* brush,[None] FLOAT strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        public void DrawLine(System.Drawing.PointF point0, System.Drawing.PointF point1, SlimDX2.Direct2D1.Brush brush, float strokeWidth, SlimDX2.Direct2D1.StrokeStyle strokeStyle) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 15 * 4, point0, point1, (void*)((brush == null)?IntPtr.Zero:brush.NativePointer), strokeWidth, (void*)((strokeStyle == null)?IntPtr.Zero:strokeStyle.NativePointer));
            }
        }
        
        /// <summary>	
        /// Draws the outline of a rectangle that has the specified dimensions and stroke style. 	
        /// </summary>	
        /// <remarks>	
        /// When this method fails, it does not return an error code. To determine whether a drawing method (such as {{DrawRectangle}}) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> method. 	
        /// </remarks>	
        /// <param name="rect">The dimensions of the rectangle to draw, in device-independent pixels.</param>
        /// <param name="brush">The brush used to paint the rectangle's stroke.</param>
        /// <param name="strokeWidth">A value greater than or equal to 0.0f that specifies the width of the rectangle's stroke. The stroke is centered on the rectangle's outline.</param>
        /// <param name="strokeStyle">The style of stroke to paint, or NULL to paint a solid stroke.</param>
        /// <unmanaged>void ID2D1RenderTarget::DrawRectangle([In] const D2D1_RECT_F* rect,[In] ID2D1Brush* brush,[None] FLOAT strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        public void DrawRectangle(SlimDX2.RectangleF rect, SlimDX2.Direct2D1.Brush brush, float strokeWidth, SlimDX2.Direct2D1.StrokeStyle strokeStyle) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 16 * 4, &rect, (void*)((brush == null)?IntPtr.Zero:brush.NativePointer), strokeWidth, (void*)((strokeStyle == null)?IntPtr.Zero:strokeStyle.NativePointer));
            }
        }
        
        /// <summary>	
        /// Paints the interior of the specified rectangle. 	
        /// </summary>	
        /// <remarks>	
        /// This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{FillRectangle}}) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> methods. 	
        /// </remarks>	
        /// <param name="rect">The dimension of the rectangle to paint, in device-independent pixels.</param>
        /// <param name="brush">The brush used to paint the rectangle's interior.</param>
        /// <unmanaged>void ID2D1RenderTarget::FillRectangle([In] const D2D1_RECT_F* rect,[In] ID2D1Brush* brush)</unmanaged>
        public void FillRectangle(SlimDX2.RectangleF rect, SlimDX2.Direct2D1.Brush brush) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 17 * 4, &rect, (void*)((brush == null)?IntPtr.Zero:brush.NativePointer));
            }
        }
        
        /// <summary>	
        ///  Draws the outline of the specified rounded rectangle using the specified stroke style.	
        /// </summary>	
        /// <remarks>	
        /// This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{DrawRoundedRectangle}}) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> methods. 	
        /// </remarks>	
        /// <param name="roundedRect">The dimensions of the rounded rectangle to draw, in device-independent pixels.</param>
        /// <param name="brush">The brush used to paint the rounded rectangle's outline. </param>
        /// <param name="strokeWidth">The width of the rounded rectangle's stroke. The stroke is centered on the rounded rectangle's outline. The default value is 1.0f. </param>
        /// <param name="strokeStyle">The style of the rounded rectangle's stroke, or NULL to paint a solid stroke. The default value is NULL.</param>
        /// <unmanaged>void ID2D1RenderTarget::DrawRoundedRectangle([In] const D2D1_ROUNDED_RECT* roundedRect,[In] ID2D1Brush* brush,[None] FLOAT strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        public void DrawRoundedRectangle(ref SlimDX2.Direct2D1.RoundedRect roundedRect, SlimDX2.Direct2D1.Brush brush, float strokeWidth, SlimDX2.Direct2D1.StrokeStyle strokeStyle) {
            unsafe {
                fixed (void* roundedRect_ = &roundedRect)
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 18 * 4, roundedRect_, (void*)((brush == null)?IntPtr.Zero:brush.NativePointer), strokeWidth, (void*)((strokeStyle == null)?IntPtr.Zero:strokeStyle.NativePointer));
            }
        }
        
        /// <summary>	
        ///  Paints the interior of the specified rounded rectangle.	
        /// </summary>	
        /// <remarks>	
        /// This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{FillRoundedRectangle}}) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> methods. 	
        /// </remarks>	
        /// <param name="roundedRect">The dimensions of the rounded rectangle to paint, in device-independent pixels.</param>
        /// <param name="brush">The brush used to paint the interior of the rounded rectangle.</param>
        /// <unmanaged>void ID2D1RenderTarget::FillRoundedRectangle([In] const D2D1_ROUNDED_RECT* roundedRect,[In] ID2D1Brush* brush)</unmanaged>
        public void FillRoundedRectangle(ref SlimDX2.Direct2D1.RoundedRect roundedRect, SlimDX2.Direct2D1.Brush brush) {
            unsafe {
                fixed (void* roundedRect_ = &roundedRect)
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 19 * 4, roundedRect_, (void*)((brush == null)?IntPtr.Zero:brush.NativePointer));
            }
        }
        
        /// <summary>	
        /// Draws the outline of the specified ellipse using the specified stroke style. 	
        /// </summary>	
        /// <remarks>	
        /// The {{DrawEllipse}} method doesn't return an error code if it fails. To determine whether a drawing operation (such as DrawEllipse) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> methods. 	
        /// </remarks>	
        /// <param name="ellipse">The position and radius of the ellipse to draw, in device-independent pixels.</param>
        /// <param name="brush">The brush used to paint the ellipse's outline.</param>
        /// <param name="strokeWidth">The thickness of the ellipse's stroke. The stroke is centered on the ellipse's outline.</param>
        /// <param name="strokeStyle">The style of stroke to apply to the ellipse's outline, or NULL to paint a solid stroke.</param>
        /// <unmanaged>void ID2D1RenderTarget::DrawEllipse([In] const D2D1_ELLIPSE* ellipse,[In] ID2D1Brush* brush,[None] FLOAT strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        public void DrawEllipse(SlimDX2.Direct2D1.Ellipse ellipse, SlimDX2.Direct2D1.Brush brush, float strokeWidth, SlimDX2.Direct2D1.StrokeStyle strokeStyle) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 20 * 4, &ellipse, (void*)((brush == null)?IntPtr.Zero:brush.NativePointer), strokeWidth, (void*)((strokeStyle == null)?IntPtr.Zero:strokeStyle.NativePointer));
            }
        }
        
        /// <summary>	
        /// Paints the interior of the specified ellipse. 	
        /// </summary>	
        /// <remarks>	
        /// This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{FillEllipse}}) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> methods. 	
        /// </remarks>	
        /// <param name="ellipse">The position and radius, in device-independent pixels, of the ellipse to paint.</param>
        /// <param name="brush">The brush used to paint the interior of the ellipse.</param>
        /// <unmanaged>void ID2D1RenderTarget::FillEllipse([In] const D2D1_ELLIPSE* ellipse,[In] ID2D1Brush* brush)</unmanaged>
        public void FillEllipse(SlimDX2.Direct2D1.Ellipse ellipse, SlimDX2.Direct2D1.Brush brush) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 21 * 4, &ellipse, (void*)((brush == null)?IntPtr.Zero:brush.NativePointer));
            }
        }
        
        /// <summary>	
        /// Draws the outline of the specified geometry using the specified stroke style. 	
        /// </summary>	
        /// <remarks>	
        /// This method doesn't return an error code if it fails. To determine whether a drawing operation (such as DrawGeometry) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> methods. 	
        /// </remarks>	
        /// <param name="geometry">The geometry to draw.</param>
        /// <param name="brush">The brush used to paint the geometry's stroke.</param>
        /// <param name="strokeWidth">The thickness of the geometry's stroke. The stroke is centered on the geometry's outline.</param>
        /// <param name="strokeStyle">The style of stroke to apply to the geometry's outline, or NULL to paint a solid stroke.</param>
        /// <unmanaged>void ID2D1RenderTarget::DrawGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[None] FLOAT strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        public void DrawGeometry(SlimDX2.Direct2D1.Geometry geometry, SlimDX2.Direct2D1.Brush brush, float strokeWidth, SlimDX2.Direct2D1.StrokeStyle strokeStyle) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 22 * 4, (void*)((geometry == null)?IntPtr.Zero:geometry.NativePointer), (void*)((brush == null)?IntPtr.Zero:brush.NativePointer), strokeWidth, (void*)((strokeStyle == null)?IntPtr.Zero:strokeStyle.NativePointer));
            }
        }
        
        /// <summary>	
        /// Paints the interior of the specified geometry. 	
        /// </summary>	
        /// <remarks>	
        /// If the opacityBrush parameter is not NULL, the alpha value of each pixel of the mapped opacityBrush is used to determine the resulting opacity of each corresponding pixel of the geometry. Only the alpha value of each color in the brush is used for this processing; all other color information is ignored.  The alpha value specified by the brush is multiplied by the alpha value of the geometry after the geometry has been painted by brush.  	
        /// When this method fails, it does not return an error code. To determine whether a drawing operation (such as FillGeometry) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> method. 	
        /// </remarks>	
        /// <param name="geometry">The geometry to paint.</param>
        /// <param name="brush">The brush used to paint the geometry's interior.</param>
        /// <param name="opacityBrush">The opacity mask to apply to the geometry;NULL for no opacity mask. If an opacity mask (the opacityBrush parameter) is specified, brush must be an <see cref="SlimDX2.Direct2D1.BitmapBrush"/> that has   its x- and y-extend modes set to <see cref="SlimDX2.Direct2D1.ExtendMode.Clamp"/>. For more information, see the Remarks section. </param>
        /// <unmanaged>void ID2D1RenderTarget::FillGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In, Optional] ID2D1Brush* opacityBrush)</unmanaged>
        public void FillGeometry(SlimDX2.Direct2D1.Geometry geometry, SlimDX2.Direct2D1.Brush brush, SlimDX2.Direct2D1.Brush opacityBrush) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 23 * 4, (void*)((geometry == null)?IntPtr.Zero:geometry.NativePointer), (void*)((brush == null)?IntPtr.Zero:brush.NativePointer), (void*)((opacityBrush == null)?IntPtr.Zero:opacityBrush.NativePointer));
            }
        }
        
        /// <summary>	
        ///  Paints the interior of the specified mesh.	
        /// </summary>	
        /// <remarks>	
        /// The current antialias mode of the render target must be <see cref="SlimDX2.Direct2D1.AntialiasMode.Aliased"/> when FillMesh is called. To change the render target's antialias mode, use the {{SetAntialiasMode}} method.FillMesh does not expect a particular winding order for the triangles in the <see cref="SlimDX2.Direct2D1.Mesh"/>; both clockwise and counter-clockwise will work. This method doesn't return an error code if it fails. To determine whether a drawing operation (such as FillMesh) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> methods. 	
        /// </remarks>	
        /// <param name="mesh">The mesh to paint.</param>
        /// <param name="brush">The brush used to paint the mesh.</param>
        /// <unmanaged>void ID2D1RenderTarget::FillMesh([In] ID2D1Mesh* mesh,[In] ID2D1Brush* brush)</unmanaged>
        public void FillMesh(SlimDX2.Direct2D1.Mesh mesh, SlimDX2.Direct2D1.Brush brush) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 24 * 4, (void*)((mesh == null)?IntPtr.Zero:mesh.NativePointer), (void*)((brush == null)?IntPtr.Zero:brush.NativePointer));
            }
        }
        
        /// <summary>	
        /// Applies the opacity mask described by the specified bitmap to a brush and uses that brush to paint a region of the render target.    	
        /// </summary>	
        /// <remarks>	
        /// For this method to work properly, the render target must be using the <see cref="SlimDX2.Direct2D1.AntialiasMode.Aliased"/> antialiasing mode. You can set the antialiasing mode by calling the <see cref="SlimDX2.Direct2D1.RenderTarget.SetAntialiasMode"/> method.This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{FillOpacityMask}}) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> methods. 	
        /// </remarks>	
        /// <param name="opacityMask">The opacity mask to apply to the brush. The alpha value of each pixel in the  region specified by sourceRectangle is multiplied with the alpha value of the brush after the brush has been mapped to the area defined by destinationRectangle.</param>
        /// <param name="brush">The brush used to paint the region of the render target specified by destinationRectangle.</param>
        /// <param name="content">The type of content the opacity mask contains. The value is used to determine the color space in which the opacity mask is blended.</param>
        /// <param name="destinationRectangle">The region of the render target to paint, in device-independent pixels, or NULL. If NULL is specified, the brush paints a rectangle the same size as sourceRectangle, but positioned on the origin. If sourceRectangle isn't specified, the brush paints a rectangle the same size as the opacityMask bitmap and positioned on the origin.</param>
        /// <param name="sourceRectangle">The region of the bitmap to use as the opacity mask, in device-independent pixels, or NULL. If NULL is specified, the entire bitmap is used. </param>
        /// <unmanaged>void ID2D1RenderTarget::FillOpacityMask([In] ID2D1Bitmap* opacityMask,[In] ID2D1Brush* brush,[None] D2D1_OPACITY_MASK_CONTENT content,[In, Optional] const D2D1_RECT_F* destinationRectangle,[In, Optional] const D2D1_RECT_F* sourceRectangle)</unmanaged>
        public void FillOpacityMask(SlimDX2.Direct2D1.Bitmap opacityMask, SlimDX2.Direct2D1.Brush brush, SlimDX2.Direct2D1.OpacityMaskContent content, SlimDX2.RectangleF? destinationRectangle, SlimDX2.RectangleF? sourceRectangle) {
            unsafe {
                SlimDX2.RectangleF destinationRectangle_;
                if (destinationRectangle.HasValue)
                    destinationRectangle_ = destinationRectangle.Value;				
                SlimDX2.RectangleF sourceRectangle_;
                if (sourceRectangle.HasValue)
                    sourceRectangle_ = sourceRectangle.Value;				
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 25 * 4, (void*)((opacityMask == null)?IntPtr.Zero:opacityMask.NativePointer), (void*)((brush == null)?IntPtr.Zero:brush.NativePointer), unchecked((int)content), (destinationRectangle.HasValue)?&destinationRectangle_:(void*)IntPtr.Zero, (sourceRectangle.HasValue)?&sourceRectangle_:(void*)IntPtr.Zero);
            }
        }
        
        /// <summary>	
        /// Draws the specified bitmap after scaling it to the size of the specified rectangle. 	
        /// </summary>	
        /// <remarks>	
        /// This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{DrawBitmap}}) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> methods. 	
        /// </remarks>	
        /// <param name="bitmap">The bitmap to render.</param>
        /// <param name="destinationRectangle">The size and position, in device-independent pixels in the render target's coordinate space, of the area to which the bitmap is drawn; NULL to draw the selected portion of the bitmap at the origin of the render target.  If the rectangle is specified but not well-ordered, nothing is drawn, but the render target does not enter an error state.</param>
        /// <param name="opacity">A value between 0.0f and 1.0f, inclusive, that specifies an opacity value to apply to the bitmap; this value is multiplied against the alpha values of the bitmap's contents.  The default value is 1.0f.</param>
        /// <param name="interpolationMode">The interpolation mode to use if the bitmap is scaled or rotated by the drawing operation. The default value is <see cref="SlimDX2.Direct2D1.BitmapInterpolationMode.Linear"/>. </param>
        /// <param name="sourceRectangle">The size and position, in device-independent pixels in the bitmap's coordinate space, of the area within the bitmap to be drawn; NULL to draw the entire bitmap. </param>
        /// <unmanaged>void ID2D1RenderTarget::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_RECT_F* destinationRectangle,[None] FLOAT opacity,[None] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D1_RECT_F* sourceRectangle)</unmanaged>
        public void DrawBitmap(SlimDX2.Direct2D1.Bitmap bitmap, SlimDX2.RectangleF? destinationRectangle, float opacity, SlimDX2.Direct2D1.BitmapInterpolationMode interpolationMode, SlimDX2.RectangleF? sourceRectangle) {
            unsafe {
                SlimDX2.RectangleF destinationRectangle_;
                if (destinationRectangle.HasValue)
                    destinationRectangle_ = destinationRectangle.Value;				
                SlimDX2.RectangleF sourceRectangle_;
                if (sourceRectangle.HasValue)
                    sourceRectangle_ = sourceRectangle.Value;				
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 26 * 4, (void*)((bitmap == null)?IntPtr.Zero:bitmap.NativePointer), (destinationRectangle.HasValue)?&destinationRectangle_:(void*)IntPtr.Zero, opacity, unchecked((int)interpolationMode), (sourceRectangle.HasValue)?&sourceRectangle_:(void*)IntPtr.Zero);
            }
        }
        
        /// <summary>	
        /// Draws the specified text using the format information provided by an <see cref="SlimDX2.DirectWrite.TextFormat"/> object. 	
        /// </summary>	
        /// <remarks>	
        /// To create an <see cref="SlimDX2.DirectWrite.TextFormat"/> object, create an <see cref="SlimDX2.DirectWrite.Factory"/> and call its {{CreateTextFormat}} method.This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{DrawText}}) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> methods. 	
        /// </remarks>	
        /// <param name="@string">A pointer to an array of Unicode characters to draw. </param>
        /// <param name="stringLength">The number of characters in string.</param>
        /// <param name="textFormat">An object that describes formatting details of the text to draw, such as the font, the font size, and flow direction.  </param>
        /// <param name="layoutRect">The size and position of the area in which the text is drawn. </param>
        /// <param name="defaultForegroundBrush">The brush used to paint the text.</param>
        /// <param name="options">A value that indicates whether the text should be snapped to pixel boundaries and whether the text should be clipped to the layout rectangle. The default value is <see cref="SlimDX2.Direct2D1.DrawTextOptions.None"/>, which indicates that text should be snapped to pixel boundaries and it should not be clipped to the layout rectangle.</param>
        /// <param name="measuringMode">A value that indicates how glyph metrics are used to measure text when it is formatted.  The default value is DWRITE_MEASURING_MODE_NATURAL. </param>
        /// <unmanaged>void ID2D1RenderTarget::DrawTextA([In, Buffer] const wchar* string,[None] UINT stringLength,[In] IDWriteTextFormat* textFormat,[In] const D2D1_RECT_F* layoutRect,[In] ID2D1Brush* defaultForegroundBrush,[None] D2D1_DRAW_TEXT_OPTIONS options,[None] DWRITE_MEASURING_MODE measuringMode)</unmanaged>
        public void DrawTextA(string @string, int stringLength, SlimDX2.DirectWrite.TextFormat textFormat, SlimDX2.RectangleF layoutRect, SlimDX2.Direct2D1.Brush defaultForegroundBrush, SlimDX2.Direct2D1.DrawTextOptions options, SlimDX2.DirectWrite.MeasuringMode measuringMode) {
            unsafe {
                IntPtr @string_ = Marshal.StringToHGlobalUni(@string);
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 27 * 4, (void*)@string_, stringLength, (void*)((textFormat == null)?IntPtr.Zero:textFormat.NativePointer), &layoutRect, (void*)((defaultForegroundBrush == null)?IntPtr.Zero:defaultForegroundBrush.NativePointer), unchecked((int)options), unchecked((int)measuringMode));
                Marshal.FreeHGlobal(@string_ );
            }
        }
        
        /// <summary>	
        /// Draws the formatted text described by the specified <see cref="SlimDX2.DirectWrite.TextLayout"/> object.	
        /// </summary>	
        /// <remarks>	
        /// When drawing the same text repeatedly, using the DrawTextLayout method is more efficient than using the {{DrawText}} method because the text doesn't need to be formatted and the layout processed with each call.This method doesn't return an error code if it fails. To determine whether a drawing operation (such as DrawTextLayout) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> methods. 	
        /// </remarks>	
        /// <param name="origin">The point, described in device-independent pixels, at which the upper-left corner of the text described by textLayout is drawn.</param>
        /// <param name="textLayout">The formatted text to draw. Any drawing effects that do not inherit from <see cref="SlimDX2.Direct2D1.Resource"/> are ignored. If there are drawing effects that inherit from ID2D1Resource that are not brushes, this method fails and the render target is put in an error state. </param>
        /// <param name="defaultForegroundBrush">The brush used to paint any text in textLayout that does not already have a brush associated with it as a drawing effect (specified by the <see cref="SlimDX2.DirectWrite.TextLayout.SetDrawingEffect"/> method). </param>
        /// <param name="options">A value that indicates whether the text should be snapped to pixel boundaries and whether the text should be clipped to the layout rectangle. The default value is <see cref="SlimDX2.Direct2D1.DrawTextOptions.None"/>, which indicates that text should be snapped to pixel boundaries and it should not be clipped to the layout rectangle.</param>
        /// <unmanaged>void ID2D1RenderTarget::DrawTextLayout([None] D2D1_POINT_2F origin,[In] IDWriteTextLayout* textLayout,[In] ID2D1Brush* defaultForegroundBrush,[None] D2D1_DRAW_TEXT_OPTIONS options)</unmanaged>
        public void DrawTextLayout(System.Drawing.PointF origin, SlimDX2.DirectWrite.TextLayout textLayout, SlimDX2.Direct2D1.Brush defaultForegroundBrush, SlimDX2.Direct2D1.DrawTextOptions options) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 28 * 4, origin, (void*)((textLayout == null)?IntPtr.Zero:textLayout.NativePointer), (void*)((defaultForegroundBrush == null)?IntPtr.Zero:defaultForegroundBrush.NativePointer), unchecked((int)options));
            }
        }
        
        /// <summary>	
        /// Draws the specified glyphs. 	
        /// </summary>	
        /// <remarks>	
        /// This method doesn't return an error code if it fails. To determine whether a drawing operation (such as DrawGlyphRun) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> methods. 	
        /// </remarks>	
        /// <param name="baselineOrigin">The origin, in device-independent pixels, of the glyphs' baseline.</param>
        /// <param name="glyphRun">The glyphs to render.</param>
        /// <param name="foregroundBrush">The brush used to paint the specified glyphs.</param>
        /// <param name="measuringMode">A value that indicates how glyph metrics are used to measure text when it is formatted.  The default value is DWRITE_MEASURING_MODE_NATURAL. </param>
        /// <unmanaged>void ID2D1RenderTarget::DrawGlyphRun([None] D2D1_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] ID2D1Brush* foregroundBrush,[None] DWRITE_MEASURING_MODE measuringMode)</unmanaged>
        public void DrawGlyphRun(System.Drawing.PointF baselineOrigin, SlimDX2.DirectWrite.GlyphRun glyphRun, SlimDX2.Direct2D1.Brush foregroundBrush, SlimDX2.DirectWrite.MeasuringMode measuringMode) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 29 * 4, baselineOrigin, &glyphRun, (void*)((foregroundBrush == null)?IntPtr.Zero:foregroundBrush.NativePointer), unchecked((int)measuringMode));
            }
        }
        
        /// <summary>	
        ///  Applies the specified transform to the render target, replacing the existing transformation. All subsequent drawing operations occur in the transformed space.	
        /// </summary>	
        /// <param name="transform">The transform to apply to the render target.</param>
        /// <unmanaged>void ID2D1RenderTarget::SetTransform([In] const D2D1_MATRIX_3X2_F* transform)</unmanaged>
        internal void SetTransform(ref SlimDX2.Direct2D1.Matrix3x2 transform) {
            unsafe {
                fixed (void* transform_ = &transform)
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 30 * 4, transform_);
            }
        }
        
        /// <summary>	
        /// Gets the current transform of the render target. 	
        /// </summary>	
        /// <param name="transform">When this returns, contains the current transform of the render target. This parameter is passed uninitialized.</param>
        /// <unmanaged>void ID2D1RenderTarget::GetTransform([Out] D2D1_MATRIX_3X2_F* transform)</unmanaged>
        internal void GetTransform(out SlimDX2.Direct2D1.Matrix3x2 transform) {
            unsafe {
                transform = new SlimDX2.Direct2D1.Matrix3x2();
                fixed (void* transform_ = &transform)
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 31 * 4, transform_);
            }
        }
        
        /// <summary>	
        /// Sets the antialiasing mode of the render target. The antialiasing mode applies to all subsequent drawing operations, excluding text and glyph drawing operations. 	
        /// </summary>	
        /// <remarks>	
        /// To specify the antialiasing mode for text and glyph operations, use the {{SetTextAntialiasMode}} method. 	
        /// </remarks>	
        /// <param name="antialiasMode">The antialiasing mode for future drawing operations. </param>
        /// <unmanaged>void ID2D1RenderTarget::SetAntialiasMode([None] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>
        internal void SetAntialiasMode(SlimDX2.Direct2D1.AntialiasMode antialiasMode) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 32 * 4, unchecked((int)antialiasMode));
            }
        }
        
        /// <summary>	
        ///  Retrieves the current antialiasing mode for nontext drawing operations.	
        /// </summary>	
        /// <returns>The current antialiasing mode for nontext drawing operations. </returns>
        /// <unmanaged>D2D1_ANTIALIAS_MODE ID2D1RenderTarget::GetAntialiasMode()</unmanaged>
        internal SlimDX2.Direct2D1.AntialiasMode GetAntialiasMode() {
            unsafe {
                SlimDX2.Direct2D1.AntialiasMode __result__;
                __result__= (SlimDX2.Direct2D1.AntialiasMode)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 33 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Specifies the antialiasing mode to use for subsequent text and glyph drawing operations. 	
        /// </summary>	
        /// <param name="textAntialiasMode">The antialiasing mode to use for subsequent text and glyph drawing operations.</param>
        /// <unmanaged>void ID2D1RenderTarget::SetTextAntialiasMode([None] D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode)</unmanaged>
        internal void SetTextAntialiasMode(SlimDX2.Direct2D1.TextAntialiasMode textAntialiasMode) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 34 * 4, unchecked((int)textAntialiasMode));
            }
        }
        
        /// <summary>	
        /// Gets the current antialiasing mode for text and glyph drawing operations. 	
        /// </summary>	
        /// <returns>The current antialiasing mode for text and glyph drawing operations. </returns>
        /// <unmanaged>D2D1_TEXT_ANTIALIAS_MODE ID2D1RenderTarget::GetTextAntialiasMode()</unmanaged>
        internal SlimDX2.Direct2D1.TextAntialiasMode GetTextAntialiasMode() {
            unsafe {
                SlimDX2.Direct2D1.TextAntialiasMode __result__;
                __result__= (SlimDX2.Direct2D1.TextAntialiasMode)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 35 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Specifies text rendering options to be applied to all subsequent text and glyph drawing operations. 	
        /// </summary>	
        /// <remarks>	
        /// If the settings specified by  textRenderingParams are incompatible with the render target's text antialiasing mode (specified by {{SetTextAntialiasMode}}), subsequent text and glyph drawing operations will fail and put the render target into an error state.	
        /// </remarks>	
        /// <param name="textRenderingParams">The text rendering options to be applied to all subsequent text and glyph drawing operations; NULL to clear current text rendering options. </param>
        /// <unmanaged>void ID2D1RenderTarget::SetTextRenderingParams([In, Optional] IDWriteRenderingParams* textRenderingParams)</unmanaged>
        internal void SetTextRenderingParams(SlimDX2.DirectWrite.RenderingParams textRenderingParams) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 36 * 4, (void*)((textRenderingParams == null)?IntPtr.Zero:textRenderingParams.NativePointer));
            }
        }
        
        /// <summary>	
        /// Retrieves the render target's current text rendering options. 	
        /// </summary>	
        /// <remarks>	
        /// If the settings specified by  textRenderingParams are incompatible with the render target's text antialiasing mode (specified by {{SetTextAntialiasMode}}), subsequent text and glyph drawing operations will fail and put the render target into an error state.	
        /// </remarks>	
        /// <param name="textRenderingParams"> When this method returns, textRenderingParamscontains the address  of a pointer to the render target's current text rendering options. </param>
        /// <unmanaged>void ID2D1RenderTarget::GetTextRenderingParams([Out, Optional] IDWriteRenderingParams** textRenderingParams)</unmanaged>
        internal void GetTextRenderingParams(out SlimDX2.DirectWrite.RenderingParams textRenderingParams) {
            unsafe {
                IntPtr textRenderingParams_ = IntPtr.Zero;
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 37 * 4, &textRenderingParams_);
                textRenderingParams = (textRenderingParams_ == IntPtr.Zero)?null:new SlimDX2.DirectWrite.RenderingParams(textRenderingParams_);	
            }
        }
        
        /// <summary>	
        /// Specifies a label for subsequent drawing operations.   	
        /// </summary>	
        /// <remarks>	
        /// The labels specified by this method are printed by debug error messages. If no tag is set, the default value for each tag is 0.	
        /// </remarks>	
        /// <param name="tag1">A label to apply to subsequent drawing operations.</param>
        /// <param name="tag2">A label to apply to subsequent drawing operations.</param>
        /// <unmanaged>void ID2D1RenderTarget::SetTags([None] D2D1_TAG tag1,[None] D2D1_TAG tag2)</unmanaged>
        public void SetTags(long tag1, long tag2) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 38 * 4, tag1, tag2);
            }
        }
        
        /// <summary>	
        /// Gets the label for subsequent drawing operations. 	
        /// </summary>	
        /// <remarks>	
        /// If the same address is passed for both parameters, both parameters receive the value of the second tag. 	
        /// </remarks>	
        /// <param name="tag1">When this method returns, contains the first label for subsequent drawing operations. This parameter is passed uninitialized. If NULL is specified, no value is retrieved for this parameter. </param>
        /// <param name="tag2">When this method returns, contains the second label for subsequent drawing operations. This parameter is passed uninitialized. If NULL is specified, no value is retrieved for this parameter.</param>
        /// <unmanaged>void ID2D1RenderTarget::GetTags([Out, Optional] D2D1_TAG* tag1,[Out, Optional] D2D1_TAG* tag2)</unmanaged>
        public void GetTags(out long tag1, out long tag2) {
            unsafe {
                fixed (void* tag1_ = &tag1)
                    fixed (void* tag2_ = &tag2)
                        SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 39 * 4, tag1_, tag2_);
            }
        }
        
        /// <summary>	
        /// Adds the specified layer to the render target so that it receives all subsequent drawing operations until {{PopLayer}} is called. 	
        /// </summary>	
        /// <remarks>	
        /// The {{PushLayer}} method allows a caller to begin redirecting rendering to a layer. All rendering operations are valid in a layer. The location of the layer is affected by the world transform set on the render target. Each {{PushLayer}} must have a matching {{PopLayer}} call. If there are more PopLayer calls than PushLayer calls, the render target is placed into an error state. If {{Flush}} is called before all outstanding layers are popped, the render target is placed into an error state, and an error is returned. The error state can be cleared by a call to {{EndDraw}}.A particular <see cref="SlimDX2.Direct2D1.Layer"/> resource can be active only at one time. In other words, you cannot call a {{PushLayer}} method, and then  immediately follow with another PushLayer method with the same layer resource. Instead, you must call the second PushLayer method with different layer resources. 	
        /// This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{PushLayer}}) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> methods. 	
        /// </remarks>	
        /// <param name="layerParameters">The content bounds, geometric mask, opacity, opacity mask, and antialiasing options for the layer. </param>
        /// <param name="layer">The layer that receives subsequent drawing operations.</param>
        /// <unmanaged>void ID2D1RenderTarget::PushLayer([In] const D2D1_LAYER_PARAMETERS* layerParameters,[In] ID2D1Layer* layer)</unmanaged>
        public void PushLayer(ref SlimDX2.Direct2D1.LayerParameters layerParameters, SlimDX2.Direct2D1.Layer layer) {
            unsafe {
                fixed (void* layerParameters_ = &layerParameters)
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 40 * 4, layerParameters_, (void*)((layer == null)?IntPtr.Zero:layer.NativePointer));
            }
        }
        
        /// <summary>	
        /// Stops redirecting drawing operations to the layer that is specified by the last {{PushLayer}} call. 	
        /// </summary>	
        /// <remarks>	
        /// A PopLayer must match a previous {{PushLayer}} call.This method doesn't return an error code if it fails. To determine whether a drawing operation (such as PopLayer) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> methods. 	
        /// </remarks>	
        /// <unmanaged>void ID2D1RenderTarget::PopLayer()</unmanaged>
        public void PopLayer() {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 41 * 4);
            }
        }
        
        /// <summary>	
        /// Executes all pending drawing commands. 	
        /// </summary>	
        /// <remarks>	
        /// This command does not flush the device that is associated with the render target.  Calling this method resets the error state of the render target.	
        /// </remarks>	
        /// <param name="tag1">When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</param>
        /// <param name="tag2">When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code and sets tag1 and tag2 to the tags that were active when the error occurred. If no error occurred, this method sets the error tag state to be (0,0).</returns>
        /// <unmanaged>HRESULT ID2D1RenderTarget::Flush([Out, Optional] D2D1_TAG* tag1,[Out, Optional] D2D1_TAG* tag2)</unmanaged>
        public SlimDX2.Result Flush(out long tag1, out long tag2) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* tag1_ = &tag1)
                    fixed (void* tag2_ = &tag2)
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 42 * 4, tag1_, tag2_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Saves the current drawing state to the specified <see cref="SlimDX2.Direct2D1.DrawingStateBlock"/>.	
        /// </summary>	
        /// <param name="drawingStateBlock">When this method returns, contains the current drawing state of the render target. This parameter must be initialized before passing it to the method.</param>
        /// <unmanaged>void ID2D1RenderTarget::SaveDrawingState([InOut] ID2D1DrawingStateBlock* drawingStateBlock)</unmanaged>
        public void SaveDrawingState(SlimDX2.Direct2D1.DrawingStateBlock drawingStateBlock) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 43 * 4, (void*)((drawingStateBlock == null)?IntPtr.Zero:drawingStateBlock.NativePointer));
            }
        }
        
        /// <summary>	
        /// Sets the render target's drawing state to that of the specified <see cref="SlimDX2.Direct2D1.DrawingStateBlock"/>.	
        /// </summary>	
        /// <param name="drawingStateBlock">The new drawing state of the render target.</param>
        /// <unmanaged>void ID2D1RenderTarget::RestoreDrawingState([In] ID2D1DrawingStateBlock* drawingStateBlock)</unmanaged>
        public void RestoreDrawingState(SlimDX2.Direct2D1.DrawingStateBlock drawingStateBlock) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 44 * 4, (void*)((drawingStateBlock == null)?IntPtr.Zero:drawingStateBlock.NativePointer));
            }
        }
        
        /// <summary>	
        /// Specifies a rectangle to which all subsequent drawing operations are clipped. 	
        /// </summary>	
        /// <remarks>	
        /// The clipRect is transformed by the current world transform set on the render target. After the transform is applied to the clipRect that is passed in, the axis-aligned bounding box for the clipRect is computed.  For efficiency, the contents are clipped to this axis-aligned bounding box and not to the original clipRect that is passed in. The following diagrams show how a rotation transform is applied to the render target, the resulting clipRect, and  a calculated axis-aligned bounding box.Assume the rectangle in the following illustration is a render target that is aligned to the screen pixels.Illustration of a rectangle (render target)Apply a rotation transform to the render target. In the following illustration, the black rectangle represents the original render target and the red dashed rectangle represents the transformed render target.Illustration of a rotated rectangle (transformed render target)After calling {{PushAxisAlignedClip}}, the rotation transform is applied to the clipRect. In the following illustration, the blue rectangle represents the transformed clipRect.Illustration of a small blue rectangle (transformed clipRect) inside a rotated rectangleThe axis-aligned bounding box is calculated. The green dashed rectangle represents the bounding box in the following illustration. All contents are clipped to this axis-aligned bounding box.Illustration of a green bounding box around a small blue rectangle inside a rotated rectangleNote??If rendering operations fail or if {{PopAxisAlignedClip}} is not called, clip rects may cause some artifacts on the render target. PopAxisAlignedClip can be considered a drawing operation that is designed to fix the borders of a clipping region. Without this call, the borders of a clipped area may be not antialiased or otherwise corrected.The {{PushAxisAlignedClip}} and {{PopAxisAlignedClip}} must match. Otherwise, the error state is set. For the render target to continue receiving new commands, you can call {{Flush}} to clear the error. A           {{PushAxisAlignedClip}} and {{PopAxisAlignedClip}} pair can occur around or within a PushLayer and PopLayer, but cannot overlap. For example, the sequence of PushAxisAlignedClip, {{PushLayer}}, {{PopLayer}}, PopAxisAlignedClip is valid, but the sequence of PushAxisAlignedClip, PushLayer, PopAxisAlignedClip, PopLayer is invalid.This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{PushAxisAlignedClip}}) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> methods. 	
        /// </remarks>	
        /// <param name="clipRect">The size and position of the clipping area, in device-independent pixels.</param>
        /// <param name="antialiasMode">The antialiasing mode that is used to draw the edges of clip rects that have subpixel boundaries, and to blend the clip with the scene contents. The blending is performed once when the {{PopAxisAlignedClip}} method is called, and does not apply to each primitive within the layer. </param>
        /// <unmanaged>void ID2D1RenderTarget::PushAxisAlignedClip([In] const D2D1_RECT_F* clipRect,[None] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>
        public void PushAxisAlignedClip(SlimDX2.RectangleF clipRect, SlimDX2.Direct2D1.AntialiasMode antialiasMode) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 45 * 4, &clipRect, unchecked((int)antialiasMode));
            }
        }
        
        /// <summary>	
        /// Removes the last axis-aligned clip from the render target. After this method is called, the clip is no longer applied to subsequent drawing operations. 	
        /// </summary>	
        /// <remarks>	
        /// A {{PushAxisAlignedClip}}/PopAxisAlignedClip pair can occur around or within a {{PushLayer}}/{{PopLayer}} pair, but may not overlap. For example, a PushAxisAlignedClip, PushLayer, PopLayer, PopAxisAlignedClip sequence is valid, but a PushAxisAlignedClip, PushLayer, PopAxisAlignedClip, PopLayer sequence is not. PopAxisAlignedClip must be called once for every call to {{PushAxisAlignedClip}}.For an example, see {{How to Clip with an Axis-Aligned Clip Rectangle}}.This method doesn't return an error code if it fails. To determine whether a drawing operation (such as PopAxisAlignedClip) failed, check the result returned by the <see cref="SlimDX2.Direct2D1.RenderTarget.EndDraw"/> or <see cref="SlimDX2.Direct2D1.RenderTarget.Flush"/> methods. 	
        /// </remarks>	
        /// <unmanaged>void ID2D1RenderTarget::PopAxisAlignedClip()</unmanaged>
        public void PopAxisAlignedClip() {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 46 * 4);
            }
        }
        
        /// <summary>	
        /// Clears the drawing area to the specified color. 	
        /// </summary>	
        /// <remarks>	
        /// Direct2D interprets the clearColor as straight alpha (not premultiplied).  If the render target's alpha mode is <see cref="SlimDX2.Direct2D1.AlphaMode.Ignore"/>, the alpha channel of clearColor is ignored and replaced with 1.0f (fully opaque).If the render target has an active clip (specified by {{PushAxisAlignedClip}}), the clear command is applied only to the area within the clip region.	
        /// </remarks>	
        /// <param name="clearColor">The color to which the drawing area is cleared, or NULL for transparent black.</param>
        /// <unmanaged>void ID2D1RenderTarget::Clear([In, Optional] const D2D1_COLOR_F* clearColor)</unmanaged>
        public void Clear(SlimMath.Color4? clearColor) {
            unsafe {
                SlimMath.Color4 clearColor_;
                if (clearColor.HasValue)
                    clearColor_ = clearColor.Value;				
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 47 * 4, (clearColor.HasValue)?&clearColor_:(void*)IntPtr.Zero);
            }
        }
        
        /// <summary>	
        /// Initiates drawing on this render target. 	
        /// </summary>	
        /// <remarks>	
        /// Drawing operations can only be issued between a BeginDraw and {{EndDraw}} call.BeginDraw and EndDraw are used to indicate that a render target is in use by the Direct2D system. Different implementations of <see cref="SlimDX2.Direct2D1.RenderTarget"/> might behave differently when BeginDraw is called. An <see cref="SlimDX2.Direct2D1.BitmapRenderTarget"/> may be locked between BeginDraw/{{EndDraw}} calls, a DXGI surface render target might be acquired on BeginDraw and released on EndDraw, while an <see cref="SlimDX2.Direct2D1.HwndRenderTarget"/> may begin batching at BeginDraw and may present on EndDraw, for example. The BeginDraw method must be called before rendering operations can be called, though state-setting and state-retrieval operations can be performed even outside of BeginDraw/{{EndDraw}}. After BeginDraw is called, a render target will normally build up a batch of rendering commands, but defer processing of these commands until either an internal buffer is full, the {{Flush}} method is called, or until {{EndDraw}} is called. The EndDraw method causes any batched drawing operations to complete, and then returns an HRESULT indicating the success of the operations and, optionally, the tag state of the render target at the time the error occurred. The EndDraw method always succeeds: it should not be called twice even if a previous EndDraw resulted in a failing HRESULT. If {{EndDraw}} is called without a matched call to BeginDraw, it returns an error indicating that BeginDraw must be called before EndDraw. Calling BeginDraw twice on a render target puts the target into an error state where nothing further is drawn, and returns an appropriate HRESULT and error information when EndDraw is called.	
        /// </remarks>	
        /// <unmanaged>void ID2D1RenderTarget::BeginDraw()</unmanaged>
        public void BeginDraw() {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 48 * 4);
            }
        }
        
        /// <summary>	
        /// Ends drawing operations  on the render target and indicates the current error state and associated tags. 	
        /// </summary>	
        /// <remarks>	
        /// Drawing operations can only be issued between a {{BeginDraw}} and EndDraw call.BeginDraw and EndDraw are use to indicate that a render target is in use by the Direct2D system. Different implementations of <see cref="SlimDX2.Direct2D1.RenderTarget"/> might behave differently when {{BeginDraw}} is called. An <see cref="SlimDX2.Direct2D1.BitmapRenderTarget"/> may be locked between BeginDraw/EndDraw calls, a DXGI surface render target might be acquired on BeginDraw and released on EndDraw, while an <see cref="SlimDX2.Direct2D1.HwndRenderTarget"/> may begin batching at BeginDraw and may present on EndDraw, for example. The BeginDraw method must be called before rendering operations can be called, though state-setting and state-retrieval operations can be performed even outside of {{BeginDraw}}/EndDraw. After {{BeginDraw}} is called, a render target will normally build up a batch of rendering commands, but defer processing of these commands until either an internal buffer is full, the {{Flush}} method is called, or until EndDraw is called. The EndDraw method causes any batched drawing operations to complete, and then returns an HRESULT indicating the success of the operations and, optionally, the tag state of the render target at the time the error occurred. The EndDraw method always succeeds: it should not be called twice even if a previous EndDraw resulted in a failing HRESULT. If EndDraw is called without a matched call to {{BeginDraw}}, it returns an error indicating that BeginDraw must be called before EndDraw. Calling BeginDraw twice on a render target puts the target into an error state where nothing further is drawn, and returns an appropriate HRESULT and error information when EndDraw is called.	
        /// </remarks>	
        /// <param name="tag1">When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</param>
        /// <param name="tag2">When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code and sets tag1 and tag2 to the tags that were active when the error occurred. </returns>
        /// <unmanaged>HRESULT ID2D1RenderTarget::EndDraw([Out, Optional] D2D1_TAG* tag1,[Out, Optional] D2D1_TAG* tag2)</unmanaged>
        public SlimDX2.Result EndDraw(out long tag1, out long tag2) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* tag1_ = &tag1)
                    fixed (void* tag2_ = &tag2)
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 49 * 4, tag1_, tag2_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the pixel format and alpha mode of the render target. 	
        /// </summary>	
        /// <returns>The pixel format and alpha mode of the render target.</returns>
        /// <unmanaged>D2D1_PIXEL_FORMAT ID2D1RenderTarget::GetPixelFormat()</unmanaged>
        internal SlimDX2.Direct2D1.PixelFormat GetPixelFormat() {
            unsafe {
                SlimDX2.Direct2D1.PixelFormat __result__;
                SlimDX2.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, 50 * 4,(void*)&__result__);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets the dots per inch (DPI) of the render target. 	
        /// </summary>	
        /// <remarks>	
        /// This method specifies the mapping from pixel space to device-independent space  for the render target.  If both dpiX and dpiY are 0, the factory-read system DPI is chosen. If one parameter is zero and the other unspecified, the DPI is not changed.For <see cref="SlimDX2.Direct2D1.HwndRenderTarget"/>, the DPI defaults to the most recently factory-read system DPI. The default value for all other render targets is 96 DPI.  	
        /// </remarks>	
        /// <param name="dpiX">A value greater than or equal to zero that specifies the horizontal DPI of the render target.</param>
        /// <param name="dpiY">A value greater than or equal to zero that specifies the vertical DPI of the render target.</param>
        /// <unmanaged>void ID2D1RenderTarget::SetDpi([None] FLOAT dpiX,[None] FLOAT dpiY)</unmanaged>
        public void SetDpi(float dpiX, float dpiY) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 51 * 4, dpiX, dpiY);
            }
        }
        
        /// <summary>	
        /// Return the render target's dots per inch (DPI).	
        /// </summary>	
        /// <remarks>	
        /// This method indicates the mapping from pixel space to device-independent space  for the render target.  For <see cref="SlimDX2.Direct2D1.HwndRenderTarget"/>, the DPI defaults to the most recently factory-read system DPI. The default value for all other render targets is 96 DPI.  	
        /// </remarks>	
        /// <param name="dpiX">When this method returns, contains the horizontal DPI of the render target. This parameter is passed uninitialized.</param>
        /// <param name="dpiY">When this method returns, contains the vertical DPI of the render target. This parameter is passed uninitialized.</param>
        /// <unmanaged>void ID2D1RenderTarget::GetDpi([Out] FLOAT* dpiX,[Out] FLOAT* dpiY)</unmanaged>
        public void GetDpi(out float dpiX, out float dpiY) {
            unsafe {
                fixed (void* dpiX_ = &dpiX)
                    fixed (void* dpiY_ = &dpiY)
                        SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 52 * 4, dpiX_, dpiY_);
            }
        }
        
        /// <summary>	
        /// Returns the size of the render target in device-independent pixels.	
        /// </summary>	
        /// <returns>The current size of the render target in device-independent pixels.</returns>
        /// <unmanaged>D2D1_SIZE_F ID2D1RenderTarget::GetSize()</unmanaged>
        internal System.Drawing.SizeF GetSize() {
            unsafe {
                System.Drawing.SizeF __result__;
                SlimDX2.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, 53 * 4,(void*)&__result__);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Returns the size of the render target in device pixels.	
        /// </summary>	
        /// <returns>The size of the render target in device pixels.</returns>
        /// <unmanaged>D2D1_SIZE_U ID2D1RenderTarget::GetPixelSize()</unmanaged>
        internal System.Drawing.Size GetPixelSize() {
            unsafe {
                System.Drawing.Size __result__;
                SlimDX2.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, 54 * 4,(void*)&__result__);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the maximum size, in device-dependent units (pixels), of  any one bitmap dimension supported by the render target.	
        /// </summary>	
        /// <returns>UINT32 The maximum size, in pixels, of  any one bitmap dimension supported by the render target.</returns>
        /// <unmanaged>UINT32 ID2D1RenderTarget::GetMaximumBitmapSize()</unmanaged>
        internal int GetMaximumBitmapSize() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 55 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Indicates whether the render target supports the specified properties.	
        /// </summary>	
        /// <remarks>	
        /// This method does not evaluate the DPI settings specified by the renderTargetProperties parameter.	
        /// </remarks>	
        /// <param name="renderTargetProperties">The render target properties to test.</param>
        /// <returns>BOOLTRUE if the specified render target properties are supported by this render target; otherwise, FALSE.</returns>
        /// <unmanaged>BOOL ID2D1RenderTarget::IsSupported([In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties)</unmanaged>
        public bool IsSupported(ref SlimDX2.Direct2D1.RenderTargetProperties renderTargetProperties) {
            unsafe {
                bool __result__;
                fixed (void* renderTargetProperties_ = &renderTargetProperties)
                    __result__= (bool)(0!=SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 56 * 4, renderTargetProperties_));
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Renders to an intermediate texture created by the {{CreateCompatibleRenderTarget}} method.  	
    /// </summary>	
    /// <unmanaged>ID2D1BitmapRenderTarget</unmanaged>
    [Guid("2cd90695-12e2-11dc-9fed-001143a055f9")]
    public partial class BitmapRenderTarget : SlimDX2.Direct2D1.RenderTarget {
        public BitmapRenderTarget(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the bitmap for this render target. The returned bitmap can be used for drawing operations. 	
        /// </summary>	
        /// <remarks>	
        /// The DPI for the <see cref="SlimDX2.Direct2D1.Bitmap"/> obtained from GetBitmap will be the DPI of the <see cref="SlimDX2.Direct2D1.BitmapRenderTarget"/> when the render target was created. Changing the DPI of the ID2D1BitmapRenderTarget by calling  {{SetDpi}} doesn't affect the DPI of the bitmap, even if SetDpi is called before GetBitmap. Using SetDpi to change the DPI of the ID2D1BitmapRenderTarget does affect how contents are rendered into the bitmap: it just doesn't affect the DPI of the bitmap retrieved by GetBitmap.	
        /// </remarks>	
        /// <unmanaged>HRESULT ID2D1BitmapRenderTarget::GetBitmap([Out] ID2D1Bitmap** bitmap)</unmanaged>
        public SlimDX2.Direct2D1.Bitmap Bitmap {
                get { SlimDX2.Direct2D1.Bitmap __output__; GetBitmap(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Retrieves the bitmap for this render target. The returned bitmap can be used for drawing operations. 	
        /// </summary>	
        /// <remarks>	
        /// The DPI for the <see cref="SlimDX2.Direct2D1.Bitmap"/> obtained from GetBitmap will be the DPI of the <see cref="SlimDX2.Direct2D1.BitmapRenderTarget"/> when the render target was created. Changing the DPI of the ID2D1BitmapRenderTarget by calling  {{SetDpi}} doesn't affect the DPI of the bitmap, even if SetDpi is called before GetBitmap. Using SetDpi to change the DPI of the ID2D1BitmapRenderTarget does affect how contents are rendered into the bitmap: it just doesn't affect the DPI of the bitmap retrieved by GetBitmap.	
        /// </remarks>	
        /// <param name="bitmap">When this method returns, contains the address of a pointer to the bitmap for this render target. This bitmap can be used for drawing operations. </param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1BitmapRenderTarget::GetBitmap([Out] ID2D1Bitmap** bitmap)</unmanaged>
        internal SlimDX2.Result GetBitmap(out SlimDX2.Direct2D1.Bitmap bitmap) {
            unsafe {
                IntPtr bitmap_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 57 * 4, &bitmap_);
                bitmap = (bitmap_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.Bitmap(bitmap_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Renders drawing instructions to a window.	
    /// </summary>	
    /// <unmanaged>ID2D1HwndRenderTarget</unmanaged>
    [Guid("2cd90698-12e2-11dc-9fed-001143a055f9")]
    public partial class HwndRenderTarget : SlimDX2.Direct2D1.RenderTarget {
        public HwndRenderTarget(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Returns the HWND associated with this render target.	
        /// </summary>	
        /// <unmanaged>HWND ID2D1HwndRenderTarget::GetHwnd()</unmanaged>
        public IntPtr Hwnd {
                get { return GetHwnd(); }
        }
        
        /// <summary>	
        /// Indicates whether the HWND associated with this render target is occluded. 	
        /// </summary>	
        /// <remarks>	
        /// Note??If the window was occluded the last time  {{EndDraw}} was called, the next time the render target calls CheckWindowState, it will return <see cref="SlimDX2.Direct2D1.WindowState.Occluded"/> regardless of the current window state. If you want to use CheckWindowState to determine the current window state, you should call CheckWindowState after every EndDraw call and ignore its return value. This will ensure that your next call to CheckWindowState state will return the actual window state.	
        /// </remarks>	
        /// <returns>D2D1_WINDOW_STATEA value that indicates whether the HWND associated with this render target is occluded.</returns>
        /// <unmanaged>D2D1_WINDOW_STATE ID2D1HwndRenderTarget::CheckWindowState()</unmanaged>
        public SlimDX2.Direct2D1.WindowState CheckWindowState() {
            unsafe {
                SlimDX2.Direct2D1.WindowState __result__;
                __result__= (SlimDX2.Direct2D1.WindowState)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 57 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Changes the size of the render target to the specified pixel size.	
        /// </summary>	
        /// <remarks>	
        /// After this method is called, the contents of the render target's back-buffer are not defined, even if the <see cref="SlimDX2.Direct2D1.PresentOptions.RetainContents"/> option was specified when the render target was created.	
        /// </remarks>	
        /// <param name="ixelSizeRef">The new size of the render target in device pixels.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1HwndRenderTarget::Resize([In] const D2D1_SIZE_U* pixelSize)</unmanaged>
        public SlimDX2.Result Resize(System.Drawing.Size ixelSizeRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 58 * 4, &ixelSizeRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Returns the HWND associated with this render target.	
        /// </summary>	
        /// <returns>HWNDThe HWND associated with this render target.</returns>
        /// <unmanaged>HWND ID2D1HwndRenderTarget::GetHwnd()</unmanaged>
        internal IntPtr GetHwnd() {
            unsafe {
                IntPtr __result__;
                __result__= (IntPtr)SlimDX2.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, 59 * 4);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Provides access to an device context that can accept GDI drawing commands. 	
    /// </summary>	
    /// <unmanaged>ID2D1GdiInteropRenderTarget</unmanaged>
    [Guid("e0db51c3-6f77-4bae-b3d5-e47509b35838")]
    public partial class GdiInteropRenderTarget : SlimDX2.ComObject {
        public GdiInteropRenderTarget(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Retrieves the device context associated with this render target. 	
        /// </summary>	
        /// <remarks>	
        /// Calling this method flushes the render target.This command can be called only after {{BeginDraw}} and before {{EndDraw}}. It should not be called between {{PushAxisAlignedClip}}/{{PopAxisAlignedClip}} commands or between {{PushLayer}}/{{PopLayer}}.{{ReleaseDC}} must be called once for each call to GetDC.	
        /// </remarks>	
        /// <param name="mode">A value that specifies whether the device context should be cleared.</param>
        /// <param name="hdc">When this method returns, contains the device context associated with this render target. You must allocate storage for this parameter.  </param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1GdiInteropRenderTarget::GetDC([None] D2D1_DC_INITIALIZE_MODE mode,[Out] HDC* hdc)</unmanaged>
        public SlimDX2.Result GetDC(SlimDX2.Direct2D1.DcInitializeMode mode, out IntPtr hdc) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* hdc_ = &hdc)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4, unchecked((int)mode), hdc_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Indicates that drawing with the device context retrieved using the {{GetDC}} method is finished.  	
        /// </summary>	
        /// <remarks>	
        /// ReleaseDC must be called once for each call to {{GetDC}}.	
        /// </remarks>	
        /// <param name="update">The modified region of the device context, or NULL to specify the entire render target. </param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1GdiInteropRenderTarget::ReleaseDC([In, Optional] const RECT* update)</unmanaged>
        public SlimDX2.Result ReleaseDC(SlimDX2.Rectangle? update) {
            unsafe {
                SlimDX2.Rectangle update_;
                if (update.HasValue)
                    update_ = update.Value;				
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4, (update.HasValue)?&update_:(void*)IntPtr.Zero);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Issues drawing commands to a GDI device context. 	
    /// </summary>	
    /// <unmanaged>ID2D1DCRenderTarget</unmanaged>
    [Guid("1c51bc64-de61-46fd-9899-63a5d8f03950")]
    public partial class DCRenderTarget : SlimDX2.Direct2D1.RenderTarget {
        public DCRenderTarget(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        ///  Binds the render target to the device context to which it issues drawing commands.	
        /// </summary>	
        /// <remarks>	
        /// Before you can render with the DC render target, you must use its BindDC method to associate it with a GDI DC.  You do this each time you  use a different DC, or the size of the area you want to draw to changes.	
        /// </remarks>	
        /// <param name="hDC">The device context to which the render target issues drawing commands.</param>
        /// <param name="subRectRef">The dimensions of the handle to a device context (HDC) to which the render target is bound. </param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1DCRenderTarget::BindDC([In] const HDC hDC,[In] const RECT* pSubRect)</unmanaged>
        public SlimDX2.Result BindDC(IntPtr hDC, SlimDX2.Rectangle subRectRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 57 * 4, (void*)hDC, &subRectRef);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Creates Direct2D resources.	
    /// </summary>	
    /// <unmanaged>ID2D1Factory</unmanaged>
    [Guid("06152247-6f50-465a-9245-118bfd3b6007")]
    public partial class Factory : SlimDX2.ComObject {
        public Factory(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Forces the factory to refresh any system defaults that it might have changed since factory creation.	
        /// </summary>	
        /// <remarks>	
        /// You should call this method before calling the {{GetDesktopDpi}} method, to ensure that the system DPI is current.	
        /// </remarks>	
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Factory::ReloadSystemMetrics()</unmanaged>
        public SlimDX2.Result ReloadSystemMetrics() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 3 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Retrieves the current desktop dots per inch (DPI). To refresh this value, call {{ReloadSystemMetrics}}.	
        /// </summary>	
        /// <remarks>	
        /// Use this method to obtain the system DPI when setting physical pixel values, such as when you specify the size of a window.	
        /// </remarks>	
        /// <param name="dpiX"> When this method returns, contains the horizontal DPI of the desktop. You must allocate storage for this parameter.</param>
        /// <param name="dpiY">When this method returns, contains the vertical DPI of the desktop. You must allocate storage for this parameter. </param>
        /// <unmanaged>void ID2D1Factory::GetDesktopDpi([Out] FLOAT* dpiX,[Out] FLOAT* dpiY)</unmanaged>
        public void GetDesktopDpi(out float dpiX, out float dpiY) {
            unsafe {
                fixed (void* dpiX_ = &dpiX)
                    fixed (void* dpiY_ = &dpiY)
                        SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 4 * 4, dpiX_, dpiY_);
            }
        }
        
        /// <summary>	
        ///  Creates an <see cref="SlimDX2.Direct2D1.RectangleGeometry"/>. 	
        /// </summary>	
        /// <param name="rectangle">The coordinates of the rectangle geometry. </param>
        /// <param name="rectangleGeometry">When this method returns, contains the address of the pointer to the rectangle geometry created by this method.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Factory::CreateRectangleGeometry([In] const D2D1_RECT_F* rectangle,[Out] ID2D1RectangleGeometry** rectangleGeometry)</unmanaged>
        internal SlimDX2.Result CreateRectangleGeometry(SlimDX2.RectangleF rectangle, out SlimDX2.Direct2D1.RectangleGeometry rectangleGeometry) {
            unsafe {
                IntPtr rectangleGeometry_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 5 * 4, &rectangle, &rectangleGeometry_);
                rectangleGeometry = (rectangleGeometry_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.RectangleGeometry(rectangleGeometry_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        ///  Creates an <see cref="SlimDX2.Direct2D1.RoundedRectangleGeometry"/>. 	
        /// </summary>	
        /// <param name="roundedRectangle">The coordinates and corner radii of the rounded rectangle geometry.</param>
        /// <param name="roundedRectangleGeometry">When this method returns, contains the address of the pointer to the rounded rectangle geometry created by this method.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Factory::CreateRoundedRectangleGeometry([In] const D2D1_ROUNDED_RECT* roundedRectangle,[Out] ID2D1RoundedRectangleGeometry** roundedRectangleGeometry)</unmanaged>
        internal SlimDX2.Result CreateRoundedRectangleGeometry(ref SlimDX2.Direct2D1.RoundedRect roundedRectangle, out SlimDX2.Direct2D1.RoundedRectangleGeometry roundedRectangleGeometry) {
            unsafe {
                IntPtr roundedRectangleGeometry_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* roundedRectangle_ = &roundedRectangle)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 6 * 4, roundedRectangle_, &roundedRectangleGeometry_);
                roundedRectangleGeometry = (roundedRectangleGeometry_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.RoundedRectangleGeometry(roundedRectangleGeometry_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct2D1.EllipseGeometry"/>. 	
        /// </summary>	
        /// <param name="ellipse">A value that describes the center point, x-radius, and y-radius of the ellipse geometry.</param>
        /// <param name="ellipseGeometry">When this method returns, contains the address of the pointer to the ellipse geometry created by this method.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Factory::CreateEllipseGeometry([In] const D2D1_ELLIPSE* ellipse,[Out] ID2D1EllipseGeometry** ellipseGeometry)</unmanaged>
        internal SlimDX2.Result CreateEllipseGeometry(SlimDX2.Direct2D1.Ellipse ellipse, out SlimDX2.Direct2D1.EllipseGeometry ellipseGeometry) {
            unsafe {
                IntPtr ellipseGeometry_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 7 * 4, &ellipse, &ellipseGeometry_);
                ellipseGeometry = (ellipseGeometry_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.EllipseGeometry(ellipseGeometry_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct2D1.GeometryGroup"/>, which is an object that holds other geometries.	
        /// </summary>	
        /// <remarks>	
        /// Geometry groups are a convenient way to group several geometries simultaneously so all figures of several distinct geometries are concatenated into one. To create a  <see cref="SlimDX2.Direct2D1.GeometryGroup"/> object, call  the CreateGeometryGroup method on the <see cref="SlimDX2.Direct2D1.Factory"/> object, passing in the fillMode with possible values of   <see cref="SlimDX2.Direct2D1.FillMode.Alternate"/> (alternate) and D2D1_FILL_MODE_WINDING, an array of geometry objects to add to the geometry group, and the number of elements in this array. 	
        /// </remarks>	
        /// <param name="fillMode">A value that specifies the rule that a composite shape uses to determine whether a given point is part of the geometry. </param>
        /// <param name="geometries">An array containing the geometry objects to add to the geometry group. The number of elements in this array is indicated by the geometriesCount parameter.</param>
        /// <param name="geometriesCount">The number of elements in geometries.</param>
        /// <param name="geometryGroup">When this method returns, contains the address of a pointer to the geometry group created by this method.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Factory::CreateGeometryGroup([None] D2D1_FILL_MODE fillMode,[In, Buffer] ID2D1Geometry** geometries,[None] UINT geometriesCount,[Out] ID2D1GeometryGroup** geometryGroup)</unmanaged>
        internal SlimDX2.Result CreateGeometryGroup(SlimDX2.Direct2D1.FillMode fillMode, SlimDX2.Direct2D1.Geometry[] geometries, int geometriesCount, out SlimDX2.Direct2D1.GeometryGroup geometryGroup) {
            unsafe {
                IntPtr* geometries_ = (IntPtr*)0;
                if ( geometries != null ) {
                    IntPtr* geometries__ = stackalloc IntPtr[geometries.Length];
                    geometries_ = geometries__;
                    for (int i = 0; i < geometries.Length; i++)                        
                        geometries_[i] =  geometries[i].NativePointer;
                }
                IntPtr geometryGroup_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 8 * 4, unchecked((int)fillMode), geometries_, geometriesCount, &geometryGroup_);
                geometryGroup = (geometryGroup_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.GeometryGroup(geometryGroup_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Transforms the specified geometry and stores the result as an <see cref="SlimDX2.Direct2D1.TransformedGeometry"/> object.  	
        /// </summary>	
        /// <remarks>	
        /// Like other resources, a transformed geometry the inherits the resource space and threading policy of the factory that created it. This object is immutable.When stroking a transformed geometry with the {{DrawGeometry}} method, the stroke width is not affected by the transform applied to the geometry.  The stroke width is only affected by the world transform.	
        /// </remarks>	
        /// <param name="sourceGeometry">The geometry to transform.</param>
        /// <param name="transform">The transformation to apply. </param>
        /// <param name="transformedGeometry">When this method returns, contains the address of the pointer to the new transformed geometry object. The transformed geometry stores  the result of transforming sourceGeometry by transform.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Factory::CreateTransformedGeometry([In] ID2D1Geometry* sourceGeometry,[In] const D2D1_MATRIX_3X2_F* transform,[Out] ID2D1TransformedGeometry** transformedGeometry)</unmanaged>
        internal SlimDX2.Result CreateTransformedGeometry(SlimDX2.Direct2D1.Geometry sourceGeometry, ref SlimDX2.Direct2D1.Matrix3x2 transform, out SlimDX2.Direct2D1.TransformedGeometry transformedGeometry) {
            unsafe {
                IntPtr transformedGeometry_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* transform_ = &transform)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 9 * 4, (void*)((sourceGeometry == null)?IntPtr.Zero:sourceGeometry.NativePointer), transform_, &transformedGeometry_);
                transformedGeometry = (transformedGeometry_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.TransformedGeometry(transformedGeometry_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates an empty <see cref="SlimDX2.Direct2D1.PathGeometry"/>.	
        /// </summary>	
        /// <param name="athGeometryRef">When this method returns, contains the address to a pointer to the path geometry created by this method. </param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Factory::CreatePathGeometry([Out] ID2D1PathGeometry** pathGeometry)</unmanaged>
        internal SlimDX2.Result CreatePathGeometry(out SlimDX2.Direct2D1.PathGeometry athGeometryRef) {
            unsafe {
                IntPtr athGeometryRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 10 * 4, &athGeometryRef_);
                athGeometryRef = (athGeometryRef_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.PathGeometry(athGeometryRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct2D1.StrokeStyle"/> that describes start cap, dash pattern, and other features of a stroke.	
        /// </summary>	
        /// <param name="strokeStyleProperties">A structure that describes the stroke's line cap, dash offset, and other details of a stroke.</param>
        /// <param name="dashes">An array whose elements are set to the length of each dash and space in the dash pattern. The first element sets the length of a dash, the second element sets the length of a space, the third element sets the length of a dash, and so on. The length of each dash and space in the dash pattern is the product of the element value in the array and the stroke width. </param>
        /// <param name="dashesCount">The number of elements in the dashes array. </param>
        /// <param name="strokeStyle">When this method returns, contains the address of the pointer to the stroke style created by this method.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Factory::CreateStrokeStyle([In] const D2D1_STROKE_STYLE_PROPERTIES* strokeStyleProperties,[In, Buffer, Optional] const FLOAT* dashes,[None] UINT dashesCount,[Out] ID2D1StrokeStyle** strokeStyle)</unmanaged>
        internal SlimDX2.Result CreateStrokeStyle(ref SlimDX2.Direct2D1.StrokeStyleProperties strokeStyleProperties, float[] dashes, int dashesCount, out SlimDX2.Direct2D1.StrokeStyle strokeStyle) {
            unsafe {
                float[] dashes__ = dashes ?? new float[1];
                IntPtr strokeStyle_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* strokeStyleProperties_ = &strokeStyleProperties)
                    fixed (void* dashes_ = &dashes__[0])
                        __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 11 * 4, strokeStyleProperties_, dashes==null?(void*)IntPtr.Zero:dashes_, dashesCount, &strokeStyle_);
                strokeStyle = (strokeStyle_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.StrokeStyle(strokeStyle_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct2D1.DrawingStateBlock"/> that can be used with the {{SaveDrawingState}} and {{RestoreDrawingState}} methods of a render target.	
        /// </summary>	
        /// <param name="drawingStateDescription">A structure that contains antialiasing, transform, and tags  information.</param>
        /// <param name="textRenderingParams">Optional text parameters that indicate how text should be rendered.  </param>
        /// <param name="drawingStateBlock">When this method returns, contains the address of a pointer to the new drawing state block created by this method.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Factory::CreateDrawingStateBlock([In, Optional] const D2D1_DRAWING_STATE_DESCRIPTION* drawingStateDescription,[In, Optional] IDWriteRenderingParams* textRenderingParams,[Out] ID2D1DrawingStateBlock** drawingStateBlock)</unmanaged>
        internal SlimDX2.Result CreateDrawingStateBlock(SlimDX2.Direct2D1.DrawingStateDescription? drawingStateDescription, SlimDX2.DirectWrite.RenderingParams textRenderingParams, out SlimDX2.Direct2D1.DrawingStateBlock drawingStateBlock) {
            unsafe {
                SlimDX2.Direct2D1.DrawingStateDescription drawingStateDescription_;
                if (drawingStateDescription.HasValue)
                    drawingStateDescription_ = drawingStateDescription.Value;				
                IntPtr drawingStateBlock_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 12 * 4, (drawingStateDescription.HasValue)?&drawingStateDescription_:(void*)IntPtr.Zero, (void*)((textRenderingParams == null)?IntPtr.Zero:textRenderingParams.NativePointer), &drawingStateBlock_);
                drawingStateBlock = (drawingStateBlock_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.DrawingStateBlock(drawingStateBlock_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates an <see cref="SlimDX2.Direct2D1.HwndRenderTarget"/>, a render target that renders to a window.	
        /// </summary>	
        /// <remarks>	
        /// When you create a render target and hardware acceleration is available, you allocate resources on the computer's GPU. By creating a render target once and retaining it as long as possible, you gain performance benefits. Your application should create render targets once and hold onto them for the life of the application or until the {{D2DERR_RECREATE_TARGET}} error is received. When you receive this error, you need to recreate the render target (and any resources it created).	
        /// </remarks>	
        /// <param name="renderTargetProperties">The rendering mode, pixel format, remoting options, DPI information, and the minimum DirectX support required for hardware rendering. For information about supported pixel formats, see  {{Supported Pixel  Formats and Alpha Modes}}.</param>
        /// <param name="hwndRenderTargetProperties">The window handle, initial size (in pixels), and present options.</param>
        /// <param name="hwndRenderTarget">When this method returns, contains the address of the pointer to the <see cref="SlimDX2.Direct2D1.HwndRenderTarget"/> object created by this method.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Factory::CreateHwndRenderTarget([In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,[In] const D2D1_HWND_RENDER_TARGET_PROPERTIES* hwndRenderTargetProperties,[Out] ID2D1HwndRenderTarget** hwndRenderTarget)</unmanaged>
        internal SlimDX2.Result CreateHwndRenderTarget(ref SlimDX2.Direct2D1.RenderTargetProperties renderTargetProperties, SlimDX2.Direct2D1.HwndRenderTargetProperties hwndRenderTargetProperties, out SlimDX2.Direct2D1.HwndRenderTarget hwndRenderTarget) {
            unsafe {
                IntPtr hwndRenderTarget_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* renderTargetProperties_ = &renderTargetProperties)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 14 * 4, renderTargetProperties_, &hwndRenderTargetProperties, &hwndRenderTarget_);
                hwndRenderTarget = (hwndRenderTarget_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.HwndRenderTarget(hwndRenderTarget_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a render target that draws to a DirectX Graphics Infrastructure (DXGI) surface. 	
        /// </summary>	
        /// <remarks>	
        /// To write to a Direct3D surface, you obtain an <see cref="SlimDX2.DXGI.Surface"/> and pass it to the {{CreateDxgiSurfaceRenderTarget}} method to create a DXGI surface render target; you can then use the DXGI surface render target to draw 2-D content to the DXGI surface.  A DXGI surface render target is a type of <see cref="SlimDX2.Direct2D1.RenderTarget"/>. Like other Direct2D render targets, you can use it to create resources and issue drawing commands. The DXGI surface render target and the DXGI surface must use the same DXGI format. If you specify the {{DXGI_FORMAT_UNKOWN}} format when you create the render target, it will automatically use the surface's format.The DXGI surface render target does not perform DXGI surface synchronization. To work with Direct2D, the Direct3D device that provides the <see cref="SlimDX2.DXGI.Surface"/> must be created with the D3D10_CREATE_DEVICE_BGRA_SUPPORT flag.For more information about creating and using DXGI surface render targets, see the {{Direct2D and Direct3D Interoperability Overview}}.When you create a render target and hardware acceleration is available, you allocate resources on the computer's GPU. By creating a render target once and retaining it as long as possible, you gain performance benefits. Your application should create render targets once and hold onto them for the life of the application or until the render target's {{EndDraw}} method returns the {{D2DERR_RECREATE_TARGET}} error. When you receive this error, you need to recreate the render target (and any resources it created). 	
        /// </remarks>	
        /// <param name="dxgiSurface">The IDXGISurface to which the render target will draw. </param>
        /// <param name="renderTargetProperties">The rendering mode, pixel format, remoting options, DPI information, and the minimum DirectX support required for hardware rendering. For information about supported pixel formats, see  {{Supported Pixel  Formats and Alpha Modes}}.</param>
        /// <param name="renderTarget">When this method returns, contains the address of the pointer to the <see cref="SlimDX2.Direct2D1.RenderTarget"/> object created by this method.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Factory::CreateDxgiSurfaceRenderTarget([In] IDXGISurface* dxgiSurface,[In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,[Out] ID2D1RenderTarget** renderTarget)</unmanaged>
        internal SlimDX2.Result CreateDxgiSurfaceRenderTarget(SlimDX2.DXGI.Surface dxgiSurface, ref SlimDX2.Direct2D1.RenderTargetProperties renderTargetProperties, out SlimDX2.Direct2D1.RenderTarget renderTarget) {
            unsafe {
                IntPtr renderTarget_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* renderTargetProperties_ = &renderTargetProperties)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 15 * 4, (void*)((dxgiSurface == null)?IntPtr.Zero:dxgiSurface.NativePointer), renderTargetProperties_, &renderTarget_);
                renderTarget = (renderTarget_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.RenderTarget(renderTarget_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a render target that draws to a Windows Graphics Device Interface (GDI) device context.	
        /// </summary>	
        /// <remarks>	
        /// Before you can render with a DC render target, you must use the render target's {{BindDC}} method to associate it with a GDI DC.  Do this for each different DC and whenever there is a change in the size of the area you want to draw to.To enable the DC render target to work with GDI, set the render target's DXGI format to <see cref="SlimDX2.DXGI.Format.B8G8R8A8_UNorm"/> and alpha mode to <see cref="SlimDX2.Direct2D1.AlphaMode.Premultiplied"/> or D2D1_ALPHA_MODE_IGNORE.Your application should create render targets once and hold on to them for the life of the application or until the render target's  {{EndDraw}} method returns the {{D2DERR_RECREATE_TARGET}} error. When you receive this error, recreate the render target (and any resources it created).	
        /// </remarks>	
        /// <param name="renderTargetProperties">The rendering mode, pixel format, remoting options, DPI information, and the minimum DirectX support required for hardware rendering.  To enable the device context (DC) render target to work with GDI, set the DXGI format to <see cref="SlimDX2.DXGI.Format.B8G8R8A8_UNorm"/> and the alpha mode to <see cref="SlimDX2.Direct2D1.AlphaMode.Premultiplied"/> or D2D1_ALPHA_MODE_IGNORE. For more information about pixel formats, see  {{Supported Pixel  Formats and Alpha Modes}}.</param>
        /// <param name="dcRenderTarget">When this method returns, dcRenderTarget contains the address of the pointer to the  <see cref="SlimDX2.Direct2D1.DCRenderTarget"/> created by the method.</param>
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1Factory::CreateDCRenderTarget([In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,[Out] ID2D1DCRenderTarget** dcRenderTarget)</unmanaged>
        internal SlimDX2.Result CreateDCRenderTarget(ref SlimDX2.Direct2D1.RenderTargetProperties renderTargetProperties, out SlimDX2.Direct2D1.DCRenderTarget dcRenderTarget) {
            unsafe {
                IntPtr dcRenderTarget_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* renderTargetProperties_ = &renderTargetProperties)
                    __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 16 * 4, renderTargetProperties_, &dcRenderTarget_);
                dcRenderTarget = (dcRenderTarget_ == IntPtr.Zero)?null:new SlimDX2.Direct2D1.DCRenderTarget(dcRenderTarget_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    ///  Describes a geometric path that does not contain quadratic bezier curves or arcs. 	
    /// </summary>	
    /// <unmanaged>ID2D1SimplifiedGeometrySink</unmanaged>
    [Guid("2cd9069e-12e2-11dc-9fed-001143a055f9")]
    internal partial class DefaultSimplifiedGeometrySink : SlimDX2.ComObject, SlimDX2.Direct2D1.SimplifiedGeometrySink {
        public DefaultSimplifiedGeometrySink(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Specifies the method used to determine which points are inside the geometry described by this geometry sink  and which points are outside.  	
        /// </summary>	
        /// <remarks>	
        /// The fill mode defaults to D2D1_FILL_MODE_ALTERNATE. To set the fill mode, call SetFillMode before the first call to {{BeginFigure}}. Not doing will put the geometry sink in an error state. 	
        /// </remarks>	
        /// <param name="fillMode">The method used to determine whether a given point is part of the geometry.</param>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::SetFillMode([None] D2D1_FILL_MODE fillMode)</unmanaged>
        internal void SetFillMode_(SlimDX2.Direct2D1.FillMode fillMode) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 3 * 4, unchecked((int)fillMode));
            }
        }
        
        /// <summary>	
        /// Specifies stroke and join options to be applied to new segments added to the geometry sink. 	
        /// </summary>	
        /// <remarks>	
        /// After this method is called, the specified segment flags are applied to each segment subsequently added to the sink. The segment flags are applied to every additional segment until this method is called again and a different set of segment flags is specified.     	
        /// </remarks>	
        /// <param name="vertexFlags">Stroke and join options to be applied to new segments added to the geometry sink.</param>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::SetSegmentFlags([None] D2D1_PATH_SEGMENT vertexFlags)</unmanaged>
        internal void SetSegmentFlags_(SlimDX2.Direct2D1.PathSegment vertexFlags) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 4 * 4, unchecked((int)vertexFlags));
            }
        }
        
        /// <summary>	
        /// Starts a new figure at the specified point. 	
        /// </summary>	
        /// <remarks>	
        /// If this method is called while a figure is currently in progress, the interface is invalidated and all future methods will fail.	
        /// </remarks>	
        /// <param name="startPoint">The point at which to begin the new figure.</param>
        /// <param name="figureBegin">Whether the new figure should be hollow or filled.</param>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::BeginFigure([None] D2D1_POINT_2F startPoint,[None] D2D1_FIGURE_BEGIN figureBegin)</unmanaged>
        internal void BeginFigure_(System.Drawing.PointF startPoint, SlimDX2.Direct2D1.FigureBegin figureBegin) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 5 * 4, startPoint, unchecked((int)figureBegin));
            }
        }
        
        /// <summary>	
        ///  Creates a sequence of lines using the specified points and adds them to the geometry sink.	
        /// </summary>	
        /// <param name="ointsRef">A pointer to an array of one or more points that describe the lines to draw. A line is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by {{BeginFigure}}) to the first point in the array. if the array contains additional points, a line is drawn from the first point to the second point in the array, from the second point to the third point, and so on.   </param>
        /// <param name="pointsCount">The number of points in the points array.</param>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::AddLines([In, Buffer] const D2D1_POINT_2F* points,[None] UINT pointsCount)</unmanaged>
        internal void AddLines_(System.Drawing.PointF[] ointsRef, int pointsCount) {
            unsafe {
                fixed (void* ointsRef_ = &ointsRef[0])
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 6 * 4, ointsRef_, pointsCount);
            }
        }
        
        /// <summary>	
        /// Creates a sequence of cubic Bezier curves and adds them to the geometry sink. 	
        /// </summary>	
        /// <param name="beziers">A pointer to an array of Bezier segments that describes the Bezier curves to create. A curve is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by {{BeginFigure}}) to the end point of the first Bezier segment in the array. if the array contains additional Bezier segments, each subsequent Bezier segment uses the end point of the preceding Bezier segment as its start point.</param>
        /// <param name="beziersCount">The number of Bezier segments in the beziers array.</param>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::AddBeziers([In, Buffer] const D2D1_BEZIER_SEGMENT* beziers,[None] UINT beziersCount)</unmanaged>
        internal void AddBeziers_(SlimDX2.Direct2D1.BezierSegment[] beziers, int beziersCount) {
            unsafe {
                fixed (void* beziers_ = &beziers[0])
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 7 * 4, beziers_, beziersCount);
            }
        }
        
        /// <summary>	
        ///  Ends the current figure; optionally, closes it.	
        /// </summary>	
        /// <remarks>	
        /// Calling this method without a matching call to {{BeginFigure}} places the geometry sink in an error state; subsequent calls are ignored, and the overall failure will be returned when the {{Close}} method is called.	
        /// </remarks>	
        /// <param name="figureEnd">A value that indicates whether the current figure is closed. If the figure is closed, a line is drawn between the current point and the start point specified by {{BeginFigure}}.</param>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::EndFigure([None] D2D1_FIGURE_END figureEnd)</unmanaged>
        internal void EndFigure_(SlimDX2.Direct2D1.FigureEnd figureEnd) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 8 * 4, unchecked((int)figureEnd));
            }
        }
        
        /// <summary>	
        /// Closes the geometry sink, indicates whether it is in an error state, and resets the sink's error state. 	
        /// </summary>	
        /// <remarks>	
        /// Do not close the geometry sink while a figure is still in progress; doing so puts the geometry sink in an error state. For the close operation to be successful, there must be one {{EndFigure}} call for each call to {{BeginFigure}}.After calling this method, the geometry sink might not be usable. Direct2D implementations of this interface do not allow the geometry sink to be modified after it is closed, but other implementations might not impose this restriction.	
        /// </remarks>	
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1SimplifiedGeometrySink::Close()</unmanaged>
        internal SlimDX2.Result Close_() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 9 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Describes a geometric path that can contain lines, arcs, cubic Bezier curves, and quadratic Bezier curves. 	
    /// </summary>	
    /// <unmanaged>ID2D1GeometrySink</unmanaged>
    [Guid("2cd9069f-12e2-11dc-9fed-001143a055f9")]
    internal partial class DefaultGeometrySink : SlimDX2.Direct2D1.DefaultSimplifiedGeometrySink, SlimDX2.Direct2D1.GeometrySink {
        public DefaultGeometrySink(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Creates a line segment between the current point and the specified end point and adds it to the geometry sink. 	
        /// </summary>	
        /// <param name="point">The end point of the line to draw.</param>
        /// <unmanaged>void ID2D1GeometrySink::AddLine([None] D2D1_POINT_2F point)</unmanaged>
        internal void AddLine_(System.Drawing.PointF point) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 10 * 4, point);
            }
        }
        
        /// <summary>	
        ///  Creates  a cubic Bezier curve between the current point and the specified endpoint.	
        /// </summary>	
        /// <param name="bezier">A structure that describes the control points and endpoint of the Bezier curve to add. </param>
        /// <unmanaged>void ID2D1GeometrySink::AddBezier([In] const D2D1_BEZIER_SEGMENT* bezier)</unmanaged>
        internal void AddBezier_(SlimDX2.Direct2D1.BezierSegment bezier) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 11 * 4, &bezier);
            }
        }
        
        /// <summary>	
        /// Creates  a quadratic Bezier curve between the current point and the specified endpoint.	
        /// </summary>	
        /// <param name="bezier">A structure that describes the control point and the endpoint of the quadratic Bezier curve to add.</param>
        /// <unmanaged>void ID2D1GeometrySink::AddQuadraticBezier([In] const D2D1_QUADRATIC_BEZIER_SEGMENT* bezier)</unmanaged>
        internal void AddQuadraticBezier_(SlimDX2.Direct2D1.QuadraticBezierSegment bezier) {
            unsafe {
                SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 12 * 4, &bezier);
            }
        }
        
        /// <summary>	
        /// Adds a sequence of quadratic Bezier segments as an array in a single call.	
        /// </summary>	
        /// <param name="beziers">An array of a sequence of quadratic Bezier segments.</param>
        /// <param name="beziersCount">A value indicating the number of quadratic Bezier segments in beziers. </param>
        /// <unmanaged>void ID2D1GeometrySink::AddQuadraticBeziers([In, Buffer] const D2D1_QUADRATIC_BEZIER_SEGMENT* beziers,[None] UINT beziersCount)</unmanaged>
        internal void AddQuadraticBeziers_(SlimDX2.Direct2D1.QuadraticBezierSegment[] beziers, int beziersCount) {
            unsafe {
                fixed (void* beziers_ = &beziers[0])
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 13 * 4, beziers_, beziersCount);
            }
        }
        
        /// <summary>	
        /// Adds a single arc to the path geometry.	
        /// </summary>	
        /// <param name="arc">The arc segment to add to the figure.</param>
        /// <unmanaged>void ID2D1GeometrySink::AddArc([In] const D2D1_ARC_SEGMENT* arc)</unmanaged>
        internal void AddArc_(ref SlimDX2.Direct2D1.ArcSegment arc) {
            unsafe {
                fixed (void* arc_ = &arc)
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 14 * 4, arc_);
            }
        }
    }
    
    /// <summary>	
    /// Populates an <see cref="SlimDX2.Direct2D1.Mesh"/> object with triangles. 	
    /// </summary>	
    /// <unmanaged>ID2D1TessellationSink</unmanaged>
    [Guid("2cd906c1-12e2-11dc-9fed-001143a055f9")]
    internal partial class DefaultTessellationSink : SlimDX2.ComObject, SlimDX2.Direct2D1.TessellationSink {
        public DefaultTessellationSink(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Copies the specified triangles to the sink.  	
        /// </summary>	
        /// <param name="triangles">An array of <see cref="SlimDX2.Direct2D1.Triangle"/> structures that describe the triangles to add to the sink.</param>
        /// <param name="trianglesCount">The number of triangles to copy from the triangles array.</param>
        /// <unmanaged>void ID2D1TessellationSink::AddTriangles([In, Buffer] const D2D1_TRIANGLE* triangles,[None] UINT trianglesCount)</unmanaged>
        internal void AddTriangles_(SlimDX2.Direct2D1.Triangle[] triangles, int trianglesCount) {
            unsafe {
                fixed (void* triangles_ = &triangles[0])
                    SlimDX2.Direct2D1.LocalInterop.Callivoid(_nativePointer, 3 * 4, triangles_, trianglesCount);
            }
        }
        
        /// <summary>	
        ///  Closes the sink and returns its error status.	
        /// </summary>	
        /// <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        /// <unmanaged>HRESULT ID2D1TessellationSink::Close()</unmanaged>
        internal SlimDX2.Result Close_() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Direct2D1.LocalInterop.Calliint(_nativePointer, 4 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
    }
}
