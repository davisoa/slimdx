// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Enums for SlimDX2.Direct2D1 namespace.
//     This code was generated by a tool.
//     Date : 11/15/2010 14:52:48
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace SlimDX2.Direct2D1 {

    
    /// <summary>	
    /// Specifies how the alpha value of a bitmap or render target should be treated.	
    /// </summary>	
    /// <remarks>	
    /// The D2D1_ALPHA_MODE enumeration is used with the <see cref="SlimDX2.Direct2D1.PixelFormat"/> enumeration to specify the alpha mode of a render target or bitmap. Different render targets and bitmaps support different alpha modes. For a list, see {{Supported Pixel Formats and Alpha Modes}}.The Differences Between Straight and Premultiplied AlphaWhen describing an RGBA color using straight alpha, the alpha value of the color is stored in the alpha channel. For example, to describe a red color that is 60% opaque, you'd use the following values: (255, 0, 0, 255 * 0.6) = (255, 0, 0, 153). The 255 value indicates full red, and 153 (which is 60 percent of 255) indicates that the color should have an opacity of 60 percent.When describing an RGBA color using premultiplied alpha, each color is multiplied by the alpha value: (255 * 0.6, 0 * 0.6, 0 * 0.6, 255 * 0.6) = (153, 0, 0, 153).  Regardless of the alpha mode of the render target, <see cref="SlimMath.Color4"/> values are always interpreted as straight alpha.  For example, when specifying the color of an <see cref="SlimDX2.Direct2D1.SolidColorBrush"/> for use with a bitmap that uses the premultiplied alpha mode, you'd specify the color just as you would if the bitmap used straight alpha. When you paint with the brush, Direct2D translates the color to the destination format for you.Alpha Mode for Render TargetsRegardless of the alpha mode setting, a render target's contents support transparency. For example, if you draw a partially transparent red rectangle with a render target with an alpha mode of D2D1_ALPHA_MODE_IGNORE, the rectangle will appear pink (if the background is white), as you might expect.If you draw a partially transparent red rectangle when the alpha mode is D2D1_ALPHA_MODE_PREMULTIPLIED, the rectangle will appear pink (assuming the background is white) and you can see through it to whatever is behind the render target. This is useful when using a <see cref="SlimDX2.Direct2D1.DCRenderTarget"/> to render to a transparent window or when using an compatible render target (a render targeted created by the {{CreateCompatibleRenderTarget}} method) to create a bitmap that supports transparency. ClearType and Alpha ModesIf you specify an alpha mode other than D2D1_ALPHA_MODE_IGNORE for a render target, the text antialiasing mode automatically changes from {{D2D1_TEXT_ANTIALIAS_MODE CLEARTYPE}} to D2D1_TEXT_ANTIALIAS_MODE GRAYSCALE. (When you specify an alpha mode of D2D1_ALPHA_MODE_UNKNOWN, Direct2D sets the alpha for you depending on the type of render target. For a list of what the D2D1_ALPHA_MODE_UNKNOWN setting resolves to for each render target, see the {{Supported Pixel Formats and Alpha Modes}} overview.) You can use the {{SetTextAntialiasMode}} method to change the text antialias mode  back to {{D2D1_TEXT_ANTIALIAS_MODE CLEARTYPE}}, but rendering ClearType text to a transparent surface can create unpredictable results. If you want to render ClearType text to an transparent render target, we recommend that you use one of the following two techniques. Use the {{PushAxisAlignedClip}} method to clip the render target to the area where the text will be rendered,    then call the {{Clear}} method and specify an opaque color, then render your text.Use {{DrawRectangle}} to draw an opaque rectangle behind the area where the text will be rendered.	
    /// </remarks>	
    /// <unmanaged>D2D1_ALPHA_MODE</unmanaged>
    public enum AlphaMode : int {	
        
        /// <summary>	
        /// The alpha value might not be meaningful.	
        /// </summary>	
        /// <unmanaged>D2D1_ALPHA_MODE_UNKNOWN</unmanaged>
        Unknown = unchecked((int)0),			
        
        /// <summary>	
        /// The alpha value has been premultiplied. Each color is first scaled by the alpha value. The alpha value itself is the same in both straight and premultiplied alpha. Typically, no color channel value is greater than the alpha channel value.  If a color channel value in a premultiplied format is greater than the alpha channel, the standard source-over blending math results in an additive blend.	
        /// </summary>	
        /// <unmanaged>D2D1_ALPHA_MODE_PREMULTIPLIED</unmanaged>
        Premultiplied = unchecked((int)1),			
        
        /// <summary>	
        /// The alpha value has not been premultiplied. The alpha channel indicates the transparency of the color. 	
        /// </summary>	
        /// <unmanaged>D2D1_ALPHA_MODE_STRAIGHT</unmanaged>
        Straight = unchecked((int)2),			
        
        /// <summary>	
        /// The alpha value is ignored.	
        /// </summary>	
        /// <unmanaged>D2D1_ALPHA_MODE_IGNORE</unmanaged>
        Ignore = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Specifies which gamma is used for interpolation.	
    /// </summary>	
    /// <remarks>	
    /// Interpolating in a linear gamma space (D2D1_GAMMA_1_0) can avoid changes in perceived brightness caused by the effect of gamma correction in spaces where the gamma is not 1.0, such as the default sRGB color space, where the gamma is 2.2. For an example of the differences between these two blending modes, consider the following illustration, which shows two gradients, each of which blends from red to blue to green:?Illustration of two gradients from red to blue to green, blended by using sRGB gamma and linear-gamma?The first gradient is interpolated linearly in the space of the render target (sRGB in this case), and one can see the dark bands between each color. The second gradient uses a gamma-correct linear interpolation, and thus does not exhibit the same variations in brightness.	
    /// </remarks>	
    /// <unmanaged>D2D1_GAMMA</unmanaged>
    public enum Gamma : int {	
        
        /// <summary>	
        /// Interpolation is performed in the standard RGB (sRGB) gamma.	
        /// </summary>	
        /// <unmanaged>D2D1_GAMMA_2_2</unmanaged>
        StandardRgb = unchecked((int)0),			
        
        /// <summary>	
        /// Interpolation is performed in the linear-gamma color space.	
        /// </summary>	
        /// <unmanaged>D2D1_GAMMA_1_0</unmanaged>
        Linear = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Describes whether an opacity mask contains graphics or text. Direct2D uses this information to determine which gamma space to use when blending the opacity mask.	
    /// </summary>	
    /// <unmanaged>D2D1_OPACITY_MASK_CONTENT</unmanaged>
    public enum OpacityMaskContent : int {	
        
        /// <summary>	
        /// The opacity mask contains graphics. The opacity mask is blended in the gamma 2.2 color space.	
        /// </summary>	
        /// <unmanaged>D2D1_OPACITY_MASK_CONTENT_GRAPHICS</unmanaged>
        Graphics = unchecked((int)0),			
        
        /// <summary>	
        /// The opacity mask contains non-GDI text. The gamma space used for blending is obtained from the render target's text rendering parameters. (<see cref="SlimDX2.Direct2D1.RenderTarget.SetTextRenderingParams"/>).	
        /// </summary>	
        /// <unmanaged>D2D1_OPACITY_MASK_CONTENT_TEXT_NATURAL</unmanaged>
        TextNatural = unchecked((int)1),			
        
        /// <summary>	
        /// The opacity mask contains text rendered using the GDI-compatible rendering mode. The opacity mask is blended using the gamma for GDI rendering.	
        /// </summary>	
        /// <unmanaged>D2D1_OPACITY_MASK_CONTENT_TEXT_GDI_COMPATIBLE</unmanaged>
        TextGdiCompatible = unchecked((int)2),			
    }
    
    /// <summary>	
    /// Specifies how a brush paints areas outside of its normal content area.	
    /// </summary>	
    /// <remarks>	
    /// For an <see cref="SlimDX2.Direct2D1.BitmapBrush"/>, the brush's content is the brush's bitmap. For an <see cref="SlimDX2.Direct2D1.LinearGradientBrush"/>, the brush's content area is the gradient axis. For an <see cref="SlimDX2.Direct2D1.RadialGradientBrush"/>, the brush's content is the area within the gradient ellipse.  For an example, see the {{Draw Extend Mode Example}}.	
    /// </remarks>	
    /// <unmanaged>D2D1_EXTEND_MODE</unmanaged>
    public enum ExtendMode : int {	
        
        /// <summary>	
        /// Repeat the edge pixels of the brush's content for all regions outside the normal content area.	
        /// </summary>	
        /// <unmanaged>D2D1_EXTEND_MODE_CLAMP</unmanaged>
        Clamp = unchecked((int)0),			
        
        /// <summary>	
        /// Repeat the brush's content.	
        /// </summary>	
        /// <unmanaged>D2D1_EXTEND_MODE_WRAP</unmanaged>
        Wrap = unchecked((int)1),			
        
        /// <summary>	
        ///  The same as D2D1_EXTEND_MODE_WRAP, except that alternate tiles of the brush's content are flipped. (The brush's normal content is drawn untransformed.)	
        /// </summary>	
        /// <unmanaged>D2D1_EXTEND_MODE_MIRROR</unmanaged>
        Mirror = unchecked((int)2),			
    }
    
    /// <summary>	
    /// Specifies how the edges of nontext primitives are rendered.	
    /// </summary>	
    /// <unmanaged>D2D1_ANTIALIAS_MODE</unmanaged>
    public enum AntialiasMode : int {	
        
        /// <summary>	
        /// Edges are antialiased using the Direct2D per-primitive method of high-quality antialiasing.	
        /// </summary>	
        /// <unmanaged>D2D1_ANTIALIAS_MODE_PER_PRIMITIVE</unmanaged>
        PerPrimitive = unchecked((int)0),			
        
        /// <summary>	
        /// Objects are aliased in most cases. Objects are antialiased only when they are drawn to a render target created by the {{CreateDxgiSurfaceRenderTarget}} method and  Direct3D multisampling has been enabled on the backing DirectX Graphics Infrastructure (DXGI) surface. 	
        /// </summary>	
        /// <unmanaged>D2D1_ANTIALIAS_MODE_ALIASED</unmanaged>
        Aliased = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Describes the antialiasing mode used for drawing text. 	
    /// </summary>	
    /// <remarks>	
    /// This enumeration is used with the {{SetTextAntialiasMode}} of an <see cref="SlimDX2.Direct2D1.RenderTarget"/> to specify how text and glyphs are antialiased. By default, Direct2D renders text in ClearType mode. Factors that  can downgrade the default quality to grayscale or aliased:If the <see cref="SlimDX2.DirectWrite.RenderingMode"/> value  is DWRITE_RENDERING_MODE_ALIASED , then the  default text antialiasing mode is aliased.  To change the DirectWrite rendering mode of an <see cref="SlimDX2.Direct2D1.RenderTarget"/>, use the  <see cref="SlimDX2.Direct2D1.RenderTarget.SetTextRenderingParams"/> method. If the <see cref="SlimDX2.DirectWrite.RenderingMode"/> value is DWRITE_RENDERING_MODE_OUTLINE, then the default text  antialiasing mode is grayscale.If the render target has an alpha channel and is not set to <see cref="SlimDX2.Direct2D1.AlphaMode.Ignore"/>, then  the default text antialiasing mode is grayscale.If <see cref="SlimDX2.Direct2D1.RenderTarget.PushLayer"/> is called without <see cref="SlimDX2.Direct2D1.LayerOptions.InitializeForCleartype"/> (and the corresponding {{PopLayer}} has not  been called yet), then the default text  antialiasing mode is grayscale.	
    /// </remarks>	
    /// <unmanaged>D2D1_TEXT_ANTIALIAS_MODE</unmanaged>
    public enum TextAntialiasMode : int {	
        
        /// <summary>	
        /// Use the system default. See Remarks.	
        /// </summary>	
        /// <unmanaged>D2D1_TEXT_ANTIALIAS_MODE_DEFAULT</unmanaged>
        Default = unchecked((int)0),			
        
        /// <summary>	
        /// Use ClearType antialiasing.	
        /// </summary>	
        /// <unmanaged>D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE</unmanaged>
        Cleartype = unchecked((int)1),			
        
        /// <summary>	
        /// Use grayscale antialiasing.	
        /// </summary>	
        /// <unmanaged>D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE</unmanaged>
        Grayscale = unchecked((int)2),			
        
        /// <summary>	
        /// Do not use antialiasing.	
        /// </summary>	
        /// <unmanaged>D2D1_TEXT_ANTIALIAS_MODE_ALIASED</unmanaged>
        Aliased = unchecked((int)3),			
    }
    
    /// <summary>	
    ///  Specifies the algorithm that is used when images are scaled or rotated.	
    /// </summary>	
    /// <remarks>	
    ///  To stretch an image, each pixel in the original image must be mapped to a group of pixels in the larger image. To shrink an image, groups of pixels in the original image must be mapped to single pixels in the smaller image. The effectiveness of the algorithms that perform these mappings determines the quality of a scaled image. Algorithms that produce higher-quality scaled images tend to require more processing time. D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR provides faster but lower-quality interpolation, while D2D1_BITMAP_INTERPOLATION_MODE_LINEAR provides higher-quality interpolation. 	
    /// </remarks>	
    /// <unmanaged>D2D1_BITMAP_INTERPOLATION_MODE</unmanaged>
    public enum BitmapInterpolationMode : int {	
        
        /// <summary>	
        /// Use the exact color of the nearest bitmap pixel to the current rendering pixel.	
        /// </summary>	
        /// <unmanaged>D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged>
        NearestNeighbor = unchecked((int)0),			
        
        /// <summary>	
        /// Interpolate a color from the four bitmap pixels that are the nearest to the rendering pixel.	
        /// </summary>	
        /// <unmanaged>D2D1_BITMAP_INTERPOLATION_MODE_LINEAR</unmanaged>
        Linear = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Specifies whether text snapping is suppressed or clipping to the layout rectangle is enabled. This enumeration allows a bitwise combination of its member values.	
    /// </summary>	
    /// <unmanaged>D2D1_DRAW_TEXT_OPTIONS</unmanaged>
    public enum DrawTextOptions : int {	
        
        /// <summary>	
        /// Text is not vertically snapped to pixel boundaries. This setting is recommended for text that is being animated. 	
        /// </summary>	
        /// <unmanaged>D2D1_DRAW_TEXT_OPTIONS_NO_SNAP</unmanaged>
        NoSnap = unchecked((int)1),			
        
        /// <summary>	
        /// Text is clipped to the layout rectangle.	
        /// </summary>	
        /// <unmanaged>D2D1_DRAW_TEXT_OPTIONS_CLIP</unmanaged>
        Clip = unchecked((int)2),			
        
        /// <summary>	
        /// Text is vertically snapped to pixel boundaries and is not clipped to the layout rectangle. 	
        /// </summary>	
        /// <unmanaged>D2D1_DRAW_TEXT_OPTIONS_NONE</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Specifies whether an arc should be greater than 180 degrees.	
    /// </summary>	
    /// <unmanaged>D2D1_ARC_SIZE</unmanaged>
    public enum ArcSize : int {	
        
        /// <summary>	
        /// An arc's sweep should be 180 degrees or less.	
        /// </summary>	
        /// <unmanaged>D2D1_ARC_SIZE_SMALL</unmanaged>
        Small = unchecked((int)0),			
        
        /// <summary>	
        /// An arc's sweep should be 180 degrees or greater.	
        /// </summary>	
        /// <unmanaged>D2D1_ARC_SIZE_LARGE</unmanaged>
        Large = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Describes the shape at the end of a line or segment.	
    /// </summary>	
    /// <remarks>	
    ///  The following illustration shows the available cap styles for lines or segments. The red portion of the line shows the extra area added by the line cap setting. ?Illustration of four cap styles?	
    /// </remarks>	
    /// <unmanaged>D2D1_CAP_STYLE</unmanaged>
    public enum CapStyle : int {	
        
        /// <summary>	
        /// A cap that does not extend past the last point of the line. Comparable to cap used for objects other than lines. 	
        /// </summary>	
        /// <unmanaged>D2D1_CAP_STYLE_FLAT</unmanaged>
        Flat = unchecked((int)0),			
        
        /// <summary>	
        /// Half of a square that has a length equal to the line thickness.	
        /// </summary>	
        /// <unmanaged>D2D1_CAP_STYLE_SQUARE</unmanaged>
        Square = unchecked((int)1),			
        
        /// <summary>	
        /// A semicircle that has a diameter equal to the line thickness.	
        /// </summary>	
        /// <unmanaged>D2D1_CAP_STYLE_ROUND</unmanaged>
        Round = unchecked((int)2),			
        
        /// <summary>	
        /// An isosceles right triangle whose hypotenuse is equal in length to the thickness of the line.	
        /// </summary>	
        /// <unmanaged>D2D1_CAP_STYLE_TRIANGLE</unmanaged>
        Triangle = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Describes the sequence of dashes and gaps in a stroke. 	
    /// </summary>	
    /// <remarks>	
    /// The following illustration shows several available dash styles. For more information, see the {{Stroke Style Example}}.?Illustration of available dash styles?	
    /// </remarks>	
    /// <unmanaged>D2D1_DASH_STYLE</unmanaged>
    public enum DashStyle : int {	
        
        /// <summary>	
        /// A solid line with no breaks.	
        /// </summary>	
        /// <unmanaged>D2D1_DASH_STYLE_SOLID</unmanaged>
        Solid = unchecked((int)0),			
        
        /// <summary>	
        /// A dash followed by a gap of equal length. The dash and the gap are each twice as long as the stroke thickness.The equivalent dash  array for  D2D1_DASH_STYLE_DASH is {2, 2}.	
        /// </summary>	
        /// <unmanaged>D2D1_DASH_STYLE_DASH</unmanaged>
        Dash = unchecked((int)1),			
        
        /// <summary>	
        /// A dot followed by a longer gap.The equivalent dash  array for  D2D1_DASH_STYLE_DOT is {0, 2}.	
        /// </summary>	
        /// <unmanaged>D2D1_DASH_STYLE_DOT</unmanaged>
        Dot = unchecked((int)2),			
        
        /// <summary>	
        /// A dash, followed by a gap, followed by a dot, followed by another gap.The equivalent dash array for  D2D1_DASH_STYLE_DASH_DOT is {2, 2, 0, 2}.	
        /// </summary>	
        /// <unmanaged>D2D1_DASH_STYLE_DASH_DOT</unmanaged>
        DashDot = unchecked((int)3),			
        
        /// <summary>	
        /// A dash, followed by a gap, followed by a dot, followed by another gap, followed by another dot, followed by another gap.The equivalent dash array for  D2D1_DASH_STYLE_DASH_DOT_DOT is {2, 2, 0, 2, 0, 2}.	
        /// </summary>	
        /// <unmanaged>D2D1_DASH_STYLE_DASH_DOT_DOT</unmanaged>
        DashDotDot = unchecked((int)4),			
        
        /// <summary>	
        /// The dash pattern is specified by an array of floating-point values.	
        /// </summary>	
        /// <unmanaged>D2D1_DASH_STYLE_CUSTOM</unmanaged>
        Custom = unchecked((int)5),			
    }
    
    /// <summary>	
    /// Describes the shape that joins two lines or segments.  	
    /// </summary>	
    /// <remarks>	
    ///  A miter limit affects how sharp miter joins are allowed to be. If the line join style is D2D1_LINE_JOIN_MITER_OR_BEVEL, then the join will be mitered with regular angular vertices if it doesn't extend beyond the miter limit; otherwise, the line join will be beveled.The following illustration shows  different line join settings for the same stroked path geometry.  For more information, see {{Stroke Style Example}}.?Illustration of line join settings?	
    /// </remarks>	
    /// <unmanaged>D2D1_LINE_JOIN</unmanaged>
    public enum LineJoin : int {	
        
        /// <summary>	
        /// Regular angular vertices. 	
        /// </summary>	
        /// <unmanaged>D2D1_LINE_JOIN_MITER</unmanaged>
        Miter = unchecked((int)0),			
        
        /// <summary>	
        /// Beveled vertices.   	
        /// </summary>	
        /// <unmanaged>D2D1_LINE_JOIN_BEVEL</unmanaged>
        Bevel = unchecked((int)1),			
        
        /// <summary>	
        /// Rounded vertices. 	
        /// </summary>	
        /// <unmanaged>D2D1_LINE_JOIN_ROUND</unmanaged>
        Round = unchecked((int)2),			
        
        /// <summary>	
        /// Regular angular vertices unless the join would extend beyond the miter limit; otherwise, beveled vertices.  	
        /// </summary>	
        /// <unmanaged>D2D1_LINE_JOIN_MITER_OR_BEVEL</unmanaged>
        MiterOrBevel = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Specifies the different methods by which two geometries can be combined.	
    /// </summary>	
    /// <remarks>	
    /// The following illustration shows the different geometry combine modes.	
    /// ?Illustration of two geometries and the resulting shapes after various geometry combine modes?	
    /// </remarks>	
    /// <unmanaged>D2D1_COMBINE_MODE</unmanaged>
    public enum CombineMode : int {	
        
        /// <summary>	
        /// The two regions are combined by taking the union of both. Given two geometries, A and B, the resulting geometry is geometry A + geometry B.	
        /// </summary>	
        /// <unmanaged>D2D1_COMBINE_MODE_UNION</unmanaged>
        Union = unchecked((int)0),			
        
        /// <summary>	
        /// The two regions are combined by taking their intersection. The new area consists of the overlapping region between the two geometries. 	
        /// </summary>	
        /// <unmanaged>D2D1_COMBINE_MODE_INTERSECT</unmanaged>
        Intersect = unchecked((int)1),			
        
        /// <summary>	
        /// The two regions are combined by taking the area that exists in the first region but not the second and the area that exists in the second region but not the first. Given two geometries, A and B, the new region consists of (A-B) + (B-A). 	
        /// </summary>	
        /// <unmanaged>D2D1_COMBINE_MODE_XOR</unmanaged>
        Xor = unchecked((int)2),			
        
        /// <summary>	
        /// The second region is excluded from the first. Given two geometries, A and B, the area of geometry B is removed from the area of geometry A, producing a region that is A-B.	
        /// </summary>	
        /// <unmanaged>D2D1_COMBINE_MODE_EXCLUDE</unmanaged>
        Exclude = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Describes how one geometry object is spatially related to another geometry object. 	
    /// </summary>	
    /// <unmanaged>D2D1_GEOMETRY_RELATION</unmanaged>
    public enum GeometryRelation : int {	
        
        /// <summary>	
        /// The relationship between the two geometries cannot be determined. This value is never returned by any D2D method.  	
        /// </summary>	
        /// <unmanaged>D2D1_GEOMETRY_RELATION_UNKNOWN</unmanaged>
        Unknown = unchecked((int)0),			
        
        /// <summary>	
        /// The two geometries do not intersect at all.	
        /// </summary>	
        /// <unmanaged>D2D1_GEOMETRY_RELATION_DISJOINT</unmanaged>
        Disjoint = unchecked((int)1),			
        
        /// <summary>	
        /// The instance geometry is entirely contained by  the passed-in geometry.	
        /// </summary>	
        /// <unmanaged>D2D1_GEOMETRY_RELATION_IS_CONTAINED</unmanaged>
        IsContained = unchecked((int)2),			
        
        /// <summary>	
        /// The instance geometry entirely contains the passed-in geometry.	
        /// </summary>	
        /// <unmanaged>D2D1_GEOMETRY_RELATION_CONTAINS</unmanaged>
        Contains = unchecked((int)3),			
        
        /// <summary>	
        /// The two geometries overlap but neither completely contains the other. 	
        /// </summary>	
        /// <unmanaged>D2D1_GEOMETRY_RELATION_OVERLAP</unmanaged>
        Overlap = unchecked((int)4),			
    }
    
    /// <summary>	
    /// Specifies how a geometry is simplified to an <see cref="SlimDX2.Direct2D1.SimplifiedGeometrySink"/>.	
    /// </summary>	
    /// <unmanaged>D2D1_GEOMETRY_SIMPLIFICATION_OPTION</unmanaged>
    public enum GeometrySimplificationOption : int {	
        
        /// <summary>	
        /// The output can contain cubic Bezier curves and line segments.	
        /// </summary>	
        /// <unmanaged>D2D1_GEOMETRY_SIMPLIFICATION_OPTION_CUBICS_AND_LINES</unmanaged>
        CubicsAndLines = unchecked((int)0),			
        
        /// <summary>	
        /// The output is flattened so that it contains only line segments. 	
        /// </summary>	
        /// <unmanaged>D2D1_GEOMETRY_SIMPLIFICATION_OPTION_LINES</unmanaged>
        Lines = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Indicates whether a specific<see cref="SlimDX2.Direct2D1.SimplifiedGeometrySink"/> figure is filled or hollow. 	
    /// </summary>	
    /// <unmanaged>D2D1_FIGURE_BEGIN</unmanaged>
    public enum FigureBegin : int {	
        
        /// <summary>	
        /// The figure is filled. 	
        /// </summary>	
        /// <unmanaged>D2D1_FIGURE_BEGIN_FILLED</unmanaged>
        Filled = unchecked((int)0),			
        
        /// <summary>	
        /// The figure is hollow.	
        /// </summary>	
        /// <unmanaged>D2D1_FIGURE_BEGIN_HOLLOW</unmanaged>
        Hollow = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Indicates whether a specific <see cref="SlimDX2.Direct2D1.SimplifiedGeometrySink"/> figure is open or closed. 	
    /// </summary>	
    /// <unmanaged>D2D1_FIGURE_END</unmanaged>
    public enum FigureEnd : int {	
        
        /// <summary>	
        /// The figure is open.	
        /// </summary>	
        /// <unmanaged>D2D1_FIGURE_END_OPEN</unmanaged>
        Open = unchecked((int)0),			
        
        /// <summary>	
        /// The figure is closed.	
        /// </summary>	
        /// <unmanaged>D2D1_FIGURE_END_CLOSED</unmanaged>
        Closed = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Indicates whether a segment should be stroked and whether the join between this segment and the previous one should be smooth. This enumeration allows a bitwise combination of its member values. 	
    /// </summary>	
    /// <unmanaged>D2D1_PATH_SEGMENT</unmanaged>
    public enum PathSegment : int {	
        
        /// <summary>	
        /// The segment is joined  as specified by the <see cref="SlimDX2.Direct2D1.StrokeStyle"/> interface, and it is stroked. 	
        /// </summary>	
        /// <unmanaged>D2D1_PATH_SEGMENT_NONE</unmanaged>
        None = unchecked((int)0),			
        
        /// <summary>	
        /// The segment is not stroked.	
        /// </summary>	
        /// <unmanaged>D2D1_PATH_SEGMENT_FORCE_UNSTROKED</unmanaged>
        ForceUnstroked = unchecked((int)1),			
        
        /// <summary>	
        /// The segment is always joined with the one preceding it using a round line join, regardless of which <see cref="SlimDX2.Direct2D1.LineJoin"/>enumeration is specified by the <see cref="SlimDX2.Direct2D1.StrokeStyle"/> interface. If this segment is the first segment and the figure is closed, a round line join is used to connect the closing segment with the first segment. If the figure is not closed, this setting has no effect on the first segment of the figure. If <see cref="SlimDX2.Direct2D1.SimplifiedGeometrySink.SetSegmentFlags"/> is called just before <see cref="SlimDX2.Direct2D1.SimplifiedGeometrySink.EndFigure"/>, the join between the closing segment and the last explicitly specified segment is affected.	
        /// </summary>	
        /// <unmanaged>D2D1_PATH_SEGMENT_FORCE_ROUND_LINE_JOIN</unmanaged>
        ForceRoundLineJoin = unchecked((int)2),			
    }
    
    /// <summary>	
    /// Defines the direction that an elliptical arc is drawn.  	
    /// </summary>	
    /// <unmanaged>D2D1_SWEEP_DIRECTION</unmanaged>
    public enum SweepDirection : int {	
        
        /// <summary>	
        ///  Arcs are drawn in a counterclockwise (negative-angle) direction. 	
        /// </summary>	
        /// <unmanaged>D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE</unmanaged>
        CounterClockwise = unchecked((int)0),			
        
        /// <summary>	
        ///  Arcs are drawn in a clockwise (positive-angle) direction. 	
        /// </summary>	
        /// <unmanaged>D2D1_SWEEP_DIRECTION_CLOCKWISE</unmanaged>
        Clockwise = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Specifies how the intersecting areas of geometries or figures are combined to form the area of the composite geometry. 	
    /// </summary>	
    /// <remarks>	
    /// Use the D2D1_FILL_MODE enumeration when creating an <see cref="SlimDX2.Direct2D1.GeometryGroup"/> with the {{CreateGeometryGroup}} method, or when modifying the fill mode of an <see cref="SlimDX2.Direct2D1.SimplifiedGeometrySink"/> with the <see cref="SlimDX2.Direct2D1.SimplifiedGeometrySink.SetFillMode"/> method.Direct2D fills the interior of a path by using one of the two fill modes specified by this enumeration: D2D1_FILL_MODE_ALTERNATE (alternate) or D2D1_FILL_MODE_WINDING (winding). Because the modes determine how to fill the interior of a closed shape, all shapes are treated as closed when they are filled.  If there is a gap in a segment in a shape, draw an imaginary line to close it.  To see the difference between the winding and alternate fill modes, assume that you have four circles with the same center and a different radius, as shown in the following illustration. The first one has the radius of 25, the second 50, the third 75, and the fourth 100.?Illustration of four concentric circles with different radius values?The following  illustration shows the shape filled by using the alternate fill mode. Notice that the center and third ring are not filled. This is because a ray drawn from any point in either of those two rings passes through an even number of segments. ?Illustration of concentric circles with the second and fourth rings filled?The following illustration explains this process. ?Illustration of concentric circles with points in the second and third rings and two arbitrary rays extending from each point?The following illustration shows how the same shape is filled when the winding fill mode is specified. ?Illustration of concentric circles with all rings filled?Notice that all the rings are filled. This is because all the segments run in the same direction, so a ray drawn from any point will cross one or more segments, and the sum of the crossings will not equal zero. The following illustration explains this process. The red arrows represent the direction in which the segments are drawn and the black arrow represents an arbitrary ray that runs from a point in the innermost ring. Starting with a value of zero, for each segment that the ray crosses, a value of one is added for every clockwise intersection. All points lie in the fill region in this illustration, because the count does not equal zero. ?Illustration of concentric circles with a ray from within the first ring that crosses all four rings?	
    /// </remarks>	
    /// <unmanaged>D2D1_FILL_MODE</unmanaged>
    public enum FillMode : int {	
        
        /// <summary>	
        /// Determines whether a point is in the fill region by drawing a ray from that point to infinity in any direction, and then counting the number of path segments within the given shape that the ray crosses. If this number is odd, the point is in the fill region; if even, the point is outside the fill region.  	
        /// </summary>	
        /// <unmanaged>D2D1_FILL_MODE_ALTERNATE</unmanaged>
        Alternate = unchecked((int)0),			
        
        /// <summary>	
        /// Determines whether a point is in the fill region of the path by drawing a ray from that point to infinity in any direction, and then examining the places where a segment of the shape crosses the ray. Starting with a count of zero, add one each time a segment crosses the ray from left to right and subtract one each time a path segment crosses the ray from right to left,  as long as left and right are seen from the perspective of the ray. After counting the crossings, if the result is zero, then the point is outside the path. Otherwise, it is inside the path.  	
        /// </summary>	
        /// <unmanaged>D2D1_FILL_MODE_WINDING</unmanaged>
        Winding = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Specifies options that can be applied when a layer resource is applied to create a layer.	
    /// </summary>	
    /// <remarks>	
    /// ClearType antialiasing must use the current contents of the render target to blend properly. When a pushed layer requests initializing for ClearType, Direct 2D copies the current contents of the render target into the layer so that ClearType antialiasing can be performed. Rendering ClearType text into a transparent layer does not produce the desired results.A small performance hit from re-copying content occurs when <see cref="SlimDX2.Direct2D1.RenderTarget.Clear"/> is called.	
    /// </remarks>	
    /// <unmanaged>D2D1_LAYER_OPTIONS</unmanaged>
    public enum LayerOptions : int {	
        
        /// <summary>	
        ///  The text in this layer does not use ClearType antialiasing.	
        /// </summary>	
        /// <unmanaged>D2D1_LAYER_OPTIONS_NONE</unmanaged>
        None = unchecked((int)0),			
        
        /// <summary>	
        /// The layer renders correctly for ClearType text. If the render target is set to ClearType, the  layer continues to render ClearType. If the render target is set to ClearType and this option is not specified, the render target will be set to render gray-scale until the layer is popped. The caller can override this default by calling {{SetTextAntialiasMode}} while within the layer. This flag is slightly slower than the default. 	
        /// </summary>	
        /// <unmanaged>D2D1_LAYER_OPTIONS_INITIALIZE_FOR_CLEARTYPE</unmanaged>
        InitializeForCleartype = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Describes whether a window is occluded. 	
    /// </summary>	
    /// <remarks>	
    /// If the window was occluded the last time  {{EndDraw}} was called, the next time the render target calls {{CheckWindowState}}, it will return D2D1_WINDOW_STATE_OCCLUDED regardless of the current window state. If you want to use CheckWindowState to determine the current window state, you should call CheckWindowState after every EndDraw call and ignore its return value. This will ensure that your next call to CheckWindowState state will return the actual window state.	
    /// </remarks>	
    /// <unmanaged>D2D1_WINDOW_STATE</unmanaged>
    public enum WindowState : int {	
        
        /// <summary>	
        /// The window is not occluded.	
        /// </summary>	
        /// <unmanaged>D2D1_WINDOW_STATE_NONE</unmanaged>
        None = unchecked((int)0),			
        
        /// <summary>	
        /// The window is occluded.	
        /// </summary>	
        /// <unmanaged>D2D1_WINDOW_STATE_OCCLUDED</unmanaged>
        Occluded = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Describes whether a render target uses hardware or software rendering, or if Direct2D should select the rendering mode.	
    /// </summary>	
    /// <remarks>	
    /// Not every render target supports hardware rendering. For more information, see the {{Render Targets Overview}}. 	
    /// </remarks>	
    /// <unmanaged>D2D1_RENDER_TARGET_TYPE</unmanaged>
    public enum RenderTargetType : int {	
        
        /// <summary>	
        /// The render target uses hardware rendering, if available; otherwise, it uses software rendering.	
        /// </summary>	
        /// <unmanaged>D2D1_RENDER_TARGET_TYPE_DEFAULT</unmanaged>
        Default = unchecked((int)0),			
        
        /// <summary>	
        /// The render target uses software rendering only.	
        /// </summary>	
        /// <unmanaged>D2D1_RENDER_TARGET_TYPE_SOFTWARE</unmanaged>
        Software = unchecked((int)1),			
        
        /// <summary>	
        /// The render target uses hardware rendering only. 	
        /// </summary>	
        /// <unmanaged>D2D1_RENDER_TARGET_TYPE_HARDWARE</unmanaged>
        Hardware = unchecked((int)2),			
    }
    
    /// <summary>	
    /// Describes the minimum DirectX support required for hardware rendering by a render target.	
    /// </summary>	
    /// <unmanaged>D2D1_FEATURE_LEVEL</unmanaged>
    public enum FeatureLevel : int {	
        
        /// <summary>	
        /// Direct2D determines whether the video card provides adequate hardware rendering support.	
        /// </summary>	
        /// <unmanaged>D2D1_FEATURE_LEVEL_DEFAULT</unmanaged>
        Level_DEFAULT = unchecked((int)0),			
        
        /// <summary>	
        /// The video card must support DirectX 9.	
        /// </summary>	
        /// <unmanaged>D2D1_FEATURE_LEVEL_9</unmanaged>
        Level_9 = unchecked((int)37120),			
        
        /// <summary>	
        /// The video card must support DirectX 10. 	
        /// </summary>	
        /// <unmanaged>D2D1_FEATURE_LEVEL_10</unmanaged>
        Level_10 = unchecked((int)40960),			
    }
    
    /// <summary>	
    ///  Describes how a render target is remoted and whether it should be GDI-compatible. This enumeration allows a bitwise combination of its member values.	
    /// </summary>	
    /// <unmanaged>D2D1_RENDER_TARGET_USAGE</unmanaged>
    public enum RenderTargetUsage : int {	
        
        /// <summary>	
        /// The render target attempts to use Direct3D command-stream remoting and uses bitmap remoting if stream remoting fails. The render target is not GDI-compatible.	
        /// </summary>	
        /// <unmanaged>D2D1_RENDER_TARGET_USAGE_NONE</unmanaged>
        None = unchecked((int)0),			
        
        /// <summary>	
        /// The render target renders content locally and sends it to the terminal services client as a bitmap. 	
        /// </summary>	
        /// <unmanaged>D2D1_RENDER_TARGET_USAGE_FORCE_BITMAP_REMOTING</unmanaged>
        ForceBitmapRemoting = unchecked((int)1),			
        
        /// <summary>	
        /// The render target can be used efficiently with GDI.	
        /// </summary>	
        /// <unmanaged>D2D1_RENDER_TARGET_USAGE_GDI_COMPATIBLE</unmanaged>
        GdiCompatible = unchecked((int)2),			
    }
    
    /// <summary>	
    /// Describes how a render target behaves when it presents its content. This enumeration allows a bitwise combination of its member values.	
    /// </summary>	
    /// <unmanaged>D2D1_PRESENT_OPTIONS</unmanaged>
    public enum PresentOptions : int {	
        
        /// <summary>	
        /// The render target waits until the display refreshes to present and discards the frame upon presenting.	
        /// </summary>	
        /// <unmanaged>D2D1_PRESENT_OPTIONS_NONE</unmanaged>
        None = unchecked((int)0),			
        
        /// <summary>	
        /// The render target does not discard the frame upon presenting.	
        /// </summary>	
        /// <unmanaged>D2D1_PRESENT_OPTIONS_RETAIN_CONTENTS</unmanaged>
        RetainContents = unchecked((int)1),			
        
        /// <summary>	
        /// The render target does not wait until the display refreshes to present.	
        /// </summary>	
        /// <unmanaged>D2D1_PRESENT_OPTIONS_IMMEDIATELY</unmanaged>
        Immediately = unchecked((int)2),			
    }
    
    /// <summary>	
    /// Specifies additional features supportable by a compatible render target when it is created.  This enumeration allows a bitwise combination of its member values.	
    /// </summary>	
    /// <remarks>	
    /// Use this enumeration when creating a compatible render target with the {{CreateCompatibleRenderTarget}} method. For more information about compatible render targets, see the {{Render Targets Overview}}. The D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_GDI_COMPATIBLE option may only be requested if the parent render target was created with <see cref="SlimDX2.Direct2D1.RenderTargetUsage.GdiCompatible"/> (for most render targets) or D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_GDI_COMPATIBLE (for render targets created by the {{CreateCompatibleRenderTarget}} method).	
    /// </remarks>	
    /// <unmanaged>D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS</unmanaged>
    public enum CompatibleRenderTargetOptions : int {	
        
        /// <summary>	
        /// The render target supports no additional features.	
        /// </summary>	
        /// <unmanaged>D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_NONE</unmanaged>
        None = unchecked((int)0),			
        
        /// <summary>	
        /// The render target supports interoperability with the Windows Graphics Device Interface  (GDI). 	
        /// </summary>	
        /// <unmanaged>D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_GDI_COMPATIBLE</unmanaged>
        GdiCompatible = unchecked((int)1),			
    }
    
    /// <summary>	
    ///  Specifies how a device context is initialized for GDI rendering when it is retrieved from the render target.	
    /// </summary>	
    /// <remarks>	
    /// Use this enumeration with the <see cref="SlimDX2.Direct2D1.GdiInteropRenderTarget.GetDC"/> method to specify how the device context is  initialized for GDI rendering.	
    /// </remarks>	
    /// <unmanaged>D2D1_DC_INITIALIZE_MODE</unmanaged>
    public enum DcInitializeMode : int {	
        
        /// <summary>	
        /// The current contents of the render target are copied to the device context when it is initialized. 	
        /// </summary>	
        /// <unmanaged>D2D1_DC_INITIALIZE_MODE_COPY</unmanaged>
        Copy = unchecked((int)0),			
        
        /// <summary>	
        /// The device context is cleared to transparent black when it is initialized.	
        /// </summary>	
        /// <unmanaged>D2D1_DC_INITIALIZE_MODE_CLEAR</unmanaged>
        Clear = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Indicates the type of information provided by the {{Direct2D Debug Layer}}.  	
    /// </summary>	
    /// <remarks>	
    /// To receive debugging messages, you must install the {{Direct2D Debug Layer}}.	
    /// </remarks>	
    /// <unmanaged>D2D1_DEBUG_LEVEL</unmanaged>
    public enum DebugLevel : int {	
        
        /// <summary>	
        /// Direct2D does not produce any debugging output. 	
        /// </summary>	
        /// <unmanaged>D2D1_DEBUG_LEVEL_NONE</unmanaged>
        None = unchecked((int)0),			
        
        /// <summary>	
        /// Direct2D sends error messages to the debug layer.	
        /// </summary>	
        /// <unmanaged>D2D1_DEBUG_LEVEL_ERROR</unmanaged>
        Error = unchecked((int)1),			
        
        /// <summary>	
        /// Direct2D sends error messages and warnings to the debug layer.	
        /// </summary>	
        /// <unmanaged>D2D1_DEBUG_LEVEL_WARNING</unmanaged>
        Warning = unchecked((int)2),			
        
        /// <summary>	
        /// Direct2D sends error messages, warnings, and additional diagnostic information that can help improve performance to the debug layer.  	
        /// </summary>	
        /// <unmanaged>D2D1_DEBUG_LEVEL_INFORMATION</unmanaged>
        Information = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Specifies whether Direct2D provides synchronization for an <see cref="SlimDX2.Direct2D1.Factory"/> and the resources it creates, so that they may be safely accessed from multiple threads. 	
    /// </summary>	
    /// <remarks>	
    /// When you create a factory, you can specify whether it is multithreaded or singlethreaded. A singlethreaded factory provides no serialization against any other single threaded instance within Direct2D, so this mechanism provides a very large degree of scaling on the CPU.You can also create a multithreaded factory instance. In this case, the factory and all derived objects can be used from any thread, and each render target can be rendered to independently. Direct2D serializes calls to these objects, so a single multithreaded Direct2D instance won't scale as well on the CPU as many single threaded instances. However, the resources can be shared within the multithreaded instance.Note the qualifier "On the CPU": GPUs generally take advantage of fine-grained parallelism more so than CPUs. For example, multithreaded calls from the CPU might still end up being serialized when being sent to the GPU; however, a whole bank of pixel and vertex shaders will run in parallel to perform the rendering. 	
    /// </remarks>	
    /// <unmanaged>D2D1_FACTORY_TYPE</unmanaged>
    public enum FactoryType : int {	
        
        /// <summary>	
        /// No synchronization is provided for accessing or writing to the factory or the objects it creates. If the factory or the objects are called from multiple threads, it is up to the application to provide access locking.	
        /// </summary>	
        /// <unmanaged>D2D1_FACTORY_TYPE_SINGLE_THREADED</unmanaged>
        SingleThreaded = unchecked((int)0),			
        
        /// <summary>	
        /// Direct2D provides synchronization for accessing and writing to the factory and the objects it creates, enabling safe access from multiple threads.	
        /// </summary>	
        /// <unmanaged>D2D1_FACTORY_TYPE_MULTI_THREADED</unmanaged>
        MultiThreaded = unchecked((int)1),			
    }
}
