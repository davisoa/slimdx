// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Enums for SlimDX2.Direct3D11 namespace.
//     This code was generated by a tool.
//     Date : 11/08/2010 15:18:18
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace SlimDX2.Direct3D11 {

    
    /// <summary>	
    /// Type of data contained in an input slot.	
    /// </summary>	
    /// <remarks>	
    /// Use these values to specify the type of data for a particular input element (see <see cref="SlimDX2.Direct3D11.InputElement"/>) of an input-layout object.	
    /// </remarks>	
    /// <unmanaged>D3D11_INPUT_CLASSIFICATION</unmanaged>
    public enum InputClassification : int {	
        
        /// <summary>	
        /// Input data is per-vertex data.	
        /// </summary>	
        /// <unmanaged>D3D11_INPUT_PER_VERTEX_DATA</unmanaged>
        PerVertexData = unchecked((int)0),			
        
        /// <summary>	
        /// Input data is per-instance data.	
        /// </summary>	
        /// <unmanaged>D3D11_INPUT_PER_INSTANCE_DATA</unmanaged>
        PerInstanceData = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Determines the fill mode to use when rendering triangles.	
    /// </summary>	
    /// <remarks>	
    /// This enumeration is part of a rasterizer-state object description (see <see cref="SlimDX2.Direct3D11.RasterizerStateDescription"/>).	
    /// </remarks>	
    /// <unmanaged>D3D11_FILL_MODE</unmanaged>
    public enum FillMode : int {	
        
        /// <summary>	
        /// Draw lines connecting the vertices. Adjacent vertices are not drawn.	
        /// </summary>	
        /// <unmanaged>D3D11_FILL_WIREFRAME</unmanaged>
        Wireframe = unchecked((int)2),			
        
        /// <summary>	
        /// Fill the triangles formed by the vertices. Adjacent vertices are not drawn.	
        /// </summary>	
        /// <unmanaged>D3D11_FILL_SOLID</unmanaged>
        Solid = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Indicates triangles facing a particular direction are not drawn.	
    /// </summary>	
    /// <remarks>	
    /// This enumeration is part of a rasterizer-state object description (see <see cref="SlimDX2.Direct3D11.RasterizerStateDescription"/>).	
    /// </remarks>	
    /// <unmanaged>D3D11_CULL_MODE</unmanaged>
    public enum CullMode : int {	
        
        /// <summary>	
        /// Always draw all triangles.	
        /// </summary>	
        /// <unmanaged>D3D11_CULL_NONE</unmanaged>
        None = unchecked((int)1),			
        
        /// <summary>	
        /// Do not draw triangles that are front-facing.	
        /// </summary>	
        /// <unmanaged>D3D11_CULL_FRONT</unmanaged>
        Front = unchecked((int)2),			
        
        /// <summary>	
        /// Do not draw triangles that are back-facing.	
        /// </summary>	
        /// <unmanaged>D3D11_CULL_BACK</unmanaged>
        Back = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Identifies the type of resource being used.	
    /// </summary>	
    /// <remarks>	
    /// This enumeration is used in <see cref="SlimDX2.Direct3D11.Resource.GetTypeInfo"/>. 	
    /// </remarks>	
    /// <unmanaged>D3D11_RESOURCE_DIMENSION</unmanaged>
    public enum ResourceDimension : int {	
        
        /// <summary>	
        /// Resource is of unknown type.	
        /// </summary>	
        /// <unmanaged>D3D11_RESOURCE_DIMENSION_UNKNOWN</unmanaged>
        Unknown = unchecked((int)0),			
        
        /// <summary>	
        /// Resource is a buffer.	
        /// </summary>	
        /// <unmanaged>D3D11_RESOURCE_DIMENSION_BUFFER</unmanaged>
        Buffer = unchecked((int)1),			
        
        /// <summary>	
        /// Resource is a 1D texture.	
        /// </summary>	
        /// <unmanaged>D3D11_RESOURCE_DIMENSION_TEXTURE1D</unmanaged>
        Texture1D = unchecked((int)2),			
        
        /// <summary>	
        /// Resource is a 2D texture.	
        /// </summary>	
        /// <unmanaged>D3D11_RESOURCE_DIMENSION_TEXTURE2D</unmanaged>
        Texture2D = unchecked((int)3),			
        
        /// <summary>	
        /// Resource is a 3D texture.	
        /// </summary>	
        /// <unmanaged>D3D11_RESOURCE_DIMENSION_TEXTURE3D</unmanaged>
        Texture3D = unchecked((int)4),			
    }
    
    /// <summary>	
    /// Specifies how to access a resource used in a depth-stencil view.	
    /// </summary>	
    /// <remarks>	
    /// This enumeration is used in <see cref="SlimDX2.Direct3D11.DepthStencilViewDescription"/> to create a depth-stencil view.	
    /// </remarks>	
    /// <unmanaged>D3D11_DSV_DIMENSION</unmanaged>
    public enum Dimension : int {	
        
        /// <summary>	
        /// D3D11_DSV_DIMENSION_UNKNOWN is not a valid value for <see cref="SlimDX2.Direct3D11.DepthStencilViewDescription"/> and is not used.	
        /// </summary>	
        /// <unmanaged>D3D11_DSV_DIMENSION_UNKNOWN</unmanaged>
        DimensionUnknown = unchecked((int)0),			
        
        /// <summary>	
        /// The resource will be accessed as a 1D texture.	
        /// </summary>	
        /// <unmanaged>D3D11_DSV_DIMENSION_TEXTURE1D</unmanaged>
        DimensionTexture1D = unchecked((int)1),			
        
        /// <summary>	
        /// The resource will be accessed as an array of 1D textures.	
        /// </summary>	
        /// <unmanaged>D3D11_DSV_DIMENSION_TEXTURE1DARRAY</unmanaged>
        DimensionTexture1DArray = unchecked((int)2),			
        
        /// <summary>	
        /// The resource will be accessed as a 2D texture.	
        /// </summary>	
        /// <unmanaged>D3D11_DSV_DIMENSION_TEXTURE2D</unmanaged>
        DimensionTexture2D = unchecked((int)3),			
        
        /// <summary>	
        /// The resource will be accessed as an array of 2D textures.	
        /// </summary>	
        /// <unmanaged>D3D11_DSV_DIMENSION_TEXTURE2DARRAY</unmanaged>
        DimensionTexture2DArray = unchecked((int)4),			
        
        /// <summary>	
        /// The resource will be accessed as a 2D texture with multisampling.	
        /// </summary>	
        /// <unmanaged>D3D11_DSV_DIMENSION_TEXTURE2DMS</unmanaged>
        DimensionTexture2DMultisampled = unchecked((int)5),			
        
        /// <summary>	
        /// The resource will be accessed as an array of 2D textures with multisampling.	
        /// </summary>	
        /// <unmanaged>D3D11_DSV_DIMENSION_TEXTURE2DMSARRAY</unmanaged>
        DimensionTexture2DMultisampledArray = unchecked((int)6),			
    }
    
    /// <summary>	
    /// These flags identify the type of resource that will be viewed as a render target.	
    /// </summary>	
    /// <remarks>	
    /// This enumeration is used in <see cref="SlimDX2.Direct3D11.RenderTargetViewDescription"/> to create a render-target view.	
    /// </remarks>	
    /// <unmanaged>D3D11_RTV_DIMENSION</unmanaged>
    public enum RenderTargetViewDimension : int {	
        
        /// <summary>	
        /// Do not use this value, as it will cause <see cref="SlimDX2.Direct3D11.Device.CreateRenderTargetView"/> to fail.	
        /// </summary>	
        /// <unmanaged>D3D11_RTV_DIMENSION_UNKNOWN</unmanaged>
        Unknown = unchecked((int)0),			
        
        /// <summary>	
        /// The resource will be accessed as a buffer.	
        /// </summary>	
        /// <unmanaged>D3D11_RTV_DIMENSION_BUFFER</unmanaged>
        Buffer = unchecked((int)1),			
        
        /// <summary>	
        /// The resource will be accessed as a 1D texture.	
        /// </summary>	
        /// <unmanaged>D3D11_RTV_DIMENSION_TEXTURE1D</unmanaged>
        Texture1D = unchecked((int)2),			
        
        /// <summary>	
        /// The resource will be accessed as an array of 1D textures.	
        /// </summary>	
        /// <unmanaged>D3D11_RTV_DIMENSION_TEXTURE1DARRAY</unmanaged>
        Texture1DArray = unchecked((int)3),			
        
        /// <summary>	
        /// The resource will be accessed as a 2D texture.	
        /// </summary>	
        /// <unmanaged>D3D11_RTV_DIMENSION_TEXTURE2D</unmanaged>
        Texture2D = unchecked((int)4),			
        
        /// <summary>	
        /// The resource will be accessed as an array of 2D textures.	
        /// </summary>	
        /// <unmanaged>D3D11_RTV_DIMENSION_TEXTURE2DARRAY</unmanaged>
        Texture2DArray = unchecked((int)5),			
        
        /// <summary>	
        /// The resource will be accessed as a 2D texture with multisampling.	
        /// </summary>	
        /// <unmanaged>D3D11_RTV_DIMENSION_TEXTURE2DMS</unmanaged>
        Texture2DMultisampled = unchecked((int)6),			
        
        /// <summary>	
        /// The resource will be accessed as an array of 2D textures with multisampling.	
        /// </summary>	
        /// <unmanaged>D3D11_RTV_DIMENSION_TEXTURE2DMSARRAY</unmanaged>
        Texture2DMultisampledArray = unchecked((int)7),			
        
        /// <summary>	
        /// The resource will be accessed as a 3D texture.	
        /// </summary>	
        /// <unmanaged>D3D11_RTV_DIMENSION_TEXTURE3D</unmanaged>
        Texture3D = unchecked((int)8),			
    }
    
    /// <summary>	
    /// Unordered-access view options.	
    /// </summary>	
    /// <remarks>	
    /// This enumeration is used by a unordered access-view description (see <see cref="SlimDX2.Direct3D11.UnorderedAccessViewDescription"/>).	
    /// </remarks>	
    /// <unmanaged>D3D11_UAV_DIMENSION</unmanaged>
    public enum UnorderedAccessViewDimension : int {	
        
        /// <summary>	
        /// The view type is unknown.	
        /// </summary>	
        /// <unmanaged>D3D11_UAV_DIMENSION_UNKNOWN</unmanaged>
        Unknown = unchecked((int)0),			
        
        /// <summary>	
        /// View the resource as a buffer.	
        /// </summary>	
        /// <unmanaged>D3D11_UAV_DIMENSION_BUFFER</unmanaged>
        Buffer = unchecked((int)1),			
        
        /// <summary>	
        /// View the resource as a 1D texture.	
        /// </summary>	
        /// <unmanaged>D3D11_UAV_DIMENSION_TEXTURE1D</unmanaged>
        Texture1D = unchecked((int)2),			
        
        /// <summary>	
        /// View the resource as a 1D texture array.	
        /// </summary>	
        /// <unmanaged>D3D11_UAV_DIMENSION_TEXTURE1DARRAY</unmanaged>
        Texture1DArray = unchecked((int)3),			
        
        /// <summary>	
        /// View the resource as a 2D texture.	
        /// </summary>	
        /// <unmanaged>D3D11_UAV_DIMENSION_TEXTURE2D</unmanaged>
        Texture2D = unchecked((int)4),			
        
        /// <summary>	
        /// View the resource as a 2D texture array.	
        /// </summary>	
        /// <unmanaged>D3D11_UAV_DIMENSION_TEXTURE2DARRAY</unmanaged>
        Texture2DArray = unchecked((int)5),			
        
        /// <summary>	
        /// View the resource as a 3D texture array.	
        /// </summary>	
        /// <unmanaged>D3D11_UAV_DIMENSION_TEXTURE3D</unmanaged>
        Texture3D = unchecked((int)8),			
    }
    
    /// <summary>	
    /// Identifies expected resource use during rendering. The usage directly reflects whether a resource is accessible by the CPU and/or the GPU.	
    /// </summary>	
    /// <remarks>	
    /// An application identifies the way a resource is intended to be used (its usage) in a resource description. There are several structures for creating resources including: <see cref="SlimDX2.Direct3D11.Texture1DDescription"/>, <see cref="SlimDX2.Direct3D11.Texture2DDescription"/>, <see cref="SlimDX2.Direct3D11.Texture3DDescription"/>, <see cref="SlimDX2.Direct3D11.BufferDescription"/>.Differences between Direct3D 9 and Direct3D 10/11:In Direct3D 9, you specify the type of memory a resource should be created in at resource creation time (using D3DPOOL). It was an application's job to decide what memory pool would provide the best combination of functionality and performance.In Direct3D 10/11, an application no longer specifies what type of memory (the pool) to create a resource in. Instead, you specify the intended usage of the resource, and let the runtime (in concert with the driver and a memory manager) choose the type of memory that will achieve the best performance. Resource Usage RestrictionsEach usage dictates a tradeoff between functionality and performance. In general, resource accessing is accomplished with the following APIs.CPU access is done with <see cref="SlimDX2.Direct3D11.DeviceContext.Map"/>.GPU access is done with <see cref="SlimDX2.Direct3D11.DeviceContext.CopySubresourceRegion"/>, <see cref="SlimDX2.Direct3D11.DeviceContext.CopyResource"/>, or <see cref="SlimDX2.Direct3D11.DeviceContext.UpdateSubresource"/>.Use the following table to choose the usage that best describes how the resource will need to be accessed by the CPU and/or the GPU. Of course, there will be performance tradeoffs.Resource UsageDefaultDynamicImmutableStagingGPU-Readyesyes1yesyes1, 2GPU-Writeyes1yes1, 2CPU-Readyes1, 2CPU-Writeyesyes1, 2 1 - This is restricted to <see cref="SlimDX2.Direct3D11.DeviceContext.CopySubresourceRegion"/>, <see cref="SlimDX2.Direct3D11.DeviceContext.CopyResource"/> and <see cref="SlimDX2.Direct3D11.DeviceContext.CopyStructureCount"/>.2 - Cannot be a depth-stencil buffer or a multisampled render target.Resource Bind OptionsTo maximize performance, not all resource usage options can be used as input or output resources to the pipeline. This table identifies these limitations.Resource Can Be Bound AsDefaultDynamicImmutableStagingInput to a Stageyes3yes4yesOutput from a Stageyes3 3 - If bound as an input and an output using different views, each view must use different subresources.4 - The resource can only be created with a single subresource. The resource cannot be a texture array. The resource cannot be a mipmap chain.	
    /// </remarks>	
    /// <unmanaged>D3D11_USAGE</unmanaged>
    public enum ResourceUsage : int {	
        
        /// <summary>	
        /// A resource that requires read and write access by the GPU. This is likely to be the most common usage choice.	
        /// </summary>	
        /// <unmanaged>D3D11_USAGE_DEFAULT</unmanaged>
        Default = unchecked((int)0),			
        
        /// <summary>	
        /// A resource that can only be read by the GPU. It cannot be written by the GPU, and cannot be accessed at all by the CPU. This type of resource must be initialized when it is created, since it cannot be changed after creation.	
        /// </summary>	
        /// <unmanaged>D3D11_USAGE_IMMUTABLE</unmanaged>
        Immutable = unchecked((int)1),			
        
        /// <summary>	
        /// A resource that is accessible by both the GPU (read only) and the CPU (write only). A dynamic resource is a good choice for a resource that will be updated by the CPU at least once per frame. To update a dynamic resource, use a Map method.	
        /// </summary>	
        /// <unmanaged>D3D11_USAGE_DYNAMIC</unmanaged>
        Dynamic = unchecked((int)2),			
        
        /// <summary>	
        /// A resource that supports data transfer (copy) from the GPU to the CPU.	
        /// </summary>	
        /// <unmanaged>D3D11_USAGE_STAGING</unmanaged>
        Staging = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Identifies how to bind a resource to the pipeline.	
    /// </summary>	
    /// <remarks>	
    /// In general, binding flags can be combined using a logical OR (except the constant-buffer flag); however, you should use a single flag to allow the device to optimize the resource usage.This enumeration is used by a:{{Buffer description}} when creating a buffer.Texture description when creating a texture (see <see cref="SlimDX2.Direct3D11.Texture1DDescription"/> or <see cref="SlimDX2.Direct3D11.Texture2DDescription"/> or <see cref="SlimDX2.Direct3D11.Texture3DDescription"/>).A shader-resource buffer is NOT a constant buffer; rather, it is a texture or buffer resource that is bound to a shader, that contains texture or buffer data (it is not limited to a single element type in the buffer). A shader-resource buffer is created with the D3D11_BIND_SHADER_RESOURCE flag and is bound to the pipeline using one of these APIs: <see cref="SlimDX2.Direct3D11.DeviceContext.GeometryShaderStage.SetShaderResources"/>, <see cref="SlimDX2.Direct3D11.DeviceContext.PixelShaderStage.SetShaderResources"/>, or <see cref="SlimDX2.Direct3D11.DeviceContext.VertexShaderStage.SetShaderResources"/>. Furthermore, a shader-resource buffer cannot use the <see cref="SlimDX2.Direct3D11.MapMode.WriteNoOverwrite"/> flag.	
    /// </remarks>	
    /// <unmanaged>D3D11_BIND_FLAG</unmanaged>
    [Flags]
    public enum BindFlags : int {	
        
        /// <summary>	
        /// Bind a buffer as a vertex buffer to the input-assembler stage.	
        /// </summary>	
        /// <unmanaged>D3D11_BIND_VERTEX_BUFFER</unmanaged>
        VertexBuffer = unchecked((int)1),			
        
        /// <summary>	
        /// Bind a buffer as an index buffer to the input-assembler stage.	
        /// </summary>	
        /// <unmanaged>D3D11_BIND_INDEX_BUFFER</unmanaged>
        IndexBuffer = unchecked((int)2),			
        
        /// <summary>	
        /// Bind a buffer as a constant buffer to a shader stage; this flag may NOT be combined with any other bind flag.	
        /// </summary>	
        /// <unmanaged>D3D11_BIND_CONSTANT_BUFFER</unmanaged>
        ConstantBuffer = unchecked((int)4),			
        
        /// <summary>	
        /// Bind a buffer or texture to a shader stage; this flag cannot be used with the <see cref="SlimDX2.Direct3D11.MapMode.WriteNoOverwrite"/> flag.	
        /// </summary>	
        /// <unmanaged>D3D11_BIND_SHADER_RESOURCE</unmanaged>
        ShaderResource = unchecked((int)8),			
        
        /// <summary>	
        /// Bind an output buffer for the stream-output stage.	
        /// </summary>	
        /// <unmanaged>D3D11_BIND_STREAM_OUTPUT</unmanaged>
        StreamOutput = unchecked((int)16),			
        
        /// <summary>	
        /// Bind a texture as a render target for the output-merger stage.	
        /// </summary>	
        /// <unmanaged>D3D11_BIND_RENDER_TARGET</unmanaged>
        RenderTarget = unchecked((int)32),			
        
        /// <summary>	
        /// Bind a texture as a depth-stencil target for the output-merger stage.	
        /// </summary>	
        /// <unmanaged>D3D11_BIND_DEPTH_STENCIL</unmanaged>
        DepthStencil = unchecked((int)64),			
        
        /// <summary>	
        /// Bind an {{unordered access}} resource.	
        /// </summary>	
        /// <unmanaged>D3D11_BIND_UNORDERED_ACCESS</unmanaged>
        UnorderedAccess = unchecked((int)128),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Specifies the types of CPU access allowed for a resource.	
    /// </summary>	
    /// <remarks>	
    /// This enumeration is used in <see cref="SlimDX2.Direct3D11.BufferDescription"/>, <see cref="SlimDX2.Direct3D11.Texture1DDescription"/>, <see cref="SlimDX2.Direct3D11.Texture2DDescription"/>, <see cref="SlimDX2.Direct3D11.Texture3DDescription"/>. Applications may combine one or more of these flags with a logical OR. When possible, create resources with no CPU access flags, as this enables better resource optimiztion.	
    /// </remarks>	
    /// <unmanaged>D3D11_CPU_ACCESS_FLAG</unmanaged>
    [Flags]
    public enum CpuAccessFlags : int {	
        
        /// <summary>	
        /// The resource is to be mappable so that the CPU can change its contents. Resources created with this flag cannot be set as outputs of the pipeline and must be created with either dynamic or staging usage (see <see cref="SlimDX2.Direct3D11.ResourceUsage"/>).	
        /// </summary>	
        /// <unmanaged>D3D11_CPU_ACCESS_WRITE</unmanaged>
        Write = unchecked((int)65536),			
        
        /// <summary>	
        /// The resource is to be mappable so that the CPU can read its contents. Resources created with this flag cannot be set as either inputs or outputs to the pipeline and must be created with staging usage (see <see cref="SlimDX2.Direct3D11.ResourceUsage"/>).	
        /// </summary>	
        /// <unmanaged>D3D11_CPU_ACCESS_READ</unmanaged>
        Read = unchecked((int)131072),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Identifies other, less common options for resources.	
    /// </summary>	
    /// <remarks>	
    /// This enumeration is used in <see cref="SlimDX2.Direct3D11.BufferDescription"/>, <see cref="SlimDX2.Direct3D11.Texture1DDescription"/>, <see cref="SlimDX2.Direct3D11.Texture2DDescription"/>, <see cref="SlimDX2.Direct3D11.Texture3DDescription"/>. These flags can be combined by bitwise OR.	
    /// </remarks>	
    /// <unmanaged>D3D11_RESOURCE_MISC_FLAG</unmanaged>
    [Flags]
    public enum ResourceOptionFlags : int {	
        
        /// <summary>	
        /// Enables mipmap generation using <see cref="SlimDX2.Direct3D11.DeviceContext.GenerateMips"/> on a texture resource. The resource must be created with the {{bind flags}} that specify that the resource is a render target and a shader resource.	
        /// </summary>	
        /// <unmanaged>D3D11_RESOURCE_MISC_GENERATE_MIPS</unmanaged>
        GenerateMips = unchecked((int)1),			
        
        /// <summary>	
        /// Enables resource data sharing between two or more Direct3D devices. The only resources that can be shared are 2D non-mipmapped textures.D3D11_RESOURCE_MISC_SHARED and D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX are mutually exclusive.WARP and REF devices do not support shared resources. Attempting to create a resource with this flag on either a WARP or REF device will cause the create method to return an E_OUTOFMEMORY error code.	
        /// </summary>	
        /// <unmanaged>D3D11_RESOURCE_MISC_SHARED</unmanaged>
        Shared = unchecked((int)2),			
        
        /// <summary>	
        /// Enables a resource to be a cube texture created from a Texture2DArray that contains 6 textures.	
        /// </summary>	
        /// <unmanaged>D3D11_RESOURCE_MISC_TEXTURECUBE</unmanaged>
        Texturecube = unchecked((int)4),			
        
        /// <summary>	
        /// Enables instancing of GPU-generated content.	
        /// </summary>	
        /// <unmanaged>D3D11_RESOURCE_MISC_DRAWINDIRECT_ARGS</unmanaged>
        DrawindirectArgs = unchecked((int)16),			
        
        /// <summary>	
        /// Enables a resource as a {{byte address buffer}}.	
        /// </summary>	
        /// <unmanaged>D3D11_RESOURCE_MISC_BUFFER_ALLOW_RAW_VIEWS</unmanaged>
        BufferAllowRawViews = unchecked((int)32),			
        
        /// <summary>	
        /// Enables a resource as a {{structured buffer}}.	
        /// </summary>	
        /// <unmanaged>D3D11_RESOURCE_MISC_BUFFER_STRUCTURED</unmanaged>
        BufferStructured = unchecked((int)64),			
        
        /// <summary>	
        /// Enables a resource with mipmap clamping for use with <see cref="SlimDX2.Direct3D11.DeviceContext.SetMinimumLod"/>.	
        /// </summary>	
        /// <unmanaged>D3D11_RESOURCE_MISC_RESOURCE_CLAMP</unmanaged>
        ResourceClamp = unchecked((int)128),			
        
        /// <summary>	
        /// Enables the resource created to be synchronized using the <see cref="SlimDX2.DXGI.KeyedMutex.AcquireSync"/> and  <see cref="SlimDX2.DXGI.KeyedMutex.ReleaseSync"/> APIs.  The following Direct3D 11 resource creation  APIs, that take D3D11_RESOURCE_MISC_FLAG parameters, have been extended to support the new flag.<see cref="SlimDX2.Direct3D11.Device.CreateTexture1D"/><see cref="SlimDX2.Direct3D11.Device.CreateTexture2D"/><see cref="SlimDX2.Direct3D11.Device.CreateTexture3D"/><see cref="SlimDX2.Direct3D11.Device.CreateBuffer"/>If any of the above methods is called with the D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX flag set, the interface returned will support the <see cref="SlimDX2.DXGI.KeyedMutex"/> interface.  The IDXGIKeyedMutex interface can be acquired from the resource using {{IUnknown::QueryInterface}}.  The IDXGIKeyedMutex interface implements the <see cref="SlimDX2.DXGI.KeyedMutex.AcquireSync"/> and <see cref="SlimDX2.DXGI.KeyedMutex.ReleaseSync"/> APIs to synchronize access to the surface. The device creating the surface, and any other device opening the surface (using {{OpenSharedResource}}) is required to call IDXGIKeyedMutex::AcquireSync before any rendering commands to the surface, and IDXGIKeyedMutex::ReleaseSync when it is done rendering.D3D11_RESOURCE_MISC_SHARED and D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX are mutually exclusive.WARP and REF devices do not support shared resources. Attempting to create a resource with this flag on either a WARP or REF device will cause the create method to return an E_OUTOFMEMORY error code.	
        /// </summary>	
        /// <unmanaged>D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX</unmanaged>
        SharedKeyedmutex = unchecked((int)256),			
        
        /// <summary>	
        /// Enables a resource compatible with GDI. The D3D11_RESOURCE_MISC_GDI_COMPATIBLE flag is required on surfaces that will be used with GDI. Setting the D3D11_RESOURCE_MISC_GDI_COMPATIBLE flag allows GDI rendering on the surface via GetDC.	
        /// </summary>	
        /// <unmanaged>D3D11_RESOURCE_MISC_GDI_COMPATIBLE</unmanaged>
        GdiCompatible = unchecked((int)512),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Identifies a resource to be accessed for reading and writing by the CPU. Applications may combine one or more of these flags.	
    /// </summary>	
    /// <remarks>	
    /// This enumeration is used in <see cref="SlimDX2.Direct3D11.DeviceContext.Map"/>.These remarks are divided into the following topics:{{Meaning of D3D11_MAP_WRITE_NO_OVERWRITE}}{{Common Usage of D3D11_MAP_WRITE_DISCARD with D3D11_MAP_WRITE_NO_OVERWRITE}}Meaning of D3D11_MAP_WRITE_NO_OVERWRITED3D11_MAP_WRITE_NO_OVERWRITE signifies that the application promises not to write to data that the input assembler (IA) stage is using. In exchange, the GPU allows the application to write to other parts of the same buffer.  The application must ensure that it does not write over any data in use by the IA stage.For example, consider the buffer illustrated in the following diagram. If a Draw call has been issued that uses vertices 4-6, then an application that calls Map on this buffer must ensure that it does not write to the vertices that the Draw call will access during rendering. Diagram of a buffer that includes vertices in different stages of utilization However, ensuring this can be difficult, because the GPU is often many frames behind the CPU in terms of which frame it is currently processing. Keeping track of which sections of a resource are being used because of calls made 2 to 5 frames ago is difficult and error-prone. Because of this, it is recommended that applications only write to the uninitialized portions of a resource when using D3D11_MAP_WRITE_NO_OVERWRITE.Common Usage of D3D11_MAP_WRITE_DISCARD with D3D11_MAP_WRITE_NO_OVERWRITED3D11_MAP_WRITE_DISCARD and D3D11_MAP_WRITE_NO_OVERWRITE are normally used in conjunction with dynamic index/vertex buffers. D3D11_MAP_WRITE_DISCARD can also be used with dynamic textures. However, D3D11_MAP_WRITE_NO_OVERWRITE cannot be used with dynamic textures.A common use of these two flags involves filling dynamic index/vertex buffers with geometry that can be seen from the camera's current position. The first time that data is entered into the buffer on a given frame, Map is called with D3D11_MAP_WRITE_DISCARD; doing so invalidates the previous contents of the buffer. The buffer is then filled with all available data.Subsequent writes to the buffer within the same frame should use D3D11_MAP_WRITE_NO_OVERWRITE. This will enable the CPU to access a resource that is potentially being used by the GPU as long as the restrictions described previously are respected.	
    /// </remarks>	
    /// <unmanaged>D3D11_MAP</unmanaged>
    public enum MapMode : int {	
        
        /// <summary>	
        /// Resource is mapped for reading. The resource must have been created with read access  (see <see cref="SlimDX2.Direct3D11.CpuAccessFlags.Read"/>).	
        /// </summary>	
        /// <unmanaged>D3D11_MAP_READ</unmanaged>
        Read = unchecked((int)1),			
        
        /// <summary>	
        /// Resource is mapped for writing. The resource must have been created with write  access (see <see cref="SlimDX2.Direct3D11.CpuAccessFlags.Write"/>).	
        /// </summary>	
        /// <unmanaged>D3D11_MAP_WRITE</unmanaged>
        Write = unchecked((int)2),			
        
        /// <summary>	
        /// Resource is mapped for reading and writing. The resource must have been created with read and write  access (see {{D3D11_CPU_ACCESS_READ and D3D11_CPU_ACCESS_WRITE}}).	
        /// </summary>	
        /// <unmanaged>D3D11_MAP_READ_WRITE</unmanaged>
        ReadWrite = unchecked((int)3),			
        
        /// <summary>	
        /// Resource is mapped for writing; the previous contents of the resource will be undefined. The resource must have been created with write access  and dynamic usage (See <see cref="SlimDX2.Direct3D11.CpuAccessFlags.Write"/> and <see cref="SlimDX2.Direct3D11.ResourceUsage.Dynamic"/>).	
        /// </summary>	
        /// <unmanaged>D3D11_MAP_WRITE_DISCARD</unmanaged>
        WriteDiscard = unchecked((int)4),			
        
        /// <summary>	
        /// Resource is mapped for writing; the existing contents of the resource cannot be overwritten (see Remarks). This flag is only valid on vertex and  index buffers. The resource must have been created with write access (see <see cref="SlimDX2.Direct3D11.CpuAccessFlags.Write"/>).  Cannot be used on a resource created with the <see cref="SlimDX2.Direct3D11.BindFlags.ConstantBuffer"/> flag.	
        /// </summary>	
        /// <unmanaged>D3D11_MAP_WRITE_NO_OVERWRITE</unmanaged>
        WriteNoOverwrite = unchecked((int)5),			
    }
    
    /// <summary>	
    /// Specifies how the CPU should respond when an application calls the <see cref="SlimDX2.Direct3D11.DeviceContext.Map"/> method on a resource that is being used by the GPU.	
    /// </summary>	
    /// <remarks>	
    /// This enumeration is used by <see cref="SlimDX2.Direct3D11.DeviceContext.Map"/>.D3D11_MAP_FLAG_DO_NOT_WAIT cannot be used with <see cref="SlimDX2.Direct3D11.MapMode.WriteDiscard"/> or {{D3D11_MAP_WRITE_NOOVERWRITE}}.	
    /// </remarks>	
    /// <unmanaged>D3D11_MAP_FLAG</unmanaged>
    [Flags]
    public enum MapFlags : int {	
        
        /// <summary>	
        /// Specifies that <see cref="SlimDX2.Direct3D11.DeviceContext.Map"/> should return DXGI_ERROR_WAS_STILL_DRAWING when the GPU blocks the CPU from accessing a resource. For more information about this error code, see <see cref="SlimDX2.DXGI.DXGIError"/>.	
        /// </summary>	
        /// <unmanaged>D3D11_MAP_FLAG_DO_NOT_WAIT</unmanaged>
        DoNotWait = unchecked((int)1048576),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Option(s) for raising an error to a non-continuable exception.	
    /// </summary>	
    /// <remarks>	
    /// These flags are used by <see cref="SlimDX2.Direct3D11.Device.GetExceptionMode"/> and <see cref="SlimDX2.Direct3D11.Device.SetExceptionMode"/>. Use 0 to indicate no flags; multiple flags can be logically OR'ed together.	
    /// </remarks>	
    /// <unmanaged>D3D11_RAISE_FLAG</unmanaged>
    [Flags]
    public enum RaiseFlags : int {	
        
        /// <summary>	
        /// Raise an internal driver error to a non-continuable exception.	
        /// </summary>	
        /// <unmanaged>D3D11_RAISE_FLAG_DRIVER_INTERNAL_ERROR</unmanaged>
        DriverInternalError = unchecked((int)1),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Specifies the parts of the depth stencil to clear.	
    /// </summary>	
    /// <remarks>	
    /// These flags are used when calling <see cref="SlimDX2.Direct3D11.DeviceContext.ClearDepthStencilView"/>; the flags can be combined with a bitwise OR.	
    /// </remarks>	
    /// <unmanaged>D3D11_CLEAR_FLAG</unmanaged>
    [Flags]
    public enum DepthStencilClearFlags : int {	
        
        /// <summary>	
        /// Clear the depth buffer.	
        /// </summary>	
        /// <unmanaged>D3D11_CLEAR_DEPTH</unmanaged>
        Depth = unchecked((int)1),			
        
        /// <summary>	
        /// Clear the stencil buffer.	
        /// </summary>	
        /// <unmanaged>D3D11_CLEAR_STENCIL</unmanaged>
        Stencil = unchecked((int)2),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Comparison options.	
    /// </summary>	
    /// <remarks>	
    /// A comparison option determines whether how the runtime compares source (new) data against destination (existing) data before storing the new data. The comparison option is declared in a description before an object is created. The API allows you to set a comparison option for a depth-stencil buffer (see <see cref="SlimDX2.Direct3D11.DepthStencilStateDescription"/>), depth-stencil operations (see <see cref="SlimDX2.Direct3D11.DepthStencilOperationDescription"/>), or sampler state (see <see cref="SlimDX2.Direct3D11.SamplerStateDescription"/>).	
    /// </remarks>	
    /// <unmanaged>D3D11_COMPARISON_FUNC</unmanaged>
    public enum ComparisonFunction : int {	
        
        /// <summary>	
        /// Never pass the comparison.	
        /// </summary>	
        /// <unmanaged>D3D11_COMPARISON_NEVER</unmanaged>
        Never = unchecked((int)1),			
        
        /// <summary>	
        /// If the source data is less than the destination data, the comparison passes.	
        /// </summary>	
        /// <unmanaged>D3D11_COMPARISON_LESS</unmanaged>
        Less = unchecked((int)2),			
        
        /// <summary>	
        /// If the source data is equal to the destination data, the comparison passes.	
        /// </summary>	
        /// <unmanaged>D3D11_COMPARISON_EQUAL</unmanaged>
        Equal = unchecked((int)3),			
        
        /// <summary>	
        /// If the source data is less than or equal to the destination data, the comparison passes.	
        /// </summary>	
        /// <unmanaged>D3D11_COMPARISON_LESS_EQUAL</unmanaged>
        LessEqual = unchecked((int)4),			
        
        /// <summary>	
        /// If the source data is greater than the destination data, the comparison passes.	
        /// </summary>	
        /// <unmanaged>D3D11_COMPARISON_GREATER</unmanaged>
        Greater = unchecked((int)5),			
        
        /// <summary>	
        /// If the source data is not equal to the destination data, the comparison passes.	
        /// </summary>	
        /// <unmanaged>D3D11_COMPARISON_NOT_EQUAL</unmanaged>
        NotEqual = unchecked((int)6),			
        
        /// <summary>	
        /// If the source data is greater than or equal to the destination data, the comparison passes.	
        /// </summary>	
        /// <unmanaged>D3D11_COMPARISON_GREATER_EQUAL</unmanaged>
        GreaterEqual = unchecked((int)7),			
        
        /// <summary>	
        /// Always pass the comparison.	
        /// </summary>	
        /// <unmanaged>D3D11_COMPARISON_ALWAYS</unmanaged>
        Always = unchecked((int)8),			
    }
    
    /// <summary>	
    /// Identify the portion of a depth-stencil buffer for writing depth data.	
    /// </summary>	
    /// <unmanaged>D3D11_DEPTH_WRITE_MASK</unmanaged>
    public enum DepthWriteMask : int {	
        
        /// <summary>	
        /// Turn off writes to the depth-stencil buffer.	
        /// </summary>	
        /// <unmanaged>D3D11_DEPTH_WRITE_MASK_ZERO</unmanaged>
        Zero = unchecked((int)0),			
        
        /// <summary>	
        /// Turn on writes to the depth-stencil buffer.	
        /// </summary>	
        /// <unmanaged>D3D11_DEPTH_WRITE_MASK_ALL</unmanaged>
        All = unchecked((int)1),			
    }
    
    /// <summary>	
    /// The stencil operations that can be performed during depth-stencil testing.	
    /// </summary>	
    /// <unmanaged>D3D11_STENCIL_OP</unmanaged>
    public enum StencilOperation : int {	
        
        /// <summary>	
        /// Keep the existing stencil data.	
        /// </summary>	
        /// <unmanaged>D3D11_STENCIL_OP_KEEP</unmanaged>
        Keep = unchecked((int)1),			
        
        /// <summary>	
        /// Set the stencil data to 0.	
        /// </summary>	
        /// <unmanaged>D3D11_STENCIL_OP_ZERO</unmanaged>
        Zero = unchecked((int)2),			
        
        /// <summary>	
        /// Set the stencil data to the reference value set by calling <see cref="SlimDX2.Direct3D11.DeviceContext.OutputMergerStage.SetDepthStencilState"/>.	
        /// </summary>	
        /// <unmanaged>D3D11_STENCIL_OP_REPLACE</unmanaged>
        Replace = unchecked((int)3),			
        
        /// <summary>	
        /// Increment the stencil value by 1, and clamp the result.	
        /// </summary>	
        /// <unmanaged>D3D11_STENCIL_OP_INCR_SAT</unmanaged>
        IncrementSaturate = unchecked((int)4),			
        
        /// <summary>	
        /// Decrement the stencil value by 1, and clamp the result.	
        /// </summary>	
        /// <unmanaged>D3D11_STENCIL_OP_DECR_SAT</unmanaged>
        DecrementSaturate = unchecked((int)5),			
        
        /// <summary>	
        /// Invert the stencil data.	
        /// </summary>	
        /// <unmanaged>D3D11_STENCIL_OP_INVERT</unmanaged>
        Invert = unchecked((int)6),			
        
        /// <summary>	
        /// Increment the stencil value by 1, and wrap the result if necessary.	
        /// </summary>	
        /// <unmanaged>D3D11_STENCIL_OP_INCR</unmanaged>
        Increment = unchecked((int)7),			
        
        /// <summary>	
        /// Increment the stencil value by 1, and wrap the result if necessary.	
        /// </summary>	
        /// <unmanaged>D3D11_STENCIL_OP_DECR</unmanaged>
        Decrement = unchecked((int)8),			
    }
    
    /// <summary>	
    /// Blend options. A blend option identifies the data source and an optional pre-blend operation.	
    /// </summary>	
    /// <remarks>	
    /// Blend operations are specified in a {{blend description}}.	
    /// </remarks>	
    /// <unmanaged>D3D11_BLEND</unmanaged>
    public enum BlendOption : int {	
        
        /// <summary>	
        /// The data source is the color black (0, 0, 0, 0). No pre-blend operation.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_ZERO</unmanaged>
        Zero = unchecked((int)1),			
        
        /// <summary>	
        /// The data source is the color white (1, 1, 1, 1). No pre-blend operation.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_ONE</unmanaged>
        One = unchecked((int)2),			
        
        /// <summary>	
        /// The data source is color data (RGB) from a pixel shader. No pre-blend operation.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_SRC_COLOR</unmanaged>
        SourceColor = unchecked((int)3),			
        
        /// <summary>	
        /// The data source is color data (RGB) from a pixel shader. The pre-blend operation inverts the data, generating 1 - RGB.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_INV_SRC_COLOR</unmanaged>
        InverseSourceColor = unchecked((int)4),			
        
        /// <summary>	
        /// The data source is alpha data (A) from a pixel shader. No pre-blend operation.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_SRC_ALPHA</unmanaged>
        SourceAlpha = unchecked((int)5),			
        
        /// <summary>	
        /// The data source is alpha data (A) from a pixel shader. The pre-blend operation inverts the data, generating 1 - A.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_INV_SRC_ALPHA</unmanaged>
        InverseSourceAlpha = unchecked((int)6),			
        
        /// <summary>	
        /// The data source is alpha data from a rendertarget. No pre-blend operation.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_DEST_ALPHA</unmanaged>
        DestinationAlpha = unchecked((int)7),			
        
        /// <summary>	
        /// The data source is alpha data from a rendertarget. The pre-blend operation inverts the data, generating 1 - A.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_INV_DEST_ALPHA</unmanaged>
        InverseDestinationAlpha = unchecked((int)8),			
        
        /// <summary>	
        /// The data source is color data from a rendertarget. No pre-blend operation.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_DEST_COLOR</unmanaged>
        DestinationColor = unchecked((int)9),			
        
        /// <summary>	
        /// The data source is color data from a rendertarget. The pre-blend operation inverts the data, generating 1 - RGB.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_INV_DEST_COLOR</unmanaged>
        InverseDestinationColor = unchecked((int)10),			
        
        /// <summary>	
        /// The data source is alpha data from a pixel shader. The pre-blend operation clamps the data to 1 or less. 	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_SRC_ALPHA_SAT</unmanaged>
        SourceAlphaSaturate = unchecked((int)11),			
        
        /// <summary>	
        /// The data source is the blend factor set with <see cref="SlimDX2.Direct3D11.DeviceContext.OutputMergerStage.SetBlendState"/>. No pre-blend operation.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_BLEND_FACTOR</unmanaged>
        BlendFactor = unchecked((int)14),			
        
        /// <summary>	
        /// The data source is the blend factor set with <see cref="SlimDX2.Direct3D11.DeviceContext.OutputMergerStage.SetBlendState"/>. The pre-blend operation inverts the blend factor, generating 1 - blend_factor.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_INV_BLEND_FACTOR</unmanaged>
        InverseBlendFactor = unchecked((int)15),			
        
        /// <summary>	
        /// The data sources are both color data output by a pixel shader. There is no pre-blend operation. This options supports dual-source color blending.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_SRC1_COLOR</unmanaged>
        SecondarySourceColor = unchecked((int)16),			
        
        /// <summary>	
        /// The data sources are both color data output by a pixel shader. The pre-blend operation inverts the data, generating 1 - RGB. This options supports dual-source color blending.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_INV_SRC1_COLOR</unmanaged>
        InverseSecondarySourceColor = unchecked((int)17),			
        
        /// <summary>	
        /// The data sources are alpha data output by a pixel shader. There is no pre-blend operation. This options supports dual-source color blending.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_SRC1_ALPHA</unmanaged>
        SecondarySourceAlpha = unchecked((int)18),			
        
        /// <summary>	
        /// The data sources are alpha data output by a pixel shader. The pre-blend operation inverts the data, generating 1 - A. This options supports dual-source color blending.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_INV_SRC1_ALPHA</unmanaged>
        InverseSecondarySourceAlpha = unchecked((int)19),			
    }
    
    /// <summary>	
    /// RGB or alpha blending operation.	
    /// </summary>	
    /// <remarks>	
    /// The runtime implements RGB blending and alpha blending separately. Therefore, blend state requires separate blend operations for RGB data and alpha data. These blend operations are specified in a {{blend description}}. The two sources?Source 1, called SrcBlend and SrcBlendAlpha, and Source 2, called DestBlend and DestBlendAlpha?are shown in the blending block diagram.	
    /// </remarks>	
    /// <unmanaged>D3D11_BLEND_OP</unmanaged>
    public enum BlendOperation : int {	
        
        /// <summary>	
        /// Add source 1 and source 2.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_OP_ADD</unmanaged>
        Add = unchecked((int)1),			
        
        /// <summary>	
        /// Subtract source 1 from source 2.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_OP_SUBTRACT</unmanaged>
        Subtract = unchecked((int)2),			
        
        /// <summary>	
        /// Subtract source 2 from source 1.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_OP_REV_SUBTRACT</unmanaged>
        ReverseSubtract = unchecked((int)3),			
        
        /// <summary>	
        /// Find the minimum of source 1 and source 2.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_OP_MIN</unmanaged>
        Minimum = unchecked((int)4),			
        
        /// <summary>	
        /// Find the maximum of source 1 and source 2.	
        /// </summary>	
        /// <unmanaged>D3D11_BLEND_OP_MAX</unmanaged>
        Maximum = unchecked((int)5),			
    }
    
    /// <summary>	
    /// Identify which components of each pixel of a render target are writable during blending.	
    /// </summary>	
    /// <remarks>	
    /// These flags can be combined with a bitwise OR.	
    /// </remarks>	
    /// <unmanaged>D3D11_COLOR_WRITE_ENABLE</unmanaged>
    [Flags]
    public enum ColorWriteMaskFlags : int {	
        
        /// <summary>	
        /// Allow data to be stored in the red component.	
        /// </summary>	
        /// <unmanaged>D3D11_COLOR_WRITE_ENABLE_RED</unmanaged>
        Red = unchecked((int)1),			
        
        /// <summary>	
        /// Allow data to be stored in the green component.	
        /// </summary>	
        /// <unmanaged>D3D11_COLOR_WRITE_ENABLE_GREEN</unmanaged>
        Green = unchecked((int)2),			
        
        /// <summary>	
        /// Allow data to be stored in the blue component.	
        /// </summary>	
        /// <unmanaged>D3D11_COLOR_WRITE_ENABLE_BLUE</unmanaged>
        Blue = unchecked((int)4),			
        
        /// <summary>	
        /// Allow data to be stored in the alpha component.	
        /// </summary>	
        /// <unmanaged>D3D11_COLOR_WRITE_ENABLE_ALPHA</unmanaged>
        Alpha = unchecked((int)8),			
        
        /// <summary>	
        /// Allow data to be stored in all components.	
        /// </summary>	
        /// <unmanaged>D3D11_COLOR_WRITE_ENABLE_ALL</unmanaged>
        All = unchecked((int)15),			
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// The different faces of a cube texture.	
    /// </summary>	
    /// <unmanaged>D3D11_TEXTURECUBE_FACE</unmanaged>
    public enum TexturecubeFace : int {	
        
        /// <summary>	
        /// Positive X face.	
        /// </summary>	
        /// <unmanaged>D3D11_TEXTURECUBE_FACE_POSITIVE_X</unmanaged>
        PositiveX = unchecked((int)0),			
        
        /// <summary>	
        /// Negative X face.	
        /// </summary>	
        /// <unmanaged>D3D11_TEXTURECUBE_FACE_NEGATIVE_X</unmanaged>
        NegativeX = unchecked((int)1),			
        
        /// <summary>	
        /// Positive Y face.	
        /// </summary>	
        /// <unmanaged>D3D11_TEXTURECUBE_FACE_POSITIVE_Y</unmanaged>
        PositiveY = unchecked((int)2),			
        
        /// <summary>	
        /// Negative Y face.	
        /// </summary>	
        /// <unmanaged>D3D11_TEXTURECUBE_FACE_NEGATIVE_Y</unmanaged>
        NegativeY = unchecked((int)3),			
        
        /// <summary>	
        /// Positive Z face.	
        /// </summary>	
        /// <unmanaged>D3D11_TEXTURECUBE_FACE_POSITIVE_Z</unmanaged>
        PositiveZ = unchecked((int)4),			
        
        /// <summary>	
        /// Negative Z face.	
        /// </summary>	
        /// <unmanaged>D3D11_TEXTURECUBE_FACE_NEGATIVE_Z</unmanaged>
        NegativeZ = unchecked((int)5),			
    }
    
    /// <summary>	
    /// Identifies how to bind a raw-buffer resource to the pipeline.	
    /// </summary>	
    /// <remarks>	
    /// This enumeration is used by <see cref="SlimDX2.Direct3D11.ShaderResourceViewDescription.ExtendedBufferResource"/>	
    /// </remarks>	
    /// <unmanaged>D3D11_BUFFEREX_SRV_FLAG</unmanaged>
    [Flags]
    public enum ExtendedBufferShaderResourceViewFlags : int {	
        
        /// <summary>	
        /// Bind a raw buffer to the input-assembler stage.	
        /// </summary>	
        /// <unmanaged>D3D11_BUFFEREX_SRV_FLAG_RAW</unmanaged>
        Raw = unchecked((int)1),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Depth-stencil view options.	
    /// </summary>	
    /// <remarks>	
    /// This enumeration is used by <see cref="SlimDX2.Direct3D11.DepthStencilViewDescription"/>.Limiting a depth-stencil buffer to read-only access allows more than one depth-stencil view to be bound to the pipeline simultaneously, since it is not possible to have a read/write conflicts between separate views.	
    /// </remarks>	
    /// <unmanaged>D3D11_DSV_FLAG</unmanaged>
    [Flags]
    public enum DepthStencilViewFlags : int {	
        
        /// <summary>	
        /// Indicates that depth values are read only.	
        /// </summary>	
        /// <unmanaged>D3D11_DSV_READ_ONLY_DEPTH</unmanaged>
        ReadOnlyDepth = unchecked((int)1),			
        
        /// <summary>	
        /// Indicates that stencil values are read only.	
        /// </summary>	
        /// <unmanaged>D3D11_DSV_READ_ONLY_STENCIL</unmanaged>
        ReadOnlyStencil = unchecked((int)2),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Unordered-access-view buffer options.	
    /// </summary>	
    /// <unmanaged>D3D11_BUFFER_UAV_FLAG</unmanaged>
    [Flags]
    public enum UnorderedAccessViewBufferFlags : int {	
        
        /// <summary>	
        /// Resource contains raw, unstructured data.  Requires the UAV format to be DXGI_FORMAT_R32_TYPELESS. 	
        /// </summary>	
        /// <unmanaged>D3D11_BUFFER_UAV_FLAG_RAW</unmanaged>
        Raw = unchecked((int)1),			
        
        /// <summary>	
        /// Allow data to be appended to the end of the buffer.  D3D11_BUFFER_UAV_FLAG_APPEND flag must also be used for  any view that will be used as a {{AppendStructuredBuffer}} or a {{ConsumeStructuredBuffer}}.  Requires the UAV format to be DXGI_FORMAT_UNKNOWN.	
        /// </summary>	
        /// <unmanaged>D3D11_BUFFER_UAV_FLAG_APPEND</unmanaged>
        Append = unchecked((int)2),			
        
        /// <summary>	
        /// Adds a counter to the unordered-access-view buffer.  D3D11_BUFFER_UAV_FLAG_COUNTER can only be used on a UAV that is a  {{RWStructuredBuffer}} and it enables the functionality needed for the {{IncrementCounter}} and {{DecrementCounter}} methods in HLSL.  Requires the UAV format to be DXGI_FORMAT_UNKNOWN.	
        /// </summary>	
        /// <unmanaged>D3D11_BUFFER_UAV_FLAG_COUNTER</unmanaged>
        Counter = unchecked((int)4),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Filtering options during texture sampling.	
    /// </summary>	
    /// <remarks>	
    /// During texture sampling, one or more texels are read and combined (this is calling filtering) to produce a single value. Point sampling reads a single texel while linear sampling reads two texels (endpoints) and linearly interpolates a third value between the endpoints.HLSL texture-sampling functions also support comparison filtering during texture sampling. Comparison filtering compares each sampled texel against a comparison value. The boolean result is blended the same way that normal texture filtering is blended.You can use HLSL intrinsic texture-sampling functions that implement texture filtering only or companion functions that use texture filtering with comparison filtering.Texture Sampling FunctionTexture Sampling Function with Comparison Filteringsamplesamplecmp or samplecmplevelzero Comparison filters only work with textures that have the following DXGI formats: R32_FLOAT_X8X24_TYPELESS, R32_FLOAT, R24_UNORM_X8_TYPELESS, R16_UNORM.	
    /// </remarks>	
    /// <unmanaged>D3D11_FILTER</unmanaged>
    public enum Filter : int {	
        
        /// <summary>	
        /// Use point sampling for minification, magnification, and mip-level sampling.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_MIN_MAG_MIP_POINT</unmanaged>
        MinimumMagMipPoint = unchecked((int)0),			
        
        /// <summary>	
        /// Use point sampling for minification and magnification; use linear interpolation for mip-level sampling.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_MIN_MAG_POINT_MIP_LINEAR</unmanaged>
        MinimumMagPointMipLinear = unchecked((int)1),			
        
        /// <summary>	
        /// Use point sampling for minification; use linear interpolation for magnification; use point sampling for mip-level sampling.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT</unmanaged>
        MinimumPointMagLinearMipPoint = unchecked((int)4),			
        
        /// <summary>	
        /// Use point sampling for minification; use linear interpolation for magnification and mip-level sampling.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_MIN_POINT_MAG_MIP_LINEAR</unmanaged>
        MinimumPointMagMipLinear = unchecked((int)5),			
        
        /// <summary>	
        /// Use linear interpolation for minification; use point sampling for magnification and mip-level sampling.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_MIN_LINEAR_MAG_MIP_POINT</unmanaged>
        MinimumLinearMagMipPoint = unchecked((int)16),			
        
        /// <summary>	
        /// Use linear interpolation for minification; use point sampling for magnification; use linear interpolation for mip-level sampling.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR</unmanaged>
        MinimumLinearMagPointMipLinear = unchecked((int)17),			
        
        /// <summary>	
        /// Use linear interpolation for minification and magnification; use point sampling for mip-level sampling.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT</unmanaged>
        MinimumMagLinearMipPoint = unchecked((int)20),			
        
        /// <summary>	
        /// Use linear interpolation for minification, magnification, and mip-level sampling.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_MIN_MAG_MIP_LINEAR</unmanaged>
        MinimumMagMipLinear = unchecked((int)21),			
        
        /// <summary>	
        /// Use anisotropic interpolation for minification, magnification, and mip-level sampling.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_ANISOTROPIC</unmanaged>
        Anisotropic = unchecked((int)85),			
        
        /// <summary>	
        /// Use point sampling for minification, magnification, and mip-level sampling. Compare the result to the comparison value.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_COMPARISON_MIN_MAG_MIP_POINT</unmanaged>
        ComparisonMinimumMagMipPoint = unchecked((int)128),			
        
        /// <summary>	
        /// Use point sampling for minification and magnification; use linear interpolation for mip-level sampling. Compare the result to the comparison value.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR</unmanaged>
        ComparisonMinimumMagPointMipLinear = unchecked((int)129),			
        
        /// <summary>	
        /// Use point sampling for minification; use linear interpolation for magnification; use point sampling for mip-level sampling. Compare the result to the comparison value.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT</unmanaged>
        ComparisonMinimumPointMagLinearMipPoint = unchecked((int)132),			
        
        /// <summary>	
        /// Use point sampling for minification; use linear interpolation for magnification and mip-level sampling. Compare the result to the comparison value.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR</unmanaged>
        ComparisonMinimumPointMagMipLinear = unchecked((int)133),			
        
        /// <summary>	
        /// Use linear interpolation for minification; use point sampling for magnification and mip-level sampling. Compare the result to the comparison value.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT</unmanaged>
        ComparisonMinimumLinearMagMipPoint = unchecked((int)144),			
        
        /// <summary>	
        /// Use linear interpolation for minification; use point sampling for magnification; use linear interpolation for mip-level sampling. Compare the result to the comparison value.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR</unmanaged>
        ComparisonMinimumLinearMagPointMipLinear = unchecked((int)145),			
        
        /// <summary>	
        /// Use linear interpolation for minification and magnification; use point sampling for mip-level sampling. Compare the result to the comparison value.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT</unmanaged>
        ComparisonMinimumMagLinearMipPoint = unchecked((int)148),			
        
        /// <summary>	
        /// Use linear interpolation for minification, magnification, and mip-level sampling. Compare the result to the comparison value.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR</unmanaged>
        ComparisonMinimumMagMipLinear = unchecked((int)149),			
        
        /// <summary>	
        /// Use anisotropic interpolation for minification, magnification, and mip-level sampling. Compare the result to the comparison value.	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_COMPARISON_ANISOTROPIC</unmanaged>
        ComparisonAnisotropic = unchecked((int)213),			
    }
    
    /// <summary>	
    /// Types of magnification or minification sampler filters.	
    /// </summary>	
    /// <unmanaged>D3D11_FILTER_TYPE</unmanaged>
    public enum FilterType : int {	
        
        /// <summary>	
        /// Point filtering used as a texture magnification or minification filter. The texel with coordinates nearest to the desired pixel value is used. The texture filter to be used between mipmap levels is nearest-point mipmap filtering. The rasterizer uses the color from the texel of the nearest mipmap texture. 	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_TYPE_POINT</unmanaged>
        Point = unchecked((int)0),			
        
        /// <summary>	
        /// Bilinear interpolation filtering used as a texture magnification or minification filter. A weighted average of a 2 x 2 area of texels surrounding the desired pixel is used. The texture filter to use between mipmap levels is trilinear mipmap interpolation. The rasterizer linearly interpolates pixel color, using the texels of the two nearest mipmap textures. 	
        /// </summary>	
        /// <unmanaged>D3D11_FILTER_TYPE_LINEAR</unmanaged>
        Linear = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Identify a technique for resolving texture coordinates that are outside of the boundaries of a texture.	
    /// </summary>	
    /// <unmanaged>D3D11_TEXTURE_ADDRESS_MODE</unmanaged>
    public enum TextureAddressMode : int {	
        
        /// <summary>	
        /// Tile the texture at every (u,v) integer junction. For example, for u values between 0 and 3, the texture is repeated three times.	
        /// </summary>	
        /// <unmanaged>D3D11_TEXTURE_ADDRESS_WRAP</unmanaged>
        Wrap = unchecked((int)1),			
        
        /// <summary>	
        /// Flip the texture at every (u,v) integer junction. For u values between 0 and 1, for example, the texture is addressed normally; between 1 and 2, the texture is flipped (mirrored); between 2 and 3, the texture is normal again; and so on. 	
        /// </summary>	
        /// <unmanaged>D3D11_TEXTURE_ADDRESS_MIRROR</unmanaged>
        Mirror = unchecked((int)2),			
        
        /// <summary>	
        /// Texture coordinates outside the range [0.0, 1.0] are set to the texture color at 0.0 or 1.0, respectively.	
        /// </summary>	
        /// <unmanaged>D3D11_TEXTURE_ADDRESS_CLAMP</unmanaged>
        Clamp = unchecked((int)3),			
        
        /// <summary>	
        /// Texture coordinates outside the range [0.0, 1.0] are set to the border color specified in <see cref="SlimDX2.Direct3D11.SamplerStateDescription"/> or HLSL code.	
        /// </summary>	
        /// <unmanaged>D3D11_TEXTURE_ADDRESS_BORDER</unmanaged>
        Border = unchecked((int)4),			
        
        /// <summary>	
        /// Similar to D3D11_TEXTURE_ADDRESS_MIRROR and D3D11_TEXTURE_ADDRESS_CLAMP. Takes the absolute value of the texture coordinate (thus, mirroring around 0), and then clamps to the maximum value.	
        /// </summary>	
        /// <unmanaged>D3D11_TEXTURE_ADDRESS_MIRROR_ONCE</unmanaged>
        MirrorOnce = unchecked((int)5),			
    }
    
    /// <summary>	
    /// Which resources are supported for a given format and given device (see <see cref="SlimDX2.Direct3D11.Device.CheckFormatSupport"/> and <see cref="SlimDX2.Direct3D11.Device.CheckFeatureSupport"/>).	
    /// </summary>	
    /// <unmanaged>D3D11_FORMAT_SUPPORT</unmanaged>
    [Flags]
    public enum FormatSupport : int {	
        
        /// <summary>	
        /// Buffer resources supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_BUFFER</unmanaged>
        Buffer = unchecked((int)1),			
        
        /// <summary>	
        /// Vertex buffers supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_IA_VERTEX_BUFFER</unmanaged>
        InputAssemblyVertexBuffer = unchecked((int)2),			
        
        /// <summary>	
        /// Index buffers supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_IA_INDEX_BUFFER</unmanaged>
        InputAssemblyIndexBuffer = unchecked((int)4),			
        
        /// <summary>	
        /// Streaming output buffers supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_SO_BUFFER</unmanaged>
        StreamOutputBuffer = unchecked((int)8),			
        
        /// <summary>	
        /// 1D texture resources supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_TEXTURE1D</unmanaged>
        Texture1D = unchecked((int)16),			
        
        /// <summary>	
        /// 2D texture resources supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_TEXTURE2D</unmanaged>
        Texture2D = unchecked((int)32),			
        
        /// <summary>	
        /// 3D texture resources supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_TEXTURE3D</unmanaged>
        Texture3D = unchecked((int)64),			
        
        /// <summary>	
        /// Cube texture resources supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_TEXTURECUBE</unmanaged>
        Texturecube = unchecked((int)128),			
        
        /// <summary>	
        /// The intrinsic HLSL function load is supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_SHADER_LOAD</unmanaged>
        ShaderLoad = unchecked((int)256),			
        
        /// <summary>	
        /// The intrinsic HLSL functions sample supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_SHADER_SAMPLE</unmanaged>
        ShaderSample = unchecked((int)512),			
        
        /// <summary>	
        /// The intrinsic HLSL functions samplecmp and samplecmplevelzero are supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_SHADER_SAMPLE_COMPARISON</unmanaged>
        ShaderSampleComparison = unchecked((int)1024),			
        
        /// <summary>	
        /// Reserved.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_SHADER_SAMPLE_MONO_TEXT</unmanaged>
        ShaderSampleMonoText = unchecked((int)2048),			
        
        /// <summary>	
        /// Mipmaps are supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_MIP</unmanaged>
        Mip = unchecked((int)4096),			
        
        /// <summary>	
        /// Automatic generation of mipmaps is supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_MIP_AUTOGEN</unmanaged>
        MipAutogen = unchecked((int)8192),			
        
        /// <summary>	
        /// Rendertargets are supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_RENDER_TARGET</unmanaged>
        RenderTarget = unchecked((int)16384),			
        
        /// <summary>	
        /// Blend operations supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_BLENDABLE</unmanaged>
        Blendable = unchecked((int)32768),			
        
        /// <summary>	
        /// Depth stencils supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_DEPTH_STENCIL</unmanaged>
        DepthStencil = unchecked((int)65536),			
        
        /// <summary>	
        /// CPU locking supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_CPU_LOCKABLE</unmanaged>
        CpuLockable = unchecked((int)131072),			
        
        /// <summary>	
        /// Multisampling resolution supported.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_MULTISAMPLE_RESOLVE</unmanaged>
        MultisampleResolve = unchecked((int)262144),			
        
        /// <summary>	
        /// Format can be displayed on screen.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_DISPLAY</unmanaged>
        Display = unchecked((int)524288),			
        
        /// <summary>	
        /// Format cannot be cast to another format.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_CAST_WITHIN_BIT_LAYOUT</unmanaged>
        CastWithinBitLayout = unchecked((int)1048576),			
        
        /// <summary>	
        /// Format can be used as a multisampled rendertarget.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_MULTISAMPLE_RENDERTARGET</unmanaged>
        MultisampleRendertarget = unchecked((int)2097152),			
        
        /// <summary>	
        /// Format can be used as a multisampled texture and read into a shader with the HLSL load function.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_MULTISAMPLE_LOAD</unmanaged>
        MultisampleLoad = unchecked((int)4194304),			
        
        /// <summary>	
        /// Format can be used with the HLSL gather function. This value is available in DirectX 10.1 or higher.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_SHADER_GATHER</unmanaged>
        ShaderGather = unchecked((int)8388608),			
        
        /// <summary>	
        /// Format supports casting when used the resource is a back buffer.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_BACK_BUFFER_CAST</unmanaged>
        BackBufferCast = unchecked((int)16777216),			
        
        /// <summary>	
        /// Format can be used for an unordered access view.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_TYPED_UNORDERED_ACCESS_VIEW</unmanaged>
        TypedUnorderedAccessView = unchecked((int)33554432),			
        
        /// <summary>	
        /// Format can be used with the HLSL gather with comparison function.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT_SHADER_GATHER_COMPARISON</unmanaged>
        ShaderGatherComparison = unchecked((int)67108864),			
    }
    
    /// <summary>	
    /// Unordered resource support options for a compute shader resource (see <see cref="SlimDX2.Direct3D11.Device.CheckFeatureSupport"/>).	
    /// </summary>	
    /// <unmanaged>D3D11_FORMAT_SUPPORT2</unmanaged>
    [Flags]
    public enum ComputeShaderFormatSupport : int {	
        
        /// <summary>	
        /// Format supports atomic add.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_ADD</unmanaged>
        AtomicAdd = unchecked((int)1),			
        
        /// <summary>	
        /// Format supports atomic bitwise operations.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_BITWISE_OPS</unmanaged>
        AtomicBitwiseOps = unchecked((int)2),			
        
        /// <summary>	
        /// Format supports atomic compare with store or exchange.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_COMPARE_STORE_OR_COMPARE_EXCHANGE</unmanaged>
        AtomicCompareStoreOrCompareExchange = unchecked((int)4),			
        
        /// <summary>	
        /// Format supports atomic exchange.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_EXCHANGE</unmanaged>
        AtomicExchange = unchecked((int)8),			
        
        /// <summary>	
        /// Format supports atomic min and max.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_SIGNED_MIN_OR_MAX</unmanaged>
        AtomicSignedMinimumOrMaximum = unchecked((int)16),			
        
        /// <summary>	
        /// Format supports atomic unsigned min and max.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_UNSIGNED_MIN_OR_MAX</unmanaged>
        AtomicUnsignedMinimumOrMaximum = unchecked((int)32),			
        
        /// <summary>	
        /// Format supports a typed load.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT2_UAV_TYPED_LOAD</unmanaged>
        TypedLoad = unchecked((int)64),			
        
        /// <summary>	
        /// Format supports a typed store.	
        /// </summary>	
        /// <unmanaged>D3D11_FORMAT_SUPPORT2_UAV_TYPED_STORE</unmanaged>
        TypedStore = unchecked((int)128),			
    }
    
    /// <summary>	
    /// Optional flags that control the behavior of {{ID3D11Asynchronous::GetData}}.	
    /// </summary>	
    /// <unmanaged>D3D11_ASYNC_GETDATA_FLAG</unmanaged>
    [Flags]
    public enum AsynchronousFlags : int {	
        
        /// <summary>	
        /// Do not flush the command buffer. This can potentially cause an infinite loop if GetData is continually called until it returns S_OK as there may still be commands in the command buffer that need to be processed in order for GetData to return S_OK. Since the commands in the command buffer are not flushed they will not be processed and therefore GetData will never return S_OK.	
        /// </summary>	
        /// <unmanaged>D3D11_ASYNC_GETDATA_DONOTFLUSH</unmanaged>
        DoNotFlush = unchecked((int)1),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    ///  Query types.	
    /// </summary>	
    /// <unmanaged>D3D11_QUERY</unmanaged>
    public enum QueryType : int {	
        
        /// <summary>	
        ///  Determines whether or not the GPU is finished processing commands. When the GPU is finished processing commands <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> will return S_OK, and pData will point to a BOOL with a value of TRUE. When using this type of query, <see cref="SlimDX2.Direct3D11.DeviceContext.Begin"/> is disabled. 	
        /// </summary>	
        /// <unmanaged>D3D11_QUERY_EVENT</unmanaged>
        Event = unchecked((int)0),			
        
        /// <summary>	
        ///  Get the number of samples that passed the depth and stencil tests in between <see cref="SlimDX2.Direct3D11.DeviceContext.Begin"/> and <see cref="SlimDX2.Direct3D11.DeviceContext.End"/>. <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> returns a UINT64. If a depth or stencil test is disabled, then each of those tests will be counted as a pass. 	
        /// </summary>	
        /// <unmanaged>D3D11_QUERY_OCCLUSION</unmanaged>
        Occlusion = unchecked((int)1),			
        
        /// <summary>	
        ///  Get a timestamp value where <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> returns a UINT64. This kind of query is only useful if two timestamp queries are done in the middle of a D3D11_QUERY_TIMESTAMP_DISJOINT query. The difference of two timestamps can be used to determine how many ticks have elapsed, and the D3D11_QUERY_TIMESTAMP_DISJOINT query will determine if that difference is a reliable value and also has a value that shows how to convert the number of ticks into seconds. See <see cref="SlimDX2.Direct3D11.QueryDataTimestampDisjoint"/>. When using this type of query, <see cref="SlimDX2.Direct3D11.DeviceContext.Begin"/> is disabled. 	
        /// </summary>	
        /// <unmanaged>D3D11_QUERY_TIMESTAMP</unmanaged>
        Timestamp = unchecked((int)2),			
        
        /// <summary>	
        ///  Determines whether or not a D3D11_QUERY_TIMESTAMP is returning reliable values, and also gives the frequency of the processor enabling you to convert the number of elapsed ticks into seconds. <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> will return a <see cref="SlimDX2.Direct3D11.QueryDataTimestampDisjoint"/>. This type of query should only be invoked once per frame or less. 	
        /// </summary>	
        /// <unmanaged>D3D11_QUERY_TIMESTAMP_DISJOINT</unmanaged>
        TimestampDisjoint = unchecked((int)3),			
        
        /// <summary>	
        ///  Get pipeline statistics, such as the number of pixel shader invocations in between <see cref="SlimDX2.Direct3D11.DeviceContext.Begin"/> and <see cref="SlimDX2.Direct3D11.DeviceContext.End"/>. <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> will return a <see cref="SlimDX2.Direct3D11.QueryDataPipelineStatistics"/>. 	
        /// </summary>	
        /// <unmanaged>D3D11_QUERY_PIPELINE_STATISTICS</unmanaged>
        PipelineStatistics = unchecked((int)4),			
        
        /// <summary>	
        ///  Similar to D3D11_QUERY_OCCLUSION, except <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> returns a BOOL indicating whether or not any samples passed the depth and stencil tests - TRUE meaning at least one passed, FALSE meaning none passed. 	
        /// </summary>	
        /// <unmanaged>D3D11_QUERY_OCCLUSION_PREDICATE</unmanaged>
        OcclusionPredicate = unchecked((int)5),			
        
        /// <summary>	
        ///  Get streaming output statistics, such as the number of primitives streamed out in between <see cref="SlimDX2.Direct3D11.DeviceContext.Begin"/> and <see cref="SlimDX2.Direct3D11.DeviceContext.End"/>. <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> will return a <see cref="SlimDX2.Direct3D11.StreamOutputStatistics"/> structure. 	
        /// </summary>	
        /// <unmanaged>D3D11_QUERY_SO_STATISTICS</unmanaged>
        StreamOutputStatistics = unchecked((int)6),			
        
        /// <summary>	
        ///  Determines whether or not any of the streaming output buffers overflowed in between <see cref="SlimDX2.Direct3D11.DeviceContext.Begin"/> and <see cref="SlimDX2.Direct3D11.DeviceContext.End"/>. <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> returns a BOOL - TRUE meaning there was an overflow, FALSE meaning there was not an overflow. If streaming output writes to multiple buffers, and one of the buffers overflows, then it will stop writing to all the output buffers. When an overflow is detected by Direct3D it is prevented from happening - no memory is corrupted. This predication may be used in conjunction with an SO_STATISTICS query so that when an overflow occurs the SO_STATISTIC query will let the application know how much memory was needed to prevent an overflow. 	
        /// </summary>	
        /// <unmanaged>D3D11_QUERY_SO_OVERFLOW_PREDICATE</unmanaged>
        StreamOutputOverflowPredicate = unchecked((int)7),			
        
        /// <summary>	
        ///  Get streaming output statistics for stream 0, such as the number of primitives streamed out in between <see cref="SlimDX2.Direct3D11.DeviceContext.Begin"/> and <see cref="SlimDX2.Direct3D11.DeviceContext.End"/>. <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> will return a <see cref="SlimDX2.Direct3D11.StreamOutputStatistics"/> structure. 	
        /// </summary>	
        /// <unmanaged>D3D11_QUERY_SO_STATISTICS_STREAM0</unmanaged>
        StreamOutputStatisticsStream0 = unchecked((int)8),			
        
        /// <summary>	
        ///  Determines whether or not the stream 0 output buffers overflowed in between <see cref="SlimDX2.Direct3D11.DeviceContext.Begin"/> and <see cref="SlimDX2.Direct3D11.DeviceContext.End"/>. <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> returns a BOOL - TRUE meaning there was an overflow, FALSE meaning there was not an overflow. If streaming output writes to multiple buffers, and one of the buffers overflows, then it will stop writing to all the output buffers. When an overflow is detected by Direct3D it is prevented from happening - no memory is corrupted. This predication may be used in conjunction with an SO_STATISTICS query so that when an overflow occurs the SO_STATISTIC query will let the application know how much memory was needed to prevent an overflow. 	
        /// </summary>	
        /// <unmanaged>D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM0</unmanaged>
        StreamOutputOverflowPredicateStream0 = unchecked((int)9),			
        
        /// <summary>	
        ///  Get streaming output statistics for stream 1, such as the number of primitives streamed out in between <see cref="SlimDX2.Direct3D11.DeviceContext.Begin"/> and <see cref="SlimDX2.Direct3D11.DeviceContext.End"/>. <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> will return a <see cref="SlimDX2.Direct3D11.StreamOutputStatistics"/> structure. 	
        /// </summary>	
        /// <unmanaged>D3D11_QUERY_SO_STATISTICS_STREAM1</unmanaged>
        StreamOutputStatisticsStream1 = unchecked((int)10),			
        
        /// <summary>	
        ///  Determines whether or not the stream 1 output buffers overflowed in between <see cref="SlimDX2.Direct3D11.DeviceContext.Begin"/> and <see cref="SlimDX2.Direct3D11.DeviceContext.End"/>. <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> returns a BOOL - TRUE meaning there was an overflow, FALSE meaning there was not an overflow. If streaming output writes to multiple buffers, and one of the buffers overflows, then it will stop writing to all the output buffers. When an overflow is detected by Direct3D it is prevented from happening - no memory is corrupted. This predication may be used in conjunction with an SO_STATISTICS query so that when an overflow occurs the SO_STATISTIC query will let the application know how much memory was needed to prevent an overflow. 	
        /// </summary>	
        /// <unmanaged>D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM1</unmanaged>
        StreamOutputOverflowPredicateStream1 = unchecked((int)11),			
        
        /// <summary>	
        ///  Get streaming output statistics for stream 2, such as the number of primitives streamed out in between <see cref="SlimDX2.Direct3D11.DeviceContext.Begin"/> and <see cref="SlimDX2.Direct3D11.DeviceContext.End"/>. <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> will return a <see cref="SlimDX2.Direct3D11.StreamOutputStatistics"/> structure. 	
        /// </summary>	
        /// <unmanaged>D3D11_QUERY_SO_STATISTICS_STREAM2</unmanaged>
        StreamOutputStatisticsStream2 = unchecked((int)12),			
        
        /// <summary>	
        ///  Determines whether or not the stream 2 output buffers overflowed in between <see cref="SlimDX2.Direct3D11.DeviceContext.Begin"/> and <see cref="SlimDX2.Direct3D11.DeviceContext.End"/>. <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> returns a BOOL - TRUE meaning there was an overflow, FALSE meaning there was not an overflow. If streaming output writes to multiple buffers, and one of the buffers overflows, then it will stop writing to all the output buffers. When an overflow is detected by Direct3D it is prevented from happening - no memory is corrupted. This predication may be used in conjunction with an SO_STATISTICS query so that when an overflow occurs the SO_STATISTIC query will let the application know how much memory was needed to prevent an overflow. 	
        /// </summary>	
        /// <unmanaged>D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM2</unmanaged>
        StreamOutputOverflowPredicateStream2 = unchecked((int)13),			
        
        /// <summary>	
        ///  Get streaming output statistics for stream 3, such as the number of primitives streamed out in between <see cref="SlimDX2.Direct3D11.DeviceContext.Begin"/> and <see cref="SlimDX2.Direct3D11.DeviceContext.End"/>. <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> will return a <see cref="SlimDX2.Direct3D11.StreamOutputStatistics"/> structure. 	
        /// </summary>	
        /// <unmanaged>D3D11_QUERY_SO_STATISTICS_STREAM3</unmanaged>
        StreamOutputStatisticsStream3 = unchecked((int)14),			
        
        /// <summary>	
        ///  Determines whether or not the stream 3 output buffers overflowed in between <see cref="SlimDX2.Direct3D11.DeviceContext.Begin"/> and <see cref="SlimDX2.Direct3D11.DeviceContext.End"/>. <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> returns a BOOL - TRUE meaning there was an overflow, FALSE meaning there was not an overflow. If streaming output writes to multiple buffers, and one of the buffers overflows, then it will stop writing to all the output buffers. When an overflow is detected by Direct3D it is prevented from happening - no memory is corrupted. This predication may be used in conjunction with an SO_STATISTICS query so that when an overflow occurs the SO_STATISTIC query will let the application know how much memory was needed to prevent an overflow. 	
        /// </summary>	
        /// <unmanaged>D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM3</unmanaged>
        StreamOutputOverflowPredicateStream3 = unchecked((int)15),			
    }
    
    /// <summary>	
    /// Flags that describe miscellaneous query behavior.	
    /// </summary>	
    /// <remarks>	
    /// This flag is part of a query description (see <see cref="SlimDX2.Direct3D11.QueryDescription"/>).	
    /// </remarks>	
    /// <unmanaged>D3D11_QUERY_MISC_FLAG</unmanaged>
    [Flags]
    public enum QueryFlags : int {	
        
        /// <summary>	
        /// Tell the hardware that if it is not yet sure if something is hidden or not to draw it anyway. This is only used with an occlusion predicate. Predication data cannot be returned to your application via <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> when using this flag.	
        /// </summary>	
        /// <unmanaged>D3D11_QUERY_MISC_PREDICATEHINT</unmanaged>
        Predicatehint = unchecked((int)1),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Options for performance counters.	
    /// </summary>	
    /// <remarks>	
    /// Independent hardware vendors may define their own set of performance counters for their devices, by giving the enumeration value a number that is greater than the value for D3D11_COUNTER_DEVICE_DEPENDENT_0.This enumeration is used by <see cref="SlimDX2.Direct3D11.CounterDescription"/> and <see cref="SlimDX2.Direct3D11.CounterInformation"/>.	
    /// </remarks>	
    /// <unmanaged>D3D11_COUNTER</unmanaged>
    public enum CounterKind : int {	
        
        /// <summary>	
        /// Define a performance counter that is dependent on the hardware device.	
        /// </summary>	
        /// <unmanaged>D3D11_COUNTER_DEVICE_DEPENDENT_0</unmanaged>
        DeviceDependent0 = unchecked((int)1073741824),			
    }
    
    /// <summary>	
    /// Data type of a performance counter.	
    /// </summary>	
    /// <remarks>	
    /// These flags are an output parameter in <see cref="SlimDX2.Direct3D11.Device.CheckCounter"/>.	
    /// </remarks>	
    /// <unmanaged>D3D11_COUNTER_TYPE</unmanaged>
    public enum CounterType : int {	
        
        /// <summary>	
        /// 32-bit floating point.	
        /// </summary>	
        /// <unmanaged>D3D11_COUNTER_TYPE_FLOAT32</unmanaged>
        Float32 = unchecked((int)0),			
        
        /// <summary>	
        /// 16-bit unsigned integer.	
        /// </summary>	
        /// <unmanaged>D3D11_COUNTER_TYPE_UINT16</unmanaged>
        Uint16 = unchecked((int)1),			
        
        /// <summary>	
        /// 32-bit unsigned integer.	
        /// </summary>	
        /// <unmanaged>D3D11_COUNTER_TYPE_UINT32</unmanaged>
        Uint32 = unchecked((int)2),			
        
        /// <summary>	
        /// 64-bit unsigned integer.	
        /// </summary>	
        /// <unmanaged>D3D11_COUNTER_TYPE_UINT64</unmanaged>
        Uint64 = unchecked((int)3),			
    }
    
    /// <summary>	
    /// Specifies a multi-sample pattern type.	
    /// </summary>	
    /// <unmanaged>D3D11_STANDARD_MULTISAMPLE_QUALITY_LEVELS</unmanaged>
    public enum StandardMultisampleQualityLevels : int {	
        
        /// <summary>	
        /// Pre-defined multi-sample patterns required for DX11 and DX10.1 hardware.	
        /// </summary>	
        /// <unmanaged>D3D11_STANDARD_MULTISAMPLE_PATTERN</unmanaged>
        StandardMultisamplePattern = unchecked((int)4294967295),			
        
        /// <summary>	
        /// Pattern where all of the samples are located at the pixel center.	
        /// </summary>	
        /// <unmanaged>D3D11_CENTER_MULTISAMPLE_PATTERN</unmanaged>
        CenterMultisamplePattern = unchecked((int)4294967294),			
    }
    
    /// <summary>	
    /// Device context options.	
    /// </summary>	
    /// <remarks>	
    /// This enumeration is used by <see cref="SlimDX2.Direct3D11.DeviceContext.GetTypeInfo"/>.	
    /// </remarks>	
    /// <unmanaged>D3D11_DEVICE_CONTEXT_TYPE</unmanaged>
    public enum DeviceContextType : int {	
        
        /// <summary>	
        /// The device context is an immediate context.	
        /// </summary>	
        /// <unmanaged>D3D11_DEVICE_CONTEXT_IMMEDIATE</unmanaged>
        Immediate = unchecked((int)0),			
        
        /// <summary>	
        /// The device context is a deferred context.	
        /// </summary>	
        /// <unmanaged>D3D11_DEVICE_CONTEXT_DEFERRED</unmanaged>
        Deferred = unchecked((int)1),			
    }
    
    /// <summary>	
    /// Direct3D 11 feature options.	
    /// </summary>	
    /// <remarks>	
    /// This enumeration is used when querying a driver about support for these features by calling <see cref="SlimDX2.Direct3D11.Device.CheckFeatureSupport"/>.   Each value in this enumeration has a corresponding data structure that is required to be passed to the pFeatureSupportData parameter  of ID3D11Device::CheckFeatureSupport.The following table shows the structures associated with each enumerant.EnumerantAssociated StructureD3D11_FEATURE_THREADING<see cref="SlimDX2.Direct3D11.FeatureDataThreading"/>D3D11_FEATURE_DOUBLES<see cref="SlimDX2.Direct3D11.FeatureDataDoubles"/>D3D11_FEATURE_FORMAT_SUPPORT<see cref="SlimDX2.Direct3D11.FeatureDataFormatSupport"/>D3D11_FEATURE_FORMAT_SUPPORT2<see cref="SlimDX2.Direct3D11.FeatureDataFormatSupport2"/>D3D11_FEATURE_D3D10_X_HARDWARE_OPTIONS<see cref="SlimDX2.Direct3D11.FeatureDataXHardwareOptions"/> 	
    /// </remarks>	
    /// <unmanaged>D3D11_FEATURE</unmanaged>
    public enum Feature : int {	
        
        /// <summary>	
        /// The driver supports {{multithreading}}.  To see an example of testing a driver for multithread support, see {{How To: Check for Driver Support}}.	
        /// </summary>	
        /// <unmanaged>D3D11_FEATURE_THREADING</unmanaged>
        Threading = unchecked((int)0),			
        
        /// <summary>	
        /// Supports the use of the  doubles type in HLSL.	
        /// </summary>	
        /// <unmanaged>D3D11_FEATURE_DOUBLES</unmanaged>
        ShaderDoubles = unchecked((int)1),			
        
        /// <summary>	
        /// Supports the formats in <see cref="SlimDX2.Direct3D11.FormatSupport"/>.	
        /// </summary>	
        /// <unmanaged>D3D11_FEATURE_FORMAT_SUPPORT</unmanaged>
        FormatSupport = unchecked((int)2),			
        
        /// <summary>	
        /// Supports the formats in <see cref="SlimDX2.Direct3D11.ComputeShaderFormatSupport"/>.	
        /// </summary>	
        /// <unmanaged>D3D11_FEATURE_FORMAT_SUPPORT2</unmanaged>
        ComputeShaders = unchecked((int)3),			
        
        /// <summary>	
        /// Supports compute shaders and raw and structured buffers.	
        /// </summary>	
        /// <unmanaged>D3D11_FEATURE_D3D10_X_HARDWARE_OPTIONS</unmanaged>
        XHardwareOptions = unchecked((int)4),			
    }
    
    /// <summary>	
    /// Describes parameters that are used to create a device.	
    /// </summary>	
    /// <remarks>	
    /// Device creation flags are used by <see cref="SlimDX2.Direct3D11.D3D11.CreateDevice"/> and <see cref="SlimDX2.Direct3D11.D3D11.CreateDeviceAndSwapChain"/>.An application might dynamically create (and destroy) threads to improve performance especially on a machine with multiple CPU cores. There may be cases, however, when an application needs to prevent extra threads from being created. This can happen when you want to simplify debugging, profile code or develop a tool for instance. For these cases, use D3D11_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS to request that the runtime and video driver not create any additional threads that might interfere with the application.	
    /// </remarks>	
    /// <unmanaged>D3D11_CREATE_DEVICE_FLAG</unmanaged>
    [Flags]
    public enum DeviceCreationFlags : int {	
        
        /// <summary>	
        /// You should use this flag if your application will only call methods of Direct3D 11 interfaces from a single thread. By default, the <see cref="SlimDX2.Direct3D11.Device"/> object is  {{thread-safe}}.  By using this flag, you can increase performance. However, if you use this flag and your application calls methods of Direct3D 11 interfaces from multiple threads, undefined behavior might result.	
        /// </summary>	
        /// <unmanaged>D3D11_CREATE_DEVICE_SINGLETHREADED</unmanaged>
        Singlethreaded = unchecked((int)1),			
        
        /// <summary>	
        /// Creates a device that supports the debug layer.	
        /// </summary>	
        /// <unmanaged>D3D11_CREATE_DEVICE_DEBUG</unmanaged>
        Debug = unchecked((int)2),			
        
        /// <summary>	
        /// Note This flag is not supported in Direct3D 11.	
        /// </summary>	
        /// <unmanaged>D3D11_CREATE_DEVICE_SWITCH_TO_REF</unmanaged>
        SwitchToRef = unchecked((int)4),			
        
        /// <summary>	
        /// Prevents multiple threads from being created. When this flag is used with a WARP device, no additional threads will be created by WARP  and all rasterization will occur on the calling thread. This flag is not recommended for general use. See remarks.	
        /// </summary>	
        /// <unmanaged>D3D11_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS</unmanaged>
        PreventInternalThreadingOptimizations = unchecked((int)8),			
        
        /// <summary>	
        /// Required for Direct2D interoperability with Direct3D resources.	
        /// </summary>	
        /// <unmanaged>D3D11_CREATE_DEVICE_BGRA_SUPPORT</unmanaged>
        BgraSupport = unchecked((int)32),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Texture filtering flags.	
    /// </summary>	
    /// <remarks>	
    /// D3DX11 automatically performs gamma correction (to convert color data from RGB space to standard RGB space) when loading texture data. This is automatically done for instance when RGB data is loaded from a .png file into an sRGB texture. Use the SRGB filter flags to indicate if the data does not need to be converted into sRGB space.	
    /// </remarks>	
    /// <unmanaged>D3DX11_FILTER_FLAG</unmanaged>
    [Flags]
    public enum FilterFlags : int {	
        
        /// <summary>	
        /// No scaling or filtering will take place. Pixels outside the bounds of the source image are assumed to be transparent black.	
        /// </summary>	
        /// <unmanaged>D3DX11_FILTER_NONE</unmanaged>
        None = unchecked((int)1),			
        
        /// <summary>	
        /// Each destination pixel is computed by sampling the nearest pixel from the source image.	
        /// </summary>	
        /// <unmanaged>D3DX11_FILTER_POINT</unmanaged>
        Point = unchecked((int)2),			
        
        /// <summary>	
        /// Each destination pixel is computed by sampling the four nearest pixels from the source image. This filter works best when the scale on both axes is less than two.	
        /// </summary>	
        /// <unmanaged>D3DX11_FILTER_LINEAR</unmanaged>
        Linear = unchecked((int)3),			
        
        /// <summary>	
        /// Every pixel in the source image contributes equally to the destination image. This is the slowest of the filters.	
        /// </summary>	
        /// <unmanaged>D3DX11_FILTER_TRIANGLE</unmanaged>
        Triangle = unchecked((int)4),			
        
        /// <summary>	
        /// Each pixel is computed by averaging a 2x2(x2) box of pixels from the source image. This filter works only when the dimensions of the destination are half those of the source, as is the case with mipmaps.	
        /// </summary>	
        /// <unmanaged>D3DX11_FILTER_BOX</unmanaged>
        Box = unchecked((int)5),			
        
        /// <summary>	
        /// Pixels off the edge of the texture on the u-axis should be mirrored, not wrapped.	
        /// </summary>	
        /// <unmanaged>D3DX11_FILTER_MIRROR_U</unmanaged>
        MirrorU = unchecked((int)65536),			
        
        /// <summary>	
        /// Pixels off the edge of the texture on the v-axis should be mirrored, not wrapped.	
        /// </summary>	
        /// <unmanaged>D3DX11_FILTER_MIRROR_V</unmanaged>
        MirrorV = unchecked((int)131072),			
        
        /// <summary>	
        /// Pixels off the edge of the texture on the w-axis should be mirrored, not wrapped.	
        /// </summary>	
        /// <unmanaged>D3DX11_FILTER_MIRROR_W</unmanaged>
        MirrorW = unchecked((int)262144),			
        
        /// <summary>	
        /// Specifying this flag is the same as specifying the D3DX_FILTER_MIRROR_U, D3DX_FILTER_MIRROR_V, and D3DX_FILTER_MIRROR_W flags.	
        /// </summary>	
        /// <unmanaged>D3DX11_FILTER_MIRROR</unmanaged>
        Mirror = unchecked((int)458752),			
        
        /// <summary>	
        /// The resulting image must be dithered using a 4x4 ordered dither algorithm. This happens when converting from one format to another.	
        /// </summary>	
        /// <unmanaged>D3DX11_FILTER_DITHER</unmanaged>
        Dither = unchecked((int)524288),			
        
        /// <summary>	
        /// Do diffuse dithering on the image when changing from one format to another.	
        /// </summary>	
        /// <unmanaged>D3DX11_FILTER_DITHER_DIFFUSION</unmanaged>
        DitherDiffusion = unchecked((int)1048576),			
        
        /// <summary>	
        /// Input data is in standard RGB (sRGB) color space. See remarks.	
        /// </summary>	
        /// <unmanaged>D3DX11_FILTER_SRGB_IN</unmanaged>
        SRgbIn = unchecked((int)2097152),			
        
        /// <summary>	
        /// Output data is in standard RGB (sRGB) color space. See remarks.	
        /// </summary>	
        /// <unmanaged>D3DX11_FILTER_SRGB_OUT</unmanaged>
        SRgbOut = unchecked((int)4194304),			
        
        /// <summary>	
        /// Same as specifying D3DX_FILTER_SRGB_IN | D3DX_FILTER_SRGB_OUT. See remarks.	
        /// </summary>	
        /// <unmanaged>D3DX11_FILTER_SRGB</unmanaged>
        SRgb = unchecked((int)6291456),			
    }
    
    /// <summary>	
    /// Normal map options. Any number of these flags may be OR'd together in any combination.	
    /// </summary>	
    /// <remarks>	
    /// These flags are used by <see cref="SlimDX2.Direct3D11.D3DX11.ComputeNormalMap"/>.	
    /// </remarks>	
    /// <unmanaged>D3DX11_NORMALMAP_FLAG</unmanaged>
    [Flags]
    public enum NormalMapFlags : int {	
        
        /// <summary>	
        /// Indicates that pixels off the edge of the texture on the U-axis should be mirrored, not wraped.	
        /// </summary>	
        /// <unmanaged>D3DX11_NORMALMAP_MIRROR_U</unmanaged>
        MirrorU = unchecked((int)65536),			
        
        /// <summary>	
        /// Indicates that pixels off the edge of the texture on the V-axis should be mirrored, not wraped.	
        /// </summary>	
        /// <unmanaged>D3DX11_NORMALMAP_MIRROR_V</unmanaged>
        MirrorV = unchecked((int)131072),			
        
        /// <summary>	
        /// Same as D3DX11_NORMALMAP_MIRROR_U | D3DX11_NORMALMAP_MIRROR_V.	
        /// </summary>	
        /// <unmanaged>D3DX11_NORMALMAP_MIRROR</unmanaged>
        Mirror = unchecked((int)196608),			
        
        /// <summary>	
        /// Inverts the direction of each normal.	
        /// </summary>	
        /// <unmanaged>D3DX11_NORMALMAP_INVERTSIGN</unmanaged>
        Invertsign = unchecked((int)524288),			
        
        /// <summary>	
        /// Computes the per pixel occlusion term and encodes it into the alpha. An Alpha of 1 means that the pixel is not obscured in any way, and an alpha of 0 would mean that the pixel is completly obscured.	
        /// </summary>	
        /// <unmanaged>D3DX11_NORMALMAP_COMPUTE_OCCLUSION</unmanaged>
        ComputeOcclusion = unchecked((int)1048576),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// These flags are used by functions which operate on one or more channels in a texture.	
    /// </summary>	
    /// <unmanaged>D3DX11_CHANNEL_FLAG</unmanaged>
    [Flags]
    public enum ChannelFlags : int {	
        
        /// <summary>	
        /// Indicates the red channel should be used.	
        /// </summary>	
        /// <unmanaged>D3DX11_CHANNEL_RED</unmanaged>
        Red = unchecked((int)1),			
        
        /// <summary>	
        /// Indicates the blue channel should be used.	
        /// </summary>	
        /// <unmanaged>D3DX11_CHANNEL_BLUE</unmanaged>
        Blue = unchecked((int)2),			
        
        /// <summary>	
        /// Indicates the green channel should be used.	
        /// </summary>	
        /// <unmanaged>D3DX11_CHANNEL_GREEN</unmanaged>
        Green = unchecked((int)4),			
        
        /// <summary>	
        /// Indicates the alpha channel should be used.	
        /// </summary>	
        /// <unmanaged>D3DX11_CHANNEL_ALPHA</unmanaged>
        Alpha = unchecked((int)8),			
        
        /// <summary>	
        /// Indicates the luminaces of the red, green, and blue channels should be used.	
        /// </summary>	
        /// <unmanaged>D3DX11_CHANNEL_LUMINANCE</unmanaged>
        Luminance = unchecked((int)16),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
    
    /// <summary>	
    /// Image file formats supported by D3DX11Createxxx and D3DX11Savexxx functions.	
    /// </summary>	
    /// <remarks>	
    /// See {{Types of Bitmaps (GDI+)}} for more information on some of these formats.	
    /// </remarks>	
    /// <unmanaged>D3DX11_IMAGE_FILE_FORMAT</unmanaged>
    public enum ImageFileFormat : int {	
        
        /// <summary>	
        /// Windows bitmap (BMP) file format. Contains a header that describes the resolution of the device on which the rectangle of pixels was created, the dimensions of the rectangle, the size of the array of bits, a logical palette, and an array of bits that defines the relationship between pixels in the bitmapped image and entries in the logical palette.	
        /// </summary>	
        /// <unmanaged>D3DX11_IFF_BMP</unmanaged>
        Bmp = unchecked((int)0),			
        
        /// <summary>	
        /// Joint Photographic Experts Group (JPEG) compressed file format. Specifies variable compression of 24-bit RGB color and 8-bit gray-scale Tagged Image File Format (TIFF) image document files.	
        /// </summary>	
        /// <unmanaged>D3DX11_IFF_JPG</unmanaged>
        Jpg = unchecked((int)1),			
        
        /// <summary>	
        /// Portable Network Graphics (PNG) file format. A non-proprietary bitmap format using lossless compression.	
        /// </summary>	
        /// <unmanaged>D3DX11_IFF_PNG</unmanaged>
        Png = unchecked((int)3),			
        
        /// <summary>	
        /// DirectDraw surface (DDS) file format. Stores textures, volume textures, and cubic environment maps, with or without mipmap levels, and with or without pixel compression.	
        /// </summary>	
        /// <unmanaged>D3DX11_IFF_DDS</unmanaged>
        Dds = unchecked((int)4),			
        
        /// <summary>	
        /// Tagged Image File Format (TIFF).	
        /// </summary>	
        /// <unmanaged>D3DX11_IFF_TIFF</unmanaged>
        Tiff = unchecked((int)10),			
        
        /// <summary>	
        /// Graphics Interchange Format (GIF).	
        /// </summary>	
        /// <unmanaged>D3DX11_IFF_GIF</unmanaged>
        Gif = unchecked((int)11),			
        
        /// <summary>	
        /// Windows Media Player format (WMP).	
        /// </summary>	
        /// <unmanaged>D3DX11_IFF_WMP</unmanaged>
        Wmp = unchecked((int)12),			
    }
    
    /// <summary>	
    /// Texture save options.	
    /// </summary>	
    /// <unmanaged>D3DX11_SAVE_TEXTURE_FLAG</unmanaged>
    [Flags]
    public enum SaveTextureFlags : int {	
        
        /// <summary>	
        /// Do not optimize.	
        /// </summary>	
        /// <unmanaged>D3DX11_STF_USEINPUTBLOB</unmanaged>
        UseInputBlob = unchecked((int)1),			
        
        /// <summary>	
        /// None.	
        /// </summary>	
        /// <unmanaged>None</unmanaged>
        None = unchecked((int)0),			
    }
}
