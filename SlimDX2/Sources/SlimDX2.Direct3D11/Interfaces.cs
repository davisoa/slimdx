// Copyright (c) 2007-2010 SlimDX Group
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Interfaces for SlimDX2.Direct3D11 namespace.
//     This code was generated by a tool.
//     Date : 10/24/2010 14:23:50
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace SlimDX2.Direct3D11 {

    
    /// <summary>	
    /// A device-child interface accesses data used by a device.	
    /// </summary>	
    /// <unmanaged>ID3D11DeviceChild</unmanaged>
    [Guid("1841e5c8-16b0-489b-bcc8-44cfb0d5deae")]
    public partial class DeviceChild : SlimDX2.ComObject {

        public DeviceChild(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get a pointer to the device that created this interface.	
        /// </summary>	
        /// <remarks>	
        /// Any returned interfaces will have their reference count incremented by one, so be sure to call ::release() on the returned pointer(s) before they are freed or else you will have a memory leak.	
        /// </remarks>	
        /// <unmanaged>void GetDevice([Out] ID3D11Device** ppDevice)</unmanaged>
        public SlimDX2.Direct3D11.Device Device {
                get { SlimDX2.Direct3D11.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a pointer to the device that created this interface.	
        /// </summary>	
        /// <remarks>	
        /// Any returned interfaces will have their reference count incremented by one, so be sure to call ::release() on the returned pointer(s) before they are freed or else you will have a memory leak.	
        /// </remarks>	
        /// <param name="deviceRef">Address of a pointer to a device (see <see cref="SlimDX2.Direct3D11.Device"/>).</param>
        /// <unmanaged>void GetDevice([Out] ID3D11Device** ppDevice)</unmanaged>
        internal void GetDevice(out SlimDX2.Direct3D11.Device deviceRef) {
            unsafe {
                IntPtr deviceRef_ = IntPtr.Zero;
                SlimDX2.Interop.CalliVoid(_nativePointer, 3 * 4, &deviceRef_);
                deviceRef = (deviceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Device(deviceRef_);	
            }
        }
        
        /// <summary>	
        /// Get application-defined data from a device child.	
        /// </summary>	
        /// <remarks>	
        /// The data stored in the device child is set by calling <see cref="SlimDX2.Direct3D11.DeviceChild.SetPrivateData"/>.	
        /// </remarks>	
        /// <param name="guid">Guid associated with the data.</param>
        /// <param name="dataSizeRef">A pointer to a variable that on input contains the size, in bytes, of the buffer that pData points to, and on output contains the size, in bytes, of the amount of data that GetPrivateData retrieved.</param>
        /// <param name="dataRef">A pointer to a buffer that GetPrivateData fills with data from the device child if pDataSize points to a value that specifies a buffer large enough to hold the data.</param>
        /// <returns>This method returns one of the codes described in the topic {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetPrivateData([In] REFGUID guid,[InOut] UINT* pDataSize,[Out, Buffer, Optional] void* pData)</unmanaged>
        public SlimDX2.Result GetPrivateData(Guid guid, ref int dataSizeRef, IntPtr dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* dataSizeRef_ = &dataSizeRef)
                    __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 4 * 4, &guid, dataSizeRef_, (void*)dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set application-defined data to a device child and associate that data with an application-defined guid.	
        /// </summary>	
        /// <remarks>	
        /// The data stored in the device child with this method can be retrieved with <see cref="SlimDX2.Direct3D11.DeviceChild.GetPrivateData"/>.The {{debug layer}} reports memory leaks by outputting a list of object interface pointers along with their friendly names. The default friendly name is "&lt;unnamed&gt;". You can set the friendly name so that you can determine if the corresponding object interface pointer caused the leak. To set the friendly name, use the SetPrivateData method and the WKPDID_D3DDebugObjectName GUID that is in D3Dcommon.h. For example, to give pContext a friendly name of My name, use the following code:	
        /// <code> static const char c_szName[] = "My name";	
        /// hr = pContext-&gt;SetPrivateData( WKPDID_D3DDebugObjectName, sizeof( c_szName ) - 1, c_szName ); </code>	
        /// 	
        /// </remarks>	
        /// <param name="guid">Guid associated with the data.</param>
        /// <param name="dataSize">Size of the data.</param>
        /// <param name="dataRef">Pointer to the data to be stored with this device child. If pData is NULL, DataSize must also be 0, and any data previously associated with the specified guid will be destroyed.</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetPrivateData([In] REFGUID guid,[In] UINT DataSize,[In, Buffer, Optional] const void* pData)</unmanaged>
        public SlimDX2.Result SetPrivateData(Guid guid, int dataSize, IntPtr dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 5 * 4, &guid, dataSize, (void*)dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Associate an IUnknown-derived interface with this device child and associate that interface with an application-defined guid.	
        /// </summary>	
        /// <remarks>	
        /// When this method is called ::addref() will be called on the IUnknown-derived interface, and when the device child is detroyed ::release() will be called on the IUnknown-derived interface.	
        /// </remarks>	
        /// <param name="guid">Guid associated with the interface.</param>
        /// <param name="dataRef">Pointer to an IUnknown-derived interface to be associated with the device child.</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetPrivateDataInterface([In] REFGUID guid,[In, Optional] const IUnknown* pData)</unmanaged>
        public SlimDX2.Result SetPrivateDataInterface(Guid guid, SlimDX2.ComObject dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 6 * 4, &guid, (void*)((dataRef == null)?IntPtr.Zero:dataRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A depth-stencil-state interface accesses depth-stencil state which sets up the depth-stencil test for the output-merger stage.	
    /// </summary>	
    /// <unmanaged>ID3D11DepthStencilState</unmanaged>
    [Guid("03823efb-8d8f-4e1c-9aa2-f64bb2cbfdf1")]
    public partial class DepthStencilState : SlimDX2.Direct3D11.DeviceChild {

        public DepthStencilState(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the depth-stencil state.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D11_DEPTH_STENCIL_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D11.DepthStencilStateDescription Description {
                get { SlimDX2.Direct3D11.DepthStencilStateDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the depth-stencil state.	
        /// </summary>	
        /// <param name="descRef">A pointer to the depth-stencil state (see <see cref="SlimDX2.Direct3D11.DepthStencilStateDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D11_DEPTH_STENCIL_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D11.DepthStencilStateDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D11.DepthStencilStateDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 7 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// This blend-state interface accesses blending state for the output-merger stage.	
    /// </summary>	
    /// <unmanaged>ID3D11BlendState</unmanaged>
    [Guid("75b68faa-347d-4159-8f45-a0640f01cd9a")]
    public partial class BlendState : SlimDX2.Direct3D11.DeviceChild {

        public BlendState(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the blend state.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D11_BLEND_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D11.BlendStateDescription Description {
                get { SlimDX2.Direct3D11.BlendStateDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the blend state.	
        /// </summary>	
        /// <param name="descRef">A pointer to the blend state (see <see cref="SlimDX2.Direct3D11.BlendStateDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D11_BLEND_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D11.BlendStateDescription descRef) {
            unsafe {
                SlimDX2.Direct3D11.BlendStateDescription.__Native descRef_ = new SlimDX2.Direct3D11.BlendStateDescription.__Native();
                descRef = new SlimDX2.Direct3D11.BlendStateDescription();
                SlimDX2.Interop.CalliVoid(_nativePointer, 7 * 4, &descRef_);
                descRef.__MarshalFrom(ref descRef_);			
            }
        }
    }
    
    /// <summary>	
    /// A rasterizer-state interface accesses rasterizer state for the rasterizer stage.	
    /// </summary>	
    /// <unmanaged>ID3D11RasterizerState</unmanaged>
    [Guid("9bb4ab81-ab1a-4d8f-b506-fc04200b6ee7")]
    public partial class RasterizerState : SlimDX2.Direct3D11.DeviceChild {

        public RasterizerState(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the properties of a rasterizer-state object.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D11_RASTERIZER_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D11.RasterizerStateDescription Description {
                get { SlimDX2.Direct3D11.RasterizerStateDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the properties of a rasterizer-state object.	
        /// </summary>	
        /// <param name="descRef">Pointer to a rasterizer-state description (see <see cref="SlimDX2.Direct3D11.RasterizerStateDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D11_RASTERIZER_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D11.RasterizerStateDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D11.RasterizerStateDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 7 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A resource interface provides common actions on all resources.	
    /// </summary>	
    /// <unmanaged>ID3D11Resource</unmanaged>
    [Guid("dc8e63f3-d12b-4952-b47b-5e45026a862d")]
    public partial class Resource : SlimDX2.Direct3D11.DeviceChild {

        public Resource(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the type of the resource.	
        /// </summary>	
        /// <unmanaged>void GetType([Out] D3D11_RESOURCE_DIMENSION* pResourceDimension)</unmanaged>
        public SlimDX2.Direct3D11.ResourceDimension TypeInfo {
                get { SlimDX2.Direct3D11.ResourceDimension __output__; GetTypeInfo(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the eviction priority of a resource.	
        /// </summary>	
        /// <unmanaged>UINT GetEvictionPriority()</unmanaged>
        public int EvictionPriority {
                get { return GetEvictionPriority(); }
                set { SetEvictionPriority(value); }
        }
        
        /// <summary>	
        /// Get the type of the resource.	
        /// </summary>	
        /// <param name="resourceDimensionRef">Pointer to the resource type (see <see cref="SlimDX2.Direct3D11.ResourceDimension"/>).</param>
        /// <unmanaged>void GetType([Out] D3D11_RESOURCE_DIMENSION* pResourceDimension)</unmanaged>
        internal void GetTypeInfo(out SlimDX2.Direct3D11.ResourceDimension resourceDimensionRef) {
            unsafe {
                fixed (void* resourceDimensionRef_ = &resourceDimensionRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 7 * 4, resourceDimensionRef_);
            }
        }
        
        /// <summary>	
        /// Set the eviction priority of a resource.	
        /// </summary>	
        /// <remarks>	
        /// Resource priorities determine which resource to evict from video memory when the system has run out of video memory. The resource will not be lost; it will be removed from video memory and placed into system memory, or possibly placed onto the hard drive. The resource will be loaded back into video memory when it is required.A resource that is set to the maximum priority, DXGI_RESOURCE_PRIORITY_MAXIMUM, is only evicted if there is no other way of resolving the incoming memory request. The Windows Display Driver Model (WDDM) tries to split an incoming memory request to its minimum size and evict lower-priority resources before evicting a resource with maximum priority.Changing the priorities of resources should be done carefully. The wrong eviction priorities could be a detriment to performance rather than an improvement. 	
        /// </remarks>	
        /// <param name="evictionPriority">Eviction priority for the resource, which is one of the following values:DXGI_RESOURCE_PRIORITY_MINIMUMDXGI_RESOURCE_PRIORITY_LOWDXGI_RESOURCE_PRIORITY_NORMALDXGI_RESOURCE_PRIORITY_HIGHDXGI_RESOURCE_PRIORITY_MAXIMUM</param>
        /// <unmanaged>void SetEvictionPriority([In] UINT EvictionPriority)</unmanaged>
        internal void SetEvictionPriority(int evictionPriority) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 8 * 4, evictionPriority);
            }
        }
        
        /// <summary>	
        /// Get the eviction priority of a resource.	
        /// </summary>	
        /// <returns>One of the following values, which specifies the eviction priority for the resource:DXGI_RESOURCE_PRIORITY_MINIMUMDXGI_RESOURCE_PRIORITY_LOWDXGI_RESOURCE_PRIORITY_NORMALDXGI_RESOURCE_PRIORITY_HIGHDXGI_RESOURCE_PRIORITY_MAXIMUM</returns>
        /// <unmanaged>UINT GetEvictionPriority()</unmanaged>
        internal int GetEvictionPriority() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Interop.CalliInt(_nativePointer, 9 * 4);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A buffer interface accesses a buffer resource, which is unstructured memory. Buffers typically store vertex or index data.	
    /// </summary>	
    /// <unmanaged>ID3D11Buffer</unmanaged>
    [Guid("48570b85-d1ee-4fcd-a250-eb350722b037")]
    public partial class Buffer : SlimDX2.Direct3D11.Resource {

        public Buffer(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the properties of a buffer resource.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D11_BUFFER_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D11.BufferDescription Description {
                get { SlimDX2.Direct3D11.BufferDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the properties of a buffer resource.	
        /// </summary>	
        /// <param name="descRef">Pointer to a resource description (see <see cref="SlimDX2.Direct3D11.BufferDescription"/>) filled in by the method.</param>
        /// <unmanaged>void GetDesc([Out] D3D11_BUFFER_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D11.BufferDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D11.BufferDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 10 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A 1D texture interface accesses texel data, which is structured memory.	
    /// </summary>	
    /// <unmanaged>ID3D11Texture1D</unmanaged>
    [Guid("f8fb5c27-c6b3-4f75-a4c8-439af2ef564c")]
    public partial class Texture1D : SlimDX2.Direct3D11.Resource {

        public Texture1D(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the properties of the texture resource.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D11_TEXTURE1D_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D11.Texture1DDescription Description {
                get { SlimDX2.Direct3D11.Texture1DDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the properties of the texture resource.	
        /// </summary>	
        /// <param name="descRef">Pointer to a resource description (see <see cref="SlimDX2.Direct3D11.Texture1DDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D11_TEXTURE1D_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D11.Texture1DDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D11.Texture1DDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 10 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A 2D texture interface manages texel data, which is structured memory.	
    /// </summary>	
    /// <unmanaged>ID3D11Texture2D</unmanaged>
    [Guid("6f15aaf2-d208-4e89-9ab4-489535d34f9c")]
    public partial class Texture2D : SlimDX2.Direct3D11.Resource {

        public Texture2D(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the properties of the texture resource.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D11_TEXTURE2D_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D11.Texture2DDescription Description {
                get { SlimDX2.Direct3D11.Texture2DDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the properties of the texture resource.	
        /// </summary>	
        /// <param name="descRef">Pointer to a resource description (see <see cref="SlimDX2.Direct3D11.Texture2DDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D11_TEXTURE2D_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D11.Texture2DDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D11.Texture2DDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 10 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A 3D texture interface accesses texel data, which is structured memory.	
    /// </summary>	
    /// <unmanaged>ID3D11Texture3D</unmanaged>
    [Guid("037e866e-f56d-4357-a8af-9dabbe6e250e")]
    public partial class Texture3D : SlimDX2.Direct3D11.Resource {

        public Texture3D(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the properties of the texture resource.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D11_TEXTURE3D_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D11.Texture3DDescription Description {
                get { SlimDX2.Direct3D11.Texture3DDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the properties of the texture resource.	
        /// </summary>	
        /// <param name="descRef">Pointer to a resource description (see <see cref="SlimDX2.Direct3D11.Texture3DDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D11_TEXTURE3D_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D11.Texture3DDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D11.Texture3DDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 10 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A view interface specifies the parts of a resource the pipeline can access during rendering.	
    /// </summary>	
    /// <unmanaged>ID3D11View</unmanaged>
    [Guid("839d1216-bb2e-412b-b7f4-a9dbebe08ed1")]
    public partial class View : SlimDX2.Direct3D11.DeviceChild {

        public View(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the resource that is accessed through this view.	
        /// </summary>	
        /// <remarks>	
        /// This function increments the reference count of the resource by one, so it is necessary to call Release on the returned pointer when the application is done with it. Destroying (or losing) the returned pointer before Release is called will result in a memory leak.	
        /// </remarks>	
        /// <unmanaged>void GetResource([Out] ID3D11Resource** ppResource)</unmanaged>
        public SlimDX2.Direct3D11.Resource Resource {
                get { SlimDX2.Direct3D11.Resource __output__; GetResource(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the resource that is accessed through this view.	
        /// </summary>	
        /// <remarks>	
        /// This function increments the reference count of the resource by one, so it is necessary to call Release on the returned pointer when the application is done with it. Destroying (or losing) the returned pointer before Release is called will result in a memory leak.	
        /// </remarks>	
        /// <param name="resourceRef">Address of a pointer to the resource that is accessed through this view. (See <see cref="SlimDX2.Direct3D11.Resource"/>.)</param>
        /// <unmanaged>void GetResource([Out] ID3D11Resource** ppResource)</unmanaged>
        internal void GetResource(out SlimDX2.Direct3D11.Resource resourceRef) {
            unsafe {
                IntPtr resourceRef_ = IntPtr.Zero;
                SlimDX2.Interop.CalliVoid(_nativePointer, 7 * 4, &resourceRef_);
                resourceRef = (resourceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Resource(resourceRef_);	
            }
        }
    }
    
    /// <summary>	
    /// A shader-resource-view interface specifies the subresources a shader can access during rendering. Examples of shader resources include a constant buffer, a texture buffer, a texture or a sampler.	
    /// </summary>	
    /// <unmanaged>ID3D11ShaderResourceView</unmanaged>
    [Guid("b0e06fe0-8192-4e1a-b1ca-36d7414710b2")]
    public partial class ShaderResourceView : SlimDX2.Direct3D11.View {

        public ShaderResourceView(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the shader resource view's description.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D11_SHADER_RESOURCE_VIEW_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D11.ShaderResourceViewDescription Description {
                get { SlimDX2.Direct3D11.ShaderResourceViewDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the shader resource view's description.	
        /// </summary>	
        /// <param name="descRef">A pointer to a <see cref="SlimDX2.Direct3D11.ShaderResourceViewDescription"/> structure to be filled with data about the shader resource view.</param>
        /// <unmanaged>void GetDesc([Out] D3D11_SHADER_RESOURCE_VIEW_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D11.ShaderResourceViewDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D11.ShaderResourceViewDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 8 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A render-target-view interface identifies the render-target subresources that can be accessed during rendering.	
    /// </summary>	
    /// <unmanaged>ID3D11RenderTargetView</unmanaged>
    [Guid("dfdba067-0b8d-4865-875b-d7b4516cc164")]
    public partial class RenderTargetView : SlimDX2.Direct3D11.View {

        public RenderTargetView(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the properties of a render target view.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D11_RENDER_TARGET_VIEW_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D11.RenderTargetViewDescription Description {
                get { SlimDX2.Direct3D11.RenderTargetViewDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the properties of a render target view.	
        /// </summary>	
        /// <param name="descRef">Pointer to the description of a render target view (see <see cref="SlimDX2.Direct3D11.RenderTargetViewDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D11_RENDER_TARGET_VIEW_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D11.RenderTargetViewDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D11.RenderTargetViewDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 8 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A depth-stencil-view interface accesses a texture resource during depth-stencil testing.	
    /// </summary>	
    /// <unmanaged>ID3D11DepthStencilView</unmanaged>
    [Guid("9fdac92a-1876-48c3-afad-25b94f84a9b6")]
    public partial class DepthStencilView : SlimDX2.Direct3D11.View {

        public DepthStencilView(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the depth-stencil view.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D11_DEPTH_STENCIL_VIEW_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D11.DepthStencilViewDescription Description {
                get { SlimDX2.Direct3D11.DepthStencilViewDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the depth-stencil view.	
        /// </summary>	
        /// <param name="descRef">Pointer to a depth-stencil-view description (see <see cref="SlimDX2.Direct3D11.DepthStencilViewDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D11_DEPTH_STENCIL_VIEW_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D11.DepthStencilViewDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D11.DepthStencilViewDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 8 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A view interface specifies the parts of a resource the pipeline can access during rendering.	
    /// </summary>	
    /// <unmanaged>ID3D11UnorderedAccessView</unmanaged>
    [Guid("28acf509-7f5c-48f6-8611-f316010a6380")]
    public partial class UnorderedAccessView : SlimDX2.Direct3D11.View {

        public UnorderedAccessView(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get a description of the resource.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D11_UNORDERED_ACCESS_VIEW_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D11.UnorderedAccessViewDescription Description {
                get { SlimDX2.Direct3D11.UnorderedAccessViewDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a description of the resource.	
        /// </summary>	
        /// <param name="descRef">Pointer to a resource description (see <see cref="SlimDX2.Direct3D11.UnorderedAccessViewDescription"/>.)</param>
        /// <unmanaged>void GetDesc([Out] D3D11_UNORDERED_ACCESS_VIEW_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D11.UnorderedAccessViewDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D11.UnorderedAccessViewDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 8 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A vertex-shader interface manages an executable program (a vertex shader) that controls the vertex-shader stage.	
    /// </summary>	
    /// <unmanaged>ID3D11VertexShader</unmanaged>
    [Guid("3b301d64-d678-4289-8897-22f8928b72f3")]
    public partial class VertexShader : SlimDX2.Direct3D11.DeviceChild {

        public VertexShader(IntPtr basePtr) : base(basePtr) {
        }
        
    }
    
    /// <summary>	
    /// A hull-shader interface manages an executable program (a hull shader) that controls the hull-shader stage.	
    /// </summary>	
    /// <unmanaged>ID3D11HullShader</unmanaged>
    [Guid("8e5c6061-628a-4c8e-8264-bbe45cb3d5dd")]
    public partial class HullShader : SlimDX2.Direct3D11.DeviceChild {

        public HullShader(IntPtr basePtr) : base(basePtr) {
        }
        
    }
    
    /// <summary>	
    /// A domain-shader interface manages an executable program (a domain shader) that controls the domain-shader stage.	
    /// </summary>	
    /// <unmanaged>ID3D11DomainShader</unmanaged>
    [Guid("f582c508-0f36-490c-9977-31eece268cfa")]
    public partial class DomainShader : SlimDX2.Direct3D11.DeviceChild {

        public DomainShader(IntPtr basePtr) : base(basePtr) {
        }
        
    }
    
    /// <summary>	
    /// A geometry-shader interface manages an executable program (a geometry shader) that controls the geometry-shader stage.	
    /// </summary>	
    /// <unmanaged>ID3D11GeometryShader</unmanaged>
    [Guid("38325b96-effb-4022-ba02-2e795b70275c")]
    public partial class GeometryShader : SlimDX2.Direct3D11.DeviceChild {

        public GeometryShader(IntPtr basePtr) : base(basePtr) {
        }
        
    }
    
    /// <summary>	
    /// A pixel-shader interface manages an executable program (a pixel shader) that controls the pixel-shader stage.	
    /// </summary>	
    /// <unmanaged>ID3D11PixelShader</unmanaged>
    [Guid("ea82e40d-51dc-4f33-93d4-db7c9125ae8c")]
    public partial class PixelShader : SlimDX2.Direct3D11.DeviceChild {

        public PixelShader(IntPtr basePtr) : base(basePtr) {
        }
        
    }
    
    /// <summary>	
    /// A compute-shader interface manages an executable program (a compute shader) that controls the compute-shader stage.	
    /// </summary>	
    /// <unmanaged>ID3D11ComputeShader</unmanaged>
    [Guid("4f5b196e-c2bd-495e-bd01-1fded38e4969")]
    public partial class ComputeShader : SlimDX2.Direct3D11.DeviceChild {

        public ComputeShader(IntPtr basePtr) : base(basePtr) {
        }
        
    }
    
    /// <summary>	
    /// An input-layout interface accesses the input data for the input-assembler stage.	
    /// </summary>	
    /// <unmanaged>ID3D11InputLayout</unmanaged>
    [Guid("e4819ddc-4cf0-4025-bd26-5de82a3e07b7")]
    public partial class InputLayout : SlimDX2.Direct3D11.DeviceChild {

        public InputLayout(IntPtr basePtr) : base(basePtr) {
        }
        
    }
    
    /// <summary>	
    /// A sampler-state interface accesses sampler state for a texture.	
    /// </summary>	
    /// <unmanaged>ID3D11SamplerState</unmanaged>
    [Guid("da6fea51-564c-4487-9810-f0d0f9b4e3a5")]
    public partial class SamplerState : SlimDX2.Direct3D11.DeviceChild {

        public SamplerState(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the sampler state.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D11_SAMPLER_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D11.SamplerStateDescription Description {
                get { SlimDX2.Direct3D11.SamplerStateDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get the sampler state.	
        /// </summary>	
        /// <param name="descRef">A pointer to the sampler state (see <see cref="SlimDX2.Direct3D11.SamplerStateDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D11_SAMPLER_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D11.SamplerStateDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D11.SamplerStateDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 7 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// This interface encapsulates methods for retrieving data from the GPU asynchronously.	
    /// </summary>	
    /// <unmanaged>ID3D11Asynchronous</unmanaged>
    [Guid("4b35d0cd-1e15-4258-9c98-1b1333f6dd3b")]
    public partial class Asynchronous : SlimDX2.Direct3D11.DeviceChild {

        public Asynchronous(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get the size of the data (in bytes) that is output when calling <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/>.	
        /// </summary>	
        /// <unmanaged>UINT GetDataSize()</unmanaged>
        public int DataSize {
                get { return GetDataSize(); }
        }
        
        /// <summary>	
        /// Get the size of the data (in bytes) that is output when calling <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/>.	
        /// </summary>	
        /// <returns>Size of the data (in bytes) that is output when calling GetData.</returns>
        /// <unmanaged>UINT GetDataSize()</unmanaged>
        internal int GetDataSize() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Interop.CalliInt(_nativePointer, 7 * 4);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// A query interface queries information from the GPU.	
    /// </summary>	
    /// <unmanaged>ID3D11Query</unmanaged>
    [Guid("d6c00747-87b7-425e-b84d-44d108560afd")]
    public partial class Query : SlimDX2.Direct3D11.Asynchronous {

        public Query(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get a query description.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D11_QUERY_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D11.QueryDescription Description {
                get { SlimDX2.Direct3D11.QueryDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a query description.	
        /// </summary>	
        /// <param name="descRef">Pointer to a query description (see <see cref="SlimDX2.Direct3D11.QueryDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D11_QUERY_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D11.QueryDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D11.QueryDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 8 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// A predicate interface determines whether geometry should be processed depending on the results of a previous draw call.	
    /// </summary>	
    /// <unmanaged>ID3D11Predicate</unmanaged>
    [Guid("9eb576dd-9f77-4d86-81aa-8bab5fe490e2")]
    public partial class Predicate : SlimDX2.Direct3D11.Query {

        public Predicate(IntPtr basePtr) : base(basePtr) {
        }
        
    }
    
    /// <summary>	
    /// This interface encapsulates methods for measuring GPU performance.	
    /// </summary>	
    /// <unmanaged>ID3D11Counter</unmanaged>
    [Guid("6e8c49fb-a371-4770-b440-29086022b741")]
    public partial class Counter : SlimDX2.Direct3D11.Asynchronous {

        public Counter(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Get a counter description.	
        /// </summary>	
        /// <unmanaged>void GetDesc([Out] D3D11_COUNTER_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D11.CounterDescription Description {
                get { SlimDX2.Direct3D11.CounterDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Get a counter description.	
        /// </summary>	
        /// <param name="descRef">Pointer to a counter description (see <see cref="SlimDX2.Direct3D11.CounterDescription"/>).</param>
        /// <unmanaged>void GetDesc([Out] D3D11_COUNTER_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D11.CounterDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D11.CounterDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 8 * 4, descRef_);
            }
        }
    }
    
    /// <summary>	
    /// This interface encapsulates an HLSL class.	
    /// </summary>	
    /// <unmanaged>ID3D11ClassInstance</unmanaged>
    [Guid("a6cd7faa-b0b7-4a2f-9436-8662a65797cb")]
    public partial class ClassInstance : SlimDX2.Direct3D11.DeviceChild {

        public ClassInstance(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the <see cref="SlimDX2.Direct3D11.ClassLinkage"/> object associated with the current HLSL class.	
        /// </summary>	
        /// <remarks>	
        /// For more information about using the <see cref="SlimDX2.Direct3D11.ClassInstance"/> interface, see {{Dynamic Linking}}.	
        /// </remarks>	
        /// <unmanaged>void GetClassLinkage([Out] ID3D11ClassLinkage** ppLinkage)</unmanaged>
        public SlimDX2.Direct3D11.ClassLinkage ClassLinkage {
                get { SlimDX2.Direct3D11.ClassLinkage __output__; GetClassLinkage(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets a description of the current HLSL class.	
        /// </summary>	
        /// <remarks>	
        /// For more information about using the <see cref="SlimDX2.Direct3D11.ClassInstance"/> interface, see {{Dynamic Linking}}.An instance is not restricted to being used for a single type in a single shader. An instance is flexible and can be used for any shader that used the same type name or instance name when the instance was generated.A created instance will work for any shader that contains a type of the same type name. For instance, a class instance created with the type name DefaultShader would work in any shader that contained a type DefaultShader even though several shaders could describe a different type.A gotten instance maps directly to an instance name/index in a shader.  A class instance aquired using GetClassInstance will work for any shader that contains a class instance of the name used to generate the runtime instance, the instance does not have to be the same type in all of the shaders it's used in.An instance does not replace the importance of reflection for a particular shader since a gotten instance will not know its slot location and a created instance only specifies a type name.	
        /// </remarks>	
        /// <unmanaged>void GetDesc([Out] D3D11_CLASS_INSTANCE_DESC* pDesc)</unmanaged>
        public SlimDX2.Direct3D11.ClassInstanceDescription Description {
                get { SlimDX2.Direct3D11.ClassInstanceDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// Gets the <see cref="SlimDX2.Direct3D11.ClassLinkage"/> object associated with the current HLSL class.	
        /// </summary>	
        /// <remarks>	
        /// For more information about using the <see cref="SlimDX2.Direct3D11.ClassInstance"/> interface, see {{Dynamic Linking}}.	
        /// </remarks>	
        /// <param name="linkageRef">A pointer to a <see cref="SlimDX2.Direct3D11.ClassLinkage"/> interface pointer.</param>
        /// <unmanaged>void GetClassLinkage([Out] ID3D11ClassLinkage** ppLinkage)</unmanaged>
        internal void GetClassLinkage(out SlimDX2.Direct3D11.ClassLinkage linkageRef) {
            unsafe {
                IntPtr linkageRef_ = IntPtr.Zero;
                SlimDX2.Interop.CalliVoid(_nativePointer, 7 * 4, &linkageRef_);
                linkageRef = (linkageRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ClassLinkage(linkageRef_);	
            }
        }
        
        /// <summary>	
        /// Gets a description of the current HLSL class.	
        /// </summary>	
        /// <remarks>	
        /// For more information about using the <see cref="SlimDX2.Direct3D11.ClassInstance"/> interface, see {{Dynamic Linking}}.An instance is not restricted to being used for a single type in a single shader. An instance is flexible and can be used for any shader that used the same type name or instance name when the instance was generated.A created instance will work for any shader that contains a type of the same type name. For instance, a class instance created with the type name DefaultShader would work in any shader that contained a type DefaultShader even though several shaders could describe a different type.A gotten instance maps directly to an instance name/index in a shader.  A class instance aquired using GetClassInstance will work for any shader that contains a class instance of the name used to generate the runtime instance, the instance does not have to be the same type in all of the shaders it's used in.An instance does not replace the importance of reflection for a particular shader since a gotten instance will not know its slot location and a created instance only specifies a type name.	
        /// </remarks>	
        /// <param name="descRef">A pointer to a <see cref="SlimDX2.Direct3D11.ClassInstanceDescription"/> structure that describes the current HLSL class.</param>
        /// <unmanaged>void GetDesc([Out] D3D11_CLASS_INSTANCE_DESC* pDesc)</unmanaged>
        internal void GetDescription(out SlimDX2.Direct3D11.ClassInstanceDescription descRef) {
            unsafe {
                descRef = new SlimDX2.Direct3D11.ClassInstanceDescription();
                fixed (void* descRef_ = &descRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 8 * 4, descRef_);
            }
        }
        
        /// <summary>	
        /// Gets the instance name of the current HLSL class.	
        /// </summary>	
        /// <remarks>	
        /// GetInstanceName will return a valid name only for instances acquired using <see cref="SlimDX2.Direct3D11.ClassLinkage.GetClassInstance"/>.For more information about using the <see cref="SlimDX2.Direct3D11.ClassInstance"/> interface, see {{Dynamic Linking}}.	
        /// </remarks>	
        /// <param name="pInstanceName">The instance name of the current HLSL class.</param>
        /// <param name="bufferLengthRef">The length of the pInstanceName parameter.</param>
        /// <unmanaged>void GetInstanceName([Out, Buffer, Optional] LPSTR pInstanceName,[InOut] SIZE_T* pBufferLength)</unmanaged>
        internal void GetInstanceName(IntPtr pInstanceName, ref SlimDX2.Size bufferLengthRef) {
            unsafe {
                fixed (void* bufferLengthRef_ = &bufferLengthRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 9 * 4, (void*)pInstanceName, bufferLengthRef_);
            }
        }
        
        /// <summary>	
        /// Gets the type of the current HLSL class.	
        /// </summary>	
        /// <remarks>	
        /// GetTypeName will return a valid name only for instances acquired using <see cref="SlimDX2.Direct3D11.ClassLinkage.GetClassInstance"/>.For more information about using the <see cref="SlimDX2.Direct3D11.ClassInstance"/> interface, see {{Dynamic Linking}}.	
        /// </remarks>	
        /// <param name="pTypeName">Type of the current HLSL class.</param>
        /// <param name="bufferLengthRef">The length of the pTypeName parameter.</param>
        /// <unmanaged>void GetTypeName([Out, Buffer, Optional] LPSTR pTypeName,[InOut] SIZE_T* pBufferLength)</unmanaged>
        internal void GetTypeName(IntPtr pTypeName, ref SlimDX2.Size bufferLengthRef) {
            unsafe {
                fixed (void* bufferLengthRef_ = &bufferLengthRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 10 * 4, (void*)pTypeName, bufferLengthRef_);
            }
        }
    }
    
    /// <summary>	
    /// This interface encapsulates an HLSL dynamic linkage.	
    /// </summary>	
    /// <unmanaged>ID3D11ClassLinkage</unmanaged>
    [Guid("ddf57cba-9543-46e4-a12b-f207a0fe7fed")]
    public partial class ClassLinkage : SlimDX2.Direct3D11.DeviceChild {

        public ClassLinkage(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the class-instance object that represents the specified HLSL class.	
        /// </summary>	
        /// <remarks>	
        /// For more information about using the <see cref="SlimDX2.Direct3D11.ClassLinkage"/> interface, see {{Dynamic Linking}}.A class instance must have at least 1 data member in order to be available for the runtime to use with ID3D11ClassLinkage::GetClassInstance. Any instance with no members will be optimized out of a compiled shader blob as a zero-sized object. If you have a class with no data members, use <see cref="SlimDX2.Direct3D11.ClassLinkage.CreateClassInstance"/> instead.	
        /// </remarks>	
        /// <param name="classInstanceNameRef">The name of a class for which to get the class instance.</param>
        /// <param name="instanceIndex">The index of the class instance.</param>
        /// <param name="instanceRef">The address of a pointer to an <see cref="SlimDX2.Direct3D11.ClassInstance"/> interface to initialize.</param>
        /// <returns>Returns S_OK if successful; otherwise, returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetClassInstance([In] const char* pClassInstanceName,[In] UINT InstanceIndex,[Out] ID3D11ClassInstance** ppInstance)</unmanaged>
        public SlimDX2.Result GetClassInstance(string classInstanceNameRef, int instanceIndex, out SlimDX2.Direct3D11.ClassInstance instanceRef) {
            unsafe {
                IntPtr classInstanceNameRef_ = Marshal.StringToHGlobalAnsi(classInstanceNameRef);
                IntPtr instanceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 7 * 4, (void*)classInstanceNameRef_, instanceIndex, &instanceRef_);
                Marshal.FreeHGlobal(classInstanceNameRef_ );
                instanceRef = (instanceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ClassInstance(instanceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Initializes a class-instance object that represents an HLSL class instance.	
        /// </summary>	
        /// <remarks>	
        /// Instances can be created (or gotten) before or after a shader is created. Use the same shader linkage object to acquire a class instance and create the shader the instance is going to be used in.For more information about using the <see cref="SlimDX2.Direct3D11.ClassLinkage"/> interface, see {{Dynamic Linking}}.	
        /// </remarks>	
        /// <param name="classTypeNameRef">The type name of a class to initialize.</param>
        /// <param name="constantBufferOffset">Identifies the constant buffer that contains the class data.</param>
        /// <param name="constantVectorOffset">The four-component vector offset from the start of the constant buffer where the class data will begin. Consequently, this is not a byte offset.</param>
        /// <param name="textureOffset">The texture slot for the first texture; there may be multiple textures following the offset.</param>
        /// <param name="samplerOffset">The sampler slot for the first sampler; there may be multiple samplers following the offset.</param>
        /// <param name="instanceRef">The address of a pointer to an <see cref="SlimDX2.Direct3D11.ClassInstance"/> interface to initialize.</param>
        /// <returns>Returns S_OK if successful; otherwise, returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateClassInstance([In] const char* pClassTypeName,[In] UINT ConstantBufferOffset,[In] UINT ConstantVectorOffset,[In] UINT TextureOffset,[In] UINT SamplerOffset,[Out] ID3D11ClassInstance** ppInstance)</unmanaged>
        public SlimDX2.Result CreateClassInstance(string classTypeNameRef, int constantBufferOffset, int constantVectorOffset, int textureOffset, int samplerOffset, out SlimDX2.Direct3D11.ClassInstance instanceRef) {
            unsafe {
                IntPtr classTypeNameRef_ = Marshal.StringToHGlobalAnsi(classTypeNameRef);
                IntPtr instanceRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 8 * 4, (void*)classTypeNameRef_, constantBufferOffset, constantVectorOffset, textureOffset, samplerOffset, &instanceRef_);
                Marshal.FreeHGlobal(classTypeNameRef_ );
                instanceRef = (instanceRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ClassInstance(instanceRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// The ID3D11CommandList interface encapsulates a list of graphics commands for play back.	
    /// </summary>	
    /// <unmanaged>ID3D11CommandList</unmanaged>
    [Guid("a24bc4d1-769e-43f7-8013-98ff566c18e2")]
    public partial class CommandList : SlimDX2.Direct3D11.DeviceChild {

        public CommandList(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the initialization flags associated with the deferred context that created the command list.	
        /// </summary>	
        /// <remarks>	
        /// The GetContextFlags method gets the flags that were supplied to the ContextFlags parameter of <see cref="SlimDX2.Direct3D11.Device.CreateDeferredContext"/>; however, the context flag is reserved for future use.	
        /// </remarks>	
        /// <unmanaged>UINT GetContextFlags()</unmanaged>
        public int ContextFlags {
                get { return GetContextFlags(); }
        }
        
        /// <summary>	
        /// Gets the initialization flags associated with the deferred context that created the command list.	
        /// </summary>	
        /// <remarks>	
        /// The GetContextFlags method gets the flags that were supplied to the ContextFlags parameter of <see cref="SlimDX2.Direct3D11.Device.CreateDeferredContext"/>; however, the context flag is reserved for future use.	
        /// </remarks>	
        /// <returns>The context flag is reserved for future use and is always 0.</returns>
        /// <unmanaged>UINT GetContextFlags()</unmanaged>
        internal int GetContextFlags() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Interop.CalliInt(_nativePointer, 7 * 4);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// The ID3D11DeviceContext interface represents a device context which generates rendering commands.	
    /// </summary>	
    /// <unmanaged>ID3D11DeviceContext</unmanaged>
    [Guid("c0bfa96c-e089-44fb-8eaf-26f8796190da")]
    public partial class DeviceContext : SlimDX2.Direct3D11.DeviceChild {

        public DeviceContext(IntPtr basePtr) : base(basePtr) {
        }
        
				
        /// <summary>Update nested inner interfaces pointer</summary>
        protected override void NativePointerUpdated()
        {            
            InputAssembler = new SlimDX2.Direct3D11.DeviceContext.InputAssemblerStage(this.NativePointer);		
            VertexShader = new SlimDX2.Direct3D11.DeviceContext.VertexShaderStage(this.NativePointer);		
            PixelShader = new SlimDX2.Direct3D11.DeviceContext.PixelShaderStage(this.NativePointer);		
            GeometryShader = new SlimDX2.Direct3D11.DeviceContext.GeometryShaderStage(this.NativePointer);		
            StreamOutput = new SlimDX2.Direct3D11.DeviceContext.StreamOutputStage(this.NativePointer);		
            DomainShader = new SlimDX2.Direct3D11.DeviceContext.DomainShaderStage(this.NativePointer);		
            HullShader = new SlimDX2.Direct3D11.DeviceContext.HullShaderStage(this.NativePointer);		
            Rasterizer = new SlimDX2.Direct3D11.DeviceContext.RasterizerStage(this.NativePointer);		
            OutputMerger = new SlimDX2.Direct3D11.DeviceContext.OutputMergerStage(this.NativePointer);		
            ComputeShader = new SlimDX2.Direct3D11.DeviceContext.ComputeShaderStage(this.NativePointer);		
        }
      
		/// <summary>Inner interface giving access to InputAssemblerStage methods. </summary>
        public InputAssemblerStage InputAssembler { get; private set; }		
        
        /// <summary>Inner interface InputAssemblerStage.</summary>
        /// <unmanaged>ID3D11DeviceContext</unmanaged>
        public partial class InputAssemblerStage : SlimDX2.CppObject {	
    
    		public InputAssemblerStage(IntPtr basePtr) : base(basePtr) {
            }
            
            
            /// <summary>	
            /// Get a pointer to the input-layout object that is bound to the input-assembler stage.	
            /// </summary>	
            /// <remarks>	
            /// For information about creating an input-layout object, see Creating the Input-Layout Object.Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <unmanaged>void IAGetInputLayout([Out] ID3D11InputLayout** ppInputLayout)</unmanaged>
            public SlimDX2.Direct3D11.InputLayout InputLayout {
                    get { SlimDX2.Direct3D11.InputLayout __output__; GetInputLayout(out __output__); return __output__; }
                    set { SetInputLayout(value); }
            }
            
            /// <summary>	
            /// Get information about the primitive type, and data order that describes input data for the input assembler stage.	
            /// </summary>	
            /// <unmanaged>void IAGetPrimitiveTopology([Out] D3D_PRIMITIVE_TOPOLOGY* pTopology)</unmanaged>
            public SlimDX2.Direct3D.PrimitiveTopology PrimitiveTopology {
                    get { SlimDX2.Direct3D.PrimitiveTopology __output__; GetPrimitiveTopology(out __output__); return __output__; }
                    set { SetPrimitiveTopology(value); }
            }
            
            /// <summary>	
            /// Bind an input-layout object to the input-assembler stage.	
            /// </summary>	
            /// <remarks>	
            /// Input-layout objects describe how vertex buffer data is streamed into the IA pipeline stage. To create an input-layout object, call <see cref="SlimDX2.Direct3D11.Device.CreateInputLayout"/>. The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="inputLayoutRef">A pointer to the input-layout object (see <see cref="SlimDX2.Direct3D11.InputLayout"/>), which describes the input buffers that will be read by the IA stage.</param>
            /// <unmanaged>void IASetInputLayout([In, Optional] ID3D11InputLayout* pInputLayout)</unmanaged>
            internal void SetInputLayout(SlimDX2.Direct3D11.InputLayout inputLayoutRef) {
                unsafe {
                    SlimDX2.Interop.CalliVoid(_nativePointer, 17 * 4, (void*)((inputLayoutRef == null)?IntPtr.Zero:inputLayoutRef.NativePointer));
                }
            }
            
            /// <summary>	
            /// Bind an array of vertex buffers to the input-assembler stage.	
            /// </summary>	
            /// <remarks>	
            /// For information about creating vertex buffers, see Create a Vertex Buffer.Calling this method using a buffer that is currently bound for writing (i.e. bound to the stream output pipeline stage) will effectively bind NULL instead because a buffer cannot be bound as both an input and an output at the same time.The debug layer will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will not prevent invalid data from being used by the runtime. The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="startSlot">The first input slot for binding. The first vertex buffer is explicitly bound to the start slot; this causes each additional vertex buffer in the array to be implicitly bound to each subsequent input slot. There are 16 input slots (ranges from 0 to D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT - 1).</param>
            /// <param name="numBuffers">The number of vertex buffers in the array. The number of buffers (plus the starting slot) cannot exceed the total number of IA-stage input slots (ranges from 0 to D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</param>
            /// <param name="vertexBuffersRef">A pointer to an array of vertex buffers (see <see cref="SlimDX2.Direct3D11.Buffer"/>). The vertex buffers must have been created with the <see cref="SlimDX2.Direct3D11.BindFlags.VertexBuffer"/> flag.</param>
            /// <param name="stridesRef">Pointer to an array of stride values; one stride value for each buffer in the vertex-buffer array. Each stride is the size (in bytes) of the elements that are to be used from that vertex buffer.</param>
            /// <param name="offsetsRef">Pointer to an array of offset values; one offset value for each buffer in the vertex-buffer array. Each offset is the number of bytes between the first element of a vertex buffer and the first element that will be used.</param>
            /// <unmanaged>void IASetVertexBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[In, Buffer] const ID3D11Buffer** ppVertexBuffers,[In, Buffer] const UINT* pStrides,[In, Buffer] const UINT* pOffsets)</unmanaged>
            internal void SetVertexBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D11.Buffer[] vertexBuffersRef, int[] stridesRef, int[] offsetsRef) {
                unsafe {
                    IntPtr* vertexBuffersRef_ = (IntPtr*)0;
                    if ( vertexBuffersRef != null ) {
                        IntPtr* vertexBuffersRef__ = stackalloc IntPtr[vertexBuffersRef.Length];
                        vertexBuffersRef_ = vertexBuffersRef__;
                        for (int i = 0; i < vertexBuffersRef.Length; i++)                        
                            vertexBuffersRef_[i] =  vertexBuffersRef[i].NativePointer;
                    }
                    fixed (void* stridesRef_ = &stridesRef[0])
                        fixed (void* offsetsRef_ = &offsetsRef[0])
                            SlimDX2.Interop.CalliVoid(_nativePointer, 18 * 4, startSlot, numBuffers, vertexBuffersRef_, stridesRef_, offsetsRef_);
                }
            }
            
            /// <summary>	
            /// Bind an index buffer to the input-assembler stage.	
            /// </summary>	
            /// <remarks>	
            /// For information about creating index buffers, see {{How to: Create an Index Buffer}}.Calling this method using a buffer that is currently bound for writing (i.e. bound to the stream output pipeline stage) will effectively bind  NULL instead because a buffer cannot be bound as both an input and an output at the same time.The debug layer will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will  not prevent invalid data from being used by the runtime. The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="indexBufferRef">A pointer to an <see cref="SlimDX2.Direct3D11.Buffer"/> object, that contains indices. The index buffer must have been created with  the <see cref="SlimDX2.Direct3D11.BindFlags.IndexBuffer"/> flag.</param>
            /// <param name="format">A <see cref="SlimDX2.DXGI.Format"/> that specifies the format of the data in the index buffer. The only formats allowed for index  buffer data are 16-bit (DXGI_FORMAT_R16_UINT) and 32-bit (DXGI_FORMAT_R32_UINT) integers.</param>
            /// <param name="offset">Offset (in bytes) from the start of the index buffer to the first index to use.</param>
            /// <unmanaged>void IASetIndexBuffer([In, Optional] ID3D11Buffer* pIndexBuffer,[In] DXGI_FORMAT Format,[In] UINT Offset)</unmanaged>
            public void SetIndexBuffer(SlimDX2.Direct3D11.Buffer indexBufferRef, SlimDX2.DXGI.Format format, int offset) {
                unsafe {
                    SlimDX2.Interop.CalliVoid(_nativePointer, 19 * 4, (void*)((indexBufferRef == null)?IntPtr.Zero:indexBufferRef.NativePointer), unchecked((int)format), offset);
                }
            }
            
            /// <summary>	
            /// Bind information about the primitive type, and data order that describes input data for the input assembler stage.	
            /// </summary>	
            /// <param name="topology">The type of primitive and ordering of the primitive data (see {{D3D11_PRIMITIVE_TOPOLOGY}}).</param>
            /// <unmanaged>void IASetPrimitiveTopology([In] D3D_PRIMITIVE_TOPOLOGY Topology)</unmanaged>
            internal void SetPrimitiveTopology(SlimDX2.Direct3D.PrimitiveTopology topology) {
                unsafe {
                    SlimDX2.Interop.CalliVoid(_nativePointer, 24 * 4, unchecked((int)topology));
                }
            }
            
            /// <summary>	
            /// Get a pointer to the input-layout object that is bound to the input-assembler stage.	
            /// </summary>	
            /// <remarks>	
            /// For information about creating an input-layout object, see Creating the Input-Layout Object.Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="inputLayoutRef">A pointer to the input-layout object (see <see cref="SlimDX2.Direct3D11.InputLayout"/>), which describes the input buffers that will be read by the IA stage.</param>
            /// <unmanaged>void IAGetInputLayout([Out] ID3D11InputLayout** ppInputLayout)</unmanaged>
            internal void GetInputLayout(out SlimDX2.Direct3D11.InputLayout inputLayoutRef) {
                unsafe {
                    IntPtr inputLayoutRef_ = IntPtr.Zero;
                    SlimDX2.Interop.CalliVoid(_nativePointer, 78 * 4, &inputLayoutRef_);
                    inputLayoutRef = (inputLayoutRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.InputLayout(inputLayoutRef_);	
                }
            }
            
            /// <summary>	
            /// Get the vertex buffers bound to the input-assembler stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">The input slot of the first vertex buffer to get. The first vertex buffer is explicitly bound to the start slot; this causes each additional vertex buffer in the array to be implicitly bound to each subsequent input slot. There are 16 input slots.</param>
            /// <param name="numBuffers">The number of vertex buffers to get starting at the offset. The number of buffers (plus the starting slot) cannot exceed the total number of IA-stage input slots.</param>
            /// <param name="vertexBuffersRef">A pointer to an array of vertex buffers returned by the method (see <see cref="SlimDX2.Direct3D11.Buffer"/>).</param>
            /// <param name="stridesRef">Pointer to an array of stride values returned by the method; one stride value for each buffer in the vertex-buffer array. Each stride value is the size (in bytes) of the elements that are to be used from that vertex buffer.</param>
            /// <param name="offsetsRef">Pointer to an array of offset values returned by the method; one offset value for each buffer in the vertex-buffer array. Each offset is the number of bytes between the first element of a vertex buffer and the first element that will be used.</param>
            /// <unmanaged>void IAGetVertexBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[Out, Buffer, Optional] ID3D11Buffer** ppVertexBuffers,[Out, Buffer, Optional] UINT* pStrides,[Out, Buffer, Optional] UINT* pOffsets)</unmanaged>
            public void GetVertexBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D11.Buffer[] vertexBuffersRef, int[] stridesRef, int[] offsetsRef) {
                unsafe {
                    IntPtr* vertexBuffersRef_ = stackalloc IntPtr[vertexBuffersRef.Length];
                    int[] stridesRef__ = stridesRef ?? new int[1];
                    int[] offsetsRef__ = offsetsRef ?? new int[1];
                    fixed (void* stridesRef_ = &stridesRef__[0])
                        fixed (void* offsetsRef_ = &offsetsRef__[0])
                            SlimDX2.Interop.CalliVoid(_nativePointer, 79 * 4, startSlot, numBuffers, &vertexBuffersRef_, stridesRef==null?(void*)IntPtr.Zero:stridesRef_, offsetsRef==null?(void*)IntPtr.Zero:offsetsRef_);
                    for (int i = 0; i < vertexBuffersRef.Length; i++)
                        vertexBuffersRef[i] = (vertexBuffersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Buffer(vertexBuffersRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get a pointer to the index buffer that is bound to the input-assembler stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces  when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="indexBufferRef">A pointer to an index buffer returned by the method (see <see cref="SlimDX2.Direct3D11.Buffer"/>).</param>
            /// <param name="format">Specifies format of the data in the index buffer (see <see cref="SlimDX2.DXGI.Format"/>). These formats provide the size and type of  the data in the buffer. The only formats allowed for index buffer data are 16-bit (DXGI_FORMAT_R16_UINT) and 32-bit (DXGI_FORMAT_R32_UINT)  integers.</param>
            /// <param name="offset">Offset (in bytes) from the start of the index buffer, to the first index to use.</param>
            /// <unmanaged>void IAGetIndexBuffer([Out, Optional] ID3D11Buffer** pIndexBuffer,[Out, Optional] DXGI_FORMAT* Format,[Out, Optional] UINT* Offset)</unmanaged>
            public void GetIndexBuffer(out SlimDX2.Direct3D11.Buffer indexBufferRef, out SlimDX2.DXGI.Format format, out int offset) {
                unsafe {
                    IntPtr indexBufferRef_ = IntPtr.Zero;
                    fixed (void* format_ = &format)
                        fixed (void* offset_ = &offset)
                            SlimDX2.Interop.CalliVoid(_nativePointer, 80 * 4, &indexBufferRef_, format_, offset_);
                    indexBufferRef = (indexBufferRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Buffer(indexBufferRef_);	
                }
            }
            
            /// <summary>	
            /// Get information about the primitive type, and data order that describes input data for the input assembler stage.	
            /// </summary>	
            /// <param name="topologyRef">A pointer to the type of primitive, and ordering of the primitive data (see {{D3D11_PRIMITIVE_TOPOLOGY}}).</param>
            /// <unmanaged>void IAGetPrimitiveTopology([Out] D3D_PRIMITIVE_TOPOLOGY* pTopology)</unmanaged>
            internal void GetPrimitiveTopology(out SlimDX2.Direct3D.PrimitiveTopology topologyRef) {
                unsafe {
                    fixed (void* topologyRef_ = &topologyRef)
                        SlimDX2.Interop.CalliVoid(_nativePointer, 83 * 4, topologyRef_);
                }
            }
        }
      
		/// <summary>Inner interface giving access to VertexShaderStage methods. </summary>
        public VertexShaderStage VertexShader { get; private set; }		
        
        /// <summary>Inner interface VertexShaderStage.</summary>
        /// <unmanaged>ID3D11DeviceContext</unmanaged>
        public partial class VertexShaderStage : CommonShaderStage<VertexShader> {
    
            public VertexShaderStage(IntPtr basePtr) : base(basePtr) {
            }
            
            
            /// <summary>	
            ///  Set the constant buffers used by the vertex shader pipeline stage.	
            /// </summary>	
            /// <param name="startSlot"> Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1). </param>
            /// <param name="numBuffers"> Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot). </param>
            /// <param name="constantBuffersRef"> Array of constant buffers (see <see cref="SlimDX2.Direct3D11.Buffer"/>) being given to the device. </param>
            /// <unmanaged>void VSSetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[In, Buffer] const ID3D11Buffer** ppConstantBuffers)</unmanaged>
            public  override void SetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D11.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = (IntPtr*)0;
                    if ( constantBuffersRef != null ) {
                        IntPtr* constantBuffersRef__ = stackalloc IntPtr[constantBuffersRef.Length];
                        constantBuffersRef_ = constantBuffersRef__;
                        for (int i = 0; i < constantBuffersRef.Length; i++)                        
                            constantBuffersRef_[i] =  constantBuffersRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 7 * 4, startSlot, numBuffers, constantBuffersRef_);
                }
            }
            
            /// <summary>	
            /// Set a vertex shader to the device.	
            /// </summary>	
            /// <remarks>	
            ///  The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. The maximum number of instances a shader can have is 256.	
            /// </remarks>	
            /// <param name="vertexShaderRef">Pointer to a vertex shader (see <see cref="SlimDX2.Direct3D11.VertexShader"/>). Passing in NULL disables the shader for this pipeline stage.</param>
            /// <param name="classInstancesRef">A pointer to an array of class-instance interfaces (see <see cref="SlimDX2.Direct3D11.ClassInstance"/>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to NULL if the shader does not use any interfaces.</param>
            /// <param name="numClassInstances">The number of class-instance interfaces in the array.</param>
            /// <unmanaged>void VSSetShader([In, Optional] ID3D11VertexShader* pVertexShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[None] UINT NumClassInstances)</unmanaged>
            internal  override void SetShader(SlimDX2.Direct3D11.VertexShader vertexShaderRef, SlimDX2.Direct3D11.ClassInstance[] classInstancesRef, int numClassInstances) {
                unsafe {
                    IntPtr* classInstancesRef_ = (IntPtr*)0;
                    if ( classInstancesRef != null ) {
                        IntPtr* classInstancesRef__ = stackalloc IntPtr[classInstancesRef.Length];
                        classInstancesRef_ = classInstancesRef__;
                        for (int i = 0; i < classInstancesRef.Length; i++)                        
                            classInstancesRef_[i] =  classInstancesRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 11 * 4, (void*)((vertexShaderRef == null)?IntPtr.Zero:vertexShaderRef.NativePointer), classInstancesRef_, numClassInstances);
                }
            }
            
            /// <summary>	
            /// Bind an array of shader resources to the vertex-shader stage.	
            /// </summary>	
            /// <remarks>	
            /// If an overlapping resource view is already bound to an output slot, such as a rendertarget, then this API will fill the destination shader resource slot with NULL.For information about creating shader-resource views, see <see cref="SlimDX2.Direct3D11.Device.CreateShaderResourceView"/>. The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting shader resources to (range is from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</param>
            /// <param name="numViews">Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources (range is from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to set to the device.</param>
            /// <unmanaged>void VSSetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[In, Buffer] const ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
            public  override void SetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D11.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = (IntPtr*)0;
                    if ( shaderResourceViewsRef != null ) {
                        IntPtr* shaderResourceViewsRef__ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                        shaderResourceViewsRef_ = shaderResourceViewsRef__;
                        for (int i = 0; i < shaderResourceViewsRef.Length; i++)                        
                            shaderResourceViewsRef_[i] =  shaderResourceViewsRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 25 * 4, startSlot, numViews, shaderResourceViewsRef_);
                }
            }
            
            /// <summary>	
            ///  Set an array of sampler states to the vertex shader pipeline stage.	
            /// </summary>	
            /// <param name="startSlot"> Index into the device's zero-based array to begin setting samplers to (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1). </param>
            /// <param name="numSamplers"> Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot). </param>
            /// <param name="samplersRef"> Pointer to an array of sampler-state interfaces (see <see cref="SlimDX2.Direct3D11.SamplerState"/>). See Remarks. </param>
            /// <unmanaged>void VSSetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[In, Buffer] const ID3D11SamplerState** ppSamplers)</unmanaged>
            public  override void SetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D11.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = (IntPtr*)0;
                    if ( samplersRef != null ) {
                        IntPtr* samplersRef__ = stackalloc IntPtr[samplersRef.Length];
                        samplersRef_ = samplersRef__;
                        for (int i = 0; i < samplersRef.Length; i++)                        
                            samplersRef_[i] =  samplersRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 26 * 4, startSlot, numSamplers, samplersRef_);
                }
            }
            
            /// <summary>	
            /// Get the constant buffers used by the vertex shader pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name="numBuffers">Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot).</param>
            /// <param name="constantBuffersRef">Array of constant buffer interface pointers (see <see cref="SlimDX2.Direct3D11.Buffer"/>) to be returned by the method.</param>
            /// <unmanaged>void VSGetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[Out, Buffer] ID3D11Buffer** ppConstantBuffers)</unmanaged>
            internal  override void GetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D11.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = stackalloc IntPtr[constantBuffersRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 72 * 4, startSlot, numBuffers, &constantBuffersRef_);
                    for (int i = 0; i < constantBuffersRef.Length; i++)
                        constantBuffersRef[i] = (constantBuffersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Buffer(constantBuffersRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get the vertex shader currently set on the device.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="vertexShaderRef">Address of a pointer to a vertex shader (see <see cref="SlimDX2.Direct3D11.VertexShader"/>) to be returned by the method.</param>
            /// <param name="classInstancesRef">Pointer to an array of class instance interfaces (see <see cref="SlimDX2.Direct3D11.ClassInstance"/>).</param>
            /// <param name="numClassInstancesRef">The number of class-instance elements in the array.</param>
            /// <unmanaged>void VSGetShader([Out] ID3D11VertexShader** ppVertexShader,[Out, Buffer, Optional] ID3D11ClassInstance** ppClassInstances,[InOut, Optional] UINT* pNumClassInstances)</unmanaged>
            internal  override void GetShader(out SlimDX2.Direct3D11.VertexShader vertexShaderRef, SlimDX2.Direct3D11.ClassInstance[] classInstancesRef, ref int numClassInstancesRef) {
                unsafe {
                    IntPtr vertexShaderRef_ = IntPtr.Zero;
                    IntPtr* classInstancesRef_ = stackalloc IntPtr[classInstancesRef.Length];
                    fixed (void* numClassInstancesRef_ = &numClassInstancesRef)
                        SlimDX2.Interop.CalliVoid(_nativePointer, 76 * 4, &vertexShaderRef_, &classInstancesRef_, numClassInstancesRef_);
                    vertexShaderRef = (vertexShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.VertexShader(vertexShaderRef_);	
                    for (int i = 0; i < classInstancesRef.Length; i++)
                        classInstancesRef[i] = (classInstancesRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ClassInstance(classInstancesRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get the vertex shader resources.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin getting shader resources from (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</param>
            /// <param name="numViews">The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to be returned by the device.</param>
            /// <unmanaged>void VSGetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[Out, Buffer] ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
            internal  override void GetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D11.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 84 * 4, startSlot, numViews, &shaderResourceViewsRef_);
                    for (int i = 0; i < shaderResourceViewsRef.Length; i++)
                        shaderResourceViewsRef[i] = (shaderResourceViewsRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ShaderResourceView(shaderResourceViewsRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get an array of sampler states from the vertex shader pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into a zero-based array to begin getting samplers from (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</param>
            /// <param name="numSamplers">Number of samplers to get from a device context. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</param>
            /// <param name="samplersRef">Arry of sampler-state interface pointers (see <see cref="SlimDX2.Direct3D11.SamplerState"/>) to be returned by the device.</param>
            /// <unmanaged>void VSGetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[Out, Buffer] ID3D11SamplerState** ppSamplers)</unmanaged>
            internal  override void GetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D11.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = stackalloc IntPtr[samplersRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 85 * 4, startSlot, numSamplers, &samplersRef_);
                    for (int i = 0; i < samplersRef.Length; i++)
                        samplersRef[i] = (samplersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.SamplerState(samplersRef_[i]);	
                }
            }
        }
      
		/// <summary>Inner interface giving access to PixelShaderStage methods. </summary>
        public PixelShaderStage PixelShader { get; private set; }		
        
        /// <summary>Inner interface PixelShaderStage.</summary>
        /// <unmanaged>ID3D11DeviceContext</unmanaged>
        public partial class PixelShaderStage : CommonShaderStage<PixelShader> {
    
            public PixelShaderStage(IntPtr basePtr) : base(basePtr) {
            }
            
            
            /// <summary>	
            /// Bind an array of shader resources to the pixel shader stage.	
            /// </summary>	
            /// <remarks>	
            /// If an overlapping resource view is already bound to an output slot, such as a rendertarget, then this API will fill the destination shader resource slot with NULL.For information about creating shader-resource views, see <see cref="SlimDX2.Direct3D11.Device.CreateShaderResourceView"/>. The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting shader resources to (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</param>
            /// <param name="numViews">Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to set to the device.</param>
            /// <unmanaged>void PSSetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[In, Buffer] const ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
            public  override void SetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D11.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = (IntPtr*)0;
                    if ( shaderResourceViewsRef != null ) {
                        IntPtr* shaderResourceViewsRef__ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                        shaderResourceViewsRef_ = shaderResourceViewsRef__;
                        for (int i = 0; i < shaderResourceViewsRef.Length; i++)                        
                            shaderResourceViewsRef_[i] =  shaderResourceViewsRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 8 * 4, startSlot, numViews, shaderResourceViewsRef_);
                }
            }
            
            /// <summary>	
            /// Sets a pixel shader to the device.	
            /// </summary>	
            /// <remarks>	
            ///  The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. The maximum number of instances a shader can have is 256.Set ppClassInstances to NULL if no interfaces are used in the shader. If it is non-NULL, the number of class instances must match the number of interfaces used in the shader. Furthermore, each interface pointer must have a corresponding class instance or the assigned shader will be disabled.	
            /// </remarks>	
            /// <param name="pixelShaderRef">Pointer to a pixel shader (see <see cref="SlimDX2.Direct3D11.PixelShader"/>). Passing in NULL disables the shader for this pipeline stage.</param>
            /// <param name="classInstancesRef">A pointer to an array of class-instance interfaces (see <see cref="SlimDX2.Direct3D11.ClassInstance"/>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to NULL if the shader does not use any interfaces.</param>
            /// <param name="numClassInstances">The number of class-instance interfaces in the array.</param>
            /// <unmanaged>void PSSetShader([In, Optional] ID3D11PixelShader* pPixelShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[None] UINT NumClassInstances)</unmanaged>
            internal  override void SetShader(SlimDX2.Direct3D11.PixelShader pixelShaderRef, SlimDX2.Direct3D11.ClassInstance[] classInstancesRef, int numClassInstances) {
                unsafe {
                    IntPtr* classInstancesRef_ = (IntPtr*)0;
                    if ( classInstancesRef != null ) {
                        IntPtr* classInstancesRef__ = stackalloc IntPtr[classInstancesRef.Length];
                        classInstancesRef_ = classInstancesRef__;
                        for (int i = 0; i < classInstancesRef.Length; i++)                        
                            classInstancesRef_[i] =  classInstancesRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 9 * 4, (void*)((pixelShaderRef == null)?IntPtr.Zero:pixelShaderRef.NativePointer), classInstancesRef_, numClassInstances);
                }
            }
            
            /// <summary>	
            /// Set an array of sampler states to the pixel shader pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// Any sampler may be set to NULL; this invokes the default state, which is defined to be the following.StateDefault ValueFilterD3D11_FILTER_MIN_MAG_MIP_LINEARAddressUD3D11_TEXTURE_ADDRESS_CLAMPAddressVD3D11_TEXTURE_ADDRESS_CLAMPAddressWD3D11_TEXTURE_ADDRESS_CLAMPMipLODBias0MaxAnisotropy1ComparisonFuncD3D11_COMPARISON_NEVERBorderColor[0]1.0fBorderColor[1]1.0fBorderColor[2]1.0fBorderColor[3]1.0fMinLOD-FLT_MAXMaxLODFLT_MAX  The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting samplers to (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</param>
            /// <param name="numSamplers">Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</param>
            /// <param name="samplersRef">Pointer to an array of sampler-state interfaces (see <see cref="SlimDX2.Direct3D11.SamplerState"/>). See Remarks.</param>
            /// <unmanaged>void PSSetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[In, Buffer] const ID3D11SamplerState** ppSamplers)</unmanaged>
            public  override void SetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D11.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = (IntPtr*)0;
                    if ( samplersRef != null ) {
                        IntPtr* samplersRef__ = stackalloc IntPtr[samplersRef.Length];
                        samplersRef_ = samplersRef__;
                        for (int i = 0; i < samplersRef.Length; i++)                        
                            samplersRef_[i] =  samplersRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 10 * 4, startSlot, numSamplers, samplersRef_);
                }
            }
            
            /// <summary>	
            /// Set the constant buffers used by the pixel shader pipeline stage.	
            /// </summary>	
            /// <remarks>	
            ///  The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name="numBuffers">Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot).</param>
            /// <param name="constantBuffersRef">Array of constant buffers (see <see cref="SlimDX2.Direct3D11.Buffer"/>) being given to the device.</param>
            /// <unmanaged>void PSSetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[In, Buffer] const ID3D11Buffer** ppConstantBuffers)</unmanaged>
            public  override void SetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D11.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = (IntPtr*)0;
                    if ( constantBuffersRef != null ) {
                        IntPtr* constantBuffersRef__ = stackalloc IntPtr[constantBuffersRef.Length];
                        constantBuffersRef_ = constantBuffersRef__;
                        for (int i = 0; i < constantBuffersRef.Length; i++)                        
                            constantBuffersRef_[i] =  constantBuffersRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 16 * 4, startSlot, numBuffers, constantBuffersRef_);
                }
            }
            
            /// <summary>	
            /// Get the pixel shader resources.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin getting shader resources from (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</param>
            /// <param name="numViews">The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to be returned by the device.</param>
            /// <unmanaged>void PSGetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[Out, Buffer] ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
            internal  override void GetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D11.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 73 * 4, startSlot, numViews, &shaderResourceViewsRef_);
                    for (int i = 0; i < shaderResourceViewsRef.Length; i++)
                        shaderResourceViewsRef[i] = (shaderResourceViewsRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ShaderResourceView(shaderResourceViewsRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get the pixel shader currently set on the device.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="pixelShaderRef">Address of a pointer to a pixel shader (see <see cref="SlimDX2.Direct3D11.PixelShader"/>) to be returned by the method.</param>
            /// <param name="classInstancesRef">Pointer to an array of class instance interfaces (see <see cref="SlimDX2.Direct3D11.ClassInstance"/>).</param>
            /// <param name="numClassInstancesRef">The number of class-instance elements in the array.</param>
            /// <unmanaged>void PSGetShader([Out] ID3D11PixelShader** ppPixelShader,[Out, Buffer, Optional] ID3D11ClassInstance** ppClassInstances,[InOut, Optional] UINT* pNumClassInstances)</unmanaged>
            internal  override void GetShader(out SlimDX2.Direct3D11.PixelShader pixelShaderRef, SlimDX2.Direct3D11.ClassInstance[] classInstancesRef, ref int numClassInstancesRef) {
                unsafe {
                    IntPtr pixelShaderRef_ = IntPtr.Zero;
                    IntPtr* classInstancesRef_ = stackalloc IntPtr[classInstancesRef.Length];
                    fixed (void* numClassInstancesRef_ = &numClassInstancesRef)
                        SlimDX2.Interop.CalliVoid(_nativePointer, 74 * 4, &pixelShaderRef_, &classInstancesRef_, numClassInstancesRef_);
                    pixelShaderRef = (pixelShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.PixelShader(pixelShaderRef_);	
                    for (int i = 0; i < classInstancesRef.Length; i++)
                        classInstancesRef[i] = (classInstancesRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ClassInstance(classInstancesRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get an array of sampler states from the pixel shader pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into a zero-based array to begin getting samplers from (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</param>
            /// <param name="numSamplers">Number of samplers to get from a device context. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</param>
            /// <param name="samplersRef">Arry of sampler-state interface pointers (see <see cref="SlimDX2.Direct3D11.SamplerState"/>) to be returned by the device.</param>
            /// <unmanaged>void PSGetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[Out, Buffer] ID3D11SamplerState** ppSamplers)</unmanaged>
            internal  override void GetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D11.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = stackalloc IntPtr[samplersRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 75 * 4, startSlot, numSamplers, &samplersRef_);
                    for (int i = 0; i < samplersRef.Length; i++)
                        samplersRef[i] = (samplersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.SamplerState(samplersRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get the constant buffers used by the pixel shader pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name="numBuffers">Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot).</param>
            /// <param name="constantBuffersRef">Array of constant buffer interface pointers (see <see cref="SlimDX2.Direct3D11.Buffer"/>) to be returned by the method.</param>
            /// <unmanaged>void PSGetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[Out, Buffer] ID3D11Buffer** ppConstantBuffers)</unmanaged>
            internal  override void GetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D11.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = stackalloc IntPtr[constantBuffersRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 77 * 4, startSlot, numBuffers, &constantBuffersRef_);
                    for (int i = 0; i < constantBuffersRef.Length; i++)
                        constantBuffersRef[i] = (constantBuffersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Buffer(constantBuffersRef_[i]);	
                }
            }
        }
      
		/// <summary>Inner interface giving access to GeometryShaderStage methods. </summary>
        public GeometryShaderStage GeometryShader { get; private set; }		
        
        /// <summary>Inner interface GeometryShaderStage.</summary>
        /// <unmanaged>ID3D11DeviceContext</unmanaged>
        public partial class GeometryShaderStage : CommonShaderStage<GeometryShader> {
    
            public GeometryShaderStage(IntPtr basePtr) : base(basePtr) {
            }
            
            
            /// <summary>	
            /// Set the constant buffers used by the geometry shader pipeline stage.	
            /// </summary>	
            /// <remarks>	
            ///  The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name="numBuffers">Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot).</param>
            /// <param name="constantBuffersRef">Array of constant buffers (see <see cref="SlimDX2.Direct3D11.Buffer"/>) being given to the device.</param>
            /// <unmanaged>void GSSetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[In, Buffer] const ID3D11Buffer** ppConstantBuffers)</unmanaged>
            public  override void SetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D11.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = (IntPtr*)0;
                    if ( constantBuffersRef != null ) {
                        IntPtr* constantBuffersRef__ = stackalloc IntPtr[constantBuffersRef.Length];
                        constantBuffersRef_ = constantBuffersRef__;
                        for (int i = 0; i < constantBuffersRef.Length; i++)                        
                            constantBuffersRef_[i] =  constantBuffersRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 22 * 4, startSlot, numBuffers, constantBuffersRef_);
                }
            }
            
            /// <summary>	
            /// Set a geometry shader to the device.	
            /// </summary>	
            /// <remarks>	
            ///  The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. The maximum number of instances a shader can have is 256.	
            /// </remarks>	
            /// <param name="shaderRef">Pointer to a geometry shader (see <see cref="SlimDX2.Direct3D11.GeometryShader"/>). Passing in NULL disables the shader for this pipeline stage.</param>
            /// <param name="classInstancesRef">A pointer to an array of class-instance interfaces (see <see cref="SlimDX2.Direct3D11.ClassInstance"/>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to NULL if the shader does not use any interfaces.</param>
            /// <param name="numClassInstances">The number of class-instance interfaces in the array.</param>
            /// <unmanaged>void GSSetShader([In, Optional] ID3D11GeometryShader* pShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[None] UINT NumClassInstances)</unmanaged>
            internal  override void SetShader(SlimDX2.Direct3D11.GeometryShader shaderRef, SlimDX2.Direct3D11.ClassInstance[] classInstancesRef, int numClassInstances) {
                unsafe {
                    IntPtr* classInstancesRef_ = (IntPtr*)0;
                    if ( classInstancesRef != null ) {
                        IntPtr* classInstancesRef__ = stackalloc IntPtr[classInstancesRef.Length];
                        classInstancesRef_ = classInstancesRef__;
                        for (int i = 0; i < classInstancesRef.Length; i++)                        
                            classInstancesRef_[i] =  classInstancesRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 23 * 4, (void*)((shaderRef == null)?IntPtr.Zero:shaderRef.NativePointer), classInstancesRef_, numClassInstances);
                }
            }
            
            /// <summary>	
            /// Bind an array of shader resources to the geometry shader stage.	
            /// </summary>	
            /// <remarks>	
            /// If an overlapping resource view is already bound to an output slot, such as a render target, then the method will fill the destination shader resource slot with NULL.For information about creating shader-resource views, see <see cref="SlimDX2.Direct3D11.Device.CreateShaderResourceView"/>. The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting shader resources to (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</param>
            /// <param name="numViews">Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources(ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to set to the device.</param>
            /// <unmanaged>void GSSetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[In, Buffer] const ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
            public  override void SetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D11.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = (IntPtr*)0;
                    if ( shaderResourceViewsRef != null ) {
                        IntPtr* shaderResourceViewsRef__ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                        shaderResourceViewsRef_ = shaderResourceViewsRef__;
                        for (int i = 0; i < shaderResourceViewsRef.Length; i++)                        
                            shaderResourceViewsRef_[i] =  shaderResourceViewsRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 31 * 4, startSlot, numViews, shaderResourceViewsRef_);
                }
            }
            
            /// <summary>	
            /// Set an array of sampler states to the geometry shader pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// Any sampler may be set to NULL; this invokes the default state, which is defined to be the following.	
            /// <code> //Default sampler state:	
            /// D3D11_SAMPLER_DESC SamplerDesc;	
            /// SamplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;	
            /// SamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.MipLODBias = 0;	
            /// SamplerDesc.MaxAnisotropy = 1;	
            /// SamplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;	
            /// SamplerDesc.BorderColor[0] = 1.0f;	
            /// SamplerDesc.BorderColor[1] = 1.0f;	
            /// SamplerDesc.BorderColor[2] = 1.0f;	
            /// SamplerDesc.BorderColor[3] = 1.0f;	
            /// SamplerDesc.MinLOD = -FLT_MAX;	
            /// SamplerDesc.MaxLOD = FLT_MAX; </code>	
            /// 	
            ///  The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting samplers to (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</param>
            /// <param name="numSamplers">Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</param>
            /// <param name="samplersRef">Pointer to an array of sampler-state interfaces (see <see cref="SlimDX2.Direct3D11.SamplerState"/>). See Remarks.</param>
            /// <unmanaged>void GSSetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[In, Buffer] const ID3D11SamplerState** ppSamplers)</unmanaged>
            public  override void SetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D11.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = (IntPtr*)0;
                    if ( samplersRef != null ) {
                        IntPtr* samplersRef__ = stackalloc IntPtr[samplersRef.Length];
                        samplersRef_ = samplersRef__;
                        for (int i = 0; i < samplersRef.Length; i++)                        
                            samplersRef_[i] =  samplersRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 32 * 4, startSlot, numSamplers, samplersRef_);
                }
            }
            
            /// <summary>	
            /// Get the constant buffers used by the geometry shader pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name="numBuffers">Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot).</param>
            /// <param name="constantBuffersRef">Array of constant buffer interface pointers (see <see cref="SlimDX2.Direct3D11.Buffer"/>) to be returned by the method.</param>
            /// <unmanaged>void GSGetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[Out, Buffer] ID3D11Buffer** ppConstantBuffers)</unmanaged>
            internal  override void GetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D11.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = stackalloc IntPtr[constantBuffersRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 81 * 4, startSlot, numBuffers, &constantBuffersRef_);
                    for (int i = 0; i < constantBuffersRef.Length; i++)
                        constantBuffersRef[i] = (constantBuffersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Buffer(constantBuffersRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get the geometry shader currently set on the device.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="geometryShaderRef">Address of a pointer to a geometry shader (see <see cref="SlimDX2.Direct3D11.GeometryShader"/>) to be returned by the method.</param>
            /// <param name="classInstancesRef">Pointer to an array of class instance interfaces (see <see cref="SlimDX2.Direct3D11.ClassInstance"/>).</param>
            /// <param name="numClassInstancesRef">The number of class-instance elements in the array.</param>
            /// <unmanaged>void GSGetShader([Out] ID3D11GeometryShader** ppGeometryShader,[Out, Buffer, Optional] ID3D11ClassInstance** ppClassInstances,[InOut, Optional] UINT* pNumClassInstances)</unmanaged>
            internal  override void GetShader(out SlimDX2.Direct3D11.GeometryShader geometryShaderRef, SlimDX2.Direct3D11.ClassInstance[] classInstancesRef, ref int numClassInstancesRef) {
                unsafe {
                    IntPtr geometryShaderRef_ = IntPtr.Zero;
                    IntPtr* classInstancesRef_ = stackalloc IntPtr[classInstancesRef.Length];
                    fixed (void* numClassInstancesRef_ = &numClassInstancesRef)
                        SlimDX2.Interop.CalliVoid(_nativePointer, 82 * 4, &geometryShaderRef_, &classInstancesRef_, numClassInstancesRef_);
                    geometryShaderRef = (geometryShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.GeometryShader(geometryShaderRef_);	
                    for (int i = 0; i < classInstancesRef.Length; i++)
                        classInstancesRef[i] = (classInstancesRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ClassInstance(classInstancesRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get the geometry shader resources.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin getting shader resources from (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</param>
            /// <param name="numViews">The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to be returned by the device.</param>
            /// <unmanaged>void GSGetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[Out, Buffer] ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
            internal  override void GetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D11.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 87 * 4, startSlot, numViews, &shaderResourceViewsRef_);
                    for (int i = 0; i < shaderResourceViewsRef.Length; i++)
                        shaderResourceViewsRef[i] = (shaderResourceViewsRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ShaderResourceView(shaderResourceViewsRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get an array of sampler state interfaces from the geometry shader pipeline stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into a zero-based array to begin getting samplers from (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</param>
            /// <param name="numSamplers">Number of samplers to get from a device context. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</param>
            /// <param name="samplersRef">Pointer to an array of sampler-state interfaces (see <see cref="SlimDX2.Direct3D11.SamplerState"/>).</param>
            /// <unmanaged>void GSGetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[Out, Buffer] ID3D11SamplerState** ppSamplers)</unmanaged>
            internal  override void GetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D11.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = stackalloc IntPtr[samplersRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 88 * 4, startSlot, numSamplers, &samplersRef_);
                    for (int i = 0; i < samplersRef.Length; i++)
                        samplersRef[i] = (samplersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.SamplerState(samplersRef_[i]);	
                }
            }
        }
      
		/// <summary>Inner interface giving access to StreamOutputStage methods. </summary>
        public StreamOutputStage StreamOutput { get; private set; }		
        
        /// <summary>Inner interface StreamOutputStage.</summary>
        /// <unmanaged>ID3D11DeviceContext</unmanaged>
        public partial class StreamOutputStage : SlimDX2.CppObject {	
    
    		public StreamOutputStage(IntPtr basePtr) : base(basePtr) {
            }
            
            
            /// <summary>	
            /// Set the target output buffers for the stream-output stage of the pipeline.	
            /// </summary>	
            /// <remarks>	
            /// An offset of -1 will cause the stream output buffer to be appended, continuing after the last location written to the buffer in a previous stream output pass.Calling this method using a buffer that is currently bound for writing will effectively bind NULL instead because a buffer cannot be bound as both an input and an output at the same time.The debug layer will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will not prevent invalid data from being used by the runtime. The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="numBuffers">The number of buffer to bind to the device. A maximum of four output buffers can be set. If less than four are defined by the call, the remaining buffer slots are set to NULL. See Remarks.</param>
            /// <param name="sOTargetsRef">The array of output buffers (see <see cref="SlimDX2.Direct3D11.Buffer"/>) to bind to the device. The buffers must have been created with the <see cref="SlimDX2.Direct3D11.BindFlags.StreamOutput"/> flag.</param>
            /// <param name="offsetsRef">Array of offsets to the output buffers from ppSOTargets, one offset for each buffer. The offset values must be in bytes.</param>
            /// <unmanaged>void SOSetTargets([In] UINT NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppSOTargets,[In, Buffer, Optional] const UINT* pOffsets)</unmanaged>
            public void SetTargets(int numBuffers, SlimDX2.Direct3D11.Buffer[] sOTargetsRef, int[] offsetsRef) {
                unsafe {
                    IntPtr* sOTargetsRef_ = (IntPtr*)0;
                    if ( sOTargetsRef != null ) {
                        IntPtr* sOTargetsRef__ = stackalloc IntPtr[sOTargetsRef.Length];
                        sOTargetsRef_ = sOTargetsRef__;
                        for (int i = 0; i < sOTargetsRef.Length; i++)                        
                            sOTargetsRef_[i] =  sOTargetsRef[i].NativePointer;
                    }
                    int[] offsetsRef__ = offsetsRef ?? new int[1];
                    fixed (void* offsetsRef_ = &offsetsRef__[0])
                        SlimDX2.Interop.CalliVoid(_nativePointer, 37 * 4, numBuffers, sOTargetsRef_, offsetsRef==null?(void*)IntPtr.Zero:offsetsRef_);
                }
            }
            
            /// <summary>	
            /// Get the target output buffers for the stream-output stage of the pipeline.	
            /// </summary>	
            /// <remarks>	
            /// A maximum of four output buffers can be retrieved.The offsets to the output buffers pointed to in the returned ppSOTargets array may be assumed to be -1 (append), as defined for use in <see cref="SlimDX2.Direct3D11.DeviceContext.StreamOutputStage.SetTargets"/>.Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="numBuffers">Number of buffers to get.</param>
            /// <param name="sOTargetsRef">An array of output buffers (see <see cref="SlimDX2.Direct3D11.Buffer"/>) to be retrieved from the device.</param>
            /// <unmanaged>void SOGetTargets([In] UINT NumBuffers,[Out, Buffer] ID3D11Buffer** ppSOTargets)</unmanaged>
            public void GetTargets(int numBuffers, SlimDX2.Direct3D11.Buffer[] sOTargetsRef) {
                unsafe {
                    IntPtr* sOTargetsRef_ = stackalloc IntPtr[sOTargetsRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 93 * 4, numBuffers, &sOTargetsRef_);
                    for (int i = 0; i < sOTargetsRef.Length; i++)
                        sOTargetsRef[i] = (sOTargetsRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Buffer(sOTargetsRef_[i]);	
                }
            }
        }
      
		/// <summary>Inner interface giving access to DomainShaderStage methods. </summary>
        public DomainShaderStage DomainShader { get; private set; }		
        
        /// <summary>Inner interface DomainShaderStage.</summary>
        /// <unmanaged>ID3D11DeviceContext</unmanaged>
        public partial class DomainShaderStage : CommonShaderStage<DomainShader> {
    
            public DomainShaderStage(IntPtr basePtr) : base(basePtr) {
            }
            
            
            /// <summary>	
            /// Bind an array of shader resources to the domain-shader stage.	
            /// </summary>	
            /// <remarks>	
            /// If an overlapping resource view is already bound to an output slot, such as a render target, then the method will fill the destination shader resource slot with NULL.For information about creating shader-resource views, see <see cref="SlimDX2.Direct3D11.Device.CreateShaderResourceView"/>. The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting shader resources to (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</param>
            /// <param name="numViews">Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources(ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to set to the device.</param>
            /// <unmanaged>void DSSetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[In, Buffer] const ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
            public  override void SetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D11.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = (IntPtr*)0;
                    if ( shaderResourceViewsRef != null ) {
                        IntPtr* shaderResourceViewsRef__ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                        shaderResourceViewsRef_ = shaderResourceViewsRef__;
                        for (int i = 0; i < shaderResourceViewsRef.Length; i++)                        
                            shaderResourceViewsRef_[i] =  shaderResourceViewsRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 63 * 4, startSlot, numViews, shaderResourceViewsRef_);
                }
            }
            
            /// <summary>	
            /// Set a domain shader to the device.	
            /// </summary>	
            /// <remarks>	
            ///  The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. The maximum number of instances a shader can have is 256.	
            /// </remarks>	
            /// <param name="domainShaderRef">Pointer to a domain shader (see <see cref="SlimDX2.Direct3D11.DomainShader"/>). Passing in NULL disables the shader for this pipeline stage.</param>
            /// <param name="classInstancesRef">A pointer to an array of class-instance interfaces (see <see cref="SlimDX2.Direct3D11.ClassInstance"/>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to NULL if the shader does not use any interfaces.</param>
            /// <param name="numClassInstances">The number of class-instance interfaces in the array.</param>
            /// <unmanaged>void DSSetShader([In, Optional] ID3D11DomainShader* pDomainShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[None] UINT NumClassInstances)</unmanaged>
            internal  override void SetShader(SlimDX2.Direct3D11.DomainShader domainShaderRef, SlimDX2.Direct3D11.ClassInstance[] classInstancesRef, int numClassInstances) {
                unsafe {
                    IntPtr* classInstancesRef_ = (IntPtr*)0;
                    if ( classInstancesRef != null ) {
                        IntPtr* classInstancesRef__ = stackalloc IntPtr[classInstancesRef.Length];
                        classInstancesRef_ = classInstancesRef__;
                        for (int i = 0; i < classInstancesRef.Length; i++)                        
                            classInstancesRef_[i] =  classInstancesRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 64 * 4, (void*)((domainShaderRef == null)?IntPtr.Zero:domainShaderRef.NativePointer), classInstancesRef_, numClassInstances);
                }
            }
            
            /// <summary>	
            /// Set an array of sampler states to the domain-shader stage.	
            /// </summary>	
            /// <remarks>	
            /// Any sampler may be set to NULL; this invokes the default state, which is defined to be the following.	
            /// <code> //Default sampler state:	
            /// D3D11_SAMPLER_DESC SamplerDesc;	
            /// SamplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;	
            /// SamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.MipLODBias = 0;	
            /// SamplerDesc.MaxAnisotropy = 1;	
            /// SamplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;	
            /// SamplerDesc.BorderColor[0] = 1.0f;	
            /// SamplerDesc.BorderColor[1] = 1.0f;	
            /// SamplerDesc.BorderColor[2] = 1.0f;	
            /// SamplerDesc.BorderColor[3] = 1.0f;	
            /// SamplerDesc.MinLOD = -FLT_MAX;	
            /// SamplerDesc.MaxLOD = FLT_MAX; </code>	
            /// 	
            ///  The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting samplers to (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</param>
            /// <param name="numSamplers">Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</param>
            /// <param name="samplersRef">Pointer to an array of sampler-state interfaces (see <see cref="SlimDX2.Direct3D11.SamplerState"/>). See Remarks.</param>
            /// <unmanaged>void DSSetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[In, Buffer] const ID3D11SamplerState** ppSamplers)</unmanaged>
            public  override void SetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D11.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = (IntPtr*)0;
                    if ( samplersRef != null ) {
                        IntPtr* samplersRef__ = stackalloc IntPtr[samplersRef.Length];
                        samplersRef_ = samplersRef__;
                        for (int i = 0; i < samplersRef.Length; i++)                        
                            samplersRef_[i] =  samplersRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 65 * 4, startSlot, numSamplers, samplersRef_);
                }
            }
            
            /// <summary>	
            /// Set the constant buffers used by the domain-shader stage.	
            /// </summary>	
            /// <remarks>	
            ///  The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="startSlot">Index into the zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name="numBuffers">Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot).</param>
            /// <param name="constantBuffersRef">Array of constant buffers (see <see cref="SlimDX2.Direct3D11.Buffer"/>) being given to the device.</param>
            /// <unmanaged>void DSSetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[In, Buffer] const ID3D11Buffer** ppConstantBuffers)</unmanaged>
            public  override void SetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D11.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = (IntPtr*)0;
                    if ( constantBuffersRef != null ) {
                        IntPtr* constantBuffersRef__ = stackalloc IntPtr[constantBuffersRef.Length];
                        constantBuffersRef_ = constantBuffersRef__;
                        for (int i = 0; i < constantBuffersRef.Length; i++)                        
                            constantBuffersRef_[i] =  constantBuffersRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 66 * 4, startSlot, numBuffers, constantBuffersRef_);
                }
            }
            
            /// <summary>	
            /// Get the domain-shader resources.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin getting shader resources from (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</param>
            /// <param name="numViews">The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to be returned by the device.</param>
            /// <unmanaged>void DSGetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[Out, Buffer] ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
            internal  override void GetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D11.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 101 * 4, startSlot, numViews, &shaderResourceViewsRef_);
                    for (int i = 0; i < shaderResourceViewsRef.Length; i++)
                        shaderResourceViewsRef[i] = (shaderResourceViewsRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ShaderResourceView(shaderResourceViewsRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get the domain shader currently set on the device.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="domainShaderRef">Address of a pointer to a domain shader (see <see cref="SlimDX2.Direct3D11.DomainShader"/>) to be returned by the method.</param>
            /// <param name="classInstancesRef">Pointer to an array of class instance interfaces (see <see cref="SlimDX2.Direct3D11.ClassInstance"/>).</param>
            /// <param name="numClassInstancesRef">The number of class-instance elements in the array.</param>
            /// <unmanaged>void DSGetShader([Out] ID3D11DomainShader** ppDomainShader,[Out, Buffer, Optional] ID3D11ClassInstance** ppClassInstances,[InOut, Optional] UINT* pNumClassInstances)</unmanaged>
            internal  override void GetShader(out SlimDX2.Direct3D11.DomainShader domainShaderRef, SlimDX2.Direct3D11.ClassInstance[] classInstancesRef, ref int numClassInstancesRef) {
                unsafe {
                    IntPtr domainShaderRef_ = IntPtr.Zero;
                    IntPtr* classInstancesRef_ = stackalloc IntPtr[classInstancesRef.Length];
                    fixed (void* numClassInstancesRef_ = &numClassInstancesRef)
                        SlimDX2.Interop.CalliVoid(_nativePointer, 102 * 4, &domainShaderRef_, &classInstancesRef_, numClassInstancesRef_);
                    domainShaderRef = (domainShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.DomainShader(domainShaderRef_);	
                    for (int i = 0; i < classInstancesRef.Length; i++)
                        classInstancesRef[i] = (classInstancesRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ClassInstance(classInstancesRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get an array of sampler state interfaces from the domain-shader stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into a zero-based array to begin getting samplers from (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</param>
            /// <param name="numSamplers">Number of samplers to get from a device context. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</param>
            /// <param name="samplersRef">Pointer to an array of sampler-state interfaces (see <see cref="SlimDX2.Direct3D11.SamplerState"/>).</param>
            /// <unmanaged>void DSGetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[Out, Buffer] ID3D11SamplerState** ppSamplers)</unmanaged>
            internal  override void GetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D11.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = stackalloc IntPtr[samplersRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 103 * 4, startSlot, numSamplers, &samplersRef_);
                    for (int i = 0; i < samplersRef.Length; i++)
                        samplersRef[i] = (samplersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.SamplerState(samplersRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get the constant buffers used by the domain-shader stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name="numBuffers">Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot).</param>
            /// <param name="constantBuffersRef">Array of constant buffer interface pointers (see <see cref="SlimDX2.Direct3D11.Buffer"/>) to be returned by the method.</param>
            /// <unmanaged>void DSGetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[Out, Buffer] ID3D11Buffer** ppConstantBuffers)</unmanaged>
            internal  override void GetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D11.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = stackalloc IntPtr[constantBuffersRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 104 * 4, startSlot, numBuffers, &constantBuffersRef_);
                    for (int i = 0; i < constantBuffersRef.Length; i++)
                        constantBuffersRef[i] = (constantBuffersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Buffer(constantBuffersRef_[i]);	
                }
            }
        }
      
		/// <summary>Inner interface giving access to HullShaderStage methods. </summary>
        public HullShaderStage HullShader { get; private set; }		
        
        /// <summary>Inner interface HullShaderStage.</summary>
        /// <unmanaged>ID3D11DeviceContext</unmanaged>
        public partial class HullShaderStage : CommonShaderStage<HullShader> {
    
            public HullShaderStage(IntPtr basePtr) : base(basePtr) {
            }
            
            
            /// <summary>	
            /// Bind an array of shader resources to the {{hull-shader stage}}.	
            /// </summary>	
            /// <remarks>	
            /// If an overlapping resource view is already bound to an output slot, such as a render target, then the method will fill the destination shader resource slot with NULL.For information about creating shader-resource views, see <see cref="SlimDX2.Direct3D11.Device.CreateShaderResourceView"/>. The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting shader resources to (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</param>
            /// <param name="numViews">Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources(ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to set to the device.</param>
            /// <unmanaged>void HSSetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[In, Buffer] const ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
            public  override void SetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D11.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = (IntPtr*)0;
                    if ( shaderResourceViewsRef != null ) {
                        IntPtr* shaderResourceViewsRef__ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                        shaderResourceViewsRef_ = shaderResourceViewsRef__;
                        for (int i = 0; i < shaderResourceViewsRef.Length; i++)                        
                            shaderResourceViewsRef_[i] =  shaderResourceViewsRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 59 * 4, startSlot, numViews, shaderResourceViewsRef_);
                }
            }
            
            /// <summary>	
            /// Set a hull shader to the device.	
            /// </summary>	
            /// <remarks>	
            ///  The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. The maximum number of instances a shader can have is 256.	
            /// </remarks>	
            /// <param name="hullShaderRef">Pointer to a hull shader (see <see cref="SlimDX2.Direct3D11.HullShader"/>). Passing in NULL disables the shader for this pipeline stage.</param>
            /// <param name="classInstancesRef">A pointer to an array of class-instance interfaces (see <see cref="SlimDX2.Direct3D11.ClassInstance"/>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to NULL if the shader does not use any interfaces.</param>
            /// <param name="numClassInstances">The number of class-instance interfaces in the array.</param>
            /// <unmanaged>void HSSetShader([In, Optional] ID3D11HullShader* pHullShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[None] UINT NumClassInstances)</unmanaged>
            internal  override void SetShader(SlimDX2.Direct3D11.HullShader hullShaderRef, SlimDX2.Direct3D11.ClassInstance[] classInstancesRef, int numClassInstances) {
                unsafe {
                    IntPtr* classInstancesRef_ = (IntPtr*)0;
                    if ( classInstancesRef != null ) {
                        IntPtr* classInstancesRef__ = stackalloc IntPtr[classInstancesRef.Length];
                        classInstancesRef_ = classInstancesRef__;
                        for (int i = 0; i < classInstancesRef.Length; i++)                        
                            classInstancesRef_[i] =  classInstancesRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 60 * 4, (void*)((hullShaderRef == null)?IntPtr.Zero:hullShaderRef.NativePointer), classInstancesRef_, numClassInstances);
                }
            }
            
            /// <summary>	
            /// Set an array of sampler states to the {{hull-shader stage}}.	
            /// </summary>	
            /// <remarks>	
            /// Any sampler may be set to NULL; this invokes the default state, which is defined to be the following.	
            /// <code> //Default sampler state:	
            /// D3D11_SAMPLER_DESC SamplerDesc;	
            /// SamplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;	
            /// SamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.MipLODBias = 0;	
            /// SamplerDesc.MaxAnisotropy = 1;	
            /// SamplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;	
            /// SamplerDesc.BorderColor[0] = 1.0f;	
            /// SamplerDesc.BorderColor[1] = 1.0f;	
            /// SamplerDesc.BorderColor[2] = 1.0f;	
            /// SamplerDesc.BorderColor[3] = 1.0f;	
            /// SamplerDesc.MinLOD = -FLT_MAX;	
            /// SamplerDesc.MaxLOD = FLT_MAX; </code>	
            /// 	
            ///  The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="startSlot">Index into the zero-based array to begin setting samplers to (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</param>
            /// <param name="numSamplers">Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</param>
            /// <param name="samplersRef">Pointer to an array of sampler-state interfaces (see <see cref="SlimDX2.Direct3D11.SamplerState"/>). See Remarks.</param>
            /// <unmanaged>void HSSetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[In, Buffer] const ID3D11SamplerState** ppSamplers)</unmanaged>
            public  override void SetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D11.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = (IntPtr*)0;
                    if ( samplersRef != null ) {
                        IntPtr* samplersRef__ = stackalloc IntPtr[samplersRef.Length];
                        samplersRef_ = samplersRef__;
                        for (int i = 0; i < samplersRef.Length; i++)                        
                            samplersRef_[i] =  samplersRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 61 * 4, startSlot, numSamplers, samplersRef_);
                }
            }
            
            /// <summary>	
            /// Set the constant buffers used by the {{hull-shader stage}}.	
            /// </summary>	
            /// <remarks>	
            ///  The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name="numBuffers">Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot).</param>
            /// <param name="constantBuffersRef">Array of constant buffers (see <see cref="SlimDX2.Direct3D11.Buffer"/>) being given to the device.</param>
            /// <unmanaged>void HSSetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[In, Buffer] const ID3D11Buffer** ppConstantBuffers)</unmanaged>
            public  override void SetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D11.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = (IntPtr*)0;
                    if ( constantBuffersRef != null ) {
                        IntPtr* constantBuffersRef__ = stackalloc IntPtr[constantBuffersRef.Length];
                        constantBuffersRef_ = constantBuffersRef__;
                        for (int i = 0; i < constantBuffersRef.Length; i++)                        
                            constantBuffersRef_[i] =  constantBuffersRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 62 * 4, startSlot, numBuffers, constantBuffersRef_);
                }
            }
            
            /// <summary>	
            /// Get the hull-shader resources.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin getting shader resources from (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</param>
            /// <param name="numViews">The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to be returned by the device.</param>
            /// <unmanaged>void HSGetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[Out, Buffer] ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
            internal  override void GetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D11.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 97 * 4, startSlot, numViews, &shaderResourceViewsRef_);
                    for (int i = 0; i < shaderResourceViewsRef.Length; i++)
                        shaderResourceViewsRef[i] = (shaderResourceViewsRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ShaderResourceView(shaderResourceViewsRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get the hull shader currently set on the device.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="hullShaderRef">Address of a pointer to a hull shader (see <see cref="SlimDX2.Direct3D11.HullShader"/>) to be returned by the method.</param>
            /// <param name="classInstancesRef">Pointer to an array of class instance interfaces (see <see cref="SlimDX2.Direct3D11.ClassInstance"/>).</param>
            /// <param name="numClassInstancesRef">The number of class-instance elements in the array.</param>
            /// <unmanaged>void HSGetShader([Out] ID3D11HullShader** ppHullShader,[Out, Buffer, Optional] ID3D11ClassInstance** ppClassInstances,[InOut, Optional] UINT* pNumClassInstances)</unmanaged>
            internal  override void GetShader(out SlimDX2.Direct3D11.HullShader hullShaderRef, SlimDX2.Direct3D11.ClassInstance[] classInstancesRef, ref int numClassInstancesRef) {
                unsafe {
                    IntPtr hullShaderRef_ = IntPtr.Zero;
                    IntPtr* classInstancesRef_ = stackalloc IntPtr[classInstancesRef.Length];
                    fixed (void* numClassInstancesRef_ = &numClassInstancesRef)
                        SlimDX2.Interop.CalliVoid(_nativePointer, 98 * 4, &hullShaderRef_, &classInstancesRef_, numClassInstancesRef_);
                    hullShaderRef = (hullShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.HullShader(hullShaderRef_);	
                    for (int i = 0; i < classInstancesRef.Length; i++)
                        classInstancesRef[i] = (classInstancesRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ClassInstance(classInstancesRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get an array of sampler state interfaces from the {{hull-shader stage}}.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into a zero-based array to begin getting samplers from (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</param>
            /// <param name="numSamplers">Number of samplers to get from a device context. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</param>
            /// <param name="samplersRef">Pointer to an array of sampler-state interfaces (see <see cref="SlimDX2.Direct3D11.SamplerState"/>).</param>
            /// <unmanaged>void HSGetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[Out, Buffer] ID3D11SamplerState** ppSamplers)</unmanaged>
            internal  override void GetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D11.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = stackalloc IntPtr[samplersRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 99 * 4, startSlot, numSamplers, &samplersRef_);
                    for (int i = 0; i < samplersRef.Length; i++)
                        samplersRef[i] = (samplersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.SamplerState(samplersRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get the constant buffers used by the {{hull-shader stage}}.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name="numBuffers">Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot).</param>
            /// <param name="constantBuffersRef">Array of constant buffer interface pointers (see <see cref="SlimDX2.Direct3D11.Buffer"/>) to be returned by the method.</param>
            /// <unmanaged>void HSGetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[Out, Buffer] ID3D11Buffer** ppConstantBuffers)</unmanaged>
            internal  override void GetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D11.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = stackalloc IntPtr[constantBuffersRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 100 * 4, startSlot, numBuffers, &constantBuffersRef_);
                    for (int i = 0; i < constantBuffersRef.Length; i++)
                        constantBuffersRef[i] = (constantBuffersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Buffer(constantBuffersRef_[i]);	
                }
            }
        }
      
		/// <summary>Inner interface giving access to RasterizerStage methods. </summary>
        public RasterizerStage Rasterizer { get; private set; }		
        
        /// <summary>Inner interface RasterizerStage.</summary>
        /// <unmanaged>ID3D11DeviceContext</unmanaged>
        public partial class RasterizerStage : SlimDX2.CppObject {	
    
    		public RasterizerStage(IntPtr basePtr) : base(basePtr) {
            }
            
            
            /// <summary>	
            /// Get the {{rasterizer state}} from the rasterizer stage of the pipeline.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <unmanaged>void RSGetState([Out] ID3D11RasterizerState** ppRasterizerState)</unmanaged>
            public SlimDX2.Direct3D11.RasterizerState State {
                    get { SlimDX2.Direct3D11.RasterizerState __output__; GetState(out __output__); return __output__; }
                    set { SetState(value); }
            }
            
            /// <summary>	
            /// Set the {{rasterizer state}} for the rasterizer stage of the pipeline.	
            /// </summary>	
            /// <remarks>	
            /// To create a rasterizer state interface, call <see cref="SlimDX2.Direct3D11.Device.CreateRasterizerState"/>. The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="rasterizerStateRef">Pointer to a rasterizer-state interface (see <see cref="SlimDX2.Direct3D11.RasterizerState"/>) to bind to the pipeline.</param>
            /// <unmanaged>void RSSetState([In, Optional] ID3D11RasterizerState* pRasterizerState)</unmanaged>
            internal void SetState(SlimDX2.Direct3D11.RasterizerState rasterizerStateRef) {
                unsafe {
                    SlimDX2.Interop.CalliVoid(_nativePointer, 43 * 4, (void*)((rasterizerStateRef == null)?IntPtr.Zero:rasterizerStateRef.NativePointer));
                }
            }
            
            /// <summary>	
            /// Bind an array of viewports to the rasterizer stage of the pipeline.	
            /// </summary>	
            /// <remarks>	
            /// All viewports must be set atomically as one operation. Any viewports not defined by the call are disabled.Which viewport to use is determined by the SV_ViewportArrayIndex semantic output by a geometry shader; if a geometry shader does not specify the semantic, Direct3D will use the first viewport in the array.	
            /// </remarks>	
            /// <param name="numViewports">Number of viewports to bind.</param>
            /// <param name="viewportsRef">An array of <see cref="SlimDX2.Direct3D11.Viewport"/> structures to bind to the device. See the structure page for details about how the viewport size is dependent on the device feature level which has changed between Direct3D 11 and Direct3D 10.</param>
            /// <unmanaged>void RSSetViewports([In] UINT NumViewports,[In, Buffer, Optional] const D3D11_VIEWPORT* pViewports)</unmanaged>
            public void SetViewports(int numViewports, SlimDX2.Direct3D11.Viewport[] viewportsRef) {
                unsafe {
                    SlimDX2.Direct3D11.Viewport[] viewportsRef__ = viewportsRef ?? new SlimDX2.Direct3D11.Viewport[1];
                    fixed (void* viewportsRef_ = &viewportsRef__[0])
                        SlimDX2.Interop.CalliVoid(_nativePointer, 44 * 4, numViewports, viewportsRef==null?(void*)IntPtr.Zero:viewportsRef_);
                }
            }
            
            /// <summary>	
            /// Bind an array of scissor rectangles to the rasterizer stage.	
            /// </summary>	
            /// <remarks>	
            /// All scissor rects must be set atomically as one operation. Any scissor rects not defined by the call are disabled.The scissor rectangles will only be used if ScissorEnable is set to true in the rasterizer state (see <see cref="SlimDX2.Direct3D11.RasterizerStateDescription"/>).Which scissor rectangle to use is determined by the SV_ViewportArrayIndex semantic output by a geometry shader (see shader semantic syntax). If a geometry shader does not make use of the SV_ViewportArrayIndex semantic then Direct3D will use the first scissor rectangle in the array.Each scissor rectangle in the array corresponds to a viewport in an array of viewports (see <see cref="SlimDX2.Direct3D11.DeviceContext.RasterizerStage.SetViewports"/>).	
            /// </remarks>	
            /// <param name="numRects">Number of scissor rectangles to bind.</param>
            /// <param name="rectsRef">An array of scissor rectangles (see <see cref="SlimDX2.Rectangle"/>).</param>
            /// <unmanaged>void RSSetScissorRects([In] UINT NumRects,[In, Buffer, Optional] const D3D11_RECT* pRects)</unmanaged>
            public void SetScissorRects(int numRects, SlimDX2.Rectangle[] rectsRef) {
                unsafe {
                    SlimDX2.Rectangle[] rectsRef__ = rectsRef ?? new SlimDX2.Rectangle[1];
                    fixed (void* rectsRef_ = &rectsRef__[0])
                        SlimDX2.Interop.CalliVoid(_nativePointer, 45 * 4, numRects, rectsRef==null?(void*)IntPtr.Zero:rectsRef_);
                }
            }
            
            /// <summary>	
            /// Get the {{rasterizer state}} from the rasterizer stage of the pipeline.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="rasterizerStateRef">Address of a pointer to a rasterizer-state interface (see <see cref="SlimDX2.Direct3D11.RasterizerState"/>) to fill with information from the device.</param>
            /// <unmanaged>void RSGetState([Out] ID3D11RasterizerState** ppRasterizerState)</unmanaged>
            internal void GetState(out SlimDX2.Direct3D11.RasterizerState rasterizerStateRef) {
                unsafe {
                    IntPtr rasterizerStateRef_ = IntPtr.Zero;
                    SlimDX2.Interop.CalliVoid(_nativePointer, 94 * 4, &rasterizerStateRef_);
                    rasterizerStateRef = (rasterizerStateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.RasterizerState(rasterizerStateRef_);	
                }
            }
            
            /// <summary>	
            /// Get the array of viewports bound to the rasterizer stage	
            /// </summary>	
            /// <param name="numViewportsRef">The input specifies the number of viewports (ranges from 0 to D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE)  in pViewports, the output contains the actual number of viewports returned.   If pViewports is NULL, this will be filled with the number of viewports currently bound.</param>
            /// <param name="viewportsRef">An array of <see cref="SlimDX2.Direct3D11.Viewport"/> structures that are bound to the device. If the number of viewports (in pNumViewports) is  greater than the actual number of viewports currently bound, then unused members of the array will contain 0.  See the structure page for details about how the viewport size is dependent on the device feature level which has changed between Direct3D 11  and Direct3D 10.</param>
            /// <unmanaged>void RSGetViewports([InOut] UINT* pNumViewports,[Out, Buffer, Optional] D3D11_VIEWPORT* pViewports)</unmanaged>
            public void GetViewports(ref int numViewportsRef, SlimDX2.Direct3D11.Viewport[] viewportsRef) {
                unsafe {
                    SlimDX2.Direct3D11.Viewport[] viewportsRef__ = viewportsRef ?? new SlimDX2.Direct3D11.Viewport[1];
                    fixed (void* numViewportsRef_ = &numViewportsRef)
                        fixed (void* viewportsRef_ = &viewportsRef__[0])
                            SlimDX2.Interop.CalliVoid(_nativePointer, 95 * 4, numViewportsRef_, viewportsRef==null?(void*)IntPtr.Zero:viewportsRef_);
                }
            }
            
            /// <summary>	
            /// Get the array of scissor rectangles bound to the rasterizer stage.	
            /// </summary>	
            /// <param name="numRectsRef">The number of scissor rectangles (ranges between 0 and D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE) bound; set pRects to NULL to use pNumRects to see how many rectangles would be returned.</param>
            /// <param name="rectsRef">An array of scissor rectangles (see <see cref="SlimDX2.Rectangle"/>). If NumRects is greater than the number of scissor rects currently bound, then unused members of the array will contain 0.</param>
            /// <unmanaged>void RSGetScissorRects([InOut] UINT* pNumRects,[Out, Buffer, Optional] D3D11_RECT* pRects)</unmanaged>
            public void GetScissorRects(ref int numRectsRef, SlimDX2.Rectangle[] rectsRef) {
                unsafe {
                    SlimDX2.Rectangle[] rectsRef__ = rectsRef ?? new SlimDX2.Rectangle[1];
                    fixed (void* numRectsRef_ = &numRectsRef)
                        fixed (void* rectsRef_ = &rectsRef__[0])
                            SlimDX2.Interop.CalliVoid(_nativePointer, 96 * 4, numRectsRef_, rectsRef==null?(void*)IntPtr.Zero:rectsRef_);
                }
            }
        }
      
		/// <summary>Inner interface giving access to OutputMergerStage methods. </summary>
        public OutputMergerStage OutputMerger { get; private set; }		
        
        /// <summary>Inner interface OutputMergerStage.</summary>
        /// <unmanaged>ID3D11DeviceContext</unmanaged>
        public partial class OutputMergerStage : SlimDX2.CppObject {	
    
    		public OutputMergerStage(IntPtr basePtr) : base(basePtr) {
            }
            
            
            /// <summary>	
            /// Bind one or more render targets atomically and the depth-stencil buffer to the output-merger stage.	
            /// </summary>	
            /// <remarks>	
            /// The maximum number of active render targets a device can have active at any given time is set by a #define in D3D11.h called  D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT. It is invalid to try to set the same subresource to multiple render target slots.  Any render targets not defined by this call are set to NULL.If any subresources are also currently bound for reading in a different stage or writing (perhaps in a different part of the pipeline),  those bind points will be NULL'ed out to prevent the same subresource from being read and written simultaneously in a single rendering operation. The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. If the render-target views were created from an array resource type, then all of the render-target views must have the same array size.   This restriction also applies to the depth-stencil view, its array size must match that of the render-target views being bound.	
            /// </remarks>	
            /// <param name="numViews">Number of render targets to bind (ranges between 0 and D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT).</param>
            /// <param name="renderTargetViewsRef">Pointer to an array of render targets (see <see cref="SlimDX2.Direct3D11.RenderTargetView"/>) to bind to the device.  If this parameter is NULL, no render targets are bound. See Remarks.</param>
            /// <param name="depthStencilViewRef">Pointer to a depth-stencil view (see <see cref="SlimDX2.Direct3D11.DepthStencilView"/>) to bind to the device.  If this parameter is NULL, the depth-stencil state is not bound.</param>
            /// <unmanaged>void OMSetRenderTargets([In] UINT NumViews,[In, Buffer, Optional] const ID3D11RenderTargetView** ppRenderTargetViews,[In, Optional] ID3D11DepthStencilView* pDepthStencilView)</unmanaged>
            public void SetRenderTargets(int numViews, SlimDX2.Direct3D11.RenderTargetView[] renderTargetViewsRef, SlimDX2.Direct3D11.DepthStencilView depthStencilViewRef) {
                unsafe {
                    IntPtr* renderTargetViewsRef_ = (IntPtr*)0;
                    if ( renderTargetViewsRef != null ) {
                        IntPtr* renderTargetViewsRef__ = stackalloc IntPtr[renderTargetViewsRef.Length];
                        renderTargetViewsRef_ = renderTargetViewsRef__;
                        for (int i = 0; i < renderTargetViewsRef.Length; i++)                        
                            renderTargetViewsRef_[i] =  renderTargetViewsRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 33 * 4, numViews, renderTargetViewsRef_, (void*)((depthStencilViewRef == null)?IntPtr.Zero:depthStencilViewRef.NativePointer));
                }
            }
            
            /// <summary>	
            /// Binds resources to the output-merger stage.	
            /// </summary>	
            /// <remarks>	
            /// For pixel shaders, the render targets and unordered-access views share the same resource slots when being written out. This means that UAVs must be  given an offset so that they are placed in the slots after the render target views that are being bound. Note RTVs, DSV, and UAVs cannot be set independently; they all need to be set at the same time.Two RTVs conflict if they share a subresource (and therefore share the same resource).Two UAVs conflict if they share a subresource (and therefore share the same resource).An RTV conflicts with a UAV if they share a subresource or share a bind point.OMSetRenderTargetsAndUnorderedAccessViews operates properly in the following situations:NumViews != D3D11_KEEP_RENDER_TARGETS_AND_DEPTH_STENCIL and NumUAVs != D3D11_KEEP_UNORDERED_ACCESS_VIEWSThe following conditions must be true for OMSetRenderTargetsAndUnorderedAccessViews to succeed and for the runtime to pass the bind information to the driver:NumViews &lt;= 8UAVStartSlot &gt;= NumViewsUAVStartSlot + NumUAVs &lt;= 8There must be no conflicts in the set of all ppRenderTargetViews and ppUnorderedAccessView.ppDepthStencilView must match the render-target views. For more information about resource views, see {{Introduction to a Resource in Direct3D 11}}.OMSetRenderTargetsAndUnorderedAccessViews performs the following tasks:Unbinds all currently bound conflicting resources (stream-output target resources (SOTargets), compute shader (CS) UAVs, shader-resource views (SRVs)).Binds ppRenderTargetViews, ppDepthStencilView, and ppUnorderedAccessView.NumViews == D3D11_KEEP_RENDER_TARGETS_AND_DEPTH_STENCIL In this situation, OMSetRenderTargetsAndUnorderedAccessViews binds only UAVs. The following conditions must be true for OMSetRenderTargetsAndUnorderedAccessViews to succeed and for the runtime to pass the bind information to the driver:UAVStartSlot + NumUAVs &lt;= 8There must be no conflicts in ppUnorderedAccessView.OMSetRenderTargetsAndUnorderedAccessViews unbinds the following items:All RTVs in slots &gt;= UAVStartSlotAll RTVs that conflict with any UAVs in ppUnorderedAccessViewAll currently bound resources (SOTargets, CS UAVs, SRVs) that conflict with ppUnorderedAccessViewOMSetRenderTargetsAndUnorderedAccessViews binds ppUnorderedAccessView.OMSetRenderTargetsAndUnorderedAccessViews ignores ppDepthStencilView, and the current depth-stencil view remains bound.NumUAVs == D3D11_KEEP_UNORDERED_ACCESS_VIEWSIn this situation, OMSetRenderTargetsAndUnorderedAccessViews binds only RTVs and DSV. The following conditions must be true for OMSetRenderTargetsAndUnorderedAccessViews to succeed and for the runtime to pass the bind information to the driver:NumViews &lt;= 8There must be no conflicts in ppRenderTargetViews.ppDepthStencilView must match the render-target views. For more information about resource views, see {{Introduction to a Resource in Direct3D 11}}.OMSetRenderTargetsAndUnorderedAccessViews unbinds the following items:All UAVs in slots &lt; NumViewsAll UAVs that conflict with any RTVs in ppRenderTargetViewsAll currently bound resources (SOTargets, CS UAVs, SRVs) that conflict with ppRenderTargetViewsOMSetRenderTargetsAndUnorderedAccessViews binds ppRenderTargetViews and ppDepthStencilView.OMSetRenderTargetsAndUnorderedAccessViews ignores UAVStartSlot.	
            /// </remarks>	
            /// <param name="numRTVs">Number of render-target views (ppRenderTargetViews) and depth-stencil view (ppDepthStencilView)  to bind. If you set NumViews to D3D11_KEEP_RENDER_TARGETS_AND_DEPTH_STENCIL (0xffffffff), this method does not modify the currently bound render-target views (RTVs) and also does not modify depth-stencil view (DSV).</param>
            /// <param name="renderTargetViewsRef">Pointer to an array of <see cref="SlimDX2.Direct3D11.RenderTargetView"/>s, which represent render-target views. Specify NULL to set none.</param>
            /// <param name="depthStencilViewRef">Pointer to a <see cref="SlimDX2.Direct3D11.DepthStencilView"/>, which represents a depth-stencil view. Specify NULL to set none.</param>
            /// <param name="uAVStartSlot">Index into a zero-based array to begin setting unordered-access views (ranges from 0 to D3D11_PS_CS_UAV_REGISTER_COUNT - 1). For pixel shaders UAVStartSlot should be equal to the number of render-target views being bound. </param>
            /// <param name="numUAVs">Number of unordered-access views (UAVs) in ppUnorderedAccessView. If you set NumUAVs to D3D11_KEEP_UNORDERED_ACCESS_VIEWS (0xffffffff), this method does not modify the currently bound unordered-access views.</param>
            /// <param name="unorderedAccessViewsRef">Pointer to an array of <see cref="SlimDX2.Direct3D11.UnorderedAccessView"/>s, which represent unordered-access views.</param>
            /// <param name="uAVInitialCountsRef">An array of Append/Consume buffer offsets. A value of -1 indicates the current offset should be kept. Any other values set the hidden counter  for that Appendable/Consumeable UAV. pUAVInitialCounts is only relevant for UAVs that have  the <see cref="SlimDX2.Direct3D11.UnorderedAccessViewBufferFlags"/> flag, otherwise the argument is ignored.</param>
            /// <unmanaged>void OMSetRenderTargetsAndUnorderedAccessViews([In] UINT NumRTVs,[In, Buffer, Optional] const ID3D11RenderTargetView** ppRenderTargetViews,[In, Optional] ID3D11DepthStencilView* pDepthStencilView,[In] UINT UAVStartSlot,[In] UINT NumUAVs,[In, Buffer, Optional] const ID3D11UnorderedAccessView** ppUnorderedAccessViews,[In, Buffer, Optional] const UINT* pUAVInitialCounts)</unmanaged>
            public void SetRenderTargetsAndUnorderedAccessViews(int numRTVs, SlimDX2.Direct3D11.RenderTargetView[] renderTargetViewsRef, SlimDX2.Direct3D11.DepthStencilView depthStencilViewRef, int uAVStartSlot, int numUAVs, SlimDX2.Direct3D11.UnorderedAccessView[] unorderedAccessViewsRef, int[] uAVInitialCountsRef) {
                unsafe {
                    IntPtr* renderTargetViewsRef_ = (IntPtr*)0;
                    if ( renderTargetViewsRef != null ) {
                        IntPtr* renderTargetViewsRef__ = stackalloc IntPtr[renderTargetViewsRef.Length];
                        renderTargetViewsRef_ = renderTargetViewsRef__;
                        for (int i = 0; i < renderTargetViewsRef.Length; i++)                        
                            renderTargetViewsRef_[i] =  renderTargetViewsRef[i].NativePointer;
                    }
                    IntPtr* unorderedAccessViewsRef_ = (IntPtr*)0;
                    if ( unorderedAccessViewsRef != null ) {
                        IntPtr* unorderedAccessViewsRef__ = stackalloc IntPtr[unorderedAccessViewsRef.Length];
                        unorderedAccessViewsRef_ = unorderedAccessViewsRef__;
                        for (int i = 0; i < unorderedAccessViewsRef.Length; i++)                        
                            unorderedAccessViewsRef_[i] =  unorderedAccessViewsRef[i].NativePointer;
                    }
                    int[] uAVInitialCountsRef__ = uAVInitialCountsRef ?? new int[1];
                    fixed (void* uAVInitialCountsRef_ = &uAVInitialCountsRef__[0])
                        SlimDX2.Interop.CalliVoid(_nativePointer, 34 * 4, numRTVs, renderTargetViewsRef_, (void*)((depthStencilViewRef == null)?IntPtr.Zero:depthStencilViewRef.NativePointer), uAVStartSlot, numUAVs, unorderedAccessViewsRef_, uAVInitialCountsRef==null?(void*)IntPtr.Zero:uAVInitialCountsRef_);
                }
            }
            
            /// <summary>	
            /// Set the blend state of the output-merger stage.	
            /// </summary>	
            /// <remarks>	
            /// Blend state is used by the output-merger stage to determine how to blend together two pixel values. The two values are commonly the current pixel value and the pixel value already in the output render target. Use the {{blend operation}} to control where the two pixel values come from and how they are mathematically combined.To create a blend-state interface, call <see cref="SlimDX2.Direct3D11.Device.CreateBlendState"/>.Passing in NULL for the blend-state interface indicates to the runtime to set a default blending state.  The following table indicates the default blending parameters.StateDefault ValueAlphaToCoverageEnableFALSEBlendEnableFALSE[8]SrcBlendD3D11_BLEND_ONEDstBlendD3D11_BLEND_ZEROBlendOpD3D11_BLEND_OP_ADDSrcBlendAlphaD3D11_BLEND_ONEDstBlendAlphaD3D11_BLEND_ZEROBlendOpAlphaD3D11_BLEND_OP_ADDRenderTargetWriteMask[8]D3D11_COLOR_WRITE_ENABLE_ALL[8] A sample mask determines which samples get updated in all the active render targets. The mapping of bits in a sample mask to samples in a multisample render target is the responsibility of an individual application. A sample mask is always applied; it is independent of whether multisampling is enabled, and does not depend on whether an application uses multisample render targets. The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="blendStateRef">Pointer to a blend-state interface (see <see cref="SlimDX2.Direct3D11.BlendState"/>). Passing in NULL implies a default blend state. See remarks for further details.</param>
            /// <param name="blendFactor">Array of blend factors, one for each RGBA component. This requires a blend state object that specifies the <see cref="SlimDX2.Direct3D11.BlendOption.BlendFactor"/> option.</param>
            /// <param name="sampleMask">32-bit sample coverage. The default value is 0xffffffff. See remarks.</param>
            /// <unmanaged>void OMSetBlendState([In, Optional] ID3D11BlendState* pBlendState,[In, Optional] const FLOAT BlendFactor[4],[In] UINT SampleMask)</unmanaged>
            public void SetBlendState(SlimDX2.Direct3D11.BlendState blendStateRef, SlimMath.Vector4? blendFactor, int sampleMask) {
                unsafe {
                    SlimMath.Vector4 blendFactor_;
                    if (blendFactor.HasValue)
                        blendFactor_ = blendFactor.Value;				
                    SlimDX2.Interop.CalliVoid(_nativePointer, 35 * 4, (void*)((blendStateRef == null)?IntPtr.Zero:blendStateRef.NativePointer), (blendFactor.HasValue)?&blendFactor_:(void*)IntPtr.Zero, sampleMask);
                }
            }
            
            /// <summary>	
            /// Sets the depth-stencil state of the output-merger stage.	
            /// </summary>	
            /// <remarks>	
            /// To create a depth-stencil state interface, call <see cref="SlimDX2.Direct3D11.Device.CreateDepthStencilState"/>. The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="depthStencilStateRef">Pointer to a depth-stencil state interface (see <see cref="SlimDX2.Direct3D11.DepthStencilState"/>) to bind to the device. Set this to NULL to use the default state listed in <see cref="SlimDX2.Direct3D11.DepthStencilStateDescription"/>.</param>
            /// <param name="stencilRef">Reference value to perform against when doing a depth-stencil test. See remarks.</param>
            /// <unmanaged>void OMSetDepthStencilState([In, Optional] ID3D11DepthStencilState* pDepthStencilState,[In] UINT StencilRef)</unmanaged>
            public void SetDepthStencilState(SlimDX2.Direct3D11.DepthStencilState depthStencilStateRef, int stencilRef) {
                unsafe {
                    SlimDX2.Interop.CalliVoid(_nativePointer, 36 * 4, (void*)((depthStencilStateRef == null)?IntPtr.Zero:depthStencilStateRef.NativePointer), stencilRef);
                }
            }
            
            /// <summary>	
            /// Get pointers to the resources bound to the output-merger stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="numViews">Number of render targets to retrieve.</param>
            /// <param name="renderTargetViewsRef">Pointer to an array of <see cref="SlimDX2.Direct3D11.RenderTargetView"/>s which represent render target views. Specify NULL for this parameter when retrieval of a render target is not needed. </param>
            /// <param name="depthStencilViewRef">Pointer to a <see cref="SlimDX2.Direct3D11.DepthStencilView"/>, which represents a depth-stencil view. Specify NULL for this parameter when retrieval of the depth-stencil view is not needed.</param>
            /// <unmanaged>void OMGetRenderTargets([In] UINT NumViews,[Out, Buffer, Optional] ID3D11RenderTargetView** ppRenderTargetViews,[Out, Optional] ID3D11DepthStencilView** ppDepthStencilView)</unmanaged>
            public void GetRenderTargets(int numViews, SlimDX2.Direct3D11.RenderTargetView[] renderTargetViewsRef, out SlimDX2.Direct3D11.DepthStencilView depthStencilViewRef) {
                unsafe {
                    IntPtr* renderTargetViewsRef_ = stackalloc IntPtr[renderTargetViewsRef.Length];
                    IntPtr depthStencilViewRef_ = IntPtr.Zero;
                    SlimDX2.Interop.CalliVoid(_nativePointer, 89 * 4, numViews, &renderTargetViewsRef_, &depthStencilViewRef_);
                    for (int i = 0; i < renderTargetViewsRef.Length; i++)
                        renderTargetViewsRef[i] = (renderTargetViewsRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.RenderTargetView(renderTargetViewsRef_[i]);	
                    depthStencilViewRef = (depthStencilViewRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.DepthStencilView(depthStencilViewRef_);	
                }
            }
            
            /// <summary>	
            /// Get pointers to the resources bound to the output-merger stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call {{IUnknown::Release}} on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="numRTVs">The number of render-target views to retrieve.</param>
            /// <param name="renderTargetViewsRef">Pointer to an array of <see cref="SlimDX2.Direct3D11.RenderTargetView"/>s, which represent render-target views. Specify NULL for this parameter when retrieval of render-target views is not required. </param>
            /// <param name="depthStencilViewRef">Pointer to a <see cref="SlimDX2.Direct3D11.DepthStencilView"/>, which represents a depth-stencil view. Specify NULL for this parameter when retrieval of the depth-stencil view is not required.</param>
            /// <param name="uAVStartSlot">Index into a zero-based array to begin retrieving unordered-access views (ranges from 0 to D3D11_PS_CS_UAV_REGISTER_COUNT - 1). For pixel shaders UAVStartSlot should be equal to the number of render-target views that are bound. </param>
            /// <param name="numUAVs">Number of unordered-access views to return in ppUnorderedAccessViews. This number ranges from 0 to D3D11_PS_CS_UAV_REGISTER_COUNT - UAVStartSlot.</param>
            /// <param name="unorderedAccessViewsRef">Pointer to an array of <see cref="SlimDX2.Direct3D11.UnorderedAccessView"/>s, which represent unordered-access views that are retrieved. Specify NULL for this parameter when retrieval of unordered-access views is not required. </param>
            /// <unmanaged>void OMGetRenderTargetsAndUnorderedAccessViews([In] UINT NumRTVs,[Out, Buffer, Optional] ID3D11RenderTargetView** ppRenderTargetViews,[Out, Optional] ID3D11DepthStencilView** ppDepthStencilView,[In] UINT UAVStartSlot,[In] UINT NumUAVs,[Out, Buffer, Optional] ID3D11UnorderedAccessView** ppUnorderedAccessViews)</unmanaged>
            public void GetRenderTargetsAndUnorderedAccessViews(int numRTVs, SlimDX2.Direct3D11.RenderTargetView[] renderTargetViewsRef, out SlimDX2.Direct3D11.DepthStencilView depthStencilViewRef, int uAVStartSlot, int numUAVs, SlimDX2.Direct3D11.UnorderedAccessView[] unorderedAccessViewsRef) {
                unsafe {
                    IntPtr* renderTargetViewsRef_ = stackalloc IntPtr[renderTargetViewsRef.Length];
                    IntPtr depthStencilViewRef_ = IntPtr.Zero;
                    IntPtr* unorderedAccessViewsRef_ = stackalloc IntPtr[unorderedAccessViewsRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 90 * 4, numRTVs, &renderTargetViewsRef_, &depthStencilViewRef_, uAVStartSlot, numUAVs, &unorderedAccessViewsRef_);
                    for (int i = 0; i < renderTargetViewsRef.Length; i++)
                        renderTargetViewsRef[i] = (renderTargetViewsRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.RenderTargetView(renderTargetViewsRef_[i]);	
                    depthStencilViewRef = (depthStencilViewRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.DepthStencilView(depthStencilViewRef_);	
                    for (int i = 0; i < unorderedAccessViewsRef.Length; i++)
                        unorderedAccessViewsRef[i] = (unorderedAccessViewsRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.UnorderedAccessView(unorderedAccessViewsRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get the blend state of the output-merger stage.	
            /// </summary>	
            /// <remarks>	
            /// The reference count of the returned interface will be incremented by one when the blend state is retrieved. Applications must release returned pointer(s) when they are no longer needed, or else there will be a memory leak.	
            /// </remarks>	
            /// <param name="blendStateRef">Address of a pointer to a blend-state interface (see <see cref="SlimDX2.Direct3D11.BlendState"/>).</param>
            /// <param name="blendFactor">Array of blend factors, one for each RGBA component.</param>
            /// <param name="sampleMaskRef">Pointer to a {{sample mask}}.</param>
            /// <unmanaged>void OMGetBlendState([Out, Optional] ID3D11BlendState** ppBlendState,[Out, Optional] FLOAT BlendFactor[4],[Out, Optional] UINT* pSampleMask)</unmanaged>
            public void GetBlendState(out SlimDX2.Direct3D11.BlendState blendStateRef, out SlimMath.Vector4 blendFactor, out int sampleMaskRef) {
                unsafe {
                    IntPtr blendStateRef_ = IntPtr.Zero;
                    blendFactor = new SlimMath.Vector4();
                    fixed (void* blendFactor_ = &blendFactor)
                        fixed (void* sampleMaskRef_ = &sampleMaskRef)
                            SlimDX2.Interop.CalliVoid(_nativePointer, 91 * 4, &blendStateRef_, blendFactor_, sampleMaskRef_);
                    blendStateRef = (blendStateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.BlendState(blendStateRef_);	
                }
            }
            
            /// <summary>	
            /// Gets the depth-stencil state of the output-merger stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="depthStencilStateRef">Address of a pointer to a depth-stencil state interface (see <see cref="SlimDX2.Direct3D11.DepthStencilState"/>) to be filled with information from the device.</param>
            /// <param name="stencilRefRef">Pointer to the stencil reference value used in the depth-stencil test.</param>
            /// <unmanaged>void OMGetDepthStencilState([Out, Optional] ID3D11DepthStencilState** ppDepthStencilState,[Out, Optional] UINT* pStencilRef)</unmanaged>
            public void GetDepthStencilState(out SlimDX2.Direct3D11.DepthStencilState depthStencilStateRef, out int stencilRefRef) {
                unsafe {
                    IntPtr depthStencilStateRef_ = IntPtr.Zero;
                    fixed (void* stencilRefRef_ = &stencilRefRef)
                        SlimDX2.Interop.CalliVoid(_nativePointer, 92 * 4, &depthStencilStateRef_, stencilRefRef_);
                    depthStencilStateRef = (depthStencilStateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.DepthStencilState(depthStencilStateRef_);	
                }
            }
        }
      
		/// <summary>Inner interface giving access to ComputeShaderStage methods. </summary>
        public ComputeShaderStage ComputeShader { get; private set; }		
        
        /// <summary>Inner interface ComputeShaderStage.</summary>
        /// <unmanaged>ID3D11DeviceContext</unmanaged>
        public partial class ComputeShaderStage : CommonShaderStage<ComputeShader> {
    
            public ComputeShaderStage(IntPtr basePtr) : base(basePtr) {
            }
            
            
            /// <summary>	
            /// Bind an array of shader resources to the compute-shader stage.	
            /// </summary>	
            /// <remarks>	
            /// If an overlapping resource view is already bound to an output slot, such as a render target, then the method will fill the destination shader resource slot with NULL.For information about creating shader-resource views, see <see cref="SlimDX2.Direct3D11.Device.CreateShaderResourceView"/>. The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting shader resources to (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</param>
            /// <param name="numViews">Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources(ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to set to the device.</param>
            /// <unmanaged>void CSSetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[In, Buffer] const ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
            public  override void SetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D11.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = (IntPtr*)0;
                    if ( shaderResourceViewsRef != null ) {
                        IntPtr* shaderResourceViewsRef__ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                        shaderResourceViewsRef_ = shaderResourceViewsRef__;
                        for (int i = 0; i < shaderResourceViewsRef.Length; i++)                        
                            shaderResourceViewsRef_[i] =  shaderResourceViewsRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 67 * 4, startSlot, numViews, shaderResourceViewsRef_);
                }
            }
            
            /// <summary>	
            /// Sets an array of views for an unordered resource.	
            /// </summary>	
            /// <param name="startSlot">Index of the first element in the zero-based array to begin setting.</param>
            /// <param name="numUAVs">Number of views to set.</param>
            /// <param name="unorderedAccessViewsRef">A pointer to an array of <see cref="SlimDX2.Direct3D11.UnorderedAccessView"/> pointers to be set by the method.</param>
            /// <param name="uAVInitialCountsRef">An array of Append/Consume buffer offsets. A value of -1 indicates the current offset should be kept.   Any other values set the hidden counter for that Appendable/Consumeable UAV.  pUAVInitialCounts is only relevant for UAVs which have the <see cref="SlimDX2.Direct3D11.UnorderedAccessViewBufferFlags"/> flag,  otherwise the argument is ignored.</param>
            /// <unmanaged>void CSSetUnorderedAccessViews([In] UINT StartSlot,[In] UINT NumUAVs,[In, Buffer] const ID3D11UnorderedAccessView** ppUnorderedAccessViews,[In, Buffer] const UINT* pUAVInitialCounts)</unmanaged>
            public void SetUnorderedAccessViews(int startSlot, int numUAVs, SlimDX2.Direct3D11.UnorderedAccessView[] unorderedAccessViewsRef, int[] uAVInitialCountsRef) {
                unsafe {
                    IntPtr* unorderedAccessViewsRef_ = (IntPtr*)0;
                    if ( unorderedAccessViewsRef != null ) {
                        IntPtr* unorderedAccessViewsRef__ = stackalloc IntPtr[unorderedAccessViewsRef.Length];
                        unorderedAccessViewsRef_ = unorderedAccessViewsRef__;
                        for (int i = 0; i < unorderedAccessViewsRef.Length; i++)                        
                            unorderedAccessViewsRef_[i] =  unorderedAccessViewsRef[i].NativePointer;
                    }
                    fixed (void* uAVInitialCountsRef_ = &uAVInitialCountsRef[0])
                        SlimDX2.Interop.CalliVoid(_nativePointer, 68 * 4, startSlot, numUAVs, unorderedAccessViewsRef_, uAVInitialCountsRef_);
                }
            }
            
            /// <summary>	
            /// Set a compute shader to the device.	
            /// </summary>	
            /// <remarks>	
            ///  The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. The maximum number of instances a shader can have is 256.	
            /// </remarks>	
            /// <param name="computeShaderRef">Pointer to a compute shader (see <see cref="SlimDX2.Direct3D11.ComputeShader"/>). Passing in NULL disables the shader for this pipeline stage.</param>
            /// <param name="classInstancesRef">A pointer to an array of class-instance interfaces (see <see cref="SlimDX2.Direct3D11.ClassInstance"/>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to NULL if the shader does not use any interfaces.</param>
            /// <param name="numClassInstances">The number of class-instance interfaces in the array.</param>
            /// <unmanaged>void CSSetShader([In, Optional] ID3D11ComputeShader* pComputeShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[None] UINT NumClassInstances)</unmanaged>
            internal  override void SetShader(SlimDX2.Direct3D11.ComputeShader computeShaderRef, SlimDX2.Direct3D11.ClassInstance[] classInstancesRef, int numClassInstances) {
                unsafe {
                    IntPtr* classInstancesRef_ = (IntPtr*)0;
                    if ( classInstancesRef != null ) {
                        IntPtr* classInstancesRef__ = stackalloc IntPtr[classInstancesRef.Length];
                        classInstancesRef_ = classInstancesRef__;
                        for (int i = 0; i < classInstancesRef.Length; i++)                        
                            classInstancesRef_[i] =  classInstancesRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 69 * 4, (void*)((computeShaderRef == null)?IntPtr.Zero:computeShaderRef.NativePointer), classInstancesRef_, numClassInstances);
                }
            }
            
            /// <summary>	
            /// Set an array of sampler states to the compute-shader stage.	
            /// </summary>	
            /// <remarks>	
            /// Any sampler may be set to NULL; this invokes the default state, which is defined to be the following.	
            /// <code> //Default sampler state:	
            /// D3D11_SAMPLER_DESC SamplerDesc;	
            /// SamplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;	
            /// SamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;	
            /// SamplerDesc.MipLODBias = 0;	
            /// SamplerDesc.MaxAnisotropy = 1;	
            /// SamplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;	
            /// SamplerDesc.BorderColor[0] = 1.0f;	
            /// SamplerDesc.BorderColor[1] = 1.0f;	
            /// SamplerDesc.BorderColor[2] = 1.0f;	
            /// SamplerDesc.BorderColor[3] = 1.0f;	
            /// SamplerDesc.MinLOD = -FLT_MAX;	
            /// SamplerDesc.MaxLOD = FLT_MAX; </code>	
            /// 	
            ///  The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin setting samplers to (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</param>
            /// <param name="numSamplers">Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</param>
            /// <param name="samplersRef">Pointer to an array of sampler-state interfaces (see <see cref="SlimDX2.Direct3D11.SamplerState"/>). See Remarks.</param>
            /// <unmanaged>void CSSetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[In, Buffer] const ID3D11SamplerState** ppSamplers)</unmanaged>
            public  override void SetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D11.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = (IntPtr*)0;
                    if ( samplersRef != null ) {
                        IntPtr* samplersRef__ = stackalloc IntPtr[samplersRef.Length];
                        samplersRef_ = samplersRef__;
                        for (int i = 0; i < samplersRef.Length; i++)                        
                            samplersRef_[i] =  samplersRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 70 * 4, startSlot, numSamplers, samplersRef_);
                }
            }
            
            /// <summary>	
            /// Set the constant buffers used by the compute-shader stage.	
            /// </summary>	
            /// <remarks>	
            ///  The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. 	
            /// </remarks>	
            /// <param name="startSlot">Index into the zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name="numBuffers">Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot).</param>
            /// <param name="constantBuffersRef">Array of constant buffers (see <see cref="SlimDX2.Direct3D11.Buffer"/>) being given to the device.</param>
            /// <unmanaged>void CSSetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[In, Buffer] const ID3D11Buffer** ppConstantBuffers)</unmanaged>
            public  override void SetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D11.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = (IntPtr*)0;
                    if ( constantBuffersRef != null ) {
                        IntPtr* constantBuffersRef__ = stackalloc IntPtr[constantBuffersRef.Length];
                        constantBuffersRef_ = constantBuffersRef__;
                        for (int i = 0; i < constantBuffersRef.Length; i++)                        
                            constantBuffersRef_[i] =  constantBuffersRef[i].NativePointer;
                    }
                    SlimDX2.Interop.CalliVoid(_nativePointer, 71 * 4, startSlot, numBuffers, constantBuffersRef_);
                }
            }
            
            /// <summary>	
            /// Get the compute-shader resources.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin getting shader resources from (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</param>
            /// <param name="numViews">The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</param>
            /// <param name="shaderResourceViewsRef">Array of {{shader resource view}} interfaces to be returned by the device.</param>
            /// <unmanaged>void CSGetShaderResources([In] UINT StartSlot,[In] UINT NumViews,[Out, Buffer] ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
            internal  override void GetShaderResources(int startSlot, int numViews, SlimDX2.Direct3D11.ShaderResourceView[] shaderResourceViewsRef) {
                unsafe {
                    IntPtr* shaderResourceViewsRef_ = stackalloc IntPtr[shaderResourceViewsRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 105 * 4, startSlot, numViews, &shaderResourceViewsRef_);
                    for (int i = 0; i < shaderResourceViewsRef.Length; i++)
                        shaderResourceViewsRef[i] = (shaderResourceViewsRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ShaderResourceView(shaderResourceViewsRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Gets an array of views for an unordered resource.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index of the first element in the zero-based array to return (ranges from 0 to D3D11_PS_CS_UAV_REGISTER_COUNT - 1).</param>
            /// <param name="numUAVs">Number of views to get (ranges from 0 to D3D11_PS_CS_UAV_REGISTER_COUNT - StartSlot).</param>
            /// <param name="unorderedAccessViewsRef">A pointer to an array of interface pointers (see <see cref="SlimDX2.Direct3D11.UnorderedAccessView"/>) to get.</param>
            /// <unmanaged>void CSGetUnorderedAccessViews([In] UINT StartSlot,[In] UINT NumUAVs,[Out, Buffer] ID3D11UnorderedAccessView** ppUnorderedAccessViews)</unmanaged>
            public void GetUnorderedAccessViews(int startSlot, int numUAVs, SlimDX2.Direct3D11.UnorderedAccessView[] unorderedAccessViewsRef) {
                unsafe {
                    IntPtr* unorderedAccessViewsRef_ = stackalloc IntPtr[unorderedAccessViewsRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 106 * 4, startSlot, numUAVs, &unorderedAccessViewsRef_);
                    for (int i = 0; i < unorderedAccessViewsRef.Length; i++)
                        unorderedAccessViewsRef[i] = (unorderedAccessViewsRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.UnorderedAccessView(unorderedAccessViewsRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get the compute shader currently set on the device.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="computeShaderRef">Address of a pointer to a Compute shader (see <see cref="SlimDX2.Direct3D11.ComputeShader"/>) to be returned by the method.</param>
            /// <param name="classInstancesRef">Pointer to an array of class instance interfaces (see <see cref="SlimDX2.Direct3D11.ClassInstance"/>).</param>
            /// <param name="numClassInstancesRef">The number of class-instance elements in the array.</param>
            /// <unmanaged>void CSGetShader([Out] ID3D11ComputeShader** ppComputeShader,[Out, Buffer, Optional] ID3D11ClassInstance** ppClassInstances,[InOut, Optional] UINT* pNumClassInstances)</unmanaged>
            internal  override void GetShader(out SlimDX2.Direct3D11.ComputeShader computeShaderRef, SlimDX2.Direct3D11.ClassInstance[] classInstancesRef, ref int numClassInstancesRef) {
                unsafe {
                    IntPtr computeShaderRef_ = IntPtr.Zero;
                    IntPtr* classInstancesRef_ = stackalloc IntPtr[classInstancesRef.Length];
                    fixed (void* numClassInstancesRef_ = &numClassInstancesRef)
                        SlimDX2.Interop.CalliVoid(_nativePointer, 107 * 4, &computeShaderRef_, &classInstancesRef_, numClassInstancesRef_);
                    computeShaderRef = (computeShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ComputeShader(computeShaderRef_);	
                    for (int i = 0; i < classInstancesRef.Length; i++)
                        classInstancesRef[i] = (classInstancesRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ClassInstance(classInstancesRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get an array of sampler state interfaces from the compute-shader stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into a zero-based array to begin getting samplers from (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</param>
            /// <param name="numSamplers">Number of samplers to get from a device context. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</param>
            /// <param name="samplersRef">Pointer to an array of sampler-state interfaces (see <see cref="SlimDX2.Direct3D11.SamplerState"/>).</param>
            /// <unmanaged>void CSGetSamplers([In] UINT StartSlot,[In] UINT NumSamplers,[Out, Buffer] ID3D11SamplerState** ppSamplers)</unmanaged>
            internal  override void GetSamplers(int startSlot, int numSamplers, SlimDX2.Direct3D11.SamplerState[] samplersRef) {
                unsafe {
                    IntPtr* samplersRef_ = stackalloc IntPtr[samplersRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 108 * 4, startSlot, numSamplers, &samplersRef_);
                    for (int i = 0; i < samplersRef.Length; i++)
                        samplersRef[i] = (samplersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.SamplerState(samplersRef_[i]);	
                }
            }
            
            /// <summary>	
            /// Get the constant buffers used by the compute-shader stage.	
            /// </summary>	
            /// <remarks>	
            /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
            /// </remarks>	
            /// <param name="startSlot">Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</param>
            /// <param name="numBuffers">Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot).</param>
            /// <param name="constantBuffersRef">Array of constant buffer interface pointers (see <see cref="SlimDX2.Direct3D11.Buffer"/>) to be returned by the method.</param>
            /// <unmanaged>void CSGetConstantBuffers([In] UINT StartSlot,[In] UINT NumBuffers,[Out, Buffer] ID3D11Buffer** ppConstantBuffers)</unmanaged>
            internal  override void GetConstantBuffers(int startSlot, int numBuffers, SlimDX2.Direct3D11.Buffer[] constantBuffersRef) {
                unsafe {
                    IntPtr* constantBuffersRef_ = stackalloc IntPtr[constantBuffersRef.Length];
                    SlimDX2.Interop.CalliVoid(_nativePointer, 109 * 4, startSlot, numBuffers, &constantBuffersRef_);
                    for (int i = 0; i < constantBuffersRef.Length; i++)
                        constantBuffersRef[i] = (constantBuffersRef_[i] == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Buffer(constantBuffersRef_[i]);	
                }
            }
        }
        
        /// <summary>	
        /// Gets the type of {{device context}}.	
        /// </summary>	
        /// <unmanaged>D3D11_DEVICE_CONTEXT_TYPE GetType()</unmanaged>
        public SlimDX2.Direct3D11.DeviceContextType TypeInfo {
                get { return GetTypeInfo(); }
        }
        
        /// <summary>	
        /// Gets the initialization flags associated with the current deferred context.	
        /// </summary>	
        /// <remarks>	
        /// The GetContextFlags method gets the flags that were supplied to the ContextFlags parameter of <see cref="SlimDX2.Direct3D11.Device.CreateDeferredContext"/>; however, the context flag is reserved for future use.	
        /// </remarks>	
        /// <unmanaged>UINT GetContextFlags()</unmanaged>
        public int ContextFlags {
                get { return GetContextFlags(); }
        }
        
        /// <summary>	
        /// Draw indexed, non-instanced primitives.	
        /// </summary>	
        /// <remarks>	
        /// A draw API submits work to the rendering pipeline.If the sum of both indices is negative, the result of the function call is undefined.	
        /// </remarks>	
        /// <param name="indexCount">Number of indices to draw.</param>
        /// <param name="startIndexLocation">The location of the first index read by the GPU from the index buffer.</param>
        /// <param name="baseVertexLocation">A value added to each index before reading a vertex from the vertex buffer.</param>
        /// <unmanaged>void DrawIndexed([In] UINT IndexCount,[In] UINT StartIndexLocation,[In] INT BaseVertexLocation)</unmanaged>
        public void DrawIndexed(int indexCount, int startIndexLocation, int baseVertexLocation) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 12 * 4, indexCount, startIndexLocation, baseVertexLocation);
            }
        }
        
        /// <summary>	
        /// Draw non-indexed, non-instanced primitives.	
        /// </summary>	
        /// <remarks>	
        /// A draw API submits work to the rendering pipeline.The vertex data for a draw call normally comes from a vertex buffer that is bound to the pipeline. However, you could also provide the vertex data from a shader that has vertex data marked with the SV_VertexId system-value semantic.	
        /// </remarks>	
        /// <param name="vertexCount">Number of vertices to draw.</param>
        /// <param name="startVertexLocation">Index of the first vertex, which is usually an offset in a vertex buffer; it could also be used as the first vertex id generated for a shader parameter marked with the SV_TargetId system-value semantic.</param>
        /// <unmanaged>void Draw([In] UINT VertexCount,[In] UINT StartVertexLocation)</unmanaged>
        public void Draw(int vertexCount, int startVertexLocation) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 13 * 4, vertexCount, startVertexLocation);
            }
        }
        
        /// <summary>	
        /// Get a pointer to the data contained in a subresource, and deny the GPU access to that subresource.	
        /// </summary>	
        /// <remarks>	
        /// If you call Map on a deferred context, you can only pass <see cref="SlimDX2.Direct3D11.MapMode.WriteDiscard"/>, D3D11_MAP_WRITE_NO_OVERWRITE, or both to the MapType parameter. Other D3D11_MAP-typed values are not supported for a deferred context.	
        /// </remarks>	
        /// <param name="resourceRef">A pointer to a <see cref="SlimDX2.Direct3D11.Resource"/> interface.</param>
        /// <param name="subresource">Index number of the subresource.</param>
        /// <param name="mapType">Specifies the CPU's read and write permissions for a resource. For possible values, see <see cref="SlimDX2.Direct3D11.MapMode"/>.</param>
        /// <param name="mapFlags"> that specifies what the CPU should do when the GPU is busy. This flag is optional.</param>
        /// <param name="mappedResourceRef">A pointer to the mapped subresource (see <see cref="SlimDX2.Direct3D11.MappedSubResource"/>).</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.This method also returns DXGI_ERROR_WAS_STILL_DRAWING if MapFlags specifies D3D10_MAP_FLAG_DO_NOT_WAIT and the GPU is not yet finished with the resource. For more information about this error code, see <see cref="SlimDX2.DXGI.DXGIError"/>.</returns>
        /// <unmanaged>HRESULT Map([In] ID3D11Resource* pResource,[In] UINT Subresource,[In] D3D11_MAP MapType,[In] UINT MapFlags,[Out] D3D11_MAPPED_SUBRESOURCE* pMappedResource)</unmanaged>
        internal SlimDX2.Result Map(SlimDX2.Direct3D11.Resource resourceRef, int subresource, SlimDX2.Direct3D11.MapMode mapType, SlimDX2.Direct3D11.MapFlags mapFlags, out SlimDX2.Direct3D11.MappedSubResource mappedResourceRef) {
            unsafe {
                mappedResourceRef = new SlimDX2.Direct3D11.MappedSubResource();
                SlimDX2.Result __result__;
                fixed (void* mappedResourceRef_ = &mappedResourceRef)
                    __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 14 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), subresource, unchecked((int)mapType), unchecked((int)mapFlags), mappedResourceRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Invalidate the pointer to a resource and re-enable the GPU's access to that resource.	
        /// </summary>	
        /// <param name="resourceRef">A pointer to a <see cref="SlimDX2.Direct3D11.Resource"/> interface.</param>
        /// <param name="subresource">A subresource to be unmapped.</param>
        /// <unmanaged>void Unmap([In] ID3D11Resource* pResource,[In] UINT Subresource)</unmanaged>
        public void UnmapSubresource(SlimDX2.Direct3D11.Resource resourceRef, int subresource) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 15 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), subresource);
            }
        }
        
        /// <summary>	
        /// Draw indexed, instanced primitives.	
        /// </summary>	
        /// <remarks>	
        /// A draw API submits work to the rendering pipeline.Instancing may extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing could be  to draw the same object with different positions and colors. Indexing requires multiple vertex buffers: at least one for per-vertex data  and a second buffer for per-instance data.	
        /// </remarks>	
        /// <param name="indexCountPerInstance">Number of indices read from the index buffer for each instance.</param>
        /// <param name="instanceCount">Number of instances to draw.</param>
        /// <param name="startIndexLocation">The location of the first index read by the GPU from the index buffer.</param>
        /// <param name="baseVertexLocation">A value added to each index before reading a vertex from the vertex buffer.</param>
        /// <param name="startInstanceLocation">A value added to each index before reading per-instance data from a vertex buffer.</param>
        /// <unmanaged>void DrawIndexedInstanced([In] UINT IndexCountPerInstance,[In] UINT InstanceCount,[In] UINT StartIndexLocation,[In] INT BaseVertexLocation,[In] UINT StartInstanceLocation)</unmanaged>
        public void DrawIndexedInstanced(int indexCountPerInstance, int instanceCount, int startIndexLocation, int baseVertexLocation, int startInstanceLocation) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 20 * 4, indexCountPerInstance, instanceCount, startIndexLocation, baseVertexLocation, startInstanceLocation);
            }
        }
        
        /// <summary>	
        /// Draw non-indexed, instanced primitives.	
        /// </summary>	
        /// <remarks>	
        /// A draw API submits work to the rendering pipeline.Instancing may extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing could be  to draw the same object with different positions and colors.The vertex data for an instanced draw call normally comes from a vertex buffer that is bound to the pipeline.  However, you could also provide the vertex data from a shader that has instanced data identified with a system-value semantic (SV_InstanceID).	
        /// </remarks>	
        /// <param name="vertexCountPerInstance">Number of vertices to draw.</param>
        /// <param name="instanceCount">Number of instances to draw.</param>
        /// <param name="startVertexLocation">Index of the first vertex.</param>
        /// <param name="startInstanceLocation">A value added to each index before reading per-instance data from a vertex buffer.</param>
        /// <unmanaged>void DrawInstanced([In] UINT VertexCountPerInstance,[In] UINT InstanceCount,[In] UINT StartVertexLocation,[In] UINT StartInstanceLocation)</unmanaged>
        public void DrawInstanced(int vertexCountPerInstance, int instanceCount, int startVertexLocation, int startInstanceLocation) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 21 * 4, vertexCountPerInstance, instanceCount, startVertexLocation, startInstanceLocation);
            }
        }
        
        /// <summary>	
        /// Mark the beginning of a series of commands.	
        /// </summary>	
        /// <remarks>	
        /// Use <see cref="SlimDX2.Direct3D11.DeviceContext.End"/> to mark the ending of the series of commands.	
        /// </remarks>	
        /// <param name="asyncRef">A pointer to an <see cref="SlimDX2.Direct3D11.Asynchronous"/> interface.</param>
        /// <unmanaged>void Begin([In] ID3D11Asynchronous* pAsync)</unmanaged>
        public void Begin(SlimDX2.Direct3D11.Asynchronous asyncRef) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 27 * 4, (void*)((asyncRef == null)?IntPtr.Zero:asyncRef.NativePointer));
            }
        }
        
        /// <summary>	
        /// Mark the end of a series of commands.	
        /// </summary>	
        /// <remarks>	
        /// Use <see cref="SlimDX2.Direct3D11.DeviceContext.Begin"/> to mark the beginning of the series of commands.	
        /// </remarks>	
        /// <param name="asyncRef">A pointer to an <see cref="SlimDX2.Direct3D11.Asynchronous"/> interface.</param>
        /// <unmanaged>void End([In] ID3D11Asynchronous* pAsync)</unmanaged>
        public void End(SlimDX2.Direct3D11.Asynchronous asyncRef) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 28 * 4, (void*)((asyncRef == null)?IntPtr.Zero:asyncRef.NativePointer));
            }
        }
        
        /// <summary>	
        /// Get data from the GPU asynchronously.	
        /// </summary>	
        /// <remarks>	
        /// Queries in a deferred context are limited to predicated drawing. That is, you cannot call ID3D11DeviceContext::GetData on a deferred context to get data about a query; you can only call GetData on the immediate context to get data about a query. For predicated drawing, the results of a predication-type query are used by the GPU and not returned to an application. For more information about predication and predicated drawing, see {{D3D11DeviceContext::SetPredication}}.	
        /// </remarks>	
        /// <param name="asyncRef">A pointer to an <see cref="SlimDX2.Direct3D11.Asynchronous"/> interface.</param>
        /// <param name="dataRef">Address of memory that will receive the data. If NULL, GetData will be used only to check status. The type of data output depends on the type of asynchronous interface.</param>
        /// <param name="dataSize">Size of the data to retrieve or 0. Must be 0 when pData is NULL.</param>
        /// <param name="getDataFlags">Optional flags. Can be 0 or any combination of the flags enumerated by <see cref="SlimDX2.Direct3D11.AsynchronousFlags"/>.</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetData([In] ID3D11Asynchronous* pAsync,[Out, Buffer, Optional] void* pData,[In] UINT DataSize,[In] UINT GetDataFlags)</unmanaged>
        internal SlimDX2.Result GetDataInternal(SlimDX2.Direct3D11.Asynchronous asyncRef, IntPtr dataRef, int dataSize, SlimDX2.Direct3D11.AsynchronousFlags getDataFlags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 29 * 4, (void*)((asyncRef == null)?IntPtr.Zero:asyncRef.NativePointer), (void*)dataRef, dataSize, unchecked((int)getDataFlags));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set a rendering predicate.	
        /// </summary>	
        /// <remarks>	
        /// The predicate must be in the "issued" or "signaled" state to be used for predication. While the predicate is set for predication, calls to <see cref="SlimDX2.Direct3D11.DeviceContext.Begin"/> and <see cref="SlimDX2.Direct3D11.DeviceContext.End"/> are invalid.This method is used to denote that subsequent rendering and resource manipulation commands are not actually performed if the resulting Predicate data of the Predicate is equal to the PredicateValue. However, some Predicates are only hints, so they may not actually prevent operations from being performed. The primary usefulness of Predication is to allow an application to issue graphics commands without taking the performance hit of spinning, waiting for <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> to return. So, Predication can occur while ID3D11DeviceContext::GetData returns S_FALSE. Another way to think of it: an application can also use Predication as a fallback, if it is possible that ID3D11DeviceContext::GetData returns S_FALSE. If ID3D11DeviceContext::GetData returns S_OK, the application can skip calling the graphics commands manually with it's own application logic.	
        /// </remarks>	
        /// <param name="predicateRef">Pointer to a predicate (see <see cref="SlimDX2.Direct3D11.Predicate"/>). A NULL value indicates "no" predication; in this case, the value of PredicateValue is irrelevent but will be preserved for <see cref="SlimDX2.Direct3D11.DeviceContext.GetPredication"/>.</param>
        /// <param name="predicateValue">If TRUE, rendering will be affected by when the predicate's conditions are met. If FALSE, rendering will be affected when the conditions are not met.</param>
        /// <unmanaged>void SetPredication([In, Optional] ID3D11Predicate* pPredicate,[In] BOOL PredicateValue)</unmanaged>
        public void SetPredication(SlimDX2.Direct3D11.Predicate predicateRef, bool predicateValue) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 30 * 4, (void*)((predicateRef == null)?IntPtr.Zero:predicateRef.NativePointer), (predicateValue?1:0));
            }
        }
        
        /// <summary>	
        /// Draw geometry of an unknown size.	
        /// </summary>	
        /// <remarks>	
        /// A draw API submits work to the rendering pipeline. This API submits work of an unknown size that was processed by the input assembler, vertex shader, and stream-output stages;  the work may or may not have gone through the geometry-shader stage.After data has been streamed out to stream-output stage buffers, those buffers can be again bound to the Input Assembler stage at input slot 0 and DrawAuto will draw them without the application needing to know the amount of data that was written to the buffers. A measurement of the amount of data written to the SO stage buffers is maintained internally when the data is streamed out. This means that the CPU does not need to fetch the measurement before re-binding the data that was streamed as input data. Although this amount is tracked internally, it is still the responsibility of applications to use input layouts to describe the format of the data in the SO stage buffers so that the layouts are available when the buffers are again bound to the input assembler.The following diagram shows the DrawAuto process. Diagram of DrawAuto as data moves through several stages to a buffer and then back to the Input Assembler stage Calling DrawAuto does not change the state of the streaming-output buffers that were bound again as inputs.DrawAuto only works when drawing with one input buffer bound as an input to the IA stage at slot 0. Applications must create the SO buffer resource with both binding flags, <see cref="SlimDX2.Direct3D11.BindFlags.VertexBuffer"/> and D3D11_BIND_STREAM_OUTPUT.This API does not support indexing or instancing.If an application needs to retrieve the size of the streaming-output buffer, it can query for statistics on streaming output by using <see cref="SlimDX2.Direct3D11.QueryType.StreamOutputStatistics"/>.	
        /// </remarks>	
        /// <unmanaged>void DrawAuto()</unmanaged>
        public void DrawAuto() {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 38 * 4);
            }
        }
        
        /// <summary>	
        /// Draw indexed, instanced, GPU-generated primitives.	
        /// </summary>	
        /// <remarks>	
        /// When an application creates a buffer that is associated with the <see cref="SlimDX2.Direct3D11.Buffer"/> interface that  pBufferForArgs points to, the application must set the <see cref="SlimDX2.Direct3D11.ResourceOptionFlags.DrawindirectArgs"/> flag in the MiscFlags member of the <see cref="SlimDX2.Direct3D11.BufferDescription"/> structure that describes the buffer. To create the buffer, the application calls the <see cref="SlimDX2.Direct3D11.Device.CreateBuffer"/> method and in this call passes a pointer to D3D11_BUFFER_DESC in the pDesc parameter.	
        /// </remarks>	
        /// <param name="bufferForArgsRef">A pointer to an <see cref="SlimDX2.Direct3D11.Buffer"/>, which is a buffer containing the GPU generated primitives.</param>
        /// <param name="alignedByteOffsetForArgs">Offset in pBufferForArgs to the start of the GPU generated primitives.</param>
        /// <unmanaged>void DrawIndexedInstancedIndirect([In] ID3D11Buffer* pBufferForArgs,[In] UINT AlignedByteOffsetForArgs)</unmanaged>
        public void DrawIndexedInstancedIndirect(SlimDX2.Direct3D11.Buffer bufferForArgsRef, int alignedByteOffsetForArgs) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 39 * 4, (void*)((bufferForArgsRef == null)?IntPtr.Zero:bufferForArgsRef.NativePointer), alignedByteOffsetForArgs);
            }
        }
        
        /// <summary>	
        /// Draw instanced, GPU-generated primitives.	
        /// </summary>	
        /// <remarks>	
        /// When an application creates a buffer that is associated with the <see cref="SlimDX2.Direct3D11.Buffer"/> interface that  pBufferForArgs points to, the application must set the <see cref="SlimDX2.Direct3D11.ResourceOptionFlags.DrawindirectArgs"/> flag in the MiscFlags member of the <see cref="SlimDX2.Direct3D11.BufferDescription"/> structure that describes the buffer. To create the buffer, the application calls the <see cref="SlimDX2.Direct3D11.Device.CreateBuffer"/> method and in this call passes a pointer to D3D11_BUFFER_DESC in the pDesc parameter.	
        /// </remarks>	
        /// <param name="bufferForArgsRef">A pointer to an <see cref="SlimDX2.Direct3D11.Buffer"/>, which is a buffer containing the GPU generated primitives.</param>
        /// <param name="alignedByteOffsetForArgs">Offset in pBufferForArgs to the start of the GPU generated primitives.</param>
        /// <unmanaged>void DrawInstancedIndirect([In] ID3D11Buffer* pBufferForArgs,[In] UINT AlignedByteOffsetForArgs)</unmanaged>
        public void DrawInstancedIndirect(SlimDX2.Direct3D11.Buffer bufferForArgsRef, int alignedByteOffsetForArgs) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 40 * 4, (void*)((bufferForArgsRef == null)?IntPtr.Zero:bufferForArgsRef.NativePointer), alignedByteOffsetForArgs);
            }
        }
        
        /// <summary>	
        /// Execute a command list from a thread group.	
        /// </summary>	
        /// <remarks>	
        /// A compute shader can be run on many threads in parallel, within a thread group. Index a particular thread, within a thread group using a 3D vector  given by (x,y,z).In the following illustration, assume a thread group with 50 threads where the size of the group is given by (5,5,2). A single thread is identified from a  thread group with 50 threads in it, using the vector (4,1,1). Illustration of a single thread within a thread group of 50 threads The following illustration shows the relationship between the parameters passed to ID3D11DeviceContext::Dispatch, Dispatch(5,3,2), the values specified in the {{numthreads}} attribute, numthreads(10,8,3), and values that will passed to the compute shader for the thread-related system values 	
        /// ({{SV_GroupIndex}},{{SV_DispatchThreadID}},{{SV_GroupThreadID}},{{SV_GroupID}}). Illustration of the relationship between Dispatch, thread groups, and threads 	
        /// </remarks>	
        /// <param name="threadGroupCountX">The number of groups dispatched in the x direction. ThreadGroupCountX must be less than 64k.</param>
        /// <param name="threadGroupCountY">The number of groups dispatched in the y direction. ThreadGroupCountY must be less than 64k.</param>
        /// <param name="threadGroupCountZ">The number of groups dispatched in the z direction.  ThreadGroupCountZ must be less than 64k.  In feature level 10 the value for ThreadGroupCountZ must be 1.</param>
        /// <unmanaged>void Dispatch([In] UINT ThreadGroupCountX,[In] UINT ThreadGroupCountY,[In] UINT ThreadGroupCountZ)</unmanaged>
        public void Dispatch(int threadGroupCountX, int threadGroupCountY, int threadGroupCountZ) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 41 * 4, threadGroupCountX, threadGroupCountY, threadGroupCountZ);
            }
        }
        
        /// <summary>	
        /// Execute a command list to draw GPU-generated primitives over one or more thread groups.	
        /// </summary>	
        /// <remarks>	
        /// When an application creates a buffer that is associated with the <see cref="SlimDX2.Direct3D11.Buffer"/> interface that  pBufferForArgs points to, the application must set the <see cref="SlimDX2.Direct3D11.ResourceOptionFlags.DrawindirectArgs"/> flag in the MiscFlags member of the <see cref="SlimDX2.Direct3D11.BufferDescription"/> structure that describes the buffer. To create the buffer, the application calls the <see cref="SlimDX2.Direct3D11.Device.CreateBuffer"/> method and in this call passes a pointer to D3D11_BUFFER_DESC in the pDesc parameter.	
        /// </remarks>	
        /// <param name="bufferForArgsRef">A pointer to an <see cref="SlimDX2.Direct3D11.Buffer"/>, which must be loaded with data that matches the argument list for <see cref="SlimDX2.Direct3D11.DeviceContext.Dispatch"/>.</param>
        /// <param name="alignedByteOffsetForArgs">A byte-aligned offset between the start of the buffer and the arguments.</param>
        /// <unmanaged>void DispatchIndirect([In] ID3D11Buffer* pBufferForArgs,[In] UINT AlignedByteOffsetForArgs)</unmanaged>
        public void DispatchIndirect(SlimDX2.Direct3D11.Buffer bufferForArgsRef, int alignedByteOffsetForArgs) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 42 * 4, (void*)((bufferForArgsRef == null)?IntPtr.Zero:bufferForArgsRef.NativePointer), alignedByteOffsetForArgs);
            }
        }
        
        /// <summary>	
        /// Copy a region from a source resource to a destination resource.	
        /// </summary>	
        /// <remarks>	
        /// The source box must be within the size of the source resource. The destination offsets, (x, y, and z) allow the source box to be offset when writing into the destination resource; however, the dimensions of the source box and the offsets must be within the size of the resource.If the resources are buffers, all coordinates are in bytes; if the resources are textures, all coordinates are in texels. {{D3D11CalcSubresource}} is a helper function for calculating subresource indexes.CopySubresourceRegion performs the copy on the GPU (similar to a memcpy by the CPU). As a consequence, the source and destination resources:Must be different subresources (although they can be from the same resource).Must be the same type.Must have compatible DXGI formats (identical or from the same type group). For example, a DXGI_FORMAT_R32G32B32_FLOAT texture can be copied to an DXGI_FORMAT_R32G32B32_UINT texture since both of these formats are in the DXGI_FORMAT_R32G32B32_TYPELESS group.May not be currently mapped.CopySubresourceRegion only supports copy; it does not support any stretch, color key, blend, or format conversions. An application that needs to copy an entire resource should use <see cref="SlimDX2.Direct3D11.DeviceContext.CopyResource"/> instead.CopySubresourceRegion is an asynchronous call which may be added to the command-buffer queue, this attempts to remove pipeline stalls that may occur when copying data. See performance considerations for more details.Note If you use CopySubresourceRegion with a depth-stencil buffer or a multisampled resource, you must copy the whole subresource. In this situation, you must pass 0 to the DstX, DstY, and DstZ parameters and NULL to the pSrcBox parameter. In addition, source and destination resources, which are represented by the pSrcResource and pDstResource parameters, should have identical sample count values.ExampleThe following code snippet copies a box (located at (120,100),(200,220)) from a source texture into a reqion (10,20),(90,140) in a destination texture.	
        /// <code> D3D11_BOX sourceRegion;	
        /// sourceRegion.left = 120;	
        /// sourceRegion.right = 200;	
        /// sourceRegion.top = 100;	
        /// sourceRegion.bottom = 220;	
        /// sourceRegion.front = 0;	
        /// sourceRegion.back = 1; pd3dDeviceContext-&gt;CopySubresourceRegion( pDestTexture, 0, 10, 20, 0, pSourceTexture, 0, &amp;sourceRegion ); </code>	
        /// 	
        /// Notice, that for a 2D texture, front and back are set to 0 and 1 respectively.	
        /// </remarks>	
        /// <param name="dstResourceRef">A pointer to the destination resource (see <see cref="SlimDX2.Direct3D11.Resource"/>).</param>
        /// <param name="dstSubresource">Destination subresource index.</param>
        /// <param name="dstX">The x-coordinate of the upper left corner of the destination region.</param>
        /// <param name="dstY">The y-coordinate of the upper left corner of the destination region. For a 1D subresource, this must be zero.</param>
        /// <param name="dstZ">The z-coordinate of the upper left corner of the destination region. For a 1D or 2D subresource, this must be zero.</param>
        /// <param name="srcResourceRef">A pointer to the source resource (see <see cref="SlimDX2.Direct3D11.Resource"/>).</param>
        /// <param name="srcSubresource">Source subresource index.</param>
        /// <param name="srcBoxRef">A pointer to a 3D box (see <see cref="SlimDX2.Direct3D11.ResourceRegion"/>) that defines the source subresources that can be copied. If NULL, the entire source subresource is copied. The box must fit within the source resource.</param>
        /// <unmanaged>void CopySubresourceRegion([In] ID3D11Resource* pDstResource,[In] UINT DstSubresource,[In] UINT DstX,[In] UINT DstY,[In] UINT DstZ,[In] ID3D11Resource* pSrcResource,[In] UINT SrcSubresource,[In, Optional] const D3D11_BOX* pSrcBox)</unmanaged>
        public void CopySubresourceRegion(SlimDX2.Direct3D11.Resource dstResourceRef, int dstSubresource, int dstX, int dstY, int dstZ, SlimDX2.Direct3D11.Resource srcResourceRef, int srcSubresource, SlimDX2.Direct3D11.ResourceRegion? srcBoxRef) {
            unsafe {
                SlimDX2.Direct3D11.ResourceRegion srcBoxRef_;
                if (srcBoxRef.HasValue)
                    srcBoxRef_ = srcBoxRef.Value;				
                SlimDX2.Interop.CalliVoid(_nativePointer, 46 * 4, (void*)((dstResourceRef == null)?IntPtr.Zero:dstResourceRef.NativePointer), dstSubresource, dstX, dstY, dstZ, (void*)((srcResourceRef == null)?IntPtr.Zero:srcResourceRef.NativePointer), srcSubresource, (srcBoxRef.HasValue)?&srcBoxRef_:(void*)IntPtr.Zero);
            }
        }
        
        /// <summary>	
        /// Copy the entire contents of the source resource to the destination resource using the GPU. 	
        /// </summary>	
        /// <remarks>	
        /// This method is unusual in that it causes the GPU to perform the copy operation (similar to a memcpy by the CPU). As a result, it has a few restrictions designed for improving performance. For instance, the source and destination resources:Must be different resources.Must be the same type.Must have identical dimensions (including width, height, depth, and size as appropriate).Will only be copied. CopyResource does not support any stretch, color key, blend, or format conversions.Must have compatible DXGI formats, which means the formats must be identical or at least from the same type group. For example, a DXGI_FORMAT_R32G32B32_FLOAT texture can be copied to an DXGI_FORMAT_R32G32B32_UINT texture since both of these formats are in the DXGI_FORMAT_R32G32B32_TYPELESS group.Might not be currently mapped.You cannot use an {{Immutable}} resource as a destination. You can use a   {{depth-stencil}} resource as either a source or a destination.  Resources created with multisampling capability (see <see cref="SlimDX2.DXGI.SampleDescription"/>) can be used as source and destination only if both source and destination have identical multisampled count and quality. If source and destination differ in multisampled count and quality or if one is multisampled and the other is not multisampled the call to ID3D11DeviceContext::CopyResource fails.The method is an asynchronous call which may be added to the command-buffer queue. This attempts to remove pipeline stalls that may occur when copying data. An application that only needs to copy a portion of the data in a resource should use <see cref="SlimDX2.Direct3D11.DeviceContext.CopySubresourceRegion"/> instead.	
        /// </remarks>	
        /// <param name="dstResourceRef">A pointer to the destination resource (see <see cref="SlimDX2.Direct3D11.Resource"/>).</param>
        /// <param name="srcResourceRef">A pointer to the source resource (see <see cref="SlimDX2.Direct3D11.Resource"/>).</param>
        /// <unmanaged>void CopyResource([In] ID3D11Resource* pDstResource,[In] ID3D11Resource* pSrcResource)</unmanaged>
        public void CopyResource(SlimDX2.Direct3D11.Resource dstResourceRef, SlimDX2.Direct3D11.Resource srcResourceRef) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 47 * 4, (void*)((dstResourceRef == null)?IntPtr.Zero:dstResourceRef.NativePointer), (void*)((srcResourceRef == null)?IntPtr.Zero:srcResourceRef.NativePointer));
            }
        }
        
        /// <summary>	
        /// The CPU copies data from memory to a subresource created in non-mappable memory.	
        /// </summary>	
        /// <remarks>	
        /// For a shader-constant buffer; set pDstBox to NULL. It is not possible to use this method to partially update a shader-constant buffer.A resource cannot be used as a destination if:the resource is created with {{immutable}} usage.the resource is created as a depth-stencil resource.the resource is created with multisampling capability (see <see cref="SlimDX2.DXGI.SampleDescription"/>).When UpdateSubresource returns, the application is free to change or even free the data pointed to by pSrcData because the method has already copied/snapped away the original contents.The performance of UpdateSubresource depends on whether or not there is contention for the destination resource. For example, contention for a vertex buffer resource occurs when the application executes a Draw call and later calls UpdateSubresource on the same vertex buffer before the Draw call is actually executed by the GPU.When there is contention for the resource, UpdateSubresource will perform 2 copies of the source data. First, the data is copied by the CPU to a temporary storage space accessible by the command buffer. This copy happens before the method returns.  A second copy is then performed by the GPU to copy the source data into non-mappable memory. This second copy happens asynchronously because it is executed by GPU when the command buffer is flushed.When there is no resource contention, the behavior of UpdateSubresource is dependent on which is faster (from the CPU's perspective): copying the data to the command buffer and then having a second copy execute when the command buffer is flushed, or having the CPU copy the data to the final resource location. This is dependent on the architecture of the underlying system.To better understand the source row pitch and source depth pitch parameters, the following illustration shows a 3D volume texture. Illustration of a 3D volume texture Each block in this visual represents an element of data, and the size of each element is dependent on the resource's format. For example, if the resource format is DXGI_FORMAT_R32G32B32A32_FLOAT, the size of each element would be 128 bits, or 16 bytes. This 3D volume texture has a width of two, a height of three, and a depth of four.To calculate the source row pitch and source depth pitch for a given resource, use the following formulas:Source Row Pitch = [size of one element in bytes] * [number of elements in one row]Source Depth Pitch = [Source Row Pitch] * [number of rows (height)]In the case of this example 3D volume texture where the size of each element is 16 bytes, the formulas are as follows:Source Row Pitch = 16 * 2 = 32Source Depth Pitch = 16 * 2 * 3 = 96The following illustration shows the resource as it is laid out in memory. Illustration of a 3D volume texture laid out in memory For example, the following code snippet shows how to specify a destination region in a 2D texture. Assume the destination texture is 512x512 and the operation will copy the data pointed to by pData to  [(120,100)..(200,220)] in the destination texture. Also assume that rowPitch has been initialized with the proper value (as explained above). front and back are set to 0 and 1 respectively, because by having front equal to back, the box is technically empty.	
        /// <code> D3D11_BOX destRegion;	
        /// destRegion.left = 120;	
        /// destRegion.right = 200;	
        /// destRegion.top = 100;	
        /// destRegion.bottom = 220;	
        /// destRegion.front = 0;	
        /// destRegion.back = 1; pd3dDeviceContext-&gt;UpdateSubresource( pDestTexture, 0, &amp;destRegion, pData, rowPitch, 0 ); </code>	
        /// 	
        /// The 1D case is similar. The following snippet shows how to specify a destination region in a 1D texture. Use the same assumptions as above, except that the texture is 512 in length.	
        /// <code> D3D11_BOX destRegion;	
        /// destRegion.left = 120	
        /// destRegion.right = 200;	
        /// destRegion.top = 0;	
        /// destRegion.bottom = 1;	
        /// destRegion.front = 0;	
        /// destRegion.back = 1; pd3dDeviceContext-&gt;UpdateSubresource( pDestTexture, 0, &amp;destRegion, pData, rowPitch, 0 ); </code>	
        /// 	
        /// Calling UpdateSubresource on a Deferred ContextIf your application calls UpdateSubresource on a deferred context with a destination box?to which pDstBox points?that has a non-(0,0,0) offset, where the driver does not support command lists, UpdateSubresource inappropriately applies that destination-box offset to the pSrcData parameter. To work around this behavior, use the following code:	
        /// <code> HRESULT UpdateSubresource_Workaround( ID3D11Device *pDevice, ID3D11DeviceContext *pDeviceContext, ID3D11Resource *pDstResource, UINT dstSubresource, const D3D11_BOX *pDstBox, const void *pSrcData, UINT srcBytesPerElement, UINT srcRowPitch, UINT srcDepthPitch, bool* pDidWorkAround )	
        /// { HRESULT hr = S_OK; bool needWorkaround = false; D3D11_DEVICE_CONTEXT_TYPE contextType = pDeviceContext-&gt;GetType(); if( pDstBox &amp;&amp; (D3D11_DEVICE_CONTEXT_DEFERRED == contextType) ) { D3D11_FEATURE_DATA_THREADING threadingCaps = { FALSE, FALSE }; hr = pDevice-&gt;CheckFeatureSupport( D3D11_FEATURE_THREADING, &amp;threadingCaps, sizeof(threadingCaps) ); if( SUCCEEDED(hr) ) { if( !threadingCaps.DriverCommandLists ) { needWorkaround = true; } } } const void* pAdjustedSrcData = pSrcData; if( needWorkaround ) { D3D11_BOX alignedBox = *pDstBox; // convert from pixels to blocks if( m_bBC ) { alignedBox.left     /= 4; alignedBox.right    /= 4; alignedBox.top      /= 4; alignedBox.bottom   /= 4; } pAdjustedSrcData = ((const BYTE*)pSrcData) - (alignedBox.front * srcDepthPitch) - (alignedBox.top * srcRowPitch) - (alignedBox.left * srcBytesPerElement); } pDeviceContext-&gt;UpdateSubresource( pDstResource, dstSubresource, pDstBox, pAdjustedSrcData, srcRowPitch, srcDepthPitch ); if( pDidWorkAround ) { *pDidWorkAround = needWorkaround; } return hr;	
        /// } </code>	
        /// 	
        /// </remarks>	
        /// <param name="dstResourceRef">A pointer to the destination resource (see <see cref="SlimDX2.Direct3D11.Resource"/>).</param>
        /// <param name="dstSubresource">A zero-based index, that identifies the destination subresource. See {{D3D11CalcSubresource}} for more details.</param>
        /// <param name="dstBoxRef">A pointer to a box that defines the portion of the destination subresource to copy the resource data into. Coordinates are in bytes for buffers and in texels for textures. If NULL, the data is written to the destination subresource with no offset. The dimensions of the source must fit the destination (see <see cref="SlimDX2.Direct3D11.ResourceRegion"/>).</param>
        /// <param name="srcDataRef">A pointer to the source data in memory.</param>
        /// <param name="srcRowPitch">The size of one row of the source data.</param>
        /// <param name="srcDepthPitch">The size of one depth slice of source data.</param>
        /// <unmanaged>void UpdateSubresource([In] ID3D11Resource* pDstResource,[In] UINT DstSubresource,[In, Optional] const D3D11_BOX* pDstBox,[In] const void* pSrcData,[In] UINT SrcRowPitch,[In] UINT SrcDepthPitch)</unmanaged>
        internal void UpdateSubresource(SlimDX2.Direct3D11.Resource dstResourceRef, int dstSubresource, SlimDX2.Direct3D11.ResourceRegion? dstBoxRef, IntPtr srcDataRef, int srcRowPitch, int srcDepthPitch) {
            unsafe {
                SlimDX2.Direct3D11.ResourceRegion dstBoxRef_;
                if (dstBoxRef.HasValue)
                    dstBoxRef_ = dstBoxRef.Value;				
                SlimDX2.Interop.CalliVoid(_nativePointer, 48 * 4, (void*)((dstResourceRef == null)?IntPtr.Zero:dstResourceRef.NativePointer), dstSubresource, (dstBoxRef.HasValue)?&dstBoxRef_:(void*)IntPtr.Zero, (void*)srcDataRef, srcRowPitch, srcDepthPitch);
            }
        }
        
        /// <summary>	
        /// Copies data from a buffer holding variable length data.	
        /// </summary>	
        /// <param name="dstBufferRef">Pointer to <see cref="SlimDX2.Direct3D11.Buffer"/>.  This can be any buffer resource that other copy commands,  such as <see cref="SlimDX2.Direct3D11.DeviceContext.CopyResource"/> or <see cref="SlimDX2.Direct3D11.DeviceContext.CopySubresourceRegion"/>, are able to write to.</param>
        /// <param name="dstAlignedByteOffset">Offset from the start of pDstBuffer to write 32-bit UINT structure (vertex) count from pSrcView.</param>
        /// <param name="srcViewRef">Pointer to an <see cref="SlimDX2.Direct3D11.UnorderedAccessView"/> of a Structured Buffer resource created with either  <see cref="SlimDX2.Direct3D11.UnorderedAccessViewBufferFlags.Append"/> or D3D11_BUFFER_UAV_FLAG_COUNTER specified  when the UAV was created.   These types of resources have hidden counters tracking "how many" records have  been written.</param>
        /// <unmanaged>void CopyStructureCount([In] ID3D11Buffer* pDstBuffer,[In] UINT DstAlignedByteOffset,[In] ID3D11UnorderedAccessView* pSrcView)</unmanaged>
        public void CopyStructureCount(SlimDX2.Direct3D11.Buffer dstBufferRef, int dstAlignedByteOffset, SlimDX2.Direct3D11.UnorderedAccessView srcViewRef) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 49 * 4, (void*)((dstBufferRef == null)?IntPtr.Zero:dstBufferRef.NativePointer), dstAlignedByteOffset, (void*)((srcViewRef == null)?IntPtr.Zero:srcViewRef.NativePointer));
            }
        }
        
        /// <summary>	
        /// Set all the elements in a render target to one value.	
        /// </summary>	
        /// <remarks>	
        /// Applications that wish to clear a render target to a specific integer value bit pattern should render a screen-aligned quad instead of using this method.  The reason for this is because this method accepts as input a floating point value, which may not have the same bit pattern as the original integer.Differences between Direct3D 9 and Direct3D 11/10:Unlike Direct3D 9, the full extent of the resource view is always cleared. Viewport and scissor settings are not applied. 	
        /// </remarks>	
        /// <param name="renderTargetViewRef">Pointer to the rendertarget.</param>
        /// <param name="colorRGBA">A 4-component array that represents the color to fill the render target with.</param>
        /// <unmanaged>void ClearRenderTargetView([In] ID3D11RenderTargetView* pRenderTargetView,[In] const SLIMDX_COLOR4* ColorRGBA)</unmanaged>
        public void ClearRenderTargetView(SlimDX2.Direct3D11.RenderTargetView renderTargetViewRef, SlimMath.Color4 colorRGBA) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 50 * 4, (void*)((renderTargetViewRef == null)?IntPtr.Zero:renderTargetViewRef.NativePointer), &colorRGBA);
            }
        }
        
        /// <summary>	
        /// Clears an {{unordered access}} resource with bit-precise values.	
        /// </summary>	
        /// <remarks>	
        /// This API copies the lower ni bits from each array element i to the corresponding channel, where ni is the number of bits in  the ith channel of the resource format (for example, R8G8B8_FLOAT has 8 bits for the first 3 channels). This works on any UAV with no format conversion.  For a raw or structured buffer view, only the first array element value is used.	
        /// </remarks>	
        /// <param name="unorderedAccessViewRef">The <see cref="SlimDX2.Direct3D11.UnorderedAccessView"/> to clear.</param>
        /// <param name="values">Values to copy to corresponding channels, see remarks.</param>
        /// <unmanaged>void ClearUnorderedAccessViewUint([In] ID3D11UnorderedAccessView* pUnorderedAccessView,[In] const UINT Values[4])</unmanaged>
        public void ClearUnorderedAccessView(SlimDX2.Direct3D11.UnorderedAccessView unorderedAccessViewRef, SlimDX2.Int4 values) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 51 * 4, (void*)((unorderedAccessViewRef == null)?IntPtr.Zero:unorderedAccessViewRef.NativePointer), &values);
            }
        }
        
        /// <summary>	
        /// Clears an {{unordered access}} resource with a float value.	
        /// </summary>	
        /// <remarks>	
        /// This API works on FLOAT, UNORM, and SNORM unordered access views (UAVs), with format conversion from FLOAT to *NORM where appropriate. On other UAVs, the operation is invalid and the call will not reach the driver.	
        /// </remarks>	
        /// <param name="unorderedAccessViewRef">The <see cref="SlimDX2.Direct3D11.UnorderedAccessView"/> to clear.</param>
        /// <param name="values">Values to copy to corresponding channels, see remarks.</param>
        /// <unmanaged>void ClearUnorderedAccessViewFloat([In] ID3D11UnorderedAccessView* pUnorderedAccessView,[In] const FLOAT Values[4])</unmanaged>
        public void ClearUnorderedAccessView(SlimDX2.Direct3D11.UnorderedAccessView unorderedAccessViewRef, SlimMath.Vector4 values) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 52 * 4, (void*)((unorderedAccessViewRef == null)?IntPtr.Zero:unorderedAccessViewRef.NativePointer), &values);
            }
        }
        
        /// <summary>	
        /// Clears the depth-stencil resource.	
        /// </summary>	
        /// <remarks>	
        /// Differences between Direct3D 9 and Direct3D 11/10:Unlike Direct3D 9, the full extent of the resource view is always cleared. Viewport and scissor settings are not applied. 	
        /// </remarks>	
        /// <param name="depthStencilViewRef">Pointer to the depth stencil to be cleared.</param>
        /// <param name="clearFlags">Identify the type of data to clear (see <see cref="SlimDX2.Direct3D11.DepthStencilClearFlags"/>).</param>
        /// <param name="depth">Clear the depth buffer with this value. This value will be clamped between 0 and 1.</param>
        /// <param name="stencil">Clear the stencil buffer with this value.</param>
        /// <unmanaged>void ClearDepthStencilView([In] ID3D11DepthStencilView* pDepthStencilView,[In] UINT ClearFlags,[In] FLOAT Depth,[In] UINT8 Stencil)</unmanaged>
        public void ClearDepthStencilView(SlimDX2.Direct3D11.DepthStencilView depthStencilViewRef, SlimDX2.Direct3D11.DepthStencilClearFlags clearFlags, float depth, byte stencil) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 53 * 4, (void*)((depthStencilViewRef == null)?IntPtr.Zero:depthStencilViewRef.NativePointer), unchecked((int)clearFlags), depth, (int)stencil);
            }
        }
        
        /// <summary>	
        /// Generate mipmaps for the given shader resource.	
        /// </summary>	
        /// <remarks>	
        /// GenerateMips may be called on any shader-resource view in order to generate the lower mipmap levels. GenerateMips uses the largest mipmap level of the view to recursively generate the lower levels of the mip, stopping with the smallest level specified by the view. If the base resource was not created with <see cref="SlimDX2.Direct3D11.BindFlags.RenderTarget"/> and <see cref="SlimDX2.Direct3D11.ResourceOptionFlags.GenerateMips"/>, this call has no effect.All video adapters support generating mipmaps if you are using any of the following formats:	
        /// <code> DXGI_FORMAT_A8_UNORM	
        /// DXGI_FORMAT_R10G10B10A2_UNORM	
        /// DXGI_FORMAT_R11G11B10_FLOAT	
        /// DXGI_FORMAT_R16_FLOAT	
        /// DXGI_FORMAT_R16_SNORM	
        /// DXGI_FORMAT_R16_UNORM	
        /// DXGI_FORMAT_R16G16_FLOAT	
        /// DXGI_FORMAT_R16G16_SNORM	
        /// DXGI_FORMAT_R16G16_UNORM	
        /// DXGI_FORMAT_R16G16B16A16_FLOAT	
        /// DXGI_FORMAT_R16G16B16A16_SNORM	
        /// DXGI_FORMAT_R16G16B16A16_UNORM	
        /// DXGI_FORMAT_R32_FLOAT	
        /// DXGI_FORMAT_R32G32_FLOAT	
        /// DXGI_FORMAT_R32G32B32A32_FLOAT	
        /// DXGI_FORMAT_R8_SNORM	
        /// DXGI_FORMAT_R8_UNORM	
        /// DXGI_FORMAT_R8G8_SNORM	
        /// DXGI_FORMAT_R8G8_UNORM	
        /// DXGI_FORMAT_R8G8B8A8_SNORM	
        /// DXGI_FORMAT_R8G8B8A8_UNORM	
        /// DXGI_FORMAT_R8G8B8A8_UNORM_SRGB </code>	
        /// 	
        /// Some video adapters support generating mipmaps if you are using this format:	
        /// <code> DXGI_FORMAT_R32G32B32_FLOAT </code>	
        /// 	
        /// For all other unsupported formats, this method will silently fail.	
        /// </remarks>	
        /// <param name="shaderResourceViewRef">Pointer to an <see cref="SlimDX2.Direct3D11.ShaderResourceView"/> interface that represents the shader resource.</param>
        /// <unmanaged>void GenerateMips([In] ID3D11ShaderResourceView* pShaderResourceView)</unmanaged>
        public void GenerateMips(SlimDX2.Direct3D11.ShaderResourceView shaderResourceViewRef) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 54 * 4, (void*)((shaderResourceViewRef == null)?IntPtr.Zero:shaderResourceViewRef.NativePointer));
            }
        }
        
        /// <summary>	
        /// Sets the minimum level-of-detail (LOD) for a resource.	
        /// </summary>	
        /// <remarks>	
        /// To use a resource with SetResourceMinLOD, you must set the <see cref="SlimDX2.Direct3D11.ResourceOptionFlags.ResourceClamp"/> flag when you create that resource.For Direct3D 10 and Direct3D 10.1, when sampling from a texture resource in a shader, the sampler can define a minimum LOD clamp to force sampling from less detailed mip levels.  For Direct3D 11, this functionality is extended from the sampler to the entire resource. Therefore, the application can specify the highest-resolution mip level of a resource that is available for access. This restricts the set of mip levels that are required to be resident in GPU memory, thereby saving memory.The set of mip levels resident per-resource in GPU memory can be specified by the user.Minimum LOD affects all of the resident mip levels. Therefore, only the resident mip levels can be updated and read from.All methods that access texture resources must adhere to minimum LOD clamps.Empty-set accesses are handled as out-of-bounds cases.	
        /// </remarks>	
        /// <param name="resourceRef">A pointer to an <see cref="SlimDX2.Direct3D11.Resource"/> that represents the resource.</param>
        /// <param name="minLOD">The level-of-detail, which ranges between 0 and the maximum number of mipmap levels of the resource. For example, the maximum number of mipmap levels of a 1D texture is specified in the  MipLevels member of the  <see cref="SlimDX2.Direct3D11.Texture1DDescription"/> structure.</param>
        /// <unmanaged>void SetResourceMinLOD([In] ID3D11Resource* pResource,[None] FLOAT MinLOD)</unmanaged>
        public void SetMinimumLod(SlimDX2.Direct3D11.Resource resourceRef, float minLOD) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 55 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), minLOD);
            }
        }
        
        /// <summary>	
        /// Gets the minimum level-of-detail (LOD).	
        /// </summary>	
        /// <param name="resourceRef">A pointer to an <see cref="SlimDX2.Direct3D11.Resource"/> which represents the resource.</param>
        /// <returns>floatReturns the minimum LOD.</returns>
        /// <unmanaged>FLOAT GetResourceMinLOD([In] ID3D11Resource* pResource)</unmanaged>
        public float GetMinimumLod(SlimDX2.Direct3D11.Resource resourceRef) {
            unsafe {
                float __result__;
                __result__= (float)SlimDX2.Interop.CalliFloat(_nativePointer, 56 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer));
                return __result__;
            }
        }
        
        /// <summary>	
        /// Copy a multisampled resource into a non-multisampled resource.	
        /// </summary>	
        /// <remarks>	
        /// This API is most useful when re-using the resulting rendertarget of one render pass as an input to a second render pass.The source and destination resources must be the same resource type and have the same dimensions. In addition, they must have compatible formats. There are three scenarios for this:ScenarioRequirementsSource and destination are prestructured and typedBoth the source and destination must have identical formats and that format must be specified in the Format parameter.One resource is prestructured and typed and the other is prestructured and typelessThe typed resource must have a format that is compatible with the typeless resource (i.e. the typed resource is DXGI_FORMAT_R32_FLOAT and the typeless resource is DXGI_FORMAT_R32_TYPELESS). The format of the typed resource must be specified in the Format parameter.Source and destination are prestructured and typelessBoth the source and desintation must have the same typeless format (i.e. both must have DXGI_FORMAT_R32_TYPELESS), and the Format parameter must specify a format that is compatible with the source and destination (i.e. if both are DXGI_FORMAT_R32_TYPELESS then DXGI_FORMAT_R32_FLOAT could be specified in the Format parameter). For example, given the DXGI_FORMAT_R16G16B16A16_TYPELESS format:The source (or dest) format could be DXGI_FORMAT_R16G16B16A16_UNORMThe dest (or source) format could be DXGI_FORMAT_R16G16B16A16_FLOAT 	
        /// </remarks>	
        /// <param name="dstResourceRef">Destination resource. Must be a created with the <see cref="SlimDX2.Direct3D11.ResourceUsage.Default"/> flag and be single-sampled. See <see cref="SlimDX2.Direct3D11.Resource"/>.</param>
        /// <param name="dstSubresource">A zero-based index, that identifies the destination subresource. Use {{D3D11CalcSubresource}} to calculate the index.</param>
        /// <param name="srcResourceRef">Source resource. Must be multisampled.</param>
        /// <param name="srcSubresource">&gt;The source subresource of the source resource.</param>
        /// <param name="format">A <see cref="SlimDX2.DXGI.Format"/> that indicates how the multisampled resource will be resolved to a single-sampled resource.  See remarks.</param>
        /// <unmanaged>void ResolveSubresource([In] ID3D11Resource* pDstResource,[In] UINT DstSubresource,[In] ID3D11Resource* pSrcResource,[In] UINT SrcSubresource,[In] DXGI_FORMAT Format)</unmanaged>
        public void ResolveSubresource(SlimDX2.Direct3D11.Resource dstResourceRef, int dstSubresource, SlimDX2.Direct3D11.Resource srcResourceRef, int srcSubresource, SlimDX2.DXGI.Format format) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 57 * 4, (void*)((dstResourceRef == null)?IntPtr.Zero:dstResourceRef.NativePointer), dstSubresource, (void*)((srcResourceRef == null)?IntPtr.Zero:srcResourceRef.NativePointer), srcSubresource, unchecked((int)format));
            }
        }
        
        /// <summary>	
        /// Queues commands from a command list onto a device.	
        /// </summary>	
        /// <remarks>	
        /// Use this method to play back a command list that was recorded by a deferred context on any thread.This method performs some runtime validation related to queries. Queries that are begun in a device context cannot be manipulated indirectly by executing a command list (that is, Begin or End was invoked against the same query by the deferred context which generated the command list). If such a condition occurs, the ExecuteCommandList method does not execute the command list. However, the state of the device context is still maintained, as would be expected (<see cref="SlimDX2.Direct3D11.DeviceContext.ClearState"/> is performed, unless the application indicates to preserve the device context state).	
        /// </remarks>	
        /// <param name="commandListRef">A pointer to an <see cref="SlimDX2.Direct3D11.CommandList"/> interface that encapsulates a command list.</param>
        /// <param name="restoreContextState">A Boolean flag that determines whether the immediate context state is saved prior to and restored after the execution of a command list. Use TRUE to indicate that the runtime needs to save and restore the state. Use FALSE to indicate that no state shall be saved or restored, which causes the immediate context to  return to its default state after the command list executes. Applications should typically use FALSE unless they will restore the state to be nearly equivalent to the state that the runtime would restore if TRUE were passed. When applications use FALSE, they can avoid unnecessary and inefficient state transitions.</param>
        /// <unmanaged>void ExecuteCommandList([In] ID3D11CommandList* pCommandList,[None] BOOL RestoreContextState)</unmanaged>
        public void ExecuteCommandList(SlimDX2.Direct3D11.CommandList commandListRef, bool restoreContextState) {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 58 * 4, (void*)((commandListRef == null)?IntPtr.Zero:commandListRef.NativePointer), (restoreContextState?1:0));
            }
        }
        
        /// <summary>	
        /// Get the rendering predicate state.	
        /// </summary>	
        /// <remarks>	
        /// Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.	
        /// </remarks>	
        /// <param name="predicateRef">Address of a pointer to a predicate (see <see cref="SlimDX2.Direct3D11.Predicate"/>). Value stored here will be NULL upon device creation.</param>
        /// <param name="predicateValueRef">Address of a boolean to fill with the predicate comparison value. FALSE upon device creation.</param>
        /// <unmanaged>void GetPredication([Out, Optional] ID3D11Predicate** ppPredicate,[Out, Optional] BOOL* pPredicateValue)</unmanaged>
        public void GetPredication(out SlimDX2.Direct3D11.Predicate predicateRef, out bool predicateValueRef) {
            unsafe {
                IntPtr predicateRef_ = IntPtr.Zero;
                fixed (void* predicateValueRef_ = &predicateValueRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 86 * 4, &predicateRef_, predicateValueRef_);
                predicateRef = (predicateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Predicate(predicateRef_);	
            }
        }
        
        /// <summary>	
        /// Restore all default settings.	
        /// </summary>	
        /// <remarks>	
        /// This method resets any device context to the default settings. This sets all input/output resource slots, shaders, input layouts, predications, scissor rectangles, depth-stencil state, rasterizer state, blend state, sampler state, and viewports to NULL. The primitive topology is set to UNDEFINED.For a scenario where you would like to clear a list of commands recorded so far, call <see cref="SlimDX2.Direct3D11.DeviceContext.FinishCommandListInternal"/> and throw away the resulting <see cref="SlimDX2.Direct3D11.CommandList"/>.	
        /// </remarks>	
        /// <unmanaged>void ClearState()</unmanaged>
        public void ClearState() {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 110 * 4);
            }
        }
        
        /// <summary>	
        /// Send queued-up commands in the command buffer to the GPU.	
        /// </summary>	
        /// <remarks>	
        /// Most applications will not need to call this method. Calling this method when not necessary will incur a performance penalty.  Each call to Flush incurs a significant amount of overhead.When Direct3D state-setting, present, or draw commands are called by an application, those commands are queued into an internal command buffer.  Flush sends those commands to the GPU for processing. Normally, these commands are sent to the GPU automatically whenever Direct3D determines that  they need to be, such as when the command buffer is full or when mapping a resource. Flush will send the commands manually.Flush should be used when the CPU waits for an arbitrary amount of time (such as when  calling {{Sleep}}).Because Flush operates asynchronously,  it can return either before or after the GPU finishes executing the queued graphics commands. However, the graphics commands will eventually always complete. You can call the <see cref="SlimDX2.Direct3D11.Device.CreateQuery"/> method with the <see cref="SlimDX2.Direct3D11.QueryType.Event"/> value to create an event query; you can then use that event query in a call to the <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> method to determine when the GPU is finished processing the graphics commands.	
        /// Direct3D11 defers the destruction of objects, an application cannot rely upon objects immediately being destroyed. Calling Flush will destroy any  objects whose destruction has been deferred.  If an application requires synchronous destruction of an object the application should release all its references, call <see cref="SlimDX2.Direct3D11.DeviceContext.ClearState"/>, and then call Flush.	
        /// </remarks>	
        /// <unmanaged>void Flush()</unmanaged>
        public void Flush() {
            unsafe {
                SlimDX2.Interop.CalliVoid(_nativePointer, 111 * 4);
            }
        }
        
        /// <summary>	
        /// Gets the type of {{device context}}.	
        /// </summary>	
        /// <returns>A member of <see cref="SlimDX2.Direct3D11.DeviceContextType"/> that indicates the type of device context.</returns>
        /// <unmanaged>D3D11_DEVICE_CONTEXT_TYPE GetType()</unmanaged>
        internal SlimDX2.Direct3D11.DeviceContextType GetTypeInfo() {
            unsafe {
                SlimDX2.Direct3D11.DeviceContextType __result__;
                __result__= (SlimDX2.Direct3D11.DeviceContextType)SlimDX2.Interop.CalliInt(_nativePointer, 112 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the initialization flags associated with the current deferred context.	
        /// </summary>	
        /// <remarks>	
        /// The GetContextFlags method gets the flags that were supplied to the ContextFlags parameter of <see cref="SlimDX2.Direct3D11.Device.CreateDeferredContext"/>; however, the context flag is reserved for future use.	
        /// </remarks>	
        /// <returns>No documentation.</returns>
        /// <unmanaged>UINT GetContextFlags()</unmanaged>
        internal int GetContextFlags() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Interop.CalliInt(_nativePointer, 113 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a command list and record graphics commands into it.	
        /// </summary>	
        /// <remarks>	
        /// Create a command list from a deferred context and record commands into it by calling FinishCommandList. Play back a command list with an immediate context by calling <see cref="SlimDX2.Direct3D11.DeviceContext.ExecuteCommandList"/>.Immediate context state is cleared before and after a command list is executed. A command list has no concept of inheritance. Each call to FinishCommandList will record only the state set since any previous call to  FinishCommandList.For example, the state of a {{device context}} is its render state or pipeline state. To retrieve device context state, an application can call  <see cref="SlimDX2.Direct3D11.DeviceContext.GetDataInternal"/> or  <see cref="SlimDX2.Direct3D11.DeviceContext.GetPredication"/>.For more information about how to use FinishCommandList, see {{How to: Record a Command List}}.	
        /// </remarks>	
        /// <param name="restoreDeferredContextState">A Boolean flag that determines whether the runtime saves deferred context state before it executes  FinishCommandList and restores it afterwards. Use TRUE to indicate that the runtime needs to save and restore the state. Use FALSE to indicate that the runtime will not save or restore any state. In this case, the deferred context will  return to its default state after the call to  FinishCommandList completes. Typically, use FALSE unless you restore the state to be nearly equivalent to the state that the runtime would restore if you passed TRUE. When you use FALSE, you can avoid unnecessary and inefficient state transitions.</param>
        /// <param name="commandListRef">Upon completion of the method, the passed pointer to an <see cref="SlimDX2.Direct3D11.CommandList"/> interface pointer is initialized with the recorded command list information.</param>
        /// <returns>Returns S_OK if successful; otherwise, returns one of the following:Returns DXGI_ERROR_DEVICE_REMOVED if the video card has been physically removed from the system, or a driver upgrade for the video card has occurred. If this error occurs, you should destroy and recreate the device.Returns DXGI_ERROR_INVALID_CALL if FinishCommandList cannot be called from the current context. See remarks.Returns E_OUTOFMEMORY if the application has exhausted available memory.</returns>
        /// <unmanaged>HRESULT FinishCommandList([None] BOOL RestoreDeferredContextState,[Out, Optional] ID3D11CommandList** ppCommandList)</unmanaged>
        internal SlimDX2.Result FinishCommandListInternal(bool restoreDeferredContextState, out SlimDX2.Direct3D11.CommandList commandListRef) {
            unsafe {
                IntPtr commandListRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 114 * 4, (restoreDeferredContextState?1:0), &commandListRef_);
                commandListRef = (commandListRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.CommandList(commandListRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// The device interface represents a virtual adapter; it is used to create resources.	
    /// </summary>	
    /// <unmanaged>ID3D11Device</unmanaged>
    [Guid("db6f6ddb-ac77-4e88-8253-819df9bbf140")]
    public partial class Device : SlimDX2.ComObject {

        public Device(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the feature level of the hardware device.	
        /// </summary>	
        /// <remarks>	
        /// {{Feature levels}} determine the capabilities of your device.	
        /// </remarks>	
        /// <unmanaged>D3D_FEATURE_LEVEL GetFeatureLevel()</unmanaged>
        public SlimDX2.Direct3D.FeatureLevel FeatureLevel {
                get { return GetFeatureLevel(); }
        }
        
        /// <summary>	
        /// Get the flags used during the call to create the device with <see cref="SlimDX2.Direct3D11.D3D11.CreateDevice"/>.	
        /// </summary>	
        /// <unmanaged>UINT GetCreationFlags()</unmanaged>
        public int CreationFlags {
                get { return GetCreationFlags(); }
        }
        
        /// <summary>	
        /// Get the reason why the device was removed.	
        /// </summary>	
        /// <unmanaged>HRESULT GetDeviceRemovedReason()</unmanaged>
        public SlimDX2.Result DeviceRemovedReason {
                get { return GetDeviceRemovedReason(); }
        }
        
        /// <summary>	
        /// Get the exception-mode flags.	
        /// </summary>	
        /// <remarks>	
        /// An exception-mode flag is used to elevate an error condition to a non-continuable exception. 	
        /// </remarks>	
        /// <unmanaged>UINT GetExceptionMode()</unmanaged>
        public int ExceptionMode {
                get { return GetExceptionMode(); }
                set { SetExceptionMode(value); }
        }
        
        /// <summary>	
        /// Create a buffer (vertex buffer, index buffer, or shader-constant buffer).	
        /// </summary>	
        /// <remarks>	
        /// For example code, see {{How to: Create a Vertex Buffer}},  {{How to: Create an Index Buffer}} or {{How to: Create a Constant Buffer}}.	
        /// </remarks>	
        /// <param name="descRef">Pointer to a buffer description (see <see cref="SlimDX2.Direct3D11.BufferDescription"/>).</param>
        /// <param name="initialDataRef">Pointer to the initialization data (see <see cref="SlimDX2.Direct3D11.SubResourceData"/>);  use NULL to allocate space only (with the exception that it cannot be NULL if the usage flag is D3D11_USAGE_IMMUTABLE).</param>
        /// <param name="bufferRef">Address of a pointer to the buffer created (see <see cref="SlimDX2.Direct3D11.Buffer"/>).  Set this parameter to NULL to validate the other input parameters (S_FALSE indicates a pass).</param>
        /// <returns>This method returns E_OUTOFMEMORY if there is insufficient memory to create the buffer.   See {{Direct3D 11 Return Codes}} for other possible return values.</returns>
        /// <unmanaged>HRESULT CreateBuffer([In] const D3D11_BUFFER_DESC* pDesc,[In, Optional] const D3D11_SUBRESOURCE_DATA* pInitialData,[Out, Optional] ID3D11Buffer** ppBuffer)</unmanaged>
        internal SlimDX2.Result CreateBuffer(ref SlimDX2.Direct3D11.BufferDescription descRef, SlimDX2.Direct3D11.SubResourceData? initialDataRef, out SlimDX2.Direct3D11.Buffer bufferRef) {
            unsafe {
                SlimDX2.Direct3D11.SubResourceData initialDataRef_;
                if (initialDataRef.HasValue)
                    initialDataRef_ = initialDataRef.Value;				
                IntPtr bufferRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 3 * 4, descRef_, (initialDataRef.HasValue)?&initialDataRef_:(void*)IntPtr.Zero, &bufferRef_);
                bufferRef = (bufferRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Buffer(bufferRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create an array of {{1D textures}}.	
        /// </summary>	
        /// <remarks>	
        /// CreateTexture1D creates a 1D texture resource, which can contain a number of 1D subresources. The number of textures is specified in the texture description. All textures in a resource must have the same format, size, and number of mipmap levels.All resources are made up of one or more subresources. To load data into the texture, applications may supply the data initially as part of <see cref="SlimDX2.Direct3D11.SubResourceData"/> structure pointed to by pInitialData, or it may use one of the D3DX texture functions such as {{D3DX11CreateTextureFromFile}}.	
        /// </remarks>	
        /// <param name="descRef">Pointer to a 1D texture description (see <see cref="SlimDX2.Direct3D11.Texture1DDescription"/>). To create a typeless resource that can be interpreted at runtime into different, compatible formats, specify a typeless format in the texture description. To generate mipmap levels automatically, set the number of mipmap levels to 0.</param>
        /// <param name="initialDataRef">Pointer to an array of subresource descriptions (see <see cref="SlimDX2.Direct3D11.SubResourceData"/>); one for each subresource. Applications may not specify NULL for pInitialData when creating IMMUTABLE resources (see <see cref="SlimDX2.Direct3D11.ResourceUsage"/>). If the resource is multisampled, pInitialData must be NULL because multisampled resources cannot be initialized with data when they are created.</param>
        /// <param name="texture1DRef">Address of a pointer to the created texture (see <see cref="SlimDX2.Direct3D11.Texture1D"/>). Set this parameter to NULL to validate the other input parameters (the method will return S_FALSE if the other input parameters pass validation).</param>
        /// <returns>If the method succeeds, the return code is S_OK. See {{Direct3D 11 Return Codes}} for failing error codes.</returns>
        /// <unmanaged>HRESULT CreateTexture1D([In] const D3D11_TEXTURE1D_DESC* pDesc,[In, Buffer, Optional] const D3D11_SUBRESOURCE_DATA* pInitialData,[Out, Optional] ID3D11Texture1D** ppTexture1D)</unmanaged>
        internal SlimDX2.Result CreateTexture1D(ref SlimDX2.Direct3D11.Texture1DDescription descRef, SlimDX2.Direct3D11.SubResourceData[] initialDataRef, out SlimDX2.Direct3D11.Texture1D texture1DRef) {
            unsafe {
                SlimDX2.Direct3D11.SubResourceData[] initialDataRef__ = initialDataRef ?? new SlimDX2.Direct3D11.SubResourceData[1];
                IntPtr texture1DRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    fixed (void* initialDataRef_ = &initialDataRef__[0])
                        __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 4 * 4, descRef_, initialDataRef==null?(void*)IntPtr.Zero:initialDataRef_, &texture1DRef_);
                texture1DRef = (texture1DRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Texture1D(texture1DRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create an array of {{2D textures}}.	
        /// </summary>	
        /// <remarks>	
        /// CreateTexture2D creates a 2D texture resource, which can contain a number of 2D subresources. The number of textures is specified in the texture description. All textures in a resource must have the same format, size, and number of mipmap levels.All resources are made up of one or more subresources. To load data into the texture, applications may supply the data initially as part of <see cref="SlimDX2.Direct3D11.SubResourceData"/> structure pointed to by pInitialData, or it may use one of the D3DX texture functions such as {{D3DX11CreateTextureFromFile}}.	
        /// </remarks>	
        /// <param name="descRef">Pointer to a 2D texture description (see <see cref="SlimDX2.Direct3D11.Texture2DDescription"/>). To create a typeless resource that can be interpreted at runtime into different, compatible formats, specify a typeless format in the texture description. To generate mipmap levels automatically, set the number of mipmap levels to 0.</param>
        /// <param name="initialDataRef">Pointer to an array of subresource descriptions (see <see cref="SlimDX2.Direct3D11.SubResourceData"/>); one for each subresource. Applications may not specify NULL for pInitialData when creating IMMUTABLE resources (see <see cref="SlimDX2.Direct3D11.ResourceUsage"/>). If the resource is multisampled, pInitialData must be NULL because multisampled resources cannot be initialized with data when they are created.</param>
        /// <param name="texture2DRef">Address of a pointer to the created texture (see <see cref="SlimDX2.Direct3D11.Texture2D"/>). Set this parameter to NULL to validate the other input parameters (the method will return S_FALSE if the other input parameters pass validation).</param>
        /// <returns>If the method succeeds, the return code is S_OK. See {{Direct3D 11 Return Codes}} for failing error codes.</returns>
        /// <unmanaged>HRESULT CreateTexture2D([In] const D3D11_TEXTURE2D_DESC* pDesc,[In, Buffer, Optional] const D3D11_SUBRESOURCE_DATA* pInitialData,[Out, Optional] ID3D11Texture2D** ppTexture2D)</unmanaged>
        internal SlimDX2.Result CreateTexture2D(ref SlimDX2.Direct3D11.Texture2DDescription descRef, SlimDX2.Direct3D11.SubResourceData[] initialDataRef, out SlimDX2.Direct3D11.Texture2D texture2DRef) {
            unsafe {
                SlimDX2.Direct3D11.SubResourceData[] initialDataRef__ = initialDataRef ?? new SlimDX2.Direct3D11.SubResourceData[1];
                IntPtr texture2DRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    fixed (void* initialDataRef_ = &initialDataRef__[0])
                        __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 5 * 4, descRef_, initialDataRef==null?(void*)IntPtr.Zero:initialDataRef_, &texture2DRef_);
                texture2DRef = (texture2DRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Texture2D(texture2DRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a single {{3D texture}}.	
        /// </summary>	
        /// <remarks>	
        /// CreateTexture3D creates a 3D texture resource, which can contain a number of 3D subresources. The number of textures is specified in the texture description. All textures in a resource must have the same format, size, and number of mipmap levels.All resources are made up of one or more subresources. To load data into the texture, applications may supply the data initially as part of <see cref="SlimDX2.Direct3D11.SubResourceData"/> structure pointed to by pInitialData, or it may use one of the D3DX texture functions such as {{D3DX11CreateTextureFromFile}}.	
        /// </remarks>	
        /// <param name="descRef">Pointer to a 3D texture description (see <see cref="SlimDX2.Direct3D11.Texture3DDescription"/>). To create a typeless resource that can be interpreted at runtime into different, compatible formats, specify a typeless format in the texture description. To generate mipmap levels automatically, set the number of mipmap levels to 0.</param>
        /// <param name="initialDataRef">Pointer to an array of subresource descriptions (see <see cref="SlimDX2.Direct3D11.SubResourceData"/>); one for each subresource. Applications may not specify NULL for pInitialData when creating IMMUTABLE resources (see <see cref="SlimDX2.Direct3D11.ResourceUsage"/>). If the resource is multisampled, pInitialData must be NULL because multisampled resources cannot be initialized with data when they are created.</param>
        /// <param name="texture3DRef">Address of a pointer to the created texture (see <see cref="SlimDX2.Direct3D11.Texture3D"/>). Set this parameter to NULL to validate the other input parameters (the method will return S_FALSE if the other input parameters pass validation).</param>
        /// <returns>If the method succeeds, the return code is S_OK. See {{Direct3D 11 Return Codes}} for failing error codes.</returns>
        /// <unmanaged>HRESULT CreateTexture3D([In] const D3D11_TEXTURE3D_DESC* pDesc,[In, Buffer, Optional] const D3D11_SUBRESOURCE_DATA* pInitialData,[Out, Optional] ID3D11Texture3D** ppTexture3D)</unmanaged>
        internal SlimDX2.Result CreateTexture3D(ref SlimDX2.Direct3D11.Texture3DDescription descRef, SlimDX2.Direct3D11.SubResourceData[] initialDataRef, out SlimDX2.Direct3D11.Texture3D texture3DRef) {
            unsafe {
                SlimDX2.Direct3D11.SubResourceData[] initialDataRef__ = initialDataRef ?? new SlimDX2.Direct3D11.SubResourceData[1];
                IntPtr texture3DRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* descRef_ = &descRef)
                    fixed (void* initialDataRef_ = &initialDataRef__[0])
                        __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 6 * 4, descRef_, initialDataRef==null?(void*)IntPtr.Zero:initialDataRef_, &texture3DRef_);
                texture3DRef = (texture3DRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Texture3D(texture3DRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a shader-resource view for accessing data in a resource.	
        /// </summary>	
        /// <remarks>	
        /// A resource is made up of one or more subresources, a view identifies which subresources to allow the pipeline to access. In addition, each resource is bound to the pipeline using a view. A shader-resource view is designed to bind any buffer or texture resource to the shader stages using the following  API methods: <see cref="SlimDX2.Direct3D11.DeviceContext.VertexShaderStage.SetShaderResources"/>, <see cref="SlimDX2.Direct3D11.DeviceContext.GeometryShaderStage.SetShaderResources"/> and <see cref="SlimDX2.Direct3D11.DeviceContext.PixelShaderStage.SetShaderResources"/>.Since a view is fully typed, this means that typeless resources become fully typed when bound to the pipeline.	
        /// </remarks>	
        /// <param name="resourceRef">Pointer to the resource that will serve as input to a shader. This resource must have been created with the <see cref="SlimDX2.Direct3D11.BindFlags.ShaderResource"/> flag.</param>
        /// <param name="descRef">Pointer to a shader-resource-view description (see <see cref="SlimDX2.Direct3D11.ShaderResourceViewDescription"/>). Set this parameter to NULL to create a  view that accesses the entire resource (using the format the resource was created with).</param>
        /// <param name="sRViewRef">Address of a pointer to an <see cref="SlimDX2.Direct3D11.ShaderResourceView"/>. Set this parameter to NULL to validate the  other input parameters (the method will return S_FALSE if the other input parameters pass validation).</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateShaderResourceView([In] ID3D11Resource* pResource,[In, Optional] const D3D11_SHADER_RESOURCE_VIEW_DESC* pDesc,[Out, Optional] ID3D11ShaderResourceView** ppSRView)</unmanaged>
        internal SlimDX2.Result CreateShaderResourceView(SlimDX2.Direct3D11.Resource resourceRef, SlimDX2.Direct3D11.ShaderResourceViewDescription? descRef, out SlimDX2.Direct3D11.ShaderResourceView sRViewRef) {
            unsafe {
                SlimDX2.Direct3D11.ShaderResourceViewDescription descRef_;
                if (descRef.HasValue)
                    descRef_ = descRef.Value;				
                IntPtr sRViewRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 7 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), (descRef.HasValue)?&descRef_:(void*)IntPtr.Zero, &sRViewRef_);
                sRViewRef = (sRViewRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ShaderResourceView(sRViewRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a view for accessing an {{unordered access}} resource.	
        /// </summary>	
        /// <param name="resourceRef">Pointer to an <see cref="SlimDX2.Direct3D11.Resource"/> that represents a resources that will be serve as an input to a shader.</param>
        /// <param name="descRef">Pointer to an <see cref="SlimDX2.Direct3D11.UnorderedAccessViewDescription"/> that represents a shader-resource-view description. Set this parameter to NULL to create a view that accesses the entire resource (using the format the resource was created with).</param>
        /// <param name="uAViewRef">Address of a pointer to an <see cref="SlimDX2.Direct3D11.UnorderedAccessView"/> that represents an unordered access view. Set this parameter to NULL to validate the other input parameters (the method will return S_FALSE if the other input parameters pass validation).</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateUnorderedAccessView([In] ID3D11Resource* pResource,[In, Optional] const D3D11_UNORDERED_ACCESS_VIEW_DESC* pDesc,[Out, Optional] ID3D11UnorderedAccessView** ppUAView)</unmanaged>
        internal SlimDX2.Result CreateUnorderedAccessView(SlimDX2.Direct3D11.Resource resourceRef, SlimDX2.Direct3D11.UnorderedAccessViewDescription? descRef, out SlimDX2.Direct3D11.UnorderedAccessView uAViewRef) {
            unsafe {
                SlimDX2.Direct3D11.UnorderedAccessViewDescription descRef_;
                if (descRef.HasValue)
                    descRef_ = descRef.Value;				
                IntPtr uAViewRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 8 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), (descRef.HasValue)?&descRef_:(void*)IntPtr.Zero, &uAViewRef_);
                uAViewRef = (uAViewRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.UnorderedAccessView(uAViewRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a render-target view for accessing resource data.	
        /// </summary>	
        /// <remarks>	
        /// A rendertarget view can be bound to the output-merger stage by calling <see cref="SlimDX2.Direct3D11.DeviceContext.OutputMergerStage.SetRenderTargets"/>.	
        /// </remarks>	
        /// <param name="resourceRef">Pointer to a <see cref="SlimDX2.Direct3D11.Resource"/> which represents a render target. This resource must have been created with the <see cref="SlimDX2.Direct3D11.BindFlags.RenderTarget"/> flag.</param>
        /// <param name="descRef">Pointer to a <see cref="SlimDX2.Direct3D11.RenderTargetViewDescription"/> which represents a render-target-view description. Set this parameter to NULL to create a view that accesses all of the subresources in mipmap level 0.</param>
        /// <param name="rTViewRef">Address of a pointer to an <see cref="SlimDX2.Direct3D11.RenderTargetView"/>. Set this parameter to NULL to validate the other input parameters (the method will return S_FALSE if the other input parameters pass validation).</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateRenderTargetView([In] ID3D11Resource* pResource,[In, Optional] const D3D11_RENDER_TARGET_VIEW_DESC* pDesc,[Out, Optional] ID3D11RenderTargetView** ppRTView)</unmanaged>
        internal SlimDX2.Result CreateRenderTargetView(SlimDX2.Direct3D11.Resource resourceRef, SlimDX2.Direct3D11.RenderTargetViewDescription? descRef, out SlimDX2.Direct3D11.RenderTargetView rTViewRef) {
            unsafe {
                SlimDX2.Direct3D11.RenderTargetViewDescription descRef_;
                if (descRef.HasValue)
                    descRef_ = descRef.Value;				
                IntPtr rTViewRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 9 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), (descRef.HasValue)?&descRef_:(void*)IntPtr.Zero, &rTViewRef_);
                rTViewRef = (rTViewRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.RenderTargetView(rTViewRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a depth-stencil view for accessing resource data.	
        /// </summary>	
        /// <remarks>	
        /// A depth-stencil view can be bound to the output-merger stage by calling <see cref="SlimDX2.Direct3D11.DeviceContext.OutputMergerStage.SetRenderTargets"/>.	
        /// </remarks>	
        /// <param name="resourceRef">Pointer to the resource that will serve as the depth-stencil surface. This resource must have been created with the <see cref="SlimDX2.Direct3D11.BindFlags.DepthStencil"/> flag.</param>
        /// <param name="descRef">Pointer to a depth-stencil-view description (see <see cref="SlimDX2.Direct3D11.DepthStencilViewDescription"/>). Set this parameter to NULL to create a view that accesses mipmap level 0 of the entire resource (using the format the resource was created with).</param>
        /// <param name="depthStencilViewRef">Address of a pointer to an <see cref="SlimDX2.Direct3D11.DepthStencilView"/>. Set this parameter to NULL to validate the other input parameters (the method will return S_FALSE if the other input parameters pass validation).</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateDepthStencilView([In] ID3D11Resource* pResource,[In, Optional] const D3D11_DEPTH_STENCIL_VIEW_DESC* pDesc,[Out, Optional] ID3D11DepthStencilView** ppDepthStencilView)</unmanaged>
        internal SlimDX2.Result CreateDepthStencilView(SlimDX2.Direct3D11.Resource resourceRef, SlimDX2.Direct3D11.DepthStencilViewDescription? descRef, out SlimDX2.Direct3D11.DepthStencilView depthStencilViewRef) {
            unsafe {
                SlimDX2.Direct3D11.DepthStencilViewDescription descRef_;
                if (descRef.HasValue)
                    descRef_ = descRef.Value;				
                IntPtr depthStencilViewRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 10 * 4, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), (descRef.HasValue)?&descRef_:(void*)IntPtr.Zero, &depthStencilViewRef_);
                depthStencilViewRef = (depthStencilViewRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.DepthStencilView(depthStencilViewRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create an input-layout object to describe the input-buffer data for the input-assembler stage.	
        /// </summary>	
        /// <remarks>	
        /// After creating an input layout object, it must be bound to the input-assembler stage before calling a draw API.Once an input-layout object is created from a shader signature, the input-layout object can be reused with any other shader that has an identical input signature (semantics included). This can simplify the creation of input-layout objects when you are working with many shaders with identical inputs.If a data type in the input-layout declaration does not match the data type in a shader-input signature, CreateInputLayout will generate a warning during compilation. The warning is simply to call attention to the fact that the data may be reinterpreted when read from a register. You may either disregard this warning (if reinterpretation is intentional) or make the data types match in both declarations to eliminate the warning.	
        /// </remarks>	
        /// <param name="inputElementDescsRef">An array of the input-assembler stage input data types; each type is described by an element description (see <see cref="SlimDX2.Direct3D11.InputElement"/>).</param>
        /// <param name="numElements">The number of input-data types in the array of input-elements.</param>
        /// <param name="shaderBytecodeWithInputSignatureRef">A pointer to the compiled shader.  The compiled shader code contains a input signature which is validated against the array of elements. See remarks.</param>
        /// <param name="bytecodeLength">Size of the compiled shader.</param>
        /// <param name="inputLayoutRef">A pointer to the input-layout object created (see <see cref="SlimDX2.Direct3D11.InputLayout"/>). To validate the other input parameters, set this pointer to be NULL and verify that the method returns S_FALSE.</param>
        /// <returns>If the method succeeds, the return code is S_OK. See {{Direct3D 11 Return Codes}} for failing error codes.</returns>
        /// <unmanaged>HRESULT CreateInputLayout([In, Buffer] const D3D11_INPUT_ELEMENT_DESC* pInputElementDescs,[In] UINT NumElements,[In] const void* pShaderBytecodeWithInputSignature,[In] SIZE_T BytecodeLength,[Out, Optional] ID3D11InputLayout** ppInputLayout)</unmanaged>
        internal SlimDX2.Result CreateInputLayout(SlimDX2.Direct3D11.InputElement[] inputElementDescsRef, int numElements, IntPtr shaderBytecodeWithInputSignatureRef, SlimDX2.Size bytecodeLength, out SlimDX2.Direct3D11.InputLayout inputLayoutRef) {
            unsafe {
                SlimDX2.Direct3D11.InputElement.__Native[] inputElementDescsRef__ = new SlimDX2.Direct3D11.InputElement.__Native[inputElementDescsRef.Length];
                for (int i = 0; i < inputElementDescsRef.Length; i++)
                    inputElementDescsRef[i].__MarshalTo(ref inputElementDescsRef__[i]);				
                IntPtr inputLayoutRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* inputElementDescsRef_ = &inputElementDescsRef__[0])
                    __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 11 * 4, inputElementDescsRef_, numElements, (void*)shaderBytecodeWithInputSignatureRef, (void*)bytecodeLength, &inputLayoutRef_);
                for (int i = 0; i < inputElementDescsRef.Length; i++)
                    inputElementDescsRef__[i].__MarshalFree();				
                inputLayoutRef = (inputLayoutRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.InputLayout(inputLayoutRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a vertex-shader object from a compiled shader.	
        /// </summary>	
        /// <param name="shaderBytecodeRef">A pointer to the compiled shader. </param>
        /// <param name="bytecodeLength">Size of the compiled vertex shader.</param>
        /// <param name="classLinkageRef">A pointer to a class linkage interface (see <see cref="SlimDX2.Direct3D11.ClassLinkage"/>); the value can be NULL.</param>
        /// <param name="vertexShaderRef">Address of a pointer to a <see cref="SlimDX2.Direct3D11.VertexShader"/> interface. If this is NULL, all other parameters will be validated, and if all parameters pass validation this API will return S_FALSE instead of S_OK.</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateVertexShader([In] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In, Optional] ID3D11ClassLinkage* pClassLinkage,[Out, Optional] ID3D11VertexShader** ppVertexShader)</unmanaged>
        internal SlimDX2.Result CreateVertexShader(IntPtr shaderBytecodeRef, SlimDX2.Size bytecodeLength, SlimDX2.Direct3D11.ClassLinkage classLinkageRef, out SlimDX2.Direct3D11.VertexShader vertexShaderRef) {
            unsafe {
                IntPtr vertexShaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 12 * 4, (void*)shaderBytecodeRef, (void*)bytecodeLength, (void*)((classLinkageRef == null)?IntPtr.Zero:classLinkageRef.NativePointer), &vertexShaderRef_);
                vertexShaderRef = (vertexShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.VertexShader(vertexShaderRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a geometry shader.	
        /// </summary>	
        /// <remarks>	
        /// Once created, the shader can be set to the device by calling <see cref="SlimDX2.Direct3D11.DeviceContext.GeometryShaderStage.SetShader"/>.	
        /// </remarks>	
        /// <param name="shaderBytecodeRef">A pointer to the compiled shader.  </param>
        /// <param name="bytecodeLength">Size of the compiled geometry shader.</param>
        /// <param name="classLinkageRef">A pointer to a class linkage interface (see <see cref="SlimDX2.Direct3D11.ClassLinkage"/>); the value can be NULL.</param>
        /// <param name="geometryShaderRef">Address of a pointer to a <see cref="SlimDX2.Direct3D11.GeometryShader"/> interface. If this is NULL, all other parameters will be validated, and if all parameters pass validation this API will return S_FALSE instead of S_OK.</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateGeometryShader([In] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In, Optional] ID3D11ClassLinkage* pClassLinkage,[Out, Optional] ID3D11GeometryShader** ppGeometryShader)</unmanaged>
        internal SlimDX2.Result CreateGeometryShader(IntPtr shaderBytecodeRef, SlimDX2.Size bytecodeLength, SlimDX2.Direct3D11.ClassLinkage classLinkageRef, out SlimDX2.Direct3D11.GeometryShader geometryShaderRef) {
            unsafe {
                IntPtr geometryShaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 13 * 4, (void*)shaderBytecodeRef, (void*)bytecodeLength, (void*)((classLinkageRef == null)?IntPtr.Zero:classLinkageRef.NativePointer), &geometryShaderRef_);
                geometryShaderRef = (geometryShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.GeometryShader(geometryShaderRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a geometry shader that can write to streaming output buffers.	
        /// </summary>	
        /// <param name="shaderBytecodeRef">A pointer to the compiled shader. </param>
        /// <param name="bytecodeLength">Size of the compiled geometry shader.</param>
        /// <param name="sODeclarationRef">Pointer to a <see cref="SlimDX2.Direct3D11.StreamOutputElement"/> array. Cannot be NULL if NumEntries &gt; 0.</param>
        /// <param name="numEntries">The number of entries in the stream output declaration ( ranges from 0 to D3D11_SO_STREAM_COUNT * D3D11_SO_OUTPUT_COMPONENT_COUNT ).</param>
        /// <param name="bufferStridesRef">An array of buffer strides; each stride is the size of an element for that buffer.</param>
        /// <param name="numStrides">The number of strides (or buffers) in pBufferStrides (ranges from 0 to D3D11_SO_BUFFER_SLOT_COUNT).</param>
        /// <param name="rasterizedStream">The index number of the stream to be sent to the rasterizer stage (ranges from 0 to D3D11_SO_STREAM_COUNT - 1).  Set to D3D11_SO_NO_RASTERIZED_STREAM if no stream is to be rasterized.</param>
        /// <param name="classLinkageRef">A pointer to a class linkage interface (see <see cref="SlimDX2.Direct3D11.ClassLinkage"/>); the value can be NULL.</param>
        /// <param name="geometryShaderRef">Address of a pointer to an <see cref="SlimDX2.Direct3D11.GeometryShader"/> interface, representing the geometry shader that was created.  Set this to NULL to validate the other parameters; if validation passes, the method will return S_FALSE instead of S_OK.</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateGeometryShaderWithStreamOutput([In] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In, Buffer, Optional] const D3D11_SO_DECLARATION_ENTRY* pSODeclaration,[In] UINT NumEntries,[In, Buffer, Optional] const UINT* pBufferStrides,[In] UINT NumStrides,[In] UINT RasterizedStream,[In, Optional] ID3D11ClassLinkage* pClassLinkage,[Out, Optional] ID3D11GeometryShader** ppGeometryShader)</unmanaged>
        internal SlimDX2.Result CreateGeometryShaderWithStreamOutput(IntPtr shaderBytecodeRef, SlimDX2.Size bytecodeLength, SlimDX2.Direct3D11.StreamOutputElement[] sODeclarationRef, int numEntries, int[] bufferStridesRef, int numStrides, int rasterizedStream, SlimDX2.Direct3D11.ClassLinkage classLinkageRef, out SlimDX2.Direct3D11.GeometryShader geometryShaderRef) {
            unsafe {
                SlimDX2.Direct3D11.StreamOutputElement.__Native[] sODeclarationRef__ = new SlimDX2.Direct3D11.StreamOutputElement.__Native[sODeclarationRef.Length];
                for (int i = 0; i < sODeclarationRef.Length; i++)
                    sODeclarationRef[i].__MarshalTo(ref sODeclarationRef__[i]);				
                int[] bufferStridesRef__ = bufferStridesRef ?? new int[1];
                IntPtr geometryShaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* sODeclarationRef_ = &sODeclarationRef__[0])
                    fixed (void* bufferStridesRef_ = &bufferStridesRef__[0])
                        __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 14 * 4, (void*)shaderBytecodeRef, (void*)bytecodeLength, sODeclarationRef_, numEntries, bufferStridesRef==null?(void*)IntPtr.Zero:bufferStridesRef_, numStrides, rasterizedStream, (void*)((classLinkageRef == null)?IntPtr.Zero:classLinkageRef.NativePointer), &geometryShaderRef_);
                for (int i = 0; i < sODeclarationRef.Length; i++)
                    sODeclarationRef__[i].__MarshalFree();				
                geometryShaderRef = (geometryShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.GeometryShader(geometryShaderRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a pixel shader.	
        /// </summary>	
        /// <remarks>	
        /// After creating the pixel shader, you can set it to the device using <see cref="SlimDX2.Direct3D11.DeviceContext.PixelShaderStage.SetShader"/>.	
        /// </remarks>	
        /// <param name="shaderBytecodeRef">A pointer to the compiled shader. </param>
        /// <param name="bytecodeLength">Size of the compiled pixel shader.</param>
        /// <param name="classLinkageRef">A pointer to a class linkage interface (see <see cref="SlimDX2.Direct3D11.ClassLinkage"/>); the value can be NULL.</param>
        /// <param name="pixelShaderRef">Address of a pointer to a <see cref="SlimDX2.Direct3D11.PixelShader"/> interface. If this is NULL, all other parameters will be validated, and if all parameters pass validation this API will return S_FALSE instead of S_OK.</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreatePixelShader([In] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In, Optional] ID3D11ClassLinkage* pClassLinkage,[Out, Optional] ID3D11PixelShader** ppPixelShader)</unmanaged>
        internal SlimDX2.Result CreatePixelShader(IntPtr shaderBytecodeRef, SlimDX2.Size bytecodeLength, SlimDX2.Direct3D11.ClassLinkage classLinkageRef, out SlimDX2.Direct3D11.PixelShader pixelShaderRef) {
            unsafe {
                IntPtr pixelShaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 15 * 4, (void*)shaderBytecodeRef, (void*)bytecodeLength, (void*)((classLinkageRef == null)?IntPtr.Zero:classLinkageRef.NativePointer), &pixelShaderRef_);
                pixelShaderRef = (pixelShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.PixelShader(pixelShaderRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a {{hull shader}}.	
        /// </summary>	
        /// <param name="shaderBytecodeRef">A pointer to a compiled shader.</param>
        /// <param name="bytecodeLength">Size of the compiled shader.</param>
        /// <param name="classLinkageRef">A pointer to a class linkage interface (see <see cref="SlimDX2.Direct3D11.ClassLinkage"/>); the value can be NULL.</param>
        /// <param name="hullShaderRef">A pointer to a hull-shader interface (see <see cref="SlimDX2.Direct3D11.HullShader"/>).</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateHullShader([In] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In, Optional] ID3D11ClassLinkage* pClassLinkage,[Out, Optional] ID3D11HullShader** ppHullShader)</unmanaged>
        internal SlimDX2.Result CreateHullShader(IntPtr shaderBytecodeRef, SlimDX2.Size bytecodeLength, SlimDX2.Direct3D11.ClassLinkage classLinkageRef, out SlimDX2.Direct3D11.HullShader hullShaderRef) {
            unsafe {
                IntPtr hullShaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 16 * 4, (void*)shaderBytecodeRef, (void*)bytecodeLength, (void*)((classLinkageRef == null)?IntPtr.Zero:classLinkageRef.NativePointer), &hullShaderRef_);
                hullShaderRef = (hullShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.HullShader(hullShaderRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a {{domain shader}} .	
        /// </summary>	
        /// <param name="shaderBytecodeRef">A pointer to a compiled shader.</param>
        /// <param name="bytecodeLength">Size of the compiled shader.</param>
        /// <param name="classLinkageRef">A pointer to a class linkage interface (see <see cref="SlimDX2.Direct3D11.ClassLinkage"/>); the value can be NULL.</param>
        /// <param name="domainShaderRef">Address of a pointer to a <see cref="SlimDX2.Direct3D11.DomainShader"/> interface. If this is NULL, all other parameters will be validated, and if all parameters pass validation this API will return S_FALSE instead of S_OK.</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateDomainShader([In] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In, Optional] ID3D11ClassLinkage* pClassLinkage,[Out, Optional] ID3D11DomainShader** ppDomainShader)</unmanaged>
        internal SlimDX2.Result CreateDomainShader(IntPtr shaderBytecodeRef, SlimDX2.Size bytecodeLength, SlimDX2.Direct3D11.ClassLinkage classLinkageRef, out SlimDX2.Direct3D11.DomainShader domainShaderRef) {
            unsafe {
                IntPtr domainShaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 17 * 4, (void*)shaderBytecodeRef, (void*)bytecodeLength, (void*)((classLinkageRef == null)?IntPtr.Zero:classLinkageRef.NativePointer), &domainShaderRef_);
                domainShaderRef = (domainShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.DomainShader(domainShaderRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a {{compute shader}}.	
        /// </summary>	
        /// <remarks>	
        /// For an example, see {{How To: Create a Compute Shader}} and {{HDRToneMappingCS11 Sample}}.	
        /// </remarks>	
        /// <param name="shaderBytecodeRef">A pointer to a compiled shader.</param>
        /// <param name="bytecodeLength">Size of the compiled shader in pShaderBytecode.</param>
        /// <param name="classLinkageRef">A pointer to a <see cref="SlimDX2.Direct3D11.ClassLinkage"/>, which represents  class linkage interface; the value can be NULL.</param>
        /// <param name="computeShaderRef">Address of a pointer to an <see cref="SlimDX2.Direct3D11.ComputeShader"/> interface. If this is NULL,  all other parameters will be validated; if validation passes, CreateComputeShader returns S_FALSE instead of S_OK.</param>
        /// <returns>This method returns E_OUTOFMEMORY if there is insufficient memory to create the compute shader.   See {{Direct3D 11 Return Codes}} for other possible return values.</returns>
        /// <unmanaged>HRESULT CreateComputeShader([In] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In, Optional] ID3D11ClassLinkage* pClassLinkage,[Out, Optional] ID3D11ComputeShader** ppComputeShader)</unmanaged>
        internal SlimDX2.Result CreateComputeShader(IntPtr shaderBytecodeRef, SlimDX2.Size bytecodeLength, SlimDX2.Direct3D11.ClassLinkage classLinkageRef, out SlimDX2.Direct3D11.ComputeShader computeShaderRef) {
            unsafe {
                IntPtr computeShaderRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 18 * 4, (void*)shaderBytecodeRef, (void*)bytecodeLength, (void*)((classLinkageRef == null)?IntPtr.Zero:classLinkageRef.NativePointer), &computeShaderRef_);
                computeShaderRef = (computeShaderRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ComputeShader(computeShaderRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates class linkage libraries to enable dynamic shader linkage.	
        /// </summary>	
        /// <remarks>	
        /// The <see cref="SlimDX2.Direct3D11.ClassLinkage"/> interface returned in ppLinkage is associated with a shader by passing it as a parameter to one of the <see cref="SlimDX2.Direct3D11.Device"/> create shader methods such as <see cref="SlimDX2.Direct3D11.Device.CreatePixelShader"/>.	
        /// </remarks>	
        /// <param name="linkageRef">A pointer to a class-linkage interface pointer (see <see cref="SlimDX2.Direct3D11.ClassLinkage"/>).</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateClassLinkage([Out] ID3D11ClassLinkage** ppLinkage)</unmanaged>
        internal SlimDX2.Result CreateClassLinkage(out SlimDX2.Direct3D11.ClassLinkage linkageRef) {
            unsafe {
                IntPtr linkageRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 19 * 4, &linkageRef_);
                linkageRef = (linkageRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.ClassLinkage(linkageRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a blend-state object that encapsules blend state for the output-merger stage.	
        /// </summary>	
        /// <remarks>	
        /// An application can create up to 4096 unique blend-state objects. For each object created, the runtime checks to see if a previous object  has the same state. If such a previous object exists, the runtime will return a pointer to previous instance instead of creating a duplicate object.	
        /// </remarks>	
        /// <param name="blendStateDescRef">Pointer to a blend-state description (see <see cref="SlimDX2.Direct3D11.BlendStateDescription"/>).</param>
        /// <param name="blendStateRef">Address of a pointer to the blend-state object created (see <see cref="SlimDX2.Direct3D11.BlendState"/>).</param>
        /// <returns>This method returns E_OUTOFMEMORY if there is insufficient memory to create the blend-state object.   See {{Direct3D 11 Return Codes}} for other possible return values.</returns>
        /// <unmanaged>HRESULT CreateBlendState([In] const D3D11_BLEND_DESC* pBlendStateDesc,[Out, Optional] ID3D11BlendState** ppBlendState)</unmanaged>
        internal SlimDX2.Result CreateBlendState(ref SlimDX2.Direct3D11.BlendStateDescription blendStateDescRef, out SlimDX2.Direct3D11.BlendState blendStateRef) {
            unsafe {
                SlimDX2.Direct3D11.BlendStateDescription.__Native blendStateDescRef_ = new SlimDX2.Direct3D11.BlendStateDescription.__Native();
                blendStateDescRef.__MarshalTo(ref blendStateDescRef_);
                IntPtr blendStateRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 20 * 4, &blendStateDescRef_, &blendStateRef_);
                blendStateDescRef_.__MarshalFree();
                blendStateRef = (blendStateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.BlendState(blendStateRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a depth-stencil state object that encapsulates depth-stencil test information for the output-merger stage.	
        /// </summary>	
        /// <remarks>	
        /// 4096 unique depth-stencil state objects can be created on a device at a time.If an application attempts to create a depth-stencil-state interface with the same state as an existing interface, the same interface will be returned and the total number of unique depth-stencil state objects will stay the same.	
        /// </remarks>	
        /// <param name="depthStencilDescRef">Pointer to a depth-stencil state description (see <see cref="SlimDX2.Direct3D11.DepthStencilStateDescription"/>).</param>
        /// <param name="depthStencilStateRef">Address of a pointer to the depth-stencil state object created (see <see cref="SlimDX2.Direct3D11.DepthStencilState"/>).</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateDepthStencilState([In] const D3D11_DEPTH_STENCIL_DESC* pDepthStencilDesc,[Out, Optional] ID3D11DepthStencilState** ppDepthStencilState)</unmanaged>
        internal SlimDX2.Result CreateDepthStencilState(ref SlimDX2.Direct3D11.DepthStencilStateDescription depthStencilDescRef, out SlimDX2.Direct3D11.DepthStencilState depthStencilStateRef) {
            unsafe {
                IntPtr depthStencilStateRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* depthStencilDescRef_ = &depthStencilDescRef)
                    __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 21 * 4, depthStencilDescRef_, &depthStencilStateRef_);
                depthStencilStateRef = (depthStencilStateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.DepthStencilState(depthStencilStateRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a rasterizer state object that tells the rasterizer stage how to behave.	
        /// </summary>	
        /// <remarks>	
        /// 4096 unique rasterizer state objects can be created on a device at a time.If an application attempts to create a rasterizer-state interface with the same state as an existing interface, the same interface will be returned and the total number of unique rasterizer state objects will stay the same.	
        /// </remarks>	
        /// <param name="rasterizerDescRef">Pointer to a rasterizer state description (see <see cref="SlimDX2.Direct3D11.RasterizerStateDescription"/>).</param>
        /// <param name="rasterizerStateRef">Address of a pointer to the rasterizer state object created (see <see cref="SlimDX2.Direct3D11.RasterizerState"/>).</param>
        /// <returns>This method returns E_OUTOFMEMORY if there is insufficient memory to create the compute shader.  See {{Direct3D 11 Return Codes}} for other possible return values.</returns>
        /// <unmanaged>HRESULT CreateRasterizerState([In] const D3D11_RASTERIZER_DESC* pRasterizerDesc,[Out, Optional] ID3D11RasterizerState** ppRasterizerState)</unmanaged>
        internal SlimDX2.Result CreateRasterizerState(ref SlimDX2.Direct3D11.RasterizerStateDescription rasterizerDescRef, out SlimDX2.Direct3D11.RasterizerState rasterizerStateRef) {
            unsafe {
                IntPtr rasterizerStateRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* rasterizerDescRef_ = &rasterizerDescRef)
                    __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 22 * 4, rasterizerDescRef_, &rasterizerStateRef_);
                rasterizerStateRef = (rasterizerStateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.RasterizerState(rasterizerStateRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a sampler-state object that encapsulates sampling information for a texture.	
        /// </summary>	
        /// <remarks>	
        /// 4096 unique sampler state objects can be created on a device at a time.If an application attempts to create a sampler-state interface with the same state as an existing interface, the same interface will be returned and the total number of unique sampler state objects will stay the same.	
        /// </remarks>	
        /// <param name="samplerDescRef">Pointer to a sampler state description (see <see cref="SlimDX2.Direct3D11.SamplerStateDescription"/>).</param>
        /// <param name="samplerStateRef">Address of a pointer to the sampler state object created (see <see cref="SlimDX2.Direct3D11.SamplerState"/>).</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateSamplerState([In] const D3D11_SAMPLER_DESC* pSamplerDesc,[Out, Optional] ID3D11SamplerState** ppSamplerState)</unmanaged>
        internal SlimDX2.Result CreateSamplerState(ref SlimDX2.Direct3D11.SamplerStateDescription samplerDescRef, out SlimDX2.Direct3D11.SamplerState samplerStateRef) {
            unsafe {
                IntPtr samplerStateRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                fixed (void* samplerDescRef_ = &samplerDescRef)
                    __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 23 * 4, samplerDescRef_, &samplerStateRef_);
                samplerStateRef = (samplerStateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.SamplerState(samplerStateRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// This interface encapsulates methods for querying information from the GPU.	
        /// </summary>	
        /// <param name="queryDescRef">Pointer to a query description (see <see cref="SlimDX2.Direct3D11.QueryDescription"/>).</param>
        /// <param name="queryRef">Address of a pointer to the query object created (see <see cref="SlimDX2.Direct3D11.Query"/>).</param>
        /// <returns>This method returns E_OUTOFMEMORY if there is insufficient memory to create the compute shader.   See {{Direct3D 11 Return Codes}} for other possible return values.</returns>
        /// <unmanaged>HRESULT CreateQuery([In] const D3D11_QUERY_DESC* pQueryDesc,[Out, Optional] ID3D11Query** ppQuery)</unmanaged>
        internal SlimDX2.Result CreateQuery(SlimDX2.Direct3D11.QueryDescription queryDescRef, out SlimDX2.Direct3D11.Query queryRef) {
            unsafe {
                IntPtr queryRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 24 * 4, &queryDescRef, &queryRef_);
                queryRef = (queryRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Query(queryRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a predicate.	
        /// </summary>	
        /// <param name="predicateDescRef">Pointer to a query description where the type of query must be a D3D11_QUERY_SO_OVERFLOW_PREDICATE or D3D11_QUERY_OCCLUSION_PREDICATE (see <see cref="SlimDX2.Direct3D11.QueryDescription"/>).</param>
        /// <param name="predicateRef">Address of a pointer to a predicate (see <see cref="SlimDX2.Direct3D11.Predicate"/>).</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreatePredicate([In] const D3D11_QUERY_DESC* pPredicateDesc,[Out, Optional] ID3D11Predicate** ppPredicate)</unmanaged>
        internal SlimDX2.Result CreatePredicate(SlimDX2.Direct3D11.QueryDescription predicateDescRef, out SlimDX2.Direct3D11.Predicate predicateRef) {
            unsafe {
                IntPtr predicateRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 25 * 4, &predicateDescRef, &predicateRef_);
                predicateRef = (predicateRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Predicate(predicateRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Create a counter object for measuring GPU performance.	
        /// </summary>	
        /// <param name="counterDescRef">Pointer to a counter description (see <see cref="SlimDX2.Direct3D11.CounterDescription"/>).</param>
        /// <param name="counterRef">Address of a pointer to a counter (see <see cref="SlimDX2.Direct3D11.Counter"/>).</param>
        /// <returns>If this function succeeds, it will return S_OK. If it fails, possible return values are: S_FALSE, E_OUTOFMEMORY, DXGI_ERROR_UNSUPPORTED, DXGI_ERROR_NONEXCLUSIVE, or E_INVALIDARG.DXGI_ERROR_UNSUPPORTED is returned whenever the application requests to create a well-known counter, but the current device does not support it.DXGI_ERROR_NONEXCLUSIVE indicates that another device object is currently using the counters, so they cannot be used by this device at the moment.E_INVALIDARG is returned whenever an out-of-range well-known or device-dependent counter is requested, or when the simulataneously active counters have been exhausted.</returns>
        /// <unmanaged>HRESULT CreateCounter([In] const D3D11_COUNTER_DESC* pCounterDesc,[Out, Optional] ID3D11Counter** ppCounter)</unmanaged>
        internal SlimDX2.Result CreateCounter(SlimDX2.Direct3D11.CounterDescription counterDescRef, out SlimDX2.Direct3D11.Counter counterRef) {
            unsafe {
                IntPtr counterRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 26 * 4, &counterDescRef, &counterRef_);
                counterRef = (counterRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.Counter(counterRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Creates a deferred context for play back of command lists.	
        /// </summary>	
        /// <remarks>	
        /// A deferred context is a thread-safe context that you can use to record graphics commands on a thread other than the main rendering thread.  Using a deferred context, you can record graphics commands into a command list that is encapsulated by the <see cref="SlimDX2.Direct3D11.CommandList"/> interface.  After all scene items are recorded, you can then submit them to the main render thread for final rendering.  In this manner, you can perform rendering tasks concurrently across multiple threads and potentially improve performance in multi-core CPU scenarios.You can create multiple deferred contexts.Note If you use the <see cref="SlimDX2.Direct3D11.DeviceCreationFlags.Singlethreaded"/> value to create the device that is represented by <see cref="SlimDX2.Direct3D11.Device"/>, the CreateDeferredContext method will fail, and you will not be able to create a deferred context.For more information about deferred contexts, see {{Immediate and Deferred Rendering}}.	
        /// </remarks>	
        /// <param name="contextFlags">Reserved for future use.  Pass 0.</param>
        /// <param name="deferredContextRef">Upon completion of the method, the passed pointer to an <see cref="SlimDX2.Direct3D11.DeviceContext"/> interface pointer is initialized.</param>
        /// <returns>Returns S_OK if successful; otherwise, returns one of the following:Returns DXGI_ERROR_DEVICE_REMOVED if the video card has been physically removed from the system, or a driver upgrade for the video card has occurred. If this error occurs, you should destroy and recreate the device.Returns DXGI_ERROR_INVALID_CALL if the CreateDeferredContext method cannot be called from the current context. For example, if the device was created with the <see cref="SlimDX2.Direct3D11.DeviceCreationFlags.Singlethreaded"/> value,  CreateDeferredContext returns DXGI_ERROR_INVALID_CALL.Returns E_INVALIDARG if the ContextFlags parameter is invalid.Returns E_OUTOFMEMORY if the application has exhausted available memory.</returns>
        /// <unmanaged>HRESULT CreateDeferredContext([None] UINT ContextFlags,[Out, Optional] ID3D11DeviceContext** ppDeferredContext)</unmanaged>
        internal SlimDX2.Result CreateDeferredContext(int contextFlags, out SlimDX2.Direct3D11.DeviceContext deferredContextRef) {
            unsafe {
                IntPtr deferredContextRef_ = IntPtr.Zero;
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 27 * 4, contextFlags, &deferredContextRef_);
                deferredContextRef = (deferredContextRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.DeviceContext(deferredContextRef_);	
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Give a device access to a shared resource created on a different device.	
        /// </summary>	
        /// <remarks>	
        /// The REFIID, or GUID, of the interface to the resource can be obtained by using the __uuidof() macro. For example, __uuidof(ID3D11Buffer) will get the GUID of the interface to a buffer resource.The unique handle of the resource is obtained differently depending on the type of device that originally created the resource.To share a resource between two Direct3D 11 devices the resource must have been created with the  <see cref="SlimDX2.Direct3D11.ResourceOptionFlags.Shared"/> flag, if it was created using the ID3D11Device interface.  If it was created using a DXGI device interface, then the resource is always shared.The REFIID, or GUID, of the interface to the resource can be obtained by using the __uuidof() macro.  For example, __uuidof(ID3D11Buffer) will get the GUID of the interface to a buffer resource.When sharing a resource between two Direct3D 10/11 devices the unique handle of the resource can be obtained by querying the resource for the <see cref="SlimDX2.DXGI.Resource"/> interface and then calling {{GetSharedHandle}}.	
        /// <code> IDXGIResource* pOtherResource(NULL);	
        /// hr = pOtherDeviceResource-&gt;QueryInterface( __uuidof(IDXGIResource), (void**)&amp;pOtherResource );	
        /// HANDLE sharedHandle;	
        /// pOtherResource-&gt;GetSharedHandle(&amp;sharedHandle); </code>	
        /// 	
        /// The only resources that can be shared are 2D non-mipmapped textures.To share a resource between a Direct3D 9 device and a Direct3D 11 device the texture must have been created using  the pSharedHandle argument of {{CreateTexture}}.   The shared Direct3D 9 handle is then passed to OpenSharedResource in the hResource argument.The following code illustrates the method calls involved.	
        /// <code> sharedHandle = NULL; // must be set to NULL to create, can use a valid handle here to open in D3D9 	
        /// pDevice9-&gt;CreateTexture(..., pTex2D_9, &amp;sharedHandle); 	
        /// ... 	
        /// pDevice11-&gt;OpenSharedResource(sharedHandle, __uuidof(ID3D11Resource), (void**)(&amp;tempResource11)); 	
        /// tempResource11-&gt;QueryInterface(__uuidof(ID3D11Texture2D), (void**)(&amp;pTex2D_11)); 	
        /// tempResource11-&gt;Release(); 	
        /// // now use pTex2D_11 with pDevice11    </code>	
        /// 	
        /// Textures being shared from D3D9 to D3D11 have the following restrictions.Textures must be 2DOnly 1 mip level is allowedTexture must have default usageTexture must be write onlyMSAA textures are not allowedBind flags must have SHADER_RESOURCE and RENDER_TARGET setOnly R10G10B10A2_UNORM, R16G16B16A16_FLOAT and R8G8B8A8_UNORM formats are allowedIf a shared texture is updated on one device <see cref="SlimDX2.Direct3D11.DeviceContext.Flush"/> must be called on that device.	
        /// </remarks>	
        /// <param name="hResource">A resource handle. See remarks.</param>
        /// <param name="returnedInterface">The globally unique identifier (GUID) for the resource interface. See remarks.</param>
        /// <param name="resourceRef">Address of a pointer to the resource we are gaining access to.</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT OpenSharedResource([In] HANDLE hResource,[In] REFIID ReturnedInterface,[Out, Optional] void** ppResource)</unmanaged>
        public SlimDX2.Result OpenSharedResource(IntPtr hResource, Guid returnedInterface, out IntPtr resourceRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* resourceRef_ = &resourceRef)
                    __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 28 * 4, (void*)hResource, &returnedInterface, resourceRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the support of a given format on the installed video device.	
        /// </summary>	
        /// <param name="format">A <see cref="SlimDX2.DXGI.Format"/> enumeration that describes a format for which to check for support.</param>
        /// <param name="formatSupportRef">A bitfield of <see cref="SlimDX2.Direct3D11.FormatSupport"/> enumeration values describing how the specified format is supported on the installed device.  The values are ORed together.</param>
        /// <returns>Returns S_OK if successful; otherwise, returns E_INVALIDARG if the Format parameter is NULL, or returns E_FAIL if the  described format does not exist.</returns>
        /// <unmanaged>HRESULT CheckFormatSupport([In] DXGI_FORMAT Format,[Out] UINT* pFormatSupport)</unmanaged>
        public SlimDX2.Result CheckFormatSupport(SlimDX2.DXGI.Format format, out int formatSupportRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* formatSupportRef_ = &formatSupportRef)
                    __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 29 * 4, unchecked((int)format), formatSupportRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the number of quality levels available during multisampling.	
        /// </summary>	
        /// <remarks>	
        /// When multisampling a texture, the number of quality levels available for an adapter is dependent on the texture format used and the number of  samples requested. The maximum number of quality levels is defined by D3D11_MAX_MULTISAMPLE_SAMPLE_COUNT in D3D11.h. If this method returns 0, the format  and sample count combination is not supported for the installed adapter.Furthermore, the definition of a quality level is up to each hardware vendor to define, however no facility is provided by Direct3D to help discover  this information.Note that FEATURE_LEVEL_10_1 devices are required to support 4x MSAA for all render targets except R32G32B32A32 and R32G32B32. FEATURE_LEVEL_11_0 devices are required to support 4x MSAA for all render target formats, and 8x MSAA for all render target formats  except R32G32B32A32 formats.	
        /// </remarks>	
        /// <param name="format">The texture format. See <see cref="SlimDX2.DXGI.Format"/>.</param>
        /// <param name="sampleCount">The number of samples during multisampling.</param>
        /// <param name="numQualityLevelsRef">Number of quality levels supported by the adapter. See remarks.</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CheckMultisampleQualityLevels([In] DXGI_FORMAT Format,[In] UINT SampleCount,[Out] UINT* pNumQualityLevels)</unmanaged>
        public SlimDX2.Result CheckMultisampleQualityLevels(SlimDX2.DXGI.Format format, int sampleCount, out int numQualityLevelsRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* numQualityLevelsRef_ = &numQualityLevelsRef)
                    __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 30 * 4, unchecked((int)format), sampleCount, numQualityLevelsRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get a counter's information.	
        /// </summary>	
        /// <param name="counterInfoRef">Pointer to counter information (see <see cref="SlimDX2.Direct3D11.CounterInformation"/>).</param>
        /// <unmanaged>void CheckCounterInfo([Out] D3D11_COUNTER_INFO* pCounterInfo)</unmanaged>
        public void CheckCounterInfo(out SlimDX2.Direct3D11.CounterInformation counterInfoRef) {
            unsafe {
                counterInfoRef = new SlimDX2.Direct3D11.CounterInformation();
                fixed (void* counterInfoRef_ = &counterInfoRef)
                    SlimDX2.Interop.CalliVoid(_nativePointer, 31 * 4, counterInfoRef_);
            }
        }
        
        /// <summary>	
        ///  Get the type, name, units of measure, and a description of an existing counter.	
        /// </summary>	
        /// <param name="descRef"> Pointer to a counter description (see <see cref="SlimDX2.Direct3D11.CounterDescription"/>). Specifies which counter information is to be retrieved about. </param>
        /// <param name="typeRef"> Pointer to the data type of a counter (see <see cref="SlimDX2.Direct3D11.CounterType"/>). Specifies the data type of the counter being retrieved. </param>
        /// <param name="activeCountersRef"> Pointer to the number of hardware counters that are needed for this counter type to be created. All instances of the same counter type use the same hardware counters. </param>
        /// <param name="szName"> String to be filled with a brief name for the counter. May be NULL if the application is not interested in the name of the counter. </param>
        /// <param name="nameLengthRef"> Length of the string returned to szName. Can be NULL. </param>
        /// <param name="szUnits"> Name of the units a counter measures, provided the memory the pointer points to has enough room to hold the string. Can be NULL. The returned string will always be in English. </param>
        /// <param name="unitsLengthRef"> Length of the string returned to szUnits. Can be NULL. </param>
        /// <param name="szDescription"> A description of the counter, provided the memory the pointer points to has enough room to hold the string. Can be NULL. The returned string will always be in English. </param>
        /// <param name="descriptionLengthRef"> Length of the string returned to szDescription. Can be NULL. </param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT CheckCounter([In] const D3D11_COUNTER_DESC* pDesc,[Out] D3D11_COUNTER_TYPE* pType,[Out] UINT* pActiveCounters,[Out, Buffer, Optional] LPSTR szName,[InOut, Optional] UINT* pNameLength,[Out, Buffer, Optional] LPSTR szUnits,[InOut, Optional] UINT* pUnitsLength,[Out, Buffer, Optional] LPSTR szDescription,[InOut, Optional] UINT* pDescriptionLength)</unmanaged>
        public SlimDX2.Result CheckCounter(SlimDX2.Direct3D11.CounterDescription descRef, out SlimDX2.Direct3D11.CounterType typeRef, out int activeCountersRef, IntPtr szName, ref int nameLengthRef, IntPtr szUnits, ref int unitsLengthRef, IntPtr szDescription, ref int descriptionLengthRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* typeRef_ = &typeRef)
                    fixed (void* activeCountersRef_ = &activeCountersRef)
                        fixed (void* nameLengthRef_ = &nameLengthRef)
                            fixed (void* unitsLengthRef_ = &unitsLengthRef)
                                fixed (void* descriptionLengthRef_ = &descriptionLengthRef)
                                    __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 32 * 4, &descRef, typeRef_, activeCountersRef_, (void*)szName, nameLengthRef_, (void*)szUnits, unitsLengthRef_, (void*)szDescription, descriptionLengthRef_);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets information about the features that are supported by the current graphics driver.	
        /// </summary>	
        /// <remarks>	
        /// To query for multi-threading support, pass the D3D11_FEATURE_THREADING value to the Feature parameter, pass  the <see cref="SlimDX2.Direct3D11.FeatureDataThreading"/> structure to the  pFeatureSupportData parameter, and pass the size of  the D3D11_FEATURE_DATA_THREADING structure to the FeatureSupportDataSize parameter.Calling CheckFeatureSupport with Feature set to D3D11_FEATURE_FORMAT_SUPPORT causes the method to return the same information that would be returned  by <see cref="SlimDX2.Direct3D11.Device.CheckFormatSupport"/>.	
        /// </remarks>	
        /// <param name="feature">A member of the <see cref="SlimDX2.Direct3D11.Feature"/> enumerated type that describes which feature to query for support.</param>
        /// <param name="featureSupportDataRef">Upon completion of the method, the passed structure is filled with data that describes the feature support.</param>
        /// <param name="featureSupportDataSize">The size of the structure passed to the pFeatureSupportData parameter.</param>
        /// <returns>Returns S_OK if successful; otherwise, returns E_INVALIDARG if an unsupported data type is passed to the pFeatureSupportData parameter  or a size mismatch is detected for the FeatureSupportDataSize parameter.</returns>
        /// <unmanaged>HRESULT CheckFeatureSupport([None] D3D11_FEATURE Feature,[Out, Buffer] void* pFeatureSupportData,[None] UINT FeatureSupportDataSize)</unmanaged>
        public SlimDX2.Result CheckFeatureSupport(SlimDX2.Direct3D11.Feature feature, IntPtr featureSupportDataRef, int featureSupportDataSize) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 33 * 4, unchecked((int)feature), (void*)featureSupportDataRef, featureSupportDataSize);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get application-defined data from a device.	
        /// </summary>	
        /// <param name="guid">Guid associated with the data.</param>
        /// <param name="dataSizeRef">A pointer to a variable that on input contains the size, in bytes, of the buffer that pData points to, and on output contains the size, in bytes, of the amount of data that GetPrivateData retrieved.</param>
        /// <param name="dataRef">A pointer to a buffer that GetPrivateData fills with data from the device if pDataSize points to a value that specifies a buffer large enough to hold the data.</param>
        /// <returns>This method returns one of the codes described in the topic {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetPrivateData([In] REFGUID guid,[InOut] UINT* pDataSize,[Out, Buffer, Optional] void* pData)</unmanaged>
        public SlimDX2.Result GetPrivateData(Guid guid, ref int dataSizeRef, IntPtr dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                fixed (void* dataSizeRef_ = &dataSizeRef)
                    __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 34 * 4, &guid, dataSizeRef_, (void*)dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Set data to a device and associate that data with a guid.	
        /// </summary>	
        /// <remarks>	
        /// The data stored in the device with this method can be retrieved with <see cref="SlimDX2.Direct3D11.Device.GetPrivateData"/>.The data and guid set with this method will typically be application-defined.If an application uses this method to change the device type using GUID_DeviceType, results are undefined. However, GUID_DeviceType can be used to retrieve the device type using <see cref="SlimDX2.Direct3D11.Device.GetPrivateData"/>.The {{debug layer}} reports memory leaks by outputting a list of object interface pointers along with their friendly names. The default friendly name is "&lt;unnamed&gt;". You can set the friendly name so that you can determine if the corresponding object interface pointer caused the leak. To set the friendly name, use the SetPrivateData method and the WKPDID_D3DDebugObjectName GUID that is in D3Dcommon.h. For example, to give pContext a friendly name of My name, use the following code:	
        /// <code> static const char c_szName[] = "My name";	
        /// hr = pContext-&gt;SetPrivateData( WKPDID_D3DDebugObjectName, sizeof( c_szName ) - 1, c_szName ); </code>	
        /// 	
        /// </remarks>	
        /// <param name="guid">Guid associated with the data.</param>
        /// <param name="dataSize">Size of the data.</param>
        /// <param name="dataRef">Pointer to the data to be stored with this device. If pData is NULL, DataSize must also be 0, and any data previously associated with the guid will be destroyed.</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetPrivateData([In] REFGUID guid,[In] UINT DataSize,[In, Buffer, Optional] const void* pData)</unmanaged>
        public SlimDX2.Result SetPrivateData(Guid guid, int dataSize, IntPtr dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 35 * 4, &guid, dataSize, (void*)dataRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Associate an IUnknown-derived interface with this device child and associate that interface with an application-defined guid.	
        /// </summary>	
        /// <param name="guid">Guid associated with the interface.</param>
        /// <param name="dataRef">Pointer to an IUnknown-derived interface to be associated with the device child.</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetPrivateDataInterface([In] REFGUID guid,[In, Optional] const IUnknown* pData)</unmanaged>
        public SlimDX2.Result SetPrivateDataInterface(Guid guid, SlimDX2.ComObject dataRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 36 * 4, &guid, (void*)((dataRef == null)?IntPtr.Zero:dataRef.NativePointer));
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the feature level of the hardware device.	
        /// </summary>	
        /// <remarks>	
        /// {{Feature levels}} determine the capabilities of your device.	
        /// </remarks>	
        /// <returns>A member of the <see cref="SlimDX2.Direct3D.FeatureLevel"/> enumerated type that describes the feature level of the hardware device.</returns>
        /// <unmanaged>D3D_FEATURE_LEVEL GetFeatureLevel()</unmanaged>
        internal SlimDX2.Direct3D.FeatureLevel GetFeatureLevel() {
            unsafe {
                SlimDX2.Direct3D.FeatureLevel __result__;
                __result__= (SlimDX2.Direct3D.FeatureLevel)SlimDX2.Interop.CalliInt(_nativePointer, 37 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the flags used during the call to create the device with <see cref="SlimDX2.Direct3D11.D3D11.CreateDevice"/>.	
        /// </summary>	
        /// <returns>A bitfield containing the flags used to create the device. See <see cref="SlimDX2.Direct3D11.DeviceCreationFlags"/>.</returns>
        /// <unmanaged>UINT GetCreationFlags()</unmanaged>
        internal int GetCreationFlags() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Interop.CalliInt(_nativePointer, 38 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the reason why the device was removed.	
        /// </summary>	
        /// <returns>Possible return values include:  DXGI_ERROR_DEVICE_HUNGDXGI_ERROR_DEVICE_REMOVEDDXGI_ERROR_DEVICE_RESETDXGI_ERROR_DRIVER_INTERNAL_ERRORDXGI_ERROR_INVALID_CALLS_OKFor more detail on these return codes, see <see cref="SlimDX2.DXGI.DXGIError"/>.</returns>
        /// <unmanaged>HRESULT GetDeviceRemovedReason()</unmanaged>
        internal SlimDX2.Result GetDeviceRemovedReason() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 39 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets an immediate context which can record command lists.	
        /// </summary>	
        /// <remarks>	
        /// The GetImmediateContext method returns an <see cref="SlimDX2.Direct3D11.DeviceContext"/> object that represents an immediate context which is used to perform rendering that you want immediately submitted to a device. For most applications, an immediate context is the primary object that is used to draw your scene.	
        /// </remarks>	
        /// <param name="immediateContextRef">Upon completion of the method, the passed pointer to an <see cref="SlimDX2.Direct3D11.DeviceContext"/> interface pointer is initialized.</param>
        /// <unmanaged>void GetImmediateContext([Out] ID3D11DeviceContext** ppImmediateContext)</unmanaged>
        internal void GetImmediateContext(out SlimDX2.Direct3D11.DeviceContext immediateContextRef) {
            unsafe {
                IntPtr immediateContextRef_ = IntPtr.Zero;
                SlimDX2.Interop.CalliVoid(_nativePointer, 40 * 4, &immediateContextRef_);
                immediateContextRef = (immediateContextRef_ == IntPtr.Zero)?null:new SlimDX2.Direct3D11.DeviceContext(immediateContextRef_);	
            }
        }
        
        /// <summary>	
        /// Get the exception-mode flags.	
        /// </summary>	
        /// <remarks>	
        /// Set an exception-mode flag to elevate an error condition to a non-continuable exception. Whenever an error occurs, a Direct3D device enters the DEVICEREMOVED state and if the appropriate exception flag has been set, an exception is raised. A raised exception is designed to terminate an application. Before termination, the last chance an application has to persist data is by using an UnhandledExceptionFilter (see {{Structured Exception Handling}}). In general, UnhandledExceptionFilters are leveraged to try to persist data when an application is crashing (to disk, for example). Any code that executes during an UnhandledExceptionFilter is not guaranteed to reliably execute (due to possible process corruption). Any data that the UnhandledExceptionFilter manages to persist, before the UnhandledExceptionFilter crashes again, should be treated as suspect, and therefore inspected by a new, non-corrupted process to see if it is usable.	
        /// </remarks>	
        /// <param name="raiseFlags">A value that contains one or more exception flags; each flag specifies a condition which will cause an exception to be raised. The flags are listed in <see cref="SlimDX2.Direct3D11.RaiseFlags"/>. A default value of 0 means there are no flags.</param>
        /// <returns>This method returns one of the following {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT SetExceptionMode([None] UINT RaiseFlags)</unmanaged>
        internal SlimDX2.Result SetExceptionMode(int raiseFlags) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 41 * 4, raiseFlags);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Get the exception-mode flags.	
        /// </summary>	
        /// <remarks>	
        /// An exception-mode flag is used to elevate an error condition to a non-continuable exception. 	
        /// </remarks>	
        /// <returns>A value that contains one or more exception flags; each flag specifies a condition which will cause an exception to be raised. The flags are listed in <see cref="SlimDX2.Direct3D11.RaiseFlags"/>. A default value of 0 means there are no flags.</returns>
        /// <unmanaged>UINT GetExceptionMode()</unmanaged>
        internal int GetExceptionMode() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Interop.CalliInt(_nativePointer, 42 * 4);
                return __result__;
            }
        }
    }
    
    /// <summary>	
    /// Data loading object used by <see cref="SlimDX2.Direct3D11.ThreadPump"/> for loading data asynchronously.	
    /// </summary>	
    /// <unmanaged>ID3DX11DataLoader</unmanaged>
    public abstract partial class DataLoader : SlimDX2.CppObject {
        
        
        /// <summary>	
        /// Loads data from a disk.	
        /// </summary>	
        /// <remarks>	
        /// This method is used by an <see cref="SlimDX2.Direct3D11.ThreadPump"/>.	
        /// </remarks>	
        /// <returns>The return value is one of the values listed in {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT Load()</unmanaged>
        public abstract SlimDX2.Result Load();
        
        /// <summary>	
        /// Decompresses encoded data.	
        /// </summary>	
        /// <remarks>	
        /// Use this method to load resources from file systems, such as ZIP files. When loading from an uncompressed resource, the decompression stage does not have to do any work.<see cref="SlimDX2.Direct3D11.DataLoader"/> can be inherited and its members redefined to support custom file formats.	
        /// </remarks>	
        /// <param name="dataRef">Pointer to the raw data to decompress.</param>
        /// <param name="cBytesRef">The size of the data pointed to by ppData.</param>
        /// <returns>The return value is one of the values listed in {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT Decompress([None] void** ppData,[None] SIZE_T* pcBytes)</unmanaged>
        public abstract SlimDX2.Result Decompress(IntPtr dataRef, SlimDX2.Size cBytesRef);
        
        /// <summary>	
        /// Destroys the loader after a work item completes.	
        /// </summary>	
        /// <remarks>	
        /// This method is used by an <see cref="SlimDX2.Direct3D11.ThreadPump"/>.	
        /// </remarks>	
        /// <returns>The return value is one of the values listed in {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT Destroy()</unmanaged>
        public abstract SlimDX2.Result Destroy();
    }
    
    /// <summary>	
    /// Data processing object used by <see cref="SlimDX2.Direct3D11.ThreadPump"/> for loading data asynchronously.	
    /// </summary>	
    /// <unmanaged>ID3DX11DataProcessor</unmanaged>
    public abstract partial class DataProcessor : SlimDX2.CppObject {
        
        
        /// <summary>	
        /// Processes data.	
        /// </summary>	
        /// <remarks>	
        /// This method is used by an <see cref="SlimDX2.Direct3D11.ThreadPump"/>.	
        /// </remarks>	
        /// <param name="dataRef">Pointer to the data to be processed.</param>
        /// <param name="cBytes">Size of the data to be processed.</param>
        /// <returns>The return value is one of the values listed in {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT Process([None] void* pData,[None] SIZE_T cBytes)</unmanaged>
        public abstract SlimDX2.Result Process(IntPtr dataRef, SlimDX2.Size cBytes);
        
        /// <summary>	
        /// Creates a device object.	
        /// </summary>	
        /// <remarks>	
        /// This method is used by an <see cref="SlimDX2.Direct3D11.ThreadPump"/>.	
        /// </remarks>	
        /// <param name="dataObjectRef">Address of a pointer to the created device object.</param>
        /// <returns>The return value is one of the values listed in {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT CreateDeviceObject([None] void** ppDataObject)</unmanaged>
        public abstract SlimDX2.Result CreateDeviceObject(IntPtr dataObjectRef);
        
        /// <summary>	
        /// Destroys the processor after a work item completes.	
        /// </summary>	
        /// <remarks>	
        /// This method is used by an <see cref="SlimDX2.Direct3D11.ThreadPump"/>.	
        /// </remarks>	
        /// <returns>The return value is one of the values listed in {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT Destroy()</unmanaged>
        public abstract SlimDX2.Result Destroy();
    }
    
    /// <summary>	
    /// A thread pump executes tasks asynchronously. It is created by calling {{D3DX11CreateThreadPump}}. There are several APIs that take an optional thread pump as a parameter, such as {{D3DX11CreateTextureFromFile}} and {{D3DX11CompileFromFile}}; if you pass a thread pump interface into these APIs, the functions will execute asynchronously on a separate thread. Particularly on multiprocessor machines, a thread pump can load resources and process data without a noticeable decrease in performance.	
    /// </summary>	
    /// <unmanaged>ID3DX11ThreadPump</unmanaged>
    [Guid("c93fecfa-6967-478a-abbc-402d90621fcb")]
    public partial class ThreadPump : SlimDX2.ComObject {

        public ThreadPump(IntPtr basePtr) : base(basePtr) {
        }
        
        
        /// <summary>	
        /// Gets the number of work items in the thread pump.	
        /// </summary>	
        /// <unmanaged>UINT GetWorkItemCount()</unmanaged>
        public int WorkItemCount {
                get { return GetWorkItemCount(); }
        }
        
        /// <summary>	
        /// Adds a work item to the thread pump.	
        /// </summary>	
        /// <param name="dataLoaderRef">The loader that the thread pump will use when a work item requires data to be loaded.</param>
        /// <param name="dataProcessorRef">The processor that the thread pump will use when a work item requires data to be processed.</param>
        /// <param name="hResultRef">A pointer to the return value. May be NULL.</param>
        /// <param name="deviceObjectRef">The device that uses the object.</param>
        /// <returns>The return value is one of the values listed in {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT AddWorkItem([None] ID3DX11DataLoader* pDataLoader,[None] ID3DX11DataProcessor* pDataProcessor,[None] HRESULT* pHResult,[None] void** ppDeviceObject)</unmanaged>
        public SlimDX2.Result AddWorkItem(SlimDX2.Direct3D11.DataLoader dataLoaderRef, SlimDX2.Direct3D11.DataProcessor dataProcessorRef, int hResultRef, IntPtr deviceObjectRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 3 * 4, (void*)((dataLoaderRef == null)?IntPtr.Zero:dataLoaderRef.NativePointer), (void*)((dataProcessorRef == null)?IntPtr.Zero:dataProcessorRef.NativePointer), &hResultRef, (void*)deviceObjectRef);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of work items in the thread pump.	
        /// </summary>	
        /// <returns>The number of work items queued in the thread pump.</returns>
        /// <unmanaged>UINT GetWorkItemCount()</unmanaged>
        internal int GetWorkItemCount() {
            unsafe {
                int __result__;
                __result__= (int)SlimDX2.Interop.CalliInt(_nativePointer, 4 * 4);
                return __result__;
            }
        }
        
        /// <summary>	
        /// Waits for all work items in the thread pump to finish.	
        /// </summary>	
        /// <returns>The return value is one of the values listed in {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT WaitForAllItems()</unmanaged>
        public SlimDX2.Result WaitForAllItems() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 5 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Sets work items to the device after they have finished loading and processing.	
        /// </summary>	
        /// <remarks>	
        /// When the thread pump has finished loading and processing a resource or shader, it will hold it in a queue until this API is called, at which point the processed items will be set to the device. This is useful for controlling the amount of processing that is spent on binding resources to the device for each frame.As an example of how one might use this API, say you are nearing the end of one level in your game and you want to begin preloading the textures, shaders, and other resources for the next level. The thread pump will begin loading, decompressing, and processing the resources and shaders on a separate thread until they are ready to be set to the device, at which point it will leave them in a queue. One may not want to set all the resources and shaders to the device at once because this may cause a noticeable temporary slow down in the game's performance. So, this API could be called once per frame so that only a small number work items would be set to the device on each frame, thereby spreading the work load of binding resources to the device over several frames.	
        /// </remarks>	
        /// <param name="iWorkItemCount">The number of work items to set to the device.</param>
        /// <returns>The return value is one of the values listed in {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT ProcessDeviceWorkItems([None] UINT iWorkItemCount)</unmanaged>
        public SlimDX2.Result ProcessDeviceWorkItems(int iWorkItemCount) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 6 * 4, iWorkItemCount);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Clears all work items from the thread pump.	
        /// </summary>	
        /// <returns>The return value is one of the values listed in {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT PurgeAllItems()</unmanaged>
        public SlimDX2.Result PurgeAllItems() {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 7 * 4);
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// Gets the number of items in each of the three queues inside the thread pump.	
        /// </summary>	
        /// <param name="ioQueueRef">Number of items in the I/O queue.</param>
        /// <param name="processQueueRef">Number of items in the process queue.</param>
        /// <param name="deviceQueueRef">Number of items in the device queue.</param>
        /// <returns>The return value is one of the values listed in {{Direct3D 11 Return Codes}}.</returns>
        /// <unmanaged>HRESULT GetQueueStatus([None] UINT* pIoQueue,[None] UINT* pProcessQueue,[None] UINT* pDeviceQueue)</unmanaged>
        public SlimDX2.Result GetQueueStatus(int ioQueueRef, int processQueueRef, int deviceQueueRef) {
            unsafe {
                SlimDX2.Result __result__;
                __result__= (SlimDX2.Result)SlimDX2.Interop.CalliInt(_nativePointer, 8 * 4, &ioQueueRef, &processQueueRef, &deviceQueueRef);
                __result__.CheckError();
                return __result__;
            }
        }
    }
}
